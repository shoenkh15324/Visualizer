
visualizer_fw.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00023e3c  080001a0  080001a0  000011a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00015650  08024000  08024000  00025000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08039650  08039650  0003b36c  2**0
                  CONTENTS
  4 .ARM          00000008  08039650  08039650  0003a650  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08039658  08039658  0003b36c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08039658  08039658  0003a658  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0803965c  0803965c  0003a65c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000036c  20000000  08039660  0003b000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00011f8c  20000380  080399cc  0003b380  2**6
                  ALLOC
 10 ._user_heap_stack 00000604  2001230c  080399cc  0003c30c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0003b36c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00044039  00000000  00000000  0003b39c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000b516  00000000  00000000  0007f3d5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00002db0  00000000  00000000  0008a8f0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00002bab  00000000  00000000  0008d6a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00026d3d  00000000  00000000  0009024b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0004ecb9  00000000  00000000  000b6f88  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000a840c  00000000  00000000  00105c41  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      000000b1  00000000  00000000  001ae04d  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000c884  00000000  00000000  001ae100  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000081  00000000  00000000  001ba984  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_loclists 0000d139  00000000  00000000  001baa05  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_loc    00002928  00000000  00000000  001c7b3e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_ranges 000000d0  00000000  00000000  001ca466  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	@ (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	@ (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	@ (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000380 	.word	0x20000380
 80001bc:	00000000 	.word	0x00000000
 80001c0:	08023fc4 	.word	0x08023fc4

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	@ (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	@ (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	@ (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000384 	.word	0x20000384
 80001dc:	08023fc4 	.word	0x08023fc4

080001e0 <arm_bitreversal_32>:
 80001e0:	1c4b      	adds	r3, r1, #1
 80001e2:	2b01      	cmp	r3, #1
 80001e4:	bf98      	it	ls
 80001e6:	4770      	bxls	lr
 80001e8:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 80001ec:	1c91      	adds	r1, r2, #2
 80001ee:	089b      	lsrs	r3, r3, #2

080001f0 <arm_bitreversal_32_0>:
 80001f0:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 80001f4:	f8b1 9002 	ldrh.w	r9, [r1, #2]
 80001f8:	880a      	ldrh	r2, [r1, #0]
 80001fa:	f831 cc02 	ldrh.w	ip, [r1, #-2]
 80001fe:	4480      	add	r8, r0
 8000200:	4481      	add	r9, r0
 8000202:	4402      	add	r2, r0
 8000204:	4484      	add	ip, r0
 8000206:	f8d9 7000 	ldr.w	r7, [r9]
 800020a:	f8d8 6000 	ldr.w	r6, [r8]
 800020e:	6815      	ldr	r5, [r2, #0]
 8000210:	f8dc 4000 	ldr.w	r4, [ip]
 8000214:	f8c9 6000 	str.w	r6, [r9]
 8000218:	f8c8 7000 	str.w	r7, [r8]
 800021c:	f8cc 5000 	str.w	r5, [ip]
 8000220:	6014      	str	r4, [r2, #0]
 8000222:	f8d9 7004 	ldr.w	r7, [r9, #4]
 8000226:	f8d8 6004 	ldr.w	r6, [r8, #4]
 800022a:	6855      	ldr	r5, [r2, #4]
 800022c:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8000230:	f8c9 6004 	str.w	r6, [r9, #4]
 8000234:	f8c8 7004 	str.w	r7, [r8, #4]
 8000238:	f8cc 5004 	str.w	r5, [ip, #4]
 800023c:	6054      	str	r4, [r2, #4]
 800023e:	3108      	adds	r1, #8
 8000240:	3b01      	subs	r3, #1
 8000242:	d1d5      	bne.n	80001f0 <arm_bitreversal_32_0>
 8000244:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 8000248:	4770      	bx	lr

0800024a <arm_bitreversal_16>:
 800024a:	1c4b      	adds	r3, r1, #1
 800024c:	2b01      	cmp	r3, #1
 800024e:	bf98      	it	ls
 8000250:	4770      	bxls	lr
 8000252:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
 8000256:	1c91      	adds	r1, r2, #2
 8000258:	089b      	lsrs	r3, r3, #2

0800025a <arm_bitreversal_16_0>:
 800025a:	f8b1 8004 	ldrh.w	r8, [r1, #4]
 800025e:	f8b1 9002 	ldrh.w	r9, [r1, #2]
 8000262:	880a      	ldrh	r2, [r1, #0]
 8000264:	f831 cc02 	ldrh.w	ip, [r1, #-2]
 8000268:	eb00 0858 	add.w	r8, r0, r8, lsr #1
 800026c:	eb00 0959 	add.w	r9, r0, r9, lsr #1
 8000270:	eb00 0252 	add.w	r2, r0, r2, lsr #1
 8000274:	eb00 0c5c 	add.w	ip, r0, ip, lsr #1
 8000278:	f8d9 7000 	ldr.w	r7, [r9]
 800027c:	f8d8 6000 	ldr.w	r6, [r8]
 8000280:	6815      	ldr	r5, [r2, #0]
 8000282:	f8dc 4000 	ldr.w	r4, [ip]
 8000286:	f8c9 6000 	str.w	r6, [r9]
 800028a:	f8c8 7000 	str.w	r7, [r8]
 800028e:	f8cc 5000 	str.w	r5, [ip]
 8000292:	6014      	str	r4, [r2, #0]
 8000294:	3108      	adds	r1, #8
 8000296:	3b01      	subs	r3, #1
 8000298:	d1df      	bne.n	800025a <arm_bitreversal_16_0>
 800029a:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
 800029e:	4770      	bx	lr

080002a0 <strcmp>:
 80002a0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80002a4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80002a8:	2a01      	cmp	r2, #1
 80002aa:	bf28      	it	cs
 80002ac:	429a      	cmpcs	r2, r3
 80002ae:	d0f7      	beq.n	80002a0 <strcmp>
 80002b0:	1ad0      	subs	r0, r2, r3
 80002b2:	4770      	bx	lr
	...

080002c0 <memchr>:
 80002c0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80002c4:	2a10      	cmp	r2, #16
 80002c6:	db2b      	blt.n	8000320 <memchr+0x60>
 80002c8:	f010 0f07 	tst.w	r0, #7
 80002cc:	d008      	beq.n	80002e0 <memchr+0x20>
 80002ce:	f810 3b01 	ldrb.w	r3, [r0], #1
 80002d2:	3a01      	subs	r2, #1
 80002d4:	428b      	cmp	r3, r1
 80002d6:	d02d      	beq.n	8000334 <memchr+0x74>
 80002d8:	f010 0f07 	tst.w	r0, #7
 80002dc:	b342      	cbz	r2, 8000330 <memchr+0x70>
 80002de:	d1f6      	bne.n	80002ce <memchr+0xe>
 80002e0:	b4f0      	push	{r4, r5, r6, r7}
 80002e2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 80002e6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 80002ea:	f022 0407 	bic.w	r4, r2, #7
 80002ee:	f07f 0700 	mvns.w	r7, #0
 80002f2:	2300      	movs	r3, #0
 80002f4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 80002f8:	3c08      	subs	r4, #8
 80002fa:	ea85 0501 	eor.w	r5, r5, r1
 80002fe:	ea86 0601 	eor.w	r6, r6, r1
 8000302:	fa85 f547 	uadd8	r5, r5, r7
 8000306:	faa3 f587 	sel	r5, r3, r7
 800030a:	fa86 f647 	uadd8	r6, r6, r7
 800030e:	faa5 f687 	sel	r6, r5, r7
 8000312:	b98e      	cbnz	r6, 8000338 <memchr+0x78>
 8000314:	d1ee      	bne.n	80002f4 <memchr+0x34>
 8000316:	bcf0      	pop	{r4, r5, r6, r7}
 8000318:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800031c:	f002 0207 	and.w	r2, r2, #7
 8000320:	b132      	cbz	r2, 8000330 <memchr+0x70>
 8000322:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000326:	3a01      	subs	r2, #1
 8000328:	ea83 0301 	eor.w	r3, r3, r1
 800032c:	b113      	cbz	r3, 8000334 <memchr+0x74>
 800032e:	d1f8      	bne.n	8000322 <memchr+0x62>
 8000330:	2000      	movs	r0, #0
 8000332:	4770      	bx	lr
 8000334:	3801      	subs	r0, #1
 8000336:	4770      	bx	lr
 8000338:	2d00      	cmp	r5, #0
 800033a:	bf06      	itte	eq
 800033c:	4635      	moveq	r5, r6
 800033e:	3803      	subeq	r0, #3
 8000340:	3807      	subne	r0, #7
 8000342:	f015 0f01 	tst.w	r5, #1
 8000346:	d107      	bne.n	8000358 <memchr+0x98>
 8000348:	3001      	adds	r0, #1
 800034a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800034e:	bf02      	ittt	eq
 8000350:	3001      	addeq	r0, #1
 8000352:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000356:	3001      	addeq	r0, #1
 8000358:	bcf0      	pop	{r4, r5, r6, r7}
 800035a:	3801      	subs	r0, #1
 800035c:	4770      	bx	lr
 800035e:	bf00      	nop

08000360 <__aeabi_drsub>:
 8000360:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8000364:	e002      	b.n	800036c <__adddf3>
 8000366:	bf00      	nop

08000368 <__aeabi_dsub>:
 8000368:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

0800036c <__adddf3>:
 800036c:	b530      	push	{r4, r5, lr}
 800036e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000372:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000376:	ea94 0f05 	teq	r4, r5
 800037a:	bf08      	it	eq
 800037c:	ea90 0f02 	teqeq	r0, r2
 8000380:	bf1f      	itttt	ne
 8000382:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000386:	ea55 0c02 	orrsne.w	ip, r5, r2
 800038a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800038e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000392:	f000 80e2 	beq.w	800055a <__adddf3+0x1ee>
 8000396:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800039a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800039e:	bfb8      	it	lt
 80003a0:	426d      	neglt	r5, r5
 80003a2:	dd0c      	ble.n	80003be <__adddf3+0x52>
 80003a4:	442c      	add	r4, r5
 80003a6:	ea80 0202 	eor.w	r2, r0, r2
 80003aa:	ea81 0303 	eor.w	r3, r1, r3
 80003ae:	ea82 0000 	eor.w	r0, r2, r0
 80003b2:	ea83 0101 	eor.w	r1, r3, r1
 80003b6:	ea80 0202 	eor.w	r2, r0, r2
 80003ba:	ea81 0303 	eor.w	r3, r1, r3
 80003be:	2d36      	cmp	r5, #54	@ 0x36
 80003c0:	bf88      	it	hi
 80003c2:	bd30      	pophi	{r4, r5, pc}
 80003c4:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80003c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80003cc:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 80003d0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80003d4:	d002      	beq.n	80003dc <__adddf3+0x70>
 80003d6:	4240      	negs	r0, r0
 80003d8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80003dc:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 80003e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80003e4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80003e8:	d002      	beq.n	80003f0 <__adddf3+0x84>
 80003ea:	4252      	negs	r2, r2
 80003ec:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80003f0:	ea94 0f05 	teq	r4, r5
 80003f4:	f000 80a7 	beq.w	8000546 <__adddf3+0x1da>
 80003f8:	f1a4 0401 	sub.w	r4, r4, #1
 80003fc:	f1d5 0e20 	rsbs	lr, r5, #32
 8000400:	db0d      	blt.n	800041e <__adddf3+0xb2>
 8000402:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000406:	fa22 f205 	lsr.w	r2, r2, r5
 800040a:	1880      	adds	r0, r0, r2
 800040c:	f141 0100 	adc.w	r1, r1, #0
 8000410:	fa03 f20e 	lsl.w	r2, r3, lr
 8000414:	1880      	adds	r0, r0, r2
 8000416:	fa43 f305 	asr.w	r3, r3, r5
 800041a:	4159      	adcs	r1, r3
 800041c:	e00e      	b.n	800043c <__adddf3+0xd0>
 800041e:	f1a5 0520 	sub.w	r5, r5, #32
 8000422:	f10e 0e20 	add.w	lr, lr, #32
 8000426:	2a01      	cmp	r2, #1
 8000428:	fa03 fc0e 	lsl.w	ip, r3, lr
 800042c:	bf28      	it	cs
 800042e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000432:	fa43 f305 	asr.w	r3, r3, r5
 8000436:	18c0      	adds	r0, r0, r3
 8000438:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800043c:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000440:	d507      	bpl.n	8000452 <__adddf3+0xe6>
 8000442:	f04f 0e00 	mov.w	lr, #0
 8000446:	f1dc 0c00 	rsbs	ip, ip, #0
 800044a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800044e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000452:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000456:	d31b      	bcc.n	8000490 <__adddf3+0x124>
 8000458:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 800045c:	d30c      	bcc.n	8000478 <__adddf3+0x10c>
 800045e:	0849      	lsrs	r1, r1, #1
 8000460:	ea5f 0030 	movs.w	r0, r0, rrx
 8000464:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000468:	f104 0401 	add.w	r4, r4, #1
 800046c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000470:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 8000474:	f080 809a 	bcs.w	80005ac <__adddf3+0x240>
 8000478:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 800047c:	bf08      	it	eq
 800047e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000482:	f150 0000 	adcs.w	r0, r0, #0
 8000486:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800048a:	ea41 0105 	orr.w	r1, r1, r5
 800048e:	bd30      	pop	{r4, r5, pc}
 8000490:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000494:	4140      	adcs	r0, r0
 8000496:	eb41 0101 	adc.w	r1, r1, r1
 800049a:	3c01      	subs	r4, #1
 800049c:	bf28      	it	cs
 800049e:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 80004a2:	d2e9      	bcs.n	8000478 <__adddf3+0x10c>
 80004a4:	f091 0f00 	teq	r1, #0
 80004a8:	bf04      	itt	eq
 80004aa:	4601      	moveq	r1, r0
 80004ac:	2000      	moveq	r0, #0
 80004ae:	fab1 f381 	clz	r3, r1
 80004b2:	bf08      	it	eq
 80004b4:	3320      	addeq	r3, #32
 80004b6:	f1a3 030b 	sub.w	r3, r3, #11
 80004ba:	f1b3 0220 	subs.w	r2, r3, #32
 80004be:	da0c      	bge.n	80004da <__adddf3+0x16e>
 80004c0:	320c      	adds	r2, #12
 80004c2:	dd08      	ble.n	80004d6 <__adddf3+0x16a>
 80004c4:	f102 0c14 	add.w	ip, r2, #20
 80004c8:	f1c2 020c 	rsb	r2, r2, #12
 80004cc:	fa01 f00c 	lsl.w	r0, r1, ip
 80004d0:	fa21 f102 	lsr.w	r1, r1, r2
 80004d4:	e00c      	b.n	80004f0 <__adddf3+0x184>
 80004d6:	f102 0214 	add.w	r2, r2, #20
 80004da:	bfd8      	it	le
 80004dc:	f1c2 0c20 	rsble	ip, r2, #32
 80004e0:	fa01 f102 	lsl.w	r1, r1, r2
 80004e4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80004e8:	bfdc      	itt	le
 80004ea:	ea41 010c 	orrle.w	r1, r1, ip
 80004ee:	4090      	lslle	r0, r2
 80004f0:	1ae4      	subs	r4, r4, r3
 80004f2:	bfa2      	ittt	ge
 80004f4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80004f8:	4329      	orrge	r1, r5
 80004fa:	bd30      	popge	{r4, r5, pc}
 80004fc:	ea6f 0404 	mvn.w	r4, r4
 8000500:	3c1f      	subs	r4, #31
 8000502:	da1c      	bge.n	800053e <__adddf3+0x1d2>
 8000504:	340c      	adds	r4, #12
 8000506:	dc0e      	bgt.n	8000526 <__adddf3+0x1ba>
 8000508:	f104 0414 	add.w	r4, r4, #20
 800050c:	f1c4 0220 	rsb	r2, r4, #32
 8000510:	fa20 f004 	lsr.w	r0, r0, r4
 8000514:	fa01 f302 	lsl.w	r3, r1, r2
 8000518:	ea40 0003 	orr.w	r0, r0, r3
 800051c:	fa21 f304 	lsr.w	r3, r1, r4
 8000520:	ea45 0103 	orr.w	r1, r5, r3
 8000524:	bd30      	pop	{r4, r5, pc}
 8000526:	f1c4 040c 	rsb	r4, r4, #12
 800052a:	f1c4 0220 	rsb	r2, r4, #32
 800052e:	fa20 f002 	lsr.w	r0, r0, r2
 8000532:	fa01 f304 	lsl.w	r3, r1, r4
 8000536:	ea40 0003 	orr.w	r0, r0, r3
 800053a:	4629      	mov	r1, r5
 800053c:	bd30      	pop	{r4, r5, pc}
 800053e:	fa21 f004 	lsr.w	r0, r1, r4
 8000542:	4629      	mov	r1, r5
 8000544:	bd30      	pop	{r4, r5, pc}
 8000546:	f094 0f00 	teq	r4, #0
 800054a:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800054e:	bf06      	itte	eq
 8000550:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000554:	3401      	addeq	r4, #1
 8000556:	3d01      	subne	r5, #1
 8000558:	e74e      	b.n	80003f8 <__adddf3+0x8c>
 800055a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800055e:	bf18      	it	ne
 8000560:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000564:	d029      	beq.n	80005ba <__adddf3+0x24e>
 8000566:	ea94 0f05 	teq	r4, r5
 800056a:	bf08      	it	eq
 800056c:	ea90 0f02 	teqeq	r0, r2
 8000570:	d005      	beq.n	800057e <__adddf3+0x212>
 8000572:	ea54 0c00 	orrs.w	ip, r4, r0
 8000576:	bf04      	itt	eq
 8000578:	4619      	moveq	r1, r3
 800057a:	4610      	moveq	r0, r2
 800057c:	bd30      	pop	{r4, r5, pc}
 800057e:	ea91 0f03 	teq	r1, r3
 8000582:	bf1e      	ittt	ne
 8000584:	2100      	movne	r1, #0
 8000586:	2000      	movne	r0, #0
 8000588:	bd30      	popne	{r4, r5, pc}
 800058a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800058e:	d105      	bne.n	800059c <__adddf3+0x230>
 8000590:	0040      	lsls	r0, r0, #1
 8000592:	4149      	adcs	r1, r1
 8000594:	bf28      	it	cs
 8000596:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 800059a:	bd30      	pop	{r4, r5, pc}
 800059c:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 80005a0:	bf3c      	itt	cc
 80005a2:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 80005a6:	bd30      	popcc	{r4, r5, pc}
 80005a8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 80005ac:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 80005b0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 80005b4:	f04f 0000 	mov.w	r0, #0
 80005b8:	bd30      	pop	{r4, r5, pc}
 80005ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80005be:	bf1a      	itte	ne
 80005c0:	4619      	movne	r1, r3
 80005c2:	4610      	movne	r0, r2
 80005c4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80005c8:	bf1c      	itt	ne
 80005ca:	460b      	movne	r3, r1
 80005cc:	4602      	movne	r2, r0
 80005ce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80005d2:	bf06      	itte	eq
 80005d4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80005d8:	ea91 0f03 	teqeq	r1, r3
 80005dc:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 80005e0:	bd30      	pop	{r4, r5, pc}
 80005e2:	bf00      	nop

080005e4 <__aeabi_ui2d>:
 80005e4:	f090 0f00 	teq	r0, #0
 80005e8:	bf04      	itt	eq
 80005ea:	2100      	moveq	r1, #0
 80005ec:	4770      	bxeq	lr
 80005ee:	b530      	push	{r4, r5, lr}
 80005f0:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80005f4:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80005f8:	f04f 0500 	mov.w	r5, #0
 80005fc:	f04f 0100 	mov.w	r1, #0
 8000600:	e750      	b.n	80004a4 <__adddf3+0x138>
 8000602:	bf00      	nop

08000604 <__aeabi_i2d>:
 8000604:	f090 0f00 	teq	r0, #0
 8000608:	bf04      	itt	eq
 800060a:	2100      	moveq	r1, #0
 800060c:	4770      	bxeq	lr
 800060e:	b530      	push	{r4, r5, lr}
 8000610:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000614:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 8000618:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 800061c:	bf48      	it	mi
 800061e:	4240      	negmi	r0, r0
 8000620:	f04f 0100 	mov.w	r1, #0
 8000624:	e73e      	b.n	80004a4 <__adddf3+0x138>
 8000626:	bf00      	nop

08000628 <__aeabi_f2d>:
 8000628:	0042      	lsls	r2, r0, #1
 800062a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800062e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000632:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000636:	bf1f      	itttt	ne
 8000638:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 800063c:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8000640:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000644:	4770      	bxne	lr
 8000646:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 800064a:	bf08      	it	eq
 800064c:	4770      	bxeq	lr
 800064e:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 8000652:	bf04      	itt	eq
 8000654:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000658:	4770      	bxeq	lr
 800065a:	b530      	push	{r4, r5, lr}
 800065c:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8000660:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000664:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000668:	e71c      	b.n	80004a4 <__adddf3+0x138>
 800066a:	bf00      	nop

0800066c <__aeabi_ul2d>:
 800066c:	ea50 0201 	orrs.w	r2, r0, r1
 8000670:	bf08      	it	eq
 8000672:	4770      	bxeq	lr
 8000674:	b530      	push	{r4, r5, lr}
 8000676:	f04f 0500 	mov.w	r5, #0
 800067a:	e00a      	b.n	8000692 <__aeabi_l2d+0x16>

0800067c <__aeabi_l2d>:
 800067c:	ea50 0201 	orrs.w	r2, r0, r1
 8000680:	bf08      	it	eq
 8000682:	4770      	bxeq	lr
 8000684:	b530      	push	{r4, r5, lr}
 8000686:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 800068a:	d502      	bpl.n	8000692 <__aeabi_l2d+0x16>
 800068c:	4240      	negs	r0, r0
 800068e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000692:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000696:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 800069a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800069e:	f43f aed8 	beq.w	8000452 <__adddf3+0xe6>
 80006a2:	f04f 0203 	mov.w	r2, #3
 80006a6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80006aa:	bf18      	it	ne
 80006ac:	3203      	addne	r2, #3
 80006ae:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80006b2:	bf18      	it	ne
 80006b4:	3203      	addne	r2, #3
 80006b6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80006ba:	f1c2 0320 	rsb	r3, r2, #32
 80006be:	fa00 fc03 	lsl.w	ip, r0, r3
 80006c2:	fa20 f002 	lsr.w	r0, r0, r2
 80006c6:	fa01 fe03 	lsl.w	lr, r1, r3
 80006ca:	ea40 000e 	orr.w	r0, r0, lr
 80006ce:	fa21 f102 	lsr.w	r1, r1, r2
 80006d2:	4414      	add	r4, r2
 80006d4:	e6bd      	b.n	8000452 <__adddf3+0xe6>
 80006d6:	bf00      	nop

080006d8 <__aeabi_dmul>:
 80006d8:	b570      	push	{r4, r5, r6, lr}
 80006da:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 80006de:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 80006e2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80006e6:	bf1d      	ittte	ne
 80006e8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80006ec:	ea94 0f0c 	teqne	r4, ip
 80006f0:	ea95 0f0c 	teqne	r5, ip
 80006f4:	f000 f8de 	bleq	80008b4 <__aeabi_dmul+0x1dc>
 80006f8:	442c      	add	r4, r5
 80006fa:	ea81 0603 	eor.w	r6, r1, r3
 80006fe:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000702:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000706:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800070a:	bf18      	it	ne
 800070c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000710:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000714:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8000718:	d038      	beq.n	800078c <__aeabi_dmul+0xb4>
 800071a:	fba0 ce02 	umull	ip, lr, r0, r2
 800071e:	f04f 0500 	mov.w	r5, #0
 8000722:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000726:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
 800072a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800072e:	f04f 0600 	mov.w	r6, #0
 8000732:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000736:	f09c 0f00 	teq	ip, #0
 800073a:	bf18      	it	ne
 800073c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000740:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
 8000744:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
 8000748:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
 800074c:	d204      	bcs.n	8000758 <__aeabi_dmul+0x80>
 800074e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000752:	416d      	adcs	r5, r5
 8000754:	eb46 0606 	adc.w	r6, r6, r6
 8000758:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800075c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000760:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000764:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000768:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800076c:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8000770:	bf88      	it	hi
 8000772:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000776:	d81e      	bhi.n	80007b6 <__aeabi_dmul+0xde>
 8000778:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
 800077c:	bf08      	it	eq
 800077e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000782:	f150 0000 	adcs.w	r0, r0, #0
 8000786:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800078a:	bd70      	pop	{r4, r5, r6, pc}
 800078c:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
 8000790:	ea46 0101 	orr.w	r1, r6, r1
 8000794:	ea40 0002 	orr.w	r0, r0, r2
 8000798:	ea81 0103 	eor.w	r1, r1, r3
 800079c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80007a0:	bfc2      	ittt	gt
 80007a2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80007a6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80007aa:	bd70      	popgt	{r4, r5, r6, pc}
 80007ac:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80007b0:	f04f 0e00 	mov.w	lr, #0
 80007b4:	3c01      	subs	r4, #1
 80007b6:	f300 80ab 	bgt.w	8000910 <__aeabi_dmul+0x238>
 80007ba:	f114 0f36 	cmn.w	r4, #54	@ 0x36
 80007be:	bfde      	ittt	le
 80007c0:	2000      	movle	r0, #0
 80007c2:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
 80007c6:	bd70      	pople	{r4, r5, r6, pc}
 80007c8:	f1c4 0400 	rsb	r4, r4, #0
 80007cc:	3c20      	subs	r4, #32
 80007ce:	da35      	bge.n	800083c <__aeabi_dmul+0x164>
 80007d0:	340c      	adds	r4, #12
 80007d2:	dc1b      	bgt.n	800080c <__aeabi_dmul+0x134>
 80007d4:	f104 0414 	add.w	r4, r4, #20
 80007d8:	f1c4 0520 	rsb	r5, r4, #32
 80007dc:	fa00 f305 	lsl.w	r3, r0, r5
 80007e0:	fa20 f004 	lsr.w	r0, r0, r4
 80007e4:	fa01 f205 	lsl.w	r2, r1, r5
 80007e8:	ea40 0002 	orr.w	r0, r0, r2
 80007ec:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
 80007f0:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 80007f4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80007f8:	fa21 f604 	lsr.w	r6, r1, r4
 80007fc:	eb42 0106 	adc.w	r1, r2, r6
 8000800:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000804:	bf08      	it	eq
 8000806:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800080a:	bd70      	pop	{r4, r5, r6, pc}
 800080c:	f1c4 040c 	rsb	r4, r4, #12
 8000810:	f1c4 0520 	rsb	r5, r4, #32
 8000814:	fa00 f304 	lsl.w	r3, r0, r4
 8000818:	fa20 f005 	lsr.w	r0, r0, r5
 800081c:	fa01 f204 	lsl.w	r2, r1, r4
 8000820:	ea40 0002 	orr.w	r0, r0, r2
 8000824:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000828:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800082c:	f141 0100 	adc.w	r1, r1, #0
 8000830:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000834:	bf08      	it	eq
 8000836:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800083a:	bd70      	pop	{r4, r5, r6, pc}
 800083c:	f1c4 0520 	rsb	r5, r4, #32
 8000840:	fa00 f205 	lsl.w	r2, r0, r5
 8000844:	ea4e 0e02 	orr.w	lr, lr, r2
 8000848:	fa20 f304 	lsr.w	r3, r0, r4
 800084c:	fa01 f205 	lsl.w	r2, r1, r5
 8000850:	ea43 0302 	orr.w	r3, r3, r2
 8000854:	fa21 f004 	lsr.w	r0, r1, r4
 8000858:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 800085c:	fa21 f204 	lsr.w	r2, r1, r4
 8000860:	ea20 0002 	bic.w	r0, r0, r2
 8000864:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000868:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800086c:	bf08      	it	eq
 800086e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000872:	bd70      	pop	{r4, r5, r6, pc}
 8000874:	f094 0f00 	teq	r4, #0
 8000878:	d10f      	bne.n	800089a <__aeabi_dmul+0x1c2>
 800087a:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
 800087e:	0040      	lsls	r0, r0, #1
 8000880:	eb41 0101 	adc.w	r1, r1, r1
 8000884:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000888:	bf08      	it	eq
 800088a:	3c01      	subeq	r4, #1
 800088c:	d0f7      	beq.n	800087e <__aeabi_dmul+0x1a6>
 800088e:	ea41 0106 	orr.w	r1, r1, r6
 8000892:	f095 0f00 	teq	r5, #0
 8000896:	bf18      	it	ne
 8000898:	4770      	bxne	lr
 800089a:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 800089e:	0052      	lsls	r2, r2, #1
 80008a0:	eb43 0303 	adc.w	r3, r3, r3
 80008a4:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
 80008a8:	bf08      	it	eq
 80008aa:	3d01      	subeq	r5, #1
 80008ac:	d0f7      	beq.n	800089e <__aeabi_dmul+0x1c6>
 80008ae:	ea43 0306 	orr.w	r3, r3, r6
 80008b2:	4770      	bx	lr
 80008b4:	ea94 0f0c 	teq	r4, ip
 80008b8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80008bc:	bf18      	it	ne
 80008be:	ea95 0f0c 	teqne	r5, ip
 80008c2:	d00c      	beq.n	80008de <__aeabi_dmul+0x206>
 80008c4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80008c8:	bf18      	it	ne
 80008ca:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80008ce:	d1d1      	bne.n	8000874 <__aeabi_dmul+0x19c>
 80008d0:	ea81 0103 	eor.w	r1, r1, r3
 80008d4:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 80008d8:	f04f 0000 	mov.w	r0, #0
 80008dc:	bd70      	pop	{r4, r5, r6, pc}
 80008de:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80008e2:	bf06      	itte	eq
 80008e4:	4610      	moveq	r0, r2
 80008e6:	4619      	moveq	r1, r3
 80008e8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80008ec:	d019      	beq.n	8000922 <__aeabi_dmul+0x24a>
 80008ee:	ea94 0f0c 	teq	r4, ip
 80008f2:	d102      	bne.n	80008fa <__aeabi_dmul+0x222>
 80008f4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80008f8:	d113      	bne.n	8000922 <__aeabi_dmul+0x24a>
 80008fa:	ea95 0f0c 	teq	r5, ip
 80008fe:	d105      	bne.n	800090c <__aeabi_dmul+0x234>
 8000900:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000904:	bf1c      	itt	ne
 8000906:	4610      	movne	r0, r2
 8000908:	4619      	movne	r1, r3
 800090a:	d10a      	bne.n	8000922 <__aeabi_dmul+0x24a>
 800090c:	ea81 0103 	eor.w	r1, r1, r3
 8000910:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
 8000914:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000918:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800091c:	f04f 0000 	mov.w	r0, #0
 8000920:	bd70      	pop	{r4, r5, r6, pc}
 8000922:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
 8000926:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
 800092a:	bd70      	pop	{r4, r5, r6, pc}

0800092c <__aeabi_ddiv>:
 800092c:	b570      	push	{r4, r5, r6, lr}
 800092e:	f04f 0cff 	mov.w	ip, #255	@ 0xff
 8000932:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
 8000936:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800093a:	bf1d      	ittte	ne
 800093c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000940:	ea94 0f0c 	teqne	r4, ip
 8000944:	ea95 0f0c 	teqne	r5, ip
 8000948:	f000 f8a7 	bleq	8000a9a <__aeabi_ddiv+0x16e>
 800094c:	eba4 0405 	sub.w	r4, r4, r5
 8000950:	ea81 0e03 	eor.w	lr, r1, r3
 8000954:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000958:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800095c:	f000 8088 	beq.w	8000a70 <__aeabi_ddiv+0x144>
 8000960:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000964:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
 8000968:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800096c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000970:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000974:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000978:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800097c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000980:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000
 8000984:	429d      	cmp	r5, r3
 8000986:	bf08      	it	eq
 8000988:	4296      	cmpeq	r6, r2
 800098a:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
 800098e:	f504 7440 	add.w	r4, r4, #768	@ 0x300
 8000992:	d202      	bcs.n	800099a <__aeabi_ddiv+0x6e>
 8000994:	085b      	lsrs	r3, r3, #1
 8000996:	ea4f 0232 	mov.w	r2, r2, rrx
 800099a:	1ab6      	subs	r6, r6, r2
 800099c:	eb65 0503 	sbc.w	r5, r5, r3
 80009a0:	085b      	lsrs	r3, r3, #1
 80009a2:	ea4f 0232 	mov.w	r2, r2, rrx
 80009a6:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
 80009aa:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000
 80009ae:	ebb6 0e02 	subs.w	lr, r6, r2
 80009b2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80009b6:	bf22      	ittt	cs
 80009b8:	1ab6      	subcs	r6, r6, r2
 80009ba:	4675      	movcs	r5, lr
 80009bc:	ea40 000c 	orrcs.w	r0, r0, ip
 80009c0:	085b      	lsrs	r3, r3, #1
 80009c2:	ea4f 0232 	mov.w	r2, r2, rrx
 80009c6:	ebb6 0e02 	subs.w	lr, r6, r2
 80009ca:	eb75 0e03 	sbcs.w	lr, r5, r3
 80009ce:	bf22      	ittt	cs
 80009d0:	1ab6      	subcs	r6, r6, r2
 80009d2:	4675      	movcs	r5, lr
 80009d4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80009d8:	085b      	lsrs	r3, r3, #1
 80009da:	ea4f 0232 	mov.w	r2, r2, rrx
 80009de:	ebb6 0e02 	subs.w	lr, r6, r2
 80009e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80009e6:	bf22      	ittt	cs
 80009e8:	1ab6      	subcs	r6, r6, r2
 80009ea:	4675      	movcs	r5, lr
 80009ec:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80009f0:	085b      	lsrs	r3, r3, #1
 80009f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80009f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80009fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80009fe:	bf22      	ittt	cs
 8000a00:	1ab6      	subcs	r6, r6, r2
 8000a02:	4675      	movcs	r5, lr
 8000a04:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000a08:	ea55 0e06 	orrs.w	lr, r5, r6
 8000a0c:	d018      	beq.n	8000a40 <__aeabi_ddiv+0x114>
 8000a0e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000a12:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000a16:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000a1a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000a1e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000a22:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000a26:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000a2a:	d1c0      	bne.n	80009ae <__aeabi_ddiv+0x82>
 8000a2c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000a30:	d10b      	bne.n	8000a4a <__aeabi_ddiv+0x11e>
 8000a32:	ea41 0100 	orr.w	r1, r1, r0
 8000a36:	f04f 0000 	mov.w	r0, #0
 8000a3a:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
 8000a3e:	e7b6      	b.n	80009ae <__aeabi_ddiv+0x82>
 8000a40:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
 8000a44:	bf04      	itt	eq
 8000a46:	4301      	orreq	r1, r0
 8000a48:	2000      	moveq	r0, #0
 8000a4a:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
 8000a4e:	bf88      	it	hi
 8000a50:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
 8000a54:	f63f aeaf 	bhi.w	80007b6 <__aeabi_dmul+0xde>
 8000a58:	ebb5 0c03 	subs.w	ip, r5, r3
 8000a5c:	bf04      	itt	eq
 8000a5e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000a62:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000a66:	f150 0000 	adcs.w	r0, r0, #0
 8000a6a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000a6e:	bd70      	pop	{r4, r5, r6, pc}
 8000a70:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
 8000a74:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000a78:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000a7c:	bfc2      	ittt	gt
 8000a7e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000a82:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000a86:	bd70      	popgt	{r4, r5, r6, pc}
 8000a88:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000a8c:	f04f 0e00 	mov.w	lr, #0
 8000a90:	3c01      	subs	r4, #1
 8000a92:	e690      	b.n	80007b6 <__aeabi_dmul+0xde>
 8000a94:	ea45 0e06 	orr.w	lr, r5, r6
 8000a98:	e68d      	b.n	80007b6 <__aeabi_dmul+0xde>
 8000a9a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a9e:	ea94 0f0c 	teq	r4, ip
 8000aa2:	bf08      	it	eq
 8000aa4:	ea95 0f0c 	teqeq	r5, ip
 8000aa8:	f43f af3b 	beq.w	8000922 <__aeabi_dmul+0x24a>
 8000aac:	ea94 0f0c 	teq	r4, ip
 8000ab0:	d10a      	bne.n	8000ac8 <__aeabi_ddiv+0x19c>
 8000ab2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000ab6:	f47f af34 	bne.w	8000922 <__aeabi_dmul+0x24a>
 8000aba:	ea95 0f0c 	teq	r5, ip
 8000abe:	f47f af25 	bne.w	800090c <__aeabi_dmul+0x234>
 8000ac2:	4610      	mov	r0, r2
 8000ac4:	4619      	mov	r1, r3
 8000ac6:	e72c      	b.n	8000922 <__aeabi_dmul+0x24a>
 8000ac8:	ea95 0f0c 	teq	r5, ip
 8000acc:	d106      	bne.n	8000adc <__aeabi_ddiv+0x1b0>
 8000ace:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000ad2:	f43f aefd 	beq.w	80008d0 <__aeabi_dmul+0x1f8>
 8000ad6:	4610      	mov	r0, r2
 8000ad8:	4619      	mov	r1, r3
 8000ada:	e722      	b.n	8000922 <__aeabi_dmul+0x24a>
 8000adc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000ae0:	bf18      	it	ne
 8000ae2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000ae6:	f47f aec5 	bne.w	8000874 <__aeabi_dmul+0x19c>
 8000aea:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000aee:	f47f af0d 	bne.w	800090c <__aeabi_dmul+0x234>
 8000af2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000af6:	f47f aeeb 	bne.w	80008d0 <__aeabi_dmul+0x1f8>
 8000afa:	e712      	b.n	8000922 <__aeabi_dmul+0x24a>

08000afc <__gedf2>:
 8000afc:	f04f 3cff 	mov.w	ip, #4294967295
 8000b00:	e006      	b.n	8000b10 <__cmpdf2+0x4>
 8000b02:	bf00      	nop

08000b04 <__ledf2>:
 8000b04:	f04f 0c01 	mov.w	ip, #1
 8000b08:	e002      	b.n	8000b10 <__cmpdf2+0x4>
 8000b0a:	bf00      	nop

08000b0c <__cmpdf2>:
 8000b0c:	f04f 0c01 	mov.w	ip, #1
 8000b10:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000b14:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b18:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b1c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b20:	bf18      	it	ne
 8000b22:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000b26:	d01b      	beq.n	8000b60 <__cmpdf2+0x54>
 8000b28:	b001      	add	sp, #4
 8000b2a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000b2e:	bf0c      	ite	eq
 8000b30:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000b34:	ea91 0f03 	teqne	r1, r3
 8000b38:	bf02      	ittt	eq
 8000b3a:	ea90 0f02 	teqeq	r0, r2
 8000b3e:	2000      	moveq	r0, #0
 8000b40:	4770      	bxeq	lr
 8000b42:	f110 0f00 	cmn.w	r0, #0
 8000b46:	ea91 0f03 	teq	r1, r3
 8000b4a:	bf58      	it	pl
 8000b4c:	4299      	cmppl	r1, r3
 8000b4e:	bf08      	it	eq
 8000b50:	4290      	cmpeq	r0, r2
 8000b52:	bf2c      	ite	cs
 8000b54:	17d8      	asrcs	r0, r3, #31
 8000b56:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000b5a:	f040 0001 	orr.w	r0, r0, #1
 8000b5e:	4770      	bx	lr
 8000b60:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b64:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b68:	d102      	bne.n	8000b70 <__cmpdf2+0x64>
 8000b6a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b6e:	d107      	bne.n	8000b80 <__cmpdf2+0x74>
 8000b70:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b74:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b78:	d1d6      	bne.n	8000b28 <__cmpdf2+0x1c>
 8000b7a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b7e:	d0d3      	beq.n	8000b28 <__cmpdf2+0x1c>
 8000b80:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000b84:	4770      	bx	lr
 8000b86:	bf00      	nop

08000b88 <__aeabi_cdrcmple>:
 8000b88:	4684      	mov	ip, r0
 8000b8a:	4610      	mov	r0, r2
 8000b8c:	4662      	mov	r2, ip
 8000b8e:	468c      	mov	ip, r1
 8000b90:	4619      	mov	r1, r3
 8000b92:	4663      	mov	r3, ip
 8000b94:	e000      	b.n	8000b98 <__aeabi_cdcmpeq>
 8000b96:	bf00      	nop

08000b98 <__aeabi_cdcmpeq>:
 8000b98:	b501      	push	{r0, lr}
 8000b9a:	f7ff ffb7 	bl	8000b0c <__cmpdf2>
 8000b9e:	2800      	cmp	r0, #0
 8000ba0:	bf48      	it	mi
 8000ba2:	f110 0f00 	cmnmi.w	r0, #0
 8000ba6:	bd01      	pop	{r0, pc}

08000ba8 <__aeabi_dcmpeq>:
 8000ba8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000bac:	f7ff fff4 	bl	8000b98 <__aeabi_cdcmpeq>
 8000bb0:	bf0c      	ite	eq
 8000bb2:	2001      	moveq	r0, #1
 8000bb4:	2000      	movne	r0, #0
 8000bb6:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bba:	bf00      	nop

08000bbc <__aeabi_dcmplt>:
 8000bbc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000bc0:	f7ff ffea 	bl	8000b98 <__aeabi_cdcmpeq>
 8000bc4:	bf34      	ite	cc
 8000bc6:	2001      	movcc	r0, #1
 8000bc8:	2000      	movcs	r0, #0
 8000bca:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bce:	bf00      	nop

08000bd0 <__aeabi_dcmple>:
 8000bd0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000bd4:	f7ff ffe0 	bl	8000b98 <__aeabi_cdcmpeq>
 8000bd8:	bf94      	ite	ls
 8000bda:	2001      	movls	r0, #1
 8000bdc:	2000      	movhi	r0, #0
 8000bde:	f85d fb08 	ldr.w	pc, [sp], #8
 8000be2:	bf00      	nop

08000be4 <__aeabi_dcmpge>:
 8000be4:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000be8:	f7ff ffce 	bl	8000b88 <__aeabi_cdrcmple>
 8000bec:	bf94      	ite	ls
 8000bee:	2001      	movls	r0, #1
 8000bf0:	2000      	movhi	r0, #0
 8000bf2:	f85d fb08 	ldr.w	pc, [sp], #8
 8000bf6:	bf00      	nop

08000bf8 <__aeabi_dcmpgt>:
 8000bf8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000bfc:	f7ff ffc4 	bl	8000b88 <__aeabi_cdrcmple>
 8000c00:	bf34      	ite	cc
 8000c02:	2001      	movcc	r0, #1
 8000c04:	2000      	movcs	r0, #0
 8000c06:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c0a:	bf00      	nop

08000c0c <__aeabi_dcmpun>:
 8000c0c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000c10:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c14:	d102      	bne.n	8000c1c <__aeabi_dcmpun+0x10>
 8000c16:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000c1a:	d10a      	bne.n	8000c32 <__aeabi_dcmpun+0x26>
 8000c1c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000c20:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c24:	d102      	bne.n	8000c2c <__aeabi_dcmpun+0x20>
 8000c26:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000c2a:	d102      	bne.n	8000c32 <__aeabi_dcmpun+0x26>
 8000c2c:	f04f 0000 	mov.w	r0, #0
 8000c30:	4770      	bx	lr
 8000c32:	f04f 0001 	mov.w	r0, #1
 8000c36:	4770      	bx	lr

08000c38 <__aeabi_d2uiz>:
 8000c38:	004a      	lsls	r2, r1, #1
 8000c3a:	d211      	bcs.n	8000c60 <__aeabi_d2uiz+0x28>
 8000c3c:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
 8000c40:	d211      	bcs.n	8000c66 <__aeabi_d2uiz+0x2e>
 8000c42:	d50d      	bpl.n	8000c60 <__aeabi_d2uiz+0x28>
 8000c44:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
 8000c48:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000c4c:	d40e      	bmi.n	8000c6c <__aeabi_d2uiz+0x34>
 8000c4e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000c52:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 8000c56:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000c5a:	fa23 f002 	lsr.w	r0, r3, r2
 8000c5e:	4770      	bx	lr
 8000c60:	f04f 0000 	mov.w	r0, #0
 8000c64:	4770      	bx	lr
 8000c66:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000c6a:	d102      	bne.n	8000c72 <__aeabi_d2uiz+0x3a>
 8000c6c:	f04f 30ff 	mov.w	r0, #4294967295
 8000c70:	4770      	bx	lr
 8000c72:	f04f 0000 	mov.w	r0, #0
 8000c76:	4770      	bx	lr

08000c78 <__aeabi_d2f>:
 8000c78:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000c7c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 8000c80:	bf24      	itt	cs
 8000c82:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 8000c86:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 8000c8a:	d90d      	bls.n	8000ca8 <__aeabi_d2f+0x30>
 8000c8c:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 8000c90:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000c94:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000c98:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 8000c9c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000ca0:	bf08      	it	eq
 8000ca2:	f020 0001 	biceq.w	r0, r0, #1
 8000ca6:	4770      	bx	lr
 8000ca8:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 8000cac:	d121      	bne.n	8000cf2 <__aeabi_d2f+0x7a>
 8000cae:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 8000cb2:	bfbc      	itt	lt
 8000cb4:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 8000cb8:	4770      	bxlt	lr
 8000cba:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 8000cbe:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000cc2:	f1c2 0218 	rsb	r2, r2, #24
 8000cc6:	f1c2 0c20 	rsb	ip, r2, #32
 8000cca:	fa10 f30c 	lsls.w	r3, r0, ip
 8000cce:	fa20 f002 	lsr.w	r0, r0, r2
 8000cd2:	bf18      	it	ne
 8000cd4:	f040 0001 	orrne.w	r0, r0, #1
 8000cd8:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000cdc:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ce0:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000ce4:	ea40 000c 	orr.w	r0, r0, ip
 8000ce8:	fa23 f302 	lsr.w	r3, r3, r2
 8000cec:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000cf0:	e7cc      	b.n	8000c8c <__aeabi_d2f+0x14>
 8000cf2:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000cf6:	d107      	bne.n	8000d08 <__aeabi_d2f+0x90>
 8000cf8:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000cfc:	bf1e      	ittt	ne
 8000cfe:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000d02:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000d06:	4770      	bxne	lr
 8000d08:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 8000d0c:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000d10:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000d14:	4770      	bx	lr
 8000d16:	bf00      	nop

08000d18 <__aeabi_uldivmod>:
 8000d18:	b953      	cbnz	r3, 8000d30 <__aeabi_uldivmod+0x18>
 8000d1a:	b94a      	cbnz	r2, 8000d30 <__aeabi_uldivmod+0x18>
 8000d1c:	2900      	cmp	r1, #0
 8000d1e:	bf08      	it	eq
 8000d20:	2800      	cmpeq	r0, #0
 8000d22:	bf1c      	itt	ne
 8000d24:	f04f 31ff 	movne.w	r1, #4294967295
 8000d28:	f04f 30ff 	movne.w	r0, #4294967295
 8000d2c:	f000 b9a0 	b.w	8001070 <__aeabi_idiv0>
 8000d30:	f1ad 0c08 	sub.w	ip, sp, #8
 8000d34:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000d38:	f000 f83c 	bl	8000db4 <__udivmoddi4>
 8000d3c:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000d40:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000d44:	b004      	add	sp, #16
 8000d46:	4770      	bx	lr

08000d48 <__aeabi_d2lz>:
 8000d48:	b538      	push	{r3, r4, r5, lr}
 8000d4a:	2200      	movs	r2, #0
 8000d4c:	2300      	movs	r3, #0
 8000d4e:	4604      	mov	r4, r0
 8000d50:	460d      	mov	r5, r1
 8000d52:	f7ff ff33 	bl	8000bbc <__aeabi_dcmplt>
 8000d56:	b928      	cbnz	r0, 8000d64 <__aeabi_d2lz+0x1c>
 8000d58:	4620      	mov	r0, r4
 8000d5a:	4629      	mov	r1, r5
 8000d5c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8000d60:	f000 b80a 	b.w	8000d78 <__aeabi_d2ulz>
 8000d64:	4620      	mov	r0, r4
 8000d66:	f105 4100 	add.w	r1, r5, #2147483648	@ 0x80000000
 8000d6a:	f000 f805 	bl	8000d78 <__aeabi_d2ulz>
 8000d6e:	4240      	negs	r0, r0
 8000d70:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000d74:	bd38      	pop	{r3, r4, r5, pc}
 8000d76:	bf00      	nop

08000d78 <__aeabi_d2ulz>:
 8000d78:	b5d0      	push	{r4, r6, r7, lr}
 8000d7a:	4b0c      	ldr	r3, [pc, #48]	@ (8000dac <__aeabi_d2ulz+0x34>)
 8000d7c:	2200      	movs	r2, #0
 8000d7e:	4606      	mov	r6, r0
 8000d80:	460f      	mov	r7, r1
 8000d82:	f7ff fca9 	bl	80006d8 <__aeabi_dmul>
 8000d86:	f7ff ff57 	bl	8000c38 <__aeabi_d2uiz>
 8000d8a:	4604      	mov	r4, r0
 8000d8c:	f7ff fc2a 	bl	80005e4 <__aeabi_ui2d>
 8000d90:	4b07      	ldr	r3, [pc, #28]	@ (8000db0 <__aeabi_d2ulz+0x38>)
 8000d92:	2200      	movs	r2, #0
 8000d94:	f7ff fca0 	bl	80006d8 <__aeabi_dmul>
 8000d98:	4602      	mov	r2, r0
 8000d9a:	460b      	mov	r3, r1
 8000d9c:	4630      	mov	r0, r6
 8000d9e:	4639      	mov	r1, r7
 8000da0:	f7ff fae2 	bl	8000368 <__aeabi_dsub>
 8000da4:	f7ff ff48 	bl	8000c38 <__aeabi_d2uiz>
 8000da8:	4621      	mov	r1, r4
 8000daa:	bdd0      	pop	{r4, r6, r7, pc}
 8000dac:	3df00000 	.word	0x3df00000
 8000db0:	41f00000 	.word	0x41f00000

08000db4 <__udivmoddi4>:
 8000db4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000db8:	9d08      	ldr	r5, [sp, #32]
 8000dba:	460c      	mov	r4, r1
 8000dbc:	2b00      	cmp	r3, #0
 8000dbe:	d14e      	bne.n	8000e5e <__udivmoddi4+0xaa>
 8000dc0:	4694      	mov	ip, r2
 8000dc2:	458c      	cmp	ip, r1
 8000dc4:	4686      	mov	lr, r0
 8000dc6:	fab2 f282 	clz	r2, r2
 8000dca:	d962      	bls.n	8000e92 <__udivmoddi4+0xde>
 8000dcc:	b14a      	cbz	r2, 8000de2 <__udivmoddi4+0x2e>
 8000dce:	f1c2 0320 	rsb	r3, r2, #32
 8000dd2:	4091      	lsls	r1, r2
 8000dd4:	fa20 f303 	lsr.w	r3, r0, r3
 8000dd8:	fa0c fc02 	lsl.w	ip, ip, r2
 8000ddc:	4319      	orrs	r1, r3
 8000dde:	fa00 fe02 	lsl.w	lr, r0, r2
 8000de2:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000de6:	fa1f f68c 	uxth.w	r6, ip
 8000dea:	fbb1 f4f7 	udiv	r4, r1, r7
 8000dee:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000df2:	fb07 1114 	mls	r1, r7, r4, r1
 8000df6:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000dfa:	fb04 f106 	mul.w	r1, r4, r6
 8000dfe:	4299      	cmp	r1, r3
 8000e00:	d90a      	bls.n	8000e18 <__udivmoddi4+0x64>
 8000e02:	eb1c 0303 	adds.w	r3, ip, r3
 8000e06:	f104 30ff 	add.w	r0, r4, #4294967295
 8000e0a:	f080 8112 	bcs.w	8001032 <__udivmoddi4+0x27e>
 8000e0e:	4299      	cmp	r1, r3
 8000e10:	f240 810f 	bls.w	8001032 <__udivmoddi4+0x27e>
 8000e14:	3c02      	subs	r4, #2
 8000e16:	4463      	add	r3, ip
 8000e18:	1a59      	subs	r1, r3, r1
 8000e1a:	fa1f f38e 	uxth.w	r3, lr
 8000e1e:	fbb1 f0f7 	udiv	r0, r1, r7
 8000e22:	fb07 1110 	mls	r1, r7, r0, r1
 8000e26:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000e2a:	fb00 f606 	mul.w	r6, r0, r6
 8000e2e:	429e      	cmp	r6, r3
 8000e30:	d90a      	bls.n	8000e48 <__udivmoddi4+0x94>
 8000e32:	eb1c 0303 	adds.w	r3, ip, r3
 8000e36:	f100 31ff 	add.w	r1, r0, #4294967295
 8000e3a:	f080 80fc 	bcs.w	8001036 <__udivmoddi4+0x282>
 8000e3e:	429e      	cmp	r6, r3
 8000e40:	f240 80f9 	bls.w	8001036 <__udivmoddi4+0x282>
 8000e44:	4463      	add	r3, ip
 8000e46:	3802      	subs	r0, #2
 8000e48:	1b9b      	subs	r3, r3, r6
 8000e4a:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000e4e:	2100      	movs	r1, #0
 8000e50:	b11d      	cbz	r5, 8000e5a <__udivmoddi4+0xa6>
 8000e52:	40d3      	lsrs	r3, r2
 8000e54:	2200      	movs	r2, #0
 8000e56:	e9c5 3200 	strd	r3, r2, [r5]
 8000e5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000e5e:	428b      	cmp	r3, r1
 8000e60:	d905      	bls.n	8000e6e <__udivmoddi4+0xba>
 8000e62:	b10d      	cbz	r5, 8000e68 <__udivmoddi4+0xb4>
 8000e64:	e9c5 0100 	strd	r0, r1, [r5]
 8000e68:	2100      	movs	r1, #0
 8000e6a:	4608      	mov	r0, r1
 8000e6c:	e7f5      	b.n	8000e5a <__udivmoddi4+0xa6>
 8000e6e:	fab3 f183 	clz	r1, r3
 8000e72:	2900      	cmp	r1, #0
 8000e74:	d146      	bne.n	8000f04 <__udivmoddi4+0x150>
 8000e76:	42a3      	cmp	r3, r4
 8000e78:	d302      	bcc.n	8000e80 <__udivmoddi4+0xcc>
 8000e7a:	4290      	cmp	r0, r2
 8000e7c:	f0c0 80f0 	bcc.w	8001060 <__udivmoddi4+0x2ac>
 8000e80:	1a86      	subs	r6, r0, r2
 8000e82:	eb64 0303 	sbc.w	r3, r4, r3
 8000e86:	2001      	movs	r0, #1
 8000e88:	2d00      	cmp	r5, #0
 8000e8a:	d0e6      	beq.n	8000e5a <__udivmoddi4+0xa6>
 8000e8c:	e9c5 6300 	strd	r6, r3, [r5]
 8000e90:	e7e3      	b.n	8000e5a <__udivmoddi4+0xa6>
 8000e92:	2a00      	cmp	r2, #0
 8000e94:	f040 8090 	bne.w	8000fb8 <__udivmoddi4+0x204>
 8000e98:	eba1 040c 	sub.w	r4, r1, ip
 8000e9c:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000ea0:	fa1f f78c 	uxth.w	r7, ip
 8000ea4:	2101      	movs	r1, #1
 8000ea6:	fbb4 f6f8 	udiv	r6, r4, r8
 8000eaa:	ea4f 431e 	mov.w	r3, lr, lsr #16
 8000eae:	fb08 4416 	mls	r4, r8, r6, r4
 8000eb2:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000eb6:	fb07 f006 	mul.w	r0, r7, r6
 8000eba:	4298      	cmp	r0, r3
 8000ebc:	d908      	bls.n	8000ed0 <__udivmoddi4+0x11c>
 8000ebe:	eb1c 0303 	adds.w	r3, ip, r3
 8000ec2:	f106 34ff 	add.w	r4, r6, #4294967295
 8000ec6:	d202      	bcs.n	8000ece <__udivmoddi4+0x11a>
 8000ec8:	4298      	cmp	r0, r3
 8000eca:	f200 80cd 	bhi.w	8001068 <__udivmoddi4+0x2b4>
 8000ece:	4626      	mov	r6, r4
 8000ed0:	1a1c      	subs	r4, r3, r0
 8000ed2:	fa1f f38e 	uxth.w	r3, lr
 8000ed6:	fbb4 f0f8 	udiv	r0, r4, r8
 8000eda:	fb08 4410 	mls	r4, r8, r0, r4
 8000ede:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8000ee2:	fb00 f707 	mul.w	r7, r0, r7
 8000ee6:	429f      	cmp	r7, r3
 8000ee8:	d908      	bls.n	8000efc <__udivmoddi4+0x148>
 8000eea:	eb1c 0303 	adds.w	r3, ip, r3
 8000eee:	f100 34ff 	add.w	r4, r0, #4294967295
 8000ef2:	d202      	bcs.n	8000efa <__udivmoddi4+0x146>
 8000ef4:	429f      	cmp	r7, r3
 8000ef6:	f200 80b0 	bhi.w	800105a <__udivmoddi4+0x2a6>
 8000efa:	4620      	mov	r0, r4
 8000efc:	1bdb      	subs	r3, r3, r7
 8000efe:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000f02:	e7a5      	b.n	8000e50 <__udivmoddi4+0x9c>
 8000f04:	f1c1 0620 	rsb	r6, r1, #32
 8000f08:	408b      	lsls	r3, r1
 8000f0a:	fa22 f706 	lsr.w	r7, r2, r6
 8000f0e:	431f      	orrs	r7, r3
 8000f10:	fa20 fc06 	lsr.w	ip, r0, r6
 8000f14:	fa04 f301 	lsl.w	r3, r4, r1
 8000f18:	ea43 030c 	orr.w	r3, r3, ip
 8000f1c:	40f4      	lsrs	r4, r6
 8000f1e:	fa00 f801 	lsl.w	r8, r0, r1
 8000f22:	0c38      	lsrs	r0, r7, #16
 8000f24:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8000f28:	fbb4 fef0 	udiv	lr, r4, r0
 8000f2c:	fa1f fc87 	uxth.w	ip, r7
 8000f30:	fb00 441e 	mls	r4, r0, lr, r4
 8000f34:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000f38:	fb0e f90c 	mul.w	r9, lr, ip
 8000f3c:	45a1      	cmp	r9, r4
 8000f3e:	fa02 f201 	lsl.w	r2, r2, r1
 8000f42:	d90a      	bls.n	8000f5a <__udivmoddi4+0x1a6>
 8000f44:	193c      	adds	r4, r7, r4
 8000f46:	f10e 3aff 	add.w	sl, lr, #4294967295
 8000f4a:	f080 8084 	bcs.w	8001056 <__udivmoddi4+0x2a2>
 8000f4e:	45a1      	cmp	r9, r4
 8000f50:	f240 8081 	bls.w	8001056 <__udivmoddi4+0x2a2>
 8000f54:	f1ae 0e02 	sub.w	lr, lr, #2
 8000f58:	443c      	add	r4, r7
 8000f5a:	eba4 0409 	sub.w	r4, r4, r9
 8000f5e:	fa1f f983 	uxth.w	r9, r3
 8000f62:	fbb4 f3f0 	udiv	r3, r4, r0
 8000f66:	fb00 4413 	mls	r4, r0, r3, r4
 8000f6a:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000f6e:	fb03 fc0c 	mul.w	ip, r3, ip
 8000f72:	45a4      	cmp	ip, r4
 8000f74:	d907      	bls.n	8000f86 <__udivmoddi4+0x1d2>
 8000f76:	193c      	adds	r4, r7, r4
 8000f78:	f103 30ff 	add.w	r0, r3, #4294967295
 8000f7c:	d267      	bcs.n	800104e <__udivmoddi4+0x29a>
 8000f7e:	45a4      	cmp	ip, r4
 8000f80:	d965      	bls.n	800104e <__udivmoddi4+0x29a>
 8000f82:	3b02      	subs	r3, #2
 8000f84:	443c      	add	r4, r7
 8000f86:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 8000f8a:	fba0 9302 	umull	r9, r3, r0, r2
 8000f8e:	eba4 040c 	sub.w	r4, r4, ip
 8000f92:	429c      	cmp	r4, r3
 8000f94:	46ce      	mov	lr, r9
 8000f96:	469c      	mov	ip, r3
 8000f98:	d351      	bcc.n	800103e <__udivmoddi4+0x28a>
 8000f9a:	d04e      	beq.n	800103a <__udivmoddi4+0x286>
 8000f9c:	b155      	cbz	r5, 8000fb4 <__udivmoddi4+0x200>
 8000f9e:	ebb8 030e 	subs.w	r3, r8, lr
 8000fa2:	eb64 040c 	sbc.w	r4, r4, ip
 8000fa6:	fa04 f606 	lsl.w	r6, r4, r6
 8000faa:	40cb      	lsrs	r3, r1
 8000fac:	431e      	orrs	r6, r3
 8000fae:	40cc      	lsrs	r4, r1
 8000fb0:	e9c5 6400 	strd	r6, r4, [r5]
 8000fb4:	2100      	movs	r1, #0
 8000fb6:	e750      	b.n	8000e5a <__udivmoddi4+0xa6>
 8000fb8:	f1c2 0320 	rsb	r3, r2, #32
 8000fbc:	fa20 f103 	lsr.w	r1, r0, r3
 8000fc0:	fa0c fc02 	lsl.w	ip, ip, r2
 8000fc4:	fa24 f303 	lsr.w	r3, r4, r3
 8000fc8:	4094      	lsls	r4, r2
 8000fca:	430c      	orrs	r4, r1
 8000fcc:	ea4f 481c 	mov.w	r8, ip, lsr #16
 8000fd0:	fa00 fe02 	lsl.w	lr, r0, r2
 8000fd4:	fa1f f78c 	uxth.w	r7, ip
 8000fd8:	fbb3 f0f8 	udiv	r0, r3, r8
 8000fdc:	fb08 3110 	mls	r1, r8, r0, r3
 8000fe0:	0c23      	lsrs	r3, r4, #16
 8000fe2:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000fe6:	fb00 f107 	mul.w	r1, r0, r7
 8000fea:	4299      	cmp	r1, r3
 8000fec:	d908      	bls.n	8001000 <__udivmoddi4+0x24c>
 8000fee:	eb1c 0303 	adds.w	r3, ip, r3
 8000ff2:	f100 36ff 	add.w	r6, r0, #4294967295
 8000ff6:	d22c      	bcs.n	8001052 <__udivmoddi4+0x29e>
 8000ff8:	4299      	cmp	r1, r3
 8000ffa:	d92a      	bls.n	8001052 <__udivmoddi4+0x29e>
 8000ffc:	3802      	subs	r0, #2
 8000ffe:	4463      	add	r3, ip
 8001000:	1a5b      	subs	r3, r3, r1
 8001002:	b2a4      	uxth	r4, r4
 8001004:	fbb3 f1f8 	udiv	r1, r3, r8
 8001008:	fb08 3311 	mls	r3, r8, r1, r3
 800100c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8001010:	fb01 f307 	mul.w	r3, r1, r7
 8001014:	42a3      	cmp	r3, r4
 8001016:	d908      	bls.n	800102a <__udivmoddi4+0x276>
 8001018:	eb1c 0404 	adds.w	r4, ip, r4
 800101c:	f101 36ff 	add.w	r6, r1, #4294967295
 8001020:	d213      	bcs.n	800104a <__udivmoddi4+0x296>
 8001022:	42a3      	cmp	r3, r4
 8001024:	d911      	bls.n	800104a <__udivmoddi4+0x296>
 8001026:	3902      	subs	r1, #2
 8001028:	4464      	add	r4, ip
 800102a:	1ae4      	subs	r4, r4, r3
 800102c:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8001030:	e739      	b.n	8000ea6 <__udivmoddi4+0xf2>
 8001032:	4604      	mov	r4, r0
 8001034:	e6f0      	b.n	8000e18 <__udivmoddi4+0x64>
 8001036:	4608      	mov	r0, r1
 8001038:	e706      	b.n	8000e48 <__udivmoddi4+0x94>
 800103a:	45c8      	cmp	r8, r9
 800103c:	d2ae      	bcs.n	8000f9c <__udivmoddi4+0x1e8>
 800103e:	ebb9 0e02 	subs.w	lr, r9, r2
 8001042:	eb63 0c07 	sbc.w	ip, r3, r7
 8001046:	3801      	subs	r0, #1
 8001048:	e7a8      	b.n	8000f9c <__udivmoddi4+0x1e8>
 800104a:	4631      	mov	r1, r6
 800104c:	e7ed      	b.n	800102a <__udivmoddi4+0x276>
 800104e:	4603      	mov	r3, r0
 8001050:	e799      	b.n	8000f86 <__udivmoddi4+0x1d2>
 8001052:	4630      	mov	r0, r6
 8001054:	e7d4      	b.n	8001000 <__udivmoddi4+0x24c>
 8001056:	46d6      	mov	lr, sl
 8001058:	e77f      	b.n	8000f5a <__udivmoddi4+0x1a6>
 800105a:	4463      	add	r3, ip
 800105c:	3802      	subs	r0, #2
 800105e:	e74d      	b.n	8000efc <__udivmoddi4+0x148>
 8001060:	4606      	mov	r6, r0
 8001062:	4623      	mov	r3, r4
 8001064:	4608      	mov	r0, r1
 8001066:	e70f      	b.n	8000e88 <__udivmoddi4+0xd4>
 8001068:	3e02      	subs	r6, #2
 800106a:	4463      	add	r3, ip
 800106c:	e730      	b.n	8000ed0 <__udivmoddi4+0x11c>
 800106e:	bf00      	nop

08001070 <__aeabi_idiv0>:
 8001070:	4770      	bx	lr
 8001072:	bf00      	nop

08001074 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
 8001074:	b580      	push	{r7, lr}
 8001076:	b082      	sub	sp, #8
 8001078:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 800107a:	2300      	movs	r3, #0
 800107c:	607b      	str	r3, [r7, #4]
 800107e:	4b18      	ldr	r3, [pc, #96]	@ (80010e0 <MX_DMA_Init+0x6c>)
 8001080:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001082:	4a17      	ldr	r2, [pc, #92]	@ (80010e0 <MX_DMA_Init+0x6c>)
 8001084:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8001088:	6313      	str	r3, [r2, #48]	@ 0x30
 800108a:	4b15      	ldr	r3, [pc, #84]	@ (80010e0 <MX_DMA_Init+0x6c>)
 800108c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800108e:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8001092:	607b      	str	r3, [r7, #4]
 8001094:	687b      	ldr	r3, [r7, #4]

  /* DMA interrupt init */
  /* DMA2_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
 8001096:	2200      	movs	r2, #0
 8001098:	2105      	movs	r1, #5
 800109a:	2039      	movs	r0, #57	@ 0x39
 800109c:	f007 ff21 	bl	8008ee2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
 80010a0:	2039      	movs	r0, #57	@ 0x39
 80010a2:	f007 ff3a 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 5, 0);
 80010a6:	2200      	movs	r2, #0
 80010a8:	2105      	movs	r1, #5
 80010aa:	203b      	movs	r0, #59	@ 0x3b
 80010ac:	f007 ff19 	bl	8008ee2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 80010b0:	203b      	movs	r0, #59	@ 0x3b
 80010b2:	f007 ff32 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream4_IRQn, 5, 0);
 80010b6:	2200      	movs	r2, #0
 80010b8:	2105      	movs	r1, #5
 80010ba:	203c      	movs	r0, #60	@ 0x3c
 80010bc:	f007 ff11 	bl	8008ee2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream4_IRQn);
 80010c0:	203c      	movs	r0, #60	@ 0x3c
 80010c2:	f007 ff2a 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 5, 0);
 80010c6:	2200      	movs	r2, #0
 80010c8:	2105      	movs	r1, #5
 80010ca:	2045      	movs	r0, #69	@ 0x45
 80010cc:	f007 ff09 	bl	8008ee2 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
 80010d0:	2045      	movs	r0, #69	@ 0x45
 80010d2:	f007 ff22 	bl	8008f1a <HAL_NVIC_EnableIRQ>

}
 80010d6:	bf00      	nop
 80010d8:	3708      	adds	r7, #8
 80010da:	46bd      	mov	sp, r7
 80010dc:	bd80      	pop	{r7, pc}
 80010de:	bf00      	nop
 80010e0:	40023800 	.word	0x40023800

080010e4 <flashInit>:
#ifdef _USE_HW_CLI
static void cliFlash(cli_args_t *args);
#endif

bool flashInit(void)
{
 80010e4:	b580      	push	{r7, lr}
 80010e6:	af00      	add	r7, sp, #0

#ifdef _USE_HW_CLI
	cliAdd("flash", cliFlash);
 80010e8:	4903      	ldr	r1, [pc, #12]	@ (80010f8 <flashInit+0x14>)
 80010ea:	4804      	ldr	r0, [pc, #16]	@ (80010fc <flashInit+0x18>)
 80010ec:	f002 f9dc 	bl	80034a8 <cliAdd>
#endif

	return true;
 80010f0:	2301      	movs	r3, #1
}
 80010f2:	4618      	mov	r0, r3
 80010f4:	bd80      	pop	{r7, pc}
 80010f6:	bf00      	nop
 80010f8:	080012b1 	.word	0x080012b1
 80010fc:	08024000 	.word	0x08024000

08001100 <flashErase>:

bool flashErase(uint32_t addr, uint32_t length)
{
 8001100:	b580      	push	{r7, lr}
 8001102:	b08c      	sub	sp, #48	@ 0x30
 8001104:	af00      	add	r7, sp, #0
 8001106:	6078      	str	r0, [r7, #4]
 8001108:	6039      	str	r1, [r7, #0]
	bool ret = false;
 800110a:	2300      	movs	r3, #0
 800110c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  HAL_StatusTypeDef status;
  FLASH_EraseInitTypeDef init;
  uint32_t page_error;

  uint16_t start_sector_num = -1;
 8001110:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8001114:	84fb      	strh	r3, [r7, #38]	@ 0x26
  uint16_t sector_count = 0;
 8001116:	2300      	movs	r3, #0
 8001118:	85bb      	strh	r3, [r7, #44]	@ 0x2c

  for(int i=0; i<FLASH_SECTOR_MAX; i++)
 800111a:	2300      	movs	r3, #0
 800111c:	62bb      	str	r3, [r7, #40]	@ 0x28
 800111e:	e00f      	b.n	8001140 <flashErase+0x40>
  {
  	if(flashInSector(i, addr, length) == true)
 8001120:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001122:	b29b      	uxth	r3, r3
 8001124:	683a      	ldr	r2, [r7, #0]
 8001126:	6879      	ldr	r1, [r7, #4]
 8001128:	4618      	mov	r0, r3
 800112a:	f000 f869 	bl	8001200 <flashInSector>
 800112e:	4603      	mov	r3, r0
 8001130:	2b00      	cmp	r3, #0
 8001132:	d002      	beq.n	800113a <flashErase+0x3a>
  	{
  		if(start_sector_num < 0)
  		{
  			start_sector_num = i;
  		}
  		sector_count++;
 8001134:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 8001136:	3301      	adds	r3, #1
 8001138:	85bb      	strh	r3, [r7, #44]	@ 0x2c
  for(int i=0; i<FLASH_SECTOR_MAX; i++)
 800113a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800113c:	3301      	adds	r3, #1
 800113e:	62bb      	str	r3, [r7, #40]	@ 0x28
 8001140:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001142:	2b07      	cmp	r3, #7
 8001144:	ddec      	ble.n	8001120 <flashErase+0x20>
  	}
  }

  if(sector_count > 0)
 8001146:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 8001148:	2b00      	cmp	r3, #0
 800114a:	d01f      	beq.n	800118c <flashErase+0x8c>
  {
  	HAL_FLASH_Unlock();
 800114c:	f008 fbdc 	bl	8009908 <HAL_FLASH_Unlock>

    init.TypeErase   = FLASH_TYPEERASE_SECTORS;
 8001150:	2300      	movs	r3, #0
 8001152:	613b      	str	r3, [r7, #16]
    init.Banks       = FLASH_BANK_1;
 8001154:	2301      	movs	r3, #1
 8001156:	617b      	str	r3, [r7, #20]
    init.Sector      = start_sector_num;
 8001158:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 800115a:	61bb      	str	r3, [r7, #24]
    init.NbSectors   = sector_count;
 800115c:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 800115e:	61fb      	str	r3, [r7, #28]
    init.VoltageRange = FLASH_VOLTAGE_RANGE_3;
 8001160:	2302      	movs	r3, #2
 8001162:	623b      	str	r3, [r7, #32]

    status = HAL_FLASHEx_Erase(&init, &page_error);
 8001164:	f107 020c 	add.w	r2, r7, #12
 8001168:	f107 0310 	add.w	r3, r7, #16
 800116c:	4611      	mov	r1, r2
 800116e:	4618      	mov	r0, r3
 8001170:	f008 fd3c 	bl	8009bec <HAL_FLASHEx_Erase>
 8001174:	4603      	mov	r3, r0
 8001176:	f887 3025 	strb.w	r3, [r7, #37]	@ 0x25
    if(status == HAL_OK)
 800117a:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 800117e:	2b00      	cmp	r3, #0
 8001180:	d102      	bne.n	8001188 <flashErase+0x88>
    {
    	ret = true;
 8001182:	2301      	movs	r3, #1
 8001184:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    }

    HAL_FLASH_Lock();
 8001188:	f008 fbe0 	bl	800994c <HAL_FLASH_Lock>
  }

  return ret;
 800118c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 8001190:	4618      	mov	r0, r3
 8001192:	3730      	adds	r7, #48	@ 0x30
 8001194:	46bd      	mov	sp, r7
 8001196:	bd80      	pop	{r7, pc}

08001198 <flashWrite>:

bool flashWrite(uint32_t addr, uint8_t *p_data, uint32_t length)
{
 8001198:	b5b0      	push	{r4, r5, r7, lr}
 800119a:	b088      	sub	sp, #32
 800119c:	af00      	add	r7, sp, #0
 800119e:	60f8      	str	r0, [r7, #12]
 80011a0:	60b9      	str	r1, [r7, #8]
 80011a2:	607a      	str	r2, [r7, #4]
	bool ret = true;
 80011a4:	2301      	movs	r3, #1
 80011a6:	77fb      	strb	r3, [r7, #31]
	HAL_StatusTypeDef status;

	HAL_FLASH_Unlock();
 80011a8:	f008 fbae 	bl	8009908 <HAL_FLASH_Unlock>

	for(int i=0; i<length; i++)
 80011ac:	2300      	movs	r3, #0
 80011ae:	61bb      	str	r3, [r7, #24]
 80011b0:	e01b      	b.n	80011ea <flashWrite+0x52>
	{
		uint16_t data;

		data = p_data[i+0] << 0;
 80011b2:	69bb      	ldr	r3, [r7, #24]
 80011b4:	68ba      	ldr	r2, [r7, #8]
 80011b6:	4413      	add	r3, r2
 80011b8:	781b      	ldrb	r3, [r3, #0]
 80011ba:	82fb      	strh	r3, [r7, #22]

		status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, addr + i, (uint16_t)data);
 80011bc:	69ba      	ldr	r2, [r7, #24]
 80011be:	68fb      	ldr	r3, [r7, #12]
 80011c0:	18d1      	adds	r1, r2, r3
 80011c2:	8afb      	ldrh	r3, [r7, #22]
 80011c4:	2200      	movs	r2, #0
 80011c6:	461c      	mov	r4, r3
 80011c8:	4615      	mov	r5, r2
 80011ca:	4622      	mov	r2, r4
 80011cc:	462b      	mov	r3, r5
 80011ce:	2000      	movs	r0, #0
 80011d0:	f008 fb46 	bl	8009860 <HAL_FLASH_Program>
 80011d4:	4603      	mov	r3, r0
 80011d6:	757b      	strb	r3, [r7, #21]
		if(status != HAL_OK)
 80011d8:	7d7b      	ldrb	r3, [r7, #21]
 80011da:	2b00      	cmp	r3, #0
 80011dc:	d002      	beq.n	80011e4 <flashWrite+0x4c>
		{
			ret = false;
 80011de:	2300      	movs	r3, #0
 80011e0:	77fb      	strb	r3, [r7, #31]
			break;
 80011e2:	e006      	b.n	80011f2 <flashWrite+0x5a>
	for(int i=0; i<length; i++)
 80011e4:	69bb      	ldr	r3, [r7, #24]
 80011e6:	3301      	adds	r3, #1
 80011e8:	61bb      	str	r3, [r7, #24]
 80011ea:	69bb      	ldr	r3, [r7, #24]
 80011ec:	687a      	ldr	r2, [r7, #4]
 80011ee:	429a      	cmp	r2, r3
 80011f0:	d8df      	bhi.n	80011b2 <flashWrite+0x1a>
		}
	}

	HAL_FLASH_Lock();
 80011f2:	f008 fbab 	bl	800994c <HAL_FLASH_Lock>

	return ret;
 80011f6:	7ffb      	ldrb	r3, [r7, #31]
}
 80011f8:	4618      	mov	r0, r3
 80011fa:	3720      	adds	r7, #32
 80011fc:	46bd      	mov	sp, r7
 80011fe:	bdb0      	pop	{r4, r5, r7, pc}

08001200 <flashInSector>:

	return ret;
}

bool flashInSector(uint16_t sector_num, uint32_t addr, uint32_t length)
{
 8001200:	b480      	push	{r7}
 8001202:	b08b      	sub	sp, #44	@ 0x2c
 8001204:	af00      	add	r7, sp, #0
 8001206:	4603      	mov	r3, r0
 8001208:	60b9      	str	r1, [r7, #8]
 800120a:	607a      	str	r2, [r7, #4]
 800120c:	81fb      	strh	r3, [r7, #14]
	bool ret = false;
 800120e:	2300      	movs	r3, #0
 8001210:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	uint32_t sector_start;
	uint32_t sector_end;
	uint32_t flash_start;
	uint32_t flash_end;

	sector_start = flash_tbl[sector_num].addr;
 8001214:	89fb      	ldrh	r3, [r7, #14]
 8001216:	4a25      	ldr	r2, [pc, #148]	@ (80012ac <flashInSector+0xac>)
 8001218:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800121c:	623b      	str	r3, [r7, #32]
	sector_end = flash_tbl[sector_num].addr + flash_tbl[sector_num].length - 1;
 800121e:	89fb      	ldrh	r3, [r7, #14]
 8001220:	4a22      	ldr	r2, [pc, #136]	@ (80012ac <flashInSector+0xac>)
 8001222:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8001226:	89fb      	ldrh	r3, [r7, #14]
 8001228:	4920      	ldr	r1, [pc, #128]	@ (80012ac <flashInSector+0xac>)
 800122a:	00db      	lsls	r3, r3, #3
 800122c:	440b      	add	r3, r1
 800122e:	685b      	ldr	r3, [r3, #4]
 8001230:	4413      	add	r3, r2
 8001232:	3b01      	subs	r3, #1
 8001234:	61fb      	str	r3, [r7, #28]
	flash_start = addr;
 8001236:	68bb      	ldr	r3, [r7, #8]
 8001238:	61bb      	str	r3, [r7, #24]
	flash_end = addr + length - 1;
 800123a:	68ba      	ldr	r2, [r7, #8]
 800123c:	687b      	ldr	r3, [r7, #4]
 800123e:	4413      	add	r3, r2
 8001240:	3b01      	subs	r3, #1
 8001242:	617b      	str	r3, [r7, #20]

	if(sector_start >= flash_start && sector_start <= flash_end)
 8001244:	6a3a      	ldr	r2, [r7, #32]
 8001246:	69bb      	ldr	r3, [r7, #24]
 8001248:	429a      	cmp	r2, r3
 800124a:	d306      	bcc.n	800125a <flashInSector+0x5a>
 800124c:	6a3a      	ldr	r2, [r7, #32]
 800124e:	697b      	ldr	r3, [r7, #20]
 8001250:	429a      	cmp	r2, r3
 8001252:	d802      	bhi.n	800125a <flashInSector+0x5a>
	{
		ret = true;
 8001254:	2301      	movs	r3, #1
 8001256:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	}

  if (sector_end >= flash_start && sector_end <= flash_end)
 800125a:	69fa      	ldr	r2, [r7, #28]
 800125c:	69bb      	ldr	r3, [r7, #24]
 800125e:	429a      	cmp	r2, r3
 8001260:	d306      	bcc.n	8001270 <flashInSector+0x70>
 8001262:	69fa      	ldr	r2, [r7, #28]
 8001264:	697b      	ldr	r3, [r7, #20]
 8001266:	429a      	cmp	r2, r3
 8001268:	d802      	bhi.n	8001270 <flashInSector+0x70>
  {
    ret = true;
 800126a:	2301      	movs	r3, #1
 800126c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (flash_start >= sector_start && flash_start <= sector_end)
 8001270:	69ba      	ldr	r2, [r7, #24]
 8001272:	6a3b      	ldr	r3, [r7, #32]
 8001274:	429a      	cmp	r2, r3
 8001276:	d306      	bcc.n	8001286 <flashInSector+0x86>
 8001278:	69ba      	ldr	r2, [r7, #24]
 800127a:	69fb      	ldr	r3, [r7, #28]
 800127c:	429a      	cmp	r2, r3
 800127e:	d802      	bhi.n	8001286 <flashInSector+0x86>
  {
    ret = true;
 8001280:	2301      	movs	r3, #1
 8001282:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (flash_end >= sector_start && flash_end <= sector_end)
 8001286:	697a      	ldr	r2, [r7, #20]
 8001288:	6a3b      	ldr	r3, [r7, #32]
 800128a:	429a      	cmp	r2, r3
 800128c:	d306      	bcc.n	800129c <flashInSector+0x9c>
 800128e:	697a      	ldr	r2, [r7, #20]
 8001290:	69fb      	ldr	r3, [r7, #28]
 8001292:	429a      	cmp	r2, r3
 8001294:	d802      	bhi.n	800129c <flashInSector+0x9c>
  {
    ret = true;
 8001296:	2301      	movs	r3, #1
 8001298:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  return ret;
 800129c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
 80012a0:	4618      	mov	r0, r3
 80012a2:	372c      	adds	r7, #44	@ 0x2c
 80012a4:	46bd      	mov	sp, r7
 80012a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80012aa:	4770      	bx	lr
 80012ac:	20000000 	.word	0x20000000

080012b0 <cliFlash>:


#ifdef _USE_HW_CLI

void cliFlash(cli_args_t *args)
{
 80012b0:	b580      	push	{r7, lr}
 80012b2:	b08c      	sub	sp, #48	@ 0x30
 80012b4:	af00      	add	r7, sp, #0
 80012b6:	6078      	str	r0, [r7, #4]
	bool ret = false;
 80012b8:	2300      	movs	r3, #0
 80012ba:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

	if(args->argc == 1 && args->isStr(0, "info") == true)
 80012be:	687b      	ldr	r3, [r7, #4]
 80012c0:	881b      	ldrh	r3, [r3, #0]
 80012c2:	2b01      	cmp	r3, #1
 80012c4:	d121      	bne.n	800130a <cliFlash+0x5a>
 80012c6:	687b      	ldr	r3, [r7, #4]
 80012c8:	695b      	ldr	r3, [r3, #20]
 80012ca:	495c      	ldr	r1, [pc, #368]	@ (800143c <cliFlash+0x18c>)
 80012cc:	2000      	movs	r0, #0
 80012ce:	4798      	blx	r3
 80012d0:	4603      	mov	r3, r0
 80012d2:	2b00      	cmp	r3, #0
 80012d4:	d019      	beq.n	800130a <cliFlash+0x5a>
	{
		for(int i=0; i<FLASH_SECTOR_MAX; i++)
 80012d6:	2300      	movs	r3, #0
 80012d8:	62bb      	str	r3, [r7, #40]	@ 0x28
 80012da:	e010      	b.n	80012fe <cliFlash+0x4e>
		{
			cliPrintf("0x%X : %dKB\n", flash_tbl[i].addr, flash_tbl[i].length / 1024);
 80012dc:	4a58      	ldr	r2, [pc, #352]	@ (8001440 <cliFlash+0x190>)
 80012de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80012e0:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 80012e4:	4a56      	ldr	r2, [pc, #344]	@ (8001440 <cliFlash+0x190>)
 80012e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80012e8:	00db      	lsls	r3, r3, #3
 80012ea:	4413      	add	r3, r2
 80012ec:	685b      	ldr	r3, [r3, #4]
 80012ee:	0a9b      	lsrs	r3, r3, #10
 80012f0:	461a      	mov	r2, r3
 80012f2:	4854      	ldr	r0, [pc, #336]	@ (8001444 <cliFlash+0x194>)
 80012f4:	f001 ffc8 	bl	8003288 <cliPrintf>
		for(int i=0; i<FLASH_SECTOR_MAX; i++)
 80012f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80012fa:	3301      	adds	r3, #1
 80012fc:	62bb      	str	r3, [r7, #40]	@ 0x28
 80012fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001300:	2b07      	cmp	r3, #7
 8001302:	ddeb      	ble.n	80012dc <cliFlash+0x2c>
		}

		ret = true;
 8001304:	2301      	movs	r3, #1
 8001306:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
	}

	if(args->argc == 2 && args->isStr(0, "read") == true)
 800130a:	687b      	ldr	r3, [r7, #4]
 800130c:	881b      	ldrh	r3, [r3, #0]
 800130e:	2b02      	cmp	r3, #2
 8001310:	d12b      	bne.n	800136a <cliFlash+0xba>
 8001312:	687b      	ldr	r3, [r7, #4]
 8001314:	695b      	ldr	r3, [r3, #20]
 8001316:	494c      	ldr	r1, [pc, #304]	@ (8001448 <cliFlash+0x198>)
 8001318:	2000      	movs	r0, #0
 800131a:	4798      	blx	r3
 800131c:	4603      	mov	r3, r0
 800131e:	2b00      	cmp	r3, #0
 8001320:	d023      	beq.n	800136a <cliFlash+0xba>
	{
		uint32_t addr;
		uint32_t length;

		addr = (uint32_t)args->getData(1);
 8001322:	687b      	ldr	r3, [r7, #4]
 8001324:	689b      	ldr	r3, [r3, #8]
 8001326:	2001      	movs	r0, #1
 8001328:	4798      	blx	r3
 800132a:	4603      	mov	r3, r0
 800132c:	623b      	str	r3, [r7, #32]
		length = (uint32_t)args->getData(2);
 800132e:	687b      	ldr	r3, [r7, #4]
 8001330:	689b      	ldr	r3, [r3, #8]
 8001332:	2002      	movs	r0, #2
 8001334:	4798      	blx	r3
 8001336:	4603      	mov	r3, r0
 8001338:	61fb      	str	r3, [r7, #28]

		for(int i=0; i<length; i++)
 800133a:	2300      	movs	r3, #0
 800133c:	627b      	str	r3, [r7, #36]	@ 0x24
 800133e:	e00d      	b.n	800135c <cliFlash+0xac>
		{
			cliPrintf("0x%X : 0x%X\n", addr + i, *((uint8_t *)(addr + i)));
 8001340:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8001342:	6a3b      	ldr	r3, [r7, #32]
 8001344:	18d1      	adds	r1, r2, r3
 8001346:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8001348:	6a3b      	ldr	r3, [r7, #32]
 800134a:	4413      	add	r3, r2
 800134c:	781b      	ldrb	r3, [r3, #0]
 800134e:	461a      	mov	r2, r3
 8001350:	483e      	ldr	r0, [pc, #248]	@ (800144c <cliFlash+0x19c>)
 8001352:	f001 ff99 	bl	8003288 <cliPrintf>
		for(int i=0; i<length; i++)
 8001356:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001358:	3301      	adds	r3, #1
 800135a:	627b      	str	r3, [r7, #36]	@ 0x24
 800135c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800135e:	69fa      	ldr	r2, [r7, #28]
 8001360:	429a      	cmp	r2, r3
 8001362:	d8ed      	bhi.n	8001340 <cliFlash+0x90>
		}

		ret = true;
 8001364:	2301      	movs	r3, #1
 8001366:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
	}

	if(args->argc == 3 && args->isStr(0, "erase") == true)
 800136a:	687b      	ldr	r3, [r7, #4]
 800136c:	881b      	ldrh	r3, [r3, #0]
 800136e:	2b03      	cmp	r3, #3
 8001370:	d121      	bne.n	80013b6 <cliFlash+0x106>
 8001372:	687b      	ldr	r3, [r7, #4]
 8001374:	695b      	ldr	r3, [r3, #20]
 8001376:	4936      	ldr	r1, [pc, #216]	@ (8001450 <cliFlash+0x1a0>)
 8001378:	2000      	movs	r0, #0
 800137a:	4798      	blx	r3
 800137c:	4603      	mov	r3, r0
 800137e:	2b00      	cmp	r3, #0
 8001380:	d019      	beq.n	80013b6 <cliFlash+0x106>
	{
		uint32_t addr;
		uint32_t length;

		addr = (uint32_t)args->getData(1);
 8001382:	687b      	ldr	r3, [r7, #4]
 8001384:	689b      	ldr	r3, [r3, #8]
 8001386:	2001      	movs	r0, #1
 8001388:	4798      	blx	r3
 800138a:	4603      	mov	r3, r0
 800138c:	61bb      	str	r3, [r7, #24]
		length = (uint32_t)args->getData(2);
 800138e:	687b      	ldr	r3, [r7, #4]
 8001390:	689b      	ldr	r3, [r3, #8]
 8001392:	2002      	movs	r0, #2
 8001394:	4798      	blx	r3
 8001396:	4603      	mov	r3, r0
 8001398:	617b      	str	r3, [r7, #20]

		if(flashErase(addr, length) == true)
 800139a:	6979      	ldr	r1, [r7, #20]
 800139c:	69b8      	ldr	r0, [r7, #24]
 800139e:	f7ff feaf 	bl	8001100 <flashErase>
 80013a2:	4603      	mov	r3, r0
 80013a4:	2b00      	cmp	r3, #0
 80013a6:	d003      	beq.n	80013b0 <cliFlash+0x100>
		{
			cliPrintf("Erase OK\n");
 80013a8:	482a      	ldr	r0, [pc, #168]	@ (8001454 <cliFlash+0x1a4>)
 80013aa:	f001 ff6d 	bl	8003288 <cliPrintf>
 80013ae:	e002      	b.n	80013b6 <cliFlash+0x106>
		}
		else
		{
			cliPrintf("Erase Fail\n");
 80013b0:	4829      	ldr	r0, [pc, #164]	@ (8001458 <cliFlash+0x1a8>)
 80013b2:	f001 ff69 	bl	8003288 <cliPrintf>
		}
	}


  if (args->argc == 3 && args->isStr(0, "write") == true)
 80013b6:	687b      	ldr	r3, [r7, #4]
 80013b8:	881b      	ldrh	r3, [r3, #0]
 80013ba:	2b03      	cmp	r3, #3
 80013bc:	d127      	bne.n	800140e <cliFlash+0x15e>
 80013be:	687b      	ldr	r3, [r7, #4]
 80013c0:	695b      	ldr	r3, [r3, #20]
 80013c2:	4926      	ldr	r1, [pc, #152]	@ (800145c <cliFlash+0x1ac>)
 80013c4:	2000      	movs	r0, #0
 80013c6:	4798      	blx	r3
 80013c8:	4603      	mov	r3, r0
 80013ca:	2b00      	cmp	r3, #0
 80013cc:	d01f      	beq.n	800140e <cliFlash+0x15e>
  {
    uint32_t addr;
    uint32_t data;

    addr   = (uint32_t)args->getData(1);
 80013ce:	687b      	ldr	r3, [r7, #4]
 80013d0:	689b      	ldr	r3, [r3, #8]
 80013d2:	2001      	movs	r0, #1
 80013d4:	4798      	blx	r3
 80013d6:	4603      	mov	r3, r0
 80013d8:	613b      	str	r3, [r7, #16]
    data   = (uint32_t)args->getData(2);
 80013da:	687b      	ldr	r3, [r7, #4]
 80013dc:	689b      	ldr	r3, [r3, #8]
 80013de:	2002      	movs	r0, #2
 80013e0:	4798      	blx	r3
 80013e2:	4603      	mov	r3, r0
 80013e4:	60fb      	str	r3, [r7, #12]

    if (flashWrite(addr, (uint8_t *)&data, 4) == true)
 80013e6:	f107 030c 	add.w	r3, r7, #12
 80013ea:	2204      	movs	r2, #4
 80013ec:	4619      	mov	r1, r3
 80013ee:	6938      	ldr	r0, [r7, #16]
 80013f0:	f7ff fed2 	bl	8001198 <flashWrite>
 80013f4:	4603      	mov	r3, r0
 80013f6:	2b00      	cmp	r3, #0
 80013f8:	d003      	beq.n	8001402 <cliFlash+0x152>
    {
      cliPrintf("Write OK\n");
 80013fa:	4819      	ldr	r0, [pc, #100]	@ (8001460 <cliFlash+0x1b0>)
 80013fc:	f001 ff44 	bl	8003288 <cliPrintf>
 8001400:	e002      	b.n	8001408 <cliFlash+0x158>
    }
    else
    {
      cliPrintf("Write Fail\n");
 8001402:	4818      	ldr	r0, [pc, #96]	@ (8001464 <cliFlash+0x1b4>)
 8001404:	f001 ff40 	bl	8003288 <cliPrintf>
    }

    ret = true;
 8001408:	2301      	movs	r3, #1
 800140a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  }

  if (ret != true)
 800140e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8001412:	f083 0301 	eor.w	r3, r3, #1
 8001416:	b2db      	uxtb	r3, r3
 8001418:	2b00      	cmp	r3, #0
 800141a:	d00b      	beq.n	8001434 <cliFlash+0x184>
  {
    cliPrintf("flash info\n");
 800141c:	4812      	ldr	r0, [pc, #72]	@ (8001468 <cliFlash+0x1b8>)
 800141e:	f001 ff33 	bl	8003288 <cliPrintf>
    cliPrintf("flash read  addr length\n");
 8001422:	4812      	ldr	r0, [pc, #72]	@ (800146c <cliFlash+0x1bc>)
 8001424:	f001 ff30 	bl	8003288 <cliPrintf>
    cliPrintf("flash erase addr length\n");
 8001428:	4811      	ldr	r0, [pc, #68]	@ (8001470 <cliFlash+0x1c0>)
 800142a:	f001 ff2d 	bl	8003288 <cliPrintf>
    cliPrintf("flash write addr data\n");
 800142e:	4811      	ldr	r0, [pc, #68]	@ (8001474 <cliFlash+0x1c4>)
 8001430:	f001 ff2a 	bl	8003288 <cliPrintf>
  }
}
 8001434:	bf00      	nop
 8001436:	3730      	adds	r7, #48	@ 0x30
 8001438:	46bd      	mov	sp, r7
 800143a:	bd80      	pop	{r7, pc}
 800143c:	08024008 	.word	0x08024008
 8001440:	20000000 	.word	0x20000000
 8001444:	08024010 	.word	0x08024010
 8001448:	08024020 	.word	0x08024020
 800144c:	08024028 	.word	0x08024028
 8001450:	08024038 	.word	0x08024038
 8001454:	08024040 	.word	0x08024040
 8001458:	0802404c 	.word	0x0802404c
 800145c:	08024058 	.word	0x08024058
 8001460:	08024060 	.word	0x08024060
 8001464:	0802406c 	.word	0x0802406c
 8001468:	08024078 	.word	0x08024078
 800146c:	08024084 	.word	0x08024084
 8001470:	080240a0 	.word	0x080240a0
 8001474:	080240bc 	.word	0x080240bc

08001478 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
 8001478:	b580      	push	{r7, lr}
 800147a:	b08a      	sub	sp, #40	@ 0x28
 800147c:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800147e:	f107 0314 	add.w	r3, r7, #20
 8001482:	2200      	movs	r2, #0
 8001484:	601a      	str	r2, [r3, #0]
 8001486:	605a      	str	r2, [r3, #4]
 8001488:	609a      	str	r2, [r3, #8]
 800148a:	60da      	str	r2, [r3, #12]
 800148c:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800148e:	2300      	movs	r3, #0
 8001490:	613b      	str	r3, [r7, #16]
 8001492:	4b38      	ldr	r3, [pc, #224]	@ (8001574 <MX_GPIO_Init+0xfc>)
 8001494:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8001496:	4a37      	ldr	r2, [pc, #220]	@ (8001574 <MX_GPIO_Init+0xfc>)
 8001498:	f043 0304 	orr.w	r3, r3, #4
 800149c:	6313      	str	r3, [r2, #48]	@ 0x30
 800149e:	4b35      	ldr	r3, [pc, #212]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014a0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014a2:	f003 0304 	and.w	r3, r3, #4
 80014a6:	613b      	str	r3, [r7, #16]
 80014a8:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80014aa:	2300      	movs	r3, #0
 80014ac:	60fb      	str	r3, [r7, #12]
 80014ae:	4b31      	ldr	r3, [pc, #196]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014b0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014b2:	4a30      	ldr	r2, [pc, #192]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014b4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80014b8:	6313      	str	r3, [r2, #48]	@ 0x30
 80014ba:	4b2e      	ldr	r3, [pc, #184]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014bc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014be:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80014c2:	60fb      	str	r3, [r7, #12]
 80014c4:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80014c6:	2300      	movs	r3, #0
 80014c8:	60bb      	str	r3, [r7, #8]
 80014ca:	4b2a      	ldr	r3, [pc, #168]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014cc:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014ce:	4a29      	ldr	r2, [pc, #164]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014d0:	f043 0301 	orr.w	r3, r3, #1
 80014d4:	6313      	str	r3, [r2, #48]	@ 0x30
 80014d6:	4b27      	ldr	r3, [pc, #156]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014d8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014da:	f003 0301 	and.w	r3, r3, #1
 80014de:	60bb      	str	r3, [r7, #8]
 80014e0:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 80014e2:	2300      	movs	r3, #0
 80014e4:	607b      	str	r3, [r7, #4]
 80014e6:	4b23      	ldr	r3, [pc, #140]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014e8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014ea:	4a22      	ldr	r2, [pc, #136]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014ec:	f043 0302 	orr.w	r3, r3, #2
 80014f0:	6313      	str	r3, [r2, #48]	@ 0x30
 80014f2:	4b20      	ldr	r3, [pc, #128]	@ (8001574 <MX_GPIO_Init+0xfc>)
 80014f4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80014f6:	f003 0302 	and.w	r3, r3, #2
 80014fa:	607b      	str	r3, [r7, #4]
 80014fc:	687b      	ldr	r3, [r7, #4]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
 80014fe:	2200      	movs	r2, #0
 8001500:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8001504:	481c      	ldr	r0, [pc, #112]	@ (8001578 <MX_GPIO_Init+0x100>)
 8001506:	f008 ff13 	bl	800a330 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_15, GPIO_PIN_RESET);
 800150a:	2200      	movs	r2, #0
 800150c:	f248 011c 	movw	r1, #32796	@ 0x801c
 8001510:	481a      	ldr	r0, [pc, #104]	@ (800157c <MX_GPIO_Init+0x104>)
 8001512:	f008 ff0d 	bl	800a330 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PC13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8001516:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 800151a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800151c:	2301      	movs	r3, #1
 800151e:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001520:	2300      	movs	r3, #0
 8001522:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001524:	2300      	movs	r3, #0
 8001526:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001528:	f107 0314 	add.w	r3, r7, #20
 800152c:	4619      	mov	r1, r3
 800152e:	4812      	ldr	r0, [pc, #72]	@ (8001578 <MX_GPIO_Init+0x100>)
 8001530:	f008 fc7e 	bl	8009e30 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA2 PA3 PA4 PA15 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_15;
 8001534:	f248 031c 	movw	r3, #32796	@ 0x801c
 8001538:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800153a:	2301      	movs	r3, #1
 800153c:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800153e:	2300      	movs	r3, #0
 8001540:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001542:	2300      	movs	r3, #0
 8001544:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001546:	f107 0314 	add.w	r3, r7, #20
 800154a:	4619      	mov	r1, r3
 800154c:	480b      	ldr	r0, [pc, #44]	@ (800157c <MX_GPIO_Init+0x104>)
 800154e:	f008 fc6f 	bl	8009e30 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB9 */
  GPIO_InitStruct.Pin = GPIO_PIN_9;
 8001552:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8001556:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8001558:	2300      	movs	r3, #0
 800155a:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800155c:	2300      	movs	r3, #0
 800155e:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001560:	f107 0314 	add.w	r3, r7, #20
 8001564:	4619      	mov	r1, r3
 8001566:	4806      	ldr	r0, [pc, #24]	@ (8001580 <MX_GPIO_Init+0x108>)
 8001568:	f008 fc62 	bl	8009e30 <HAL_GPIO_Init>

}
 800156c:	bf00      	nop
 800156e:	3728      	adds	r7, #40	@ 0x28
 8001570:	46bd      	mov	sp, r7
 8001572:	bd80      	pop	{r7, pc}
 8001574:	40023800 	.word	0x40023800
 8001578:	40020800 	.word	0x40020800
 800157c:	40020000 	.word	0x40020000
 8001580:	40020400 	.word	0x40020400

08001584 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8001584:	b580      	push	{r7, lr}
 8001586:	b082      	sub	sp, #8
 8001588:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800158a:	f007 fb15 	bl	8008bb8 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800158e:	f000 f841 	bl	8001614 <SystemClock_Config>

  /* USER CODE BEGIN SysInit */
  MX_GPIO_Init();
 8001592:	f7ff ff71 	bl	8001478 <MX_GPIO_Init>
  MX_DMA_Init();
 8001596:	f7ff fd6d 	bl	8001074 <MX_DMA_Init>
  MX_USB_DEVICE_Init();
 800159a:	f019 ff6d 	bl	801b478 <MX_USB_DEVICE_Init>
  MX_I2C2_Init();
  MX_USART1_UART_Init();
  /* USER CODE BEGIN 2 */
#endif

  uartInit();
 800159e:	f007 f9f7 	bl	8008990 <uartInit>
  cliInit();
 80015a2:	f001 f941 	bl	8002828 <cliInit>
  ledInit();
 80015a6:	f005 f91d 	bl	80067e4 <ledInit>
  gpioInit();
 80015aa:	f002 fbcb 	bl	8003d44 <gpioInit>
  flashInit();
 80015ae:	f7ff fd99 	bl	80010e4 <flashInit>
  spiInit();
 80015b2:	f006 ff1b 	bl	80083ec <spiInit>
  i2cInit();
 80015b6:	f002 fd13 	bl	8003fe0 <i2cInit>
  mcp2515Init();
 80015ba:	f005 f9c5 	bl	8006948 <mcp2515Init>
  i2sInit();
 80015be:	f003 f92f 	bl	8004820 <i2sInit>

  if(sdInit() == true)
 80015c2:	f006 fb17 	bl	8007bf4 <sdInit>
 80015c6:	4603      	mov	r3, r0
 80015c8:	2b00      	cmp	r3, #0
 80015ca:	d001      	beq.n	80015d0 <main+0x4c>
  {
  	fatfsInit();
 80015cc:	f002 f890 	bl	80036f0 <fatfsInit>
  }

  lcdInit();
 80015d0:	f004 fc02 	bl	8005dd8 <lcdInit>

  cliOpen(_DEF_UART1, 115200);
 80015d4:	f44f 31e1 	mov.w	r1, #115200	@ 0x1c200
 80015d8:	2000      	movs	r0, #0
 80015da:	f001 f971 	bl	80028c0 <cliOpen>
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */

	uint32_t pre_time;

	pre_time = millis();
 80015de:	f000 fa57 	bl	8001a90 <millis>
 80015e2:	6078      	str	r0, [r7, #4]
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  	if(millis() - pre_time >= 1000)
 80015e4:	f000 fa54 	bl	8001a90 <millis>
 80015e8:	4602      	mov	r2, r0
 80015ea:	687b      	ldr	r3, [r7, #4]
 80015ec:	1ad3      	subs	r3, r2, r3
 80015ee:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80015f2:	d309      	bcc.n	8001608 <main+0x84>
  	{
  		pre_time = millis();
 80015f4:	f000 fa4c 	bl	8001a90 <millis>
 80015f8:	6078      	str	r0, [r7, #4]
    	if(uartAvailable(_DEF_UART1) >= 0)
 80015fa:	2000      	movs	r0, #0
 80015fc:	f007 fa2a 	bl	8008a54 <uartAvailable>
    	{

    		uartPrintf(_DEF_UART1, "Hello world\n");
 8001600:	4903      	ldr	r1, [pc, #12]	@ (8001610 <main+0x8c>)
 8001602:	2000      	movs	r0, #0
 8001604:	f007 faa0 	bl	8008b48 <uartPrintf>
    	}
  	}

  	cliMain();
 8001608:	f001 fa12 	bl	8002a30 <cliMain>
  	if(millis() - pre_time >= 1000)
 800160c:	e7ea      	b.n	80015e4 <main+0x60>
 800160e:	bf00      	nop
 8001610:	080240d4 	.word	0x080240d4

08001614 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8001614:	b580      	push	{r7, lr}
 8001616:	b094      	sub	sp, #80	@ 0x50
 8001618:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800161a:	f107 0320 	add.w	r3, r7, #32
 800161e:	2230      	movs	r2, #48	@ 0x30
 8001620:	2100      	movs	r1, #0
 8001622:	4618      	mov	r0, r3
 8001624:	f020 fd6e 	bl	8022104 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8001628:	f107 030c 	add.w	r3, r7, #12
 800162c:	2200      	movs	r2, #0
 800162e:	601a      	str	r2, [r3, #0]
 8001630:	605a      	str	r2, [r3, #4]
 8001632:	609a      	str	r2, [r3, #8]
 8001634:	60da      	str	r2, [r3, #12]
 8001636:	611a      	str	r2, [r3, #16]

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8001638:	2300      	movs	r3, #0
 800163a:	60bb      	str	r3, [r7, #8]
 800163c:	4b27      	ldr	r3, [pc, #156]	@ (80016dc <SystemClock_Config+0xc8>)
 800163e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001640:	4a26      	ldr	r2, [pc, #152]	@ (80016dc <SystemClock_Config+0xc8>)
 8001642:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8001646:	6413      	str	r3, [r2, #64]	@ 0x40
 8001648:	4b24      	ldr	r3, [pc, #144]	@ (80016dc <SystemClock_Config+0xc8>)
 800164a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800164c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001650:	60bb      	str	r3, [r7, #8]
 8001652:	68bb      	ldr	r3, [r7, #8]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8001654:	2300      	movs	r3, #0
 8001656:	607b      	str	r3, [r7, #4]
 8001658:	4b21      	ldr	r3, [pc, #132]	@ (80016e0 <SystemClock_Config+0xcc>)
 800165a:	681b      	ldr	r3, [r3, #0]
 800165c:	4a20      	ldr	r2, [pc, #128]	@ (80016e0 <SystemClock_Config+0xcc>)
 800165e:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 8001662:	6013      	str	r3, [r2, #0]
 8001664:	4b1e      	ldr	r3, [pc, #120]	@ (80016e0 <SystemClock_Config+0xcc>)
 8001666:	681b      	ldr	r3, [r3, #0]
 8001668:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 800166c:	607b      	str	r3, [r7, #4]
 800166e:	687b      	ldr	r3, [r7, #4]

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8001670:	2301      	movs	r3, #1
 8001672:	623b      	str	r3, [r7, #32]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8001674:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
 8001678:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800167a:	2302      	movs	r3, #2
 800167c:	63bb      	str	r3, [r7, #56]	@ 0x38
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800167e:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8001682:	63fb      	str	r3, [r7, #60]	@ 0x3c
  RCC_OscInitStruct.PLL.PLLM = 25;
 8001684:	2319      	movs	r3, #25
 8001686:	643b      	str	r3, [r7, #64]	@ 0x40
  RCC_OscInitStruct.PLL.PLLN = 192;
 8001688:	23c0      	movs	r3, #192	@ 0xc0
 800168a:	647b      	str	r3, [r7, #68]	@ 0x44
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800168c:	2302      	movs	r3, #2
 800168e:	64bb      	str	r3, [r7, #72]	@ 0x48
  RCC_OscInitStruct.PLL.PLLQ = 4;
 8001690:	2304      	movs	r3, #4
 8001692:	64fb      	str	r3, [r7, #76]	@ 0x4c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001694:	f107 0320 	add.w	r3, r7, #32
 8001698:	4618      	mov	r0, r3
 800169a:	f00d fd45 	bl	800f128 <HAL_RCC_OscConfig>
 800169e:	4603      	mov	r3, r0
 80016a0:	2b00      	cmp	r3, #0
 80016a2:	d001      	beq.n	80016a8 <SystemClock_Config+0x94>
  {
    Error_Handler();
 80016a4:	f000 f81e 	bl	80016e4 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80016a8:	230f      	movs	r3, #15
 80016aa:	60fb      	str	r3, [r7, #12]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80016ac:	2302      	movs	r3, #2
 80016ae:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80016b0:	2300      	movs	r3, #0
 80016b2:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 80016b4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 80016b8:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80016ba:	2300      	movs	r3, #0
 80016bc:	61fb      	str	r3, [r7, #28]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
 80016be:	f107 030c 	add.w	r3, r7, #12
 80016c2:	2103      	movs	r1, #3
 80016c4:	4618      	mov	r0, r3
 80016c6:	f00d ffa7 	bl	800f618 <HAL_RCC_ClockConfig>
 80016ca:	4603      	mov	r3, r0
 80016cc:	2b00      	cmp	r3, #0
 80016ce:	d001      	beq.n	80016d4 <SystemClock_Config+0xc0>
  {
    Error_Handler();
 80016d0:	f000 f808 	bl	80016e4 <Error_Handler>
  }
}
 80016d4:	bf00      	nop
 80016d6:	3750      	adds	r7, #80	@ 0x50
 80016d8:	46bd      	mov	sp, r7
 80016da:	bd80      	pop	{r7, pc}
 80016dc:	40023800 	.word	0x40023800
 80016e0:	40007000 	.word	0x40007000

080016e4 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80016e4:	b480      	push	{r7}
 80016e6:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80016e8:	b672      	cpsid	i
}
 80016ea:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80016ec:	bf00      	nop
 80016ee:	e7fd      	b.n	80016ec <Error_Handler+0x8>

080016f0 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80016f0:	b480      	push	{r7}
 80016f2:	b083      	sub	sp, #12
 80016f4:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80016f6:	2300      	movs	r3, #0
 80016f8:	607b      	str	r3, [r7, #4]
 80016fa:	4b10      	ldr	r3, [pc, #64]	@ (800173c <HAL_MspInit+0x4c>)
 80016fc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80016fe:	4a0f      	ldr	r2, [pc, #60]	@ (800173c <HAL_MspInit+0x4c>)
 8001700:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8001704:	6453      	str	r3, [r2, #68]	@ 0x44
 8001706:	4b0d      	ldr	r3, [pc, #52]	@ (800173c <HAL_MspInit+0x4c>)
 8001708:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800170a:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 800170e:	607b      	str	r3, [r7, #4]
 8001710:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_PWR_CLK_ENABLE();
 8001712:	2300      	movs	r3, #0
 8001714:	603b      	str	r3, [r7, #0]
 8001716:	4b09      	ldr	r3, [pc, #36]	@ (800173c <HAL_MspInit+0x4c>)
 8001718:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800171a:	4a08      	ldr	r2, [pc, #32]	@ (800173c <HAL_MspInit+0x4c>)
 800171c:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8001720:	6413      	str	r3, [r2, #64]	@ 0x40
 8001722:	4b06      	ldr	r3, [pc, #24]	@ (800173c <HAL_MspInit+0x4c>)
 8001724:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8001726:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800172a:	603b      	str	r3, [r7, #0]
 800172c:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800172e:	bf00      	nop
 8001730:	370c      	adds	r7, #12
 8001732:	46bd      	mov	sp, r7
 8001734:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001738:	4770      	bx	lr
 800173a:	bf00      	nop
 800173c:	40023800 	.word	0x40023800

08001740 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8001740:	b480      	push	{r7}
 8001742:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8001744:	bf00      	nop
 8001746:	e7fd      	b.n	8001744 <NMI_Handler+0x4>

08001748 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8001748:	b480      	push	{r7}
 800174a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800174c:	bf00      	nop
 800174e:	e7fd      	b.n	800174c <HardFault_Handler+0x4>

08001750 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001750:	b480      	push	{r7}
 8001752:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001754:	bf00      	nop
 8001756:	e7fd      	b.n	8001754 <MemManage_Handler+0x4>

08001758 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001758:	b480      	push	{r7}
 800175a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800175c:	bf00      	nop
 800175e:	e7fd      	b.n	800175c <BusFault_Handler+0x4>

08001760 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001760:	b480      	push	{r7}
 8001762:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001764:	bf00      	nop
 8001766:	e7fd      	b.n	8001764 <UsageFault_Handler+0x4>

08001768 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001768:	b480      	push	{r7}
 800176a:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800176c:	bf00      	nop
 800176e:	46bd      	mov	sp, r7
 8001770:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001774:	4770      	bx	lr

08001776 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8001776:	b580      	push	{r7, lr}
 8001778:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800177a:	f007 fa6f 	bl	8008c5c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */
  osSystickHandler();
 800177e:	f017 fc8b 	bl	8019098 <osSystickHandler>
  /* USER CODE END SysTick_IRQn 1 */
}
 8001782:	bf00      	nop
 8001784:	bd80      	pop	{r7, pc}
	...

08001788 <I2C2_EV_IRQHandler>:

/**
  * @brief This function handles I2C2 event interrupt.
  */
void I2C2_EV_IRQHandler(void)
{
 8001788:	b580      	push	{r7, lr}
 800178a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C2_EV_IRQn 0 */

  /* USER CODE END I2C2_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c2);
 800178c:	4802      	ldr	r0, [pc, #8]	@ (8001798 <I2C2_EV_IRQHandler+0x10>)
 800178e:	f009 fbe5 	bl	800af5c <HAL_I2C_EV_IRQHandler>
  /* USER CODE BEGIN I2C2_EV_IRQn 1 */

  /* USER CODE END I2C2_EV_IRQn 1 */
}
 8001792:	bf00      	nop
 8001794:	bd80      	pop	{r7, pc}
 8001796:	bf00      	nop
 8001798:	20002368 	.word	0x20002368

0800179c <I2C2_ER_IRQHandler>:

/**
  * @brief This function handles I2C2 error interrupt.
  */
void I2C2_ER_IRQHandler(void)
{
 800179c:	b580      	push	{r7, lr}
 800179e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN I2C2_ER_IRQn 0 */

  /* USER CODE END I2C2_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c2);
 80017a0:	4802      	ldr	r0, [pc, #8]	@ (80017ac <I2C2_ER_IRQHandler+0x10>)
 80017a2:	f009 fd2e 	bl	800b202 <HAL_I2C_ER_IRQHandler>
  /* USER CODE BEGIN I2C2_ER_IRQn 1 */

  /* USER CODE END I2C2_ER_IRQn 1 */
}
 80017a6:	bf00      	nop
 80017a8:	bd80      	pop	{r7, pc}
 80017aa:	bf00      	nop
 80017ac:	20002368 	.word	0x20002368

080017b0 <SPI1_IRQHandler>:

/**
  * @brief This function handles SPI1 global interrupt.
  */
void SPI1_IRQHandler(void)
{
 80017b0:	b580      	push	{r7, lr}
 80017b2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI1_IRQn 0 */

  /* USER CODE END SPI1_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi1);
 80017b4:	4802      	ldr	r0, [pc, #8]	@ (80017c0 <SPI1_IRQHandler+0x10>)
 80017b6:	f010 fa4d 	bl	8011c54 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI1_IRQn 1 */

  /* USER CODE END SPI1_IRQn 1 */
}
 80017ba:	bf00      	nop
 80017bc:	bd80      	pop	{r7, pc}
 80017be:	bf00      	nop
 80017c0:	2000a4e0 	.word	0x2000a4e0

080017c4 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 80017c4:	b580      	push	{r7, lr}
 80017c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 80017c8:	4802      	ldr	r0, [pc, #8]	@ (80017d4 <USART1_IRQHandler+0x10>)
 80017ca:	f010 fd3d 	bl	8012248 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 80017ce:	bf00      	nop
 80017d0:	bd80      	pop	{r7, pc}
 80017d2:	bf00      	nop
 80017d4:	2000a714 	.word	0x2000a714

080017d8 <SDIO_IRQHandler>:

/**
  * @brief This function handles SDIO global interrupt.
  */
void SDIO_IRQHandler(void)
{
 80017d8:	b580      	push	{r7, lr}
 80017da:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SDIO_IRQn 0 */

  /* USER CODE END SDIO_IRQn 0 */
  HAL_SD_IRQHandler(&hsd);
 80017dc:	4802      	ldr	r0, [pc, #8]	@ (80017e8 <SDIO_IRQHandler+0x10>)
 80017de:	f00e fcb1 	bl	8010144 <HAL_SD_IRQHandler>
  /* USER CODE BEGIN SDIO_IRQn 1 */

  /* USER CODE END SDIO_IRQn 1 */
}
 80017e2:	bf00      	nop
 80017e4:	bd80      	pop	{r7, pc}
 80017e6:	bf00      	nop
 80017e8:	2000039c 	.word	0x2000039c

080017ec <DMA2_Stream1_IRQHandler>:

/**
  * @brief This function handles DMA2 stream1 global interrupt.
  */
void DMA2_Stream1_IRQHandler(void)
{
 80017ec:	b580      	push	{r7, lr}
 80017ee:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream1_IRQn 0 */

  /* USER CODE END DMA2_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi4_tx);
 80017f0:	4802      	ldr	r0, [pc, #8]	@ (80017fc <DMA2_Stream1_IRQHandler+0x10>)
 80017f2:	f007 fdb1 	bl	8009358 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream1_IRQn 1 */

  /* USER CODE END DMA2_Stream1_IRQn 1 */
}
 80017f6:	bf00      	nop
 80017f8:	bd80      	pop	{r7, pc}
 80017fa:	bf00      	nop
 80017fc:	2000a590 	.word	0x2000a590

08001800 <DMA2_Stream3_IRQHandler>:

/**
  * @brief This function handles DMA2 stream3 global interrupt.
  */
void DMA2_Stream3_IRQHandler(void)
{
 8001800:	b580      	push	{r7, lr}
 8001802:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream3_IRQn 0 */

  /* USER CODE END DMA2_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdio_rx);
 8001804:	4802      	ldr	r0, [pc, #8]	@ (8001810 <DMA2_Stream3_IRQHandler+0x10>)
 8001806:	f007 fda7 	bl	8009358 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream3_IRQn 1 */

  /* USER CODE END DMA2_Stream3_IRQn 1 */
}
 800180a:	bf00      	nop
 800180c:	bd80      	pop	{r7, pc}
 800180e:	bf00      	nop
 8001810:	20000420 	.word	0x20000420

08001814 <DMA2_Stream4_IRQHandler>:

/**
  * @brief This function handles DMA2 stream4 global interrupt.
  */
void DMA2_Stream4_IRQHandler(void)
{
 8001814:	b580      	push	{r7, lr}
 8001816:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream4_IRQn 0 */

  /* USER CODE END DMA2_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi5_tx);
 8001818:	4802      	ldr	r0, [pc, #8]	@ (8001824 <DMA2_Stream4_IRQHandler+0x10>)
 800181a:	f007 fd9d 	bl	8009358 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream4_IRQn 1 */

  /* USER CODE END DMA2_Stream4_IRQn 1 */
}
 800181e:	bf00      	nop
 8001820:	bd80      	pop	{r7, pc}
 8001822:	bf00      	nop
 8001824:	20006418 	.word	0x20006418

08001828 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 8001828:	b580      	push	{r7, lr}
 800182a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_OTG_FS);
 800182c:	4802      	ldr	r0, [pc, #8]	@ (8001838 <OTG_FS_IRQHandler+0x10>)
 800182e:	f00c fb6f 	bl	800df10 <HAL_PCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 8001832:	bf00      	nop
 8001834:	bd80      	pop	{r7, pc}
 8001836:	bf00      	nop
 8001838:	2000bdb4 	.word	0x2000bdb4

0800183c <DMA2_Stream6_IRQHandler>:

/**
  * @brief This function handles DMA2 stream6 global interrupt.
  */
void DMA2_Stream6_IRQHandler(void)
{
 800183c:	b580      	push	{r7, lr}
 800183e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */

  /* USER CODE END DMA2_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdio_tx);
 8001840:	4802      	ldr	r0, [pc, #8]	@ (800184c <DMA2_Stream6_IRQHandler+0x10>)
 8001842:	f007 fd89 	bl	8009358 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream6_IRQn 1 */

  /* USER CODE END DMA2_Stream6_IRQn 1 */
}
 8001846:	bf00      	nop
 8001848:	bd80      	pop	{r7, pc}
 800184a:	bf00      	nop
 800184c:	20000480 	.word	0x20000480

08001850 <SPI4_IRQHandler>:

/**
  * @brief This function handles SPI4 global interrupt.
  */
void SPI4_IRQHandler(void)
{
 8001850:	b580      	push	{r7, lr}
 8001852:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI4_IRQn 0 */

  /* USER CODE END SPI4_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi4);
 8001854:	4802      	ldr	r0, [pc, #8]	@ (8001860 <SPI4_IRQHandler+0x10>)
 8001856:	f010 f9fd 	bl	8011c54 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI4_IRQn 1 */

  /* USER CODE END SPI4_IRQn 1 */
}
 800185a:	bf00      	nop
 800185c:	bd80      	pop	{r7, pc}
 800185e:	bf00      	nop
 8001860:	2000a538 	.word	0x2000a538

08001864 <SPI5_IRQHandler>:

/**
  * @brief This function handles SPI5 global interrupt.
  */
void SPI5_IRQHandler(void)
{
 8001864:	b580      	push	{r7, lr}
 8001866:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI5_IRQn 0 */

  /* USER CODE END SPI5_IRQn 0 */
  HAL_I2S_IRQHandler(&hi2s5);
 8001868:	4802      	ldr	r0, [pc, #8]	@ (8001874 <SPI5_IRQHandler+0x10>)
 800186a:	f00b fe57 	bl	800d51c <HAL_I2S_IRQHandler>
  /* USER CODE BEGIN SPI5_IRQn 1 */

  /* USER CODE END SPI5_IRQn 1 */
}
 800186e:	bf00      	nop
 8001870:	bd80      	pop	{r7, pc}
 8001872:	bf00      	nop
 8001874:	200063d0 	.word	0x200063d0

08001878 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 8001878:	b480      	push	{r7}
 800187a:	af00      	add	r7, sp, #0
  return 1;
 800187c:	2301      	movs	r3, #1
}
 800187e:	4618      	mov	r0, r3
 8001880:	46bd      	mov	sp, r7
 8001882:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001886:	4770      	bx	lr

08001888 <_kill>:

int _kill(int pid, int sig)
{
 8001888:	b580      	push	{r7, lr}
 800188a:	b082      	sub	sp, #8
 800188c:	af00      	add	r7, sp, #0
 800188e:	6078      	str	r0, [r7, #4]
 8001890:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 8001892:	f020 fcd3 	bl	802223c <__errno>
 8001896:	4603      	mov	r3, r0
 8001898:	2216      	movs	r2, #22
 800189a:	601a      	str	r2, [r3, #0]
  return -1;
 800189c:	f04f 33ff 	mov.w	r3, #4294967295
}
 80018a0:	4618      	mov	r0, r3
 80018a2:	3708      	adds	r7, #8
 80018a4:	46bd      	mov	sp, r7
 80018a6:	bd80      	pop	{r7, pc}

080018a8 <_exit>:

void _exit (int status)
{
 80018a8:	b580      	push	{r7, lr}
 80018aa:	b082      	sub	sp, #8
 80018ac:	af00      	add	r7, sp, #0
 80018ae:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 80018b0:	f04f 31ff 	mov.w	r1, #4294967295
 80018b4:	6878      	ldr	r0, [r7, #4]
 80018b6:	f7ff ffe7 	bl	8001888 <_kill>
  while (1) {}    /* Make sure we hang here */
 80018ba:	bf00      	nop
 80018bc:	e7fd      	b.n	80018ba <_exit+0x12>

080018be <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80018be:	b580      	push	{r7, lr}
 80018c0:	b086      	sub	sp, #24
 80018c2:	af00      	add	r7, sp, #0
 80018c4:	60f8      	str	r0, [r7, #12]
 80018c6:	60b9      	str	r1, [r7, #8]
 80018c8:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80018ca:	2300      	movs	r3, #0
 80018cc:	617b      	str	r3, [r7, #20]
 80018ce:	e00a      	b.n	80018e6 <_read+0x28>
  {
    *ptr++ = __io_getchar();
 80018d0:	f3af 8000 	nop.w
 80018d4:	4601      	mov	r1, r0
 80018d6:	68bb      	ldr	r3, [r7, #8]
 80018d8:	1c5a      	adds	r2, r3, #1
 80018da:	60ba      	str	r2, [r7, #8]
 80018dc:	b2ca      	uxtb	r2, r1
 80018de:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 80018e0:	697b      	ldr	r3, [r7, #20]
 80018e2:	3301      	adds	r3, #1
 80018e4:	617b      	str	r3, [r7, #20]
 80018e6:	697a      	ldr	r2, [r7, #20]
 80018e8:	687b      	ldr	r3, [r7, #4]
 80018ea:	429a      	cmp	r2, r3
 80018ec:	dbf0      	blt.n	80018d0 <_read+0x12>
  }

  return len;
 80018ee:	687b      	ldr	r3, [r7, #4]
}
 80018f0:	4618      	mov	r0, r3
 80018f2:	3718      	adds	r7, #24
 80018f4:	46bd      	mov	sp, r7
 80018f6:	bd80      	pop	{r7, pc}

080018f8 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 80018f8:	b580      	push	{r7, lr}
 80018fa:	b086      	sub	sp, #24
 80018fc:	af00      	add	r7, sp, #0
 80018fe:	60f8      	str	r0, [r7, #12]
 8001900:	60b9      	str	r1, [r7, #8]
 8001902:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001904:	2300      	movs	r3, #0
 8001906:	617b      	str	r3, [r7, #20]
 8001908:	e009      	b.n	800191e <_write+0x26>
  {
    __io_putchar(*ptr++);
 800190a:	68bb      	ldr	r3, [r7, #8]
 800190c:	1c5a      	adds	r2, r3, #1
 800190e:	60ba      	str	r2, [r7, #8]
 8001910:	781b      	ldrb	r3, [r3, #0]
 8001912:	4618      	mov	r0, r3
 8001914:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001918:	697b      	ldr	r3, [r7, #20]
 800191a:	3301      	adds	r3, #1
 800191c:	617b      	str	r3, [r7, #20]
 800191e:	697a      	ldr	r2, [r7, #20]
 8001920:	687b      	ldr	r3, [r7, #4]
 8001922:	429a      	cmp	r2, r3
 8001924:	dbf1      	blt.n	800190a <_write+0x12>
  }
  return len;
 8001926:	687b      	ldr	r3, [r7, #4]
}
 8001928:	4618      	mov	r0, r3
 800192a:	3718      	adds	r7, #24
 800192c:	46bd      	mov	sp, r7
 800192e:	bd80      	pop	{r7, pc}

08001930 <_close>:

int _close(int file)
{
 8001930:	b480      	push	{r7}
 8001932:	b083      	sub	sp, #12
 8001934:	af00      	add	r7, sp, #0
 8001936:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 8001938:	f04f 33ff 	mov.w	r3, #4294967295
}
 800193c:	4618      	mov	r0, r3
 800193e:	370c      	adds	r7, #12
 8001940:	46bd      	mov	sp, r7
 8001942:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001946:	4770      	bx	lr

08001948 <_fstat>:


int _fstat(int file, struct stat *st)
{
 8001948:	b480      	push	{r7}
 800194a:	b083      	sub	sp, #12
 800194c:	af00      	add	r7, sp, #0
 800194e:	6078      	str	r0, [r7, #4]
 8001950:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 8001952:	683b      	ldr	r3, [r7, #0]
 8001954:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8001958:	605a      	str	r2, [r3, #4]
  return 0;
 800195a:	2300      	movs	r3, #0
}
 800195c:	4618      	mov	r0, r3
 800195e:	370c      	adds	r7, #12
 8001960:	46bd      	mov	sp, r7
 8001962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001966:	4770      	bx	lr

08001968 <_isatty>:

int _isatty(int file)
{
 8001968:	b480      	push	{r7}
 800196a:	b083      	sub	sp, #12
 800196c:	af00      	add	r7, sp, #0
 800196e:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 8001970:	2301      	movs	r3, #1
}
 8001972:	4618      	mov	r0, r3
 8001974:	370c      	adds	r7, #12
 8001976:	46bd      	mov	sp, r7
 8001978:	f85d 7b04 	ldr.w	r7, [sp], #4
 800197c:	4770      	bx	lr

0800197e <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 800197e:	b480      	push	{r7}
 8001980:	b085      	sub	sp, #20
 8001982:	af00      	add	r7, sp, #0
 8001984:	60f8      	str	r0, [r7, #12]
 8001986:	60b9      	str	r1, [r7, #8]
 8001988:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 800198a:	2300      	movs	r3, #0
}
 800198c:	4618      	mov	r0, r3
 800198e:	3714      	adds	r7, #20
 8001990:	46bd      	mov	sp, r7
 8001992:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001996:	4770      	bx	lr

08001998 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001998:	b580      	push	{r7, lr}
 800199a:	b086      	sub	sp, #24
 800199c:	af00      	add	r7, sp, #0
 800199e:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 80019a0:	4a14      	ldr	r2, [pc, #80]	@ (80019f4 <_sbrk+0x5c>)
 80019a2:	4b15      	ldr	r3, [pc, #84]	@ (80019f8 <_sbrk+0x60>)
 80019a4:	1ad3      	subs	r3, r2, r3
 80019a6:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 80019a8:	697b      	ldr	r3, [r7, #20]
 80019aa:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80019ac:	4b13      	ldr	r3, [pc, #76]	@ (80019fc <_sbrk+0x64>)
 80019ae:	681b      	ldr	r3, [r3, #0]
 80019b0:	2b00      	cmp	r3, #0
 80019b2:	d102      	bne.n	80019ba <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 80019b4:	4b11      	ldr	r3, [pc, #68]	@ (80019fc <_sbrk+0x64>)
 80019b6:	4a12      	ldr	r2, [pc, #72]	@ (8001a00 <_sbrk+0x68>)
 80019b8:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80019ba:	4b10      	ldr	r3, [pc, #64]	@ (80019fc <_sbrk+0x64>)
 80019bc:	681a      	ldr	r2, [r3, #0]
 80019be:	687b      	ldr	r3, [r7, #4]
 80019c0:	4413      	add	r3, r2
 80019c2:	693a      	ldr	r2, [r7, #16]
 80019c4:	429a      	cmp	r2, r3
 80019c6:	d207      	bcs.n	80019d8 <_sbrk+0x40>
  {
    errno = ENOMEM;
 80019c8:	f020 fc38 	bl	802223c <__errno>
 80019cc:	4603      	mov	r3, r0
 80019ce:	220c      	movs	r2, #12
 80019d0:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 80019d2:	f04f 33ff 	mov.w	r3, #4294967295
 80019d6:	e009      	b.n	80019ec <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80019d8:	4b08      	ldr	r3, [pc, #32]	@ (80019fc <_sbrk+0x64>)
 80019da:	681b      	ldr	r3, [r3, #0]
 80019dc:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 80019de:	4b07      	ldr	r3, [pc, #28]	@ (80019fc <_sbrk+0x64>)
 80019e0:	681a      	ldr	r2, [r3, #0]
 80019e2:	687b      	ldr	r3, [r7, #4]
 80019e4:	4413      	add	r3, r2
 80019e6:	4a05      	ldr	r2, [pc, #20]	@ (80019fc <_sbrk+0x64>)
 80019e8:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 80019ea:	68fb      	ldr	r3, [r7, #12]
}
 80019ec:	4618      	mov	r0, r3
 80019ee:	3718      	adds	r7, #24
 80019f0:	46bd      	mov	sp, r7
 80019f2:	bd80      	pop	{r7, pc}
 80019f4:	20020000 	.word	0x20020000
 80019f8:	00000400 	.word	0x00000400
 80019fc:	200004e0 	.word	0x200004e0
 8001a00:	20012310 	.word	0x20012310

08001a04 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8001a04:	b480      	push	{r7}
 8001a06:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001a08:	4b06      	ldr	r3, [pc, #24]	@ (8001a24 <SystemInit+0x20>)
 8001a0a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8001a0e:	4a05      	ldr	r2, [pc, #20]	@ (8001a24 <SystemInit+0x20>)
 8001a10:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 8001a14:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001a18:	bf00      	nop
 8001a1a:	46bd      	mov	sp, r7
 8001a1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a20:	4770      	bx	lr
 8001a22:	bf00      	nop
 8001a24:	e000ed00 	.word	0xe000ed00

08001a28 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    		 /* set stack pointer */
 8001a28:	f8df d034 	ldr.w	sp, [pc, #52]	@ 8001a60 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8001a2c:	f7ff ffea 	bl	8001a04 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
 8001a30:	480c      	ldr	r0, [pc, #48]	@ (8001a64 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8001a32:	490d      	ldr	r1, [pc, #52]	@ (8001a68 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001a34:	4a0d      	ldr	r2, [pc, #52]	@ (8001a6c <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001a36:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001a38:	e002      	b.n	8001a40 <LoopCopyDataInit>

08001a3a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001a3a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001a3c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001a3e:	3304      	adds	r3, #4

08001a40 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001a40:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001a42:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001a44:	d3f9      	bcc.n	8001a3a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001a46:	4a0a      	ldr	r2, [pc, #40]	@ (8001a70 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001a48:	4c0a      	ldr	r4, [pc, #40]	@ (8001a74 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001a4a:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001a4c:	e001      	b.n	8001a52 <LoopFillZerobss>

08001a4e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001a4e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001a50:	3204      	adds	r2, #4

08001a52 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001a52:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001a54:	d3fb      	bcc.n	8001a4e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001a56:	f020 fbf7 	bl	8022248 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001a5a:	f7ff fd93 	bl	8001584 <main>
  bx  lr    
 8001a5e:	4770      	bx	lr
  ldr   sp, =_estack    		 /* set stack pointer */
 8001a60:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001a64:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8001a68:	2000036c 	.word	0x2000036c
  ldr r2, =_sidata
 8001a6c:	08039660 	.word	0x08039660
  ldr r2, =_sbss
 8001a70:	20000380 	.word	0x20000380
  ldr r4, =_ebss
 8001a74:	2001230c 	.word	0x2001230c

08001a78 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001a78:	e7fe      	b.n	8001a78 <ADC_IRQHandler>

08001a7a <delay>:
#include "common.h"



void delay(uint32_t ms)
{
 8001a7a:	b580      	push	{r7, lr}
 8001a7c:	b082      	sub	sp, #8
 8001a7e:	af00      	add	r7, sp, #0
 8001a80:	6078      	str	r0, [r7, #4]
	HAL_Delay(ms);
 8001a82:	6878      	ldr	r0, [r7, #4]
 8001a84:	f007 f90a 	bl	8008c9c <HAL_Delay>
}
 8001a88:	bf00      	nop
 8001a8a:	3708      	adds	r7, #8
 8001a8c:	46bd      	mov	sp, r7
 8001a8e:	bd80      	pop	{r7, pc}

08001a90 <millis>:


uint32_t millis(void)
{
 8001a90:	b580      	push	{r7, lr}
 8001a92:	af00      	add	r7, sp, #0
	return HAL_GetTick();
 8001a94:	f007 f8f6 	bl	8008c84 <HAL_GetTick>
 8001a98:	4603      	mov	r3, r0
}
 8001a9a:	4618      	mov	r0, r3
 8001a9c:	bd80      	pop	{r7, pc}

08001a9e <qbufferCreate>:
{

}

bool qbufferCreate(qbuffer_t *p_node, uint8_t *p_buf, uint32_t len)
{
 8001a9e:	b480      	push	{r7}
 8001aa0:	b087      	sub	sp, #28
 8001aa2:	af00      	add	r7, sp, #0
 8001aa4:	60f8      	str	r0, [r7, #12]
 8001aa6:	60b9      	str	r1, [r7, #8]
 8001aa8:	607a      	str	r2, [r7, #4]
	bool ret = true;
 8001aaa:	2301      	movs	r3, #1
 8001aac:	75fb      	strb	r3, [r7, #23]

	p_node->in = 0;
 8001aae:	68fb      	ldr	r3, [r7, #12]
 8001ab0:	2200      	movs	r2, #0
 8001ab2:	601a      	str	r2, [r3, #0]
	p_node->out = 0;
 8001ab4:	68fb      	ldr	r3, [r7, #12]
 8001ab6:	2200      	movs	r2, #0
 8001ab8:	605a      	str	r2, [r3, #4]
	p_node->len = len;
 8001aba:	68fb      	ldr	r3, [r7, #12]
 8001abc:	687a      	ldr	r2, [r7, #4]
 8001abe:	609a      	str	r2, [r3, #8]
	p_node->p_buf = p_buf;
 8001ac0:	68fb      	ldr	r3, [r7, #12]
 8001ac2:	68ba      	ldr	r2, [r7, #8]
 8001ac4:	60da      	str	r2, [r3, #12]

	return ret;
 8001ac6:	7dfb      	ldrb	r3, [r7, #23]
}
 8001ac8:	4618      	mov	r0, r3
 8001aca:	371c      	adds	r7, #28
 8001acc:	46bd      	mov	sp, r7
 8001ace:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ad2:	4770      	bx	lr

08001ad4 <qbufferRead>:

	return ret;
}

bool qbufferRead(qbuffer_t *p_node, uint8_t *p_data, uint32_t len)
{
 8001ad4:	b480      	push	{r7}
 8001ad6:	b087      	sub	sp, #28
 8001ad8:	af00      	add	r7, sp, #0
 8001ada:	60f8      	str	r0, [r7, #12]
 8001adc:	60b9      	str	r1, [r7, #8]
 8001ade:	607a      	str	r2, [r7, #4]
	bool ret = true;
 8001ae0:	2301      	movs	r3, #1
 8001ae2:	75fb      	strb	r3, [r7, #23]

	for(int i=0; i<len; i++)
 8001ae4:	2300      	movs	r3, #0
 8001ae6:	613b      	str	r3, [r7, #16]
 8001ae8:	e026      	b.n	8001b38 <qbufferRead+0x64>
	{
		if(p_node->p_buf != NULL)
 8001aea:	68fb      	ldr	r3, [r7, #12]
 8001aec:	68db      	ldr	r3, [r3, #12]
 8001aee:	2b00      	cmp	r3, #0
 8001af0:	d009      	beq.n	8001b06 <qbufferRead+0x32>
		{
			p_data[i] = p_node->p_buf[p_node->out];
 8001af2:	68fb      	ldr	r3, [r7, #12]
 8001af4:	68da      	ldr	r2, [r3, #12]
 8001af6:	68fb      	ldr	r3, [r7, #12]
 8001af8:	685b      	ldr	r3, [r3, #4]
 8001afa:	441a      	add	r2, r3
 8001afc:	693b      	ldr	r3, [r7, #16]
 8001afe:	68b9      	ldr	r1, [r7, #8]
 8001b00:	440b      	add	r3, r1
 8001b02:	7812      	ldrb	r2, [r2, #0]
 8001b04:	701a      	strb	r2, [r3, #0]
		}

		if(p_node->out != p_node->in)
 8001b06:	68fb      	ldr	r3, [r7, #12]
 8001b08:	685a      	ldr	r2, [r3, #4]
 8001b0a:	68fb      	ldr	r3, [r7, #12]
 8001b0c:	681b      	ldr	r3, [r3, #0]
 8001b0e:	429a      	cmp	r2, r3
 8001b10:	d00c      	beq.n	8001b2c <qbufferRead+0x58>
		{
			p_node->out = (p_node->out + 1) % p_node->len;
 8001b12:	68fb      	ldr	r3, [r7, #12]
 8001b14:	685b      	ldr	r3, [r3, #4]
 8001b16:	3301      	adds	r3, #1
 8001b18:	68fa      	ldr	r2, [r7, #12]
 8001b1a:	6892      	ldr	r2, [r2, #8]
 8001b1c:	fbb3 f1f2 	udiv	r1, r3, r2
 8001b20:	fb01 f202 	mul.w	r2, r1, r2
 8001b24:	1a9a      	subs	r2, r3, r2
 8001b26:	68fb      	ldr	r3, [r7, #12]
 8001b28:	605a      	str	r2, [r3, #4]
 8001b2a:	e002      	b.n	8001b32 <qbufferRead+0x5e>
		}
		else
		{
			ret = false;
 8001b2c:	2300      	movs	r3, #0
 8001b2e:	75fb      	strb	r3, [r7, #23]
			break;
 8001b30:	e006      	b.n	8001b40 <qbufferRead+0x6c>
	for(int i=0; i<len; i++)
 8001b32:	693b      	ldr	r3, [r7, #16]
 8001b34:	3301      	adds	r3, #1
 8001b36:	613b      	str	r3, [r7, #16]
 8001b38:	693b      	ldr	r3, [r7, #16]
 8001b3a:	687a      	ldr	r2, [r7, #4]
 8001b3c:	429a      	cmp	r2, r3
 8001b3e:	d8d4      	bhi.n	8001aea <qbufferRead+0x16>
		}
	}

	return ret;
 8001b40:	7dfb      	ldrb	r3, [r7, #23]
}
 8001b42:	4618      	mov	r0, r3
 8001b44:	371c      	adds	r7, #28
 8001b46:	46bd      	mov	sp, r7
 8001b48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b4c:	4770      	bx	lr

08001b4e <qbufferAvailable>:
uint32_t qbufferAvailable(qbuffer_t *p_node)
{
 8001b4e:	b480      	push	{r7}
 8001b50:	b085      	sub	sp, #20
 8001b52:	af00      	add	r7, sp, #0
 8001b54:	6078      	str	r0, [r7, #4]
	uint32_t ret = (p_node->in - p_node->out) % p_node->len;
 8001b56:	687b      	ldr	r3, [r7, #4]
 8001b58:	681a      	ldr	r2, [r3, #0]
 8001b5a:	687b      	ldr	r3, [r7, #4]
 8001b5c:	685b      	ldr	r3, [r3, #4]
 8001b5e:	1ad3      	subs	r3, r2, r3
 8001b60:	687a      	ldr	r2, [r7, #4]
 8001b62:	6892      	ldr	r2, [r2, #8]
 8001b64:	fbb3 f1f2 	udiv	r1, r3, r2
 8001b68:	fb01 f202 	mul.w	r2, r1, r2
 8001b6c:	1a9b      	subs	r3, r3, r2
 8001b6e:	60fb      	str	r3, [r7, #12]
	return ret;
 8001b70:	68fb      	ldr	r3, [r7, #12]
}
 8001b72:	4618      	mov	r0, r3
 8001b74:	3714      	adds	r7, #20
 8001b76:	46bd      	mov	sp, r7
 8001b78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b7c:	4770      	bx	lr
	...

08001b80 <SD_CheckStatus>:
#endif /* _USE_IOCTL == 1 */
};

/* Private functions ---------------------------------------------------------*/
static DSTATUS SD_CheckStatus(BYTE lun)
{
 8001b80:	b580      	push	{r7, lr}
 8001b82:	b082      	sub	sp, #8
 8001b84:	af00      	add	r7, sp, #0
 8001b86:	4603      	mov	r3, r0
 8001b88:	71fb      	strb	r3, [r7, #7]
  Stat = 0;
 8001b8a:	4b1d      	ldr	r3, [pc, #116]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001b8c:	2200      	movs	r2, #0
 8001b8e:	701a      	strb	r2, [r3, #0]


  if (sdIsInit() != true)
 8001b90:	f006 f882 	bl	8007c98 <sdIsInit>
 8001b94:	4603      	mov	r3, r0
 8001b96:	f083 0301 	eor.w	r3, r3, #1
 8001b9a:	b2db      	uxtb	r3, r3
 8001b9c:	2b00      	cmp	r3, #0
 8001b9e:	d007      	beq.n	8001bb0 <SD_CheckStatus+0x30>
  {
    Stat |= STA_NOINIT;
 8001ba0:	4b17      	ldr	r3, [pc, #92]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001ba2:	781b      	ldrb	r3, [r3, #0]
 8001ba4:	b2db      	uxtb	r3, r3
 8001ba6:	f043 0301 	orr.w	r3, r3, #1
 8001baa:	b2da      	uxtb	r2, r3
 8001bac:	4b14      	ldr	r3, [pc, #80]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001bae:	701a      	strb	r2, [r3, #0]
  }
  if (sdIsDetected() != true)
 8001bb0:	f006 f87e 	bl	8007cb0 <sdIsDetected>
 8001bb4:	4603      	mov	r3, r0
 8001bb6:	f083 0301 	eor.w	r3, r3, #1
 8001bba:	b2db      	uxtb	r3, r3
 8001bbc:	2b00      	cmp	r3, #0
 8001bbe:	d007      	beq.n	8001bd0 <SD_CheckStatus+0x50>
  {
    Stat |= STA_NODISK;
 8001bc0:	4b0f      	ldr	r3, [pc, #60]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001bc2:	781b      	ldrb	r3, [r3, #0]
 8001bc4:	b2db      	uxtb	r3, r3
 8001bc6:	f043 0302 	orr.w	r3, r3, #2
 8001bca:	b2da      	uxtb	r2, r3
 8001bcc:	4b0c      	ldr	r3, [pc, #48]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001bce:	701a      	strb	r2, [r3, #0]
  }
  if (sdIsReady(10) != true)
 8001bd0:	200a      	movs	r0, #10
 8001bd2:	f006 f8f1 	bl	8007db8 <sdIsReady>
 8001bd6:	4603      	mov	r3, r0
 8001bd8:	f083 0301 	eor.w	r3, r3, #1
 8001bdc:	b2db      	uxtb	r3, r3
 8001bde:	2b00      	cmp	r3, #0
 8001be0:	d007      	beq.n	8001bf2 <SD_CheckStatus+0x72>
  {
    Stat |= STA_NOINIT;
 8001be2:	4b07      	ldr	r3, [pc, #28]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001be4:	781b      	ldrb	r3, [r3, #0]
 8001be6:	b2db      	uxtb	r3, r3
 8001be8:	f043 0301 	orr.w	r3, r3, #1
 8001bec:	b2da      	uxtb	r2, r3
 8001bee:	4b04      	ldr	r3, [pc, #16]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001bf0:	701a      	strb	r2, [r3, #0]
  }

  return Stat;
 8001bf2:	4b03      	ldr	r3, [pc, #12]	@ (8001c00 <SD_CheckStatus+0x80>)
 8001bf4:	781b      	ldrb	r3, [r3, #0]
 8001bf6:	b2db      	uxtb	r3, r3
}
 8001bf8:	4618      	mov	r0, r3
 8001bfa:	3708      	adds	r7, #8
 8001bfc:	46bd      	mov	sp, r7
 8001bfe:	bd80      	pop	{r7, pc}
 8001c00:	20000044 	.word	0x20000044

08001c04 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8001c04:	b580      	push	{r7, lr}
 8001c06:	b082      	sub	sp, #8
 8001c08:	af00      	add	r7, sp, #0
 8001c0a:	4603      	mov	r3, r0
 8001c0c:	71fb      	strb	r3, [r7, #7]
  Stat = 0;
 8001c0e:	4b0d      	ldr	r3, [pc, #52]	@ (8001c44 <SD_initialize+0x40>)
 8001c10:	2200      	movs	r2, #0
 8001c12:	701a      	strb	r2, [r3, #0]

  if (sdIsInit() != true)
 8001c14:	f006 f840 	bl	8007c98 <sdIsInit>
 8001c18:	4603      	mov	r3, r0
 8001c1a:	f083 0301 	eor.w	r3, r3, #1
 8001c1e:	b2db      	uxtb	r3, r3
 8001c20:	2b00      	cmp	r3, #0
 8001c22:	d007      	beq.n	8001c34 <SD_initialize+0x30>
  {
    Stat |= STA_NOINIT;
 8001c24:	4b07      	ldr	r3, [pc, #28]	@ (8001c44 <SD_initialize+0x40>)
 8001c26:	781b      	ldrb	r3, [r3, #0]
 8001c28:	b2db      	uxtb	r3, r3
 8001c2a:	f043 0301 	orr.w	r3, r3, #1
 8001c2e:	b2da      	uxtb	r2, r3
 8001c30:	4b04      	ldr	r3, [pc, #16]	@ (8001c44 <SD_initialize+0x40>)
 8001c32:	701a      	strb	r2, [r3, #0]
  }

  return Stat;
 8001c34:	4b03      	ldr	r3, [pc, #12]	@ (8001c44 <SD_initialize+0x40>)
 8001c36:	781b      	ldrb	r3, [r3, #0]
 8001c38:	b2db      	uxtb	r3, r3
}
 8001c3a:	4618      	mov	r0, r3
 8001c3c:	3708      	adds	r7, #8
 8001c3e:	46bd      	mov	sp, r7
 8001c40:	bd80      	pop	{r7, pc}
 8001c42:	bf00      	nop
 8001c44:	20000044 	.word	0x20000044

08001c48 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 8001c48:	b580      	push	{r7, lr}
 8001c4a:	b082      	sub	sp, #8
 8001c4c:	af00      	add	r7, sp, #0
 8001c4e:	4603      	mov	r3, r0
 8001c50:	71fb      	strb	r3, [r7, #7]
  return SD_CheckStatus(lun);
 8001c52:	79fb      	ldrb	r3, [r7, #7]
 8001c54:	4618      	mov	r0, r3
 8001c56:	f7ff ff93 	bl	8001b80 <SD_CheckStatus>
 8001c5a:	4603      	mov	r3, r0
}
 8001c5c:	4618      	mov	r0, r3
 8001c5e:	3708      	adds	r7, #8
 8001c60:	46bd      	mov	sp, r7
 8001c62:	bd80      	pop	{r7, pc}

08001c64 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8001c64:	b580      	push	{r7, lr}
 8001c66:	b086      	sub	sp, #24
 8001c68:	af00      	add	r7, sp, #0
 8001c6a:	60b9      	str	r1, [r7, #8]
 8001c6c:	607a      	str	r2, [r7, #4]
 8001c6e:	603b      	str	r3, [r7, #0]
 8001c70:	4603      	mov	r3, r0
 8001c72:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 8001c74:	2301      	movs	r3, #1
 8001c76:	75fb      	strb	r3, [r7, #23]


  if (sdReadBlocks(sector, buff, count, SD_TIMEOUT) == true)
 8001c78:	f242 7310 	movw	r3, #10000	@ 0x2710
 8001c7c:	683a      	ldr	r2, [r7, #0]
 8001c7e:	68b9      	ldr	r1, [r7, #8]
 8001c80:	6878      	ldr	r0, [r7, #4]
 8001c82:	f006 f8b9 	bl	8007df8 <sdReadBlocks>
 8001c86:	4603      	mov	r3, r0
 8001c88:	2b00      	cmp	r3, #0
 8001c8a:	d001      	beq.n	8001c90 <SD_read+0x2c>
  {
    res = RES_OK;
 8001c8c:	2300      	movs	r3, #0
 8001c8e:	75fb      	strb	r3, [r7, #23]
  }

  return res;
 8001c90:	7dfb      	ldrb	r3, [r7, #23]
}
 8001c92:	4618      	mov	r0, r3
 8001c94:	3718      	adds	r7, #24
 8001c96:	46bd      	mov	sp, r7
 8001c98:	bd80      	pop	{r7, pc}

08001c9a <SD_write>:
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
 8001c9a:	b580      	push	{r7, lr}
 8001c9c:	b086      	sub	sp, #24
 8001c9e:	af00      	add	r7, sp, #0
 8001ca0:	60b9      	str	r1, [r7, #8]
 8001ca2:	607a      	str	r2, [r7, #4]
 8001ca4:	603b      	str	r3, [r7, #0]
 8001ca6:	4603      	mov	r3, r0
 8001ca8:	73fb      	strb	r3, [r7, #15]
  DRESULT res = RES_ERROR;
 8001caa:	2301      	movs	r3, #1
 8001cac:	75fb      	strb	r3, [r7, #23]

  if (sdWriteBlocks(sector, (uint8_t *)buff, count, SD_TIMEOUT) == true)
 8001cae:	f242 7310 	movw	r3, #10000	@ 0x2710
 8001cb2:	683a      	ldr	r2, [r7, #0]
 8001cb4:	68b9      	ldr	r1, [r7, #8]
 8001cb6:	6878      	ldr	r0, [r7, #4]
 8001cb8:	f006 f8e8 	bl	8007e8c <sdWriteBlocks>
 8001cbc:	4603      	mov	r3, r0
 8001cbe:	2b00      	cmp	r3, #0
 8001cc0:	d001      	beq.n	8001cc6 <SD_write+0x2c>
  {
    res = RES_OK;
 8001cc2:	2300      	movs	r3, #0
 8001cc4:	75fb      	strb	r3, [r7, #23]
  }

  return res;
 8001cc6:	7dfb      	ldrb	r3, [r7, #23]
}
 8001cc8:	4618      	mov	r0, r3
 8001cca:	3718      	adds	r7, #24
 8001ccc:	46bd      	mov	sp, r7
 8001cce:	bd80      	pop	{r7, pc}

08001cd0 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8001cd0:	b580      	push	{r7, lr}
 8001cd2:	b08c      	sub	sp, #48	@ 0x30
 8001cd4:	af00      	add	r7, sp, #0
 8001cd6:	4603      	mov	r3, r0
 8001cd8:	603a      	str	r2, [r7, #0]
 8001cda:	71fb      	strb	r3, [r7, #7]
 8001cdc:	460b      	mov	r3, r1
 8001cde:	71bb      	strb	r3, [r7, #6]
  DRESULT res = RES_ERROR;
 8001ce0:	2301      	movs	r3, #1
 8001ce2:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  sd_info_t sd_info;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8001ce6:	4b25      	ldr	r3, [pc, #148]	@ (8001d7c <SD_ioctl+0xac>)
 8001ce8:	781b      	ldrb	r3, [r3, #0]
 8001cea:	b2db      	uxtb	r3, r3
 8001cec:	f003 0301 	and.w	r3, r3, #1
 8001cf0:	2b00      	cmp	r3, #0
 8001cf2:	d001      	beq.n	8001cf8 <SD_ioctl+0x28>
 8001cf4:	2303      	movs	r3, #3
 8001cf6:	e03c      	b.n	8001d72 <SD_ioctl+0xa2>

  switch (cmd)
 8001cf8:	79bb      	ldrb	r3, [r7, #6]
 8001cfa:	2b03      	cmp	r3, #3
 8001cfc:	d834      	bhi.n	8001d68 <SD_ioctl+0x98>
 8001cfe:	a201      	add	r2, pc, #4	@ (adr r2, 8001d04 <SD_ioctl+0x34>)
 8001d00:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001d04:	08001d15 	.word	0x08001d15
 8001d08:	08001d1d 	.word	0x08001d1d
 8001d0c:	08001d35 	.word	0x08001d35
 8001d10:	08001d4f 	.word	0x08001d4f
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC :
    res = RES_OK;
 8001d14:	2300      	movs	r3, #0
 8001d16:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    break;
 8001d1a:	e028      	b.n	8001d6e <SD_ioctl+0x9e>

  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    sdGetInfo(&sd_info);
 8001d1c:	f107 0308 	add.w	r3, r7, #8
 8001d20:	4618      	mov	r0, r3
 8001d22:	f005 ffdb 	bl	8007cdc <sdGetInfo>
    *(DWORD*)buff = sd_info.log_block_numbers;
 8001d26:	6a3a      	ldr	r2, [r7, #32]
 8001d28:	683b      	ldr	r3, [r7, #0]
 8001d2a:	601a      	str	r2, [r3, #0]
    res = RES_OK;
 8001d2c:	2300      	movs	r3, #0
 8001d2e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    break;
 8001d32:	e01c      	b.n	8001d6e <SD_ioctl+0x9e>

  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    sdGetInfo(&sd_info);
 8001d34:	f107 0308 	add.w	r3, r7, #8
 8001d38:	4618      	mov	r0, r3
 8001d3a:	f005 ffcf 	bl	8007cdc <sdGetInfo>
    *(WORD*)buff = sd_info.log_block_size;
 8001d3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001d40:	b29a      	uxth	r2, r3
 8001d42:	683b      	ldr	r3, [r7, #0]
 8001d44:	801a      	strh	r2, [r3, #0]
    res = RES_OK;
 8001d46:	2300      	movs	r3, #0
 8001d48:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    break;
 8001d4c:	e00f      	b.n	8001d6e <SD_ioctl+0x9e>

  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    sdGetInfo(&sd_info);
 8001d4e:	f107 0308 	add.w	r3, r7, #8
 8001d52:	4618      	mov	r0, r3
 8001d54:	f005 ffc2 	bl	8007cdc <sdGetInfo>
    *(DWORD*)buff = sd_info.log_block_size / SD_DEFAULT_BLOCK_SIZE;
 8001d58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8001d5a:	0a5a      	lsrs	r2, r3, #9
 8001d5c:	683b      	ldr	r3, [r7, #0]
 8001d5e:	601a      	str	r2, [r3, #0]
    res = RES_OK;
 8001d60:	2300      	movs	r3, #0
 8001d62:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    break;
 8001d66:	e002      	b.n	8001d6e <SD_ioctl+0x9e>

  default:
    res = RES_PARERR;
 8001d68:	2304      	movs	r3, #4
 8001d6a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  }

  return res;
 8001d6e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 8001d72:	4618      	mov	r0, r3
 8001d74:	3730      	adds	r7, #48	@ 0x30
 8001d76:	46bd      	mov	sp, r7
 8001d78:	bd80      	pop	{r7, pc}
 8001d7a:	bf00      	nop
 8001d7c:	20000044 	.word	0x20000044

08001d80 <hanFontLoad>:
void hanWanFontLoad(char *HanCode, han_font_t *FontPtr);
void hanUniFontLoad(char *HanCode, han_font_t *FontPtr);
uint16_t hanCnvCodeWan2Johab(uint16_t WanCode);

uint16_t hanFontLoad(char *HanCode, han_font_t *FontPtr)
{
 8001d80:	b580      	push	{r7, lr}
 8001d82:	b084      	sub	sp, #16
 8001d84:	af00      	add	r7, sp, #0
 8001d86:	6078      	str	r0, [r7, #4]
 8001d88:	6039      	str	r1, [r7, #0]
	// buffer reset
	memset(FontPtr->FontBuffer, 0x00, 32);
 8001d8a:	683b      	ldr	r3, [r7, #0]
 8001d8c:	3306      	adds	r3, #6
 8001d8e:	2220      	movs	r2, #32
 8001d90:	2100      	movs	r1, #0
 8001d92:	4618      	mov	r0, r3
 8001d94:	f020 f9b6 	bl	8022104 <memset>

	FontPtr->Code_Type = PHAN_NULL_CODE;
 8001d98:	683b      	ldr	r3, [r7, #0]
 8001d9a:	2200      	movs	r2, #0
 8001d9c:	809a      	strh	r2, [r3, #4]

	// Identifying if it's a Korean code
	if(!HanCode[0] || HanCode[0] == 0x0A)
 8001d9e:	687b      	ldr	r3, [r7, #4]
 8001da0:	781b      	ldrb	r3, [r3, #0]
 8001da2:	2b00      	cmp	r3, #0
 8001da4:	d003      	beq.n	8001dae <hanFontLoad+0x2e>
 8001da6:	687b      	ldr	r3, [r7, #4]
 8001da8:	781b      	ldrb	r3, [r3, #0]
 8001daa:	2b0a      	cmp	r3, #10
 8001dac:	d107      	bne.n	8001dbe <hanFontLoad+0x3e>
	{
		FontPtr->Code_Type = PHAN_END_CODE;
 8001dae:	683b      	ldr	r3, [r7, #0]
 8001db0:	2204      	movs	r2, #4
 8001db2:	809a      	strh	r2, [r3, #4]
		FontPtr->Size_Char = 1;
 8001db4:	683b      	ldr	r3, [r7, #0]
 8001db6:	2201      	movs	r2, #1
 8001db8:	805a      	strh	r2, [r3, #2]
		return PHAN_END_CODE;
 8001dba:	2304      	movs	r3, #4
 8001dbc:	e03b      	b.n	8001e36 <hanFontLoad+0xb6>
	}
	else if(HanCode[0] & 0x80)
 8001dbe:	687b      	ldr	r3, [r7, #4]
 8001dc0:	781b      	ldrb	r3, [r3, #0]
 8001dc2:	b25b      	sxtb	r3, r3
 8001dc4:	2b00      	cmp	r3, #0
 8001dc6:	da2b      	bge.n	8001e20 <hanFontLoad+0xa0>
	{
		uint32_t utf8_code;

		utf8_code = ((uint8_t)HanCode[0]<<16) | ((uint8_t)HanCode[1]<<8) | ((uint8_t)HanCode[2]<<0);
 8001dc8:	687b      	ldr	r3, [r7, #4]
 8001dca:	781b      	ldrb	r3, [r3, #0]
 8001dcc:	041a      	lsls	r2, r3, #16
 8001dce:	687b      	ldr	r3, [r7, #4]
 8001dd0:	3301      	adds	r3, #1
 8001dd2:	781b      	ldrb	r3, [r3, #0]
 8001dd4:	021b      	lsls	r3, r3, #8
 8001dd6:	4313      	orrs	r3, r2
 8001dd8:	687a      	ldr	r2, [r7, #4]
 8001dda:	3202      	adds	r2, #2
 8001ddc:	7812      	ldrb	r2, [r2, #0]
 8001dde:	4313      	orrs	r3, r2
 8001de0:	60fb      	str	r3, [r7, #12]

		if(utf8_code >= 0xEAB080 && utf8_code <= 0xED9FB0)
 8001de2:	68fb      	ldr	r3, [r7, #12]
 8001de4:	4a16      	ldr	r2, [pc, #88]	@ (8001e40 <hanFontLoad+0xc0>)
 8001de6:	4293      	cmp	r3, r2
 8001de8:	d30e      	bcc.n	8001e08 <hanFontLoad+0x88>
 8001dea:	68fb      	ldr	r3, [r7, #12]
 8001dec:	4a15      	ldr	r2, [pc, #84]	@ (8001e44 <hanFontLoad+0xc4>)
 8001dee:	4293      	cmp	r3, r2
 8001df0:	d80a      	bhi.n	8001e08 <hanFontLoad+0x88>
		{
			FontPtr->Code_Type = PHAN_HANGUL_CODE;
 8001df2:	683b      	ldr	r3, [r7, #0]
 8001df4:	2201      	movs	r2, #1
 8001df6:	809a      	strh	r2, [r3, #4]
			FontPtr->Size_Char = 3;
 8001df8:	683b      	ldr	r3, [r7, #0]
 8001dfa:	2203      	movs	r2, #3
 8001dfc:	805a      	strh	r2, [r3, #2]
			hanUniFontLoad(HanCode, FontPtr);
 8001dfe:	6839      	ldr	r1, [r7, #0]
 8001e00:	6878      	ldr	r0, [r7, #4]
 8001e02:	f000 f91f 	bl	8002044 <hanUniFontLoad>
 8001e06:	e009      	b.n	8001e1c <hanFontLoad+0x9c>
		}
		else
		{
			FontPtr->Code_Type = PHAN_HANGUL_CODE;
 8001e08:	683b      	ldr	r3, [r7, #0]
 8001e0a:	2201      	movs	r2, #1
 8001e0c:	809a      	strh	r2, [r3, #4]
			FontPtr->Size_Char = 2;
 8001e0e:	683b      	ldr	r3, [r7, #0]
 8001e10:	2202      	movs	r2, #2
 8001e12:	805a      	strh	r2, [r3, #2]
			hanWanFontLoad(HanCode, FontPtr);
 8001e14:	6839      	ldr	r1, [r7, #0]
 8001e16:	6878      	ldr	r0, [r7, #4]
 8001e18:	f000 f816 	bl	8001e48 <hanWanFontLoad>
		}

		return PHAN_HANGUL_CODE;
 8001e1c:	2301      	movs	r3, #1
 8001e1e:	e00a      	b.n	8001e36 <hanFontLoad+0xb6>
	}
	else // eng code
	{
		FontPtr->Code_Type = PHAN_ENG_CODE;
 8001e20:	683b      	ldr	r3, [r7, #0]
 8001e22:	2202      	movs	r2, #2
 8001e24:	809a      	strh	r2, [r3, #4]
		FontPtr->Size_Char = 1;
 8001e26:	683b      	ldr	r3, [r7, #0]
 8001e28:	2201      	movs	r2, #1
 8001e2a:	805a      	strh	r2, [r3, #2]
		hanEngFontLoad(HanCode, FontPtr);
 8001e2c:	6839      	ldr	r1, [r7, #0]
 8001e2e:	6878      	ldr	r0, [r7, #4]
 8001e30:	f000 fa30 	bl	8002294 <hanEngFontLoad>
		return PHAN_ENG_CODE;
 8001e34:	2302      	movs	r3, #2
	}

	return FontPtr->Code_Type;
}
 8001e36:	4618      	mov	r0, r3
 8001e38:	3710      	adds	r7, #16
 8001e3a:	46bd      	mov	sp, r7
 8001e3c:	bd80      	pop	{r7, pc}
 8001e3e:	bf00      	nop
 8001e40:	00eab080 	.word	0x00eab080
 8001e44:	00ed9fb0 	.word	0x00ed9fb0

08001e48 <hanWanFontLoad>:

//       
void hanWanFontLoad(char *HanCode, han_font_t *FontPtr)
{
 8001e48:	b580      	push	{r7, lr}
 8001e4a:	b084      	sub	sp, #16
 8001e4c:	af00      	add	r7, sp, #0
 8001e4e:	6078      	str	r0, [r7, #4]
 8001e50:	6039      	str	r1, [r7, #0]
	uint16_t wHanCode;

	// static declaration    .
	static uint16_t uChosung, uJoongsung, uJongsung, uChoType, uJooType, uJonType;

	wHanCode = (uint16_t)HanCode[0]<<8 | ((uint16_t)HanCode[1] & 0x00FF);
 8001e52:	687b      	ldr	r3, [r7, #4]
 8001e54:	781b      	ldrb	r3, [r3, #0]
 8001e56:	021b      	lsls	r3, r3, #8
 8001e58:	b21a      	sxth	r2, r3
 8001e5a:	687b      	ldr	r3, [r7, #4]
 8001e5c:	3301      	adds	r3, #1
 8001e5e:	781b      	ldrb	r3, [r3, #0]
 8001e60:	b21b      	sxth	r3, r3
 8001e62:	4313      	orrs	r3, r2
 8001e64:	b21b      	sxth	r3, r3
 8001e66:	81bb      	strh	r3, [r7, #12]
	wHanCode = hanCnvCodeWan2Johab(wHanCode);
 8001e68:	89bb      	ldrh	r3, [r7, #12]
 8001e6a:	4618      	mov	r0, r3
 8001e6c:	f000 fa3c 	bl	80022e8 <hanCnvCodeWan2Johab>
 8001e70:	4603      	mov	r3, r0
 8001e72:	81bb      	strh	r3, [r7, #12]

	// seperate phoneme code
	uChosung = (wHanCode>>10) & 0x001F; // Chosung code
 8001e74:	89bb      	ldrh	r3, [r7, #12]
 8001e76:	0a9b      	lsrs	r3, r3, #10
 8001e78:	b29b      	uxth	r3, r3
 8001e7a:	f003 031f 	and.w	r3, r3, #31
 8001e7e:	b29a      	uxth	r2, r3
 8001e80:	4b63      	ldr	r3, [pc, #396]	@ (8002010 <hanWanFontLoad+0x1c8>)
 8001e82:	801a      	strh	r2, [r3, #0]
  uJoongsung = (wHanCode>>5) & 0x001F;//Joongsung code
 8001e84:	89bb      	ldrh	r3, [r7, #12]
 8001e86:	095b      	lsrs	r3, r3, #5
 8001e88:	b29b      	uxth	r3, r3
 8001e8a:	f003 031f 	and.w	r3, r3, #31
 8001e8e:	b29a      	uxth	r2, r3
 8001e90:	4b60      	ldr	r3, [pc, #384]	@ (8002014 <hanWanFontLoad+0x1cc>)
 8001e92:	801a      	strh	r2, [r3, #0]
	uJongsung  = wHanCode & 0x001F;    //Jongsung code
 8001e94:	89bb      	ldrh	r3, [r7, #12]
 8001e96:	f003 031f 	and.w	r3, r3, #31
 8001e9a:	b29a      	uxth	r2, r3
 8001e9c:	4b5e      	ldr	r3, [pc, #376]	@ (8002018 <hanWanFontLoad+0x1d0>)
 8001e9e:	801a      	strh	r2, [r3, #0]

  //make font index
  uChosung   = ChoIdxTbl[uChosung];    //Chosung index
 8001ea0:	4b5b      	ldr	r3, [pc, #364]	@ (8002010 <hanWanFontLoad+0x1c8>)
 8001ea2:	881b      	ldrh	r3, [r3, #0]
 8001ea4:	461a      	mov	r2, r3
 8001ea6:	4b5d      	ldr	r3, [pc, #372]	@ (800201c <hanWanFontLoad+0x1d4>)
 8001ea8:	5c9b      	ldrb	r3, [r3, r2]
 8001eaa:	461a      	mov	r2, r3
 8001eac:	4b58      	ldr	r3, [pc, #352]	@ (8002010 <hanWanFontLoad+0x1c8>)
 8001eae:	801a      	strh	r2, [r3, #0]
  uJoongsung = JooIdxTbl[uJoongsung];  //Joongsung index
 8001eb0:	4b58      	ldr	r3, [pc, #352]	@ (8002014 <hanWanFontLoad+0x1cc>)
 8001eb2:	881b      	ldrh	r3, [r3, #0]
 8001eb4:	461a      	mov	r2, r3
 8001eb6:	4b5a      	ldr	r3, [pc, #360]	@ (8002020 <hanWanFontLoad+0x1d8>)
 8001eb8:	5c9b      	ldrb	r3, [r3, r2]
 8001eba:	461a      	mov	r2, r3
 8001ebc:	4b55      	ldr	r3, [pc, #340]	@ (8002014 <hanWanFontLoad+0x1cc>)
 8001ebe:	801a      	strh	r2, [r3, #0]
  uJongsung  = JonIdxTbl[uJongsung];   //Jongsung index
 8001ec0:	4b55      	ldr	r3, [pc, #340]	@ (8002018 <hanWanFontLoad+0x1d0>)
 8001ec2:	881b      	ldrh	r3, [r3, #0]
 8001ec4:	461a      	mov	r2, r3
 8001ec6:	4b57      	ldr	r3, [pc, #348]	@ (8002024 <hanWanFontLoad+0x1dc>)
 8001ec8:	5c9b      	ldrb	r3, [r3, r2]
 8001eca:	461a      	mov	r2, r3
 8001ecc:	4b52      	ldr	r3, [pc, #328]	@ (8002018 <hanWanFontLoad+0x1d0>)
 8001ece:	801a      	strh	r2, [r3, #0]

  //decide a character type (   )
  uChoType = uJongsung ? ChoTypeCaseJongYes[uJoongsung]:ChoTypeCaseJongNo [uJoongsung];
 8001ed0:	4b51      	ldr	r3, [pc, #324]	@ (8002018 <hanWanFontLoad+0x1d0>)
 8001ed2:	881b      	ldrh	r3, [r3, #0]
 8001ed4:	2b00      	cmp	r3, #0
 8001ed6:	d006      	beq.n	8001ee6 <hanWanFontLoad+0x9e>
 8001ed8:	4b4e      	ldr	r3, [pc, #312]	@ (8002014 <hanWanFontLoad+0x1cc>)
 8001eda:	881b      	ldrh	r3, [r3, #0]
 8001edc:	461a      	mov	r2, r3
 8001ede:	4b52      	ldr	r3, [pc, #328]	@ (8002028 <hanWanFontLoad+0x1e0>)
 8001ee0:	5c9b      	ldrb	r3, [r3, r2]
 8001ee2:	461a      	mov	r2, r3
 8001ee4:	e005      	b.n	8001ef2 <hanWanFontLoad+0xaa>
 8001ee6:	4b4b      	ldr	r3, [pc, #300]	@ (8002014 <hanWanFontLoad+0x1cc>)
 8001ee8:	881b      	ldrh	r3, [r3, #0]
 8001eea:	461a      	mov	r2, r3
 8001eec:	4b4f      	ldr	r3, [pc, #316]	@ (800202c <hanWanFontLoad+0x1e4>)
 8001eee:	5c9b      	ldrb	r3, [r3, r2]
 8001ef0:	461a      	mov	r2, r3
 8001ef2:	4b4f      	ldr	r3, [pc, #316]	@ (8002030 <hanWanFontLoad+0x1e8>)
 8001ef4:	801a      	strh	r2, [r3, #0]

  //''(1)  ''(16) 
  uJooType = ((uChosung == 0 || uChosung == 1 || uChosung == 16 ) ? 0: 1) + (uJongsung ? 2 : 0);
 8001ef6:	4b46      	ldr	r3, [pc, #280]	@ (8002010 <hanWanFontLoad+0x1c8>)
 8001ef8:	881b      	ldrh	r3, [r3, #0]
 8001efa:	2b00      	cmp	r3, #0
 8001efc:	d009      	beq.n	8001f12 <hanWanFontLoad+0xca>
 8001efe:	4b44      	ldr	r3, [pc, #272]	@ (8002010 <hanWanFontLoad+0x1c8>)
 8001f00:	881b      	ldrh	r3, [r3, #0]
 8001f02:	2b01      	cmp	r3, #1
 8001f04:	d005      	beq.n	8001f12 <hanWanFontLoad+0xca>
 8001f06:	4b42      	ldr	r3, [pc, #264]	@ (8002010 <hanWanFontLoad+0x1c8>)
 8001f08:	881b      	ldrh	r3, [r3, #0]
 8001f0a:	2b10      	cmp	r3, #16
 8001f0c:	d001      	beq.n	8001f12 <hanWanFontLoad+0xca>
 8001f0e:	2301      	movs	r3, #1
 8001f10:	e000      	b.n	8001f14 <hanWanFontLoad+0xcc>
 8001f12:	2300      	movs	r3, #0
 8001f14:	b29b      	uxth	r3, r3
 8001f16:	4a40      	ldr	r2, [pc, #256]	@ (8002018 <hanWanFontLoad+0x1d0>)
 8001f18:	8812      	ldrh	r2, [r2, #0]
 8001f1a:	2a00      	cmp	r2, #0
 8001f1c:	d001      	beq.n	8001f22 <hanWanFontLoad+0xda>
 8001f1e:	2202      	movs	r2, #2
 8001f20:	e000      	b.n	8001f24 <hanWanFontLoad+0xdc>
 8001f22:	2200      	movs	r2, #0
 8001f24:	4413      	add	r3, r2
 8001f26:	b29a      	uxth	r2, r3
 8001f28:	4b42      	ldr	r3, [pc, #264]	@ (8002034 <hanWanFontLoad+0x1ec>)
 8001f2a:	801a      	strh	r2, [r3, #0]
  uJonType = JonType[uJoongsung];
 8001f2c:	4b39      	ldr	r3, [pc, #228]	@ (8002014 <hanWanFontLoad+0x1cc>)
 8001f2e:	881b      	ldrh	r3, [r3, #0]
 8001f30:	461a      	mov	r2, r3
 8001f32:	4b41      	ldr	r3, [pc, #260]	@ (8002038 <hanWanFontLoad+0x1f0>)
 8001f34:	5c9b      	ldrb	r3, [r3, r2]
 8001f36:	461a      	mov	r2, r3
 8001f38:	4b40      	ldr	r3, [pc, #256]	@ (800203c <hanWanFontLoad+0x1f4>)
 8001f3a:	801a      	strh	r2, [r3, #0]

  for(i = 0; i<32; i++)
 8001f3c:	2300      	movs	r3, #0
 8001f3e:	81fb      	strh	r3, [r7, #14]
 8001f40:	e035      	b.n	8001fae <hanWanFontLoad+0x166>
  {
    FontPtr->FontBuffer[i]  = K_font[uChoType*20+uChosung][i];
 8001f42:	4b3b      	ldr	r3, [pc, #236]	@ (8002030 <hanWanFontLoad+0x1e8>)
 8001f44:	881b      	ldrh	r3, [r3, #0]
 8001f46:	461a      	mov	r2, r3
 8001f48:	4613      	mov	r3, r2
 8001f4a:	009b      	lsls	r3, r3, #2
 8001f4c:	4413      	add	r3, r2
 8001f4e:	009b      	lsls	r3, r3, #2
 8001f50:	461a      	mov	r2, r3
 8001f52:	4b2f      	ldr	r3, [pc, #188]	@ (8002010 <hanWanFontLoad+0x1c8>)
 8001f54:	881b      	ldrh	r3, [r3, #0]
 8001f56:	441a      	add	r2, r3
 8001f58:	89fb      	ldrh	r3, [r7, #14]
 8001f5a:	4939      	ldr	r1, [pc, #228]	@ (8002040 <hanWanFontLoad+0x1f8>)
 8001f5c:	0152      	lsls	r2, r2, #5
 8001f5e:	4413      	add	r3, r2
 8001f60:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
 8001f64:	89fb      	ldrh	r3, [r7, #14]
 8001f66:	b2d1      	uxtb	r1, r2
 8001f68:	683a      	ldr	r2, [r7, #0]
 8001f6a:	4413      	add	r3, r2
 8001f6c:	460a      	mov	r2, r1
 8001f6e:	719a      	strb	r2, [r3, #6]
    FontPtr->FontBuffer[i] |= K_font[160 + uJooType*22+uJoongsung][i];
 8001f70:	89fb      	ldrh	r3, [r7, #14]
 8001f72:	683a      	ldr	r2, [r7, #0]
 8001f74:	4413      	add	r3, r2
 8001f76:	7999      	ldrb	r1, [r3, #6]
 8001f78:	4b2e      	ldr	r3, [pc, #184]	@ (8002034 <hanWanFontLoad+0x1ec>)
 8001f7a:	881b      	ldrh	r3, [r3, #0]
 8001f7c:	461a      	mov	r2, r3
 8001f7e:	2316      	movs	r3, #22
 8001f80:	fb02 f303 	mul.w	r3, r2, r3
 8001f84:	33a0      	adds	r3, #160	@ 0xa0
 8001f86:	4a23      	ldr	r2, [pc, #140]	@ (8002014 <hanWanFontLoad+0x1cc>)
 8001f88:	8812      	ldrh	r2, [r2, #0]
 8001f8a:	441a      	add	r2, r3
 8001f8c:	89fb      	ldrh	r3, [r7, #14]
 8001f8e:	482c      	ldr	r0, [pc, #176]	@ (8002040 <hanWanFontLoad+0x1f8>)
 8001f90:	0152      	lsls	r2, r2, #5
 8001f92:	4413      	add	r3, r2
 8001f94:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
 8001f98:	b2da      	uxtb	r2, r3
 8001f9a:	89fb      	ldrh	r3, [r7, #14]
 8001f9c:	430a      	orrs	r2, r1
 8001f9e:	b2d1      	uxtb	r1, r2
 8001fa0:	683a      	ldr	r2, [r7, #0]
 8001fa2:	4413      	add	r3, r2
 8001fa4:	460a      	mov	r2, r1
 8001fa6:	719a      	strb	r2, [r3, #6]
  for(i = 0; i<32; i++)
 8001fa8:	89fb      	ldrh	r3, [r7, #14]
 8001faa:	3301      	adds	r3, #1
 8001fac:	81fb      	strh	r3, [r7, #14]
 8001fae:	89fb      	ldrh	r3, [r7, #14]
 8001fb0:	2b1f      	cmp	r3, #31
 8001fb2:	d9c6      	bls.n	8001f42 <hanWanFontLoad+0xfa>
  }

  //combine Jongsung
  if(uJongsung)
 8001fb4:	4b18      	ldr	r3, [pc, #96]	@ (8002018 <hanWanFontLoad+0x1d0>)
 8001fb6:	881b      	ldrh	r3, [r3, #0]
 8001fb8:	2b00      	cmp	r3, #0
 8001fba:	d025      	beq.n	8002008 <hanWanFontLoad+0x1c0>
  {
    for(i = 0; i < 32; i++)   FontPtr->FontBuffer[i] |= K_font[248 + uJonType*28+uJongsung][i];
 8001fbc:	2300      	movs	r3, #0
 8001fbe:	81fb      	strh	r3, [r7, #14]
 8001fc0:	e01f      	b.n	8002002 <hanWanFontLoad+0x1ba>
 8001fc2:	89fb      	ldrh	r3, [r7, #14]
 8001fc4:	683a      	ldr	r2, [r7, #0]
 8001fc6:	4413      	add	r3, r2
 8001fc8:	7999      	ldrb	r1, [r3, #6]
 8001fca:	4b1c      	ldr	r3, [pc, #112]	@ (800203c <hanWanFontLoad+0x1f4>)
 8001fcc:	881b      	ldrh	r3, [r3, #0]
 8001fce:	461a      	mov	r2, r3
 8001fd0:	4613      	mov	r3, r2
 8001fd2:	00db      	lsls	r3, r3, #3
 8001fd4:	1a9b      	subs	r3, r3, r2
 8001fd6:	009b      	lsls	r3, r3, #2
 8001fd8:	33f8      	adds	r3, #248	@ 0xf8
 8001fda:	4a0f      	ldr	r2, [pc, #60]	@ (8002018 <hanWanFontLoad+0x1d0>)
 8001fdc:	8812      	ldrh	r2, [r2, #0]
 8001fde:	441a      	add	r2, r3
 8001fe0:	89fb      	ldrh	r3, [r7, #14]
 8001fe2:	4817      	ldr	r0, [pc, #92]	@ (8002040 <hanWanFontLoad+0x1f8>)
 8001fe4:	0152      	lsls	r2, r2, #5
 8001fe6:	4413      	add	r3, r2
 8001fe8:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
 8001fec:	b2da      	uxtb	r2, r3
 8001fee:	89fb      	ldrh	r3, [r7, #14]
 8001ff0:	430a      	orrs	r2, r1
 8001ff2:	b2d1      	uxtb	r1, r2
 8001ff4:	683a      	ldr	r2, [r7, #0]
 8001ff6:	4413      	add	r3, r2
 8001ff8:	460a      	mov	r2, r1
 8001ffa:	719a      	strb	r2, [r3, #6]
 8001ffc:	89fb      	ldrh	r3, [r7, #14]
 8001ffe:	3301      	adds	r3, #1
 8002000:	81fb      	strh	r3, [r7, #14]
 8002002:	89fb      	ldrh	r3, [r7, #14]
 8002004:	2b1f      	cmp	r3, #31
 8002006:	d9dc      	bls.n	8001fc2 <hanWanFontLoad+0x17a>
  }
}
 8002008:	bf00      	nop
 800200a:	3710      	adds	r7, #16
 800200c:	46bd      	mov	sp, r7
 800200e:	bd80      	pop	{r7, pc}
 8002010:	200004e4 	.word	0x200004e4
 8002014:	200004e6 	.word	0x200004e6
 8002018:	200004e8 	.word	0x200004e8
 800201c:	08026850 	.word	0x08026850
 8002020:	08026870 	.word	0x08026870
 8002024:	08026890 	.word	0x08026890
 8002028:	08026928 	.word	0x08026928
 800202c:	08026910 	.word	0x08026910
 8002030:	200004ea 	.word	0x200004ea
 8002034:	200004ec 	.word	0x200004ec
 8002038:	08026940 	.word	0x08026940
 800203c:	200004ee 	.word	0x200004ee
 8002040:	08028e40 	.word	0x08028e40

08002044 <hanUniFontLoad>:

//     
void hanUniFontLoad(char *HanCode, han_font_t *FontPtr)
{
 8002044:	b480      	push	{r7}
 8002046:	b085      	sub	sp, #20
 8002048:	af00      	add	r7, sp, #0
 800204a:	6078      	str	r0, [r7, #4]
 800204c:	6039      	str	r1, [r7, #0]
  uint16_t utf16;

  //static declaration    .
  static uint16_t uChosung, uJoongsung, uJongsung, uChoType, uJooType,uJonType;

  utf16 = (uint8_t)(HanCode[0] & 0x0f) << 12 | (uint8_t)(HanCode[1] & 0x3f) << 6 | (uint8_t)(HanCode[2] & 0x3f);
 800204e:	687b      	ldr	r3, [r7, #4]
 8002050:	781b      	ldrb	r3, [r3, #0]
 8002052:	031b      	lsls	r3, r3, #12
 8002054:	b21a      	sxth	r2, r3
 8002056:	687b      	ldr	r3, [r7, #4]
 8002058:	3301      	adds	r3, #1
 800205a:	781b      	ldrb	r3, [r3, #0]
 800205c:	019b      	lsls	r3, r3, #6
 800205e:	b21b      	sxth	r3, r3
 8002060:	f403 637c 	and.w	r3, r3, #4032	@ 0xfc0
 8002064:	b21b      	sxth	r3, r3
 8002066:	4313      	orrs	r3, r2
 8002068:	b21a      	sxth	r2, r3
 800206a:	687b      	ldr	r3, [r7, #4]
 800206c:	3302      	adds	r3, #2
 800206e:	781b      	ldrb	r3, [r3, #0]
 8002070:	b21b      	sxth	r3, r3
 8002072:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8002076:	b21b      	sxth	r3, r3
 8002078:	4313      	orrs	r3, r2
 800207a:	b21b      	sxth	r3, r3
 800207c:	81bb      	strh	r3, [r7, #12]

  //seperate phoneme code
  utf16 -= 0xac00;
 800207e:	89bb      	ldrh	r3, [r7, #12]
 8002080:	f503 43a8 	add.w	r3, r3, #21504	@ 0x5400
 8002084:	81bb      	strh	r3, [r7, #12]
  uJongsung  = utf16 % 28;
 8002086:	89ba      	ldrh	r2, [r7, #12]
 8002088:	0893      	lsrs	r3, r2, #2
 800208a:	4973      	ldr	r1, [pc, #460]	@ (8002258 <hanUniFontLoad+0x214>)
 800208c:	fba1 3103 	umull	r3, r1, r1, r3
 8002090:	460b      	mov	r3, r1
 8002092:	00db      	lsls	r3, r3, #3
 8002094:	1a5b      	subs	r3, r3, r1
 8002096:	009b      	lsls	r3, r3, #2
 8002098:	1ad3      	subs	r3, r2, r3
 800209a:	b29a      	uxth	r2, r3
 800209c:	4b6f      	ldr	r3, [pc, #444]	@ (800225c <hanUniFontLoad+0x218>)
 800209e:	801a      	strh	r2, [r3, #0]
  utf16 /= 28;
 80020a0:	89bb      	ldrh	r3, [r7, #12]
 80020a2:	089b      	lsrs	r3, r3, #2
 80020a4:	4a6c      	ldr	r2, [pc, #432]	@ (8002258 <hanUniFontLoad+0x214>)
 80020a6:	fba2 2303 	umull	r2, r3, r2, r3
 80020aa:	81bb      	strh	r3, [r7, #12]
  uJoongsung = utf16 % 21;
 80020ac:	89b9      	ldrh	r1, [r7, #12]
 80020ae:	4b6c      	ldr	r3, [pc, #432]	@ (8002260 <hanUniFontLoad+0x21c>)
 80020b0:	fba3 2301 	umull	r2, r3, r3, r1
 80020b4:	1aca      	subs	r2, r1, r3
 80020b6:	0852      	lsrs	r2, r2, #1
 80020b8:	4413      	add	r3, r2
 80020ba:	091a      	lsrs	r2, r3, #4
 80020bc:	4613      	mov	r3, r2
 80020be:	005b      	lsls	r3, r3, #1
 80020c0:	4413      	add	r3, r2
 80020c2:	00da      	lsls	r2, r3, #3
 80020c4:	1ad2      	subs	r2, r2, r3
 80020c6:	1a8b      	subs	r3, r1, r2
 80020c8:	b29a      	uxth	r2, r3
 80020ca:	4b66      	ldr	r3, [pc, #408]	@ (8002264 <hanUniFontLoad+0x220>)
 80020cc:	801a      	strh	r2, [r3, #0]
  uChosung   = utf16 / 21;
 80020ce:	89ba      	ldrh	r2, [r7, #12]
 80020d0:	4b63      	ldr	r3, [pc, #396]	@ (8002260 <hanUniFontLoad+0x21c>)
 80020d2:	fba3 1302 	umull	r1, r3, r3, r2
 80020d6:	1ad2      	subs	r2, r2, r3
 80020d8:	0852      	lsrs	r2, r2, #1
 80020da:	4413      	add	r3, r2
 80020dc:	091b      	lsrs	r3, r3, #4
 80020de:	b29a      	uxth	r2, r3
 80020e0:	4b61      	ldr	r3, [pc, #388]	@ (8002268 <hanUniFontLoad+0x224>)
 80020e2:	801a      	strh	r2, [r3, #0]

  //make font index
  uChosung   = UniChoIdxTbl[uChosung];    //Chosung index
 80020e4:	4b60      	ldr	r3, [pc, #384]	@ (8002268 <hanUniFontLoad+0x224>)
 80020e6:	881b      	ldrh	r3, [r3, #0]
 80020e8:	461a      	mov	r2, r3
 80020ea:	4b60      	ldr	r3, [pc, #384]	@ (800226c <hanUniFontLoad+0x228>)
 80020ec:	5c9b      	ldrb	r3, [r3, r2]
 80020ee:	461a      	mov	r2, r3
 80020f0:	4b5d      	ldr	r3, [pc, #372]	@ (8002268 <hanUniFontLoad+0x224>)
 80020f2:	801a      	strh	r2, [r3, #0]
  uJoongsung = UniJooIdxTbl[uJoongsung];  //Joongsung index
 80020f4:	4b5b      	ldr	r3, [pc, #364]	@ (8002264 <hanUniFontLoad+0x220>)
 80020f6:	881b      	ldrh	r3, [r3, #0]
 80020f8:	461a      	mov	r2, r3
 80020fa:	4b5d      	ldr	r3, [pc, #372]	@ (8002270 <hanUniFontLoad+0x22c>)
 80020fc:	5c9b      	ldrb	r3, [r3, r2]
 80020fe:	461a      	mov	r2, r3
 8002100:	4b58      	ldr	r3, [pc, #352]	@ (8002264 <hanUniFontLoad+0x220>)
 8002102:	801a      	strh	r2, [r3, #0]
  uJongsung  = UniJonIdxTbl[uJongsung];   //Jongsung index
 8002104:	4b55      	ldr	r3, [pc, #340]	@ (800225c <hanUniFontLoad+0x218>)
 8002106:	881b      	ldrh	r3, [r3, #0]
 8002108:	461a      	mov	r2, r3
 800210a:	4b5a      	ldr	r3, [pc, #360]	@ (8002274 <hanUniFontLoad+0x230>)
 800210c:	5c9b      	ldrb	r3, [r3, r2]
 800210e:	461a      	mov	r2, r3
 8002110:	4b52      	ldr	r3, [pc, #328]	@ (800225c <hanUniFontLoad+0x218>)
 8002112:	801a      	strh	r2, [r3, #0]

  //decide a character type (   )
  uChoType = uJongsung ? ChoTypeCaseJongYes[uJoongsung]:ChoTypeCaseJongNo [uJoongsung];
 8002114:	4b51      	ldr	r3, [pc, #324]	@ (800225c <hanUniFontLoad+0x218>)
 8002116:	881b      	ldrh	r3, [r3, #0]
 8002118:	2b00      	cmp	r3, #0
 800211a:	d006      	beq.n	800212a <hanUniFontLoad+0xe6>
 800211c:	4b51      	ldr	r3, [pc, #324]	@ (8002264 <hanUniFontLoad+0x220>)
 800211e:	881b      	ldrh	r3, [r3, #0]
 8002120:	461a      	mov	r2, r3
 8002122:	4b55      	ldr	r3, [pc, #340]	@ (8002278 <hanUniFontLoad+0x234>)
 8002124:	5c9b      	ldrb	r3, [r3, r2]
 8002126:	461a      	mov	r2, r3
 8002128:	e005      	b.n	8002136 <hanUniFontLoad+0xf2>
 800212a:	4b4e      	ldr	r3, [pc, #312]	@ (8002264 <hanUniFontLoad+0x220>)
 800212c:	881b      	ldrh	r3, [r3, #0]
 800212e:	461a      	mov	r2, r3
 8002130:	4b52      	ldr	r3, [pc, #328]	@ (800227c <hanUniFontLoad+0x238>)
 8002132:	5c9b      	ldrb	r3, [r3, r2]
 8002134:	461a      	mov	r2, r3
 8002136:	4b52      	ldr	r3, [pc, #328]	@ (8002280 <hanUniFontLoad+0x23c>)
 8002138:	801a      	strh	r2, [r3, #0]

  //''(1)  ''(16) 
  uJooType = ((uChosung == 0 || uChosung == 1 ||uChosung == 16 ) ? 0: 1) + (uJongsung ? 2: 0);
 800213a:	4b4b      	ldr	r3, [pc, #300]	@ (8002268 <hanUniFontLoad+0x224>)
 800213c:	881b      	ldrh	r3, [r3, #0]
 800213e:	2b00      	cmp	r3, #0
 8002140:	d009      	beq.n	8002156 <hanUniFontLoad+0x112>
 8002142:	4b49      	ldr	r3, [pc, #292]	@ (8002268 <hanUniFontLoad+0x224>)
 8002144:	881b      	ldrh	r3, [r3, #0]
 8002146:	2b01      	cmp	r3, #1
 8002148:	d005      	beq.n	8002156 <hanUniFontLoad+0x112>
 800214a:	4b47      	ldr	r3, [pc, #284]	@ (8002268 <hanUniFontLoad+0x224>)
 800214c:	881b      	ldrh	r3, [r3, #0]
 800214e:	2b10      	cmp	r3, #16
 8002150:	d001      	beq.n	8002156 <hanUniFontLoad+0x112>
 8002152:	2301      	movs	r3, #1
 8002154:	e000      	b.n	8002158 <hanUniFontLoad+0x114>
 8002156:	2300      	movs	r3, #0
 8002158:	b29b      	uxth	r3, r3
 800215a:	4a40      	ldr	r2, [pc, #256]	@ (800225c <hanUniFontLoad+0x218>)
 800215c:	8812      	ldrh	r2, [r2, #0]
 800215e:	2a00      	cmp	r2, #0
 8002160:	d001      	beq.n	8002166 <hanUniFontLoad+0x122>
 8002162:	2202      	movs	r2, #2
 8002164:	e000      	b.n	8002168 <hanUniFontLoad+0x124>
 8002166:	2200      	movs	r2, #0
 8002168:	4413      	add	r3, r2
 800216a:	b29a      	uxth	r2, r3
 800216c:	4b45      	ldr	r3, [pc, #276]	@ (8002284 <hanUniFontLoad+0x240>)
 800216e:	801a      	strh	r2, [r3, #0]
  uJonType = JonType[uJoongsung];
 8002170:	4b3c      	ldr	r3, [pc, #240]	@ (8002264 <hanUniFontLoad+0x220>)
 8002172:	881b      	ldrh	r3, [r3, #0]
 8002174:	461a      	mov	r2, r3
 8002176:	4b44      	ldr	r3, [pc, #272]	@ (8002288 <hanUniFontLoad+0x244>)
 8002178:	5c9b      	ldrb	r3, [r3, r2]
 800217a:	461a      	mov	r2, r3
 800217c:	4b43      	ldr	r3, [pc, #268]	@ (800228c <hanUniFontLoad+0x248>)
 800217e:	801a      	strh	r2, [r3, #0]

  for(i = 0; i<32; i++)
 8002180:	2300      	movs	r3, #0
 8002182:	81fb      	strh	r3, [r7, #14]
 8002184:	e035      	b.n	80021f2 <hanUniFontLoad+0x1ae>
  {
    FontPtr->FontBuffer[i]  = (uint8_t)K_font[uChoType*20+uChosung][i];
 8002186:	4b3e      	ldr	r3, [pc, #248]	@ (8002280 <hanUniFontLoad+0x23c>)
 8002188:	881b      	ldrh	r3, [r3, #0]
 800218a:	461a      	mov	r2, r3
 800218c:	4613      	mov	r3, r2
 800218e:	009b      	lsls	r3, r3, #2
 8002190:	4413      	add	r3, r2
 8002192:	009b      	lsls	r3, r3, #2
 8002194:	461a      	mov	r2, r3
 8002196:	4b34      	ldr	r3, [pc, #208]	@ (8002268 <hanUniFontLoad+0x224>)
 8002198:	881b      	ldrh	r3, [r3, #0]
 800219a:	441a      	add	r2, r3
 800219c:	89fb      	ldrh	r3, [r7, #14]
 800219e:	493c      	ldr	r1, [pc, #240]	@ (8002290 <hanUniFontLoad+0x24c>)
 80021a0:	0152      	lsls	r2, r2, #5
 80021a2:	4413      	add	r3, r2
 80021a4:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
 80021a8:	89fb      	ldrh	r3, [r7, #14]
 80021aa:	b2d1      	uxtb	r1, r2
 80021ac:	683a      	ldr	r2, [r7, #0]
 80021ae:	4413      	add	r3, r2
 80021b0:	460a      	mov	r2, r1
 80021b2:	719a      	strb	r2, [r3, #6]
    FontPtr->FontBuffer[i] |= (uint8_t)K_font[160 + uJooType*22+uJoongsung][i];
 80021b4:	89fb      	ldrh	r3, [r7, #14]
 80021b6:	683a      	ldr	r2, [r7, #0]
 80021b8:	4413      	add	r3, r2
 80021ba:	7999      	ldrb	r1, [r3, #6]
 80021bc:	4b31      	ldr	r3, [pc, #196]	@ (8002284 <hanUniFontLoad+0x240>)
 80021be:	881b      	ldrh	r3, [r3, #0]
 80021c0:	461a      	mov	r2, r3
 80021c2:	2316      	movs	r3, #22
 80021c4:	fb02 f303 	mul.w	r3, r2, r3
 80021c8:	33a0      	adds	r3, #160	@ 0xa0
 80021ca:	4a26      	ldr	r2, [pc, #152]	@ (8002264 <hanUniFontLoad+0x220>)
 80021cc:	8812      	ldrh	r2, [r2, #0]
 80021ce:	441a      	add	r2, r3
 80021d0:	89fb      	ldrh	r3, [r7, #14]
 80021d2:	482f      	ldr	r0, [pc, #188]	@ (8002290 <hanUniFontLoad+0x24c>)
 80021d4:	0152      	lsls	r2, r2, #5
 80021d6:	4413      	add	r3, r2
 80021d8:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
 80021dc:	b2da      	uxtb	r2, r3
 80021de:	89fb      	ldrh	r3, [r7, #14]
 80021e0:	430a      	orrs	r2, r1
 80021e2:	b2d1      	uxtb	r1, r2
 80021e4:	683a      	ldr	r2, [r7, #0]
 80021e6:	4413      	add	r3, r2
 80021e8:	460a      	mov	r2, r1
 80021ea:	719a      	strb	r2, [r3, #6]
  for(i = 0; i<32; i++)
 80021ec:	89fb      	ldrh	r3, [r7, #14]
 80021ee:	3301      	adds	r3, #1
 80021f0:	81fb      	strh	r3, [r7, #14]
 80021f2:	89fb      	ldrh	r3, [r7, #14]
 80021f4:	2b1f      	cmp	r3, #31
 80021f6:	d9c6      	bls.n	8002186 <hanUniFontLoad+0x142>
  }

  //combine Jongsung
  if(uJongsung)
 80021f8:	4b18      	ldr	r3, [pc, #96]	@ (800225c <hanUniFontLoad+0x218>)
 80021fa:	881b      	ldrh	r3, [r3, #0]
 80021fc:	2b00      	cmp	r3, #0
 80021fe:	d025      	beq.n	800224c <hanUniFontLoad+0x208>
  {
    for(i = 0; i < 32; i++)   FontPtr->FontBuffer[i] |= K_font[248 + uJonType*28+uJongsung][i];
 8002200:	2300      	movs	r3, #0
 8002202:	81fb      	strh	r3, [r7, #14]
 8002204:	e01f      	b.n	8002246 <hanUniFontLoad+0x202>
 8002206:	89fb      	ldrh	r3, [r7, #14]
 8002208:	683a      	ldr	r2, [r7, #0]
 800220a:	4413      	add	r3, r2
 800220c:	7999      	ldrb	r1, [r3, #6]
 800220e:	4b1f      	ldr	r3, [pc, #124]	@ (800228c <hanUniFontLoad+0x248>)
 8002210:	881b      	ldrh	r3, [r3, #0]
 8002212:	461a      	mov	r2, r3
 8002214:	4613      	mov	r3, r2
 8002216:	00db      	lsls	r3, r3, #3
 8002218:	1a9b      	subs	r3, r3, r2
 800221a:	009b      	lsls	r3, r3, #2
 800221c:	33f8      	adds	r3, #248	@ 0xf8
 800221e:	4a0f      	ldr	r2, [pc, #60]	@ (800225c <hanUniFontLoad+0x218>)
 8002220:	8812      	ldrh	r2, [r2, #0]
 8002222:	441a      	add	r2, r3
 8002224:	89fb      	ldrh	r3, [r7, #14]
 8002226:	481a      	ldr	r0, [pc, #104]	@ (8002290 <hanUniFontLoad+0x24c>)
 8002228:	0152      	lsls	r2, r2, #5
 800222a:	4413      	add	r3, r2
 800222c:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
 8002230:	b2da      	uxtb	r2, r3
 8002232:	89fb      	ldrh	r3, [r7, #14]
 8002234:	430a      	orrs	r2, r1
 8002236:	b2d1      	uxtb	r1, r2
 8002238:	683a      	ldr	r2, [r7, #0]
 800223a:	4413      	add	r3, r2
 800223c:	460a      	mov	r2, r1
 800223e:	719a      	strb	r2, [r3, #6]
 8002240:	89fb      	ldrh	r3, [r7, #14]
 8002242:	3301      	adds	r3, #1
 8002244:	81fb      	strh	r3, [r7, #14]
 8002246:	89fb      	ldrh	r3, [r7, #14]
 8002248:	2b1f      	cmp	r3, #31
 800224a:	d9dc      	bls.n	8002206 <hanUniFontLoad+0x1c2>
  }
}
 800224c:	bf00      	nop
 800224e:	3714      	adds	r7, #20
 8002250:	46bd      	mov	sp, r7
 8002252:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002256:	4770      	bx	lr
 8002258:	24924925 	.word	0x24924925
 800225c:	200004f0 	.word	0x200004f0
 8002260:	86186187 	.word	0x86186187
 8002264:	200004f2 	.word	0x200004f2
 8002268:	200004f4 	.word	0x200004f4
 800226c:	080268b0 	.word	0x080268b0
 8002270:	080268d0 	.word	0x080268d0
 8002274:	080268f0 	.word	0x080268f0
 8002278:	08026928 	.word	0x08026928
 800227c:	08026910 	.word	0x08026910
 8002280:	200004f6 	.word	0x200004f6
 8002284:	200004f8 	.word	0x200004f8
 8002288:	08026940 	.word	0x08026940
 800228c:	200004fa 	.word	0x200004fa
 8002290:	08028e40 	.word	0x08028e40

08002294 <hanEngFontLoad>:

//      
void hanEngFontLoad(char *HanCode, han_font_t *FontPtr)
{
 8002294:	b480      	push	{r7}
 8002296:	b085      	sub	sp, #20
 8002298:	af00      	add	r7, sp, #0
 800229a:	6078      	str	r0, [r7, #4]
 800229c:	6039      	str	r1, [r7, #0]
  uint16_t i;
  char EngCode;

  EngCode = *HanCode;
 800229e:	687b      	ldr	r3, [r7, #4]
 80022a0:	781b      	ldrb	r3, [r3, #0]
 80022a2:	737b      	strb	r3, [r7, #13]

  EngCode -= 0x20;  // FONT   .
 80022a4:	7b7b      	ldrb	r3, [r7, #13]
 80022a6:	3b20      	subs	r3, #32
 80022a8:	737b      	strb	r3, [r7, #13]

  for ( i = 0 ; i < 16 ; i++ )
 80022aa:	2300      	movs	r3, #0
 80022ac:	81fb      	strh	r3, [r7, #14]
 80022ae:	e00f      	b.n	80022d0 <hanEngFontLoad+0x3c>
  {
     FontPtr->FontBuffer[ i ] = (char)wEngFon[(int)EngCode][i];
 80022b0:	7b7a      	ldrb	r2, [r7, #13]
 80022b2:	89fb      	ldrh	r3, [r7, #14]
 80022b4:	490b      	ldr	r1, [pc, #44]	@ (80022e4 <hanEngFontLoad+0x50>)
 80022b6:	0112      	lsls	r2, r2, #4
 80022b8:	4413      	add	r3, r2
 80022ba:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 80022be:	89fb      	ldrh	r3, [r7, #14]
 80022c0:	b2d1      	uxtb	r1, r2
 80022c2:	683a      	ldr	r2, [r7, #0]
 80022c4:	4413      	add	r3, r2
 80022c6:	460a      	mov	r2, r1
 80022c8:	719a      	strb	r2, [r3, #6]
  for ( i = 0 ; i < 16 ; i++ )
 80022ca:	89fb      	ldrh	r3, [r7, #14]
 80022cc:	3301      	adds	r3, #1
 80022ce:	81fb      	strh	r3, [r7, #14]
 80022d0:	89fb      	ldrh	r3, [r7, #14]
 80022d2:	2b0f      	cmp	r3, #15
 80022d4:	d9ec      	bls.n	80022b0 <hanEngFontLoad+0x1c>
  }
}
 80022d6:	bf00      	nop
 80022d8:	bf00      	nop
 80022da:	3714      	adds	r7, #20
 80022dc:	46bd      	mov	sp, r7
 80022de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80022e2:	4770      	bx	lr
 80022e4:	08025050 	.word	0x08025050

080022e8 <hanCnvCodeWan2Johab>:

//     
uint16_t hanCnvCodeWan2Johab(uint16_t WanCode)
{
 80022e8:	b480      	push	{r7}
 80022ea:	b085      	sub	sp, #20
 80022ec:	af00      	add	r7, sp, #0
 80022ee:	4603      	mov	r3, r0
 80022f0:	80fb      	strh	r3, [r7, #6]
  int index;
  uint16_t hcode, lcode;

  hcode = (WanCode >> 8) & 0xFF;
 80022f2:	88fb      	ldrh	r3, [r7, #6]
 80022f4:	0a1b      	lsrs	r3, r3, #8
 80022f6:	81fb      	strh	r3, [r7, #14]
  lcode = WanCode & 0x0ff;
 80022f8:	88fb      	ldrh	r3, [r7, #6]
 80022fa:	b2db      	uxtb	r3, r3
 80022fc:	81bb      	strh	r3, [r7, #12]

  index = (hcode - 0x0B0) * 94 + (lcode - 0x0A1);
 80022fe:	89fb      	ldrh	r3, [r7, #14]
 8002300:	3bb0      	subs	r3, #176	@ 0xb0
 8002302:	225e      	movs	r2, #94	@ 0x5e
 8002304:	fb03 f202 	mul.w	r2, r3, r2
 8002308:	89bb      	ldrh	r3, [r7, #12]
 800230a:	3ba1      	subs	r3, #161	@ 0xa1
 800230c:	4413      	add	r3, r2
 800230e:	60bb      	str	r3, [r7, #8]

  return wWanToJohabTable[index];
 8002310:	4a05      	ldr	r2, [pc, #20]	@ (8002328 <hanCnvCodeWan2Johab+0x40>)
 8002312:	68bb      	ldr	r3, [r7, #8]
 8002314:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8002318:	b29b      	uxth	r3, r3
}
 800231a:	4618      	mov	r0, r3
 800231c:	3714      	adds	r7, #20
 800231e:	46bd      	mov	sp, r7
 8002320:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002324:	4770      	bx	lr
 8002326:	bf00      	nop
 8002328:	08026980 	.word	0x08026980

0800232c <ssd1306Init>:
static void ssd1306DrawPixel(uint8_t x, uint8_t y, uint16_t color);

static uint8_t ssd1306_buffer[SSD1306_WIDTH * SSD1306_HEIGHT / 8];

bool ssd1306Init(void)
{
 800232c:	b580      	push	{r7, lr}
 800232e:	b082      	sub	sp, #8
 8002330:	af00      	add	r7, sp, #0
	bool ret;

	ret = ssd1306Reset();
 8002332:	f000 f84f 	bl	80023d4 <ssd1306Reset>
 8002336:	4603      	mov	r3, r0
 8002338:	71fb      	strb	r3, [r7, #7]

	return ret;
 800233a:	79fb      	ldrb	r3, [r7, #7]
}
 800233c:	4618      	mov	r0, r3
 800233e:	3708      	adds	r7, #8
 8002340:	46bd      	mov	sp, r7
 8002342:	bd80      	pop	{r7, pc}

08002344 <ssd1306InitDriver>:

bool ssd1306InitDriver(lcd_driver_t *p_driver)
{
 8002344:	b480      	push	{r7}
 8002346:	b083      	sub	sp, #12
 8002348:	af00      	add	r7, sp, #0
 800234a:	6078      	str	r0, [r7, #4]
	p_driver->init = ssd1306Init;
 800234c:	687b      	ldr	r3, [r7, #4]
 800234e:	4a0d      	ldr	r2, [pc, #52]	@ (8002384 <ssd1306InitDriver+0x40>)
 8002350:	601a      	str	r2, [r3, #0]
	p_driver->reset = ssd1306Reset;
 8002352:	687b      	ldr	r3, [r7, #4]
 8002354:	4a0c      	ldr	r2, [pc, #48]	@ (8002388 <ssd1306InitDriver+0x44>)
 8002356:	605a      	str	r2, [r3, #4]
	p_driver->setWindow = ssd1306SetWindow;
 8002358:	687b      	ldr	r3, [r7, #4]
 800235a:	4a0c      	ldr	r2, [pc, #48]	@ (800238c <ssd1306InitDriver+0x48>)
 800235c:	609a      	str	r2, [r3, #8]
	p_driver->getWidth = ssd1306GetWidth;
 800235e:	687b      	ldr	r3, [r7, #4]
 8002360:	4a0b      	ldr	r2, [pc, #44]	@ (8002390 <ssd1306InitDriver+0x4c>)
 8002362:	60da      	str	r2, [r3, #12]
	p_driver->getHeight = ssd1306GetHeight;
 8002364:	687b      	ldr	r3, [r7, #4]
 8002366:	4a0b      	ldr	r2, [pc, #44]	@ (8002394 <ssd1306InitDriver+0x50>)
 8002368:	611a      	str	r2, [r3, #16]
	p_driver->setCallBack = ssd1306SetCallBack;
 800236a:	687b      	ldr	r3, [r7, #4]
 800236c:	4a0a      	ldr	r2, [pc, #40]	@ (8002398 <ssd1306InitDriver+0x54>)
 800236e:	615a      	str	r2, [r3, #20]
	p_driver->sendBuffer = ssd1306SendBuffer;
 8002370:	687b      	ldr	r3, [r7, #4]
 8002372:	4a0a      	ldr	r2, [pc, #40]	@ (800239c <ssd1306InitDriver+0x58>)
 8002374:	619a      	str	r2, [r3, #24]
	return true;
 8002376:	2301      	movs	r3, #1
}
 8002378:	4618      	mov	r0, r3
 800237a:	370c      	adds	r7, #12
 800237c:	46bd      	mov	sp, r7
 800237e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002382:	4770      	bx	lr
 8002384:	0800232d 	.word	0x0800232d
 8002388:	080023d5 	.word	0x080023d5
 800238c:	080024e1 	.word	0x080024e1
 8002390:	080024fb 	.word	0x080024fb
 8002394:	0800250b 	.word	0x0800250b
 8002398:	08002591 	.word	0x08002591
 800239c:	0800251d 	.word	0x0800251d

080023a0 <ssd1306WriteCmd>:

bool ssd1306WriteCmd(uint8_t cmd_data)
{
 80023a0:	b580      	push	{r7, lr}
 80023a2:	b084      	sub	sp, #16
 80023a4:	af02      	add	r7, sp, #8
 80023a6:	4603      	mov	r3, r0
 80023a8:	71fb      	strb	r3, [r7, #7]
	return i2cWriteByte(i2c_ch, i2c_dev, 0x00, cmd_data, 10);
 80023aa:	4b08      	ldr	r3, [pc, #32]	@ (80023cc <ssd1306WriteCmd+0x2c>)
 80023ac:	7818      	ldrb	r0, [r3, #0]
 80023ae:	4b08      	ldr	r3, [pc, #32]	@ (80023d0 <ssd1306WriteCmd+0x30>)
 80023b0:	781b      	ldrb	r3, [r3, #0]
 80023b2:	4619      	mov	r1, r3
 80023b4:	79fb      	ldrb	r3, [r7, #7]
 80023b6:	220a      	movs	r2, #10
 80023b8:	9200      	str	r2, [sp, #0]
 80023ba:	2200      	movs	r2, #0
 80023bc:	f001 ffbc 	bl	8004338 <i2cWriteByte>
 80023c0:	4603      	mov	r3, r0
}
 80023c2:	4618      	mov	r0, r3
 80023c4:	3708      	adds	r7, #8
 80023c6:	46bd      	mov	sp, r7
 80023c8:	bd80      	pop	{r7, pc}
 80023ca:	bf00      	nop
 80023cc:	200004fc 	.word	0x200004fc
 80023d0:	20000068 	.word	0x20000068

080023d4 <ssd1306Reset>:

bool ssd1306Reset(void)
{
 80023d4:	b580      	push	{r7, lr}
 80023d6:	b082      	sub	sp, #8
 80023d8:	af00      	add	r7, sp, #0
	bool ret;

	ret = i2cBegin(i2c_ch, 800);
 80023da:	4b3f      	ldr	r3, [pc, #252]	@ (80024d8 <ssd1306Reset+0x104>)
 80023dc:	781b      	ldrb	r3, [r3, #0]
 80023de:	f44f 7148 	mov.w	r1, #800	@ 0x320
 80023e2:	4618      	mov	r0, r3
 80023e4:	f001 fe30 	bl	8004048 <i2cBegin>
 80023e8:	4603      	mov	r3, r0
 80023ea:	71fb      	strb	r3, [r7, #7]

	if(ret != true)
 80023ec:	79fb      	ldrb	r3, [r7, #7]
 80023ee:	f083 0301 	eor.w	r3, r3, #1
 80023f2:	b2db      	uxtb	r3, r3
 80023f4:	2b00      	cmp	r3, #0
 80023f6:	d001      	beq.n	80023fc <ssd1306Reset+0x28>
	{
		return false;
 80023f8:	2300      	movs	r3, #0
 80023fa:	e069      	b.n	80024d0 <ssd1306Reset+0xfc>
	}

	if(i2cIsDeviceReady(i2c_ch, i2c_dev) != true)
 80023fc:	4b36      	ldr	r3, [pc, #216]	@ (80024d8 <ssd1306Reset+0x104>)
 80023fe:	781b      	ldrb	r3, [r3, #0]
 8002400:	4a36      	ldr	r2, [pc, #216]	@ (80024dc <ssd1306Reset+0x108>)
 8002402:	7812      	ldrb	r2, [r2, #0]
 8002404:	4611      	mov	r1, r2
 8002406:	4618      	mov	r0, r3
 8002408:	f001 ff1a 	bl	8004240 <i2cIsDeviceReady>
 800240c:	4603      	mov	r3, r0
 800240e:	f083 0301 	eor.w	r3, r3, #1
 8002412:	b2db      	uxtb	r3, r3
 8002414:	2b00      	cmp	r3, #0
 8002416:	d001      	beq.n	800241c <ssd1306Reset+0x48>
	{
		return false;
 8002418:	2300      	movs	r3, #0
 800241a:	e059      	b.n	80024d0 <ssd1306Reset+0xfc>
	}

	/* Init LCD */
	  ssd1306WriteCmd(0xAE); //display off
 800241c:	20ae      	movs	r0, #174	@ 0xae
 800241e:	f7ff ffbf 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x20); //Set Memory Addressing Mode
 8002422:	2020      	movs	r0, #32
 8002424:	f7ff ffbc 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x10); //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
 8002428:	2010      	movs	r0, #16
 800242a:	f7ff ffb9 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xB0); //Set Page Start Address for Page Addressing Mode,0-7
 800242e:	20b0      	movs	r0, #176	@ 0xb0
 8002430:	f7ff ffb6 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xC8); //Set COM Output Scan Direction
 8002434:	20c8      	movs	r0, #200	@ 0xc8
 8002436:	f7ff ffb3 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x00); //---set low column address
 800243a:	2000      	movs	r0, #0
 800243c:	f7ff ffb0 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x10); //---set high column address
 8002440:	2010      	movs	r0, #16
 8002442:	f7ff ffad 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x40); //--set start line address
 8002446:	2040      	movs	r0, #64	@ 0x40
 8002448:	f7ff ffaa 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x81); //--set contrast control register
 800244c:	2081      	movs	r0, #129	@ 0x81
 800244e:	f7ff ffa7 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xFF);
 8002452:	20ff      	movs	r0, #255	@ 0xff
 8002454:	f7ff ffa4 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xA1); //--set segment re-map 0 to 127
 8002458:	20a1      	movs	r0, #161	@ 0xa1
 800245a:	f7ff ffa1 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xA6); //--set normal display
 800245e:	20a6      	movs	r0, #166	@ 0xa6
 8002460:	f7ff ff9e 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xA8); //--set multiplex ratio(1 to 64)
 8002464:	20a8      	movs	r0, #168	@ 0xa8
 8002466:	f7ff ff9b 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x3F); //
 800246a:	203f      	movs	r0, #63	@ 0x3f
 800246c:	f7ff ff98 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xA4); //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
 8002470:	20a4      	movs	r0, #164	@ 0xa4
 8002472:	f7ff ff95 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xD3); //-set display offset
 8002476:	20d3      	movs	r0, #211	@ 0xd3
 8002478:	f7ff ff92 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x00); //-not offset
 800247c:	2000      	movs	r0, #0
 800247e:	f7ff ff8f 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xD5); //--set display clock divide ratio/oscillator frequency
 8002482:	20d5      	movs	r0, #213	@ 0xd5
 8002484:	f7ff ff8c 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xF0); //--set divide ratio
 8002488:	20f0      	movs	r0, #240	@ 0xf0
 800248a:	f7ff ff89 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xD9); //--set pre-charge period
 800248e:	20d9      	movs	r0, #217	@ 0xd9
 8002490:	f7ff ff86 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x22); //
 8002494:	2022      	movs	r0, #34	@ 0x22
 8002496:	f7ff ff83 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xDA); //--set com pins hardware configuration
 800249a:	20da      	movs	r0, #218	@ 0xda
 800249c:	f7ff ff80 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x12);
 80024a0:	2012      	movs	r0, #18
 80024a2:	f7ff ff7d 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xDB); //--set vcomh
 80024a6:	20db      	movs	r0, #219	@ 0xdb
 80024a8:	f7ff ff7a 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x20); //0x20,0.77xVcc
 80024ac:	2020      	movs	r0, #32
 80024ae:	f7ff ff77 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x8D); //--set DC-DC enable
 80024b2:	208d      	movs	r0, #141	@ 0x8d
 80024b4:	f7ff ff74 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0x14); //
 80024b8:	2014      	movs	r0, #20
 80024ba:	f7ff ff71 	bl	80023a0 <ssd1306WriteCmd>
	  ssd1306WriteCmd(0xAF); //--turn on SSD1306 panel
 80024be:	20af      	movs	r0, #175	@ 0xaf
 80024c0:	f7ff ff6e 	bl	80023a0 <ssd1306WriteCmd>

	  ssd1306Fill(black);
 80024c4:	2000      	movs	r0, #0
 80024c6:	f000 f873 	bl	80025b0 <ssd1306Fill>
	  ssd1306UpdateDraw();
 80024ca:	f000 f895 	bl	80025f8 <ssd1306UpdateDraw>

	  return true;
 80024ce:	2301      	movs	r3, #1
}
 80024d0:	4618      	mov	r0, r3
 80024d2:	3708      	adds	r7, #8
 80024d4:	46bd      	mov	sp, r7
 80024d6:	bd80      	pop	{r7, pc}
 80024d8:	200004fc 	.word	0x200004fc
 80024dc:	20000068 	.word	0x20000068

080024e0 <ssd1306SetWindow>:

void ssd1306SetWindow(int32_t x0, int32_t y0, int32_t x1, int32_t y1)
{
 80024e0:	b480      	push	{r7}
 80024e2:	b085      	sub	sp, #20
 80024e4:	af00      	add	r7, sp, #0
 80024e6:	60f8      	str	r0, [r7, #12]
 80024e8:	60b9      	str	r1, [r7, #8]
 80024ea:	607a      	str	r2, [r7, #4]
 80024ec:	603b      	str	r3, [r7, #0]

}
 80024ee:	bf00      	nop
 80024f0:	3714      	adds	r7, #20
 80024f2:	46bd      	mov	sp, r7
 80024f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024f8:	4770      	bx	lr

080024fa <ssd1306GetWidth>:

uint16_t ssd1306GetWidth(void)
{
 80024fa:	b480      	push	{r7}
 80024fc:	af00      	add	r7, sp, #0
	return LCD_WIDTH;
 80024fe:	2380      	movs	r3, #128	@ 0x80
}
 8002500:	4618      	mov	r0, r3
 8002502:	46bd      	mov	sp, r7
 8002504:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002508:	4770      	bx	lr

0800250a <ssd1306GetHeight>:

uint16_t ssd1306GetHeight(void)
{
 800250a:	b480      	push	{r7}
 800250c:	af00      	add	r7, sp, #0
	return LCD_HEIGHT;
 800250e:	2340      	movs	r3, #64	@ 0x40
}
 8002510:	4618      	mov	r0, r3
 8002512:	46bd      	mov	sp, r7
 8002514:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002518:	4770      	bx	lr
	...

0800251c <ssd1306SendBuffer>:

bool ssd1306SendBuffer(uint8_t *p_data, uint32_t length, uint32_t timeout_ms)
{
 800251c:	b580      	push	{r7, lr}
 800251e:	b088      	sub	sp, #32
 8002520:	af00      	add	r7, sp, #0
 8002522:	60f8      	str	r0, [r7, #12]
 8002524:	60b9      	str	r1, [r7, #8]
 8002526:	607a      	str	r2, [r7, #4]
	uint16_t *p_buf = (uint16_t *)p_data;
 8002528:	68fb      	ldr	r3, [r7, #12]
 800252a:	617b      	str	r3, [r7, #20]

	for(int y=0; y<SSD1306_HEIGHT; y++)
 800252c:	2300      	movs	r3, #0
 800252e:	61fb      	str	r3, [r7, #28]
 8002530:	e01a      	b.n	8002568 <ssd1306SendBuffer+0x4c>
	{
		for(int x=0; x<SSD1306_WIDTH; x++)
 8002532:	2300      	movs	r3, #0
 8002534:	61bb      	str	r3, [r7, #24]
 8002536:	e011      	b.n	800255c <ssd1306SendBuffer+0x40>
		{
			ssd1306DrawPixel(x, y, p_buf[y * LCD_WIDTH + x]);
 8002538:	69bb      	ldr	r3, [r7, #24]
 800253a:	b2d8      	uxtb	r0, r3
 800253c:	69fb      	ldr	r3, [r7, #28]
 800253e:	b2d9      	uxtb	r1, r3
 8002540:	69fb      	ldr	r3, [r7, #28]
 8002542:	01da      	lsls	r2, r3, #7
 8002544:	69bb      	ldr	r3, [r7, #24]
 8002546:	4413      	add	r3, r2
 8002548:	005b      	lsls	r3, r3, #1
 800254a:	697a      	ldr	r2, [r7, #20]
 800254c:	4413      	add	r3, r2
 800254e:	881b      	ldrh	r3, [r3, #0]
 8002550:	461a      	mov	r2, r3
 8002552:	f000 f88d 	bl	8002670 <ssd1306DrawPixel>
		for(int x=0; x<SSD1306_WIDTH; x++)
 8002556:	69bb      	ldr	r3, [r7, #24]
 8002558:	3301      	adds	r3, #1
 800255a:	61bb      	str	r3, [r7, #24]
 800255c:	69bb      	ldr	r3, [r7, #24]
 800255e:	2b7f      	cmp	r3, #127	@ 0x7f
 8002560:	ddea      	ble.n	8002538 <ssd1306SendBuffer+0x1c>
	for(int y=0; y<SSD1306_HEIGHT; y++)
 8002562:	69fb      	ldr	r3, [r7, #28]
 8002564:	3301      	adds	r3, #1
 8002566:	61fb      	str	r3, [r7, #28]
 8002568:	69fb      	ldr	r3, [r7, #28]
 800256a:	2b3f      	cmp	r3, #63	@ 0x3f
 800256c:	dde1      	ble.n	8002532 <ssd1306SendBuffer+0x16>
		}
	}

	ssd1306UpdateDraw();
 800256e:	f000 f843 	bl	80025f8 <ssd1306UpdateDraw>

	if(frameCallBack != NULL)
 8002572:	4b06      	ldr	r3, [pc, #24]	@ (800258c <ssd1306SendBuffer+0x70>)
 8002574:	681b      	ldr	r3, [r3, #0]
 8002576:	2b00      	cmp	r3, #0
 8002578:	d002      	beq.n	8002580 <ssd1306SendBuffer+0x64>
	{
		frameCallBack();
 800257a:	4b04      	ldr	r3, [pc, #16]	@ (800258c <ssd1306SendBuffer+0x70>)
 800257c:	681b      	ldr	r3, [r3, #0]
 800257e:	4798      	blx	r3
	}
	return true;
 8002580:	2301      	movs	r3, #1
}
 8002582:	4618      	mov	r0, r3
 8002584:	3720      	adds	r7, #32
 8002586:	46bd      	mov	sp, r7
 8002588:	bd80      	pop	{r7, pc}
 800258a:	bf00      	nop
 800258c:	20000500 	.word	0x20000500

08002590 <ssd1306SetCallBack>:

bool ssd1306SetCallBack(void (*p_func)(void))
{
 8002590:	b480      	push	{r7}
 8002592:	b083      	sub	sp, #12
 8002594:	af00      	add	r7, sp, #0
 8002596:	6078      	str	r0, [r7, #4]
	frameCallBack = p_func;
 8002598:	4a04      	ldr	r2, [pc, #16]	@ (80025ac <ssd1306SetCallBack+0x1c>)
 800259a:	687b      	ldr	r3, [r7, #4]
 800259c:	6013      	str	r3, [r2, #0]

	return true;
 800259e:	2301      	movs	r3, #1
}
 80025a0:	4618      	mov	r0, r3
 80025a2:	370c      	adds	r7, #12
 80025a4:	46bd      	mov	sp, r7
 80025a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80025aa:	4770      	bx	lr
 80025ac:	20000500 	.word	0x20000500

080025b0 <ssd1306Fill>:

void ssd1306Fill(uint16_t color)
{
 80025b0:	b480      	push	{r7}
 80025b2:	b085      	sub	sp, #20
 80025b4:	af00      	add	r7, sp, #0
 80025b6:	4603      	mov	r3, r0
 80025b8:	80fb      	strh	r3, [r7, #6]
	uint32_t i;

	for(i=0; i<sizeof(ssd1306_buffer); i++)
 80025ba:	2300      	movs	r3, #0
 80025bc:	60fb      	str	r3, [r7, #12]
 80025be:	e00d      	b.n	80025dc <ssd1306Fill+0x2c>
	{
		ssd1306_buffer[i] = (color > 0) ? 0xFF : 0x00;
 80025c0:	88fb      	ldrh	r3, [r7, #6]
 80025c2:	2b00      	cmp	r3, #0
 80025c4:	d001      	beq.n	80025ca <ssd1306Fill+0x1a>
 80025c6:	21ff      	movs	r1, #255	@ 0xff
 80025c8:	e000      	b.n	80025cc <ssd1306Fill+0x1c>
 80025ca:	2100      	movs	r1, #0
 80025cc:	4a09      	ldr	r2, [pc, #36]	@ (80025f4 <ssd1306Fill+0x44>)
 80025ce:	68fb      	ldr	r3, [r7, #12]
 80025d0:	4413      	add	r3, r2
 80025d2:	460a      	mov	r2, r1
 80025d4:	701a      	strb	r2, [r3, #0]
	for(i=0; i<sizeof(ssd1306_buffer); i++)
 80025d6:	68fb      	ldr	r3, [r7, #12]
 80025d8:	3301      	adds	r3, #1
 80025da:	60fb      	str	r3, [r7, #12]
 80025dc:	68fb      	ldr	r3, [r7, #12]
 80025de:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 80025e2:	d3ed      	bcc.n	80025c0 <ssd1306Fill+0x10>
	}
}
 80025e4:	bf00      	nop
 80025e6:	bf00      	nop
 80025e8:	3714      	adds	r7, #20
 80025ea:	46bd      	mov	sp, r7
 80025ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 80025f0:	4770      	bx	lr
 80025f2:	bf00      	nop
 80025f4:	20000504 	.word	0x20000504

080025f8 <ssd1306UpdateDraw>:

bool ssd1306UpdateDraw(void)
{
 80025f8:	b580      	push	{r7, lr}
 80025fa:	b084      	sub	sp, #16
 80025fc:	af02      	add	r7, sp, #8
	uint8_t i;

	for(i=0; i<8; i++)
 80025fe:	2300      	movs	r3, #0
 8002600:	71fb      	strb	r3, [r7, #7]
 8002602:	e026      	b.n	8002652 <ssd1306UpdateDraw+0x5a>
	{
    ssd1306WriteCmd(0xB0 + i);
 8002604:	79fb      	ldrb	r3, [r7, #7]
 8002606:	3b50      	subs	r3, #80	@ 0x50
 8002608:	b2db      	uxtb	r3, r3
 800260a:	4618      	mov	r0, r3
 800260c:	f7ff fec8 	bl	80023a0 <ssd1306WriteCmd>
    ssd1306WriteCmd(0x00);
 8002610:	2000      	movs	r0, #0
 8002612:	f7ff fec5 	bl	80023a0 <ssd1306WriteCmd>
    ssd1306WriteCmd(0x10);
 8002616:	2010      	movs	r0, #16
 8002618:	f7ff fec2 	bl	80023a0 <ssd1306WriteCmd>

    if(i2cWriteBytes(i2c_ch, i2c_dev, 0x40, &ssd1306_buffer[SSD1306_WIDTH * i], SSD1306_WIDTH, 100) == false)
 800261c:	4b11      	ldr	r3, [pc, #68]	@ (8002664 <ssd1306UpdateDraw+0x6c>)
 800261e:	7818      	ldrb	r0, [r3, #0]
 8002620:	4b11      	ldr	r3, [pc, #68]	@ (8002668 <ssd1306UpdateDraw+0x70>)
 8002622:	781b      	ldrb	r3, [r3, #0]
 8002624:	4619      	mov	r1, r3
 8002626:	79fb      	ldrb	r3, [r7, #7]
 8002628:	01db      	lsls	r3, r3, #7
 800262a:	4a10      	ldr	r2, [pc, #64]	@ (800266c <ssd1306UpdateDraw+0x74>)
 800262c:	4413      	add	r3, r2
 800262e:	2264      	movs	r2, #100	@ 0x64
 8002630:	9201      	str	r2, [sp, #4]
 8002632:	2280      	movs	r2, #128	@ 0x80
 8002634:	9200      	str	r2, [sp, #0]
 8002636:	2240      	movs	r2, #64	@ 0x40
 8002638:	f001 fe9e 	bl	8004378 <i2cWriteBytes>
 800263c:	4603      	mov	r3, r0
 800263e:	f083 0301 	eor.w	r3, r3, #1
 8002642:	b2db      	uxtb	r3, r3
 8002644:	2b00      	cmp	r3, #0
 8002646:	d001      	beq.n	800264c <ssd1306UpdateDraw+0x54>
    {
    	return false;
 8002648:	2300      	movs	r3, #0
 800264a:	e006      	b.n	800265a <ssd1306UpdateDraw+0x62>
	for(i=0; i<8; i++)
 800264c:	79fb      	ldrb	r3, [r7, #7]
 800264e:	3301      	adds	r3, #1
 8002650:	71fb      	strb	r3, [r7, #7]
 8002652:	79fb      	ldrb	r3, [r7, #7]
 8002654:	2b07      	cmp	r3, #7
 8002656:	d9d5      	bls.n	8002604 <ssd1306UpdateDraw+0xc>
    }
	}

	return true;
 8002658:	2301      	movs	r3, #1
}
 800265a:	4618      	mov	r0, r3
 800265c:	3708      	adds	r7, #8
 800265e:	46bd      	mov	sp, r7
 8002660:	bd80      	pop	{r7, pc}
 8002662:	bf00      	nop
 8002664:	200004fc 	.word	0x200004fc
 8002668:	20000068 	.word	0x20000068
 800266c:	20000504 	.word	0x20000504

08002670 <ssd1306DrawPixel>:

void ssd1306DrawPixel(uint8_t x, uint8_t y, uint16_t color)
{
 8002670:	b480      	push	{r7}
 8002672:	b083      	sub	sp, #12
 8002674:	af00      	add	r7, sp, #0
 8002676:	4603      	mov	r3, r0
 8002678:	71fb      	strb	r3, [r7, #7]
 800267a:	460b      	mov	r3, r1
 800267c:	71bb      	strb	r3, [r7, #6]
 800267e:	4613      	mov	r3, r2
 8002680:	80bb      	strh	r3, [r7, #4]
	if(x>=SSD1306_WIDTH || y>=SSD1306_HEIGHT)
 8002682:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002686:	2b00      	cmp	r3, #0
 8002688:	db3d      	blt.n	8002706 <ssd1306DrawPixel+0x96>
 800268a:	79bb      	ldrb	r3, [r7, #6]
 800268c:	2b3f      	cmp	r3, #63	@ 0x3f
 800268e:	d83a      	bhi.n	8002706 <ssd1306DrawPixel+0x96>
	{
		return;
	}

	if(color > 0)
 8002690:	88bb      	ldrh	r3, [r7, #4]
 8002692:	2b00      	cmp	r3, #0
 8002694:	d01a      	beq.n	80026cc <ssd1306DrawPixel+0x5c>
	{
		ssd1306_buffer[x + (y/8) * SSD1306_WIDTH] |= 1 << (y%8);
 8002696:	79fa      	ldrb	r2, [r7, #7]
 8002698:	79bb      	ldrb	r3, [r7, #6]
 800269a:	08db      	lsrs	r3, r3, #3
 800269c:	b2d8      	uxtb	r0, r3
 800269e:	4603      	mov	r3, r0
 80026a0:	01db      	lsls	r3, r3, #7
 80026a2:	4413      	add	r3, r2
 80026a4:	4a1b      	ldr	r2, [pc, #108]	@ (8002714 <ssd1306DrawPixel+0xa4>)
 80026a6:	5cd3      	ldrb	r3, [r2, r3]
 80026a8:	b25a      	sxtb	r2, r3
 80026aa:	79bb      	ldrb	r3, [r7, #6]
 80026ac:	f003 0307 	and.w	r3, r3, #7
 80026b0:	2101      	movs	r1, #1
 80026b2:	fa01 f303 	lsl.w	r3, r1, r3
 80026b6:	b25b      	sxtb	r3, r3
 80026b8:	4313      	orrs	r3, r2
 80026ba:	b259      	sxtb	r1, r3
 80026bc:	79fa      	ldrb	r2, [r7, #7]
 80026be:	4603      	mov	r3, r0
 80026c0:	01db      	lsls	r3, r3, #7
 80026c2:	4413      	add	r3, r2
 80026c4:	b2c9      	uxtb	r1, r1
 80026c6:	4a13      	ldr	r2, [pc, #76]	@ (8002714 <ssd1306DrawPixel+0xa4>)
 80026c8:	54d1      	strb	r1, [r2, r3]
 80026ca:	e01d      	b.n	8002708 <ssd1306DrawPixel+0x98>
	}
	else
	{
		ssd1306_buffer[x + (y/8) * SSD1306_WIDTH] &= ~(1 << (y%8));
 80026cc:	79fa      	ldrb	r2, [r7, #7]
 80026ce:	79bb      	ldrb	r3, [r7, #6]
 80026d0:	08db      	lsrs	r3, r3, #3
 80026d2:	b2d8      	uxtb	r0, r3
 80026d4:	4603      	mov	r3, r0
 80026d6:	01db      	lsls	r3, r3, #7
 80026d8:	4413      	add	r3, r2
 80026da:	4a0e      	ldr	r2, [pc, #56]	@ (8002714 <ssd1306DrawPixel+0xa4>)
 80026dc:	5cd3      	ldrb	r3, [r2, r3]
 80026de:	b25a      	sxtb	r2, r3
 80026e0:	79bb      	ldrb	r3, [r7, #6]
 80026e2:	f003 0307 	and.w	r3, r3, #7
 80026e6:	2101      	movs	r1, #1
 80026e8:	fa01 f303 	lsl.w	r3, r1, r3
 80026ec:	b25b      	sxtb	r3, r3
 80026ee:	43db      	mvns	r3, r3
 80026f0:	b25b      	sxtb	r3, r3
 80026f2:	4013      	ands	r3, r2
 80026f4:	b259      	sxtb	r1, r3
 80026f6:	79fa      	ldrb	r2, [r7, #7]
 80026f8:	4603      	mov	r3, r0
 80026fa:	01db      	lsls	r3, r3, #7
 80026fc:	4413      	add	r3, r2
 80026fe:	b2c9      	uxtb	r1, r1
 8002700:	4a04      	ldr	r2, [pc, #16]	@ (8002714 <ssd1306DrawPixel+0xa4>)
 8002702:	54d1      	strb	r1, [r2, r3]
 8002704:	e000      	b.n	8002708 <ssd1306DrawPixel+0x98>
		return;
 8002706:	bf00      	nop
	}
}
 8002708:	370c      	adds	r7, #12
 800270a:	46bd      	mov	sp, r7
 800270c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002710:	4770      	bx	lr
 8002712:	bf00      	nop
 8002714:	20000504 	.word	0x20000504

08002718 <cdcAvailable>:
bool rx_full=false;



uint32_t cdcAvailable(void)
{
 8002718:	b480      	push	{r7}
 800271a:	b083      	sub	sp, #12
 800271c:	af00      	add	r7, sp, #0
	uint32_t ret;

	ret = (rx_in - rx_out) % BUF_SIZE;
 800271e:	4b07      	ldr	r3, [pc, #28]	@ (800273c <cdcAvailable+0x24>)
 8002720:	681a      	ldr	r2, [r3, #0]
 8002722:	4b07      	ldr	r3, [pc, #28]	@ (8002740 <cdcAvailable+0x28>)
 8002724:	681b      	ldr	r3, [r3, #0]
 8002726:	1ad3      	subs	r3, r2, r3
 8002728:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800272c:	607b      	str	r3, [r7, #4]

	return ret;
 800272e:	687b      	ldr	r3, [r7, #4]
}
 8002730:	4618      	mov	r0, r3
 8002732:	370c      	adds	r7, #12
 8002734:	46bd      	mov	sp, r7
 8002736:	f85d 7b04 	ldr.w	r7, [sp], #4
 800273a:	4770      	bx	lr
 800273c:	20000b04 	.word	0x20000b04
 8002740:	20000b08 	.word	0x20000b08

08002744 <cdcRead>:

uint8_t cdcRead(void)
{
 8002744:	b480      	push	{r7}
 8002746:	b083      	sub	sp, #12
 8002748:	af00      	add	r7, sp, #0
	uint8_t ret = 0;
 800274a:	2300      	movs	r3, #0
 800274c:	71fb      	strb	r3, [r7, #7]

	ret = rx_buf[rx_out];
 800274e:	4b0c      	ldr	r3, [pc, #48]	@ (8002780 <cdcRead+0x3c>)
 8002750:	681b      	ldr	r3, [r3, #0]
 8002752:	4a0c      	ldr	r2, [pc, #48]	@ (8002784 <cdcRead+0x40>)
 8002754:	5cd3      	ldrb	r3, [r2, r3]
 8002756:	71fb      	strb	r3, [r7, #7]

	if(rx_out != rx_in)
 8002758:	4b09      	ldr	r3, [pc, #36]	@ (8002780 <cdcRead+0x3c>)
 800275a:	681a      	ldr	r2, [r3, #0]
 800275c:	4b0a      	ldr	r3, [pc, #40]	@ (8002788 <cdcRead+0x44>)
 800275e:	681b      	ldr	r3, [r3, #0]
 8002760:	429a      	cmp	r2, r3
 8002762:	d006      	beq.n	8002772 <cdcRead+0x2e>
	{
		rx_out = (rx_out + 1) % BUF_SIZE;
 8002764:	4b06      	ldr	r3, [pc, #24]	@ (8002780 <cdcRead+0x3c>)
 8002766:	681b      	ldr	r3, [r3, #0]
 8002768:	3301      	adds	r3, #1
 800276a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800276e:	4a04      	ldr	r2, [pc, #16]	@ (8002780 <cdcRead+0x3c>)
 8002770:	6013      	str	r3, [r2, #0]
	}

	return ret;
 8002772:	79fb      	ldrb	r3, [r7, #7]
}
 8002774:	4618      	mov	r0, r3
 8002776:	370c      	adds	r7, #12
 8002778:	46bd      	mov	sp, r7
 800277a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800277e:	4770      	bx	lr
 8002780:	20000b08 	.word	0x20000b08
 8002784:	20000904 	.word	0x20000904
 8002788:	20000b04 	.word	0x20000b04

0800278c <cdcDataIn>:

void cdcDataIn(uint8_t rx_data)
{
 800278c:	b480      	push	{r7}
 800278e:	b085      	sub	sp, #20
 8002790:	af00      	add	r7, sp, #0
 8002792:	4603      	mov	r3, r0
 8002794:	71fb      	strb	r3, [r7, #7]
	rx_buf[rx_in] = rx_data;
 8002796:	4b0c      	ldr	r3, [pc, #48]	@ (80027c8 <cdcDataIn+0x3c>)
 8002798:	681b      	ldr	r3, [r3, #0]
 800279a:	490c      	ldr	r1, [pc, #48]	@ (80027cc <cdcDataIn+0x40>)
 800279c:	79fa      	ldrb	r2, [r7, #7]
 800279e:	54ca      	strb	r2, [r1, r3]

	uint8_t next_rx_in = (rx_in + 1) % BUF_SIZE;
 80027a0:	4b09      	ldr	r3, [pc, #36]	@ (80027c8 <cdcDataIn+0x3c>)
 80027a2:	681b      	ldr	r3, [r3, #0]
 80027a4:	b2db      	uxtb	r3, r3
 80027a6:	3301      	adds	r3, #1
 80027a8:	73fb      	strb	r3, [r7, #15]

	if(next_rx_in != rx_out)
 80027aa:	7bfa      	ldrb	r2, [r7, #15]
 80027ac:	4b08      	ldr	r3, [pc, #32]	@ (80027d0 <cdcDataIn+0x44>)
 80027ae:	681b      	ldr	r3, [r3, #0]
 80027b0:	429a      	cmp	r2, r3
 80027b2:	d002      	beq.n	80027ba <cdcDataIn+0x2e>
	{
		rx_in = next_rx_in;
 80027b4:	7bfb      	ldrb	r3, [r7, #15]
 80027b6:	4a04      	ldr	r2, [pc, #16]	@ (80027c8 <cdcDataIn+0x3c>)
 80027b8:	6013      	str	r3, [r2, #0]
	}
}
 80027ba:	bf00      	nop
 80027bc:	3714      	adds	r7, #20
 80027be:	46bd      	mov	sp, r7
 80027c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80027c4:	4770      	bx	lr
 80027c6:	bf00      	nop
 80027c8:	20000b04 	.word	0x20000b04
 80027cc:	20000904 	.word	0x20000904
 80027d0:	20000b08 	.word	0x20000b08

080027d4 <cdcWrite>:

uint32_t cdcWrite(uint8_t *p_data, uint32_t len)
{
 80027d4:	b580      	push	{r7, lr}
 80027d6:	b084      	sub	sp, #16
 80027d8:	af00      	add	r7, sp, #0
 80027da:	6078      	str	r0, [r7, #4]
 80027dc:	6039      	str	r1, [r7, #0]
	uint32_t pre_time = 0;
 80027de:	2300      	movs	r3, #0
 80027e0:	60fb      	str	r3, [r7, #12]
	uint8_t ret;

	pre_time = millis();
 80027e2:	f7ff f955 	bl	8001a90 <millis>
 80027e6:	60f8      	str	r0, [r7, #12]
	while(1)
	{
		ret = CDC_Transmit_FS(p_data, len);
 80027e8:	683b      	ldr	r3, [r7, #0]
 80027ea:	b29b      	uxth	r3, r3
 80027ec:	4619      	mov	r1, r3
 80027ee:	6878      	ldr	r0, [r7, #4]
 80027f0:	f018 ff6e 	bl	801b6d0 <CDC_Transmit_FS>
 80027f4:	4603      	mov	r3, r0
 80027f6:	72fb      	strb	r3, [r7, #11]

		if(ret == USBD_OK)
 80027f8:	7afb      	ldrb	r3, [r7, #11]
 80027fa:	2b00      	cmp	r3, #0
 80027fc:	d101      	bne.n	8002802 <cdcWrite+0x2e>
			{
				return len;
 80027fe:	683b      	ldr	r3, [r7, #0]
 8002800:	e00e      	b.n	8002820 <cdcWrite+0x4c>
			}
			else if(ret == USBD_FAIL)
 8002802:	7afb      	ldrb	r3, [r7, #11]
 8002804:	2b03      	cmp	r3, #3
 8002806:	d101      	bne.n	800280c <cdcWrite+0x38>
			{
				return 0;
 8002808:	2300      	movs	r3, #0
 800280a:	e009      	b.n	8002820 <cdcWrite+0x4c>
			}

			if(millis() - pre_time >= 100)
 800280c:	f7ff f940 	bl	8001a90 <millis>
 8002810:	4602      	mov	r2, r0
 8002812:	68fb      	ldr	r3, [r7, #12]
 8002814:	1ad3      	subs	r3, r2, r3
 8002816:	2b63      	cmp	r3, #99	@ 0x63
 8002818:	d800      	bhi.n	800281c <cdcWrite+0x48>
		ret = CDC_Transmit_FS(p_data, len);
 800281a:	e7e5      	b.n	80027e8 <cdcWrite+0x14>
			{
				break;
 800281c:	bf00      	nop
			}
	}

	return 0;
 800281e:	2300      	movs	r3, #0
}
 8002820:	4618      	mov	r0, r3
 8002822:	3710      	adds	r7, #16
 8002824:	46bd      	mov	sp, r7
 8002826:	bd80      	pop	{r7, pc}

08002828 <cliInit>:
void cliShowList(cli_args_t *args);
void cliMemoryDump(cli_args_t *args);


bool cliInit(void)
{
 8002828:	b580      	push	{r7, lr}
 800282a:	af00      	add	r7, sp, #0
  cli_node.is_open = false;
 800282c:	4b1b      	ldr	r3, [pc, #108]	@ (800289c <cliInit+0x74>)
 800282e:	2200      	movs	r2, #0
 8002830:	721a      	strb	r2, [r3, #8]
  cli_node.is_log  = false;
 8002832:	4b1a      	ldr	r3, [pc, #104]	@ (800289c <cliInit+0x74>)
 8002834:	2200      	movs	r2, #0
 8002836:	725a      	strb	r2, [r3, #9]
  cli_node.state   = CLI_RX_IDLE;
 8002838:	4b18      	ldr	r3, [pc, #96]	@ (800289c <cliInit+0x74>)
 800283a:	2200      	movs	r2, #0
 800283c:	741a      	strb	r2, [r3, #16]

  cli_node.hist_line_i     = 0;
 800283e:	4b17      	ldr	r3, [pc, #92]	@ (800289c <cliInit+0x74>)
 8002840:	2200      	movs	r2, #0
 8002842:	f883 2195 	strb.w	r2, [r3, #405]	@ 0x195
  cli_node.hist_line_last  = 0;
 8002846:	4b15      	ldr	r3, [pc, #84]	@ (800289c <cliInit+0x74>)
 8002848:	2200      	movs	r2, #0
 800284a:	f883 2196 	strb.w	r2, [r3, #406]	@ 0x196
  cli_node.hist_line_count = 0;
 800284e:	4b13      	ldr	r3, [pc, #76]	@ (800289c <cliInit+0x74>)
 8002850:	2200      	movs	r2, #0
 8002852:	f883 2197 	strb.w	r2, [r3, #407]	@ 0x197
  cli_node.hist_line_new   = false;
 8002856:	4b11      	ldr	r3, [pc, #68]	@ (800289c <cliInit+0x74>)
 8002858:	2200      	movs	r2, #0
 800285a:	f883 2194 	strb.w	r2, [r3, #404]	@ 0x194

  cli_node.cmd_args.getData  = cliArgsGetData;
 800285e:	4b0f      	ldr	r3, [pc, #60]	@ (800289c <cliInit+0x74>)
 8002860:	4a0f      	ldr	r2, [pc, #60]	@ (80028a0 <cliInit+0x78>)
 8002862:	f8c3 2474 	str.w	r2, [r3, #1140]	@ 0x474
  cli_node.cmd_args.getFloat = cliArgsGetFloat;
 8002866:	4b0d      	ldr	r3, [pc, #52]	@ (800289c <cliInit+0x74>)
 8002868:	4a0e      	ldr	r2, [pc, #56]	@ (80028a4 <cliInit+0x7c>)
 800286a:	f8c3 2478 	str.w	r2, [r3, #1144]	@ 0x478
  cli_node.cmd_args.getStr   = cliArgsGetStr;
 800286e:	4b0b      	ldr	r3, [pc, #44]	@ (800289c <cliInit+0x74>)
 8002870:	4a0d      	ldr	r2, [pc, #52]	@ (80028a8 <cliInit+0x80>)
 8002872:	f8c3 247c 	str.w	r2, [r3, #1148]	@ 0x47c
  cli_node.cmd_args.isStr    = cliArgsIsStr;
 8002876:	4b09      	ldr	r3, [pc, #36]	@ (800289c <cliInit+0x74>)
 8002878:	4a0c      	ldr	r2, [pc, #48]	@ (80028ac <cliInit+0x84>)
 800287a:	f8c3 2480 	str.w	r2, [r3, #1152]	@ 0x480

  cliLineClean(&cli_node);
 800287e:	4807      	ldr	r0, [pc, #28]	@ (800289c <cliInit+0x74>)
 8002880:	f000 fb72 	bl	8002f68 <cliLineClean>


  cliAdd("help", cliShowList);
 8002884:	490a      	ldr	r1, [pc, #40]	@ (80028b0 <cliInit+0x88>)
 8002886:	480b      	ldr	r0, [pc, #44]	@ (80028b4 <cliInit+0x8c>)
 8002888:	f000 fe0e 	bl	80034a8 <cliAdd>
  cliAdd("md"  , cliMemoryDump);
 800288c:	490a      	ldr	r1, [pc, #40]	@ (80028b8 <cliInit+0x90>)
 800288e:	480b      	ldr	r0, [pc, #44]	@ (80028bc <cliInit+0x94>)
 8002890:	f000 fe0a 	bl	80034a8 <cliAdd>

  return true;
 8002894:	2301      	movs	r3, #1
}
 8002896:	4618      	mov	r0, r3
 8002898:	bd80      	pop	{r7, pc}
 800289a:	bf00      	nop
 800289c:	20000b0c 	.word	0x20000b0c
 80028a0:	08003339 	.word	0x08003339
 80028a4:	08003389 	.word	0x08003389
 80028a8:	080033e1 	.word	0x080033e1
 80028ac:	08003429 	.word	0x08003429
 80028b0:	0800353d 	.word	0x0800353d
 80028b4:	080240e4 	.word	0x080240e4
 80028b8:	080035ad 	.word	0x080035ad
 80028bc:	080240ec 	.word	0x080240ec

080028c0 <cliOpen>:

bool cliOpen(uint8_t ch, uint32_t baud)
{
 80028c0:	b580      	push	{r7, lr}
 80028c2:	b082      	sub	sp, #8
 80028c4:	af00      	add	r7, sp, #0
 80028c6:	4603      	mov	r3, r0
 80028c8:	6039      	str	r1, [r7, #0]
 80028ca:	71fb      	strb	r3, [r7, #7]
  cli_node.ch = ch;
 80028cc:	4a0a      	ldr	r2, [pc, #40]	@ (80028f8 <cliOpen+0x38>)
 80028ce:	79fb      	ldrb	r3, [r7, #7]
 80028d0:	7013      	strb	r3, [r2, #0]
  cli_node.baud = baud;
 80028d2:	4a09      	ldr	r2, [pc, #36]	@ (80028f8 <cliOpen+0x38>)
 80028d4:	683b      	ldr	r3, [r7, #0]
 80028d6:	6053      	str	r3, [r2, #4]

  cli_node.is_open = uartOpen(ch, baud);
 80028d8:	79fb      	ldrb	r3, [r7, #7]
 80028da:	6839      	ldr	r1, [r7, #0]
 80028dc:	4618      	mov	r0, r3
 80028de:	f006 f85f 	bl	80089a0 <uartOpen>
 80028e2:	4603      	mov	r3, r0
 80028e4:	461a      	mov	r2, r3
 80028e6:	4b04      	ldr	r3, [pc, #16]	@ (80028f8 <cliOpen+0x38>)
 80028e8:	721a      	strb	r2, [r3, #8]

  return cli_node.is_open;
 80028ea:	4b03      	ldr	r3, [pc, #12]	@ (80028f8 <cliOpen+0x38>)
 80028ec:	7a1b      	ldrb	r3, [r3, #8]
}
 80028ee:	4618      	mov	r0, r3
 80028f0:	3708      	adds	r7, #8
 80028f2:	46bd      	mov	sp, r7
 80028f4:	bd80      	pop	{r7, pc}
 80028f6:	bf00      	nop
 80028f8:	20000b0c 	.word	0x20000b0c

080028fc <cliShowLog>:
  cli_node.is_log = false;
  return true;
}

void cliShowLog(cli_t *p_cli)
{
 80028fc:	b580      	push	{r7, lr}
 80028fe:	b084      	sub	sp, #16
 8002900:	af00      	add	r7, sp, #0
 8002902:	6078      	str	r0, [r7, #4]
  if (cli_node.is_log == true)
 8002904:	4b34      	ldr	r3, [pc, #208]	@ (80029d8 <cliShowLog+0xdc>)
 8002906:	7a5b      	ldrb	r3, [r3, #9]
 8002908:	2b00      	cmp	r3, #0
 800290a:	d061      	beq.n	80029d0 <cliShowLog+0xd4>
  {
    uartPrintf(p_cli->log_ch, "Cursor  : %d\n", p_cli->line.cursor);
 800290c:	687b      	ldr	r3, [r7, #4]
 800290e:	7a98      	ldrb	r0, [r3, #10]
 8002910:	687b      	ldr	r3, [r7, #4]
 8002912:	f893 3328 	ldrb.w	r3, [r3, #808]	@ 0x328
 8002916:	461a      	mov	r2, r3
 8002918:	4930      	ldr	r1, [pc, #192]	@ (80029dc <cliShowLog+0xe0>)
 800291a:	f006 f915 	bl	8008b48 <uartPrintf>
    uartPrintf(p_cli->log_ch, "Count   : %d\n", p_cli->line.count);
 800291e:	687b      	ldr	r3, [r7, #4]
 8002920:	7a98      	ldrb	r0, [r3, #10]
 8002922:	687b      	ldr	r3, [r7, #4]
 8002924:	f893 3329 	ldrb.w	r3, [r3, #809]	@ 0x329
 8002928:	461a      	mov	r2, r3
 800292a:	492d      	ldr	r1, [pc, #180]	@ (80029e0 <cliShowLog+0xe4>)
 800292c:	f006 f90c 	bl	8008b48 <uartPrintf>
    uartPrintf(p_cli->log_ch, "buf_len : %d\n", p_cli->line.buf_len);
 8002930:	687b      	ldr	r3, [r7, #4]
 8002932:	7a98      	ldrb	r0, [r3, #10]
 8002934:	687b      	ldr	r3, [r7, #4]
 8002936:	f893 3327 	ldrb.w	r3, [r3, #807]	@ 0x327
 800293a:	461a      	mov	r2, r3
 800293c:	4929      	ldr	r1, [pc, #164]	@ (80029e4 <cliShowLog+0xe8>)
 800293e:	f006 f903 	bl	8008b48 <uartPrintf>
    uartPrintf(p_cli->log_ch, "buf     : %s\n", p_cli->line.buf);
 8002942:	687b      	ldr	r3, [r7, #4]
 8002944:	7a98      	ldrb	r0, [r3, #10]
 8002946:	687b      	ldr	r3, [r7, #4]
 8002948:	f203 23e7 	addw	r3, r3, #743	@ 0x2e7
 800294c:	461a      	mov	r2, r3
 800294e:	4926      	ldr	r1, [pc, #152]	@ (80029e8 <cliShowLog+0xec>)
 8002950:	f006 f8fa 	bl	8008b48 <uartPrintf>
    uartPrintf(p_cli->log_ch, "line_i  : %d\n", p_cli->hist_line_i);
 8002954:	687b      	ldr	r3, [r7, #4]
 8002956:	7a98      	ldrb	r0, [r3, #10]
 8002958:	687b      	ldr	r3, [r7, #4]
 800295a:	f993 3195 	ldrsb.w	r3, [r3, #405]	@ 0x195
 800295e:	461a      	mov	r2, r3
 8002960:	4922      	ldr	r1, [pc, #136]	@ (80029ec <cliShowLog+0xf0>)
 8002962:	f006 f8f1 	bl	8008b48 <uartPrintf>
    uartPrintf(p_cli->log_ch, "line_lt : %d\n", p_cli->hist_line_last);
 8002966:	687b      	ldr	r3, [r7, #4]
 8002968:	7a98      	ldrb	r0, [r3, #10]
 800296a:	687b      	ldr	r3, [r7, #4]
 800296c:	f893 3196 	ldrb.w	r3, [r3, #406]	@ 0x196
 8002970:	461a      	mov	r2, r3
 8002972:	491f      	ldr	r1, [pc, #124]	@ (80029f0 <cliShowLog+0xf4>)
 8002974:	f006 f8e8 	bl	8008b48 <uartPrintf>
    uartPrintf(p_cli->log_ch, "line_c  : %d\n", p_cli->hist_line_count);
 8002978:	687b      	ldr	r3, [r7, #4]
 800297a:	7a98      	ldrb	r0, [r3, #10]
 800297c:	687b      	ldr	r3, [r7, #4]
 800297e:	f893 3197 	ldrb.w	r3, [r3, #407]	@ 0x197
 8002982:	461a      	mov	r2, r3
 8002984:	491b      	ldr	r1, [pc, #108]	@ (80029f4 <cliShowLog+0xf8>)
 8002986:	f006 f8df 	bl	8008b48 <uartPrintf>

    for (int i=0; i<p_cli->hist_line_count; i++)
 800298a:	2300      	movs	r3, #0
 800298c:	60fb      	str	r3, [r7, #12]
 800298e:	e012      	b.n	80029b6 <cliShowLog+0xba>
    {
      uartPrintf(p_cli->log_ch, "buf %d   : %s\n", i, p_cli->line_buf[i].buf);
 8002990:	687b      	ldr	r3, [r7, #4]
 8002992:	7a98      	ldrb	r0, [r3, #10]
 8002994:	68fa      	ldr	r2, [r7, #12]
 8002996:	4613      	mov	r3, r2
 8002998:	015b      	lsls	r3, r3, #5
 800299a:	4413      	add	r3, r2
 800299c:	005b      	lsls	r3, r3, #1
 800299e:	4413      	add	r3, r2
 80029a0:	f503 73cc 	add.w	r3, r3, #408	@ 0x198
 80029a4:	687a      	ldr	r2, [r7, #4]
 80029a6:	4413      	add	r3, r2
 80029a8:	68fa      	ldr	r2, [r7, #12]
 80029aa:	4913      	ldr	r1, [pc, #76]	@ (80029f8 <cliShowLog+0xfc>)
 80029ac:	f006 f8cc 	bl	8008b48 <uartPrintf>
    for (int i=0; i<p_cli->hist_line_count; i++)
 80029b0:	68fb      	ldr	r3, [r7, #12]
 80029b2:	3301      	adds	r3, #1
 80029b4:	60fb      	str	r3, [r7, #12]
 80029b6:	687b      	ldr	r3, [r7, #4]
 80029b8:	f893 3197 	ldrb.w	r3, [r3, #407]	@ 0x197
 80029bc:	461a      	mov	r2, r3
 80029be:	68fb      	ldr	r3, [r7, #12]
 80029c0:	4293      	cmp	r3, r2
 80029c2:	dbe5      	blt.n	8002990 <cliShowLog+0x94>
    }
    uartPrintf(p_cli->log_ch, "\n");
 80029c4:	687b      	ldr	r3, [r7, #4]
 80029c6:	7a9b      	ldrb	r3, [r3, #10]
 80029c8:	490c      	ldr	r1, [pc, #48]	@ (80029fc <cliShowLog+0x100>)
 80029ca:	4618      	mov	r0, r3
 80029cc:	f006 f8bc 	bl	8008b48 <uartPrintf>
  }
}
 80029d0:	bf00      	nop
 80029d2:	3710      	adds	r7, #16
 80029d4:	46bd      	mov	sp, r7
 80029d6:	bd80      	pop	{r7, pc}
 80029d8:	20000b0c 	.word	0x20000b0c
 80029dc:	080240f0 	.word	0x080240f0
 80029e0:	08024100 	.word	0x08024100
 80029e4:	08024110 	.word	0x08024110
 80029e8:	08024120 	.word	0x08024120
 80029ec:	08024130 	.word	0x08024130
 80029f0:	08024140 	.word	0x08024140
 80029f4:	08024150 	.word	0x08024150
 80029f8:	08024160 	.word	0x08024160
 80029fc:	08024170 	.word	0x08024170

08002a00 <cliShowPrompt>:

void cliShowPrompt(cli_t *p_cli)
{
 8002a00:	b580      	push	{r7, lr}
 8002a02:	b082      	sub	sp, #8
 8002a04:	af00      	add	r7, sp, #0
 8002a06:	6078      	str	r0, [r7, #4]
  uartPrintf(p_cli->ch, "\n\r");
 8002a08:	687b      	ldr	r3, [r7, #4]
 8002a0a:	781b      	ldrb	r3, [r3, #0]
 8002a0c:	4906      	ldr	r1, [pc, #24]	@ (8002a28 <cliShowPrompt+0x28>)
 8002a0e:	4618      	mov	r0, r3
 8002a10:	f006 f89a 	bl	8008b48 <uartPrintf>
  uartPrintf(p_cli->ch, CLI_PROMPT_STR);
 8002a14:	687b      	ldr	r3, [r7, #4]
 8002a16:	781b      	ldrb	r3, [r3, #0]
 8002a18:	4904      	ldr	r1, [pc, #16]	@ (8002a2c <cliShowPrompt+0x2c>)
 8002a1a:	4618      	mov	r0, r3
 8002a1c:	f006 f894 	bl	8008b48 <uartPrintf>
}
 8002a20:	bf00      	nop
 8002a22:	3708      	adds	r7, #8
 8002a24:	46bd      	mov	sp, r7
 8002a26:	bd80      	pop	{r7, pc}
 8002a28:	08024174 	.word	0x08024174
 8002a2c:	08024178 	.word	0x08024178

08002a30 <cliMain>:

bool cliMain(void)
{
 8002a30:	b580      	push	{r7, lr}
 8002a32:	af00      	add	r7, sp, #0
  if (cli_node.is_open != true)
 8002a34:	4b0e      	ldr	r3, [pc, #56]	@ (8002a70 <cliMain+0x40>)
 8002a36:	7a1b      	ldrb	r3, [r3, #8]
 8002a38:	f083 0301 	eor.w	r3, r3, #1
 8002a3c:	b2db      	uxtb	r3, r3
 8002a3e:	2b00      	cmp	r3, #0
 8002a40:	d001      	beq.n	8002a46 <cliMain+0x16>
  {
    return false;
 8002a42:	2300      	movs	r3, #0
 8002a44:	e012      	b.n	8002a6c <cliMain+0x3c>
  }

  if (uartAvailable(cli_node.ch) > 0)
 8002a46:	4b0a      	ldr	r3, [pc, #40]	@ (8002a70 <cliMain+0x40>)
 8002a48:	781b      	ldrb	r3, [r3, #0]
 8002a4a:	4618      	mov	r0, r3
 8002a4c:	f006 f802 	bl	8008a54 <uartAvailable>
 8002a50:	4603      	mov	r3, r0
 8002a52:	2b00      	cmp	r3, #0
 8002a54:	d009      	beq.n	8002a6a <cliMain+0x3a>
  {
    cliUpdate(&cli_node, uartRead(cli_node.ch));
 8002a56:	4b06      	ldr	r3, [pc, #24]	@ (8002a70 <cliMain+0x40>)
 8002a58:	781b      	ldrb	r3, [r3, #0]
 8002a5a:	4618      	mov	r0, r3
 8002a5c:	f006 f82a 	bl	8008ab4 <uartRead>
 8002a60:	4603      	mov	r3, r0
 8002a62:	4619      	mov	r1, r3
 8002a64:	4802      	ldr	r0, [pc, #8]	@ (8002a70 <cliMain+0x40>)
 8002a66:	f000 f81d 	bl	8002aa4 <cliUpdate>
  }

  return true;
 8002a6a:	2301      	movs	r3, #1
}
 8002a6c:	4618      	mov	r0, r3
 8002a6e:	bd80      	pop	{r7, pc}
 8002a70:	20000b0c 	.word	0x20000b0c

08002a74 <cliAvailable>:

uint32_t cliAvailable(void)
{
 8002a74:	b580      	push	{r7, lr}
 8002a76:	af00      	add	r7, sp, #0
  return uartAvailable(cli_node.ch);
 8002a78:	4b03      	ldr	r3, [pc, #12]	@ (8002a88 <cliAvailable+0x14>)
 8002a7a:	781b      	ldrb	r3, [r3, #0]
 8002a7c:	4618      	mov	r0, r3
 8002a7e:	f005 ffe9 	bl	8008a54 <uartAvailable>
 8002a82:	4603      	mov	r3, r0
}
 8002a84:	4618      	mov	r0, r3
 8002a86:	bd80      	pop	{r7, pc}
 8002a88:	20000b0c 	.word	0x20000b0c

08002a8c <cliRead>:

uint8_t cliRead(void)
{
 8002a8c:	b580      	push	{r7, lr}
 8002a8e:	af00      	add	r7, sp, #0
  return uartRead(cli_node.ch);
 8002a90:	4b03      	ldr	r3, [pc, #12]	@ (8002aa0 <cliRead+0x14>)
 8002a92:	781b      	ldrb	r3, [r3, #0]
 8002a94:	4618      	mov	r0, r3
 8002a96:	f006 f80d 	bl	8008ab4 <uartRead>
 8002a9a:	4603      	mov	r3, r0
}
 8002a9c:	4618      	mov	r0, r3
 8002a9e:	bd80      	pop	{r7, pc}
 8002aa0:	20000b0c 	.word	0x20000b0c

08002aa4 <cliUpdate>:
{
  return uartWrite(cli_node.ch, p_data, length);
}

bool cliUpdate(cli_t *p_cli, uint8_t rx_data)
{
 8002aa4:	b580      	push	{r7, lr}
 8002aa6:	b08c      	sub	sp, #48	@ 0x30
 8002aa8:	af00      	add	r7, sp, #0
 8002aaa:	6078      	str	r0, [r7, #4]
 8002aac:	460b      	mov	r3, r1
 8002aae:	70fb      	strb	r3, [r7, #3]
  bool ret = false;
 8002ab0:	2300      	movs	r3, #0
 8002ab2:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
  uint8_t tx_buf[8];
  cli_line_t *line;

  line = &p_cli->line;
 8002ab6:	687b      	ldr	r3, [r7, #4]
 8002ab8:	f203 23e7 	addw	r3, r3, #743	@ 0x2e7
 8002abc:	61fb      	str	r3, [r7, #28]

  if (p_cli->state == CLI_RX_IDLE)
 8002abe:	687b      	ldr	r3, [r7, #4]
 8002ac0:	7c1b      	ldrb	r3, [r3, #16]
 8002ac2:	2b00      	cmp	r3, #0
 8002ac4:	f040 816d 	bne.w	8002da2 <cliUpdate+0x2fe>
  {
    switch(rx_data)
 8002ac8:	78fb      	ldrb	r3, [r7, #3]
 8002aca:	2b7f      	cmp	r3, #127	@ 0x7f
 8002acc:	d02a      	beq.n	8002b24 <cliUpdate+0x80>
 8002ace:	2b7f      	cmp	r3, #127	@ 0x7f
 8002ad0:	f300 80da 	bgt.w	8002c88 <cliUpdate+0x1e4>
 8002ad4:	2b1b      	cmp	r3, #27
 8002ad6:	d021      	beq.n	8002b1c <cliUpdate+0x78>
 8002ad8:	2b1b      	cmp	r3, #27
 8002ada:	f300 80d5 	bgt.w	8002c88 <cliUpdate+0x1e4>
 8002ade:	2b08      	cmp	r3, #8
 8002ae0:	d062      	beq.n	8002ba8 <cliUpdate+0x104>
 8002ae2:	2b0d      	cmp	r3, #13
 8002ae4:	f040 80d0 	bne.w	8002c88 <cliUpdate+0x1e4>
    {
      // 
      case CLI_KEY_ENTER:
        if (line->count > 0)
 8002ae8:	69fb      	ldr	r3, [r7, #28]
 8002aea:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002aee:	2b00      	cmp	r3, #0
 8002af0:	d005      	beq.n	8002afe <cliUpdate+0x5a>
        {
          cliLineAdd(p_cli);
 8002af2:	6878      	ldr	r0, [r7, #4]
 8002af4:	f000 fa52 	bl	8002f9c <cliLineAdd>
          cliRunCmd(p_cli);
 8002af8:	6878      	ldr	r0, [r7, #4]
 8002afa:	f000 fb23 	bl	8003144 <cliRunCmd>
        }

        line->count = 0;
 8002afe:	69fb      	ldr	r3, [r7, #28]
 8002b00:	2200      	movs	r2, #0
 8002b02:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
        line->cursor = 0;
 8002b06:	69fb      	ldr	r3, [r7, #28]
 8002b08:	2200      	movs	r2, #0
 8002b0a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        line->buf[0] = 0;
 8002b0e:	69fb      	ldr	r3, [r7, #28]
 8002b10:	2200      	movs	r2, #0
 8002b12:	701a      	strb	r2, [r3, #0]
        cliShowPrompt(p_cli);
 8002b14:	6878      	ldr	r0, [r7, #4]
 8002b16:	f7ff ff73 	bl	8002a00 <cliShowPrompt>
        break;
 8002b1a:	e142      	b.n	8002da2 <cliUpdate+0x2fe>


      case CLI_KEY_ESC:
        p_cli->state = CLI_RX_SP1;
 8002b1c:	687b      	ldr	r3, [r7, #4]
 8002b1e:	2201      	movs	r2, #1
 8002b20:	741a      	strb	r2, [r3, #16]
        break;
 8002b22:	e13e      	b.n	8002da2 <cliUpdate+0x2fe>

      // DEL
      case CLI_KEY_DEL:
        if (line->cursor < line->count)
 8002b24:	69fb      	ldr	r3, [r7, #28]
 8002b26:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002b2a:	69fb      	ldr	r3, [r7, #28]
 8002b2c:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002b30:	429a      	cmp	r2, r3
 8002b32:	f080 8131 	bcs.w	8002d98 <cliUpdate+0x2f4>
        {
          uint8_t mov_len;

          mov_len = line->count - line->cursor;
 8002b36:	69fb      	ldr	r3, [r7, #28]
 8002b38:	f893 2042 	ldrb.w	r2, [r3, #66]	@ 0x42
 8002b3c:	69fb      	ldr	r3, [r7, #28]
 8002b3e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002b42:	1ad3      	subs	r3, r2, r3
 8002b44:	76fb      	strb	r3, [r7, #27]
          for (int i=1; i<mov_len; i++)
 8002b46:	2301      	movs	r3, #1
 8002b48:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8002b4a:	e013      	b.n	8002b74 <cliUpdate+0xd0>
          {
            line->buf[line->cursor + i - 1] = line->buf[line->cursor + i];
 8002b4c:	69fb      	ldr	r3, [r7, #28]
 8002b4e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002b52:	461a      	mov	r2, r3
 8002b54:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8002b56:	441a      	add	r2, r3
 8002b58:	69fb      	ldr	r3, [r7, #28]
 8002b5a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002b5e:	4619      	mov	r1, r3
 8002b60:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8002b62:	440b      	add	r3, r1
 8002b64:	3b01      	subs	r3, #1
 8002b66:	69f9      	ldr	r1, [r7, #28]
 8002b68:	5c89      	ldrb	r1, [r1, r2]
 8002b6a:	69fa      	ldr	r2, [r7, #28]
 8002b6c:	54d1      	strb	r1, [r2, r3]
          for (int i=1; i<mov_len; i++)
 8002b6e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8002b70:	3301      	adds	r3, #1
 8002b72:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8002b74:	7efb      	ldrb	r3, [r7, #27]
 8002b76:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8002b78:	429a      	cmp	r2, r3
 8002b7a:	dbe7      	blt.n	8002b4c <cliUpdate+0xa8>
          }

          line->count--;
 8002b7c:	69fb      	ldr	r3, [r7, #28]
 8002b7e:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002b82:	3b01      	subs	r3, #1
 8002b84:	b2da      	uxtb	r2, r3
 8002b86:	69fb      	ldr	r3, [r7, #28]
 8002b88:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
          line->buf[line->count] = 0;
 8002b8c:	69fb      	ldr	r3, [r7, #28]
 8002b8e:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002b92:	461a      	mov	r2, r3
 8002b94:	69fb      	ldr	r3, [r7, #28]
 8002b96:	2100      	movs	r1, #0
 8002b98:	5499      	strb	r1, [r3, r2]

          uartPrintf(p_cli->ch, "\x1B[1P");
 8002b9a:	687b      	ldr	r3, [r7, #4]
 8002b9c:	781b      	ldrb	r3, [r3, #0]
 8002b9e:	498d      	ldr	r1, [pc, #564]	@ (8002dd4 <cliUpdate+0x330>)
 8002ba0:	4618      	mov	r0, r3
 8002ba2:	f005 ffd1 	bl	8008b48 <uartPrintf>
        }
        break;
 8002ba6:	e0f7      	b.n	8002d98 <cliUpdate+0x2f4>

      // 
      case CLI_KEY_BACK:
        if (line->count > 0 && line->cursor > 0)
 8002ba8:	69fb      	ldr	r3, [r7, #28]
 8002baa:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002bae:	2b00      	cmp	r3, #0
 8002bb0:	d055      	beq.n	8002c5e <cliUpdate+0x1ba>
 8002bb2:	69fb      	ldr	r3, [r7, #28]
 8002bb4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002bb8:	2b00      	cmp	r3, #0
 8002bba:	d050      	beq.n	8002c5e <cliUpdate+0x1ba>
        {
          if (line->cursor == line->count)
 8002bbc:	69fb      	ldr	r3, [r7, #28]
 8002bbe:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002bc2:	69fb      	ldr	r3, [r7, #28]
 8002bc4:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002bc8:	429a      	cmp	r2, r3
 8002bca:	d10e      	bne.n	8002bea <cliUpdate+0x146>
          {
            line->count--;
 8002bcc:	69fb      	ldr	r3, [r7, #28]
 8002bce:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002bd2:	3b01      	subs	r3, #1
 8002bd4:	b2da      	uxtb	r2, r3
 8002bd6:	69fb      	ldr	r3, [r7, #28]
 8002bd8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
            line->buf[line->count] = 0;
 8002bdc:	69fb      	ldr	r3, [r7, #28]
 8002bde:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002be2:	461a      	mov	r2, r3
 8002be4:	69fb      	ldr	r3, [r7, #28]
 8002be6:	2100      	movs	r1, #0
 8002be8:	5499      	strb	r1, [r3, r2]
          }

          if (line->cursor < line->count)
 8002bea:	69fb      	ldr	r3, [r7, #28]
 8002bec:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002bf0:	69fb      	ldr	r3, [r7, #28]
 8002bf2:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002bf6:	429a      	cmp	r2, r3
 8002bf8:	d231      	bcs.n	8002c5e <cliUpdate+0x1ba>
          {
            uint8_t mov_len;

            mov_len = line->count - line->cursor;
 8002bfa:	69fb      	ldr	r3, [r7, #28]
 8002bfc:	f893 2042 	ldrb.w	r2, [r3, #66]	@ 0x42
 8002c00:	69fb      	ldr	r3, [r7, #28]
 8002c02:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002c06:	1ad3      	subs	r3, r2, r3
 8002c08:	76bb      	strb	r3, [r7, #26]

            for (int i=0; i<mov_len; i++)
 8002c0a:	2300      	movs	r3, #0
 8002c0c:	62bb      	str	r3, [r7, #40]	@ 0x28
 8002c0e:	e013      	b.n	8002c38 <cliUpdate+0x194>
            {
              line->buf[line->cursor + i - 1] = line->buf[line->cursor + i];
 8002c10:	69fb      	ldr	r3, [r7, #28]
 8002c12:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002c16:	461a      	mov	r2, r3
 8002c18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002c1a:	441a      	add	r2, r3
 8002c1c:	69fb      	ldr	r3, [r7, #28]
 8002c1e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002c22:	4619      	mov	r1, r3
 8002c24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002c26:	440b      	add	r3, r1
 8002c28:	3b01      	subs	r3, #1
 8002c2a:	69f9      	ldr	r1, [r7, #28]
 8002c2c:	5c89      	ldrb	r1, [r1, r2]
 8002c2e:	69fa      	ldr	r2, [r7, #28]
 8002c30:	54d1      	strb	r1, [r2, r3]
            for (int i=0; i<mov_len; i++)
 8002c32:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002c34:	3301      	adds	r3, #1
 8002c36:	62bb      	str	r3, [r7, #40]	@ 0x28
 8002c38:	7ebb      	ldrb	r3, [r7, #26]
 8002c3a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8002c3c:	429a      	cmp	r2, r3
 8002c3e:	dbe7      	blt.n	8002c10 <cliUpdate+0x16c>
            }

            line->count--;
 8002c40:	69fb      	ldr	r3, [r7, #28]
 8002c42:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002c46:	3b01      	subs	r3, #1
 8002c48:	b2da      	uxtb	r2, r3
 8002c4a:	69fb      	ldr	r3, [r7, #28]
 8002c4c:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
            line->buf[line->count] = 0;
 8002c50:	69fb      	ldr	r3, [r7, #28]
 8002c52:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002c56:	461a      	mov	r2, r3
 8002c58:	69fb      	ldr	r3, [r7, #28]
 8002c5a:	2100      	movs	r1, #0
 8002c5c:	5499      	strb	r1, [r3, r2]
          }
        }

        if (line->cursor > 0)
 8002c5e:	69fb      	ldr	r3, [r7, #28]
 8002c60:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002c64:	2b00      	cmp	r3, #0
 8002c66:	f000 8099 	beq.w	8002d9c <cliUpdate+0x2f8>
        {
          line->cursor--;
 8002c6a:	69fb      	ldr	r3, [r7, #28]
 8002c6c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002c70:	3b01      	subs	r3, #1
 8002c72:	b2da      	uxtb	r2, r3
 8002c74:	69fb      	ldr	r3, [r7, #28]
 8002c76:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          uartPrintf(p_cli->ch, "\b \b\x1B[1P");
 8002c7a:	687b      	ldr	r3, [r7, #4]
 8002c7c:	781b      	ldrb	r3, [r3, #0]
 8002c7e:	4956      	ldr	r1, [pc, #344]	@ (8002dd8 <cliUpdate+0x334>)
 8002c80:	4618      	mov	r0, r3
 8002c82:	f005 ff61 	bl	8008b48 <uartPrintf>
        }
        break;
 8002c86:	e089      	b.n	8002d9c <cliUpdate+0x2f8>

      default:
        if ((line->count + 1) < line->buf_len)
 8002c88:	69fb      	ldr	r3, [r7, #28]
 8002c8a:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002c8e:	3301      	adds	r3, #1
 8002c90:	69fa      	ldr	r2, [r7, #28]
 8002c92:	f892 2040 	ldrb.w	r2, [r2, #64]	@ 0x40
 8002c96:	4293      	cmp	r3, r2
 8002c98:	f280 8082 	bge.w	8002da0 <cliUpdate+0x2fc>
        {
          if (line->cursor == line->count)
 8002c9c:	69fb      	ldr	r3, [r7, #28]
 8002c9e:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002ca2:	69fb      	ldr	r3, [r7, #28]
 8002ca4:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002ca8:	429a      	cmp	r2, r3
 8002caa:	d124      	bne.n	8002cf6 <cliUpdate+0x252>
          {
            uartWrite(p_cli->ch, &rx_data, 1);
 8002cac:	687b      	ldr	r3, [r7, #4]
 8002cae:	781b      	ldrb	r3, [r3, #0]
 8002cb0:	1cf9      	adds	r1, r7, #3
 8002cb2:	2201      	movs	r2, #1
 8002cb4:	4618      	mov	r0, r3
 8002cb6:	f005 ff1d 	bl	8008af4 <uartWrite>

            line->buf[line->cursor] = rx_data;
 8002cba:	69fb      	ldr	r3, [r7, #28]
 8002cbc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002cc0:	461a      	mov	r2, r3
 8002cc2:	78f9      	ldrb	r1, [r7, #3]
 8002cc4:	69fb      	ldr	r3, [r7, #28]
 8002cc6:	5499      	strb	r1, [r3, r2]
            line->count++;
 8002cc8:	69fb      	ldr	r3, [r7, #28]
 8002cca:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002cce:	3301      	adds	r3, #1
 8002cd0:	b2da      	uxtb	r2, r3
 8002cd2:	69fb      	ldr	r3, [r7, #28]
 8002cd4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
            line->cursor++;
 8002cd8:	69fb      	ldr	r3, [r7, #28]
 8002cda:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002cde:	3301      	adds	r3, #1
 8002ce0:	b2da      	uxtb	r2, r3
 8002ce2:	69fb      	ldr	r3, [r7, #28]
 8002ce4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
            line->buf[line->count] = 0;
 8002ce8:	69fb      	ldr	r3, [r7, #28]
 8002cea:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002cee:	461a      	mov	r2, r3
 8002cf0:	69fb      	ldr	r3, [r7, #28]
 8002cf2:	2100      	movs	r1, #0
 8002cf4:	5499      	strb	r1, [r3, r2]
          }
          if (line->cursor < line->count)
 8002cf6:	69fb      	ldr	r3, [r7, #28]
 8002cf8:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002cfc:	69fb      	ldr	r3, [r7, #28]
 8002cfe:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002d02:	429a      	cmp	r2, r3
 8002d04:	d24c      	bcs.n	8002da0 <cliUpdate+0x2fc>
          {
            uint8_t mov_len;

            mov_len = line->count - line->cursor;
 8002d06:	69fb      	ldr	r3, [r7, #28]
 8002d08:	f893 2042 	ldrb.w	r2, [r3, #66]	@ 0x42
 8002d0c:	69fb      	ldr	r3, [r7, #28]
 8002d0e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002d12:	1ad3      	subs	r3, r2, r3
 8002d14:	767b      	strb	r3, [r7, #25]
            for (int i=0; i<mov_len; i++)
 8002d16:	2300      	movs	r3, #0
 8002d18:	627b      	str	r3, [r7, #36]	@ 0x24
 8002d1a:	e013      	b.n	8002d44 <cliUpdate+0x2a0>
            {
              line->buf[line->count - i] = line->buf[line->count - i - 1];
 8002d1c:	69fb      	ldr	r3, [r7, #28]
 8002d1e:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002d22:	461a      	mov	r2, r3
 8002d24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002d26:	1ad3      	subs	r3, r2, r3
 8002d28:	1e5a      	subs	r2, r3, #1
 8002d2a:	69fb      	ldr	r3, [r7, #28]
 8002d2c:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002d30:	4619      	mov	r1, r3
 8002d32:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002d34:	1acb      	subs	r3, r1, r3
 8002d36:	69f9      	ldr	r1, [r7, #28]
 8002d38:	5c89      	ldrb	r1, [r1, r2]
 8002d3a:	69fa      	ldr	r2, [r7, #28]
 8002d3c:	54d1      	strb	r1, [r2, r3]
            for (int i=0; i<mov_len; i++)
 8002d3e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002d40:	3301      	adds	r3, #1
 8002d42:	627b      	str	r3, [r7, #36]	@ 0x24
 8002d44:	7e7b      	ldrb	r3, [r7, #25]
 8002d46:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8002d48:	429a      	cmp	r2, r3
 8002d4a:	dbe7      	blt.n	8002d1c <cliUpdate+0x278>
            }
            line->buf[line->cursor] = rx_data;
 8002d4c:	69fb      	ldr	r3, [r7, #28]
 8002d4e:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002d52:	461a      	mov	r2, r3
 8002d54:	78f9      	ldrb	r1, [r7, #3]
 8002d56:	69fb      	ldr	r3, [r7, #28]
 8002d58:	5499      	strb	r1, [r3, r2]
            line->count++;
 8002d5a:	69fb      	ldr	r3, [r7, #28]
 8002d5c:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002d60:	3301      	adds	r3, #1
 8002d62:	b2da      	uxtb	r2, r3
 8002d64:	69fb      	ldr	r3, [r7, #28]
 8002d66:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
            line->cursor++;
 8002d6a:	69fb      	ldr	r3, [r7, #28]
 8002d6c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002d70:	3301      	adds	r3, #1
 8002d72:	b2da      	uxtb	r2, r3
 8002d74:	69fb      	ldr	r3, [r7, #28]
 8002d76:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
            line->buf[line->count] = 0;
 8002d7a:	69fb      	ldr	r3, [r7, #28]
 8002d7c:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002d80:	461a      	mov	r2, r3
 8002d82:	69fb      	ldr	r3, [r7, #28]
 8002d84:	2100      	movs	r1, #0
 8002d86:	5499      	strb	r1, [r3, r2]

            uartPrintf(p_cli->ch, "\x1B[4h%c\x1B[4l", rx_data);
 8002d88:	687b      	ldr	r3, [r7, #4]
 8002d8a:	781b      	ldrb	r3, [r3, #0]
 8002d8c:	78fa      	ldrb	r2, [r7, #3]
 8002d8e:	4913      	ldr	r1, [pc, #76]	@ (8002ddc <cliUpdate+0x338>)
 8002d90:	4618      	mov	r0, r3
 8002d92:	f005 fed9 	bl	8008b48 <uartPrintf>
          }
        }
        break;
 8002d96:	e003      	b.n	8002da0 <cliUpdate+0x2fc>
        break;
 8002d98:	bf00      	nop
 8002d9a:	e002      	b.n	8002da2 <cliUpdate+0x2fe>
        break;
 8002d9c:	bf00      	nop
 8002d9e:	e000      	b.n	8002da2 <cliUpdate+0x2fe>
        break;
 8002da0:	bf00      	nop
    }
  }

  switch(p_cli->state)
 8002da2:	687b      	ldr	r3, [r7, #4]
 8002da4:	7c1b      	ldrb	r3, [r3, #16]
 8002da6:	3b01      	subs	r3, #1
 8002da8:	2b03      	cmp	r3, #3
 8002daa:	f200 80d0 	bhi.w	8002f4e <cliUpdate+0x4aa>
 8002dae:	a201      	add	r2, pc, #4	@ (adr r2, 8002db4 <cliUpdate+0x310>)
 8002db0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002db4:	08002dc5 	.word	0x08002dc5
 8002db8:	08002dcd 	.word	0x08002dcd
 8002dbc:	08002de1 	.word	0x08002de1
 8002dc0:	08002f45 	.word	0x08002f45
  {
    case CLI_RX_SP1:
      p_cli->state = CLI_RX_SP2;
 8002dc4:	687b      	ldr	r3, [r7, #4]
 8002dc6:	2202      	movs	r2, #2
 8002dc8:	741a      	strb	r2, [r3, #16]
      break;
 8002dca:	e0c0      	b.n	8002f4e <cliUpdate+0x4aa>

    case CLI_RX_SP2:
      p_cli->state = CLI_RX_SP3;
 8002dcc:	687b      	ldr	r3, [r7, #4]
 8002dce:	2203      	movs	r2, #3
 8002dd0:	741a      	strb	r2, [r3, #16]
      break;
 8002dd2:	e0bc      	b.n	8002f4e <cliUpdate+0x4aa>
 8002dd4:	08024180 	.word	0x08024180
 8002dd8:	08024188 	.word	0x08024188
 8002ddc:	08024190 	.word	0x08024190

    case CLI_RX_SP3:
      p_cli->state = CLI_RX_IDLE;
 8002de0:	687b      	ldr	r3, [r7, #4]
 8002de2:	2200      	movs	r2, #0
 8002de4:	741a      	strb	r2, [r3, #16]

      if (rx_data == CLI_KEY_LEFT)
 8002de6:	78fb      	ldrb	r3, [r7, #3]
 8002de8:	2b44      	cmp	r3, #68	@ 0x44
 8002dea:	d11a      	bne.n	8002e22 <cliUpdate+0x37e>
      {
        if (line->cursor > 0)
 8002dec:	69fb      	ldr	r3, [r7, #28]
 8002dee:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002df2:	2b00      	cmp	r3, #0
 8002df4:	d015      	beq.n	8002e22 <cliUpdate+0x37e>
        {
          line->cursor--;
 8002df6:	69fb      	ldr	r3, [r7, #28]
 8002df8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002dfc:	3b01      	subs	r3, #1
 8002dfe:	b2da      	uxtb	r2, r3
 8002e00:	69fb      	ldr	r3, [r7, #28]
 8002e02:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          tx_buf[0] = 0x1B;
 8002e06:	231b      	movs	r3, #27
 8002e08:	733b      	strb	r3, [r7, #12]
          tx_buf[1] = 0x5B;
 8002e0a:	235b      	movs	r3, #91	@ 0x5b
 8002e0c:	737b      	strb	r3, [r7, #13]
          tx_buf[2] = rx_data;
 8002e0e:	78fb      	ldrb	r3, [r7, #3]
 8002e10:	73bb      	strb	r3, [r7, #14]
          uartWrite(p_cli->ch, tx_buf, 3);
 8002e12:	687b      	ldr	r3, [r7, #4]
 8002e14:	781b      	ldrb	r3, [r3, #0]
 8002e16:	f107 010c 	add.w	r1, r7, #12
 8002e1a:	2203      	movs	r2, #3
 8002e1c:	4618      	mov	r0, r3
 8002e1e:	f005 fe69 	bl	8008af4 <uartWrite>
        }
      }

      if (rx_data == CLI_KEY_RIGHT)
 8002e22:	78fb      	ldrb	r3, [r7, #3]
 8002e24:	2b43      	cmp	r3, #67	@ 0x43
 8002e26:	d11d      	bne.n	8002e64 <cliUpdate+0x3c0>
      {
        if (line->cursor < line->count)
 8002e28:	69fb      	ldr	r3, [r7, #28]
 8002e2a:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002e2e:	69fb      	ldr	r3, [r7, #28]
 8002e30:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002e34:	429a      	cmp	r2, r3
 8002e36:	d215      	bcs.n	8002e64 <cliUpdate+0x3c0>
        {
          line->cursor++;
 8002e38:	69fb      	ldr	r3, [r7, #28]
 8002e3a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002e3e:	3301      	adds	r3, #1
 8002e40:	b2da      	uxtb	r2, r3
 8002e42:	69fb      	ldr	r3, [r7, #28]
 8002e44:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

          tx_buf[0] = 0x1B;
 8002e48:	231b      	movs	r3, #27
 8002e4a:	733b      	strb	r3, [r7, #12]
          tx_buf[1] = 0x5B;
 8002e4c:	235b      	movs	r3, #91	@ 0x5b
 8002e4e:	737b      	strb	r3, [r7, #13]
          tx_buf[2] = rx_data;
 8002e50:	78fb      	ldrb	r3, [r7, #3]
 8002e52:	73bb      	strb	r3, [r7, #14]
          uartWrite(p_cli->ch, tx_buf, 3);
 8002e54:	687b      	ldr	r3, [r7, #4]
 8002e56:	781b      	ldrb	r3, [r3, #0]
 8002e58:	f107 010c 	add.w	r1, r7, #12
 8002e5c:	2203      	movs	r2, #3
 8002e5e:	4618      	mov	r0, r3
 8002e60:	f005 fe48 	bl	8008af4 <uartWrite>
        }
      }

      if (rx_data == CLI_KEY_UP)
 8002e64:	78fb      	ldrb	r3, [r7, #3]
 8002e66:	2b41      	cmp	r3, #65	@ 0x41
 8002e68:	d10c      	bne.n	8002e84 <cliUpdate+0x3e0>
      {
        cliLineChange(p_cli, true);
 8002e6a:	2101      	movs	r1, #1
 8002e6c:	6878      	ldr	r0, [r7, #4]
 8002e6e:	f000 f8df 	bl	8003030 <cliLineChange>
        uartPrintf(p_cli->ch, (char *)p_cli->line.buf);
 8002e72:	687b      	ldr	r3, [r7, #4]
 8002e74:	781a      	ldrb	r2, [r3, #0]
 8002e76:	687b      	ldr	r3, [r7, #4]
 8002e78:	f203 23e7 	addw	r3, r3, #743	@ 0x2e7
 8002e7c:	4619      	mov	r1, r3
 8002e7e:	4610      	mov	r0, r2
 8002e80:	f005 fe62 	bl	8008b48 <uartPrintf>
      }

      if (rx_data == CLI_KEY_DOWN)
 8002e84:	78fb      	ldrb	r3, [r7, #3]
 8002e86:	2b42      	cmp	r3, #66	@ 0x42
 8002e88:	d10c      	bne.n	8002ea4 <cliUpdate+0x400>
      {
        cliLineChange(p_cli, false);
 8002e8a:	2100      	movs	r1, #0
 8002e8c:	6878      	ldr	r0, [r7, #4]
 8002e8e:	f000 f8cf 	bl	8003030 <cliLineChange>
        uartPrintf(p_cli->ch, (char *)p_cli->line.buf);
 8002e92:	687b      	ldr	r3, [r7, #4]
 8002e94:	781a      	ldrb	r2, [r3, #0]
 8002e96:	687b      	ldr	r3, [r7, #4]
 8002e98:	f203 23e7 	addw	r3, r3, #743	@ 0x2e7
 8002e9c:	4619      	mov	r1, r3
 8002e9e:	4610      	mov	r0, r2
 8002ea0:	f005 fe52 	bl	8008b48 <uartPrintf>
      }

      if (rx_data == CLI_KEY_HOME)
 8002ea4:	78fb      	ldrb	r3, [r7, #3]
 8002ea6:	2b31      	cmp	r3, #49	@ 0x31
 8002ea8:	d10f      	bne.n	8002eca <cliUpdate+0x426>
      {
        uartPrintf(p_cli->ch, "\x1B[%dD", line->cursor);
 8002eaa:	687b      	ldr	r3, [r7, #4]
 8002eac:	7818      	ldrb	r0, [r3, #0]
 8002eae:	69fb      	ldr	r3, [r7, #28]
 8002eb0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002eb4:	461a      	mov	r2, r3
 8002eb6:	492a      	ldr	r1, [pc, #168]	@ (8002f60 <cliUpdate+0x4bc>)
 8002eb8:	f005 fe46 	bl	8008b48 <uartPrintf>
        line->cursor = 0;
 8002ebc:	69fb      	ldr	r3, [r7, #28]
 8002ebe:	2200      	movs	r2, #0
 8002ec0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

        p_cli->state = CLI_RX_SP4;
 8002ec4:	687b      	ldr	r3, [r7, #4]
 8002ec6:	2204      	movs	r2, #4
 8002ec8:	741a      	strb	r2, [r3, #16]
      }

      if (rx_data == CLI_KEY_END)
 8002eca:	78fb      	ldrb	r3, [r7, #3]
 8002ecc:	2b34      	cmp	r3, #52	@ 0x34
 8002ece:	d13d      	bne.n	8002f4c <cliUpdate+0x4a8>
      {
        uint16_t mov_len;

        if (line->cursor < line->count)
 8002ed0:	69fb      	ldr	r3, [r7, #28]
 8002ed2:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002ed6:	69fb      	ldr	r3, [r7, #28]
 8002ed8:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002edc:	429a      	cmp	r2, r3
 8002ede:	d20f      	bcs.n	8002f00 <cliUpdate+0x45c>
        {
          mov_len = line->count - line->cursor;
 8002ee0:	69fb      	ldr	r3, [r7, #28]
 8002ee2:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002ee6:	461a      	mov	r2, r3
 8002ee8:	69fb      	ldr	r3, [r7, #28]
 8002eea:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002eee:	1ad3      	subs	r3, r2, r3
 8002ef0:	82fb      	strh	r3, [r7, #22]
          uartPrintf(p_cli->ch, "\x1B[%dC", mov_len);
 8002ef2:	687b      	ldr	r3, [r7, #4]
 8002ef4:	781b      	ldrb	r3, [r3, #0]
 8002ef6:	8afa      	ldrh	r2, [r7, #22]
 8002ef8:	491a      	ldr	r1, [pc, #104]	@ (8002f64 <cliUpdate+0x4c0>)
 8002efa:	4618      	mov	r0, r3
 8002efc:	f005 fe24 	bl	8008b48 <uartPrintf>
        }
        if (line->cursor > line->count)
 8002f00:	69fb      	ldr	r3, [r7, #28]
 8002f02:	f893 2041 	ldrb.w	r2, [r3, #65]	@ 0x41
 8002f06:	69fb      	ldr	r3, [r7, #28]
 8002f08:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002f0c:	429a      	cmp	r2, r3
 8002f0e:	d90f      	bls.n	8002f30 <cliUpdate+0x48c>
        {
          mov_len = line->cursor - line->count;
 8002f10:	69fb      	ldr	r3, [r7, #28]
 8002f12:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8002f16:	461a      	mov	r2, r3
 8002f18:	69fb      	ldr	r3, [r7, #28]
 8002f1a:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8002f1e:	1ad3      	subs	r3, r2, r3
 8002f20:	82fb      	strh	r3, [r7, #22]
          uartPrintf(p_cli->ch, "\x1B[%dD", mov_len);
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	781b      	ldrb	r3, [r3, #0]
 8002f26:	8afa      	ldrh	r2, [r7, #22]
 8002f28:	490d      	ldr	r1, [pc, #52]	@ (8002f60 <cliUpdate+0x4bc>)
 8002f2a:	4618      	mov	r0, r3
 8002f2c:	f005 fe0c 	bl	8008b48 <uartPrintf>
        }
        line->cursor = line->count;
 8002f30:	69fb      	ldr	r3, [r7, #28]
 8002f32:	f893 2042 	ldrb.w	r2, [r3, #66]	@ 0x42
 8002f36:	69fb      	ldr	r3, [r7, #28]
 8002f38:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        p_cli->state = CLI_RX_SP4;
 8002f3c:	687b      	ldr	r3, [r7, #4]
 8002f3e:	2204      	movs	r2, #4
 8002f40:	741a      	strb	r2, [r3, #16]
      }
      break;
 8002f42:	e003      	b.n	8002f4c <cliUpdate+0x4a8>

    case CLI_RX_SP4:
      p_cli->state = CLI_RX_IDLE;
 8002f44:	687b      	ldr	r3, [r7, #4]
 8002f46:	2200      	movs	r2, #0
 8002f48:	741a      	strb	r2, [r3, #16]
      break;
 8002f4a:	e000      	b.n	8002f4e <cliUpdate+0x4aa>
      break;
 8002f4c:	bf00      	nop
  }

  cliShowLog(p_cli);
 8002f4e:	6878      	ldr	r0, [r7, #4]
 8002f50:	f7ff fcd4 	bl	80028fc <cliShowLog>

  return ret;
 8002f54:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
}
 8002f58:	4618      	mov	r0, r3
 8002f5a:	3730      	adds	r7, #48	@ 0x30
 8002f5c:	46bd      	mov	sp, r7
 8002f5e:	bd80      	pop	{r7, pc}
 8002f60:	0802419c 	.word	0x0802419c
 8002f64:	080241a4 	.word	0x080241a4

08002f68 <cliLineClean>:

void cliLineClean(cli_t *p_cli)
{
 8002f68:	b480      	push	{r7}
 8002f6a:	b083      	sub	sp, #12
 8002f6c:	af00      	add	r7, sp, #0
 8002f6e:	6078      	str	r0, [r7, #4]
  p_cli->line.count   = 0;
 8002f70:	687b      	ldr	r3, [r7, #4]
 8002f72:	2200      	movs	r2, #0
 8002f74:	f883 2329 	strb.w	r2, [r3, #809]	@ 0x329
  p_cli->line.cursor  = 0;
 8002f78:	687b      	ldr	r3, [r7, #4]
 8002f7a:	2200      	movs	r2, #0
 8002f7c:	f883 2328 	strb.w	r2, [r3, #808]	@ 0x328
  p_cli->line.buf_len = CLI_LINE_BUF_MAX - 1;
 8002f80:	687b      	ldr	r3, [r7, #4]
 8002f82:	223f      	movs	r2, #63	@ 0x3f
 8002f84:	f883 2327 	strb.w	r2, [r3, #807]	@ 0x327
  p_cli->line.buf[0]  = 0;
 8002f88:	687b      	ldr	r3, [r7, #4]
 8002f8a:	2200      	movs	r2, #0
 8002f8c:	f883 22e7 	strb.w	r2, [r3, #743]	@ 0x2e7
}
 8002f90:	bf00      	nop
 8002f92:	370c      	adds	r7, #12
 8002f94:	46bd      	mov	sp, r7
 8002f96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002f9a:	4770      	bx	lr

08002f9c <cliLineAdd>:

void cliLineAdd(cli_t *p_cli)
{
 8002f9c:	b580      	push	{r7, lr}
 8002f9e:	b082      	sub	sp, #8
 8002fa0:	af00      	add	r7, sp, #0
 8002fa2:	6078      	str	r0, [r7, #4]

  p_cli->line_buf[p_cli->hist_line_last] = p_cli->line;
 8002fa4:	687b      	ldr	r3, [r7, #4]
 8002fa6:	f893 3196 	ldrb.w	r3, [r3, #406]	@ 0x196
 8002faa:	461a      	mov	r2, r3
 8002fac:	6879      	ldr	r1, [r7, #4]
 8002fae:	4613      	mov	r3, r2
 8002fb0:	015b      	lsls	r3, r3, #5
 8002fb2:	4413      	add	r3, r2
 8002fb4:	005b      	lsls	r3, r3, #1
 8002fb6:	4413      	add	r3, r2
 8002fb8:	440b      	add	r3, r1
 8002fba:	f503 72cc 	add.w	r2, r3, #408	@ 0x198
 8002fbe:	687b      	ldr	r3, [r7, #4]
 8002fc0:	4610      	mov	r0, r2
 8002fc2:	f203 23e7 	addw	r3, r3, #743	@ 0x2e7
 8002fc6:	2243      	movs	r2, #67	@ 0x43
 8002fc8:	4619      	mov	r1, r3
 8002fca:	f01f f96c 	bl	80222a6 <memcpy>

  if (p_cli->hist_line_count < CLI_LINE_HIS_MAX)
 8002fce:	687b      	ldr	r3, [r7, #4]
 8002fd0:	f893 3197 	ldrb.w	r3, [r3, #407]	@ 0x197
 8002fd4:	2b04      	cmp	r3, #4
 8002fd6:	d807      	bhi.n	8002fe8 <cliLineAdd+0x4c>
  {
    p_cli->hist_line_count++;
 8002fd8:	687b      	ldr	r3, [r7, #4]
 8002fda:	f893 3197 	ldrb.w	r3, [r3, #407]	@ 0x197
 8002fde:	3301      	adds	r3, #1
 8002fe0:	b2da      	uxtb	r2, r3
 8002fe2:	687b      	ldr	r3, [r7, #4]
 8002fe4:	f883 2197 	strb.w	r2, [r3, #407]	@ 0x197
  }

  p_cli->hist_line_i    = p_cli->hist_line_last;
 8002fe8:	687b      	ldr	r3, [r7, #4]
 8002fea:	f893 3196 	ldrb.w	r3, [r3, #406]	@ 0x196
 8002fee:	b25a      	sxtb	r2, r3
 8002ff0:	687b      	ldr	r3, [r7, #4]
 8002ff2:	f883 2195 	strb.w	r2, [r3, #405]	@ 0x195
  p_cli->hist_line_last = (p_cli->hist_line_last + 1) % CLI_LINE_HIS_MAX;
 8002ff6:	687b      	ldr	r3, [r7, #4]
 8002ff8:	f893 3196 	ldrb.w	r3, [r3, #406]	@ 0x196
 8002ffc:	1c5a      	adds	r2, r3, #1
 8002ffe:	4b0b      	ldr	r3, [pc, #44]	@ (800302c <cliLineAdd+0x90>)
 8003000:	fb83 1302 	smull	r1, r3, r3, r2
 8003004:	1059      	asrs	r1, r3, #1
 8003006:	17d3      	asrs	r3, r2, #31
 8003008:	1ac9      	subs	r1, r1, r3
 800300a:	460b      	mov	r3, r1
 800300c:	009b      	lsls	r3, r3, #2
 800300e:	440b      	add	r3, r1
 8003010:	1ad1      	subs	r1, r2, r3
 8003012:	b2ca      	uxtb	r2, r1
 8003014:	687b      	ldr	r3, [r7, #4]
 8003016:	f883 2196 	strb.w	r2, [r3, #406]	@ 0x196
  p_cli->hist_line_new  = true;
 800301a:	687b      	ldr	r3, [r7, #4]
 800301c:	2201      	movs	r2, #1
 800301e:	f883 2194 	strb.w	r2, [r3, #404]	@ 0x194
}
 8003022:	bf00      	nop
 8003024:	3708      	adds	r7, #8
 8003026:	46bd      	mov	sp, r7
 8003028:	bd80      	pop	{r7, pc}
 800302a:	bf00      	nop
 800302c:	66666667 	.word	0x66666667

08003030 <cliLineChange>:

void cliLineChange(cli_t *p_cli, int8_t key_up)
{
 8003030:	b580      	push	{r7, lr}
 8003032:	b084      	sub	sp, #16
 8003034:	af00      	add	r7, sp, #0
 8003036:	6078      	str	r0, [r7, #4]
 8003038:	460b      	mov	r3, r1
 800303a:	70fb      	strb	r3, [r7, #3]
  uint8_t change_i;


  if (p_cli->hist_line_count == 0)
 800303c:	687b      	ldr	r3, [r7, #4]
 800303e:	f893 3197 	ldrb.w	r3, [r3, #407]	@ 0x197
 8003042:	2b00      	cmp	r3, #0
 8003044:	d076      	beq.n	8003134 <cliLineChange+0x104>
  {
    return;
  }


  if (p_cli->line.cursor > 0)
 8003046:	687b      	ldr	r3, [r7, #4]
 8003048:	f893 3328 	ldrb.w	r3, [r3, #808]	@ 0x328
 800304c:	2b00      	cmp	r3, #0
 800304e:	d008      	beq.n	8003062 <cliLineChange+0x32>
  {
    uartPrintf(p_cli->ch, "\x1B[%dD", p_cli->line.cursor);
 8003050:	687b      	ldr	r3, [r7, #4]
 8003052:	7818      	ldrb	r0, [r3, #0]
 8003054:	687b      	ldr	r3, [r7, #4]
 8003056:	f893 3328 	ldrb.w	r3, [r3, #808]	@ 0x328
 800305a:	461a      	mov	r2, r3
 800305c:	4937      	ldr	r1, [pc, #220]	@ (800313c <cliLineChange+0x10c>)
 800305e:	f005 fd73 	bl	8008b48 <uartPrintf>
  }
  if (p_cli->line.count > 0)
 8003062:	687b      	ldr	r3, [r7, #4]
 8003064:	f893 3329 	ldrb.w	r3, [r3, #809]	@ 0x329
 8003068:	2b00      	cmp	r3, #0
 800306a:	d008      	beq.n	800307e <cliLineChange+0x4e>
  {
    uartPrintf(p_cli->ch, "\x1B[%dP", p_cli->line.count);
 800306c:	687b      	ldr	r3, [r7, #4]
 800306e:	7818      	ldrb	r0, [r3, #0]
 8003070:	687b      	ldr	r3, [r7, #4]
 8003072:	f893 3329 	ldrb.w	r3, [r3, #809]	@ 0x329
 8003076:	461a      	mov	r2, r3
 8003078:	4931      	ldr	r1, [pc, #196]	@ (8003140 <cliLineChange+0x110>)
 800307a:	f005 fd65 	bl	8008b48 <uartPrintf>
  }


  if (key_up == true)
 800307e:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8003082:	2b01      	cmp	r3, #1
 8003084:	d125      	bne.n	80030d2 <cliLineChange+0xa2>
  {
    if (p_cli->hist_line_new == true)
 8003086:	687b      	ldr	r3, [r7, #4]
 8003088:	f893 3194 	ldrb.w	r3, [r3, #404]	@ 0x194
 800308c:	2b00      	cmp	r3, #0
 800308e:	d006      	beq.n	800309e <cliLineChange+0x6e>
    {
      p_cli->hist_line_i = p_cli->hist_line_last;
 8003090:	687b      	ldr	r3, [r7, #4]
 8003092:	f893 3196 	ldrb.w	r3, [r3, #406]	@ 0x196
 8003096:	b25a      	sxtb	r2, r3
 8003098:	687b      	ldr	r3, [r7, #4]
 800309a:	f883 2195 	strb.w	r2, [r3, #405]	@ 0x195
    }
    p_cli->hist_line_i = (p_cli->hist_line_i + p_cli->hist_line_count - 1) % p_cli->hist_line_count;
 800309e:	687b      	ldr	r3, [r7, #4]
 80030a0:	f993 3195 	ldrsb.w	r3, [r3, #405]	@ 0x195
 80030a4:	461a      	mov	r2, r3
 80030a6:	687b      	ldr	r3, [r7, #4]
 80030a8:	f893 3197 	ldrb.w	r3, [r3, #407]	@ 0x197
 80030ac:	4413      	add	r3, r2
 80030ae:	3b01      	subs	r3, #1
 80030b0:	687a      	ldr	r2, [r7, #4]
 80030b2:	f892 2197 	ldrb.w	r2, [r2, #407]	@ 0x197
 80030b6:	fb93 f1f2 	sdiv	r1, r3, r2
 80030ba:	fb01 f202 	mul.w	r2, r1, r2
 80030be:	1a9b      	subs	r3, r3, r2
 80030c0:	b25a      	sxtb	r2, r3
 80030c2:	687b      	ldr	r3, [r7, #4]
 80030c4:	f883 2195 	strb.w	r2, [r3, #405]	@ 0x195
    change_i = p_cli->hist_line_i;
 80030c8:	687b      	ldr	r3, [r7, #4]
 80030ca:	f993 3195 	ldrsb.w	r3, [r3, #405]	@ 0x195
 80030ce:	73fb      	strb	r3, [r7, #15]
 80030d0:	e013      	b.n	80030fa <cliLineChange+0xca>
  }
  else
  {
    p_cli->hist_line_i = (p_cli->hist_line_i + 1) % p_cli->hist_line_count;
 80030d2:	687b      	ldr	r3, [r7, #4]
 80030d4:	f993 3195 	ldrsb.w	r3, [r3, #405]	@ 0x195
 80030d8:	3301      	adds	r3, #1
 80030da:	687a      	ldr	r2, [r7, #4]
 80030dc:	f892 2197 	ldrb.w	r2, [r2, #407]	@ 0x197
 80030e0:	fb93 f1f2 	sdiv	r1, r3, r2
 80030e4:	fb01 f202 	mul.w	r2, r1, r2
 80030e8:	1a9b      	subs	r3, r3, r2
 80030ea:	b25a      	sxtb	r2, r3
 80030ec:	687b      	ldr	r3, [r7, #4]
 80030ee:	f883 2195 	strb.w	r2, [r3, #405]	@ 0x195
    change_i = p_cli->hist_line_i;
 80030f2:	687b      	ldr	r3, [r7, #4]
 80030f4:	f993 3195 	ldrsb.w	r3, [r3, #405]	@ 0x195
 80030f8:	73fb      	strb	r3, [r7, #15]
  }

  p_cli->line = p_cli->line_buf[change_i];
 80030fa:	7bfa      	ldrb	r2, [r7, #15]
 80030fc:	6879      	ldr	r1, [r7, #4]
 80030fe:	6878      	ldr	r0, [r7, #4]
 8003100:	4613      	mov	r3, r2
 8003102:	015b      	lsls	r3, r3, #5
 8003104:	4413      	add	r3, r2
 8003106:	005b      	lsls	r3, r3, #1
 8003108:	4413      	add	r3, r2
 800310a:	4403      	add	r3, r0
 800310c:	f503 72cc 	add.w	r2, r3, #408	@ 0x198
 8003110:	f201 23e7 	addw	r3, r1, #743	@ 0x2e7
 8003114:	4611      	mov	r1, r2
 8003116:	2243      	movs	r2, #67	@ 0x43
 8003118:	4618      	mov	r0, r3
 800311a:	f01f f8c4 	bl	80222a6 <memcpy>
  p_cli->line.cursor = p_cli->line.count;
 800311e:	687b      	ldr	r3, [r7, #4]
 8003120:	f893 2329 	ldrb.w	r2, [r3, #809]	@ 0x329
 8003124:	687b      	ldr	r3, [r7, #4]
 8003126:	f883 2328 	strb.w	r2, [r3, #808]	@ 0x328

  p_cli->hist_line_new = false;
 800312a:	687b      	ldr	r3, [r7, #4]
 800312c:	2200      	movs	r2, #0
 800312e:	f883 2194 	strb.w	r2, [r3, #404]	@ 0x194
 8003132:	e000      	b.n	8003136 <cliLineChange+0x106>
    return;
 8003134:	bf00      	nop
}
 8003136:	3710      	adds	r7, #16
 8003138:	46bd      	mov	sp, r7
 800313a:	bd80      	pop	{r7, pc}
 800313c:	0802419c 	.word	0x0802419c
 8003140:	080241ac 	.word	0x080241ac

08003144 <cliRunCmd>:

bool cliRunCmd(cli_t *p_cli)
{
 8003144:	b580      	push	{r7, lr}
 8003146:	b084      	sub	sp, #16
 8003148:	af00      	add	r7, sp, #0
 800314a:	6078      	str	r0, [r7, #4]
  bool ret = false;
 800314c:	2300      	movs	r3, #0
 800314e:	72fb      	strb	r3, [r7, #11]


  if (cliParseArgs(p_cli) == true)
 8003150:	6878      	ldr	r0, [r7, #4]
 8003152:	f000 f851 	bl	80031f8 <cliParseArgs>
 8003156:	4603      	mov	r3, r0
 8003158:	2b00      	cmp	r3, #0
 800315a:	d046      	beq.n	80031ea <cliRunCmd+0xa6>
  {
    cliPrintf("\r\n");
 800315c:	4825      	ldr	r0, [pc, #148]	@ (80031f4 <cliRunCmd+0xb0>)
 800315e:	f000 f893 	bl	8003288 <cliPrintf>

    cliToUpper(p_cli->argv[0]);
 8003162:	687b      	ldr	r3, [r7, #4]
 8003164:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 8003168:	4618      	mov	r0, r3
 800316a:	f000 f8b1 	bl	80032d0 <cliToUpper>

    for (int i=0; i<p_cli->cmd_count; i++)
 800316e:	2300      	movs	r3, #0
 8003170:	60fb      	str	r3, [r7, #12]
 8003172:	e033      	b.n	80031dc <cliRunCmd+0x98>
    {
      if (strcmp(p_cli->argv[0], p_cli->cmd_list[i].cmd_str) == 0)
 8003174:	687b      	ldr	r3, [r7, #4]
 8003176:	f8d3 0114 	ldr.w	r0, [r3, #276]	@ 0x114
 800317a:	68fa      	ldr	r2, [r7, #12]
 800317c:	4613      	mov	r3, r2
 800317e:	009b      	lsls	r3, r3, #2
 8003180:	4413      	add	r3, r2
 8003182:	009b      	lsls	r3, r3, #2
 8003184:	f503 734a 	add.w	r3, r3, #808	@ 0x328
 8003188:	687a      	ldr	r2, [r7, #4]
 800318a:	4413      	add	r3, r2
 800318c:	3304      	adds	r3, #4
 800318e:	4619      	mov	r1, r3
 8003190:	f7fd f886 	bl	80002a0 <strcmp>
 8003194:	4603      	mov	r3, r0
 8003196:	2b00      	cmp	r3, #0
 8003198:	d11d      	bne.n	80031d6 <cliRunCmd+0x92>
      {
        p_cli->cmd_args.argc =  p_cli->argc - 1;
 800319a:	687b      	ldr	r3, [r7, #4]
 800319c:	f8b3 3112 	ldrh.w	r3, [r3, #274]	@ 0x112
 80031a0:	3b01      	subs	r3, #1
 80031a2:	b29a      	uxth	r2, r3
 80031a4:	687b      	ldr	r3, [r7, #4]
 80031a6:	f8a3 246c 	strh.w	r2, [r3, #1132]	@ 0x46c
        p_cli->cmd_args.argv = &p_cli->argv[1];
 80031aa:	687b      	ldr	r3, [r7, #4]
 80031ac:	f503 728c 	add.w	r2, r3, #280	@ 0x118
 80031b0:	687b      	ldr	r3, [r7, #4]
 80031b2:	f8c3 2470 	str.w	r2, [r3, #1136]	@ 0x470
        p_cli->cmd_list[i].cmd_func(&p_cli->cmd_args);
 80031b6:	6879      	ldr	r1, [r7, #4]
 80031b8:	68fa      	ldr	r2, [r7, #12]
 80031ba:	4613      	mov	r3, r2
 80031bc:	009b      	lsls	r3, r3, #2
 80031be:	4413      	add	r3, r2
 80031c0:	009b      	lsls	r3, r3, #2
 80031c2:	440b      	add	r3, r1
 80031c4:	f503 734f 	add.w	r3, r3, #828	@ 0x33c
 80031c8:	681b      	ldr	r3, [r3, #0]
 80031ca:	687a      	ldr	r2, [r7, #4]
 80031cc:	f202 426c 	addw	r2, r2, #1132	@ 0x46c
 80031d0:	4610      	mov	r0, r2
 80031d2:	4798      	blx	r3
        break;
 80031d4:	e009      	b.n	80031ea <cliRunCmd+0xa6>
    for (int i=0; i<p_cli->cmd_count; i++)
 80031d6:	68fb      	ldr	r3, [r7, #12]
 80031d8:	3301      	adds	r3, #1
 80031da:	60fb      	str	r3, [r7, #12]
 80031dc:	687b      	ldr	r3, [r7, #4]
 80031de:	f8b3 332a 	ldrh.w	r3, [r3, #810]	@ 0x32a
 80031e2:	461a      	mov	r2, r3
 80031e4:	68fb      	ldr	r3, [r7, #12]
 80031e6:	4293      	cmp	r3, r2
 80031e8:	dbc4      	blt.n	8003174 <cliRunCmd+0x30>
      }
    }
  }

  return ret;
 80031ea:	7afb      	ldrb	r3, [r7, #11]
}
 80031ec:	4618      	mov	r0, r3
 80031ee:	3710      	adds	r7, #16
 80031f0:	46bd      	mov	sp, r7
 80031f2:	bd80      	pop	{r7, pc}
 80031f4:	080241b4 	.word	0x080241b4

080031f8 <cliParseArgs>:

bool cliParseArgs(cli_t *p_cli)
{
 80031f8:	b580      	push	{r7, lr}
 80031fa:	b088      	sub	sp, #32
 80031fc:	af00      	add	r7, sp, #0
 80031fe:	6078      	str	r0, [r7, #4]
  bool ret = false;
 8003200:	2300      	movs	r3, #0
 8003202:	77fb      	strb	r3, [r7, #31]
  char *tok;
  char *next_ptr;
  uint16_t argc = 0;
 8003204:	2300      	movs	r3, #0
 8003206:	82fb      	strh	r3, [r7, #22]
  static const char *delim = " \f\n\r\t\v";
  char *cmdline;
  char **argv;

  p_cli->argc = 0;
 8003208:	687b      	ldr	r3, [r7, #4]
 800320a:	2200      	movs	r2, #0
 800320c:	f8a3 2112 	strh.w	r2, [r3, #274]	@ 0x112

  cmdline = (char *)p_cli->line.buf;
 8003210:	687b      	ldr	r3, [r7, #4]
 8003212:	f203 23e7 	addw	r3, r3, #743	@ 0x2e7
 8003216:	613b      	str	r3, [r7, #16]
  argv    = p_cli->argv;
 8003218:	687b      	ldr	r3, [r7, #4]
 800321a:	f503 738a 	add.w	r3, r3, #276	@ 0x114
 800321e:	60fb      	str	r3, [r7, #12]

  argv[argc] = NULL;
 8003220:	8afb      	ldrh	r3, [r7, #22]
 8003222:	009b      	lsls	r3, r3, #2
 8003224:	68fa      	ldr	r2, [r7, #12]
 8003226:	4413      	add	r3, r2
 8003228:	2200      	movs	r2, #0
 800322a:	601a      	str	r2, [r3, #0]

  for (tok = strtok_r(cmdline, delim, &next_ptr); tok; tok = strtok_r(NULL, delim, &next_ptr))
 800322c:	4b15      	ldr	r3, [pc, #84]	@ (8003284 <cliParseArgs+0x8c>)
 800322e:	681b      	ldr	r3, [r3, #0]
 8003230:	f107 0208 	add.w	r2, r7, #8
 8003234:	4619      	mov	r1, r3
 8003236:	6938      	ldr	r0, [r7, #16]
 8003238:	f01e ffa6 	bl	8022188 <strtok_r>
 800323c:	61b8      	str	r0, [r7, #24]
 800323e:	e010      	b.n	8003262 <cliParseArgs+0x6a>
  {
    argv[argc++] = tok;
 8003240:	8afb      	ldrh	r3, [r7, #22]
 8003242:	1c5a      	adds	r2, r3, #1
 8003244:	82fa      	strh	r2, [r7, #22]
 8003246:	009b      	lsls	r3, r3, #2
 8003248:	68fa      	ldr	r2, [r7, #12]
 800324a:	4413      	add	r3, r2
 800324c:	69ba      	ldr	r2, [r7, #24]
 800324e:	601a      	str	r2, [r3, #0]
  for (tok = strtok_r(cmdline, delim, &next_ptr); tok; tok = strtok_r(NULL, delim, &next_ptr))
 8003250:	4b0c      	ldr	r3, [pc, #48]	@ (8003284 <cliParseArgs+0x8c>)
 8003252:	681b      	ldr	r3, [r3, #0]
 8003254:	f107 0208 	add.w	r2, r7, #8
 8003258:	4619      	mov	r1, r3
 800325a:	2000      	movs	r0, #0
 800325c:	f01e ff94 	bl	8022188 <strtok_r>
 8003260:	61b8      	str	r0, [r7, #24]
 8003262:	69bb      	ldr	r3, [r7, #24]
 8003264:	2b00      	cmp	r3, #0
 8003266:	d1eb      	bne.n	8003240 <cliParseArgs+0x48>
  }

  p_cli->argc = argc;
 8003268:	687b      	ldr	r3, [r7, #4]
 800326a:	8afa      	ldrh	r2, [r7, #22]
 800326c:	f8a3 2112 	strh.w	r2, [r3, #274]	@ 0x112

  if (argc > 0)
 8003270:	8afb      	ldrh	r3, [r7, #22]
 8003272:	2b00      	cmp	r3, #0
 8003274:	d001      	beq.n	800327a <cliParseArgs+0x82>
  {
    ret = true;
 8003276:	2301      	movs	r3, #1
 8003278:	77fb      	strb	r3, [r7, #31]
  }

  return ret;
 800327a:	7ffb      	ldrb	r3, [r7, #31]
}
 800327c:	4618      	mov	r0, r3
 800327e:	3720      	adds	r7, #32
 8003280:	46bd      	mov	sp, r7
 8003282:	bd80      	pop	{r7, pc}
 8003284:	2000006c 	.word	0x2000006c

08003288 <cliPrintf>:

void cliPrintf(const char *fmt, ...)
{
 8003288:	b40f      	push	{r0, r1, r2, r3}
 800328a:	b580      	push	{r7, lr}
 800328c:	b084      	sub	sp, #16
 800328e:	af00      	add	r7, sp, #0
  va_list arg;
  va_start (arg, fmt);
 8003290:	f107 031c 	add.w	r3, r7, #28
 8003294:	607b      	str	r3, [r7, #4]
  int32_t len;
  cli_t *p_cli = &cli_node;
 8003296:	4b0d      	ldr	r3, [pc, #52]	@ (80032cc <cliPrintf+0x44>)
 8003298:	60fb      	str	r3, [r7, #12]


  len = vsnprintf(p_cli->print_buffer, 256, fmt, arg);
 800329a:	68fb      	ldr	r3, [r7, #12]
 800329c:	f103 0011 	add.w	r0, r3, #17
 80032a0:	687b      	ldr	r3, [r7, #4]
 80032a2:	69ba      	ldr	r2, [r7, #24]
 80032a4:	f44f 7180 	mov.w	r1, #256	@ 0x100
 80032a8:	f01e fe70 	bl	8021f8c <vsniprintf>
 80032ac:	60b8      	str	r0, [r7, #8]
  va_end (arg);

  uartWrite(p_cli->ch, (uint8_t *)p_cli->print_buffer, len);
 80032ae:	68fb      	ldr	r3, [r7, #12]
 80032b0:	7818      	ldrb	r0, [r3, #0]
 80032b2:	68fb      	ldr	r3, [r7, #12]
 80032b4:	3311      	adds	r3, #17
 80032b6:	68ba      	ldr	r2, [r7, #8]
 80032b8:	4619      	mov	r1, r3
 80032ba:	f005 fc1b 	bl	8008af4 <uartWrite>
}
 80032be:	bf00      	nop
 80032c0:	3710      	adds	r7, #16
 80032c2:	46bd      	mov	sp, r7
 80032c4:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 80032c8:	b004      	add	sp, #16
 80032ca:	4770      	bx	lr
 80032cc:	20000b0c 	.word	0x20000b0c

080032d0 <cliToUpper>:

void cliToUpper(char *str)
{
 80032d0:	b480      	push	{r7}
 80032d2:	b085      	sub	sp, #20
 80032d4:	af00      	add	r7, sp, #0
 80032d6:	6078      	str	r0, [r7, #4]
  uint16_t i;
  uint8_t  str_ch;

  for (i=0; i<CLI_CMD_NAME_MAX; i++)
 80032d8:	2300      	movs	r3, #0
 80032da:	81fb      	strh	r3, [r7, #14]
 80032dc:	e018      	b.n	8003310 <cliToUpper+0x40>
  {
    str_ch = str[i];
 80032de:	89fb      	ldrh	r3, [r7, #14]
 80032e0:	687a      	ldr	r2, [r7, #4]
 80032e2:	4413      	add	r3, r2
 80032e4:	781b      	ldrb	r3, [r3, #0]
 80032e6:	737b      	strb	r3, [r7, #13]

    if (str_ch == 0)
 80032e8:	7b7b      	ldrb	r3, [r7, #13]
 80032ea:	2b00      	cmp	r3, #0
 80032ec:	d014      	beq.n	8003318 <cliToUpper+0x48>
    {
      break;
    }

    if ((str_ch >= 'a') && (str_ch <= 'z'))
 80032ee:	7b7b      	ldrb	r3, [r7, #13]
 80032f0:	2b60      	cmp	r3, #96	@ 0x60
 80032f2:	d905      	bls.n	8003300 <cliToUpper+0x30>
 80032f4:	7b7b      	ldrb	r3, [r7, #13]
 80032f6:	2b7a      	cmp	r3, #122	@ 0x7a
 80032f8:	d802      	bhi.n	8003300 <cliToUpper+0x30>
    {
      str_ch = str_ch - 'a' + 'A';
 80032fa:	7b7b      	ldrb	r3, [r7, #13]
 80032fc:	3b20      	subs	r3, #32
 80032fe:	737b      	strb	r3, [r7, #13]
    }
    str[i] = str_ch;
 8003300:	89fb      	ldrh	r3, [r7, #14]
 8003302:	687a      	ldr	r2, [r7, #4]
 8003304:	4413      	add	r3, r2
 8003306:	7b7a      	ldrb	r2, [r7, #13]
 8003308:	701a      	strb	r2, [r3, #0]
  for (i=0; i<CLI_CMD_NAME_MAX; i++)
 800330a:	89fb      	ldrh	r3, [r7, #14]
 800330c:	3301      	adds	r3, #1
 800330e:	81fb      	strh	r3, [r7, #14]
 8003310:	89fb      	ldrh	r3, [r7, #14]
 8003312:	2b0f      	cmp	r3, #15
 8003314:	d9e3      	bls.n	80032de <cliToUpper+0xe>
 8003316:	e000      	b.n	800331a <cliToUpper+0x4a>
      break;
 8003318:	bf00      	nop
  }

  if (i == CLI_CMD_NAME_MAX)
 800331a:	89fb      	ldrh	r3, [r7, #14]
 800331c:	2b10      	cmp	r3, #16
 800331e:	d105      	bne.n	800332c <cliToUpper+0x5c>
  {
    str[i-1] = 0;
 8003320:	89fb      	ldrh	r3, [r7, #14]
 8003322:	3b01      	subs	r3, #1
 8003324:	687a      	ldr	r2, [r7, #4]
 8003326:	4413      	add	r3, r2
 8003328:	2200      	movs	r2, #0
 800332a:	701a      	strb	r2, [r3, #0]
  }
}
 800332c:	bf00      	nop
 800332e:	3714      	adds	r7, #20
 8003330:	46bd      	mov	sp, r7
 8003332:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003336:	4770      	bx	lr

08003338 <cliArgsGetData>:

int32_t cliArgsGetData(uint8_t index)
{
 8003338:	b580      	push	{r7, lr}
 800333a:	b084      	sub	sp, #16
 800333c:	af00      	add	r7, sp, #0
 800333e:	4603      	mov	r3, r0
 8003340:	71fb      	strb	r3, [r7, #7]
  int32_t ret = 0;
 8003342:	2300      	movs	r3, #0
 8003344:	60fb      	str	r3, [r7, #12]
  cli_t *p_cli = &cli_node;
 8003346:	4b0f      	ldr	r3, [pc, #60]	@ (8003384 <cliArgsGetData+0x4c>)
 8003348:	60bb      	str	r3, [r7, #8]


  if (index >= p_cli->cmd_args.argc)
 800334a:	79fb      	ldrb	r3, [r7, #7]
 800334c:	b29a      	uxth	r2, r3
 800334e:	68bb      	ldr	r3, [r7, #8]
 8003350:	f8b3 346c 	ldrh.w	r3, [r3, #1132]	@ 0x46c
 8003354:	429a      	cmp	r2, r3
 8003356:	d301      	bcc.n	800335c <cliArgsGetData+0x24>
  {
    return 0;
 8003358:	2300      	movs	r3, #0
 800335a:	e00e      	b.n	800337a <cliArgsGetData+0x42>
  }

  ret = (int32_t)strtoul((const char * ) p_cli->cmd_args.argv[index], (char **)NULL, (int) 0);
 800335c:	68bb      	ldr	r3, [r7, #8]
 800335e:	f8d3 2470 	ldr.w	r2, [r3, #1136]	@ 0x470
 8003362:	79fb      	ldrb	r3, [r7, #7]
 8003364:	009b      	lsls	r3, r3, #2
 8003366:	4413      	add	r3, r2
 8003368:	681b      	ldr	r3, [r3, #0]
 800336a:	2200      	movs	r2, #0
 800336c:	2100      	movs	r1, #0
 800336e:	4618      	mov	r0, r3
 8003370:	f01e fc74 	bl	8021c5c <strtoul>
 8003374:	4603      	mov	r3, r0
 8003376:	60fb      	str	r3, [r7, #12]

  return ret;
 8003378:	68fb      	ldr	r3, [r7, #12]
}
 800337a:	4618      	mov	r0, r3
 800337c:	3710      	adds	r7, #16
 800337e:	46bd      	mov	sp, r7
 8003380:	bd80      	pop	{r7, pc}
 8003382:	bf00      	nop
 8003384:	20000b0c 	.word	0x20000b0c

08003388 <cliArgsGetFloat>:

float cliArgsGetFloat(uint8_t index)
{
 8003388:	b580      	push	{r7, lr}
 800338a:	b084      	sub	sp, #16
 800338c:	af00      	add	r7, sp, #0
 800338e:	4603      	mov	r3, r0
 8003390:	71fb      	strb	r3, [r7, #7]
  float ret = 0.0;
 8003392:	f04f 0300 	mov.w	r3, #0
 8003396:	60fb      	str	r3, [r7, #12]
  cli_t *p_cli = &cli_node;
 8003398:	4b10      	ldr	r3, [pc, #64]	@ (80033dc <cliArgsGetFloat+0x54>)
 800339a:	60bb      	str	r3, [r7, #8]


  if (index >= p_cli->cmd_args.argc)
 800339c:	79fb      	ldrb	r3, [r7, #7]
 800339e:	b29a      	uxth	r2, r3
 80033a0:	68bb      	ldr	r3, [r7, #8]
 80033a2:	f8b3 346c 	ldrh.w	r3, [r3, #1132]	@ 0x46c
 80033a6:	429a      	cmp	r2, r3
 80033a8:	d302      	bcc.n	80033b0 <cliArgsGetFloat+0x28>
  {
    return 0;
 80033aa:	f04f 0300 	mov.w	r3, #0
 80033ae:	e00d      	b.n	80033cc <cliArgsGetFloat+0x44>
  }

  ret = (float)strtof((const char * ) p_cli->cmd_args.argv[index], (char **)NULL);
 80033b0:	68bb      	ldr	r3, [r7, #8]
 80033b2:	f8d3 2470 	ldr.w	r2, [r3, #1136]	@ 0x470
 80033b6:	79fb      	ldrb	r3, [r7, #7]
 80033b8:	009b      	lsls	r3, r3, #2
 80033ba:	4413      	add	r3, r2
 80033bc:	681b      	ldr	r3, [r3, #0]
 80033be:	2100      	movs	r1, #0
 80033c0:	4618      	mov	r0, r3
 80033c2:	f01e fb79 	bl	8021ab8 <strtof>
 80033c6:	ed87 0a03 	vstr	s0, [r7, #12]

  return ret;
 80033ca:	68fb      	ldr	r3, [r7, #12]
}
 80033cc:	ee07 3a90 	vmov	s15, r3
 80033d0:	eeb0 0a67 	vmov.f32	s0, s15
 80033d4:	3710      	adds	r7, #16
 80033d6:	46bd      	mov	sp, r7
 80033d8:	bd80      	pop	{r7, pc}
 80033da:	bf00      	nop
 80033dc:	20000b0c 	.word	0x20000b0c

080033e0 <cliArgsGetStr>:

char *cliArgsGetStr(uint8_t index)
{
 80033e0:	b480      	push	{r7}
 80033e2:	b085      	sub	sp, #20
 80033e4:	af00      	add	r7, sp, #0
 80033e6:	4603      	mov	r3, r0
 80033e8:	71fb      	strb	r3, [r7, #7]
  char *ret = NULL;
 80033ea:	2300      	movs	r3, #0
 80033ec:	60fb      	str	r3, [r7, #12]
  cli_t *p_cli = &cli_node;
 80033ee:	4b0d      	ldr	r3, [pc, #52]	@ (8003424 <cliArgsGetStr+0x44>)
 80033f0:	60bb      	str	r3, [r7, #8]


  if (index >= p_cli->cmd_args.argc)
 80033f2:	79fb      	ldrb	r3, [r7, #7]
 80033f4:	b29a      	uxth	r2, r3
 80033f6:	68bb      	ldr	r3, [r7, #8]
 80033f8:	f8b3 346c 	ldrh.w	r3, [r3, #1132]	@ 0x46c
 80033fc:	429a      	cmp	r2, r3
 80033fe:	d301      	bcc.n	8003404 <cliArgsGetStr+0x24>
  {
    return 0;
 8003400:	2300      	movs	r3, #0
 8003402:	e008      	b.n	8003416 <cliArgsGetStr+0x36>
  }

  ret = p_cli->cmd_args.argv[index];
 8003404:	68bb      	ldr	r3, [r7, #8]
 8003406:	f8d3 2470 	ldr.w	r2, [r3, #1136]	@ 0x470
 800340a:	79fb      	ldrb	r3, [r7, #7]
 800340c:	009b      	lsls	r3, r3, #2
 800340e:	4413      	add	r3, r2
 8003410:	681b      	ldr	r3, [r3, #0]
 8003412:	60fb      	str	r3, [r7, #12]

  return ret;
 8003414:	68fb      	ldr	r3, [r7, #12]
}
 8003416:	4618      	mov	r0, r3
 8003418:	3714      	adds	r7, #20
 800341a:	46bd      	mov	sp, r7
 800341c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003420:	4770      	bx	lr
 8003422:	bf00      	nop
 8003424:	20000b0c 	.word	0x20000b0c

08003428 <cliArgsIsStr>:

bool cliArgsIsStr(uint8_t index, char *p_str)
{
 8003428:	b580      	push	{r7, lr}
 800342a:	b084      	sub	sp, #16
 800342c:	af00      	add	r7, sp, #0
 800342e:	4603      	mov	r3, r0
 8003430:	6039      	str	r1, [r7, #0]
 8003432:	71fb      	strb	r3, [r7, #7]
  bool ret = false;
 8003434:	2300      	movs	r3, #0
 8003436:	73fb      	strb	r3, [r7, #15]
  cli_t *p_cli = &cli_node;
 8003438:	4b0f      	ldr	r3, [pc, #60]	@ (8003478 <cliArgsIsStr+0x50>)
 800343a:	60bb      	str	r3, [r7, #8]


  if (index >= p_cli->cmd_args.argc)
 800343c:	79fb      	ldrb	r3, [r7, #7]
 800343e:	b29a      	uxth	r2, r3
 8003440:	68bb      	ldr	r3, [r7, #8]
 8003442:	f8b3 346c 	ldrh.w	r3, [r3, #1132]	@ 0x46c
 8003446:	429a      	cmp	r2, r3
 8003448:	d301      	bcc.n	800344e <cliArgsIsStr+0x26>
  {
    return 0;
 800344a:	2300      	movs	r3, #0
 800344c:	e010      	b.n	8003470 <cliArgsIsStr+0x48>
  }

  if(strcmp(p_str, p_cli->cmd_args.argv[index]) == 0)
 800344e:	68bb      	ldr	r3, [r7, #8]
 8003450:	f8d3 2470 	ldr.w	r2, [r3, #1136]	@ 0x470
 8003454:	79fb      	ldrb	r3, [r7, #7]
 8003456:	009b      	lsls	r3, r3, #2
 8003458:	4413      	add	r3, r2
 800345a:	681b      	ldr	r3, [r3, #0]
 800345c:	4619      	mov	r1, r3
 800345e:	6838      	ldr	r0, [r7, #0]
 8003460:	f7fc ff1e 	bl	80002a0 <strcmp>
 8003464:	4603      	mov	r3, r0
 8003466:	2b00      	cmp	r3, #0
 8003468:	d101      	bne.n	800346e <cliArgsIsStr+0x46>
  {
    ret = true;
 800346a:	2301      	movs	r3, #1
 800346c:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
 800346e:	7bfb      	ldrb	r3, [r7, #15]
}
 8003470:	4618      	mov	r0, r3
 8003472:	3710      	adds	r7, #16
 8003474:	46bd      	mov	sp, r7
 8003476:	bd80      	pop	{r7, pc}
 8003478:	20000b0c 	.word	0x20000b0c

0800347c <cliKeepLoop>:

bool cliKeepLoop(void)
{
 800347c:	b580      	push	{r7, lr}
 800347e:	b082      	sub	sp, #8
 8003480:	af00      	add	r7, sp, #0
  cli_t *p_cli = &cli_node;
 8003482:	4b08      	ldr	r3, [pc, #32]	@ (80034a4 <cliKeepLoop+0x28>)
 8003484:	607b      	str	r3, [r7, #4]


  if (uartAvailable(p_cli->ch) == 0)
 8003486:	687b      	ldr	r3, [r7, #4]
 8003488:	781b      	ldrb	r3, [r3, #0]
 800348a:	4618      	mov	r0, r3
 800348c:	f005 fae2 	bl	8008a54 <uartAvailable>
 8003490:	4603      	mov	r3, r0
 8003492:	2b00      	cmp	r3, #0
 8003494:	d101      	bne.n	800349a <cliKeepLoop+0x1e>
  {
    return true;
 8003496:	2301      	movs	r3, #1
 8003498:	e000      	b.n	800349c <cliKeepLoop+0x20>
  }
  else
  {
    return false;
 800349a:	2300      	movs	r3, #0
  }
}
 800349c:	4618      	mov	r0, r3
 800349e:	3708      	adds	r7, #8
 80034a0:	46bd      	mov	sp, r7
 80034a2:	bd80      	pop	{r7, pc}
 80034a4:	20000b0c 	.word	0x20000b0c

080034a8 <cliAdd>:

bool cliAdd(const char *cmd_str, void (*p_func)(cli_args_t *))
{
 80034a8:	b580      	push	{r7, lr}
 80034aa:	b086      	sub	sp, #24
 80034ac:	af00      	add	r7, sp, #0
 80034ae:	6078      	str	r0, [r7, #4]
 80034b0:	6039      	str	r1, [r7, #0]
  bool ret = true;
 80034b2:	2301      	movs	r3, #1
 80034b4:	75fb      	strb	r3, [r7, #23]
  cli_t *p_cli = &cli_node;
 80034b6:	4b20      	ldr	r3, [pc, #128]	@ (8003538 <cliAdd+0x90>)
 80034b8:	613b      	str	r3, [r7, #16]
  uint16_t index;

  if (p_cli->cmd_count >= CLI_CMD_LIST_MAX)
 80034ba:	693b      	ldr	r3, [r7, #16]
 80034bc:	f8b3 332a 	ldrh.w	r3, [r3, #810]	@ 0x32a
 80034c0:	2b0f      	cmp	r3, #15
 80034c2:	d901      	bls.n	80034c8 <cliAdd+0x20>
  {
    return false;
 80034c4:	2300      	movs	r3, #0
 80034c6:	e032      	b.n	800352e <cliAdd+0x86>
  }

  index = p_cli->cmd_count;
 80034c8:	693b      	ldr	r3, [r7, #16]
 80034ca:	f8b3 332a 	ldrh.w	r3, [r3, #810]	@ 0x32a
 80034ce:	81fb      	strh	r3, [r7, #14]

  strcpy(p_cli->cmd_list[index].cmd_str, cmd_str);
 80034d0:	89fa      	ldrh	r2, [r7, #14]
 80034d2:	4613      	mov	r3, r2
 80034d4:	009b      	lsls	r3, r3, #2
 80034d6:	4413      	add	r3, r2
 80034d8:	009b      	lsls	r3, r3, #2
 80034da:	f503 734a 	add.w	r3, r3, #808	@ 0x328
 80034de:	693a      	ldr	r2, [r7, #16]
 80034e0:	4413      	add	r3, r2
 80034e2:	3304      	adds	r3, #4
 80034e4:	6879      	ldr	r1, [r7, #4]
 80034e6:	4618      	mov	r0, r3
 80034e8:	f01e fed5 	bl	8022296 <strcpy>
  p_cli->cmd_list[index].cmd_func = p_func;
 80034ec:	89fa      	ldrh	r2, [r7, #14]
 80034ee:	6939      	ldr	r1, [r7, #16]
 80034f0:	4613      	mov	r3, r2
 80034f2:	009b      	lsls	r3, r3, #2
 80034f4:	4413      	add	r3, r2
 80034f6:	009b      	lsls	r3, r3, #2
 80034f8:	440b      	add	r3, r1
 80034fa:	f503 734f 	add.w	r3, r3, #828	@ 0x33c
 80034fe:	683a      	ldr	r2, [r7, #0]
 8003500:	601a      	str	r2, [r3, #0]

  cliToUpper(p_cli->cmd_list[index].cmd_str);
 8003502:	89fa      	ldrh	r2, [r7, #14]
 8003504:	4613      	mov	r3, r2
 8003506:	009b      	lsls	r3, r3, #2
 8003508:	4413      	add	r3, r2
 800350a:	009b      	lsls	r3, r3, #2
 800350c:	f503 734a 	add.w	r3, r3, #808	@ 0x328
 8003510:	693a      	ldr	r2, [r7, #16]
 8003512:	4413      	add	r3, r2
 8003514:	3304      	adds	r3, #4
 8003516:	4618      	mov	r0, r3
 8003518:	f7ff feda 	bl	80032d0 <cliToUpper>

  p_cli->cmd_count++;
 800351c:	693b      	ldr	r3, [r7, #16]
 800351e:	f8b3 332a 	ldrh.w	r3, [r3, #810]	@ 0x32a
 8003522:	3301      	adds	r3, #1
 8003524:	b29a      	uxth	r2, r3
 8003526:	693b      	ldr	r3, [r7, #16]
 8003528:	f8a3 232a 	strh.w	r2, [r3, #810]	@ 0x32a

  return ret;
 800352c:	7dfb      	ldrb	r3, [r7, #23]
}
 800352e:	4618      	mov	r0, r3
 8003530:	3718      	adds	r7, #24
 8003532:	46bd      	mov	sp, r7
 8003534:	bd80      	pop	{r7, pc}
 8003536:	bf00      	nop
 8003538:	20000b0c 	.word	0x20000b0c

0800353c <cliShowList>:

void cliShowList(cli_args_t *args)
{
 800353c:	b580      	push	{r7, lr}
 800353e:	b084      	sub	sp, #16
 8003540:	af00      	add	r7, sp, #0
 8003542:	6078      	str	r0, [r7, #4]
  cli_t *p_cli = &cli_node;
 8003544:	4b15      	ldr	r3, [pc, #84]	@ (800359c <cliShowList+0x60>)
 8003546:	60bb      	str	r3, [r7, #8]


  cliPrintf("\r\n");
 8003548:	4815      	ldr	r0, [pc, #84]	@ (80035a0 <cliShowList+0x64>)
 800354a:	f7ff fe9d 	bl	8003288 <cliPrintf>
  cliPrintf("---------- cmd list ---------\r\n");
 800354e:	4815      	ldr	r0, [pc, #84]	@ (80035a4 <cliShowList+0x68>)
 8003550:	f7ff fe9a 	bl	8003288 <cliPrintf>

  for (int i=0; i<p_cli->cmd_count; i++)
 8003554:	2300      	movs	r3, #0
 8003556:	60fb      	str	r3, [r7, #12]
 8003558:	e012      	b.n	8003580 <cliShowList+0x44>
  {
    cliPrintf(p_cli->cmd_list[i].cmd_str);
 800355a:	68fa      	ldr	r2, [r7, #12]
 800355c:	4613      	mov	r3, r2
 800355e:	009b      	lsls	r3, r3, #2
 8003560:	4413      	add	r3, r2
 8003562:	009b      	lsls	r3, r3, #2
 8003564:	f503 734a 	add.w	r3, r3, #808	@ 0x328
 8003568:	68ba      	ldr	r2, [r7, #8]
 800356a:	4413      	add	r3, r2
 800356c:	3304      	adds	r3, #4
 800356e:	4618      	mov	r0, r3
 8003570:	f7ff fe8a 	bl	8003288 <cliPrintf>
    cliPrintf("\r\n");
 8003574:	480a      	ldr	r0, [pc, #40]	@ (80035a0 <cliShowList+0x64>)
 8003576:	f7ff fe87 	bl	8003288 <cliPrintf>
  for (int i=0; i<p_cli->cmd_count; i++)
 800357a:	68fb      	ldr	r3, [r7, #12]
 800357c:	3301      	adds	r3, #1
 800357e:	60fb      	str	r3, [r7, #12]
 8003580:	68bb      	ldr	r3, [r7, #8]
 8003582:	f8b3 332a 	ldrh.w	r3, [r3, #810]	@ 0x32a
 8003586:	461a      	mov	r2, r3
 8003588:	68fb      	ldr	r3, [r7, #12]
 800358a:	4293      	cmp	r3, r2
 800358c:	dbe5      	blt.n	800355a <cliShowList+0x1e>
  }

  cliPrintf("-----------------------------\r\n");
 800358e:	4806      	ldr	r0, [pc, #24]	@ (80035a8 <cliShowList+0x6c>)
 8003590:	f7ff fe7a 	bl	8003288 <cliPrintf>
}
 8003594:	bf00      	nop
 8003596:	3710      	adds	r7, #16
 8003598:	46bd      	mov	sp, r7
 800359a:	bd80      	pop	{r7, pc}
 800359c:	20000b0c 	.word	0x20000b0c
 80035a0:	080241b4 	.word	0x080241b4
 80035a4:	080241b8 	.word	0x080241b8
 80035a8:	080241d8 	.word	0x080241d8

080035ac <cliMemoryDump>:

void cliMemoryDump(cli_args_t *args)
{
 80035ac:	b580      	push	{r7, lr}
 80035ae:	b08c      	sub	sp, #48	@ 0x30
 80035b0:	af00      	add	r7, sp, #0
 80035b2:	6078      	str	r0, [r7, #4]
  int idx, size = 16;
 80035b4:	2310      	movs	r3, #16
 80035b6:	62bb      	str	r3, [r7, #40]	@ 0x28
  unsigned int *addr;
  int idx1, i;
  unsigned int *ascptr;
  unsigned char asc[4];

  int    argc = args->argc;
 80035b8:	687b      	ldr	r3, [r7, #4]
 80035ba:	881b      	ldrh	r3, [r3, #0]
 80035bc:	617b      	str	r3, [r7, #20]
  char **argv = args->argv;
 80035be:	687b      	ldr	r3, [r7, #4]
 80035c0:	685b      	ldr	r3, [r3, #4]
 80035c2:	613b      	str	r3, [r7, #16]


  if(args->argc < 1)
 80035c4:	687b      	ldr	r3, [r7, #4]
 80035c6:	881b      	ldrh	r3, [r3, #0]
 80035c8:	2b00      	cmp	r3, #0
 80035ca:	d103      	bne.n	80035d4 <cliMemoryDump+0x28>
  {
    cliPrintf(">> md addr [size] \n");
 80035cc:	4840      	ldr	r0, [pc, #256]	@ (80036d0 <cliMemoryDump+0x124>)
 80035ce:	f7ff fe5b 	bl	8003288 <cliPrintf>
 80035d2:	e07a      	b.n	80036ca <cliMemoryDump+0x11e>
    return;
  }

  if(argc > 1)
 80035d4:	697b      	ldr	r3, [r7, #20]
 80035d6:	2b01      	cmp	r3, #1
 80035d8:	dd09      	ble.n	80035ee <cliMemoryDump+0x42>
  {
    size = (int)strtoul((const char * ) argv[1], (char **)NULL, (int) 0);
 80035da:	693b      	ldr	r3, [r7, #16]
 80035dc:	3304      	adds	r3, #4
 80035de:	681b      	ldr	r3, [r3, #0]
 80035e0:	2200      	movs	r2, #0
 80035e2:	2100      	movs	r1, #0
 80035e4:	4618      	mov	r0, r3
 80035e6:	f01e fb39 	bl	8021c5c <strtoul>
 80035ea:	4603      	mov	r3, r0
 80035ec:	62bb      	str	r3, [r7, #40]	@ 0x28
  }
  addr   = (unsigned int *)strtoul((const char * ) argv[0], (char **)NULL, (int) 0);
 80035ee:	693b      	ldr	r3, [r7, #16]
 80035f0:	681b      	ldr	r3, [r3, #0]
 80035f2:	2200      	movs	r2, #0
 80035f4:	2100      	movs	r1, #0
 80035f6:	4618      	mov	r0, r3
 80035f8:	f01e fb30 	bl	8021c5c <strtoul>
 80035fc:	4603      	mov	r3, r0
 80035fe:	627b      	str	r3, [r7, #36]	@ 0x24
  ascptr = (unsigned int *)addr;
 8003600:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003602:	61bb      	str	r3, [r7, #24]

  cliPrintf("\n   ");
 8003604:	4833      	ldr	r0, [pc, #204]	@ (80036d4 <cliMemoryDump+0x128>)
 8003606:	f7ff fe3f 	bl	8003288 <cliPrintf>
  for (idx = 0; idx<size; idx++)
 800360a:	2300      	movs	r3, #0
 800360c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800360e:	e058      	b.n	80036c2 <cliMemoryDump+0x116>
  {
    if((idx%4) == 0)
 8003610:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003612:	f003 0303 	and.w	r3, r3, #3
 8003616:	2b00      	cmp	r3, #0
 8003618:	d104      	bne.n	8003624 <cliMemoryDump+0x78>
    {
      cliPrintf(" 0x%08X: ", (unsigned int)addr);
 800361a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800361c:	4619      	mov	r1, r3
 800361e:	482e      	ldr	r0, [pc, #184]	@ (80036d8 <cliMemoryDump+0x12c>)
 8003620:	f7ff fe32 	bl	8003288 <cliPrintf>
    }
    cliPrintf(" 0x%08X", *(addr));
 8003624:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8003626:	681b      	ldr	r3, [r3, #0]
 8003628:	4619      	mov	r1, r3
 800362a:	482c      	ldr	r0, [pc, #176]	@ (80036dc <cliMemoryDump+0x130>)
 800362c:	f7ff fe2c 	bl	8003288 <cliPrintf>

    if ((idx%4) == 3)
 8003630:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8003632:	425a      	negs	r2, r3
 8003634:	f003 0303 	and.w	r3, r3, #3
 8003638:	f002 0203 	and.w	r2, r2, #3
 800363c:	bf58      	it	pl
 800363e:	4253      	negpl	r3, r2
 8003640:	2b03      	cmp	r3, #3
 8003642:	d138      	bne.n	80036b6 <cliMemoryDump+0x10a>
    {
      cliPrintf ("  |");
 8003644:	4826      	ldr	r0, [pc, #152]	@ (80036e0 <cliMemoryDump+0x134>)
 8003646:	f7ff fe1f 	bl	8003288 <cliPrintf>
      for (idx1= 0; idx1< 4; idx1++)
 800364a:	2300      	movs	r3, #0
 800364c:	623b      	str	r3, [r7, #32]
 800364e:	e02c      	b.n	80036aa <cliMemoryDump+0xfe>
      {
        memcpy((char *)asc, (char *)ascptr, 4);
 8003650:	69bb      	ldr	r3, [r7, #24]
 8003652:	681b      	ldr	r3, [r3, #0]
 8003654:	60fb      	str	r3, [r7, #12]
        for (i=0;i<4;i++)
 8003656:	2300      	movs	r3, #0
 8003658:	61fb      	str	r3, [r7, #28]
 800365a:	e01d      	b.n	8003698 <cliMemoryDump+0xec>
        {
          if (asc[i] > 0x1f && asc[i] < 0x7f)
 800365c:	f107 020c 	add.w	r2, r7, #12
 8003660:	69fb      	ldr	r3, [r7, #28]
 8003662:	4413      	add	r3, r2
 8003664:	781b      	ldrb	r3, [r3, #0]
 8003666:	2b1f      	cmp	r3, #31
 8003668:	d910      	bls.n	800368c <cliMemoryDump+0xe0>
 800366a:	f107 020c 	add.w	r2, r7, #12
 800366e:	69fb      	ldr	r3, [r7, #28]
 8003670:	4413      	add	r3, r2
 8003672:	781b      	ldrb	r3, [r3, #0]
 8003674:	2b7e      	cmp	r3, #126	@ 0x7e
 8003676:	d809      	bhi.n	800368c <cliMemoryDump+0xe0>
          {
            cliPrintf("%c", asc[i]);
 8003678:	f107 020c 	add.w	r2, r7, #12
 800367c:	69fb      	ldr	r3, [r7, #28]
 800367e:	4413      	add	r3, r2
 8003680:	781b      	ldrb	r3, [r3, #0]
 8003682:	4619      	mov	r1, r3
 8003684:	4817      	ldr	r0, [pc, #92]	@ (80036e4 <cliMemoryDump+0x138>)
 8003686:	f7ff fdff 	bl	8003288 <cliPrintf>
 800368a:	e002      	b.n	8003692 <cliMemoryDump+0xe6>
          }
          else
          {
            cliPrintf(".");
 800368c:	4816      	ldr	r0, [pc, #88]	@ (80036e8 <cliMemoryDump+0x13c>)
 800368e:	f7ff fdfb 	bl	8003288 <cliPrintf>
        for (i=0;i<4;i++)
 8003692:	69fb      	ldr	r3, [r7, #28]
 8003694:	3301      	adds	r3, #1
 8003696:	61fb      	str	r3, [r7, #28]
 8003698:	69fb      	ldr	r3, [r7, #28]
 800369a:	2b03      	cmp	r3, #3
 800369c:	ddde      	ble.n	800365c <cliMemoryDump+0xb0>
          }
        }
        ascptr+=1;
 800369e:	69bb      	ldr	r3, [r7, #24]
 80036a0:	3304      	adds	r3, #4
 80036a2:	61bb      	str	r3, [r7, #24]
      for (idx1= 0; idx1< 4; idx1++)
 80036a4:	6a3b      	ldr	r3, [r7, #32]
 80036a6:	3301      	adds	r3, #1
 80036a8:	623b      	str	r3, [r7, #32]
 80036aa:	6a3b      	ldr	r3, [r7, #32]
 80036ac:	2b03      	cmp	r3, #3
 80036ae:	ddcf      	ble.n	8003650 <cliMemoryDump+0xa4>
      }
      cliPrintf("|\n   ");
 80036b0:	480e      	ldr	r0, [pc, #56]	@ (80036ec <cliMemoryDump+0x140>)
 80036b2:	f7ff fde9 	bl	8003288 <cliPrintf>
    }
    addr++;
 80036b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80036b8:	3304      	adds	r3, #4
 80036ba:	627b      	str	r3, [r7, #36]	@ 0x24
  for (idx = 0; idx<size; idx++)
 80036bc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 80036be:	3301      	adds	r3, #1
 80036c0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80036c2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80036c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80036c6:	429a      	cmp	r2, r3
 80036c8:	dba2      	blt.n	8003610 <cliMemoryDump+0x64>
  }
}
 80036ca:	3730      	adds	r7, #48	@ 0x30
 80036cc:	46bd      	mov	sp, r7
 80036ce:	bd80      	pop	{r7, pc}
 80036d0:	080241f8 	.word	0x080241f8
 80036d4:	0802420c 	.word	0x0802420c
 80036d8:	08024214 	.word	0x08024214
 80036dc:	08024220 	.word	0x08024220
 80036e0:	08024228 	.word	0x08024228
 80036e4:	0802422c 	.word	0x0802422c
 80036e8:	08024230 	.word	0x08024230
 80036ec:	08024234 	.word	0x08024234

080036f0 <fatfsInit>:
#ifdef _USE_HW_CLI
static void cliFatfs(cli_args_t *args);
#endif

bool fatfsInit(void)
{
 80036f0:	b580      	push	{r7, lr}
 80036f2:	b082      	sub	sp, #8
 80036f4:	af00      	add	r7, sp, #0
	bool ret = false;
 80036f6:	2300      	movs	r3, #0
 80036f8:	71fb      	strb	r3, [r7, #7]

	if(FATFS_LinkDriver(&SD_Driver, SDPath) == 0)
 80036fa:	490d      	ldr	r1, [pc, #52]	@ (8003730 <fatfsInit+0x40>)
 80036fc:	480d      	ldr	r0, [pc, #52]	@ (8003734 <fatfsInit+0x44>)
 80036fe:	f015 fbdf 	bl	8018ec0 <FATFS_LinkDriver>
 8003702:	4603      	mov	r3, r0
 8003704:	2b00      	cmp	r3, #0
 8003706:	d10a      	bne.n	800371e <fatfsInit+0x2e>
	{
		if(f_mount(&SDFatFs, (TCHAR const*)SDPath, 0) == FR_OK)
 8003708:	2200      	movs	r2, #0
 800370a:	4909      	ldr	r1, [pc, #36]	@ (8003730 <fatfsInit+0x40>)
 800370c:	480a      	ldr	r0, [pc, #40]	@ (8003738 <fatfsInit+0x48>)
 800370e:	f013 ffd5 	bl	80176bc <f_mount>
 8003712:	4603      	mov	r3, r0
 8003714:	2b00      	cmp	r3, #0
 8003716:	d102      	bne.n	800371e <fatfsInit+0x2e>
		{
			is_init = true;
 8003718:	4b08      	ldr	r3, [pc, #32]	@ (800373c <fatfsInit+0x4c>)
 800371a:	2201      	movs	r2, #1
 800371c:	701a      	strb	r2, [r3, #0]
		}
	}

	#ifdef _USE_HW_CLI
		cliAdd("fatfs", cliFatfs);
 800371e:	4908      	ldr	r1, [pc, #32]	@ (8003740 <fatfsInit+0x50>)
 8003720:	4808      	ldr	r0, [pc, #32]	@ (8003744 <fatfsInit+0x54>)
 8003722:	f7ff fec1 	bl	80034a8 <cliAdd>
	#endif

	return ret;
 8003726:	79fb      	ldrb	r3, [r7, #7]
}
 8003728:	4618      	mov	r0, r3
 800372a:	3708      	adds	r7, #8
 800372c:	46bd      	mov	sp, r7
 800372e:	bd80      	pop	{r7, pc}
 8003730:	200011c8 	.word	0x200011c8
 8003734:	0802503c 	.word	0x0802503c
 8003738:	20000f94 	.word	0x20000f94
 800373c:	20000f90 	.word	0x20000f90
 8003740:	0800381d 	.word	0x0800381d
 8003744:	08024244 	.word	0x08024244

08003748 <fatfsDir>:


#ifdef _USE_HW_CLI

FRESULT fatfsDir(char *path)
{
 8003748:	b580      	push	{r7, lr}
 800374a:	b0d6      	sub	sp, #344	@ 0x158
 800374c:	af00      	add	r7, sp, #0
 800374e:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 8003752:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 8003756:	6018      	str	r0, [r3, #0]
	FRESULT res;
	DIR dir;
	FILINFO fno;

	res = f_opendir(&dir, path);
 8003758:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 800375c:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 8003760:	f507 7290 	add.w	r2, r7, #288	@ 0x120
 8003764:	6819      	ldr	r1, [r3, #0]
 8003766:	4610      	mov	r0, r2
 8003768:	f014 ff1d 	bl	80185a6 <f_opendir>
 800376c:	4603      	mov	r3, r0
 800376e:	f887 3157 	strb.w	r3, [r7, #343]	@ 0x157
	if(res == FR_OK)
 8003772:	f897 3157 	ldrb.w	r3, [r7, #343]	@ 0x157
 8003776:	2b00      	cmp	r3, #0
 8003778:	d144      	bne.n	8003804 <fatfsDir+0xbc>
	{
		for(;;)
		{
			res = f_readdir(&dir, &fno);
 800377a:	f107 0208 	add.w	r2, r7, #8
 800377e:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 8003782:	4611      	mov	r1, r2
 8003784:	4618      	mov	r0, r3
 8003786:	f014 ffb7 	bl	80186f8 <f_readdir>
 800378a:	4603      	mov	r3, r0
 800378c:	f887 3157 	strb.w	r3, [r7, #343]	@ 0x157
			if(res != FR_OK || fno.fname[0] == 0)
 8003790:	f897 3157 	ldrb.w	r3, [r7, #343]	@ 0x157
 8003794:	2b00      	cmp	r3, #0
 8003796:	d130      	bne.n	80037fa <fatfsDir+0xb2>
 8003798:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 800379c:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 80037a0:	7d9b      	ldrb	r3, [r3, #22]
 80037a2:	2b00      	cmp	r3, #0
 80037a4:	d029      	beq.n	80037fa <fatfsDir+0xb2>
				break;

			if(fno.fattrib & AM_DIR)
 80037a6:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80037aa:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 80037ae:	7a1b      	ldrb	r3, [r3, #8]
 80037b0:	f003 0310 	and.w	r3, r3, #16
 80037b4:	2b00      	cmp	r3, #0
 80037b6:	d00c      	beq.n	80037d2 <fatfsDir+0x8a>
			{
				cliPrintf(" %s/%s \n", path, fno.fname);
 80037b8:	f107 0308 	add.w	r3, r7, #8
 80037bc:	f103 0216 	add.w	r2, r3, #22
 80037c0:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80037c4:	f5a3 73aa 	sub.w	r3, r3, #340	@ 0x154
 80037c8:	6819      	ldr	r1, [r3, #0]
 80037ca:	4812      	ldr	r0, [pc, #72]	@ (8003814 <fatfsDir+0xcc>)
 80037cc:	f7ff fd5c 	bl	8003288 <cliPrintf>
 80037d0:	e7d3      	b.n	800377a <fatfsDir+0x32>
			}
			else
			{
				cliPrintf(" %s/%32s \t%d bytes\n", path, fno.fname, (int)fno.fsize);
 80037d2:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80037d6:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 80037da:	681b      	ldr	r3, [r3, #0]
 80037dc:	4618      	mov	r0, r3
 80037de:	f107 0308 	add.w	r3, r7, #8
 80037e2:	f103 0216 	add.w	r2, r3, #22
 80037e6:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80037ea:	f5a3 71aa 	sub.w	r1, r3, #340	@ 0x154
 80037ee:	4603      	mov	r3, r0
 80037f0:	6809      	ldr	r1, [r1, #0]
 80037f2:	4809      	ldr	r0, [pc, #36]	@ (8003818 <fatfsDir+0xd0>)
 80037f4:	f7ff fd48 	bl	8003288 <cliPrintf>
			res = f_readdir(&dir, &fno);
 80037f8:	e7bf      	b.n	800377a <fatfsDir+0x32>
			}
		}

		f_closedir(&dir);
 80037fa:	f507 7390 	add.w	r3, r7, #288	@ 0x120
 80037fe:	4618      	mov	r0, r3
 8003800:	f014 ff54 	bl	80186ac <f_closedir>
	}

	return res;
 8003804:	f897 3157 	ldrb.w	r3, [r7, #343]	@ 0x157
}
 8003808:	4618      	mov	r0, r3
 800380a:	f507 77ac 	add.w	r7, r7, #344	@ 0x158
 800380e:	46bd      	mov	sp, r7
 8003810:	bd80      	pop	{r7, pc}
 8003812:	bf00      	nop
 8003814:	0802424c 	.word	0x0802424c
 8003818:	08024258 	.word	0x08024258

0800381c <cliFatfs>:

void cliFatfs(cli_args_t *args)
{
 800381c:	b580      	push	{r7, lr}
 800381e:	f5ad 7d1a 	sub.w	sp, sp, #616	@ 0x268
 8003822:	af00      	add	r7, sp, #0
 8003824:	f507 731a 	add.w	r3, r7, #616	@ 0x268
 8003828:	f5a3 7319 	sub.w	r3, r3, #612	@ 0x264
 800382c:	6018      	str	r0, [r3, #0]
	bool ret = false;
 800382e:	2300      	movs	r3, #0
 8003830:	f887 3267 	strb.w	r3, [r7, #615]	@ 0x267

	if(args->argc == 1 && args->isStr(0, "info") == true)
 8003834:	f507 731a 	add.w	r3, r7, #616	@ 0x268
 8003838:	f5a3 7319 	sub.w	r3, r3, #612	@ 0x264
 800383c:	681b      	ldr	r3, [r3, #0]
 800383e:	881b      	ldrh	r3, [r3, #0]
 8003840:	2b01      	cmp	r3, #1
 8003842:	d14d      	bne.n	80038e0 <cliFatfs+0xc4>
 8003844:	f507 731a 	add.w	r3, r7, #616	@ 0x268
 8003848:	f5a3 7319 	sub.w	r3, r3, #612	@ 0x264
 800384c:	681b      	ldr	r3, [r3, #0]
 800384e:	695b      	ldr	r3, [r3, #20]
 8003850:	4990      	ldr	r1, [pc, #576]	@ (8003a94 <cliFatfs+0x278>)
 8003852:	2000      	movs	r0, #0
 8003854:	4798      	blx	r3
 8003856:	4603      	mov	r3, r0
 8003858:	2b00      	cmp	r3, #0
 800385a:	d041      	beq.n	80038e0 <cliFatfs+0xc4>
	{
		cliPrintf("fatfs init \t: %d\n", is_init);
 800385c:	4b8e      	ldr	r3, [pc, #568]	@ (8003a98 <cliFatfs+0x27c>)
 800385e:	781b      	ldrb	r3, [r3, #0]
 8003860:	4619      	mov	r1, r3
 8003862:	488e      	ldr	r0, [pc, #568]	@ (8003a9c <cliFatfs+0x280>)
 8003864:	f7ff fd10 	bl	8003288 <cliPrintf>

		if(is_init == true)
 8003868:	4b8b      	ldr	r3, [pc, #556]	@ (8003a98 <cliFatfs+0x27c>)
 800386a:	781b      	ldrb	r3, [r3, #0]
 800386c:	2b00      	cmp	r3, #0
 800386e:	d034      	beq.n	80038da <cliFatfs+0xbe>
			FATFS *fs;
			DWORD fre_clust, fre_sect, tot_sect;
			FRESULT res;

			/* Get volume information and free clusters of drive 1 */
			res = f_getfree("", &fre_clust, &fs);
 8003870:	f507 7211 	add.w	r2, r7, #580	@ 0x244
 8003874:	f507 7310 	add.w	r3, r7, #576	@ 0x240
 8003878:	4619      	mov	r1, r3
 800387a:	4889      	ldr	r0, [pc, #548]	@ (8003aa0 <cliFatfs+0x284>)
 800387c:	f014 ff89 	bl	8018792 <f_getfree>
 8003880:	4603      	mov	r3, r0
 8003882:	f887 325f 	strb.w	r3, [r7, #607]	@ 0x25f
			if(res == FR_OK)
 8003886:	f897 325f 	ldrb.w	r3, [r7, #607]	@ 0x25f
 800388a:	2b00      	cmp	r3, #0
 800388c:	d11f      	bne.n	80038ce <cliFatfs+0xb2>
			{
				/* Get total sectors and free sectors */
				tot_sect = (fs->n_fatent - 2) * fs->csize;
 800388e:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 8003892:	699b      	ldr	r3, [r3, #24]
 8003894:	3b02      	subs	r3, #2
 8003896:	f8d7 2244 	ldr.w	r2, [r7, #580]	@ 0x244
 800389a:	8952      	ldrh	r2, [r2, #10]
 800389c:	fb02 f303 	mul.w	r3, r2, r3
 80038a0:	f8c7 3258 	str.w	r3, [r7, #600]	@ 0x258
				fre_sect = fre_clust * fs->csize;
 80038a4:	f8d7 3244 	ldr.w	r3, [r7, #580]	@ 0x244
 80038a8:	895b      	ldrh	r3, [r3, #10]
 80038aa:	461a      	mov	r2, r3
 80038ac:	f8d7 3240 	ldr.w	r3, [r7, #576]	@ 0x240
 80038b0:	fb02 f303 	mul.w	r3, r2, r3
 80038b4:	f8c7 3254 	str.w	r3, [r7, #596]	@ 0x254

				/* Print the free space (assuming 512 bytes/sector) */
				cliPrintf("%10lu KiB total drive space.\n%10lu KiB available.\n", tot_sect/2, fre_sect/2);
 80038b8:	f8d7 3258 	ldr.w	r3, [r7, #600]	@ 0x258
 80038bc:	0859      	lsrs	r1, r3, #1
 80038be:	f8d7 3254 	ldr.w	r3, [r7, #596]	@ 0x254
 80038c2:	085b      	lsrs	r3, r3, #1
 80038c4:	461a      	mov	r2, r3
 80038c6:	4877      	ldr	r0, [pc, #476]	@ (8003aa4 <cliFatfs+0x288>)
 80038c8:	f7ff fcde 	bl	8003288 <cliPrintf>
 80038cc:	e005      	b.n	80038da <cliFatfs+0xbe>
			}
			else
			{
				cliPrintf(" err : %d\n", res);
 80038ce:	f897 325f 	ldrb.w	r3, [r7, #607]	@ 0x25f
 80038d2:	4619      	mov	r1, r3
 80038d4:	4874      	ldr	r0, [pc, #464]	@ (8003aa8 <cliFatfs+0x28c>)
 80038d6:	f7ff fcd7 	bl	8003288 <cliPrintf>
			}
		}

		ret = true;
 80038da:	2301      	movs	r3, #1
 80038dc:	f887 3267 	strb.w	r3, [r7, #615]	@ 0x267
	}

	if(args->argc == 1 && args->isStr(0, "dir") == true)
 80038e0:	f507 731a 	add.w	r3, r7, #616	@ 0x268
 80038e4:	f5a3 7319 	sub.w	r3, r3, #612	@ 0x264
 80038e8:	681b      	ldr	r3, [r3, #0]
 80038ea:	881b      	ldrh	r3, [r3, #0]
 80038ec:	2b01      	cmp	r3, #1
 80038ee:	d11e      	bne.n	800392e <cliFatfs+0x112>
 80038f0:	f507 731a 	add.w	r3, r7, #616	@ 0x268
 80038f4:	f5a3 7319 	sub.w	r3, r3, #612	@ 0x264
 80038f8:	681b      	ldr	r3, [r3, #0]
 80038fa:	695b      	ldr	r3, [r3, #20]
 80038fc:	496b      	ldr	r1, [pc, #428]	@ (8003aac <cliFatfs+0x290>)
 80038fe:	2000      	movs	r0, #0
 8003900:	4798      	blx	r3
 8003902:	4603      	mov	r3, r0
 8003904:	2b00      	cmp	r3, #0
 8003906:	d012      	beq.n	800392e <cliFatfs+0x112>
	{
		FRESULT res;

		res = fatfsDir("/");
 8003908:	4869      	ldr	r0, [pc, #420]	@ (8003ab0 <cliFatfs+0x294>)
 800390a:	f7ff ff1d 	bl	8003748 <fatfsDir>
 800390e:	4603      	mov	r3, r0
 8003910:	f887 3253 	strb.w	r3, [r7, #595]	@ 0x253
		if(res != FR_OK)
 8003914:	f897 3253 	ldrb.w	r3, [r7, #595]	@ 0x253
 8003918:	2b00      	cmp	r3, #0
 800391a:	d005      	beq.n	8003928 <cliFatfs+0x10c>
		{
			cliPrintf(" err : %d\n", res);
 800391c:	f897 3253 	ldrb.w	r3, [r7, #595]	@ 0x253
 8003920:	4619      	mov	r1, r3
 8003922:	4861      	ldr	r0, [pc, #388]	@ (8003aa8 <cliFatfs+0x28c>)
 8003924:	f7ff fcb0 	bl	8003288 <cliPrintf>
		}

		ret = true;
 8003928:	2301      	movs	r3, #1
 800392a:	f887 3267 	strb.w	r3, [r7, #615]	@ 0x267
	}

	if(args->argc == 1 && args->isStr(0, "test") == true)
 800392e:	f507 731a 	add.w	r3, r7, #616	@ 0x268
 8003932:	f5a3 7319 	sub.w	r3, r3, #612	@ 0x264
 8003936:	681b      	ldr	r3, [r3, #0]
 8003938:	881b      	ldrh	r3, [r3, #0]
 800393a:	2b01      	cmp	r3, #1
 800393c:	f040 8095 	bne.w	8003a6a <cliFatfs+0x24e>
 8003940:	f507 731a 	add.w	r3, r7, #616	@ 0x268
 8003944:	f5a3 7319 	sub.w	r3, r3, #612	@ 0x264
 8003948:	681b      	ldr	r3, [r3, #0]
 800394a:	695b      	ldr	r3, [r3, #20]
 800394c:	4959      	ldr	r1, [pc, #356]	@ (8003ab4 <cliFatfs+0x298>)
 800394e:	2000      	movs	r0, #0
 8003950:	4798      	blx	r3
 8003952:	4603      	mov	r3, r0
 8003954:	2b00      	cmp	r3, #0
 8003956:	f000 8088 	beq.w	8003a6a <cliFatfs+0x24e>
	{
		FRESULT fp_ret;
		FIL log_file;
		uint32_t pre_time;

		pre_time = millis();
 800395a:	f7fe f899 	bl	8001a90 <millis>
 800395e:	f8c7 024c 	str.w	r0, [r7, #588]	@ 0x24c
		fp_ret = f_open(&log_file, "1.csv", FA_CREATE_ALWAYS | FA_WRITE | FA_READ);
 8003962:	f107 0308 	add.w	r3, r7, #8
 8003966:	220b      	movs	r2, #11
 8003968:	4953      	ldr	r1, [pc, #332]	@ (8003ab8 <cliFatfs+0x29c>)
 800396a:	4618      	mov	r0, r3
 800396c:	f013 feec 	bl	8017748 <f_open>
 8003970:	4603      	mov	r3, r0
 8003972:	f887 324b 	strb.w	r3, [r7, #587]	@ 0x24b
		if(fp_ret == FR_OK)
 8003976:	f897 324b 	ldrb.w	r3, [r7, #587]	@ 0x24b
 800397a:	2b00      	cmp	r3, #0
 800397c:	d165      	bne.n	8003a4a <cliFatfs+0x22e>
		{
			f_printf(&log_file, "test1, ");
 800397e:	f107 0308 	add.w	r3, r7, #8
 8003982:	494e      	ldr	r1, [pc, #312]	@ (8003abc <cliFatfs+0x2a0>)
 8003984:	4618      	mov	r0, r3
 8003986:	f015 f831 	bl	80189ec <f_printf>
			f_printf(&log_file, "test2, ");
 800398a:	f107 0308 	add.w	r3, r7, #8
 800398e:	494c      	ldr	r1, [pc, #304]	@ (8003ac0 <cliFatfs+0x2a4>)
 8003990:	4618      	mov	r0, r3
 8003992:	f015 f82b 	bl	80189ec <f_printf>
			f_printf(&log_file, "test3, ");
 8003996:	f107 0308 	add.w	r3, r7, #8
 800399a:	494a      	ldr	r1, [pc, #296]	@ (8003ac4 <cliFatfs+0x2a8>)
 800399c:	4618      	mov	r0, r3
 800399e:	f015 f825 	bl	80189ec <f_printf>
			f_printf(&log_file, ", ");
 80039a2:	f107 0308 	add.w	r3, r7, #8
 80039a6:	4948      	ldr	r1, [pc, #288]	@ (8003ac8 <cliFatfs+0x2ac>)
 80039a8:	4618      	mov	r0, r3
 80039aa:	f015 f81f 	bl	80189ec <f_printf>
			f_printf(&log_file, "\n");
 80039ae:	f107 0308 	add.w	r3, r7, #8
 80039b2:	4946      	ldr	r1, [pc, #280]	@ (8003acc <cliFatfs+0x2b0>)
 80039b4:	4618      	mov	r0, r3
 80039b6:	f015 f819 	bl	80189ec <f_printf>

			for(int i=0; i<8; i++)
 80039ba:	2300      	movs	r3, #0
 80039bc:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260
 80039c0:	e00c      	b.n	80039dc <cliFatfs+0x1c0>
			{
				f_printf(&log_file, "%d \n", i);
 80039c2:	f107 0308 	add.w	r3, r7, #8
 80039c6:	f8d7 2260 	ldr.w	r2, [r7, #608]	@ 0x260
 80039ca:	4941      	ldr	r1, [pc, #260]	@ (8003ad0 <cliFatfs+0x2b4>)
 80039cc:	4618      	mov	r0, r3
 80039ce:	f015 f80d 	bl	80189ec <f_printf>
			for(int i=0; i<8; i++)
 80039d2:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80039d6:	3301      	adds	r3, #1
 80039d8:	f8c7 3260 	str.w	r3, [r7, #608]	@ 0x260
 80039dc:	f8d7 3260 	ldr.w	r3, [r7, #608]	@ 0x260
 80039e0:	2b07      	cmp	r3, #7
 80039e2:	ddee      	ble.n	80039c2 <cliFatfs+0x1a6>
			}

			f_rewind(&log_file);
 80039e4:	f107 0308 	add.w	r3, r7, #8
 80039e8:	2100      	movs	r1, #0
 80039ea:	4618      	mov	r0, r3
 80039ec:	f014 fbd2 	bl	8018194 <f_lseek>


			UINT len;
			uint8_t data;

			while(cliKeepLoop())
 80039f0:	e01c      	b.n	8003a2c <cliFatfs+0x210>
			{
				len = 0;
 80039f2:	2300      	movs	r3, #0
 80039f4:	f8c7 323c 	str.w	r3, [r7, #572]	@ 0x23c
				fp_ret = f_read(&log_file, &data, 1, &len);
 80039f8:	f507 730f 	add.w	r3, r7, #572	@ 0x23c
 80039fc:	f207 213b 	addw	r1, r7, #571	@ 0x23b
 8003a00:	f107 0008 	add.w	r0, r7, #8
 8003a04:	2201      	movs	r2, #1
 8003a06:	f014 f869 	bl	8017adc <f_read>
 8003a0a:	4603      	mov	r3, r0
 8003a0c:	f887 324b 	strb.w	r3, [r7, #587]	@ 0x24b

				if(fp_ret != FR_OK)
 8003a10:	f897 324b 	ldrb.w	r3, [r7, #587]	@ 0x24b
 8003a14:	2b00      	cmp	r3, #0
 8003a16:	d10f      	bne.n	8003a38 <cliFatfs+0x21c>
				{
					break;
				}

				if(len == 0)
 8003a18:	f8d7 323c 	ldr.w	r3, [r7, #572]	@ 0x23c
 8003a1c:	2b00      	cmp	r3, #0
 8003a1e:	d00d      	beq.n	8003a3c <cliFatfs+0x220>
				{
					break;
				}

				cliPrintf("%c", data);
 8003a20:	f897 323b 	ldrb.w	r3, [r7, #571]	@ 0x23b
 8003a24:	4619      	mov	r1, r3
 8003a26:	482b      	ldr	r0, [pc, #172]	@ (8003ad4 <cliFatfs+0x2b8>)
 8003a28:	f7ff fc2e 	bl	8003288 <cliPrintf>
			while(cliKeepLoop())
 8003a2c:	f7ff fd26 	bl	800347c <cliKeepLoop>
 8003a30:	4603      	mov	r3, r0
 8003a32:	2b00      	cmp	r3, #0
 8003a34:	d1dd      	bne.n	80039f2 <cliFatfs+0x1d6>
 8003a36:	e002      	b.n	8003a3e <cliFatfs+0x222>
					break;
 8003a38:	bf00      	nop
 8003a3a:	e000      	b.n	8003a3e <cliFatfs+0x222>
					break;
 8003a3c:	bf00      	nop
			}

			f_close(&log_file);
 8003a3e:	f107 0308 	add.w	r3, r7, #8
 8003a42:	4618      	mov	r0, r3
 8003a44:	f014 fb7c 	bl	8018140 <f_close>
 8003a48:	e002      	b.n	8003a50 <cliFatfs+0x234>
		}
		else
		{
			cliPrintf("f_open fail\r\n");
 8003a4a:	4823      	ldr	r0, [pc, #140]	@ (8003ad8 <cliFatfs+0x2bc>)
 8003a4c:	f7ff fc1c 	bl	8003288 <cliPrintf>
		}

		cliPrintf("%d ms\r\n", millis() - pre_time);
 8003a50:	f7fe f81e 	bl	8001a90 <millis>
 8003a54:	4602      	mov	r2, r0
 8003a56:	f8d7 324c 	ldr.w	r3, [r7, #588]	@ 0x24c
 8003a5a:	1ad3      	subs	r3, r2, r3
 8003a5c:	4619      	mov	r1, r3
 8003a5e:	481f      	ldr	r0, [pc, #124]	@ (8003adc <cliFatfs+0x2c0>)
 8003a60:	f7ff fc12 	bl	8003288 <cliPrintf>

		ret = true;
 8003a64:	2301      	movs	r3, #1
 8003a66:	f887 3267 	strb.w	r3, [r7, #615]	@ 0x267
	}

	if(ret != true)
 8003a6a:	f897 3267 	ldrb.w	r3, [r7, #615]	@ 0x267
 8003a6e:	f083 0301 	eor.w	r3, r3, #1
 8003a72:	b2db      	uxtb	r3, r3
 8003a74:	2b00      	cmp	r3, #0
 8003a76:	d008      	beq.n	8003a8a <cliFatfs+0x26e>
	{
		cliPrintf("fatfs info\n");
 8003a78:	4819      	ldr	r0, [pc, #100]	@ (8003ae0 <cliFatfs+0x2c4>)
 8003a7a:	f7ff fc05 	bl	8003288 <cliPrintf>
		cliPrintf("fatfs dir\n");
 8003a7e:	4819      	ldr	r0, [pc, #100]	@ (8003ae4 <cliFatfs+0x2c8>)
 8003a80:	f7ff fc02 	bl	8003288 <cliPrintf>
		cliPrintf("fatfs test\n");
 8003a84:	4818      	ldr	r0, [pc, #96]	@ (8003ae8 <cliFatfs+0x2cc>)
 8003a86:	f7ff fbff 	bl	8003288 <cliPrintf>
	}
}
 8003a8a:	bf00      	nop
 8003a8c:	f507 771a 	add.w	r7, r7, #616	@ 0x268
 8003a90:	46bd      	mov	sp, r7
 8003a92:	bd80      	pop	{r7, pc}
 8003a94:	0802426c 	.word	0x0802426c
 8003a98:	20000f90 	.word	0x20000f90
 8003a9c:	08024274 	.word	0x08024274
 8003aa0:	08024288 	.word	0x08024288
 8003aa4:	0802428c 	.word	0x0802428c
 8003aa8:	080242c0 	.word	0x080242c0
 8003aac:	080242cc 	.word	0x080242cc
 8003ab0:	080242d0 	.word	0x080242d0
 8003ab4:	080242d4 	.word	0x080242d4
 8003ab8:	080242dc 	.word	0x080242dc
 8003abc:	080242e4 	.word	0x080242e4
 8003ac0:	080242ec 	.word	0x080242ec
 8003ac4:	080242f4 	.word	0x080242f4
 8003ac8:	080242fc 	.word	0x080242fc
 8003acc:	08024300 	.word	0x08024300
 8003ad0:	08024304 	.word	0x08024304
 8003ad4:	0802430c 	.word	0x0802430c
 8003ad8:	08024310 	.word	0x08024310
 8003adc:	08024320 	.word	0x08024320
 8003ae0:	08024328 	.word	0x08024328
 8003ae4:	08024334 	.word	0x08024334
 8003ae8:	08024340 	.word	0x08024340

08003aec <ob_malloc>:

static bool is_used[8] = {0, };
static FIL	fil_buf[8];

void *ob_malloc(size_t size)
{
 8003aec:	b480      	push	{r7}
 8003aee:	b085      	sub	sp, #20
 8003af0:	af00      	add	r7, sp, #0
 8003af2:	6078      	str	r0, [r7, #4]
	void *ret = NULL;
 8003af4:	2300      	movs	r3, #0
 8003af6:	60fb      	str	r3, [r7, #12]

	for(int i=0; i<8; i++)
 8003af8:	2300      	movs	r3, #0
 8003afa:	60bb      	str	r3, [r7, #8]
 8003afc:	e019      	b.n	8003b32 <ob_malloc+0x46>
	{
		if(is_used[i] == false)
 8003afe:	4a12      	ldr	r2, [pc, #72]	@ (8003b48 <ob_malloc+0x5c>)
 8003b00:	68bb      	ldr	r3, [r7, #8]
 8003b02:	4413      	add	r3, r2
 8003b04:	781b      	ldrb	r3, [r3, #0]
 8003b06:	f083 0301 	eor.w	r3, r3, #1
 8003b0a:	b2db      	uxtb	r3, r3
 8003b0c:	2b00      	cmp	r3, #0
 8003b0e:	d00d      	beq.n	8003b2c <ob_malloc+0x40>
		{
			is_used[i] = true;
 8003b10:	4a0d      	ldr	r2, [pc, #52]	@ (8003b48 <ob_malloc+0x5c>)
 8003b12:	68bb      	ldr	r3, [r7, #8]
 8003b14:	4413      	add	r3, r2
 8003b16:	2201      	movs	r2, #1
 8003b18:	701a      	strb	r2, [r3, #0]
			ret = (void *)&fil_buf[i];
 8003b1a:	68bb      	ldr	r3, [r7, #8]
 8003b1c:	f44f 720c 	mov.w	r2, #560	@ 0x230
 8003b20:	fb02 f303 	mul.w	r3, r2, r3
 8003b24:	4a09      	ldr	r2, [pc, #36]	@ (8003b4c <ob_malloc+0x60>)
 8003b26:	4413      	add	r3, r2
 8003b28:	60fb      	str	r3, [r7, #12]
			break;
 8003b2a:	e005      	b.n	8003b38 <ob_malloc+0x4c>
	for(int i=0; i<8; i++)
 8003b2c:	68bb      	ldr	r3, [r7, #8]
 8003b2e:	3301      	adds	r3, #1
 8003b30:	60bb      	str	r3, [r7, #8]
 8003b32:	68bb      	ldr	r3, [r7, #8]
 8003b34:	2b07      	cmp	r3, #7
 8003b36:	dde2      	ble.n	8003afe <ob_malloc+0x12>
		}
	}

	return ret;
 8003b38:	68fb      	ldr	r3, [r7, #12]
}
 8003b3a:	4618      	mov	r0, r3
 8003b3c:	3714      	adds	r7, #20
 8003b3e:	46bd      	mov	sp, r7
 8003b40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b44:	4770      	bx	lr
 8003b46:	bf00      	nop
 8003b48:	200011cc 	.word	0x200011cc
 8003b4c:	200011d4 	.word	0x200011d4

08003b50 <ob_free>:

void ob_free(void *addr)
{
 8003b50:	b480      	push	{r7}
 8003b52:	b085      	sub	sp, #20
 8003b54:	af00      	add	r7, sp, #0
 8003b56:	6078      	str	r0, [r7, #4]
	for(int i=0; i<8; i++)
 8003b58:	2300      	movs	r3, #0
 8003b5a:	60fb      	str	r3, [r7, #12]
 8003b5c:	e018      	b.n	8003b90 <ob_free+0x40>
	{
		if(is_used[i] == true && addr == (void *)&fil_buf[i])
 8003b5e:	4a11      	ldr	r2, [pc, #68]	@ (8003ba4 <ob_free+0x54>)
 8003b60:	68fb      	ldr	r3, [r7, #12]
 8003b62:	4413      	add	r3, r2
 8003b64:	781b      	ldrb	r3, [r3, #0]
 8003b66:	2b00      	cmp	r3, #0
 8003b68:	d00f      	beq.n	8003b8a <ob_free+0x3a>
 8003b6a:	68fb      	ldr	r3, [r7, #12]
 8003b6c:	f44f 720c 	mov.w	r2, #560	@ 0x230
 8003b70:	fb02 f303 	mul.w	r3, r2, r3
 8003b74:	4a0c      	ldr	r2, [pc, #48]	@ (8003ba8 <ob_free+0x58>)
 8003b76:	4413      	add	r3, r2
 8003b78:	687a      	ldr	r2, [r7, #4]
 8003b7a:	429a      	cmp	r2, r3
 8003b7c:	d105      	bne.n	8003b8a <ob_free+0x3a>
		{
			is_used[i] = false;
 8003b7e:	4a09      	ldr	r2, [pc, #36]	@ (8003ba4 <ob_free+0x54>)
 8003b80:	68fb      	ldr	r3, [r7, #12]
 8003b82:	4413      	add	r3, r2
 8003b84:	2200      	movs	r2, #0
 8003b86:	701a      	strb	r2, [r3, #0]
			break;
 8003b88:	e006      	b.n	8003b98 <ob_free+0x48>
	for(int i=0; i<8; i++)
 8003b8a:	68fb      	ldr	r3, [r7, #12]
 8003b8c:	3301      	adds	r3, #1
 8003b8e:	60fb      	str	r3, [r7, #12]
 8003b90:	68fb      	ldr	r3, [r7, #12]
 8003b92:	2b07      	cmp	r3, #7
 8003b94:	dde3      	ble.n	8003b5e <ob_free+0xe>
		}
	}
}
 8003b96:	bf00      	nop
 8003b98:	bf00      	nop
 8003b9a:	3714      	adds	r7, #20
 8003b9c:	46bd      	mov	sp, r7
 8003b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ba2:	4770      	bx	lr
 8003ba4:	200011cc 	.word	0x200011cc
 8003ba8:	200011d4 	.word	0x200011d4

08003bac <ob_fopen>:

FILE *ob_fopen(const char *filename, const char *mode)
{
 8003bac:	b580      	push	{r7, lr}
 8003bae:	b086      	sub	sp, #24
 8003bb0:	af00      	add	r7, sp, #0
 8003bb2:	6078      	str	r0, [r7, #4]
 8003bb4:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE flags = 0;
 8003bb6:	2300      	movs	r3, #0
 8003bb8:	75fb      	strb	r3, [r7, #23]
	FIL *fil;
	int i;

	fil = ob_malloc(sizeof(FIL));
 8003bba:	f44f 700c 	mov.w	r0, #560	@ 0x230
 8003bbe:	f7ff ff95 	bl	8003aec <ob_malloc>
 8003bc2:	60f8      	str	r0, [r7, #12]
	if(!fil)
 8003bc4:	68fb      	ldr	r3, [r7, #12]
 8003bc6:	2b00      	cmp	r3, #0
 8003bc8:	d104      	bne.n	8003bd4 <ob_fopen+0x28>
	{
		printf("ob_fopen malloc fail\n");
 8003bca:	4821      	ldr	r0, [pc, #132]	@ (8003c50 <ob_fopen+0xa4>)
 8003bcc:	f01e f968 	bl	8021ea0 <puts>
		return NULL;
 8003bd0:	2300      	movs	r3, #0
 8003bd2:	e038      	b.n	8003c46 <ob_fopen+0x9a>
	}

	for(i=0; mode[i] != 0; i++)
 8003bd4:	2300      	movs	r3, #0
 8003bd6:	613b      	str	r3, [r7, #16]
 8003bd8:	e01e      	b.n	8003c18 <ob_fopen+0x6c>
	{
		switch(mode[i]) {
 8003bda:	693b      	ldr	r3, [r7, #16]
 8003bdc:	683a      	ldr	r2, [r7, #0]
 8003bde:	4413      	add	r3, r2
 8003be0:	781b      	ldrb	r3, [r3, #0]
 8003be2:	2b77      	cmp	r3, #119	@ 0x77
 8003be4:	d006      	beq.n	8003bf4 <ob_fopen+0x48>
 8003be6:	2b77      	cmp	r3, #119	@ 0x77
 8003be8:	dc13      	bgt.n	8003c12 <ob_fopen+0x66>
 8003bea:	2b2b      	cmp	r3, #43	@ 0x2b
 8003bec:	d00c      	beq.n	8003c08 <ob_fopen+0x5c>
 8003bee:	2b72      	cmp	r3, #114	@ 0x72
 8003bf0:	d005      	beq.n	8003bfe <ob_fopen+0x52>
 8003bf2:	e00e      	b.n	8003c12 <ob_fopen+0x66>
			case 'w':
				flags |= FA_WRITE | FA_CREATE_ALWAYS;
 8003bf4:	7dfb      	ldrb	r3, [r7, #23]
 8003bf6:	f043 030a 	orr.w	r3, r3, #10
 8003bfa:	75fb      	strb	r3, [r7, #23]
				break;
 8003bfc:	e009      	b.n	8003c12 <ob_fopen+0x66>
			case 'r':
				flags |= FA_READ;
 8003bfe:	7dfb      	ldrb	r3, [r7, #23]
 8003c00:	f043 0301 	orr.w	r3, r3, #1
 8003c04:	75fb      	strb	r3, [r7, #23]
				break;
 8003c06:	e004      	b.n	8003c12 <ob_fopen+0x66>
			case '+':
				flags |= FA_READ | FA_WRITE;
 8003c08:	7dfb      	ldrb	r3, [r7, #23]
 8003c0a:	f043 0303 	orr.w	r3, r3, #3
 8003c0e:	75fb      	strb	r3, [r7, #23]
				break;
 8003c10:	bf00      	nop
	for(i=0; mode[i] != 0; i++)
 8003c12:	693b      	ldr	r3, [r7, #16]
 8003c14:	3301      	adds	r3, #1
 8003c16:	613b      	str	r3, [r7, #16]
 8003c18:	693b      	ldr	r3, [r7, #16]
 8003c1a:	683a      	ldr	r2, [r7, #0]
 8003c1c:	4413      	add	r3, r2
 8003c1e:	781b      	ldrb	r3, [r3, #0]
 8003c20:	2b00      	cmp	r3, #0
 8003c22:	d1da      	bne.n	8003bda <ob_fopen+0x2e>
		}
	}

	res = f_open(fil, filename, flags);
 8003c24:	7dfb      	ldrb	r3, [r7, #23]
 8003c26:	461a      	mov	r2, r3
 8003c28:	6879      	ldr	r1, [r7, #4]
 8003c2a:	68f8      	ldr	r0, [r7, #12]
 8003c2c:	f013 fd8c 	bl	8017748 <f_open>
 8003c30:	4603      	mov	r3, r0
 8003c32:	72fb      	strb	r3, [r7, #11]
	if(res != FR_OK)
 8003c34:	7afb      	ldrb	r3, [r7, #11]
 8003c36:	2b00      	cmp	r3, #0
 8003c38:	d004      	beq.n	8003c44 <ob_fopen+0x98>
	{
		ob_free(fil);
 8003c3a:	68f8      	ldr	r0, [r7, #12]
 8003c3c:	f7ff ff88 	bl	8003b50 <ob_free>
		return NULL;
 8003c40:	2300      	movs	r3, #0
 8003c42:	e000      	b.n	8003c46 <ob_fopen+0x9a>
	}

	return (FILE *)fil;
 8003c44:	68fb      	ldr	r3, [r7, #12]
}
 8003c46:	4618      	mov	r0, r3
 8003c48:	3718      	adds	r7, #24
 8003c4a:	46bd      	mov	sp, r7
 8003c4c:	bd80      	pop	{r7, pc}
 8003c4e:	bf00      	nop
 8003c50:	0802434c 	.word	0x0802434c

08003c54 <ob_fclose>:

int ob_fclose(FILE *stream)
{
 8003c54:	b580      	push	{r7, lr}
 8003c56:	b084      	sub	sp, #16
 8003c58:	af00      	add	r7, sp, #0
 8003c5a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FIL *fil = (FIL *)stream;
 8003c5c:	687b      	ldr	r3, [r7, #4]
 8003c5e:	60fb      	str	r3, [r7, #12]
	res = f_close(fil);
 8003c60:	68f8      	ldr	r0, [r7, #12]
 8003c62:	f014 fa6d 	bl	8018140 <f_close>
 8003c66:	4603      	mov	r3, r0
 8003c68:	72fb      	strb	r3, [r7, #11]
	if(res != FR_OK)
 8003c6a:	7afb      	ldrb	r3, [r7, #11]
 8003c6c:	2b00      	cmp	r3, #0
 8003c6e:	d002      	beq.n	8003c76 <ob_fclose+0x22>
	{
		return -1;
 8003c70:	f04f 33ff 	mov.w	r3, #4294967295
 8003c74:	e003      	b.n	8003c7e <ob_fclose+0x2a>
	}

	ob_free(fil);
 8003c76:	68f8      	ldr	r0, [r7, #12]
 8003c78:	f7ff ff6a 	bl	8003b50 <ob_free>

	return 0;
 8003c7c:	2300      	movs	r3, #0
}
 8003c7e:	4618      	mov	r0, r3
 8003c80:	3710      	adds	r7, #16
 8003c82:	46bd      	mov	sp, r7
 8003c84:	bd80      	pop	{r7, pc}

08003c86 <ob_fread>:

size_t ob_fread(void *ptr, size_t size, size_t count, FILE *stream)
{
 8003c86:	b580      	push	{r7, lr}
 8003c88:	b088      	sub	sp, #32
 8003c8a:	af00      	add	r7, sp, #0
 8003c8c:	60f8      	str	r0, [r7, #12]
 8003c8e:	60b9      	str	r1, [r7, #8]
 8003c90:	607a      	str	r2, [r7, #4]
 8003c92:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FIL *fil = (FIL *)stream;
 8003c94:	683b      	ldr	r3, [r7, #0]
 8003c96:	61fb      	str	r3, [r7, #28]
	UINT bread;
	res = f_read(fil, ptr, size * count, &bread);
 8003c98:	68bb      	ldr	r3, [r7, #8]
 8003c9a:	687a      	ldr	r2, [r7, #4]
 8003c9c:	fb03 f202 	mul.w	r2, r3, r2
 8003ca0:	f107 0314 	add.w	r3, r7, #20
 8003ca4:	68f9      	ldr	r1, [r7, #12]
 8003ca6:	69f8      	ldr	r0, [r7, #28]
 8003ca8:	f013 ff18 	bl	8017adc <f_read>
 8003cac:	4603      	mov	r3, r0
 8003cae:	76fb      	strb	r3, [r7, #27]
	if(res != FR_OK)
 8003cb0:	7efb      	ldrb	r3, [r7, #27]
 8003cb2:	2b00      	cmp	r3, #0
 8003cb4:	d001      	beq.n	8003cba <ob_fread+0x34>
	{
		return 0;
 8003cb6:	2300      	movs	r3, #0
 8003cb8:	e000      	b.n	8003cbc <ob_fread+0x36>
	}

	return bread;
 8003cba:	697b      	ldr	r3, [r7, #20]
}
 8003cbc:	4618      	mov	r0, r3
 8003cbe:	3720      	adds	r7, #32
 8003cc0:	46bd      	mov	sp, r7
 8003cc2:	bd80      	pop	{r7, pc}

08003cc4 <ob_fseek>:

	return f_eof(fil);
}

int ob_fseek(FILE *stream, long offset, int whence)
{
 8003cc4:	b580      	push	{r7, lr}
 8003cc6:	b088      	sub	sp, #32
 8003cc8:	af00      	add	r7, sp, #0
 8003cca:	60f8      	str	r0, [r7, #12]
 8003ccc:	60b9      	str	r1, [r7, #8]
 8003cce:	607a      	str	r2, [r7, #4]
	FRESULT res;
	FIL *fil = (FIL *)stream;
 8003cd0:	68fb      	ldr	r3, [r7, #12]
 8003cd2:	61bb      	str	r3, [r7, #24]
	long o;
	switch(whence)
 8003cd4:	687b      	ldr	r3, [r7, #4]
 8003cd6:	2b02      	cmp	r3, #2
 8003cd8:	d012      	beq.n	8003d00 <ob_fseek+0x3c>
 8003cda:	687b      	ldr	r3, [r7, #4]
 8003cdc:	2b02      	cmp	r3, #2
 8003cde:	dc1a      	bgt.n	8003d16 <ob_fseek+0x52>
 8003ce0:	687b      	ldr	r3, [r7, #4]
 8003ce2:	2b00      	cmp	r3, #0
 8003ce4:	d003      	beq.n	8003cee <ob_fseek+0x2a>
 8003ce6:	687b      	ldr	r3, [r7, #4]
 8003ce8:	2b01      	cmp	r3, #1
 8003cea:	d003      	beq.n	8003cf4 <ob_fseek+0x30>
 8003cec:	e013      	b.n	8003d16 <ob_fseek+0x52>
	{
		case SEEK_SET:
			o = offset;
 8003cee:	68bb      	ldr	r3, [r7, #8]
 8003cf0:	61fb      	str	r3, [r7, #28]
			break;
 8003cf2:	e014      	b.n	8003d1e <ob_fseek+0x5a>
		case SEEK_CUR:
			o = offset + f_tell(fil);
 8003cf4:	69bb      	ldr	r3, [r7, #24]
 8003cf6:	699a      	ldr	r2, [r3, #24]
 8003cf8:	68bb      	ldr	r3, [r7, #8]
 8003cfa:	4413      	add	r3, r2
 8003cfc:	61fb      	str	r3, [r7, #28]
			break;
 8003cfe:	e00e      	b.n	8003d1e <ob_fseek+0x5a>
		case SEEK_END:
			o = f_size(fil) + offset;
 8003d00:	69bb      	ldr	r3, [r7, #24]
 8003d02:	68da      	ldr	r2, [r3, #12]
 8003d04:	68bb      	ldr	r3, [r7, #8]
 8003d06:	4413      	add	r3, r2
 8003d08:	61fb      	str	r3, [r7, #28]
			if(o < 0)
 8003d0a:	69fb      	ldr	r3, [r7, #28]
 8003d0c:	2b00      	cmp	r3, #0
 8003d0e:	da05      	bge.n	8003d1c <ob_fseek+0x58>
			{
				o = 0;
 8003d10:	2300      	movs	r3, #0
 8003d12:	61fb      	str	r3, [r7, #28]
			}
			break;
 8003d14:	e002      	b.n	8003d1c <ob_fseek+0x58>
		default:
			return -1;
 8003d16:	f04f 33ff 	mov.w	r3, #4294967295
 8003d1a:	e00e      	b.n	8003d3a <ob_fseek+0x76>
			break;
 8003d1c:	bf00      	nop
	}

	res = f_lseek(fil, o);
 8003d1e:	69fb      	ldr	r3, [r7, #28]
 8003d20:	4619      	mov	r1, r3
 8003d22:	69b8      	ldr	r0, [r7, #24]
 8003d24:	f014 fa36 	bl	8018194 <f_lseek>
 8003d28:	4603      	mov	r3, r0
 8003d2a:	75fb      	strb	r3, [r7, #23]
	if(res != FR_OK)
 8003d2c:	7dfb      	ldrb	r3, [r7, #23]
 8003d2e:	2b00      	cmp	r3, #0
 8003d30:	d002      	beq.n	8003d38 <ob_fseek+0x74>
	{
		return -1;
 8003d32:	f04f 33ff 	mov.w	r3, #4294967295
 8003d36:	e000      	b.n	8003d3a <ob_fseek+0x76>
	}

	return 0;
 8003d38:	2300      	movs	r3, #0
}
 8003d3a:	4618      	mov	r0, r3
 8003d3c:	3720      	adds	r7, #32
 8003d3e:	46bd      	mov	sp, r7
 8003d40:	bd80      	pop	{r7, pc}
	...

08003d44 <gpioInit>:
static void cliGpio(cli_args_t *args);
#endif


bool gpioInit(void)
{
 8003d44:	b580      	push	{r7, lr}
 8003d46:	b082      	sub	sp, #8
 8003d48:	af00      	add	r7, sp, #0
	bool ret = true;
 8003d4a:	2301      	movs	r3, #1
 8003d4c:	71fb      	strb	r3, [r7, #7]

#ifdef _USE_HW_CLI
	cliAdd("gpio", cliGpio);
 8003d4e:	4904      	ldr	r1, [pc, #16]	@ (8003d60 <gpioInit+0x1c>)
 8003d50:	4804      	ldr	r0, [pc, #16]	@ (8003d64 <gpioInit+0x20>)
 8003d52:	f7ff fba9 	bl	80034a8 <cliAdd>
#endif

	return ret;
 8003d56:	79fb      	ldrb	r3, [r7, #7]
}
 8003d58:	4618      	mov	r0, r3
 8003d5a:	3708      	adds	r7, #8
 8003d5c:	46bd      	mov	sp, r7
 8003d5e:	bd80      	pop	{r7, pc}
 8003d60:	08003e7d 	.word	0x08003e7d
 8003d64:	08024364 	.word	0x08024364

08003d68 <gpioPinWrite>:

	return ret;
}

void gpioPinWrite(uint8_t ch, bool value)
{
 8003d68:	b590      	push	{r4, r7, lr}
 8003d6a:	b083      	sub	sp, #12
 8003d6c:	af00      	add	r7, sp, #0
 8003d6e:	4603      	mov	r3, r0
 8003d70:	460a      	mov	r2, r1
 8003d72:	71fb      	strb	r3, [r7, #7]
 8003d74:	4613      	mov	r3, r2
 8003d76:	71bb      	strb	r3, [r7, #6]
	if(ch >= GPIO_MAX_CH)
 8003d78:	79fb      	ldrb	r3, [r7, #7]
 8003d7a:	2b03      	cmp	r3, #3
 8003d7c:	d840      	bhi.n	8003e00 <gpioPinWrite+0x98>
	{
		return;
	}

	if(value)
 8003d7e:	79bb      	ldrb	r3, [r7, #6]
 8003d80:	2b00      	cmp	r3, #0
 8003d82:	d01e      	beq.n	8003dc2 <gpioPinWrite+0x5a>
	{
		HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].on_state);
 8003d84:	79fa      	ldrb	r2, [r7, #7]
 8003d86:	4920      	ldr	r1, [pc, #128]	@ (8003e08 <gpioPinWrite+0xa0>)
 8003d88:	4613      	mov	r3, r2
 8003d8a:	005b      	lsls	r3, r3, #1
 8003d8c:	4413      	add	r3, r2
 8003d8e:	009b      	lsls	r3, r3, #2
 8003d90:	440b      	add	r3, r1
 8003d92:	6818      	ldr	r0, [r3, #0]
 8003d94:	79fa      	ldrb	r2, [r7, #7]
 8003d96:	491c      	ldr	r1, [pc, #112]	@ (8003e08 <gpioPinWrite+0xa0>)
 8003d98:	4613      	mov	r3, r2
 8003d9a:	005b      	lsls	r3, r3, #1
 8003d9c:	4413      	add	r3, r2
 8003d9e:	009b      	lsls	r3, r3, #2
 8003da0:	440b      	add	r3, r1
 8003da2:	3304      	adds	r3, #4
 8003da4:	681b      	ldr	r3, [r3, #0]
 8003da6:	b299      	uxth	r1, r3
 8003da8:	79fa      	ldrb	r2, [r7, #7]
 8003daa:	4c17      	ldr	r4, [pc, #92]	@ (8003e08 <gpioPinWrite+0xa0>)
 8003dac:	4613      	mov	r3, r2
 8003dae:	005b      	lsls	r3, r3, #1
 8003db0:	4413      	add	r3, r2
 8003db2:	009b      	lsls	r3, r3, #2
 8003db4:	4423      	add	r3, r4
 8003db6:	3309      	adds	r3, #9
 8003db8:	781b      	ldrb	r3, [r3, #0]
 8003dba:	461a      	mov	r2, r3
 8003dbc:	f006 fab8 	bl	800a330 <HAL_GPIO_WritePin>
 8003dc0:	e01f      	b.n	8003e02 <gpioPinWrite+0x9a>
	}
	else
	{
		HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].off_state);
 8003dc2:	79fa      	ldrb	r2, [r7, #7]
 8003dc4:	4910      	ldr	r1, [pc, #64]	@ (8003e08 <gpioPinWrite+0xa0>)
 8003dc6:	4613      	mov	r3, r2
 8003dc8:	005b      	lsls	r3, r3, #1
 8003dca:	4413      	add	r3, r2
 8003dcc:	009b      	lsls	r3, r3, #2
 8003dce:	440b      	add	r3, r1
 8003dd0:	6818      	ldr	r0, [r3, #0]
 8003dd2:	79fa      	ldrb	r2, [r7, #7]
 8003dd4:	490c      	ldr	r1, [pc, #48]	@ (8003e08 <gpioPinWrite+0xa0>)
 8003dd6:	4613      	mov	r3, r2
 8003dd8:	005b      	lsls	r3, r3, #1
 8003dda:	4413      	add	r3, r2
 8003ddc:	009b      	lsls	r3, r3, #2
 8003dde:	440b      	add	r3, r1
 8003de0:	3304      	adds	r3, #4
 8003de2:	681b      	ldr	r3, [r3, #0]
 8003de4:	b299      	uxth	r1, r3
 8003de6:	79fa      	ldrb	r2, [r7, #7]
 8003de8:	4c07      	ldr	r4, [pc, #28]	@ (8003e08 <gpioPinWrite+0xa0>)
 8003dea:	4613      	mov	r3, r2
 8003dec:	005b      	lsls	r3, r3, #1
 8003dee:	4413      	add	r3, r2
 8003df0:	009b      	lsls	r3, r3, #2
 8003df2:	4423      	add	r3, r4
 8003df4:	330a      	adds	r3, #10
 8003df6:	781b      	ldrb	r3, [r3, #0]
 8003df8:	461a      	mov	r2, r3
 8003dfa:	f006 fa99 	bl	800a330 <HAL_GPIO_WritePin>
 8003dfe:	e000      	b.n	8003e02 <gpioPinWrite+0x9a>
		return;
 8003e00:	bf00      	nop
	}
}
 8003e02:	370c      	adds	r7, #12
 8003e04:	46bd      	mov	sp, r7
 8003e06:	bd90      	pop	{r4, r7, pc}
 8003e08:	08031054 	.word	0x08031054

08003e0c <gpioPinRead>:

bool gpioPinRead(uint8_t ch)
{
 8003e0c:	b580      	push	{r7, lr}
 8003e0e:	b084      	sub	sp, #16
 8003e10:	af00      	add	r7, sp, #0
 8003e12:	4603      	mov	r3, r0
 8003e14:	71fb      	strb	r3, [r7, #7]
	bool ret = false;
 8003e16:	2300      	movs	r3, #0
 8003e18:	73fb      	strb	r3, [r7, #15]

	if(ch >= GPIO_MAX_CH)
 8003e1a:	79fb      	ldrb	r3, [r7, #7]
 8003e1c:	2b03      	cmp	r3, #3
 8003e1e:	d901      	bls.n	8003e24 <gpioPinRead+0x18>
	{
		return false;
 8003e20:	2300      	movs	r3, #0
 8003e22:	e024      	b.n	8003e6e <gpioPinRead+0x62>
	}

	if(HAL_GPIO_ReadPin(gpio_tbl[ch].port, gpio_tbl[ch].pin) == gpio_tbl[ch].on_state)
 8003e24:	79fa      	ldrb	r2, [r7, #7]
 8003e26:	4914      	ldr	r1, [pc, #80]	@ (8003e78 <gpioPinRead+0x6c>)
 8003e28:	4613      	mov	r3, r2
 8003e2a:	005b      	lsls	r3, r3, #1
 8003e2c:	4413      	add	r3, r2
 8003e2e:	009b      	lsls	r3, r3, #2
 8003e30:	440b      	add	r3, r1
 8003e32:	6818      	ldr	r0, [r3, #0]
 8003e34:	79fa      	ldrb	r2, [r7, #7]
 8003e36:	4910      	ldr	r1, [pc, #64]	@ (8003e78 <gpioPinRead+0x6c>)
 8003e38:	4613      	mov	r3, r2
 8003e3a:	005b      	lsls	r3, r3, #1
 8003e3c:	4413      	add	r3, r2
 8003e3e:	009b      	lsls	r3, r3, #2
 8003e40:	440b      	add	r3, r1
 8003e42:	3304      	adds	r3, #4
 8003e44:	681b      	ldr	r3, [r3, #0]
 8003e46:	b29b      	uxth	r3, r3
 8003e48:	4619      	mov	r1, r3
 8003e4a:	f006 fa59 	bl	800a300 <HAL_GPIO_ReadPin>
 8003e4e:	4603      	mov	r3, r0
 8003e50:	4618      	mov	r0, r3
 8003e52:	79fa      	ldrb	r2, [r7, #7]
 8003e54:	4908      	ldr	r1, [pc, #32]	@ (8003e78 <gpioPinRead+0x6c>)
 8003e56:	4613      	mov	r3, r2
 8003e58:	005b      	lsls	r3, r3, #1
 8003e5a:	4413      	add	r3, r2
 8003e5c:	009b      	lsls	r3, r3, #2
 8003e5e:	440b      	add	r3, r1
 8003e60:	3309      	adds	r3, #9
 8003e62:	781b      	ldrb	r3, [r3, #0]
 8003e64:	4298      	cmp	r0, r3
 8003e66:	d101      	bne.n	8003e6c <gpioPinRead+0x60>
	{
		ret = true;
 8003e68:	2301      	movs	r3, #1
 8003e6a:	73fb      	strb	r3, [r7, #15]
	}

	return ret;
 8003e6c:	7bfb      	ldrb	r3, [r7, #15]
}
 8003e6e:	4618      	mov	r0, r3
 8003e70:	3710      	adds	r7, #16
 8003e72:	46bd      	mov	sp, r7
 8003e74:	bd80      	pop	{r7, pc}
 8003e76:	bf00      	nop
 8003e78:	08031054 	.word	0x08031054

08003e7c <cliGpio>:


#ifdef _USE_HW_CLI

void cliGpio(cli_args_t *args)
{
 8003e7c:	b590      	push	{r4, r7, lr}
 8003e7e:	b087      	sub	sp, #28
 8003e80:	af00      	add	r7, sp, #0
 8003e82:	6078      	str	r0, [r7, #4]
	bool ret = false;
 8003e84:	2300      	movs	r3, #0
 8003e86:	75fb      	strb	r3, [r7, #23]

	if(args->argc == 1 && args->isStr(0, "show") == true)
 8003e88:	687b      	ldr	r3, [r7, #4]
 8003e8a:	881b      	ldrh	r3, [r3, #0]
 8003e8c:	2b01      	cmp	r3, #1
 8003e8e:	d129      	bne.n	8003ee4 <cliGpio+0x68>
 8003e90:	687b      	ldr	r3, [r7, #4]
 8003e92:	695b      	ldr	r3, [r3, #20]
 8003e94:	4948      	ldr	r1, [pc, #288]	@ (8003fb8 <cliGpio+0x13c>)
 8003e96:	2000      	movs	r0, #0
 8003e98:	4798      	blx	r3
 8003e9a:	4603      	mov	r3, r0
 8003e9c:	2b00      	cmp	r3, #0
 8003e9e:	d021      	beq.n	8003ee4 <cliGpio+0x68>
	{
		while(cliKeepLoop())
 8003ea0:	e019      	b.n	8003ed6 <cliGpio+0x5a>
		{
			for(int i=0; i<GPIO_MAX_CH; i++)
 8003ea2:	2300      	movs	r3, #0
 8003ea4:	613b      	str	r3, [r7, #16]
 8003ea6:	e00c      	b.n	8003ec2 <cliGpio+0x46>
			{
				cliPrintf("%d", gpioPinRead(i));
 8003ea8:	693b      	ldr	r3, [r7, #16]
 8003eaa:	b2db      	uxtb	r3, r3
 8003eac:	4618      	mov	r0, r3
 8003eae:	f7ff ffad 	bl	8003e0c <gpioPinRead>
 8003eb2:	4603      	mov	r3, r0
 8003eb4:	4619      	mov	r1, r3
 8003eb6:	4841      	ldr	r0, [pc, #260]	@ (8003fbc <cliGpio+0x140>)
 8003eb8:	f7ff f9e6 	bl	8003288 <cliPrintf>
			for(int i=0; i<GPIO_MAX_CH; i++)
 8003ebc:	693b      	ldr	r3, [r7, #16]
 8003ebe:	3301      	adds	r3, #1
 8003ec0:	613b      	str	r3, [r7, #16]
 8003ec2:	693b      	ldr	r3, [r7, #16]
 8003ec4:	2b03      	cmp	r3, #3
 8003ec6:	ddef      	ble.n	8003ea8 <cliGpio+0x2c>
			}
			cliPrintf("\n");
 8003ec8:	483d      	ldr	r0, [pc, #244]	@ (8003fc0 <cliGpio+0x144>)
 8003eca:	f7ff f9dd 	bl	8003288 <cliPrintf>
			delay(300);
 8003ece:	f44f 7096 	mov.w	r0, #300	@ 0x12c
 8003ed2:	f7fd fdd2 	bl	8001a7a <delay>
		while(cliKeepLoop())
 8003ed6:	f7ff fad1 	bl	800347c <cliKeepLoop>
 8003eda:	4603      	mov	r3, r0
 8003edc:	2b00      	cmp	r3, #0
 8003ede:	d1e0      	bne.n	8003ea2 <cliGpio+0x26>
		}

		ret = true;
 8003ee0:	2301      	movs	r3, #1
 8003ee2:	75fb      	strb	r3, [r7, #23]
	}

	if(args->argc == 2 && args->isStr(0, "read") == true)
 8003ee4:	687b      	ldr	r3, [r7, #4]
 8003ee6:	881b      	ldrh	r3, [r3, #0]
 8003ee8:	2b02      	cmp	r3, #2
 8003eea:	d124      	bne.n	8003f36 <cliGpio+0xba>
 8003eec:	687b      	ldr	r3, [r7, #4]
 8003eee:	695b      	ldr	r3, [r3, #20]
 8003ef0:	4934      	ldr	r1, [pc, #208]	@ (8003fc4 <cliGpio+0x148>)
 8003ef2:	2000      	movs	r0, #0
 8003ef4:	4798      	blx	r3
 8003ef6:	4603      	mov	r3, r0
 8003ef8:	2b00      	cmp	r3, #0
 8003efa:	d01c      	beq.n	8003f36 <cliGpio+0xba>
	{
		uint8_t ch;

		ch = (uint8_t)args->getData(1);
 8003efc:	687b      	ldr	r3, [r7, #4]
 8003efe:	689b      	ldr	r3, [r3, #8]
 8003f00:	2001      	movs	r0, #1
 8003f02:	4798      	blx	r3
 8003f04:	4603      	mov	r3, r0
 8003f06:	73fb      	strb	r3, [r7, #15]

		while(cliKeepLoop())
 8003f08:	e00e      	b.n	8003f28 <cliGpio+0xac>
		{
			cliPrintf("gpio read %d : %d\n", ch, gpioPinRead(ch));
 8003f0a:	7bfc      	ldrb	r4, [r7, #15]
 8003f0c:	7bfb      	ldrb	r3, [r7, #15]
 8003f0e:	4618      	mov	r0, r3
 8003f10:	f7ff ff7c 	bl	8003e0c <gpioPinRead>
 8003f14:	4603      	mov	r3, r0
 8003f16:	461a      	mov	r2, r3
 8003f18:	4621      	mov	r1, r4
 8003f1a:	482b      	ldr	r0, [pc, #172]	@ (8003fc8 <cliGpio+0x14c>)
 8003f1c:	f7ff f9b4 	bl	8003288 <cliPrintf>
			delay(300);
 8003f20:	f44f 7096 	mov.w	r0, #300	@ 0x12c
 8003f24:	f7fd fda9 	bl	8001a7a <delay>
		while(cliKeepLoop())
 8003f28:	f7ff faa8 	bl	800347c <cliKeepLoop>
 8003f2c:	4603      	mov	r3, r0
 8003f2e:	2b00      	cmp	r3, #0
 8003f30:	d1eb      	bne.n	8003f0a <cliGpio+0x8e>
		}

		ret = true;
 8003f32:	2301      	movs	r3, #1
 8003f34:	75fb      	strb	r3, [r7, #23]
	}

	if(args->argc == 3 && args->isStr(0, "write") == true)
 8003f36:	687b      	ldr	r3, [r7, #4]
 8003f38:	881b      	ldrh	r3, [r3, #0]
 8003f3a:	2b03      	cmp	r3, #3
 8003f3c:	d126      	bne.n	8003f8c <cliGpio+0x110>
 8003f3e:	687b      	ldr	r3, [r7, #4]
 8003f40:	695b      	ldr	r3, [r3, #20]
 8003f42:	4922      	ldr	r1, [pc, #136]	@ (8003fcc <cliGpio+0x150>)
 8003f44:	2000      	movs	r0, #0
 8003f46:	4798      	blx	r3
 8003f48:	4603      	mov	r3, r0
 8003f4a:	2b00      	cmp	r3, #0
 8003f4c:	d01e      	beq.n	8003f8c <cliGpio+0x110>
	{
		uint8_t ch;
		uint8_t data;

		ch = (uint8_t)args->getData(1);
 8003f4e:	687b      	ldr	r3, [r7, #4]
 8003f50:	689b      	ldr	r3, [r3, #8]
 8003f52:	2001      	movs	r0, #1
 8003f54:	4798      	blx	r3
 8003f56:	4603      	mov	r3, r0
 8003f58:	73bb      	strb	r3, [r7, #14]
		data = (uint8_t)args->getData(2);
 8003f5a:	687b      	ldr	r3, [r7, #4]
 8003f5c:	689b      	ldr	r3, [r3, #8]
 8003f5e:	2002      	movs	r0, #2
 8003f60:	4798      	blx	r3
 8003f62:	4603      	mov	r3, r0
 8003f64:	737b      	strb	r3, [r7, #13]

		gpioPinWrite(ch, data);
 8003f66:	7b7b      	ldrb	r3, [r7, #13]
 8003f68:	2b00      	cmp	r3, #0
 8003f6a:	bf14      	ite	ne
 8003f6c:	2301      	movne	r3, #1
 8003f6e:	2300      	moveq	r3, #0
 8003f70:	b2da      	uxtb	r2, r3
 8003f72:	7bbb      	ldrb	r3, [r7, #14]
 8003f74:	4611      	mov	r1, r2
 8003f76:	4618      	mov	r0, r3
 8003f78:	f7ff fef6 	bl	8003d68 <gpioPinWrite>

		cliPrintf("gpio write %d : %d\n", ch, data);
 8003f7c:	7bbb      	ldrb	r3, [r7, #14]
 8003f7e:	7b7a      	ldrb	r2, [r7, #13]
 8003f80:	4619      	mov	r1, r3
 8003f82:	4813      	ldr	r0, [pc, #76]	@ (8003fd0 <cliGpio+0x154>)
 8003f84:	f7ff f980 	bl	8003288 <cliPrintf>

		ret = true;
 8003f88:	2301      	movs	r3, #1
 8003f8a:	75fb      	strb	r3, [r7, #23]
	}

	if(ret != true)
 8003f8c:	7dfb      	ldrb	r3, [r7, #23]
 8003f8e:	f083 0301 	eor.w	r3, r3, #1
 8003f92:	b2db      	uxtb	r3, r3
 8003f94:	2b00      	cmp	r3, #0
 8003f96:	d00a      	beq.n	8003fae <cliGpio+0x132>
	{
		cliPrintf("gpio show\n");
 8003f98:	480e      	ldr	r0, [pc, #56]	@ (8003fd4 <cliGpio+0x158>)
 8003f9a:	f7ff f975 	bl	8003288 <cliPrintf>
		cliPrintf("gpio read ch[0~%d]\n", GPIO_MAX_CH-1);
 8003f9e:	2103      	movs	r1, #3
 8003fa0:	480d      	ldr	r0, [pc, #52]	@ (8003fd8 <cliGpio+0x15c>)
 8003fa2:	f7ff f971 	bl	8003288 <cliPrintf>
		cliPrintf("gpio write ch[0~%d]\n", GPIO_MAX_CH-1);
 8003fa6:	2103      	movs	r1, #3
 8003fa8:	480c      	ldr	r0, [pc, #48]	@ (8003fdc <cliGpio+0x160>)
 8003faa:	f7ff f96d 	bl	8003288 <cliPrintf>
	}
}
 8003fae:	bf00      	nop
 8003fb0:	371c      	adds	r7, #28
 8003fb2:	46bd      	mov	sp, r7
 8003fb4:	bd90      	pop	{r4, r7, pc}
 8003fb6:	bf00      	nop
 8003fb8:	0802436c 	.word	0x0802436c
 8003fbc:	08024374 	.word	0x08024374
 8003fc0:	08024378 	.word	0x08024378
 8003fc4:	0802437c 	.word	0x0802437c
 8003fc8:	08024384 	.word	0x08024384
 8003fcc:	08024398 	.word	0x08024398
 8003fd0:	080243a0 	.word	0x080243a0
 8003fd4:	080243b4 	.word	0x080243b4
 8003fd8:	080243c0 	.word	0x080243c0
 8003fdc:	080243d4 	.word	0x080243d4

08003fe0 <i2cInit>:

static void delayUs(uint32_t us);


bool i2cInit(void)
{
 8003fe0:	b580      	push	{r7, lr}
 8003fe2:	b082      	sub	sp, #8
 8003fe4:	af00      	add	r7, sp, #0
	uint32_t i;

	for(i=0; i<I2C_MAX_CH; i++)
 8003fe6:	2300      	movs	r3, #0
 8003fe8:	607b      	str	r3, [r7, #4]
 8003fea:	e011      	b.n	8004010 <i2cInit+0x30>
	{
		i2c_timeout[i] = 10;
 8003fec:	4a10      	ldr	r2, [pc, #64]	@ (8004030 <i2cInit+0x50>)
 8003fee:	687b      	ldr	r3, [r7, #4]
 8003ff0:	210a      	movs	r1, #10
 8003ff2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		i2c_errcount[i] = 0;
 8003ff6:	4a0f      	ldr	r2, [pc, #60]	@ (8004034 <i2cInit+0x54>)
 8003ff8:	687b      	ldr	r3, [r7, #4]
 8003ffa:	2100      	movs	r1, #0
 8003ffc:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		is_begin[i] = false;
 8004000:	4a0d      	ldr	r2, [pc, #52]	@ (8004038 <i2cInit+0x58>)
 8004002:	687b      	ldr	r3, [r7, #4]
 8004004:	4413      	add	r3, r2
 8004006:	2200      	movs	r2, #0
 8004008:	701a      	strb	r2, [r3, #0]
	for(i=0; i<I2C_MAX_CH; i++)
 800400a:	687b      	ldr	r3, [r7, #4]
 800400c:	3301      	adds	r3, #1
 800400e:	607b      	str	r3, [r7, #4]
 8004010:	687b      	ldr	r3, [r7, #4]
 8004012:	2b00      	cmp	r3, #0
 8004014:	d0ea      	beq.n	8003fec <i2cInit+0xc>
	}

#ifdef _USE_HW_CLI
	cliAdd("i2c", cliI2C);
 8004016:	4909      	ldr	r1, [pc, #36]	@ (800403c <i2cInit+0x5c>)
 8004018:	4809      	ldr	r0, [pc, #36]	@ (8004040 <i2cInit+0x60>)
 800401a:	f7ff fa45 	bl	80034a8 <cliAdd>
#endif

	is_init = true;
 800401e:	4b09      	ldr	r3, [pc, #36]	@ (8004044 <i2cInit+0x64>)
 8004020:	2201      	movs	r2, #1
 8004022:	701a      	strb	r2, [r3, #0]
	return true;
 8004024:	2301      	movs	r3, #1
}
 8004026:	4618      	mov	r0, r3
 8004028:	3708      	adds	r7, #8
 800402a:	46bd      	mov	sp, r7
 800402c:	bd80      	pop	{r7, pc}
 800402e:	bf00      	nop
 8004030:	20002354 	.word	0x20002354
 8004034:	20002358 	.word	0x20002358
 8004038:	20002364 	.word	0x20002364
 800403c:	08004555 	.word	0x08004555
 8004040:	080243ec 	.word	0x080243ec
 8004044:	20002360 	.word	0x20002360

08004048 <i2cBegin>:
{
	return is_init;
}

bool i2cBegin(uint8_t ch, uint32_t freq_khz)
{
 8004048:	b580      	push	{r7, lr}
 800404a:	b084      	sub	sp, #16
 800404c:	af00      	add	r7, sp, #0
 800404e:	4603      	mov	r3, r0
 8004050:	6039      	str	r1, [r7, #0]
 8004052:	71fb      	strb	r3, [r7, #7]
	bool ret = false;
 8004054:	2300      	movs	r3, #0
 8004056:	73fb      	strb	r3, [r7, #15]

	I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
 8004058:	79fa      	ldrb	r2, [r7, #7]
 800405a:	4929      	ldr	r1, [pc, #164]	@ (8004100 <i2cBegin+0xb8>)
 800405c:	4613      	mov	r3, r2
 800405e:	009b      	lsls	r3, r3, #2
 8004060:	4413      	add	r3, r2
 8004062:	009b      	lsls	r3, r3, #2
 8004064:	440b      	add	r3, r1
 8004066:	681b      	ldr	r3, [r3, #0]
 8004068:	60bb      	str	r3, [r7, #8]

	if(ch>=I2C_MAX_CH)
 800406a:	79fb      	ldrb	r3, [r7, #7]
 800406c:	2b00      	cmp	r3, #0
 800406e:	d001      	beq.n	8004074 <i2cBegin+0x2c>
	{
		return false;
 8004070:	2300      	movs	r3, #0
 8004072:	e041      	b.n	80040f8 <i2cBegin+0xb0>
	}

	switch(ch)
 8004074:	79fb      	ldrb	r3, [r7, #7]
 8004076:	2b00      	cmp	r3, #0
 8004078:	d13d      	bne.n	80040f6 <i2cBegin+0xae>
	{
		case _DEF_I2C1:
			i2c_freq[ch] = freq_khz;
 800407a:	79fb      	ldrb	r3, [r7, #7]
 800407c:	4921      	ldr	r1, [pc, #132]	@ (8004104 <i2cBegin+0xbc>)
 800407e:	683a      	ldr	r2, [r7, #0]
 8004080:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

			hi2c2.Instance = I2C2;
 8004084:	4b20      	ldr	r3, [pc, #128]	@ (8004108 <i2cBegin+0xc0>)
 8004086:	4a21      	ldr	r2, [pc, #132]	@ (800410c <i2cBegin+0xc4>)
 8004088:	601a      	str	r2, [r3, #0]
			hi2c2.Init.ClockSpeed = freq_khz * 1000;
 800408a:	683b      	ldr	r3, [r7, #0]
 800408c:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8004090:	fb02 f303 	mul.w	r3, r2, r3
 8004094:	4a1c      	ldr	r2, [pc, #112]	@ (8004108 <i2cBegin+0xc0>)
 8004096:	6053      	str	r3, [r2, #4]
			hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
 8004098:	4b1b      	ldr	r3, [pc, #108]	@ (8004108 <i2cBegin+0xc0>)
 800409a:	2200      	movs	r2, #0
 800409c:	609a      	str	r2, [r3, #8]
			hi2c2.Init.OwnAddress1 = 0;
 800409e:	4b1a      	ldr	r3, [pc, #104]	@ (8004108 <i2cBegin+0xc0>)
 80040a0:	2200      	movs	r2, #0
 80040a2:	60da      	str	r2, [r3, #12]
			hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 80040a4:	4b18      	ldr	r3, [pc, #96]	@ (8004108 <i2cBegin+0xc0>)
 80040a6:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 80040aa:	611a      	str	r2, [r3, #16]
			hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 80040ac:	4b16      	ldr	r3, [pc, #88]	@ (8004108 <i2cBegin+0xc0>)
 80040ae:	2200      	movs	r2, #0
 80040b0:	615a      	str	r2, [r3, #20]
			hi2c2.Init.OwnAddress2 = 0;
 80040b2:	4b15      	ldr	r3, [pc, #84]	@ (8004108 <i2cBegin+0xc0>)
 80040b4:	2200      	movs	r2, #0
 80040b6:	619a      	str	r2, [r3, #24]
			hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80040b8:	4b13      	ldr	r3, [pc, #76]	@ (8004108 <i2cBegin+0xc0>)
 80040ba:	2200      	movs	r2, #0
 80040bc:	61da      	str	r2, [r3, #28]
			hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 80040be:	4b12      	ldr	r3, [pc, #72]	@ (8004108 <i2cBegin+0xc0>)
 80040c0:	2200      	movs	r2, #0
 80040c2:	621a      	str	r2, [r3, #32]

			i2cReset(ch);
 80040c4:	79fb      	ldrb	r3, [r7, #7]
 80040c6:	4618      	mov	r0, r3
 80040c8:	f000 f824 	bl	8004114 <i2cReset>

			HAL_I2C_DeInit(p_handle);
 80040cc:	68b8      	ldr	r0, [r7, #8]
 80040ce:	f006 faa7 	bl	800a620 <HAL_I2C_DeInit>
			if(HAL_I2C_Init(p_handle) != HAL_OK)
 80040d2:	68b8      	ldr	r0, [r7, #8]
 80040d4:	f006 f960 	bl	800a398 <HAL_I2C_Init>
			{

			}

      /* Enable the Analog I2C Filter */
      HAL_I2CEx_ConfigAnalogFilter(p_handle,I2C_ANALOGFILTER_ENABLE);
 80040d8:	2100      	movs	r1, #0
 80040da:	68b8      	ldr	r0, [r7, #8]
 80040dc:	f008 ffbb 	bl	800d056 <HAL_I2CEx_ConfigAnalogFilter>

      /* Configure Digital filter */
      HAL_I2CEx_ConfigDigitalFilter(p_handle, 0);
 80040e0:	2100      	movs	r1, #0
 80040e2:	68b8      	ldr	r0, [r7, #8]
 80040e4:	f008 fff3 	bl	800d0ce <HAL_I2CEx_ConfigDigitalFilter>

      ret = true;
 80040e8:	2301      	movs	r3, #1
 80040ea:	73fb      	strb	r3, [r7, #15]
      is_begin[ch] = true;
 80040ec:	79fb      	ldrb	r3, [r7, #7]
 80040ee:	4a08      	ldr	r2, [pc, #32]	@ (8004110 <i2cBegin+0xc8>)
 80040f0:	2101      	movs	r1, #1
 80040f2:	54d1      	strb	r1, [r2, r3]
      break;
 80040f4:	bf00      	nop
	}

	return ret;
 80040f6:	7bfb      	ldrb	r3, [r7, #15]
}
 80040f8:	4618      	mov	r0, r3
 80040fa:	3710      	adds	r7, #16
 80040fc:	46bd      	mov	sp, r7
 80040fe:	bd80      	pop	{r7, pc}
 8004100:	20000070 	.word	0x20000070
 8004104:	2000235c 	.word	0x2000235c
 8004108:	20002368 	.word	0x20002368
 800410c:	40005800 	.word	0x40005800
 8004110:	20002364 	.word	0x20002364

08004114 <i2cReset>:
{
	return is_begin[ch];
}

void i2cReset(uint8_t ch)
{
 8004114:	b580      	push	{r7, lr}
 8004116:	b08a      	sub	sp, #40	@ 0x28
 8004118:	af00      	add	r7, sp, #0
 800411a:	4603      	mov	r3, r0
 800411c:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef  GPIO_InitStruct;
  i2c_tbl_t *p_pin = &i2c_tbl[ch];
 800411e:	79fa      	ldrb	r2, [r7, #7]
 8004120:	4613      	mov	r3, r2
 8004122:	009b      	lsls	r3, r3, #2
 8004124:	4413      	add	r3, r2
 8004126:	009b      	lsls	r3, r3, #2
 8004128:	4a44      	ldr	r2, [pc, #272]	@ (800423c <i2cReset+0x128>)
 800412a:	4413      	add	r3, r2
 800412c:	623b      	str	r3, [r7, #32]


  GPIO_InitStruct.Pin       = p_pin->scl_pin;
 800412e:	6a3b      	ldr	r3, [r7, #32]
 8004130:	689b      	ldr	r3, [r3, #8]
 8004132:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_OUTPUT_OD;
 8004134:	2311      	movs	r3, #17
 8004136:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 8004138:	2300      	movs	r3, #0
 800413a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
 800413c:	2303      	movs	r3, #3
 800413e:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(p_pin->scl_port, &GPIO_InitStruct);
 8004140:	6a3b      	ldr	r3, [r7, #32]
 8004142:	685b      	ldr	r3, [r3, #4]
 8004144:	f107 020c 	add.w	r2, r7, #12
 8004148:	4611      	mov	r1, r2
 800414a:	4618      	mov	r0, r3
 800414c:	f005 fe70 	bl	8009e30 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin       = p_pin->sda_pin;
 8004150:	6a3b      	ldr	r3, [r7, #32]
 8004152:	691b      	ldr	r3, [r3, #16]
 8004154:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode      = GPIO_MODE_OUTPUT_OD;
 8004156:	2311      	movs	r3, #17
 8004158:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 800415a:	2300      	movs	r3, #0
 800415c:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(p_pin->sda_port, &GPIO_InitStruct);
 800415e:	6a3b      	ldr	r3, [r7, #32]
 8004160:	68db      	ldr	r3, [r3, #12]
 8004162:	f107 020c 	add.w	r2, r7, #12
 8004166:	4611      	mov	r1, r2
 8004168:	4618      	mov	r0, r3
 800416a:	f005 fe61 	bl	8009e30 <HAL_GPIO_Init>
    HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
  }
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
  */

  HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET);
 800416e:	6a3b      	ldr	r3, [r7, #32]
 8004170:	6858      	ldr	r0, [r3, #4]
 8004172:	6a3b      	ldr	r3, [r7, #32]
 8004174:	689b      	ldr	r3, [r3, #8]
 8004176:	b29b      	uxth	r3, r3
 8004178:	2201      	movs	r2, #1
 800417a:	4619      	mov	r1, r3
 800417c:	f006 f8d8 	bl	800a330 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_SET);
 8004180:	6a3b      	ldr	r3, [r7, #32]
 8004182:	68d8      	ldr	r0, [r3, #12]
 8004184:	6a3b      	ldr	r3, [r7, #32]
 8004186:	691b      	ldr	r3, [r3, #16]
 8004188:	b29b      	uxth	r3, r3
 800418a:	2201      	movs	r2, #1
 800418c:	4619      	mov	r1, r3
 800418e:	f006 f8cf 	bl	800a330 <HAL_GPIO_WritePin>
  delayUs(5);
 8004192:	2005      	movs	r0, #5
 8004194:	f000 f92a 	bl	80043ec <delayUs>

  for (int i = 0; i < 9; i++)
 8004198:	2300      	movs	r3, #0
 800419a:	627b      	str	r3, [r7, #36]	@ 0x24
 800419c:	e01a      	b.n	80041d4 <i2cReset+0xc0>
  {

    HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_RESET);
 800419e:	6a3b      	ldr	r3, [r7, #32]
 80041a0:	6858      	ldr	r0, [r3, #4]
 80041a2:	6a3b      	ldr	r3, [r7, #32]
 80041a4:	689b      	ldr	r3, [r3, #8]
 80041a6:	b29b      	uxth	r3, r3
 80041a8:	2200      	movs	r2, #0
 80041aa:	4619      	mov	r1, r3
 80041ac:	f006 f8c0 	bl	800a330 <HAL_GPIO_WritePin>
    delayUs(5);
 80041b0:	2005      	movs	r0, #5
 80041b2:	f000 f91b 	bl	80043ec <delayUs>
    HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET);
 80041b6:	6a3b      	ldr	r3, [r7, #32]
 80041b8:	6858      	ldr	r0, [r3, #4]
 80041ba:	6a3b      	ldr	r3, [r7, #32]
 80041bc:	689b      	ldr	r3, [r3, #8]
 80041be:	b29b      	uxth	r3, r3
 80041c0:	2201      	movs	r2, #1
 80041c2:	4619      	mov	r1, r3
 80041c4:	f006 f8b4 	bl	800a330 <HAL_GPIO_WritePin>
    delayUs(5);
 80041c8:	2005      	movs	r0, #5
 80041ca:	f000 f90f 	bl	80043ec <delayUs>
  for (int i = 0; i < 9; i++)
 80041ce:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80041d0:	3301      	adds	r3, #1
 80041d2:	627b      	str	r3, [r7, #36]	@ 0x24
 80041d4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80041d6:	2b08      	cmp	r3, #8
 80041d8:	dde1      	ble.n	800419e <i2cReset+0x8a>
  }

  HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_RESET);
 80041da:	6a3b      	ldr	r3, [r7, #32]
 80041dc:	6858      	ldr	r0, [r3, #4]
 80041de:	6a3b      	ldr	r3, [r7, #32]
 80041e0:	689b      	ldr	r3, [r3, #8]
 80041e2:	b29b      	uxth	r3, r3
 80041e4:	2200      	movs	r2, #0
 80041e6:	4619      	mov	r1, r3
 80041e8:	f006 f8a2 	bl	800a330 <HAL_GPIO_WritePin>
  delayUs(5);
 80041ec:	2005      	movs	r0, #5
 80041ee:	f000 f8fd 	bl	80043ec <delayUs>
  HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_RESET);
 80041f2:	6a3b      	ldr	r3, [r7, #32]
 80041f4:	68d8      	ldr	r0, [r3, #12]
 80041f6:	6a3b      	ldr	r3, [r7, #32]
 80041f8:	691b      	ldr	r3, [r3, #16]
 80041fa:	b29b      	uxth	r3, r3
 80041fc:	2200      	movs	r2, #0
 80041fe:	4619      	mov	r1, r3
 8004200:	f006 f896 	bl	800a330 <HAL_GPIO_WritePin>
  delayUs(5);
 8004204:	2005      	movs	r0, #5
 8004206:	f000 f8f1 	bl	80043ec <delayUs>

  HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET);
 800420a:	6a3b      	ldr	r3, [r7, #32]
 800420c:	6858      	ldr	r0, [r3, #4]
 800420e:	6a3b      	ldr	r3, [r7, #32]
 8004210:	689b      	ldr	r3, [r3, #8]
 8004212:	b29b      	uxth	r3, r3
 8004214:	2201      	movs	r2, #1
 8004216:	4619      	mov	r1, r3
 8004218:	f006 f88a 	bl	800a330 <HAL_GPIO_WritePin>
  delayUs(5);
 800421c:	2005      	movs	r0, #5
 800421e:	f000 f8e5 	bl	80043ec <delayUs>
  HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_SET);
 8004222:	6a3b      	ldr	r3, [r7, #32]
 8004224:	68d8      	ldr	r0, [r3, #12]
 8004226:	6a3b      	ldr	r3, [r7, #32]
 8004228:	691b      	ldr	r3, [r3, #16]
 800422a:	b29b      	uxth	r3, r3
 800422c:	2201      	movs	r2, #1
 800422e:	4619      	mov	r1, r3
 8004230:	f006 f87e 	bl	800a330 <HAL_GPIO_WritePin>
}
 8004234:	bf00      	nop
 8004236:	3728      	adds	r7, #40	@ 0x28
 8004238:	46bd      	mov	sp, r7
 800423a:	bd80      	pop	{r7, pc}
 800423c:	20000070 	.word	0x20000070

08004240 <i2cIsDeviceReady>:

bool i2cIsDeviceReady(uint8_t ch, uint8_t dev_addr)
{
 8004240:	b580      	push	{r7, lr}
 8004242:	b084      	sub	sp, #16
 8004244:	af00      	add	r7, sp, #0
 8004246:	4603      	mov	r3, r0
 8004248:	460a      	mov	r2, r1
 800424a:	71fb      	strb	r3, [r7, #7]
 800424c:	4613      	mov	r3, r2
 800424e:	71bb      	strb	r3, [r7, #6]
	I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
 8004250:	79fa      	ldrb	r2, [r7, #7]
 8004252:	490e      	ldr	r1, [pc, #56]	@ (800428c <i2cIsDeviceReady+0x4c>)
 8004254:	4613      	mov	r3, r2
 8004256:	009b      	lsls	r3, r3, #2
 8004258:	4413      	add	r3, r2
 800425a:	009b      	lsls	r3, r3, #2
 800425c:	440b      	add	r3, r1
 800425e:	681b      	ldr	r3, [r3, #0]
 8004260:	60fb      	str	r3, [r7, #12]

	if(HAL_I2C_IsDeviceReady(p_handle, dev_addr << 1, 10, 10) == HAL_OK)
 8004262:	79bb      	ldrb	r3, [r7, #6]
 8004264:	b29b      	uxth	r3, r3
 8004266:	005b      	lsls	r3, r3, #1
 8004268:	b299      	uxth	r1, r3
 800426a:	230a      	movs	r3, #10
 800426c:	220a      	movs	r2, #10
 800426e:	68f8      	ldr	r0, [r7, #12]
 8004270:	f006 fd46 	bl	800ad00 <HAL_I2C_IsDeviceReady>
 8004274:	4603      	mov	r3, r0
 8004276:	2b00      	cmp	r3, #0
 8004278:	d103      	bne.n	8004282 <i2cIsDeviceReady+0x42>
  __ASM volatile ("cpsie i" : : : "memory");
 800427a:	b662      	cpsie	i
}
 800427c:	bf00      	nop
	{
		__enable_irq();
		return true;
 800427e:	2301      	movs	r3, #1
 8004280:	e000      	b.n	8004284 <i2cIsDeviceReady+0x44>
	}

	return false;
 8004282:	2300      	movs	r3, #0
}
 8004284:	4618      	mov	r0, r3
 8004286:	3710      	adds	r7, #16
 8004288:	46bd      	mov	sp, r7
 800428a:	bd80      	pop	{r7, pc}
 800428c:	20000070 	.word	0x20000070

08004290 <i2cReadByte>:

	return ret;
}

bool i2cReadByte(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t timeout)
{
 8004290:	b580      	push	{r7, lr}
 8004292:	b086      	sub	sp, #24
 8004294:	af02      	add	r7, sp, #8
 8004296:	607b      	str	r3, [r7, #4]
 8004298:	4603      	mov	r3, r0
 800429a:	73fb      	strb	r3, [r7, #15]
 800429c:	460b      	mov	r3, r1
 800429e:	81bb      	strh	r3, [r7, #12]
 80042a0:	4613      	mov	r3, r2
 80042a2:	817b      	strh	r3, [r7, #10]
	return i2cReadBytes(ch, dev_addr, reg_addr, p_data, 1, timeout);
 80042a4:	897a      	ldrh	r2, [r7, #10]
 80042a6:	89b9      	ldrh	r1, [r7, #12]
 80042a8:	7bf8      	ldrb	r0, [r7, #15]
 80042aa:	69bb      	ldr	r3, [r7, #24]
 80042ac:	9301      	str	r3, [sp, #4]
 80042ae:	2301      	movs	r3, #1
 80042b0:	9300      	str	r3, [sp, #0]
 80042b2:	687b      	ldr	r3, [r7, #4]
 80042b4:	f000 f806 	bl	80042c4 <i2cReadBytes>
 80042b8:	4603      	mov	r3, r0
}
 80042ba:	4618      	mov	r0, r3
 80042bc:	3710      	adds	r7, #16
 80042be:	46bd      	mov	sp, r7
 80042c0:	bd80      	pop	{r7, pc}
	...

080042c4 <i2cReadBytes>:

bool i2cReadBytes(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)
{
 80042c4:	b580      	push	{r7, lr}
 80042c6:	b08c      	sub	sp, #48	@ 0x30
 80042c8:	af04      	add	r7, sp, #16
 80042ca:	607b      	str	r3, [r7, #4]
 80042cc:	4603      	mov	r3, r0
 80042ce:	73fb      	strb	r3, [r7, #15]
 80042d0:	460b      	mov	r3, r1
 80042d2:	81bb      	strh	r3, [r7, #12]
 80042d4:	4613      	mov	r3, r2
 80042d6:	817b      	strh	r3, [r7, #10]
	bool ret;
	HAL_StatusTypeDef i2c_ret;
	I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
 80042d8:	7bfa      	ldrb	r2, [r7, #15]
 80042da:	4916      	ldr	r1, [pc, #88]	@ (8004334 <i2cReadBytes+0x70>)
 80042dc:	4613      	mov	r3, r2
 80042de:	009b      	lsls	r3, r3, #2
 80042e0:	4413      	add	r3, r2
 80042e2:	009b      	lsls	r3, r3, #2
 80042e4:	440b      	add	r3, r1
 80042e6:	681b      	ldr	r3, [r3, #0]
 80042e8:	61bb      	str	r3, [r7, #24]

	if(ch>=I2C_MAX_CH)
 80042ea:	7bfb      	ldrb	r3, [r7, #15]
 80042ec:	2b00      	cmp	r3, #0
 80042ee:	d001      	beq.n	80042f4 <i2cReadBytes+0x30>
	{
		return false;
 80042f0:	2300      	movs	r3, #0
 80042f2:	e01a      	b.n	800432a <i2cReadBytes+0x66>
	}

	i2c_ret = HAL_I2C_Mem_Read(p_handle, (uint16_t)(dev_addr << 1), reg_addr, I2C_MEMADD_SIZE_8BIT, p_data, length, timeout);
 80042f4:	89bb      	ldrh	r3, [r7, #12]
 80042f6:	005b      	lsls	r3, r3, #1
 80042f8:	b299      	uxth	r1, r3
 80042fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80042fc:	b29b      	uxth	r3, r3
 80042fe:	8978      	ldrh	r0, [r7, #10]
 8004300:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8004302:	9202      	str	r2, [sp, #8]
 8004304:	9301      	str	r3, [sp, #4]
 8004306:	687b      	ldr	r3, [r7, #4]
 8004308:	9300      	str	r3, [sp, #0]
 800430a:	2301      	movs	r3, #1
 800430c:	4602      	mov	r2, r0
 800430e:	69b8      	ldr	r0, [r7, #24]
 8004310:	f006 fac4 	bl	800a89c <HAL_I2C_Mem_Read>
 8004314:	4603      	mov	r3, r0
 8004316:	75fb      	strb	r3, [r7, #23]

	if(i2c_ret == HAL_OK)
 8004318:	7dfb      	ldrb	r3, [r7, #23]
 800431a:	2b00      	cmp	r3, #0
 800431c:	d102      	bne.n	8004324 <i2cReadBytes+0x60>
	{
		ret = true;
 800431e:	2301      	movs	r3, #1
 8004320:	77fb      	strb	r3, [r7, #31]
 8004322:	e001      	b.n	8004328 <i2cReadBytes+0x64>
	}
	else
	{
		ret = false;
 8004324:	2300      	movs	r3, #0
 8004326:	77fb      	strb	r3, [r7, #31]
	}

	return ret;
 8004328:	7ffb      	ldrb	r3, [r7, #31]
}
 800432a:	4618      	mov	r0, r3
 800432c:	3720      	adds	r7, #32
 800432e:	46bd      	mov	sp, r7
 8004330:	bd80      	pop	{r7, pc}
 8004332:	bf00      	nop
 8004334:	20000070 	.word	0x20000070

08004338 <i2cWriteByte>:

	return ret;
}

bool i2cWriteByte(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t data, uint32_t timeout)
{
 8004338:	b590      	push	{r4, r7, lr}
 800433a:	b085      	sub	sp, #20
 800433c:	af02      	add	r7, sp, #8
 800433e:	4604      	mov	r4, r0
 8004340:	4608      	mov	r0, r1
 8004342:	4611      	mov	r1, r2
 8004344:	461a      	mov	r2, r3
 8004346:	4623      	mov	r3, r4
 8004348:	71fb      	strb	r3, [r7, #7]
 800434a:	4603      	mov	r3, r0
 800434c:	80bb      	strh	r3, [r7, #4]
 800434e:	460b      	mov	r3, r1
 8004350:	807b      	strh	r3, [r7, #2]
 8004352:	4613      	mov	r3, r2
 8004354:	71bb      	strb	r3, [r7, #6]
	return i2cWriteBytes(ch, dev_addr, reg_addr, &data, 1, timeout);
 8004356:	1dbc      	adds	r4, r7, #6
 8004358:	887a      	ldrh	r2, [r7, #2]
 800435a:	88b9      	ldrh	r1, [r7, #4]
 800435c:	79f8      	ldrb	r0, [r7, #7]
 800435e:	69bb      	ldr	r3, [r7, #24]
 8004360:	9301      	str	r3, [sp, #4]
 8004362:	2301      	movs	r3, #1
 8004364:	9300      	str	r3, [sp, #0]
 8004366:	4623      	mov	r3, r4
 8004368:	f000 f806 	bl	8004378 <i2cWriteBytes>
 800436c:	4603      	mov	r3, r0
}
 800436e:	4618      	mov	r0, r3
 8004370:	370c      	adds	r7, #12
 8004372:	46bd      	mov	sp, r7
 8004374:	bd90      	pop	{r4, r7, pc}
	...

08004378 <i2cWriteBytes>:

bool i2cWriteBytes(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)
{
 8004378:	b580      	push	{r7, lr}
 800437a:	b08c      	sub	sp, #48	@ 0x30
 800437c:	af04      	add	r7, sp, #16
 800437e:	607b      	str	r3, [r7, #4]
 8004380:	4603      	mov	r3, r0
 8004382:	73fb      	strb	r3, [r7, #15]
 8004384:	460b      	mov	r3, r1
 8004386:	81bb      	strh	r3, [r7, #12]
 8004388:	4613      	mov	r3, r2
 800438a:	817b      	strh	r3, [r7, #10]
	bool ret;
	HAL_StatusTypeDef i2c_ret;
	I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
 800438c:	7bfa      	ldrb	r2, [r7, #15]
 800438e:	4916      	ldr	r1, [pc, #88]	@ (80043e8 <i2cWriteBytes+0x70>)
 8004390:	4613      	mov	r3, r2
 8004392:	009b      	lsls	r3, r3, #2
 8004394:	4413      	add	r3, r2
 8004396:	009b      	lsls	r3, r3, #2
 8004398:	440b      	add	r3, r1
 800439a:	681b      	ldr	r3, [r3, #0]
 800439c:	61bb      	str	r3, [r7, #24]

	if(ch>=I2C_MAX_CH)
 800439e:	7bfb      	ldrb	r3, [r7, #15]
 80043a0:	2b00      	cmp	r3, #0
 80043a2:	d001      	beq.n	80043a8 <i2cWriteBytes+0x30>
	{
		return false;
 80043a4:	2300      	movs	r3, #0
 80043a6:	e01a      	b.n	80043de <i2cWriteBytes+0x66>
	}

	i2c_ret = HAL_I2C_Mem_Write(p_handle, (uint16_t)(dev_addr << 1), reg_addr, I2C_MEMADD_SIZE_8BIT, p_data, length, timeout);
 80043a8:	89bb      	ldrh	r3, [r7, #12]
 80043aa:	005b      	lsls	r3, r3, #1
 80043ac:	b299      	uxth	r1, r3
 80043ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80043b0:	b29b      	uxth	r3, r3
 80043b2:	8978      	ldrh	r0, [r7, #10]
 80043b4:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 80043b6:	9202      	str	r2, [sp, #8]
 80043b8:	9301      	str	r3, [sp, #4]
 80043ba:	687b      	ldr	r3, [r7, #4]
 80043bc:	9300      	str	r3, [sp, #0]
 80043be:	2301      	movs	r3, #1
 80043c0:	4602      	mov	r2, r0
 80043c2:	69b8      	ldr	r0, [r7, #24]
 80043c4:	f006 f970 	bl	800a6a8 <HAL_I2C_Mem_Write>
 80043c8:	4603      	mov	r3, r0
 80043ca:	75fb      	strb	r3, [r7, #23]

	if(i2c_ret == HAL_OK)
 80043cc:	7dfb      	ldrb	r3, [r7, #23]
 80043ce:	2b00      	cmp	r3, #0
 80043d0:	d102      	bne.n	80043d8 <i2cWriteBytes+0x60>
	{
		ret = true;
 80043d2:	2301      	movs	r3, #1
 80043d4:	77fb      	strb	r3, [r7, #31]
 80043d6:	e001      	b.n	80043dc <i2cWriteBytes+0x64>
	}
	else
	{
		ret = false;
 80043d8:	2300      	movs	r3, #0
 80043da:	77fb      	strb	r3, [r7, #31]
	}

	return ret;
 80043dc:	7ffb      	ldrb	r3, [r7, #31]
}
 80043de:	4618      	mov	r0, r3
 80043e0:	3720      	adds	r7, #32
 80043e2:	46bd      	mov	sp, r7
 80043e4:	bd80      	pop	{r7, pc}
 80043e6:	bf00      	nop
 80043e8:	20000070 	.word	0x20000070

080043ec <delayUs>:
{
	return i2c_errcount[ch];
}

void delayUs(uint32_t us)
{
 80043ec:	b480      	push	{r7}
 80043ee:	b085      	sub	sp, #20
 80043f0:	af00      	add	r7, sp, #0
 80043f2:	6078      	str	r0, [r7, #4]
	volatile uint32_t i;

	for(i=0; i<us*1000; i++)
 80043f4:	2300      	movs	r3, #0
 80043f6:	60fb      	str	r3, [r7, #12]
 80043f8:	e002      	b.n	8004400 <delayUs+0x14>
 80043fa:	68fb      	ldr	r3, [r7, #12]
 80043fc:	3301      	adds	r3, #1
 80043fe:	60fb      	str	r3, [r7, #12]
 8004400:	687b      	ldr	r3, [r7, #4]
 8004402:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8004406:	fb03 f202 	mul.w	r2, r3, r2
 800440a:	68fb      	ldr	r3, [r7, #12]
 800440c:	429a      	cmp	r2, r3
 800440e:	d8f4      	bhi.n	80043fa <delayUs+0xe>
	{

	}
}
 8004410:	bf00      	nop
 8004412:	bf00      	nop
 8004414:	3714      	adds	r7, #20
 8004416:	46bd      	mov	sp, r7
 8004418:	f85d 7b04 	ldr.w	r7, [sp], #4
 800441c:	4770      	bx	lr

0800441e <HAL_I2C_ErrorCallback>:

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
 800441e:	b480      	push	{r7}
 8004420:	b083      	sub	sp, #12
 8004422:	af00      	add	r7, sp, #0
 8004424:	6078      	str	r0, [r7, #4]
	UNUSED(hi2c);
}
 8004426:	bf00      	nop
 8004428:	370c      	adds	r7, #12
 800442a:	46bd      	mov	sp, r7
 800442c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004430:	4770      	bx	lr
	...

08004434 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8004434:	b580      	push	{r7, lr}
 8004436:	b08a      	sub	sp, #40	@ 0x28
 8004438:	af00      	add	r7, sp, #0
 800443a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800443c:	f107 0314 	add.w	r3, r7, #20
 8004440:	2200      	movs	r2, #0
 8004442:	601a      	str	r2, [r3, #0]
 8004444:	605a      	str	r2, [r3, #4]
 8004446:	609a      	str	r2, [r3, #8]
 8004448:	60da      	str	r2, [r3, #12]
 800444a:	611a      	str	r2, [r3, #16]
  if(i2cHandle->Instance==I2C2)
 800444c:	687b      	ldr	r3, [r7, #4]
 800444e:	681b      	ldr	r3, [r3, #0]
 8004450:	4a29      	ldr	r2, [pc, #164]	@ (80044f8 <HAL_I2C_MspInit+0xc4>)
 8004452:	4293      	cmp	r3, r2
 8004454:	d14c      	bne.n	80044f0 <HAL_I2C_MspInit+0xbc>
  {
  /* USER CODE BEGIN I2C2_MspInit 0 */

  /* USER CODE END I2C2_MspInit 0 */

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004456:	2300      	movs	r3, #0
 8004458:	613b      	str	r3, [r7, #16]
 800445a:	4b28      	ldr	r3, [pc, #160]	@ (80044fc <HAL_I2C_MspInit+0xc8>)
 800445c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800445e:	4a27      	ldr	r2, [pc, #156]	@ (80044fc <HAL_I2C_MspInit+0xc8>)
 8004460:	f043 0302 	orr.w	r3, r3, #2
 8004464:	6313      	str	r3, [r2, #48]	@ 0x30
 8004466:	4b25      	ldr	r3, [pc, #148]	@ (80044fc <HAL_I2C_MspInit+0xc8>)
 8004468:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800446a:	f003 0302 	and.w	r3, r3, #2
 800446e:	613b      	str	r3, [r7, #16]
 8004470:	693b      	ldr	r3, [r7, #16]
    /**I2C2 GPIO Configuration
    PB10     ------> I2C2_SCL
    PB3     ------> I2C2_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10;
 8004472:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8004476:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8004478:	2312      	movs	r3, #18
 800447a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800447c:	2300      	movs	r3, #0
 800447e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8004480:	2303      	movs	r3, #3
 8004482:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8004484:	2304      	movs	r3, #4
 8004486:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004488:	f107 0314 	add.w	r3, r7, #20
 800448c:	4619      	mov	r1, r3
 800448e:	481c      	ldr	r0, [pc, #112]	@ (8004500 <HAL_I2C_MspInit+0xcc>)
 8004490:	f005 fcce 	bl	8009e30 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8004494:	2308      	movs	r3, #8
 8004496:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8004498:	2312      	movs	r3, #18
 800449a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800449c:	2300      	movs	r3, #0
 800449e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80044a0:	2303      	movs	r3, #3
 80044a2:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF9_I2C2;
 80044a4:	2309      	movs	r3, #9
 80044a6:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80044a8:	f107 0314 	add.w	r3, r7, #20
 80044ac:	4619      	mov	r1, r3
 80044ae:	4814      	ldr	r0, [pc, #80]	@ (8004500 <HAL_I2C_MspInit+0xcc>)
 80044b0:	f005 fcbe 	bl	8009e30 <HAL_GPIO_Init>

    /* I2C2 clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();
 80044b4:	2300      	movs	r3, #0
 80044b6:	60fb      	str	r3, [r7, #12]
 80044b8:	4b10      	ldr	r3, [pc, #64]	@ (80044fc <HAL_I2C_MspInit+0xc8>)
 80044ba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80044bc:	4a0f      	ldr	r2, [pc, #60]	@ (80044fc <HAL_I2C_MspInit+0xc8>)
 80044be:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 80044c2:	6413      	str	r3, [r2, #64]	@ 0x40
 80044c4:	4b0d      	ldr	r3, [pc, #52]	@ (80044fc <HAL_I2C_MspInit+0xc8>)
 80044c6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80044c8:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80044cc:	60fb      	str	r3, [r7, #12]
 80044ce:	68fb      	ldr	r3, [r7, #12]

    /* I2C2 interrupt Init */
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 0, 0);
 80044d0:	2200      	movs	r2, #0
 80044d2:	2100      	movs	r1, #0
 80044d4:	2021      	movs	r0, #33	@ 0x21
 80044d6:	f004 fd04 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
 80044da:	2021      	movs	r0, #33	@ 0x21
 80044dc:	f004 fd1d 	bl	8008f1a <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C2_ER_IRQn, 0, 0);
 80044e0:	2200      	movs	r2, #0
 80044e2:	2100      	movs	r1, #0
 80044e4:	2022      	movs	r0, #34	@ 0x22
 80044e6:	f004 fcfc 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C2_ER_IRQn);
 80044ea:	2022      	movs	r0, #34	@ 0x22
 80044ec:	f004 fd15 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
 80044f0:	bf00      	nop
 80044f2:	3728      	adds	r7, #40	@ 0x28
 80044f4:	46bd      	mov	sp, r7
 80044f6:	bd80      	pop	{r7, pc}
 80044f8:	40005800 	.word	0x40005800
 80044fc:	40023800 	.word	0x40023800
 8004500:	40020400 	.word	0x40020400

08004504 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
 8004504:	b580      	push	{r7, lr}
 8004506:	b082      	sub	sp, #8
 8004508:	af00      	add	r7, sp, #0
 800450a:	6078      	str	r0, [r7, #4]

  if(i2cHandle->Instance==I2C2)
 800450c:	687b      	ldr	r3, [r7, #4]
 800450e:	681b      	ldr	r3, [r3, #0]
 8004510:	4a0d      	ldr	r2, [pc, #52]	@ (8004548 <HAL_I2C_MspDeInit+0x44>)
 8004512:	4293      	cmp	r3, r2
 8004514:	d114      	bne.n	8004540 <HAL_I2C_MspDeInit+0x3c>
  {
  /* USER CODE BEGIN I2C2_MspDeInit 0 */

  /* USER CODE END I2C2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C2_CLK_DISABLE();
 8004516:	4b0d      	ldr	r3, [pc, #52]	@ (800454c <HAL_I2C_MspDeInit+0x48>)
 8004518:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800451a:	4a0c      	ldr	r2, [pc, #48]	@ (800454c <HAL_I2C_MspDeInit+0x48>)
 800451c:	f423 0380 	bic.w	r3, r3, #4194304	@ 0x400000
 8004520:	6413      	str	r3, [r2, #64]	@ 0x40

    /**I2C2 GPIO Configuration
    PB10     ------> I2C2_SCL
    PB3     ------> I2C2_SDA
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10);
 8004522:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8004526:	480a      	ldr	r0, [pc, #40]	@ (8004550 <HAL_I2C_MspDeInit+0x4c>)
 8004528:	f005 fe06 	bl	800a138 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_3);
 800452c:	2108      	movs	r1, #8
 800452e:	4808      	ldr	r0, [pc, #32]	@ (8004550 <HAL_I2C_MspDeInit+0x4c>)
 8004530:	f005 fe02 	bl	800a138 <HAL_GPIO_DeInit>

    /* I2C2 interrupt Deinit */
    HAL_NVIC_DisableIRQ(I2C2_EV_IRQn);
 8004534:	2021      	movs	r0, #33	@ 0x21
 8004536:	f004 fcfe 	bl	8008f36 <HAL_NVIC_DisableIRQ>
    HAL_NVIC_DisableIRQ(I2C2_ER_IRQn);
 800453a:	2022      	movs	r0, #34	@ 0x22
 800453c:	f004 fcfb 	bl	8008f36 <HAL_NVIC_DisableIRQ>
  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }
}
 8004540:	bf00      	nop
 8004542:	3708      	adds	r7, #8
 8004544:	46bd      	mov	sp, r7
 8004546:	bd80      	pop	{r7, pc}
 8004548:	40005800 	.word	0x40005800
 800454c:	40023800 	.word	0x40023800
 8004550:	40020400 	.word	0x40020400

08004554 <cliI2C>:

#ifdef _USE_HW_CLI
void cliI2C(cli_args_t *args)
{
 8004554:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004556:	b0ad      	sub	sp, #180	@ 0xb4
 8004558:	af02      	add	r7, sp, #8
 800455a:	6078      	str	r0, [r7, #4]
	bool ret = true;
 800455c:	2301      	movs	r3, #1
 800455e:	f887 30a7 	strb.w	r3, [r7, #167]	@ 0xa7

	uint32_t i;
	uint8_t i2c_data[128];
	uint32_t pre_time;

	if(args->argc == 2)
 8004562:	687b      	ldr	r3, [r7, #4]
 8004564:	881b      	ldrh	r3, [r3, #0]
 8004566:	2b02      	cmp	r3, #2
 8004568:	d16b      	bne.n	8004642 <cliI2C+0xee>
	{
		print_ch = (uint16_t)args->getData(1);
 800456a:	687b      	ldr	r3, [r7, #4]
 800456c:	689b      	ldr	r3, [r3, #8]
 800456e:	2001      	movs	r0, #1
 8004570:	4798      	blx	r3
 8004572:	4603      	mov	r3, r0
 8004574:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
		print_ch = constrain(print_ch, 1, I2C_MAX_CH);
 8004578:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 800457c:	2b00      	cmp	r3, #0
 800457e:	d006      	beq.n	800458e <cliI2C+0x3a>
 8004580:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8004584:	2b01      	cmp	r3, #1
 8004586:	bf28      	it	cs
 8004588:	2301      	movcs	r3, #1
 800458a:	b2db      	uxtb	r3, r3
 800458c:	e000      	b.n	8004590 <cliI2C+0x3c>
 800458e:	2301      	movs	r3, #1
 8004590:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
		print_ch -= 1;
 8004594:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8004598:	3b01      	subs	r3, #1
 800459a:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f

		if(args->isStr(0, "scan") == true)
 800459e:	687b      	ldr	r3, [r7, #4]
 80045a0:	695b      	ldr	r3, [r3, #20]
 80045a2:	4991      	ldr	r1, [pc, #580]	@ (80047e8 <cliI2C+0x294>)
 80045a4:	2000      	movs	r0, #0
 80045a6:	4798      	blx	r3
 80045a8:	4603      	mov	r3, r0
 80045aa:	2b00      	cmp	r3, #0
 80045ac:	d022      	beq.n	80045f4 <cliI2C+0xa0>
		{
			for(i=0x00; i<= 0x7F; i++)
 80045ae:	2300      	movs	r3, #0
 80045b0:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 80045b4:	e019      	b.n	80045ea <cliI2C+0x96>
			{
				if(i2cIsDeviceReady(print_ch, i) == true)
 80045b6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80045ba:	b2da      	uxtb	r2, r3
 80045bc:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80045c0:	4611      	mov	r1, r2
 80045c2:	4618      	mov	r0, r3
 80045c4:	f7ff fe3c 	bl	8004240 <i2cIsDeviceReady>
 80045c8:	4603      	mov	r3, r0
 80045ca:	2b00      	cmp	r3, #0
 80045cc:	d008      	beq.n	80045e0 <cliI2C+0x8c>
				{
					cliPrintf("I2C CH%d Addr 0x%X : OK\n", print_ch+1, i);
 80045ce:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80045d2:	3301      	adds	r3, #1
 80045d4:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 80045d8:	4619      	mov	r1, r3
 80045da:	4884      	ldr	r0, [pc, #528]	@ (80047ec <cliI2C+0x298>)
 80045dc:	f7fe fe54 	bl	8003288 <cliPrintf>
			for(i=0x00; i<= 0x7F; i++)
 80045e0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80045e4:	3301      	adds	r3, #1
 80045e6:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 80045ea:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80045ee:	2b7f      	cmp	r3, #127	@ 0x7f
 80045f0:	d9e1      	bls.n	80045b6 <cliI2C+0x62>
 80045f2:	e0df      	b.n	80047b4 <cliI2C+0x260>
				}
			}
		}
		else if(args->isStr(0, "begin") == true)
 80045f4:	687b      	ldr	r3, [r7, #4]
 80045f6:	695b      	ldr	r3, [r3, #20]
 80045f8:	497d      	ldr	r1, [pc, #500]	@ (80047f0 <cliI2C+0x29c>)
 80045fa:	2000      	movs	r0, #0
 80045fc:	4798      	blx	r3
 80045fe:	4603      	mov	r3, r0
 8004600:	2b00      	cmp	r3, #0
 8004602:	f000 80d7 	beq.w	80047b4 <cliI2C+0x260>
		{
			i2c_ret = i2cBegin(print_ch, 400);
 8004606:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 800460a:	f44f 71c8 	mov.w	r1, #400	@ 0x190
 800460e:	4618      	mov	r0, r3
 8004610:	f7ff fd1a 	bl	8004048 <i2cBegin>
 8004614:	4603      	mov	r3, r0
 8004616:	f887 308f 	strb.w	r3, [r7, #143]	@ 0x8f
			if(i2c_ret == true)
 800461a:	f897 308f 	ldrb.w	r3, [r7, #143]	@ 0x8f
 800461e:	2b00      	cmp	r3, #0
 8004620:	d007      	beq.n	8004632 <cliI2C+0xde>
			{
				cliPrintf("I2C CH%d Begin OK\n", print_ch + 1);
 8004622:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8004626:	3301      	adds	r3, #1
 8004628:	4619      	mov	r1, r3
 800462a:	4872      	ldr	r0, [pc, #456]	@ (80047f4 <cliI2C+0x2a0>)
 800462c:	f7fe fe2c 	bl	8003288 <cliPrintf>
 8004630:	e0c0      	b.n	80047b4 <cliI2C+0x260>
			}
			else
			{
				cliPrintf("I2C CH%d Begin Fail\n", print_ch + 1);
 8004632:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8004636:	3301      	adds	r3, #1
 8004638:	4619      	mov	r1, r3
 800463a:	486f      	ldr	r0, [pc, #444]	@ (80047f8 <cliI2C+0x2a4>)
 800463c:	f7fe fe24 	bl	8003288 <cliPrintf>
 8004640:	e0b8      	b.n	80047b4 <cliI2C+0x260>
			}
		}
	}
	else if(args->argc == 5)
 8004642:	687b      	ldr	r3, [r7, #4]
 8004644:	881b      	ldrh	r3, [r3, #0]
 8004646:	2b05      	cmp	r3, #5
 8004648:	f040 80b1 	bne.w	80047ae <cliI2C+0x25a>
	{
		print_ch = (uint16_t)args->getData(1);
 800464c:	687b      	ldr	r3, [r7, #4]
 800464e:	689b      	ldr	r3, [r3, #8]
 8004650:	2001      	movs	r0, #1
 8004652:	4798      	blx	r3
 8004654:	4603      	mov	r3, r0
 8004656:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
		print_ch = constrain(print_ch, 1, I2C_MAX_CH);
 800465a:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 800465e:	2b00      	cmp	r3, #0
 8004660:	d006      	beq.n	8004670 <cliI2C+0x11c>
 8004662:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 8004666:	2b01      	cmp	r3, #1
 8004668:	bf28      	it	cs
 800466a:	2301      	movcs	r3, #1
 800466c:	b2db      	uxtb	r3, r3
 800466e:	e000      	b.n	8004672 <cliI2C+0x11e>
 8004670:	2301      	movs	r3, #1
 8004672:	f887 309f 	strb.w	r3, [r7, #159]	@ 0x9f
		dev_addr = (uint16_t)args->getData(2);
 8004676:	687b      	ldr	r3, [r7, #4]
 8004678:	689b      	ldr	r3, [r3, #8]
 800467a:	2002      	movs	r0, #2
 800467c:	4798      	blx	r3
 800467e:	4603      	mov	r3, r0
 8004680:	f8a7 309c 	strh.w	r3, [r7, #156]	@ 0x9c
		reg_addr = (uint16_t)args->getData(3);
 8004684:	687b      	ldr	r3, [r7, #4]
 8004686:	689b      	ldr	r3, [r3, #8]
 8004688:	2003      	movs	r0, #3
 800468a:	4798      	blx	r3
 800468c:	4603      	mov	r3, r0
 800468e:	f8a7 309a 	strh.w	r3, [r7, #154]	@ 0x9a
		length = (uint16_t)args->getData(4);
 8004692:	687b      	ldr	r3, [r7, #4]
 8004694:	689b      	ldr	r3, [r3, #8]
 8004696:	2004      	movs	r0, #4
 8004698:	4798      	blx	r3
 800469a:	4603      	mov	r3, r0
 800469c:	f8a7 3098 	strh.w	r3, [r7, #152]	@ 0x98
		ch = print_ch - 1;
 80046a0:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 80046a4:	3b01      	subs	r3, #1
 80046a6:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97

		if(args->isStr(0, "read") == true)
 80046aa:	687b      	ldr	r3, [r7, #4]
 80046ac:	695b      	ldr	r3, [r3, #20]
 80046ae:	4953      	ldr	r1, [pc, #332]	@ (80047fc <cliI2C+0x2a8>)
 80046b0:	2000      	movs	r0, #0
 80046b2:	4798      	blx	r3
 80046b4:	4603      	mov	r3, r0
 80046b6:	2b00      	cmp	r3, #0
 80046b8:	d03a      	beq.n	8004730 <cliI2C+0x1dc>
		{
			for(i=0; i<length; i++)
 80046ba:	2300      	movs	r3, #0
 80046bc:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 80046c0:	e02f      	b.n	8004722 <cliI2C+0x1ce>
			{
				i2c_ret = i2cReadByte(ch, dev_addr, reg_addr + i, i2c_data, 100);
 80046c2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80046c6:	b29a      	uxth	r2, r3
 80046c8:	f8b7 309a 	ldrh.w	r3, [r7, #154]	@ 0x9a
 80046cc:	4413      	add	r3, r2
 80046ce:	b29a      	uxth	r2, r3
 80046d0:	f107 030c 	add.w	r3, r7, #12
 80046d4:	f8b7 109c 	ldrh.w	r1, [r7, #156]	@ 0x9c
 80046d8:	f897 0097 	ldrb.w	r0, [r7, #151]	@ 0x97
 80046dc:	2464      	movs	r4, #100	@ 0x64
 80046de:	9400      	str	r4, [sp, #0]
 80046e0:	f7ff fdd6 	bl	8004290 <i2cReadByte>
 80046e4:	4603      	mov	r3, r0
 80046e6:	f887 308f 	strb.w	r3, [r7, #143]	@ 0x8f

				if(i2c_ret == true)
 80046ea:	f897 308f 	ldrb.w	r3, [r7, #143]	@ 0x8f
 80046ee:	2b00      	cmp	r3, #0
 80046f0:	d00b      	beq.n	800470a <cliI2C+0x1b6>
				{
          cliPrintf("%d I2C - 0x%02X : 0x%02X\n", print_ch, reg_addr+i, i2c_data[0]);
 80046f2:	f897 109f 	ldrb.w	r1, [r7, #159]	@ 0x9f
 80046f6:	f8b7 209a 	ldrh.w	r2, [r7, #154]	@ 0x9a
 80046fa:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 80046fe:	441a      	add	r2, r3
 8004700:	7b3b      	ldrb	r3, [r7, #12]
 8004702:	483f      	ldr	r0, [pc, #252]	@ (8004800 <cliI2C+0x2ac>)
 8004704:	f7fe fdc0 	bl	8003288 <cliPrintf>
 8004708:	e006      	b.n	8004718 <cliI2C+0x1c4>
				}
				else
				{
          cliPrintf("%d I2C - Fail \n", print_ch);
 800470a:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 800470e:	4619      	mov	r1, r3
 8004710:	483c      	ldr	r0, [pc, #240]	@ (8004804 <cliI2C+0x2b0>)
 8004712:	f7fe fdb9 	bl	8003288 <cliPrintf>
          break;
 8004716:	e04d      	b.n	80047b4 <cliI2C+0x260>
			for(i=0; i<length; i++)
 8004718:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 800471c:	3301      	adds	r3, #1
 800471e:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8004722:	f8b7 3098 	ldrh.w	r3, [r7, #152]	@ 0x98
 8004726:	f8d7 20a0 	ldr.w	r2, [r7, #160]	@ 0xa0
 800472a:	429a      	cmp	r2, r3
 800472c:	d3c9      	bcc.n	80046c2 <cliI2C+0x16e>
 800472e:	e041      	b.n	80047b4 <cliI2C+0x260>
				}
			}
		}
		else if(args->isStr(0, "write") == true)
 8004730:	687b      	ldr	r3, [r7, #4]
 8004732:	695b      	ldr	r3, [r3, #20]
 8004734:	4934      	ldr	r1, [pc, #208]	@ (8004808 <cliI2C+0x2b4>)
 8004736:	2000      	movs	r0, #0
 8004738:	4798      	blx	r3
 800473a:	4603      	mov	r3, r0
 800473c:	2b00      	cmp	r3, #0
 800473e:	d032      	beq.n	80047a6 <cliI2C+0x252>
		{
			pre_time = millis();
 8004740:	f7fd f9a6 	bl	8001a90 <millis>
 8004744:	f8c7 0090 	str.w	r0, [r7, #144]	@ 0x90
			i2c_ret = i2cWriteByte(ch, dev_addr, reg_addr, (uint8_t)length, 100);
 8004748:	f8b7 3098 	ldrh.w	r3, [r7, #152]	@ 0x98
 800474c:	b2db      	uxtb	r3, r3
 800474e:	f8b7 209a 	ldrh.w	r2, [r7, #154]	@ 0x9a
 8004752:	f8b7 109c 	ldrh.w	r1, [r7, #156]	@ 0x9c
 8004756:	f897 0097 	ldrb.w	r0, [r7, #151]	@ 0x97
 800475a:	2464      	movs	r4, #100	@ 0x64
 800475c:	9400      	str	r4, [sp, #0]
 800475e:	f7ff fdeb 	bl	8004338 <i2cWriteByte>
 8004762:	4603      	mov	r3, r0
 8004764:	f887 308f 	strb.w	r3, [r7, #143]	@ 0x8f

			if(i2c_ret == true)
 8004768:	f897 308f 	ldrb.w	r3, [r7, #143]	@ 0x8f
 800476c:	2b00      	cmp	r3, #0
 800476e:	d013      	beq.n	8004798 <cliI2C+0x244>
			{
				cliPrintf("%d I2C - 0x%02X : 0x%02X, %d ms\n", print_ch, reg_addr, length, millis()-pre_time);
 8004770:	f897 409f 	ldrb.w	r4, [r7, #159]	@ 0x9f
 8004774:	f8b7 509a 	ldrh.w	r5, [r7, #154]	@ 0x9a
 8004778:	f8b7 6098 	ldrh.w	r6, [r7, #152]	@ 0x98
 800477c:	f7fd f988 	bl	8001a90 <millis>
 8004780:	4602      	mov	r2, r0
 8004782:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8004786:	1ad3      	subs	r3, r2, r3
 8004788:	9300      	str	r3, [sp, #0]
 800478a:	4633      	mov	r3, r6
 800478c:	462a      	mov	r2, r5
 800478e:	4621      	mov	r1, r4
 8004790:	481e      	ldr	r0, [pc, #120]	@ (800480c <cliI2C+0x2b8>)
 8004792:	f7fe fd79 	bl	8003288 <cliPrintf>
 8004796:	e00d      	b.n	80047b4 <cliI2C+0x260>
			}
			else
			{
				cliPrintf("%d I2C - Fail \n", print_ch);
 8004798:	f897 309f 	ldrb.w	r3, [r7, #159]	@ 0x9f
 800479c:	4619      	mov	r1, r3
 800479e:	4819      	ldr	r0, [pc, #100]	@ (8004804 <cliI2C+0x2b0>)
 80047a0:	f7fe fd72 	bl	8003288 <cliPrintf>
 80047a4:	e006      	b.n	80047b4 <cliI2C+0x260>
			}
		}
		else
		{
			ret = false;
 80047a6:	2300      	movs	r3, #0
 80047a8:	f887 30a7 	strb.w	r3, [r7, #167]	@ 0xa7
 80047ac:	e002      	b.n	80047b4 <cliI2C+0x260>
		}
	}
	else
	{
		ret = false;
 80047ae:	2300      	movs	r3, #0
 80047b0:	f887 30a7 	strb.w	r3, [r7, #167]	@ 0xa7
	}

	if(ret == false)
 80047b4:	f897 30a7 	ldrb.w	r3, [r7, #167]	@ 0xa7
 80047b8:	f083 0301 	eor.w	r3, r3, #1
 80047bc:	b2db      	uxtb	r3, r3
 80047be:	2b00      	cmp	r3, #0
 80047c0:	d00d      	beq.n	80047de <cliI2C+0x28a>
	{
    cliPrintf( "i2c begin channel[1~%d]\n", I2C_MAX_CH);
 80047c2:	2101      	movs	r1, #1
 80047c4:	4812      	ldr	r0, [pc, #72]	@ (8004810 <cliI2C+0x2bc>)
 80047c6:	f7fe fd5f 	bl	8003288 <cliPrintf>
    cliPrintf( "i2c scan channel[1~%d]\n", I2C_MAX_CH);
 80047ca:	2101      	movs	r1, #1
 80047cc:	4811      	ldr	r0, [pc, #68]	@ (8004814 <cliI2C+0x2c0>)
 80047ce:	f7fe fd5b 	bl	8003288 <cliPrintf>
    cliPrintf( "i2c read channel dev_addr reg_addr length\n");
 80047d2:	4811      	ldr	r0, [pc, #68]	@ (8004818 <cliI2C+0x2c4>)
 80047d4:	f7fe fd58 	bl	8003288 <cliPrintf>
    cliPrintf( "i2c write channel dev_addr reg_addr data\n");
 80047d8:	4810      	ldr	r0, [pc, #64]	@ (800481c <cliI2C+0x2c8>)
 80047da:	f7fe fd55 	bl	8003288 <cliPrintf>
	}
}
 80047de:	bf00      	nop
 80047e0:	37ac      	adds	r7, #172	@ 0xac
 80047e2:	46bd      	mov	sp, r7
 80047e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80047e6:	bf00      	nop
 80047e8:	080243f0 	.word	0x080243f0
 80047ec:	080243f8 	.word	0x080243f8
 80047f0:	08024414 	.word	0x08024414
 80047f4:	0802441c 	.word	0x0802441c
 80047f8:	08024430 	.word	0x08024430
 80047fc:	08024448 	.word	0x08024448
 8004800:	08024450 	.word	0x08024450
 8004804:	0802446c 	.word	0x0802446c
 8004808:	0802447c 	.word	0x0802447c
 800480c:	08024484 	.word	0x08024484
 8004810:	080244a8 	.word	0x080244a8
 8004814:	080244c4 	.word	0x080244c4
 8004818:	080244dc 	.word	0x080244dc
 800481c:	08024508 	.word	0x08024508

08004820 <i2sInit>:
#ifdef _USE_HW_CLI
static void cliI2S(cli_args_t *args);
#endif

bool i2sInit(void)
{
 8004820:	b580      	push	{r7, lr}
 8004822:	b082      	sub	sp, #8
 8004824:	af00      	add	r7, sp, #0
	bool ret = true;
 8004826:	2301      	movs	r3, #1
 8004828:	71fb      	strb	r3, [r7, #7]

  hi2s5.Instance = SPI5;
 800482a:	4b28      	ldr	r3, [pc, #160]	@ (80048cc <i2sInit+0xac>)
 800482c:	4a28      	ldr	r2, [pc, #160]	@ (80048d0 <i2sInit+0xb0>)
 800482e:	601a      	str	r2, [r3, #0]
  hi2s5.Init.Mode = I2S_MODE_SLAVE_TX;
 8004830:	4b26      	ldr	r3, [pc, #152]	@ (80048cc <i2sInit+0xac>)
 8004832:	2200      	movs	r2, #0
 8004834:	605a      	str	r2, [r3, #4]
  hi2s5.Init.Standard = I2S_STANDARD_PHILIPS;
 8004836:	4b25      	ldr	r3, [pc, #148]	@ (80048cc <i2sInit+0xac>)
 8004838:	2200      	movs	r2, #0
 800483a:	609a      	str	r2, [r3, #8]
  hi2s5.Init.DataFormat = I2S_DATAFORMAT_16B;
 800483c:	4b23      	ldr	r3, [pc, #140]	@ (80048cc <i2sInit+0xac>)
 800483e:	2200      	movs	r2, #0
 8004840:	60da      	str	r2, [r3, #12]
  hi2s5.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
 8004842:	4b22      	ldr	r3, [pc, #136]	@ (80048cc <i2sInit+0xac>)
 8004844:	2200      	movs	r2, #0
 8004846:	611a      	str	r2, [r3, #16]
  hi2s5.Init.AudioFreq = I2S_AUDIOFREQ_16K;
 8004848:	4b20      	ldr	r3, [pc, #128]	@ (80048cc <i2sInit+0xac>)
 800484a:	f44f 527a 	mov.w	r2, #16000	@ 0x3e80
 800484e:	615a      	str	r2, [r3, #20]
  hi2s5.Init.CPOL = I2S_CPOL_LOW;
 8004850:	4b1e      	ldr	r3, [pc, #120]	@ (80048cc <i2sInit+0xac>)
 8004852:	2200      	movs	r2, #0
 8004854:	619a      	str	r2, [r3, #24]
  hi2s5.Init.ClockSource = I2S_CLOCK_PLL;
 8004856:	4b1d      	ldr	r3, [pc, #116]	@ (80048cc <i2sInit+0xac>)
 8004858:	2200      	movs	r2, #0
 800485a:	61da      	str	r2, [r3, #28]
  hi2s5.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
 800485c:	4b1b      	ldr	r3, [pc, #108]	@ (80048cc <i2sInit+0xac>)
 800485e:	2200      	movs	r2, #0
 8004860:	621a      	str	r2, [r3, #32]
  if(HAL_I2S_Init(&hi2s5) != HAL_OK)
 8004862:	481a      	ldr	r0, [pc, #104]	@ (80048cc <i2sInit+0xac>)
 8004864:	f008 fc72 	bl	800d14c <HAL_I2S_Init>
 8004868:	4603      	mov	r3, r0
 800486a:	2b00      	cmp	r3, #0
 800486c:	d001      	beq.n	8004872 <i2sInit+0x52>
  {
  	ret = false;
 800486e:	2300      	movs	r3, #0
 8004870:	71fb      	strb	r3, [r7, #7]
  	q_buf_zero[i + 0] = i % 1000;
  	q_buf_zero[i + 1] = i % 1000;
  }
#endif

  q_buf_len = (i2s_sample_rate * 1) / (1000 / I2S_BUF_MS);
 8004872:	4b18      	ldr	r3, [pc, #96]	@ (80048d4 <i2sInit+0xb4>)
 8004874:	681b      	ldr	r3, [r3, #0]
 8004876:	4a18      	ldr	r2, [pc, #96]	@ (80048d8 <i2sInit+0xb8>)
 8004878:	fba2 2303 	umull	r2, r3, r2, r3
 800487c:	095b      	lsrs	r3, r3, #5
 800487e:	4a17      	ldr	r2, [pc, #92]	@ (80048dc <i2sInit+0xbc>)
 8004880:	6013      	str	r3, [r2, #0]
  q_in = 0;
 8004882:	4b17      	ldr	r3, [pc, #92]	@ (80048e0 <i2sInit+0xc0>)
 8004884:	2200      	movs	r2, #0
 8004886:	601a      	str	r2, [r3, #0]
  q_out = 0;
 8004888:	4b16      	ldr	r3, [pc, #88]	@ (80048e4 <i2sInit+0xc4>)
 800488a:	2200      	movs	r2, #0
 800488c:	601a      	str	r2, [r3, #0]
  q_len = I2S_BUF_LEN / q_buf_len;
 800488e:	4b13      	ldr	r3, [pc, #76]	@ (80048dc <i2sInit+0xbc>)
 8004890:	681b      	ldr	r3, [r3, #0]
 8004892:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8004896:	fbb2 f3f3 	udiv	r3, r2, r3
 800489a:	4a13      	ldr	r2, [pc, #76]	@ (80048e8 <i2sInit+0xc8>)
 800489c:	6013      	str	r3, [r2, #0]

  i2sStart();
 800489e:	f000 f879 	bl	8004994 <i2sStart>
  i2sStop();
 80048a2:	f000 f8a7 	bl	80049f4 <i2sStop>

  delay(50);
 80048a6:	2032      	movs	r0, #50	@ 0x32
 80048a8:	f7fd f8e7 	bl	8001a7a <delay>
  gpioPinWrite(_PIN_GPIO_SPK_EN, true);
 80048ac:	2101      	movs	r1, #1
 80048ae:	2006      	movs	r0, #6
 80048b0:	f7ff fa5a 	bl	8003d68 <gpioPinWrite>

  is_init = ret;
 80048b4:	4a0d      	ldr	r2, [pc, #52]	@ (80048ec <i2sInit+0xcc>)
 80048b6:	79fb      	ldrb	r3, [r7, #7]
 80048b8:	7013      	strb	r3, [r2, #0]

#ifdef _USE_HW_CLI
  cliAdd("i2s", cliI2S);
 80048ba:	490d      	ldr	r1, [pc, #52]	@ (80048f0 <i2sInit+0xd0>)
 80048bc:	480d      	ldr	r0, [pc, #52]	@ (80048f4 <i2sInit+0xd4>)
 80048be:	f7fe fdf3 	bl	80034a8 <cliAdd>
#endif

  return ret;
 80048c2:	79fb      	ldrb	r3, [r7, #7]
}
 80048c4:	4618      	mov	r0, r3
 80048c6:	3708      	adds	r7, #8
 80048c8:	46bd      	mov	sp, r7
 80048ca:	bd80      	pop	{r7, pc}
 80048cc:	200063d0 	.word	0x200063d0
 80048d0:	40015000 	.word	0x40015000
 80048d4:	20000084 	.word	0x20000084
 80048d8:	51eb851f 	.word	0x51eb851f
 80048dc:	200023cc 	.word	0x200023cc
 80048e0:	200023c0 	.word	0x200023c0
 80048e4:	200023c4 	.word	0x200023c4
 80048e8:	200023c8 	.word	0x200023c8
 80048ec:	200023bc 	.word	0x200023bc
 80048f0:	08004fe1 	.word	0x08004fe1
 80048f4:	08024534 	.word	0x08024534

080048f8 <i2sSetSampleRate>:

bool i2sSetSampleRate(uint8_t ch, uint32_t freq)
{
 80048f8:	b580      	push	{r7, lr}
 80048fa:	b084      	sub	sp, #16
 80048fc:	af00      	add	r7, sp, #0
 80048fe:	4603      	mov	r3, r0
 8004900:	6039      	str	r1, [r7, #0]
 8004902:	71fb      	strb	r3, [r7, #7]
	bool ret = true;
 8004904:	2301      	movs	r3, #1
 8004906:	73fb      	strb	r3, [r7, #15]

	i2s_sample_rate = freq;
 8004908:	4a1b      	ldr	r2, [pc, #108]	@ (8004978 <i2sSetSampleRate+0x80>)
 800490a:	683b      	ldr	r3, [r7, #0]
 800490c:	6013      	str	r3, [r2, #0]

	q_buf_len = (i2s_sample_rate * 1) / (1000 / I2S_BUF_MS);
 800490e:	4b1a      	ldr	r3, [pc, #104]	@ (8004978 <i2sSetSampleRate+0x80>)
 8004910:	681b      	ldr	r3, [r3, #0]
 8004912:	4a1a      	ldr	r2, [pc, #104]	@ (800497c <i2sSetSampleRate+0x84>)
 8004914:	fba2 2303 	umull	r2, r3, r2, r3
 8004918:	095b      	lsrs	r3, r3, #5
 800491a:	4a19      	ldr	r2, [pc, #100]	@ (8004980 <i2sSetSampleRate+0x88>)
 800491c:	6013      	str	r3, [r2, #0]
	q_in = 0;
 800491e:	4b19      	ldr	r3, [pc, #100]	@ (8004984 <i2sSetSampleRate+0x8c>)
 8004920:	2200      	movs	r2, #0
 8004922:	601a      	str	r2, [r3, #0]
	q_out = 0;
 8004924:	4b18      	ldr	r3, [pc, #96]	@ (8004988 <i2sSetSampleRate+0x90>)
 8004926:	2200      	movs	r2, #0
 8004928:	601a      	str	r2, [r3, #0]
	q_len = I2S_BUF_LEN / q_buf_len;
 800492a:	4b15      	ldr	r3, [pc, #84]	@ (8004980 <i2sSetSampleRate+0x88>)
 800492c:	681b      	ldr	r3, [r3, #0]
 800492e:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8004932:	fbb2 f3f3 	udiv	r3, r2, r3
 8004936:	4a15      	ldr	r2, [pc, #84]	@ (800498c <i2sSetSampleRate+0x94>)
 8004938:	6013      	str	r3, [r2, #0]

	gpioPinWrite(_PIN_GPIO_SPK_EN, false);
 800493a:	2100      	movs	r1, #0
 800493c:	2006      	movs	r0, #6
 800493e:	f7ff fa13 	bl	8003d68 <gpioPinWrite>

	hi2s5.Init.AudioFreq = freq;
 8004942:	4a13      	ldr	r2, [pc, #76]	@ (8004990 <i2sSetSampleRate+0x98>)
 8004944:	683b      	ldr	r3, [r7, #0]
 8004946:	6153      	str	r3, [r2, #20]
	if(HAL_I2S_Init(&hi2s5) != HAL_OK)
 8004948:	4811      	ldr	r0, [pc, #68]	@ (8004990 <i2sSetSampleRate+0x98>)
 800494a:	f008 fbff 	bl	800d14c <HAL_I2S_Init>
 800494e:	4603      	mov	r3, r0
 8004950:	2b00      	cmp	r3, #0
 8004952:	d001      	beq.n	8004958 <i2sSetSampleRate+0x60>
	{
		ret = false;
 8004954:	2300      	movs	r3, #0
 8004956:	73fb      	strb	r3, [r7, #15]
	}

	i2sStart();
 8004958:	f000 f81c 	bl	8004994 <i2sStart>
	i2sStop();
 800495c:	f000 f84a 	bl	80049f4 <i2sStop>

	delay(10);
 8004960:	200a      	movs	r0, #10
 8004962:	f7fd f88a 	bl	8001a7a <delay>
	gpioPinWrite(_PIN_GPIO_SPK_EN, true);
 8004966:	2101      	movs	r1, #1
 8004968:	2006      	movs	r0, #6
 800496a:	f7ff f9fd 	bl	8003d68 <gpioPinWrite>

	return ret;
 800496e:	7bfb      	ldrb	r3, [r7, #15]
}
 8004970:	4618      	mov	r0, r3
 8004972:	3710      	adds	r7, #16
 8004974:	46bd      	mov	sp, r7
 8004976:	bd80      	pop	{r7, pc}
 8004978:	20000084 	.word	0x20000084
 800497c:	51eb851f 	.word	0x51eb851f
 8004980:	200023cc 	.word	0x200023cc
 8004984:	200023c0 	.word	0x200023c0
 8004988:	200023c4 	.word	0x200023c4
 800498c:	200023c8 	.word	0x200023c8
 8004990:	200063d0 	.word	0x200063d0

08004994 <i2sStart>:

bool i2sStart(void)
{
 8004994:	b580      	push	{r7, lr}
 8004996:	b082      	sub	sp, #8
 8004998:	af00      	add	r7, sp, #0
	HAL_StatusTypeDef status;
	I2S_HandleTypeDef *p_i2s = &hi2s5;
 800499a:	4b10      	ldr	r3, [pc, #64]	@ (80049dc <i2sStart+0x48>)
 800499c:	607b      	str	r3, [r7, #4]

	q_in = 0;
 800499e:	4b10      	ldr	r3, [pc, #64]	@ (80049e0 <i2sStart+0x4c>)
 80049a0:	2200      	movs	r2, #0
 80049a2:	601a      	str	r2, [r3, #0]
	q_out = 0;
 80049a4:	4b0f      	ldr	r3, [pc, #60]	@ (80049e4 <i2sStart+0x50>)
 80049a6:	2200      	movs	r2, #0
 80049a8:	601a      	str	r2, [r3, #0]

	status = HAL_I2S_Transmit_DMA(p_i2s, (uint16_t *)q_buf_zero, q_buf_len * 2);
 80049aa:	4b0f      	ldr	r3, [pc, #60]	@ (80049e8 <i2sStart+0x54>)
 80049ac:	681b      	ldr	r3, [r3, #0]
 80049ae:	b29b      	uxth	r3, r3
 80049b0:	005b      	lsls	r3, r3, #1
 80049b2:	b29b      	uxth	r3, r3
 80049b4:	461a      	mov	r2, r3
 80049b6:	490d      	ldr	r1, [pc, #52]	@ (80049ec <i2sStart+0x58>)
 80049b8:	6878      	ldr	r0, [r7, #4]
 80049ba:	f008 fd07 	bl	800d3cc <HAL_I2S_Transmit_DMA>
 80049be:	4603      	mov	r3, r0
 80049c0:	70fb      	strb	r3, [r7, #3]
	if(status == HAL_OK)
 80049c2:	78fb      	ldrb	r3, [r7, #3]
 80049c4:	2b00      	cmp	r3, #0
 80049c6:	d102      	bne.n	80049ce <i2sStart+0x3a>
	{
		is_started = true;
 80049c8:	4b09      	ldr	r3, [pc, #36]	@ (80049f0 <i2sStart+0x5c>)
 80049ca:	2201      	movs	r2, #1
 80049cc:	701a      	strb	r2, [r3, #0]
	}

	return is_started;
 80049ce:	4b08      	ldr	r3, [pc, #32]	@ (80049f0 <i2sStart+0x5c>)
 80049d0:	781b      	ldrb	r3, [r3, #0]
}
 80049d2:	4618      	mov	r0, r3
 80049d4:	3708      	adds	r7, #8
 80049d6:	46bd      	mov	sp, r7
 80049d8:	bd80      	pop	{r7, pc}
 80049da:	bf00      	nop
 80049dc:	200063d0 	.word	0x200063d0
 80049e0:	200023c0 	.word	0x200023c0
 80049e4:	200023c4 	.word	0x200023c4
 80049e8:	200023cc 	.word	0x200023cc
 80049ec:	08031084 	.word	0x08031084
 80049f0:	200023bd 	.word	0x200023bd

080049f4 <i2sStop>:

bool i2sStop(void)
{
 80049f4:	b480      	push	{r7}
 80049f6:	af00      	add	r7, sp, #0
	is_started = false;
 80049f8:	4b04      	ldr	r3, [pc, #16]	@ (8004a0c <i2sStop+0x18>)
 80049fa:	2200      	movs	r2, #0
 80049fc:	701a      	strb	r2, [r3, #0]

	return true;
 80049fe:	2301      	movs	r3, #1
}
 8004a00:	4618      	mov	r0, r3
 8004a02:	46bd      	mov	sp, r7
 8004a04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004a08:	4770      	bx	lr
 8004a0a:	bf00      	nop
 8004a0c:	200023bd 	.word	0x200023bd

08004a10 <HAL_I2S_TxCpltCallback>:

void HAL_I2S_TxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 8004a10:	b580      	push	{r7, lr}
 8004a12:	b084      	sub	sp, #16
 8004a14:	af00      	add	r7, sp, #0
 8004a16:	6078      	str	r0, [r7, #4]
	uint32_t len;

	if(is_started != true)
 8004a18:	4b26      	ldr	r3, [pc, #152]	@ (8004ab4 <HAL_I2S_TxCpltCallback+0xa4>)
 8004a1a:	781b      	ldrb	r3, [r3, #0]
 8004a1c:	f083 0301 	eor.w	r3, r3, #1
 8004a20:	b2db      	uxtb	r3, r3
 8004a22:	2b00      	cmp	r3, #0
 8004a24:	d142      	bne.n	8004aac <HAL_I2S_TxCpltCallback+0x9c>
	{
		return;
	}

	len = (q_len + q_in - q_out) % q_len;
 8004a26:	4b24      	ldr	r3, [pc, #144]	@ (8004ab8 <HAL_I2S_TxCpltCallback+0xa8>)
 8004a28:	681a      	ldr	r2, [r3, #0]
 8004a2a:	4b24      	ldr	r3, [pc, #144]	@ (8004abc <HAL_I2S_TxCpltCallback+0xac>)
 8004a2c:	681b      	ldr	r3, [r3, #0]
 8004a2e:	441a      	add	r2, r3
 8004a30:	4b23      	ldr	r3, [pc, #140]	@ (8004ac0 <HAL_I2S_TxCpltCallback+0xb0>)
 8004a32:	681b      	ldr	r3, [r3, #0]
 8004a34:	1ad3      	subs	r3, r2, r3
 8004a36:	4a20      	ldr	r2, [pc, #128]	@ (8004ab8 <HAL_I2S_TxCpltCallback+0xa8>)
 8004a38:	6812      	ldr	r2, [r2, #0]
 8004a3a:	fbb3 f1f2 	udiv	r1, r3, r2
 8004a3e:	fb01 f202 	mul.w	r2, r1, r2
 8004a42:	1a9b      	subs	r3, r3, r2
 8004a44:	60fb      	str	r3, [r7, #12]

	if(len > 0)
 8004a46:	68fb      	ldr	r3, [r7, #12]
 8004a48:	2b00      	cmp	r3, #0
 8004a4a:	d024      	beq.n	8004a96 <HAL_I2S_TxCpltCallback+0x86>
	{
		HAL_I2S_Transmit_DMA(hi2s, (uint16_t *)&q_buf[q_out * q_buf_len], q_buf_len * 2);
 8004a4c:	4b1c      	ldr	r3, [pc, #112]	@ (8004ac0 <HAL_I2S_TxCpltCallback+0xb0>)
 8004a4e:	681b      	ldr	r3, [r3, #0]
 8004a50:	4a1c      	ldr	r2, [pc, #112]	@ (8004ac4 <HAL_I2S_TxCpltCallback+0xb4>)
 8004a52:	6812      	ldr	r2, [r2, #0]
 8004a54:	fb02 f303 	mul.w	r3, r2, r3
 8004a58:	009b      	lsls	r3, r3, #2
 8004a5a:	4a1b      	ldr	r2, [pc, #108]	@ (8004ac8 <HAL_I2S_TxCpltCallback+0xb8>)
 8004a5c:	1899      	adds	r1, r3, r2
 8004a5e:	4b19      	ldr	r3, [pc, #100]	@ (8004ac4 <HAL_I2S_TxCpltCallback+0xb4>)
 8004a60:	681b      	ldr	r3, [r3, #0]
 8004a62:	b29b      	uxth	r3, r3
 8004a64:	005b      	lsls	r3, r3, #1
 8004a66:	b29b      	uxth	r3, r3
 8004a68:	461a      	mov	r2, r3
 8004a6a:	6878      	ldr	r0, [r7, #4]
 8004a6c:	f008 fcae 	bl	800d3cc <HAL_I2S_Transmit_DMA>

		if(q_out != q_in)
 8004a70:	4b13      	ldr	r3, [pc, #76]	@ (8004ac0 <HAL_I2S_TxCpltCallback+0xb0>)
 8004a72:	681a      	ldr	r2, [r3, #0]
 8004a74:	4b11      	ldr	r3, [pc, #68]	@ (8004abc <HAL_I2S_TxCpltCallback+0xac>)
 8004a76:	681b      	ldr	r3, [r3, #0]
 8004a78:	429a      	cmp	r2, r3
 8004a7a:	d018      	beq.n	8004aae <HAL_I2S_TxCpltCallback+0x9e>
		{
			q_out = (q_out + 1) % q_len;
 8004a7c:	4b10      	ldr	r3, [pc, #64]	@ (8004ac0 <HAL_I2S_TxCpltCallback+0xb0>)
 8004a7e:	681b      	ldr	r3, [r3, #0]
 8004a80:	3301      	adds	r3, #1
 8004a82:	4a0d      	ldr	r2, [pc, #52]	@ (8004ab8 <HAL_I2S_TxCpltCallback+0xa8>)
 8004a84:	6812      	ldr	r2, [r2, #0]
 8004a86:	fbb3 f1f2 	udiv	r1, r3, r2
 8004a8a:	fb01 f202 	mul.w	r2, r1, r2
 8004a8e:	1a9b      	subs	r3, r3, r2
 8004a90:	4a0b      	ldr	r2, [pc, #44]	@ (8004ac0 <HAL_I2S_TxCpltCallback+0xb0>)
 8004a92:	6013      	str	r3, [r2, #0]
 8004a94:	e00b      	b.n	8004aae <HAL_I2S_TxCpltCallback+0x9e>
		}
	}
	else
	{
		HAL_I2S_Transmit_DMA(hi2s, (uint16_t *)q_buf_zero, q_buf_len * 2);
 8004a96:	4b0b      	ldr	r3, [pc, #44]	@ (8004ac4 <HAL_I2S_TxCpltCallback+0xb4>)
 8004a98:	681b      	ldr	r3, [r3, #0]
 8004a9a:	b29b      	uxth	r3, r3
 8004a9c:	005b      	lsls	r3, r3, #1
 8004a9e:	b29b      	uxth	r3, r3
 8004aa0:	461a      	mov	r2, r3
 8004aa2:	490a      	ldr	r1, [pc, #40]	@ (8004acc <HAL_I2S_TxCpltCallback+0xbc>)
 8004aa4:	6878      	ldr	r0, [r7, #4]
 8004aa6:	f008 fc91 	bl	800d3cc <HAL_I2S_Transmit_DMA>
 8004aaa:	e000      	b.n	8004aae <HAL_I2S_TxCpltCallback+0x9e>
		return;
 8004aac:	bf00      	nop
	}
}
 8004aae:	3710      	adds	r7, #16
 8004ab0:	46bd      	mov	sp, r7
 8004ab2:	bd80      	pop	{r7, pc}
 8004ab4:	200023bd 	.word	0x200023bd
 8004ab8:	200023c8 	.word	0x200023c8
 8004abc:	200023c0 	.word	0x200023c0
 8004ac0:	200023c4 	.word	0x200023c4
 8004ac4:	200023cc 	.word	0x200023cc
 8004ac8:	200023d0 	.word	0x200023d0
 8004acc:	08031084 	.word	0x08031084

08004ad0 <HAL_I2S_ErrorCallback>:

void HAL_I2S_ErrorCallback(I2S_HandleTypeDef *hi2s)
{
 8004ad0:	b480      	push	{r7}
 8004ad2:	b083      	sub	sp, #12
 8004ad4:	af00      	add	r7, sp, #0
 8004ad6:	6078      	str	r0, [r7, #4]

}
 8004ad8:	bf00      	nop
 8004ada:	370c      	adds	r7, #12
 8004adc:	46bd      	mov	sp, r7
 8004ade:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ae2:	4770      	bx	lr

08004ae4 <HAL_I2S_MspInit>:

void HAL_I2S_MspInit(I2S_HandleTypeDef* i2sHandle)
{
 8004ae4:	b580      	push	{r7, lr}
 8004ae6:	b090      	sub	sp, #64	@ 0x40
 8004ae8:	af00      	add	r7, sp, #0
 8004aea:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8004aec:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8004af0:	2200      	movs	r2, #0
 8004af2:	601a      	str	r2, [r3, #0]
 8004af4:	605a      	str	r2, [r3, #4]
 8004af6:	609a      	str	r2, [r3, #8]
 8004af8:	60da      	str	r2, [r3, #12]
 8004afa:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8004afc:	f107 0314 	add.w	r3, r7, #20
 8004b00:	2200      	movs	r2, #0
 8004b02:	601a      	str	r2, [r3, #0]
 8004b04:	605a      	str	r2, [r3, #4]
 8004b06:	609a      	str	r2, [r3, #8]
 8004b08:	60da      	str	r2, [r3, #12]
 8004b0a:	611a      	str	r2, [r3, #16]
 8004b0c:	615a      	str	r2, [r3, #20]
  if(i2sHandle->Instance==SPI5)
 8004b0e:	687b      	ldr	r3, [r7, #4]
 8004b10:	681b      	ldr	r3, [r3, #0]
 8004b12:	4a3f      	ldr	r2, [pc, #252]	@ (8004c10 <HAL_I2S_MspInit+0x12c>)
 8004b14:	4293      	cmp	r3, r2
 8004b16:	d176      	bne.n	8004c06 <HAL_I2S_MspInit+0x122>

  /* USER CODE END SPI5_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
 8004b18:	2301      	movs	r3, #1
 8004b1a:	617b      	str	r3, [r7, #20]
    PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
 8004b1c:	23c0      	movs	r3, #192	@ 0xc0
 8004b1e:	61fb      	str	r3, [r7, #28]
    PeriphClkInitStruct.PLLI2S.PLLI2SM = 16;
 8004b20:	2310      	movs	r3, #16
 8004b22:	61bb      	str	r3, [r7, #24]
    PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
 8004b24:	2302      	movs	r3, #2
 8004b26:	623b      	str	r3, [r7, #32]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8004b28:	f107 0314 	add.w	r3, r7, #20
 8004b2c:	4618      	mov	r0, r3
 8004b2e:	f00a ff3f 	bl	800f9b0 <HAL_RCCEx_PeriphCLKConfig>
 8004b32:	4603      	mov	r3, r0
 8004b34:	2b00      	cmp	r3, #0
 8004b36:	d001      	beq.n	8004b3c <HAL_I2S_MspInit+0x58>
    {
      Error_Handler();
 8004b38:	f7fc fdd4 	bl	80016e4 <Error_Handler>
    }

    /* I2S5 clock enable */
    __HAL_RCC_SPI5_CLK_ENABLE();
 8004b3c:	2300      	movs	r3, #0
 8004b3e:	613b      	str	r3, [r7, #16]
 8004b40:	4b34      	ldr	r3, [pc, #208]	@ (8004c14 <HAL_I2S_MspInit+0x130>)
 8004b42:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8004b44:	4a33      	ldr	r2, [pc, #204]	@ (8004c14 <HAL_I2S_MspInit+0x130>)
 8004b46:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8004b4a:	6453      	str	r3, [r2, #68]	@ 0x44
 8004b4c:	4b31      	ldr	r3, [pc, #196]	@ (8004c14 <HAL_I2S_MspInit+0x130>)
 8004b4e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8004b50:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8004b54:	613b      	str	r3, [r7, #16]
 8004b56:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8004b58:	2300      	movs	r3, #0
 8004b5a:	60fb      	str	r3, [r7, #12]
 8004b5c:	4b2d      	ldr	r3, [pc, #180]	@ (8004c14 <HAL_I2S_MspInit+0x130>)
 8004b5e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8004b60:	4a2c      	ldr	r2, [pc, #176]	@ (8004c14 <HAL_I2S_MspInit+0x130>)
 8004b62:	f043 0302 	orr.w	r3, r3, #2
 8004b66:	6313      	str	r3, [r2, #48]	@ 0x30
 8004b68:	4b2a      	ldr	r3, [pc, #168]	@ (8004c14 <HAL_I2S_MspInit+0x130>)
 8004b6a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8004b6c:	f003 0302 	and.w	r3, r3, #2
 8004b70:	60fb      	str	r3, [r7, #12]
 8004b72:	68fb      	ldr	r3, [r7, #12]
    /**I2S5 GPIO Configuration
    PB0     ------> I2S5_CK
    PB1     ------> I2S5_WS
    PB8     ------> I2S5_SD
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_8;
 8004b74:	f240 1303 	movw	r3, #259	@ 0x103
 8004b78:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004b7a:	2302      	movs	r3, #2
 8004b7c:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004b7e:	2300      	movs	r3, #0
 8004b80:	637b      	str	r3, [r7, #52]	@ 0x34
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8004b82:	2300      	movs	r3, #0
 8004b84:	63bb      	str	r3, [r7, #56]	@ 0x38
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI5;
 8004b86:	2306      	movs	r3, #6
 8004b88:	63fb      	str	r3, [r7, #60]	@ 0x3c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8004b8a:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8004b8e:	4619      	mov	r1, r3
 8004b90:	4821      	ldr	r0, [pc, #132]	@ (8004c18 <HAL_I2S_MspInit+0x134>)
 8004b92:	f005 f94d 	bl	8009e30 <HAL_GPIO_Init>

    /* I2S5 DMA Init */
    /* SPI5_TX Init */
    hdma_spi5_tx.Instance = DMA2_Stream4;
 8004b96:	4b21      	ldr	r3, [pc, #132]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004b98:	4a21      	ldr	r2, [pc, #132]	@ (8004c20 <HAL_I2S_MspInit+0x13c>)
 8004b9a:	601a      	str	r2, [r3, #0]
    hdma_spi5_tx.Init.Channel = DMA_CHANNEL_2;
 8004b9c:	4b1f      	ldr	r3, [pc, #124]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004b9e:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 8004ba2:	605a      	str	r2, [r3, #4]
    hdma_spi5_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8004ba4:	4b1d      	ldr	r3, [pc, #116]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004ba6:	2240      	movs	r2, #64	@ 0x40
 8004ba8:	609a      	str	r2, [r3, #8]
    hdma_spi5_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8004baa:	4b1c      	ldr	r3, [pc, #112]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bac:	2200      	movs	r2, #0
 8004bae:	60da      	str	r2, [r3, #12]
    hdma_spi5_tx.Init.MemInc = DMA_MINC_ENABLE;
 8004bb0:	4b1a      	ldr	r3, [pc, #104]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bb2:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8004bb6:	611a      	str	r2, [r3, #16]
    hdma_spi5_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8004bb8:	4b18      	ldr	r3, [pc, #96]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bba:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8004bbe:	615a      	str	r2, [r3, #20]
    hdma_spi5_tx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8004bc0:	4b16      	ldr	r3, [pc, #88]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bc2:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8004bc6:	619a      	str	r2, [r3, #24]
    hdma_spi5_tx.Init.Mode = DMA_NORMAL;
 8004bc8:	4b14      	ldr	r3, [pc, #80]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bca:	2200      	movs	r2, #0
 8004bcc:	61da      	str	r2, [r3, #28]
    hdma_spi5_tx.Init.Priority = DMA_PRIORITY_LOW;
 8004bce:	4b13      	ldr	r3, [pc, #76]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bd0:	2200      	movs	r2, #0
 8004bd2:	621a      	str	r2, [r3, #32]
    hdma_spi5_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8004bd4:	4b11      	ldr	r3, [pc, #68]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bd6:	2200      	movs	r2, #0
 8004bd8:	625a      	str	r2, [r3, #36]	@ 0x24
    if (HAL_DMA_Init(&hdma_spi5_tx) != HAL_OK)
 8004bda:	4810      	ldr	r0, [pc, #64]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bdc:	f004 f9c6 	bl	8008f6c <HAL_DMA_Init>
 8004be0:	4603      	mov	r3, r0
 8004be2:	2b00      	cmp	r3, #0
 8004be4:	d001      	beq.n	8004bea <HAL_I2S_MspInit+0x106>
    {
      Error_Handler();
 8004be6:	f7fc fd7d 	bl	80016e4 <Error_Handler>
    }

    __HAL_LINKDMA(i2sHandle,hdmatx,hdma_spi5_tx);
 8004bea:	687b      	ldr	r3, [r7, #4]
 8004bec:	4a0b      	ldr	r2, [pc, #44]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bee:	639a      	str	r2, [r3, #56]	@ 0x38
 8004bf0:	4a0a      	ldr	r2, [pc, #40]	@ (8004c1c <HAL_I2S_MspInit+0x138>)
 8004bf2:	687b      	ldr	r3, [r7, #4]
 8004bf4:	6393      	str	r3, [r2, #56]	@ 0x38

    /* I2S5 interrupt Init */
    HAL_NVIC_SetPriority(SPI5_IRQn, 5, 0);
 8004bf6:	2200      	movs	r2, #0
 8004bf8:	2105      	movs	r1, #5
 8004bfa:	2055      	movs	r0, #85	@ 0x55
 8004bfc:	f004 f971 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI5_IRQn);
 8004c00:	2055      	movs	r0, #85	@ 0x55
 8004c02:	f004 f98a 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SPI5_MspInit 1 */

  /* USER CODE END SPI5_MspInit 1 */
  }
}
 8004c06:	bf00      	nop
 8004c08:	3740      	adds	r7, #64	@ 0x40
 8004c0a:	46bd      	mov	sp, r7
 8004c0c:	bd80      	pop	{r7, pc}
 8004c0e:	bf00      	nop
 8004c10:	40015000 	.word	0x40015000
 8004c14:	40023800 	.word	0x40023800
 8004c18:	40020400 	.word	0x40020400
 8004c1c:	20006418 	.word	0x20006418
 8004c20:	40026470 	.word	0x40026470

08004c24 <fillReadBuffer>:
	uint8_t block_peak[BLOCK_X_CNT];
	uint8_t block_value[BLOCK_X_CNT];
} i2s_cli_t;

static int fillReadBuffer(uint8_t *read_buf, uint8_t *read_ptr, int buf_size, int bytes_left, FILE *infile)
{
 8004c24:	b580      	push	{r7, lr}
 8004c26:	b086      	sub	sp, #24
 8004c28:	af00      	add	r7, sp, #0
 8004c2a:	60f8      	str	r0, [r7, #12]
 8004c2c:	60b9      	str	r1, [r7, #8]
 8004c2e:	607a      	str	r2, [r7, #4]
 8004c30:	603b      	str	r3, [r7, #0]
	int nRead;

  /* move last, small chunk from end of buffer to start, then fill with new data */
  memmove(read_buf, read_ptr, bytes_left);
 8004c32:	683b      	ldr	r3, [r7, #0]
 8004c34:	461a      	mov	r2, r3
 8004c36:	68b9      	ldr	r1, [r7, #8]
 8004c38:	68f8      	ldr	r0, [r7, #12]
 8004c3a:	f01d fa49 	bl	80220d0 <memmove>
  nRead = fread( read_buf + bytes_left, 1, buf_size - bytes_left, infile);
 8004c3e:	683b      	ldr	r3, [r7, #0]
 8004c40:	68fa      	ldr	r2, [r7, #12]
 8004c42:	18d0      	adds	r0, r2, r3
 8004c44:	687a      	ldr	r2, [r7, #4]
 8004c46:	683b      	ldr	r3, [r7, #0]
 8004c48:	1ad3      	subs	r3, r2, r3
 8004c4a:	461a      	mov	r2, r3
 8004c4c:	6a3b      	ldr	r3, [r7, #32]
 8004c4e:	2101      	movs	r1, #1
 8004c50:	f7ff f819 	bl	8003c86 <ob_fread>
 8004c54:	4603      	mov	r3, r0
 8004c56:	617b      	str	r3, [r7, #20]
  /* zero-pad to avoid finding false sync word after last frame (from old data in readBuf) */
  if (nRead < buf_size - bytes_left)
 8004c58:	687a      	ldr	r2, [r7, #4]
 8004c5a:	683b      	ldr	r3, [r7, #0]
 8004c5c:	1ad3      	subs	r3, r2, r3
 8004c5e:	697a      	ldr	r2, [r7, #20]
 8004c60:	429a      	cmp	r2, r3
 8004c62:	da0d      	bge.n	8004c80 <fillReadBuffer+0x5c>
  {
    memset(read_buf + bytes_left + nRead, 0, buf_size - bytes_left - nRead);
 8004c64:	683a      	ldr	r2, [r7, #0]
 8004c66:	697b      	ldr	r3, [r7, #20]
 8004c68:	4413      	add	r3, r2
 8004c6a:	68fa      	ldr	r2, [r7, #12]
 8004c6c:	18d0      	adds	r0, r2, r3
 8004c6e:	687a      	ldr	r2, [r7, #4]
 8004c70:	683b      	ldr	r3, [r7, #0]
 8004c72:	1ad2      	subs	r2, r2, r3
 8004c74:	697b      	ldr	r3, [r7, #20]
 8004c76:	1ad3      	subs	r3, r2, r3
 8004c78:	461a      	mov	r2, r3
 8004c7a:	2100      	movs	r1, #0
 8004c7c:	f01d fa42 	bl	8022104 <memset>
  }
  return nRead;
 8004c80:	697b      	ldr	r3, [r7, #20]
}
 8004c82:	4618      	mov	r0, r3
 8004c84:	3718      	adds	r7, #24
 8004c86:	46bd      	mov	sp, r7
 8004c88:	bd80      	pop	{r7, pc}

08004c8a <drawBlock>:

static void drawBlock(int16_t bx, int16_t by, uint16_t color)
{
 8004c8a:	b590      	push	{r4, r7, lr}
 8004c8c:	b087      	sub	sp, #28
 8004c8e:	af02      	add	r7, sp, #8
 8004c90:	4603      	mov	r3, r0
 8004c92:	80fb      	strh	r3, [r7, #6]
 8004c94:	460b      	mov	r3, r1
 8004c96:	80bb      	strh	r3, [r7, #4]
 8004c98:	4613      	mov	r3, r2
 8004c9a:	807b      	strh	r3, [r7, #2]
	int16_t x;
	int16_t y;
	int16_t bw;
	int16_t bh;

	bw = (lcdGetWidth() / BLOCK_X_CNT);
 8004c9c:	f001 f9ea 	bl	8006074 <lcdGetWidth>
 8004ca0:	4603      	mov	r3, r0
 8004ca2:	2b00      	cmp	r3, #0
 8004ca4:	da00      	bge.n	8004ca8 <drawBlock+0x1e>
 8004ca6:	331f      	adds	r3, #31
 8004ca8:	115b      	asrs	r3, r3, #5
 8004caa:	81fb      	strh	r3, [r7, #14]
	bh = (lcdGetHeight() / BLOCK_Y_CNT);
 8004cac:	f001 f9ea 	bl	8006084 <lcdGetHeight>
 8004cb0:	4603      	mov	r3, r0
 8004cb2:	2b00      	cmp	r3, #0
 8004cb4:	da00      	bge.n	8004cb8 <drawBlock+0x2e>
 8004cb6:	331f      	adds	r3, #31
 8004cb8:	115b      	asrs	r3, r3, #5
 8004cba:	81bb      	strh	r3, [r7, #12]

	x = bx * bw;
 8004cbc:	88fa      	ldrh	r2, [r7, #6]
 8004cbe:	89fb      	ldrh	r3, [r7, #14]
 8004cc0:	fb12 f303 	smulbb	r3, r2, r3
 8004cc4:	b29b      	uxth	r3, r3
 8004cc6:	817b      	strh	r3, [r7, #10]
	y = lcdGetHeight() - bh * by - bh;
 8004cc8:	f001 f9dc 	bl	8006084 <lcdGetHeight>
 8004ccc:	4603      	mov	r3, r0
 8004cce:	b29a      	uxth	r2, r3
 8004cd0:	89b9      	ldrh	r1, [r7, #12]
 8004cd2:	88bb      	ldrh	r3, [r7, #4]
 8004cd4:	fb11 f303 	smulbb	r3, r1, r3
 8004cd8:	b29b      	uxth	r3, r3
 8004cda:	1ad3      	subs	r3, r2, r3
 8004cdc:	b29a      	uxth	r2, r3
 8004cde:	89bb      	ldrh	r3, [r7, #12]
 8004ce0:	1ad3      	subs	r3, r2, r3
 8004ce2:	b29b      	uxth	r3, r3
 8004ce4:	813b      	strh	r3, [r7, #8]

	lcdDrawFillRect(x, y, bw, bh, color);
 8004ce6:	f9b7 400c 	ldrsh.w	r4, [r7, #12]
 8004cea:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8004cee:	f9b7 1008 	ldrsh.w	r1, [r7, #8]
 8004cf2:	f9b7 000a 	ldrsh.w	r0, [r7, #10]
 8004cf6:	887b      	ldrh	r3, [r7, #2]
 8004cf8:	9300      	str	r3, [sp, #0]
 8004cfa:	4623      	mov	r3, r4
 8004cfc:	f001 faa6 	bl	800624c <lcdDrawFillRect>
}
 8004d00:	bf00      	nop
 8004d02:	3714      	adds	r7, #20
 8004d04:	46bd      	mov	sp, r7
 8004d06:	bd90      	pop	{r4, r7, pc}

08004d08 <lcdUpdate>:

static void lcdUpdate(i2s_cli_t *p_args)
{
 8004d08:	b580      	push	{r7, lr}
 8004d0a:	b08a      	sub	sp, #40	@ 0x28
 8004d0c:	af00      	add	r7, sp, #0
 8004d0e:	6078      	str	r0, [r7, #4]
	if(millis() - p_args->pre_time_lcd >= 10 && lcdDrawAvailable() == true)
 8004d10:	f7fc febe 	bl	8001a90 <millis>
 8004d14:	4602      	mov	r2, r0
 8004d16:	687b      	ldr	r3, [r7, #4]
 8004d18:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8004d1c:	f8d3 3130 	ldr.w	r3, [r3, #304]	@ 0x130
 8004d20:	1ad3      	subs	r3, r2, r3
 8004d22:	2b09      	cmp	r3, #9
 8004d24:	f240 8151 	bls.w	8004fca <lcdUpdate+0x2c2>
 8004d28:	f001 f922 	bl	8005f70 <lcdDrawAvailable>
 8004d2c:	4603      	mov	r3, r0
 8004d2e:	2b00      	cmp	r3, #0
 8004d30:	f000 814b 	beq.w	8004fca <lcdUpdate+0x2c2>
	{
		p_args->pre_time_lcd = millis();
 8004d34:	f7fc feac 	bl	8001a90 <millis>
 8004d38:	4602      	mov	r2, r0
 8004d3a:	687b      	ldr	r3, [r7, #4]
 8004d3c:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8004d40:	f8c3 2130 	str.w	r2, [r3, #304]	@ 0x130

		lcdClearBuffer(black);
 8004d44:	2000      	movs	r0, #0
 8004d46:	f001 f8e3 	bl	8005f10 <lcdClearBuffer>

		for(int i=0; i<512; i++)
 8004d4a:	2300      	movs	r3, #0
 8004d4c:	627b      	str	r3, [r7, #36]	@ 0x24
 8004d4e:	e020      	b.n	8004d92 <lcdUpdate+0x8a>
		{
			p_args->buf_q15[2*i] = p_args->out_buf[i*2];
 8004d50:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004d52:	005b      	lsls	r3, r3, #1
 8004d54:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8004d56:	0051      	lsls	r1, r2, #1
 8004d58:	687a      	ldr	r2, [r7, #4]
 8004d5a:	f203 7394 	addw	r3, r3, #1940	@ 0x794
 8004d5e:	005b      	lsls	r3, r3, #1
 8004d60:	4413      	add	r3, r2
 8004d62:	f9b3 0004 	ldrsh.w	r0, [r3, #4]
 8004d66:	687a      	ldr	r2, [r7, #4]
 8004d68:	f501 5384 	add.w	r3, r1, #4224	@ 0x1080
 8004d6c:	3318      	adds	r3, #24
 8004d6e:	005b      	lsls	r3, r3, #1
 8004d70:	4413      	add	r3, r2
 8004d72:	4602      	mov	r2, r0
 8004d74:	80da      	strh	r2, [r3, #6]
			p_args->buf_q15[2*i+1] = 0;
 8004d76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004d78:	005b      	lsls	r3, r3, #1
 8004d7a:	3301      	adds	r3, #1
 8004d7c:	687a      	ldr	r2, [r7, #4]
 8004d7e:	f503 5384 	add.w	r3, r3, #4224	@ 0x1080
 8004d82:	3318      	adds	r3, #24
 8004d84:	005b      	lsls	r3, r3, #1
 8004d86:	4413      	add	r3, r2
 8004d88:	2200      	movs	r2, #0
 8004d8a:	80da      	strh	r2, [r3, #6]
		for(int i=0; i<512; i++)
 8004d8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004d8e:	3301      	adds	r3, #1
 8004d90:	627b      	str	r3, [r7, #36]	@ 0x24
 8004d92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8004d94:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8004d98:	dbda      	blt.n	8004d50 <lcdUpdate+0x48>
		}

		arm_cfft_q15(&arm_cfft_sR_q15_len512, p_args->buf_q15, 0, 1);
 8004d9a:	687b      	ldr	r3, [r7, #4]
 8004d9c:	f503 5104 	add.w	r1, r3, #8448	@ 0x2100
 8004da0:	3136      	adds	r1, #54	@ 0x36
 8004da2:	2301      	movs	r3, #1
 8004da4:	2200      	movs	r2, #0
 8004da6:	488b      	ldr	r0, [pc, #556]	@ (8004fd4 <lcdUpdate+0x2cc>)
 8004da8:	f01b fd0c 	bl	80207c4 <arm_cfft_q15>

		int16_t xi;

		xi = 0;
 8004dac:	2300      	movs	r3, #0
 8004dae:	847b      	strh	r3, [r7, #34]	@ 0x22
		for(int i=0; i<BLOCK_X_CNT; i++)
 8004db0:	2300      	movs	r3, #0
 8004db2:	61fb      	str	r3, [r7, #28]
 8004db4:	e0a4      	b.n	8004f00 <lcdUpdate+0x1f8>
		{
			int16_t h;
			int16_t max_h;

			max_h = 0;
 8004db6:	2300      	movs	r3, #0
 8004db8:	837b      	strh	r3, [r7, #26]
			for(int j=0; j<lcdGetWidth() / BLOCK_X_CNT; j++)
 8004dba:	2300      	movs	r3, #0
 8004dbc:	617b      	str	r3, [r7, #20]
 8004dbe:	e038      	b.n	8004e32 <lcdUpdate+0x12a>
			{
				h = p_args->buf_q15[2*xi+1];
 8004dc0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	@ 0x22
 8004dc4:	005b      	lsls	r3, r3, #1
 8004dc6:	3301      	adds	r3, #1
 8004dc8:	687a      	ldr	r2, [r7, #4]
 8004dca:	f503 5384 	add.w	r3, r3, #4224	@ 0x1080
 8004dce:	3318      	adds	r3, #24
 8004dd0:	005b      	lsls	r3, r3, #1
 8004dd2:	4413      	add	r3, r2
 8004dd4:	88db      	ldrh	r3, [r3, #6]
 8004dd6:	817b      	strh	r3, [r7, #10]
				h = constrain(h, 0, 500);
 8004dd8:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8004ddc:	2b00      	cmp	r3, #0
 8004dde:	db08      	blt.n	8004df2 <lcdUpdate+0xea>
 8004de0:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8004de4:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
 8004de8:	bfa8      	it	ge
 8004dea:	f44f 73fa 	movge.w	r3, #500	@ 0x1f4
 8004dee:	b21b      	sxth	r3, r3
 8004df0:	e000      	b.n	8004df4 <lcdUpdate+0xec>
 8004df2:	2300      	movs	r3, #0
 8004df4:	817b      	strh	r3, [r7, #10]
				h = map(h, 0, 500, 0, 80);
 8004df6:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8004dfa:	4613      	mov	r3, r2
 8004dfc:	009b      	lsls	r3, r3, #2
 8004dfe:	4413      	add	r3, r2
 8004e00:	011b      	lsls	r3, r3, #4
 8004e02:	4a75      	ldr	r2, [pc, #468]	@ (8004fd8 <lcdUpdate+0x2d0>)
 8004e04:	fb82 1203 	smull	r1, r2, r2, r3
 8004e08:	1152      	asrs	r2, r2, #5
 8004e0a:	17db      	asrs	r3, r3, #31
 8004e0c:	1ad3      	subs	r3, r2, r3
 8004e0e:	817b      	strh	r3, [r7, #10]
				if(h > max_h)
 8004e10:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8004e14:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8004e18:	429a      	cmp	r2, r3
 8004e1a:	dd01      	ble.n	8004e20 <lcdUpdate+0x118>
				{
					max_h = h;
 8004e1c:	897b      	ldrh	r3, [r7, #10]
 8004e1e:	837b      	strh	r3, [r7, #26]
				}
				xi++;
 8004e20:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	@ 0x22
 8004e24:	b29b      	uxth	r3, r3
 8004e26:	3301      	adds	r3, #1
 8004e28:	b29b      	uxth	r3, r3
 8004e2a:	847b      	strh	r3, [r7, #34]	@ 0x22
			for(int j=0; j<lcdGetWidth() / BLOCK_X_CNT; j++)
 8004e2c:	697b      	ldr	r3, [r7, #20]
 8004e2e:	3301      	adds	r3, #1
 8004e30:	617b      	str	r3, [r7, #20]
 8004e32:	f001 f91f 	bl	8006074 <lcdGetWidth>
 8004e36:	4603      	mov	r3, r0
 8004e38:	2b00      	cmp	r3, #0
 8004e3a:	da00      	bge.n	8004e3e <lcdUpdate+0x136>
 8004e3c:	331f      	adds	r3, #31
 8004e3e:	115b      	asrs	r3, r3, #5
 8004e40:	461a      	mov	r2, r3
 8004e42:	697b      	ldr	r3, [r7, #20]
 8004e44:	4293      	cmp	r3, r2
 8004e46:	dbbb      	blt.n	8004dc0 <lcdUpdate+0xb8>
			}

			h = map(max_h, 0, 80, 0, BLOCK_Y_CNT - 1);
 8004e48:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8004e4c:	4613      	mov	r3, r2
 8004e4e:	015b      	lsls	r3, r3, #5
 8004e50:	1a9b      	subs	r3, r3, r2
 8004e52:	4a62      	ldr	r2, [pc, #392]	@ (8004fdc <lcdUpdate+0x2d4>)
 8004e54:	fb82 1203 	smull	r1, r2, r2, r3
 8004e58:	1152      	asrs	r2, r2, #5
 8004e5a:	17db      	asrs	r3, r3, #31
 8004e5c:	1ad3      	subs	r3, r2, r3
 8004e5e:	817b      	strh	r3, [r7, #10]

			p_args->block_target[i] = h;
 8004e60:	897b      	ldrh	r3, [r7, #10]
 8004e62:	b2d9      	uxtb	r1, r3
 8004e64:	687a      	ldr	r2, [r7, #4]
 8004e66:	69fb      	ldr	r3, [r7, #28]
 8004e68:	4413      	add	r3, r2
 8004e6a:	f503 5324 	add.w	r3, r3, #10496	@ 0x2900
 8004e6e:	3336      	adds	r3, #54	@ 0x36
 8004e70:	460a      	mov	r2, r1
 8004e72:	701a      	strb	r2, [r3, #0]

			if(p_args->update_cnt % 2 == 0)
 8004e74:	687b      	ldr	r3, [r7, #4]
 8004e76:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8004e7a:	f893 3134 	ldrb.w	r3, [r3, #308]	@ 0x134
 8004e7e:	f003 0301 	and.w	r3, r3, #1
 8004e82:	b2db      	uxtb	r3, r3
 8004e84:	2b00      	cmp	r3, #0
 8004e86:	d119      	bne.n	8004ebc <lcdUpdate+0x1b4>
			{
				if(p_args->block_peak[i] > 0)
 8004e88:	687a      	ldr	r2, [r7, #4]
 8004e8a:	69fb      	ldr	r3, [r7, #28]
 8004e8c:	4413      	add	r3, r2
 8004e8e:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004e92:	3316      	adds	r3, #22
 8004e94:	781b      	ldrb	r3, [r3, #0]
 8004e96:	2b00      	cmp	r3, #0
 8004e98:	d010      	beq.n	8004ebc <lcdUpdate+0x1b4>
				{
					p_args->block_peak[i]--;
 8004e9a:	687a      	ldr	r2, [r7, #4]
 8004e9c:	69fb      	ldr	r3, [r7, #28]
 8004e9e:	4413      	add	r3, r2
 8004ea0:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004ea4:	3316      	adds	r3, #22
 8004ea6:	781b      	ldrb	r3, [r3, #0]
 8004ea8:	3b01      	subs	r3, #1
 8004eaa:	b2d9      	uxtb	r1, r3
 8004eac:	687a      	ldr	r2, [r7, #4]
 8004eae:	69fb      	ldr	r3, [r7, #28]
 8004eb0:	4413      	add	r3, r2
 8004eb2:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004eb6:	3316      	adds	r3, #22
 8004eb8:	460a      	mov	r2, r1
 8004eba:	701a      	strb	r2, [r3, #0]
				}
			}
			if(h >= p_args->block_peak[i])
 8004ebc:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8004ec0:	6879      	ldr	r1, [r7, #4]
 8004ec2:	69fb      	ldr	r3, [r7, #28]
 8004ec4:	440b      	add	r3, r1
 8004ec6:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004eca:	3316      	adds	r3, #22
 8004ecc:	781b      	ldrb	r3, [r3, #0]
 8004ece:	429a      	cmp	r2, r3
 8004ed0:	db13      	blt.n	8004efa <lcdUpdate+0x1f2>
			{
				p_args->block_peak[i] = h;
 8004ed2:	897b      	ldrh	r3, [r7, #10]
 8004ed4:	b2d9      	uxtb	r1, r3
 8004ed6:	687a      	ldr	r2, [r7, #4]
 8004ed8:	69fb      	ldr	r3, [r7, #28]
 8004eda:	4413      	add	r3, r2
 8004edc:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004ee0:	3316      	adds	r3, #22
 8004ee2:	460a      	mov	r2, r1
 8004ee4:	701a      	strb	r2, [r3, #0]
				p_args->block_value[i] = h;
 8004ee6:	897b      	ldrh	r3, [r7, #10]
 8004ee8:	b2d9      	uxtb	r1, r3
 8004eea:	687a      	ldr	r2, [r7, #4]
 8004eec:	69fb      	ldr	r3, [r7, #28]
 8004eee:	4413      	add	r3, r2
 8004ef0:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004ef4:	3336      	adds	r3, #54	@ 0x36
 8004ef6:	460a      	mov	r2, r1
 8004ef8:	701a      	strb	r2, [r3, #0]
		for(int i=0; i<BLOCK_X_CNT; i++)
 8004efa:	69fb      	ldr	r3, [r7, #28]
 8004efc:	3301      	adds	r3, #1
 8004efe:	61fb      	str	r3, [r7, #28]
 8004f00:	69fb      	ldr	r3, [r7, #28]
 8004f02:	2b1f      	cmp	r3, #31
 8004f04:	f77f af57 	ble.w	8004db6 <lcdUpdate+0xae>
			}
		}

		p_args->update_cnt++;
 8004f08:	687b      	ldr	r3, [r7, #4]
 8004f0a:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8004f0e:	f893 3134 	ldrb.w	r3, [r3, #308]	@ 0x134
 8004f12:	3301      	adds	r3, #1
 8004f14:	b2da      	uxtb	r2, r3
 8004f16:	687b      	ldr	r3, [r7, #4]
 8004f18:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8004f1c:	f883 2134 	strb.w	r2, [r3, #308]	@ 0x134

		for(int i=0; i<BLOCK_X_CNT; i++)
 8004f20:	2300      	movs	r3, #0
 8004f22:	613b      	str	r3, [r7, #16]
 8004f24:	e04c      	b.n	8004fc0 <lcdUpdate+0x2b8>
		{
			drawBlock(i, p_args->block_peak[i], white);
 8004f26:	693b      	ldr	r3, [r7, #16]
 8004f28:	b218      	sxth	r0, r3
 8004f2a:	687a      	ldr	r2, [r7, #4]
 8004f2c:	693b      	ldr	r3, [r7, #16]
 8004f2e:	4413      	add	r3, r2
 8004f30:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004f34:	3316      	adds	r3, #22
 8004f36:	781b      	ldrb	r3, [r3, #0]
 8004f38:	b21b      	sxth	r3, r3
 8004f3a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8004f3e:	4619      	mov	r1, r3
 8004f40:	f7ff fea3 	bl	8004c8a <drawBlock>

			if(p_args->block_value[i] > p_args->block_target[i])
 8004f44:	687a      	ldr	r2, [r7, #4]
 8004f46:	693b      	ldr	r3, [r7, #16]
 8004f48:	4413      	add	r3, r2
 8004f4a:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004f4e:	3336      	adds	r3, #54	@ 0x36
 8004f50:	781a      	ldrb	r2, [r3, #0]
 8004f52:	6879      	ldr	r1, [r7, #4]
 8004f54:	693b      	ldr	r3, [r7, #16]
 8004f56:	440b      	add	r3, r1
 8004f58:	f503 5324 	add.w	r3, r3, #10496	@ 0x2900
 8004f5c:	3336      	adds	r3, #54	@ 0x36
 8004f5e:	781b      	ldrb	r3, [r3, #0]
 8004f60:	429a      	cmp	r2, r3
 8004f62:	d910      	bls.n	8004f86 <lcdUpdate+0x27e>
			{
				p_args->block_value[i]--;
 8004f64:	687a      	ldr	r2, [r7, #4]
 8004f66:	693b      	ldr	r3, [r7, #16]
 8004f68:	4413      	add	r3, r2
 8004f6a:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004f6e:	3336      	adds	r3, #54	@ 0x36
 8004f70:	781b      	ldrb	r3, [r3, #0]
 8004f72:	3b01      	subs	r3, #1
 8004f74:	b2d9      	uxtb	r1, r3
 8004f76:	687a      	ldr	r2, [r7, #4]
 8004f78:	693b      	ldr	r3, [r7, #16]
 8004f7a:	4413      	add	r3, r2
 8004f7c:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004f80:	3336      	adds	r3, #54	@ 0x36
 8004f82:	460a      	mov	r2, r1
 8004f84:	701a      	strb	r2, [r3, #0]
			}
			for(int j=0; j<p_args->block_value[i]; j++)
 8004f86:	2300      	movs	r3, #0
 8004f88:	60fb      	str	r3, [r7, #12]
 8004f8a:	e00b      	b.n	8004fa4 <lcdUpdate+0x29c>
			{
				drawBlock(i, j, white);
 8004f8c:	693b      	ldr	r3, [r7, #16]
 8004f8e:	b21b      	sxth	r3, r3
 8004f90:	68fa      	ldr	r2, [r7, #12]
 8004f92:	b211      	sxth	r1, r2
 8004f94:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8004f98:	4618      	mov	r0, r3
 8004f9a:	f7ff fe76 	bl	8004c8a <drawBlock>
			for(int j=0; j<p_args->block_value[i]; j++)
 8004f9e:	68fb      	ldr	r3, [r7, #12]
 8004fa0:	3301      	adds	r3, #1
 8004fa2:	60fb      	str	r3, [r7, #12]
 8004fa4:	687a      	ldr	r2, [r7, #4]
 8004fa6:	693b      	ldr	r3, [r7, #16]
 8004fa8:	4413      	add	r3, r2
 8004faa:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8004fae:	3336      	adds	r3, #54	@ 0x36
 8004fb0:	781b      	ldrb	r3, [r3, #0]
 8004fb2:	461a      	mov	r2, r3
 8004fb4:	68fb      	ldr	r3, [r7, #12]
 8004fb6:	4293      	cmp	r3, r2
 8004fb8:	dbe8      	blt.n	8004f8c <lcdUpdate+0x284>
		for(int i=0; i<BLOCK_X_CNT; i++)
 8004fba:	693b      	ldr	r3, [r7, #16]
 8004fbc:	3301      	adds	r3, #1
 8004fbe:	613b      	str	r3, [r7, #16]
 8004fc0:	693b      	ldr	r3, [r7, #16]
 8004fc2:	2b1f      	cmp	r3, #31
 8004fc4:	ddaf      	ble.n	8004f26 <lcdUpdate+0x21e>

      xi++;
    }
#endif

    lcdRequestDraw();
 8004fc6:	f000 ffe9 	bl	8005f9c <lcdRequestDraw>
	}
}
 8004fca:	bf00      	nop
 8004fcc:	3728      	adds	r7, #40	@ 0x28
 8004fce:	46bd      	mov	sp, r7
 8004fd0:	bd80      	pop	{r7, pc}
 8004fd2:	bf00      	nop
 8004fd4:	080388c4 	.word	0x080388c4
 8004fd8:	10624dd3 	.word	0x10624dd3
 8004fdc:	66666667 	.word	0x66666667

08004fe0 <cliI2S>:

void cliI2S(cli_args_t *args)
{
 8004fe0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004fe4:	f5ad 5d29 	sub.w	sp, sp, #10816	@ 0x2a40
 8004fe8:	b081      	sub	sp, #4
 8004fea:	af02      	add	r7, sp, #8
 8004fec:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8004ff0:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 8004ff4:	6018      	str	r0, [r3, #0]
	bool ret = false;
 8004ff6:	2300      	movs	r3, #0
 8004ff8:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8004ffc:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 8005000:	7013      	strb	r3, [r2, #0]
	i2s_cli_t i2s_args;

	memset(i2s_args.block_peak, 0, sizeof(i2s_args.block_peak));
 8005002:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005006:	3b24      	subs	r3, #36	@ 0x24
 8005008:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 800500c:	3316      	adds	r3, #22
 800500e:	2220      	movs	r2, #32
 8005010:	2100      	movs	r1, #0
 8005012:	4618      	mov	r0, r3
 8005014:	f01d f876 	bl	8022104 <memset>
	memset(i2s_args.block_value, 0, sizeof(i2s_args.block_value));
 8005018:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 800501c:	3b24      	subs	r3, #36	@ 0x24
 800501e:	f503 5325 	add.w	r3, r3, #10560	@ 0x2940
 8005022:	3336      	adds	r3, #54	@ 0x36
 8005024:	2220      	movs	r2, #32
 8005026:	2100      	movs	r1, #0
 8005028:	4618      	mov	r0, r3
 800502a:	f01d f86b 	bl	8022104 <memset>
	memset(i2s_args.block_target, 0, sizeof(i2s_args.block_target));
 800502e:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005032:	3b24      	subs	r3, #36	@ 0x24
 8005034:	f503 5324 	add.w	r3, r3, #10496	@ 0x2900
 8005038:	3336      	adds	r3, #54	@ 0x36
 800503a:	2220      	movs	r2, #32
 800503c:	2100      	movs	r1, #0
 800503e:	4618      	mov	r0, r3
 8005040:	f01d f860 	bl	8022104 <memset>

	if(args->argc == 1 && args->isStr(0, "info") == true)
 8005044:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005048:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 800504c:	681b      	ldr	r3, [r3, #0]
 800504e:	881b      	ldrh	r3, [r3, #0]
 8005050:	2b01      	cmp	r3, #1
 8005052:	d139      	bne.n	80050c8 <cliI2S+0xe8>
 8005054:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005058:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 800505c:	681b      	ldr	r3, [r3, #0]
 800505e:	695b      	ldr	r3, [r3, #20]
 8005060:	49c4      	ldr	r1, [pc, #784]	@ (8005374 <cliI2S+0x394>)
 8005062:	2000      	movs	r0, #0
 8005064:	4798      	blx	r3
 8005066:	4603      	mov	r3, r0
 8005068:	2b00      	cmp	r3, #0
 800506a:	d02d      	beq.n	80050c8 <cliI2S+0xe8>
	{
		cliPrintf("i2s init : %d\n", is_init);
 800506c:	4bc2      	ldr	r3, [pc, #776]	@ (8005378 <cliI2S+0x398>)
 800506e:	781b      	ldrb	r3, [r3, #0]
 8005070:	4619      	mov	r1, r3
 8005072:	48c2      	ldr	r0, [pc, #776]	@ (800537c <cliI2S+0x39c>)
 8005074:	f7fe f908 	bl	8003288 <cliPrintf>
    cliPrintf("q_in     : %d\n", q_in);
 8005078:	4bc1      	ldr	r3, [pc, #772]	@ (8005380 <cliI2S+0x3a0>)
 800507a:	681b      	ldr	r3, [r3, #0]
 800507c:	4619      	mov	r1, r3
 800507e:	48c1      	ldr	r0, [pc, #772]	@ (8005384 <cliI2S+0x3a4>)
 8005080:	f7fe f902 	bl	8003288 <cliPrintf>
    cliPrintf("q_out    : %d\n", q_out);
 8005084:	4bc0      	ldr	r3, [pc, #768]	@ (8005388 <cliI2S+0x3a8>)
 8005086:	681b      	ldr	r3, [r3, #0]
 8005088:	4619      	mov	r1, r3
 800508a:	48c0      	ldr	r0, [pc, #768]	@ (800538c <cliI2S+0x3ac>)
 800508c:	f7fe f8fc 	bl	8003288 <cliPrintf>
    cliPrintf("q_buf_len: %d\n", q_buf_len);
 8005090:	4bbf      	ldr	r3, [pc, #764]	@ (8005390 <cliI2S+0x3b0>)
 8005092:	681b      	ldr	r3, [r3, #0]
 8005094:	4619      	mov	r1, r3
 8005096:	48bf      	ldr	r0, [pc, #764]	@ (8005394 <cliI2S+0x3b4>)
 8005098:	f7fe f8f6 	bl	8003288 <cliPrintf>
    cliPrintf("q_len    : %d\n", q_len);
 800509c:	4bbe      	ldr	r3, [pc, #760]	@ (8005398 <cliI2S+0x3b8>)
 800509e:	681b      	ldr	r3, [r3, #0]
 80050a0:	4619      	mov	r1, r3
 80050a2:	48be      	ldr	r0, [pc, #760]	@ (800539c <cliI2S+0x3bc>)
 80050a4:	f7fe f8f0 	bl	8003288 <cliPrintf>
    cliPrintf("time     : %d ms\n", q_len * 10);
 80050a8:	4bbb      	ldr	r3, [pc, #748]	@ (8005398 <cliI2S+0x3b8>)
 80050aa:	681a      	ldr	r2, [r3, #0]
 80050ac:	4613      	mov	r3, r2
 80050ae:	009b      	lsls	r3, r3, #2
 80050b0:	4413      	add	r3, r2
 80050b2:	005b      	lsls	r3, r3, #1
 80050b4:	4619      	mov	r1, r3
 80050b6:	48ba      	ldr	r0, [pc, #744]	@ (80053a0 <cliI2S+0x3c0>)
 80050b8:	f7fe f8e6 	bl	8003288 <cliPrintf>

    ret = true;
 80050bc:	2301      	movs	r3, #1
 80050be:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 80050c2:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 80050c6:	7013      	strb	r3, [r2, #0]
	}

	if(args->argc == 2 && args->isStr(0, "play_wav") == true)
 80050c8:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80050cc:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 80050d0:	681b      	ldr	r3, [r3, #0]
 80050d2:	881b      	ldrh	r3, [r3, #0]
 80050d4:	2b02      	cmp	r3, #2
 80050d6:	f040 82bf 	bne.w	8005658 <cliI2S+0x678>
 80050da:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80050de:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 80050e2:	681b      	ldr	r3, [r3, #0]
 80050e4:	695b      	ldr	r3, [r3, #20]
 80050e6:	49af      	ldr	r1, [pc, #700]	@ (80053a4 <cliI2S+0x3c4>)
 80050e8:	2000      	movs	r0, #0
 80050ea:	4798      	blx	r3
 80050ec:	4603      	mov	r3, r0
 80050ee:	2b00      	cmp	r3, #0
 80050f0:	f000 82b2 	beq.w	8005658 <cliI2S+0x678>
	{
 80050f4:	466b      	mov	r3, sp
 80050f6:	461e      	mov	r6, r3
		char *file_name;
		FILE *fp;
		wavfile_header_t header;
		uint32_t r_len;

		file_name = args->getStr(1);
 80050f8:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80050fc:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 8005100:	681b      	ldr	r3, [r3, #0]
 8005102:	691b      	ldr	r3, [r3, #16]
 8005104:	2001      	movs	r0, #1
 8005106:	4798      	blx	r3
 8005108:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800510c:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 8005110:	6018      	str	r0, [r3, #0]

		cliPrintf("Filename			: %s\n", file_name);
 8005112:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005116:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 800511a:	6819      	ldr	r1, [r3, #0]
 800511c:	48a2      	ldr	r0, [pc, #648]	@ (80053a8 <cliI2S+0x3c8>)
 800511e:	f7fe f8b3 	bl	8003288 <cliPrintf>

		fp = fopen(file_name, "r");
 8005122:	49a2      	ldr	r1, [pc, #648]	@ (80053ac <cliI2S+0x3cc>)
 8005124:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005128:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 800512c:	6818      	ldr	r0, [r3, #0]
 800512e:	f7fe fd3d 	bl	8003bac <ob_fopen>
 8005132:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005136:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 800513a:	6018      	str	r0, [r3, #0]
		if(fp == NULL)
 800513c:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005140:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8005144:	681b      	ldr	r3, [r3, #0]
 8005146:	2b00      	cmp	r3, #0
 8005148:	d10a      	bne.n	8005160 <cliI2S+0x180>
		{
			cliPrintf("fopen fail : %s\n", file_name);
 800514a:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800514e:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 8005152:	6819      	ldr	r1, [r3, #0]
 8005154:	4896      	ldr	r0, [pc, #600]	@ (80053b0 <cliI2S+0x3d0>)
 8005156:	f7fe f897 	bl	8003288 <cliPrintf>
			return;
 800515a:	46b5      	mov	sp, r6
 800515c:	f000 bdfd 	b.w	8005d5a <cliI2S+0xd7a>
		}
		fread(&header, sizeof(wavfile_header_t), 1, fp);
 8005160:	f107 0038 	add.w	r0, r7, #56	@ 0x38
 8005164:	382c      	subs	r0, #44	@ 0x2c
 8005166:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800516a:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 800516e:	681b      	ldr	r3, [r3, #0]
 8005170:	2201      	movs	r2, #1
 8005172:	212c      	movs	r1, #44	@ 0x2c
 8005174:	f7fe fd87 	bl	8003c86 <ob_fread>

    cliPrintf("ChunkSize     : %d\n", header.ChunkSize);
 8005178:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800517c:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 8005180:	685b      	ldr	r3, [r3, #4]
 8005182:	4619      	mov	r1, r3
 8005184:	488b      	ldr	r0, [pc, #556]	@ (80053b4 <cliI2S+0x3d4>)
 8005186:	f7fe f87f 	bl	8003288 <cliPrintf>
    cliPrintf("Format        : %c%c%c%c\n", header.Format[0], header.Format[1], header.Format[2], header.Format[3]);
 800518a:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800518e:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 8005192:	7a1b      	ldrb	r3, [r3, #8]
 8005194:	4619      	mov	r1, r3
 8005196:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800519a:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 800519e:	7a5b      	ldrb	r3, [r3, #9]
 80051a0:	461a      	mov	r2, r3
 80051a2:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80051a6:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80051aa:	7a9b      	ldrb	r3, [r3, #10]
 80051ac:	4618      	mov	r0, r3
 80051ae:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80051b2:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80051b6:	7adb      	ldrb	r3, [r3, #11]
 80051b8:	9300      	str	r3, [sp, #0]
 80051ba:	4603      	mov	r3, r0
 80051bc:	487e      	ldr	r0, [pc, #504]	@ (80053b8 <cliI2S+0x3d8>)
 80051be:	f7fe f863 	bl	8003288 <cliPrintf>
    cliPrintf("Subchunk1Size : %d\n", header.Subchunk1Size);
 80051c2:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80051c6:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80051ca:	691b      	ldr	r3, [r3, #16]
 80051cc:	4619      	mov	r1, r3
 80051ce:	487b      	ldr	r0, [pc, #492]	@ (80053bc <cliI2S+0x3dc>)
 80051d0:	f7fe f85a 	bl	8003288 <cliPrintf>
    cliPrintf("AudioFormat   : %d\n", header.AudioFormat);
 80051d4:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80051d8:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80051dc:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 80051e0:	4619      	mov	r1, r3
 80051e2:	4877      	ldr	r0, [pc, #476]	@ (80053c0 <cliI2S+0x3e0>)
 80051e4:	f7fe f850 	bl	8003288 <cliPrintf>
    cliPrintf("NumChannels   : %d\n", header.NumChannels);
 80051e8:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80051ec:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80051f0:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80051f4:	4619      	mov	r1, r3
 80051f6:	4873      	ldr	r0, [pc, #460]	@ (80053c4 <cliI2S+0x3e4>)
 80051f8:	f7fe f846 	bl	8003288 <cliPrintf>
    cliPrintf("SampleRate    : %d\n", header.SampleRate);
 80051fc:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005200:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 8005204:	699b      	ldr	r3, [r3, #24]
 8005206:	4619      	mov	r1, r3
 8005208:	486f      	ldr	r0, [pc, #444]	@ (80053c8 <cliI2S+0x3e8>)
 800520a:	f7fe f83d 	bl	8003288 <cliPrintf>
    cliPrintf("ByteRate      : %d\n", header.ByteRate);
 800520e:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005212:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 8005216:	69db      	ldr	r3, [r3, #28]
 8005218:	4619      	mov	r1, r3
 800521a:	486c      	ldr	r0, [pc, #432]	@ (80053cc <cliI2S+0x3ec>)
 800521c:	f7fe f834 	bl	8003288 <cliPrintf>
    cliPrintf("BlockAlign    : %d\n", header.BlockAlign);
 8005220:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005224:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 8005228:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 800522c:	4619      	mov	r1, r3
 800522e:	4868      	ldr	r0, [pc, #416]	@ (80053d0 <cliI2S+0x3f0>)
 8005230:	f7fe f82a 	bl	8003288 <cliPrintf>
    cliPrintf("BitsPerSample : %d\n", header.BitsPerSample);
 8005234:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005238:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 800523c:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	@ 0x22
 8005240:	4619      	mov	r1, r3
 8005242:	4864      	ldr	r0, [pc, #400]	@ (80053d4 <cliI2S+0x3f4>)
 8005244:	f7fe f820 	bl	8003288 <cliPrintf>
    cliPrintf("Subchunk2Size : %d\n", header.Subchunk2Size);
 8005248:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800524c:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 8005250:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005252:	4619      	mov	r1, r3
 8005254:	4860      	ldr	r0, [pc, #384]	@ (80053d8 <cliI2S+0x3f8>)
 8005256:	f7fe f817 	bl	8003288 <cliPrintf>

    lcdClearBuffer(black);
 800525a:	2000      	movs	r0, #0
 800525c:	f000 fe58 	bl	8005f10 <lcdClearBuffer>
    lcdSetFont(LCD_FONT_HAN);
 8005260:	2003      	movs	r0, #3
 8005262:	f001 f9f3 	bl	800664c <lcdSetFont>
    lcdPrintf(24, 16*0, white, "WAV Play");
 8005266:	4b5d      	ldr	r3, [pc, #372]	@ (80053dc <cliI2S+0x3fc>)
 8005268:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800526c:	2100      	movs	r1, #0
 800526e:	2018      	movs	r0, #24
 8005270:	f001 f81c 	bl	80062ac <lcdPrintf>

    lcdSetFont(LCD_FONT_07x10);
 8005274:	2000      	movs	r0, #0
 8005276:	f001 f9e9 	bl	800664c <lcdSetFont>
    lcdPrintf(20,18*1+10*0, white, "%s", file_name);
 800527a:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800527e:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 8005282:	681b      	ldr	r3, [r3, #0]
 8005284:	9300      	str	r3, [sp, #0]
 8005286:	4b56      	ldr	r3, [pc, #344]	@ (80053e0 <cliI2S+0x400>)
 8005288:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800528c:	2112      	movs	r1, #18
 800528e:	2014      	movs	r0, #20
 8005290:	f001 f80c 	bl	80062ac <lcdPrintf>
    lcdPrintf(20,18*1+10*1, white, "%d Khz", header.SampleRate/1000);
 8005294:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005298:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 800529c:	699b      	ldr	r3, [r3, #24]
 800529e:	4a51      	ldr	r2, [pc, #324]	@ (80053e4 <cliI2S+0x404>)
 80052a0:	fb82 1203 	smull	r1, r2, r2, r3
 80052a4:	1192      	asrs	r2, r2, #6
 80052a6:	17db      	asrs	r3, r3, #31
 80052a8:	1ad3      	subs	r3, r2, r3
 80052aa:	9300      	str	r3, [sp, #0]
 80052ac:	4b4e      	ldr	r3, [pc, #312]	@ (80053e8 <cliI2S+0x408>)
 80052ae:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80052b2:	211c      	movs	r1, #28
 80052b4:	2014      	movs	r0, #20
 80052b6:	f000 fff9 	bl	80062ac <lcdPrintf>
    lcdPrintf(20,18*1+10*2, white, "%d ch", header.NumChannels);
 80052ba:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80052be:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80052c2:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80052c6:	9300      	str	r3, [sp, #0]
 80052c8:	4b48      	ldr	r3, [pc, #288]	@ (80053ec <cliI2S+0x40c>)
 80052ca:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80052ce:	2126      	movs	r1, #38	@ 0x26
 80052d0:	2014      	movs	r0, #20
 80052d2:	f000 ffeb 	bl	80062ac <lcdPrintf>
    lcdRequestDraw();
 80052d6:	f000 fe61 	bl	8005f9c <lcdRequestDraw>

    i2sSetSampleRate(_DEF_I2S1, header.SampleRate);
 80052da:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80052de:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80052e2:	699b      	ldr	r3, [r3, #24]
 80052e4:	4619      	mov	r1, r3
 80052e6:	2002      	movs	r0, #2
 80052e8:	f7ff fb06 	bl	80048f8 <i2sSetSampleRate>

    i2sStart();
 80052ec:	f7ff fb52 	bl	8004994 <i2sStart>

    r_len = q_buf_len;
 80052f0:	4b27      	ldr	r3, [pc, #156]	@ (8005390 <cliI2S+0x3b0>)
 80052f2:	681b      	ldr	r3, [r3, #0]
 80052f4:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 80052f8:	f102 0220 	add.w	r2, r2, #32
 80052fc:	6013      	str	r3, [r2, #0]

    int16_t buf_frame[q_buf_len * 2];
 80052fe:	4b24      	ldr	r3, [pc, #144]	@ (8005390 <cliI2S+0x3b0>)
 8005300:	681b      	ldr	r3, [r3, #0]
 8005302:	0059      	lsls	r1, r3, #1
 8005304:	460b      	mov	r3, r1
 8005306:	3b01      	subs	r3, #1
 8005308:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 800530c:	f102 021c 	add.w	r2, r2, #28
 8005310:	6013      	str	r3, [r2, #0]
 8005312:	2300      	movs	r3, #0
 8005314:	4688      	mov	r8, r1
 8005316:	4699      	mov	r9, r3
 8005318:	f04f 0200 	mov.w	r2, #0
 800531c:	f04f 0300 	mov.w	r3, #0
 8005320:	ea4f 1309 	mov.w	r3, r9, lsl #4
 8005324:	ea43 7318 	orr.w	r3, r3, r8, lsr #28
 8005328:	ea4f 1208 	mov.w	r2, r8, lsl #4
 800532c:	2300      	movs	r3, #0
 800532e:	460c      	mov	r4, r1
 8005330:	461d      	mov	r5, r3
 8005332:	f04f 0200 	mov.w	r2, #0
 8005336:	f04f 0300 	mov.w	r3, #0
 800533a:	012b      	lsls	r3, r5, #4
 800533c:	ea43 7314 	orr.w	r3, r3, r4, lsr #28
 8005340:	0122      	lsls	r2, r4, #4
 8005342:	004b      	lsls	r3, r1, #1
 8005344:	3307      	adds	r3, #7
 8005346:	08db      	lsrs	r3, r3, #3
 8005348:	00db      	lsls	r3, r3, #3
 800534a:	ebad 0d03 	sub.w	sp, sp, r3
 800534e:	ab02      	add	r3, sp, #8
 8005350:	3301      	adds	r3, #1
 8005352:	085b      	lsrs	r3, r3, #1
 8005354:	005b      	lsls	r3, r3, #1
 8005356:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 800535a:	f102 0218 	add.w	r2, r2, #24
 800535e:	6013      	str	r3, [r2, #0]

    fseek(fp, sizeof(wavfile_header_t), SEEK_SET);
 8005360:	2200      	movs	r2, #0
 8005362:	212c      	movs	r1, #44	@ 0x2c
 8005364:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005368:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 800536c:	6818      	ldr	r0, [r3, #0]
 800536e:	f7fe fca9 	bl	8003cc4 <ob_fseek>

    while(cliKeepLoop())
 8005372:	e159      	b.n	8005628 <cliI2S+0x648>
 8005374:	08024538 	.word	0x08024538
 8005378:	200023bc 	.word	0x200023bc
 800537c:	08024540 	.word	0x08024540
 8005380:	200023c0 	.word	0x200023c0
 8005384:	08024550 	.word	0x08024550
 8005388:	200023c4 	.word	0x200023c4
 800538c:	08024560 	.word	0x08024560
 8005390:	200023cc 	.word	0x200023cc
 8005394:	08024570 	.word	0x08024570
 8005398:	200023c8 	.word	0x200023c8
 800539c:	08024580 	.word	0x08024580
 80053a0:	08024590 	.word	0x08024590
 80053a4:	080245a4 	.word	0x080245a4
 80053a8:	080245b0 	.word	0x080245b0
 80053ac:	080245c4 	.word	0x080245c4
 80053b0:	080245c8 	.word	0x080245c8
 80053b4:	080245dc 	.word	0x080245dc
 80053b8:	080245f0 	.word	0x080245f0
 80053bc:	0802460c 	.word	0x0802460c
 80053c0:	08024620 	.word	0x08024620
 80053c4:	08024634 	.word	0x08024634
 80053c8:	08024648 	.word	0x08024648
 80053cc:	0802465c 	.word	0x0802465c
 80053d0:	08024670 	.word	0x08024670
 80053d4:	08024684 	.word	0x08024684
 80053d8:	08024698 	.word	0x08024698
 80053dc:	080246ac 	.word	0x080246ac
 80053e0:	080246b8 	.word	0x080246b8
 80053e4:	10624dd3 	.word	0x10624dd3
 80053e8:	080246bc 	.word	0x080246bc
 80053ec:	080246c4 	.word	0x080246c4
    {
    	uint32_t buf_len;
    	int len;

    	buf_len = ((q_len + q_in - q_out) % q_len);
 80053f0:	4bbe      	ldr	r3, [pc, #760]	@ (80056ec <cliI2S+0x70c>)
 80053f2:	681a      	ldr	r2, [r3, #0]
 80053f4:	4bbe      	ldr	r3, [pc, #760]	@ (80056f0 <cliI2S+0x710>)
 80053f6:	681b      	ldr	r3, [r3, #0]
 80053f8:	441a      	add	r2, r3
 80053fa:	4bbe      	ldr	r3, [pc, #760]	@ (80056f4 <cliI2S+0x714>)
 80053fc:	681b      	ldr	r3, [r3, #0]
 80053fe:	1ad3      	subs	r3, r2, r3
 8005400:	4aba      	ldr	r2, [pc, #744]	@ (80056ec <cliI2S+0x70c>)
 8005402:	6812      	ldr	r2, [r2, #0]
 8005404:	fbb3 f1f2 	udiv	r1, r3, r2
 8005408:	fb01 f202 	mul.w	r2, r1, r2
 800540c:	1a9b      	subs	r3, r3, r2
 800540e:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005412:	f102 0214 	add.w	r2, r2, #20
 8005416:	6013      	str	r3, [r2, #0]
    	buf_len = (q_len - buf_len) - 1;
 8005418:	4bb4      	ldr	r3, [pc, #720]	@ (80056ec <cliI2S+0x70c>)
 800541a:	681a      	ldr	r2, [r3, #0]
 800541c:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005420:	f103 0314 	add.w	r3, r3, #20
 8005424:	681b      	ldr	r3, [r3, #0]
 8005426:	1ad3      	subs	r3, r2, r3
 8005428:	3b01      	subs	r3, #1
 800542a:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 800542e:	f102 0214 	add.w	r2, r2, #20
 8005432:	6013      	str	r3, [r2, #0]

    	if(buf_len > 0)
 8005434:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005438:	f103 0314 	add.w	r3, r3, #20
 800543c:	681b      	ldr	r3, [r3, #0]
 800543e:	2b00      	cmp	r3, #0
 8005440:	f000 80f2 	beq.w	8005628 <cliI2S+0x648>
    	{
    		len = fread(buf_frame, r_len, 2*header.NumChannels, fp);
 8005444:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005448:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 800544c:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8005450:	005b      	lsls	r3, r3, #1
 8005452:	461a      	mov	r2, r3
 8005454:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005458:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 800545c:	681b      	ldr	r3, [r3, #0]
 800545e:	f507 5128 	add.w	r1, r7, #10752	@ 0x2a00
 8005462:	f101 0120 	add.w	r1, r1, #32
 8005466:	6809      	ldr	r1, [r1, #0]
 8005468:	f507 5028 	add.w	r0, r7, #10752	@ 0x2a00
 800546c:	f100 0018 	add.w	r0, r0, #24
 8005470:	6800      	ldr	r0, [r0, #0]
 8005472:	f7fe fc08 	bl	8003c86 <ob_fread>
 8005476:	4603      	mov	r3, r0
 8005478:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 800547c:	f102 0210 	add.w	r2, r2, #16
 8005480:	6013      	str	r3, [r2, #0]

    		if (len != r_len*2*header.NumChannels)
 8005482:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005486:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 800548a:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800548e:	461a      	mov	r2, r3
 8005490:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005494:	f103 0320 	add.w	r3, r3, #32
 8005498:	681b      	ldr	r3, [r3, #0]
 800549a:	fb02 f303 	mul.w	r3, r2, r3
 800549e:	005a      	lsls	r2, r3, #1
 80054a0:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80054a4:	f103 0310 	add.w	r3, r3, #16
 80054a8:	681b      	ldr	r3, [r3, #0]
 80054aa:	429a      	cmp	r2, r3
 80054ac:	f040 80c3 	bne.w	8005636 <cliI2S+0x656>
    			break;
    		}

    		uint32_t q_offset;

    		q_offset = q_in*q_buf_len;
 80054b0:	4b8f      	ldr	r3, [pc, #572]	@ (80056f0 <cliI2S+0x710>)
 80054b2:	681b      	ldr	r3, [r3, #0]
 80054b4:	4a90      	ldr	r2, [pc, #576]	@ (80056f8 <cliI2S+0x718>)
 80054b6:	6812      	ldr	r2, [r2, #0]
 80054b8:	fb02 f303 	mul.w	r3, r2, r3
 80054bc:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 80054c0:	f102 020c 	add.w	r2, r2, #12
 80054c4:	6013      	str	r3, [r2, #0]

    		for (int i=0; i<r_len; i++)
 80054c6:	2300      	movs	r3, #0
 80054c8:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 80054cc:	f102 0230 	add.w	r2, r2, #48	@ 0x30
 80054d0:	6013      	str	r3, [r2, #0]
 80054d2:	e082      	b.n	80055da <cliI2S+0x5fa>
    		{
    			if (header.NumChannels == 2)
 80054d4:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80054d8:	f6a3 232c 	subw	r3, r3, #2604	@ 0xa2c
 80054dc:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80054e0:	2b02      	cmp	r3, #2
 80054e2:	d139      	bne.n	8005558 <cliI2S+0x578>
    		  {
    				q_buf[q_offset + i].left  = buf_frame[i*2 + 0];
 80054e4:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80054e8:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 80054ec:	681b      	ldr	r3, [r3, #0]
 80054ee:	0059      	lsls	r1, r3, #1
 80054f0:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80054f4:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 80054f8:	681a      	ldr	r2, [r3, #0]
 80054fa:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80054fe:	f103 030c 	add.w	r3, r3, #12
 8005502:	681b      	ldr	r3, [r3, #0]
 8005504:	4413      	add	r3, r2
 8005506:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 800550a:	f102 0218 	add.w	r2, r2, #24
 800550e:	6812      	ldr	r2, [r2, #0]
 8005510:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
 8005514:	4a79      	ldr	r2, [pc, #484]	@ (80056fc <cliI2S+0x71c>)
 8005516:	f822 1023 	strh.w	r1, [r2, r3, lsl #2]
    		    q_buf[q_offset + i].right = buf_frame[i*2 + 1];
 800551a:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800551e:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8005522:	681b      	ldr	r3, [r3, #0]
 8005524:	005b      	lsls	r3, r3, #1
 8005526:	1c59      	adds	r1, r3, #1
 8005528:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800552c:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8005530:	681a      	ldr	r2, [r3, #0]
 8005532:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005536:	f103 030c 	add.w	r3, r3, #12
 800553a:	681b      	ldr	r3, [r3, #0]
 800553c:	4413      	add	r3, r2
 800553e:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005542:	f102 0218 	add.w	r2, r2, #24
 8005546:	6812      	ldr	r2, [r2, #0]
 8005548:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
 800554c:	4a6b      	ldr	r2, [pc, #428]	@ (80056fc <cliI2S+0x71c>)
 800554e:	009b      	lsls	r3, r3, #2
 8005550:	4413      	add	r3, r2
 8005552:	460a      	mov	r2, r1
 8005554:	805a      	strh	r2, [r3, #2]
 8005556:	e035      	b.n	80055c4 <cliI2S+0x5e4>
    		  }
    		  else
    		  {
    		  	q_buf[q_offset + i].left  = buf_frame[i];
 8005558:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800555c:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8005560:	681a      	ldr	r2, [r3, #0]
 8005562:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005566:	f103 030c 	add.w	r3, r3, #12
 800556a:	681b      	ldr	r3, [r3, #0]
 800556c:	4413      	add	r3, r2
 800556e:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005572:	f102 0218 	add.w	r2, r2, #24
 8005576:	6812      	ldr	r2, [r2, #0]
 8005578:	f507 5128 	add.w	r1, r7, #10752	@ 0x2a00
 800557c:	f101 0130 	add.w	r1, r1, #48	@ 0x30
 8005580:	6809      	ldr	r1, [r1, #0]
 8005582:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
 8005586:	4a5d      	ldr	r2, [pc, #372]	@ (80056fc <cliI2S+0x71c>)
 8005588:	f822 1023 	strh.w	r1, [r2, r3, lsl #2]
    		    q_buf[q_offset + i].right = buf_frame[i];
 800558c:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005590:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8005594:	681a      	ldr	r2, [r3, #0]
 8005596:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800559a:	f103 030c 	add.w	r3, r3, #12
 800559e:	681b      	ldr	r3, [r3, #0]
 80055a0:	4413      	add	r3, r2
 80055a2:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 80055a6:	f102 0218 	add.w	r2, r2, #24
 80055aa:	6812      	ldr	r2, [r2, #0]
 80055ac:	f507 5128 	add.w	r1, r7, #10752	@ 0x2a00
 80055b0:	f101 0130 	add.w	r1, r1, #48	@ 0x30
 80055b4:	6809      	ldr	r1, [r1, #0]
 80055b6:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
 80055ba:	4a50      	ldr	r2, [pc, #320]	@ (80056fc <cliI2S+0x71c>)
 80055bc:	009b      	lsls	r3, r3, #2
 80055be:	4413      	add	r3, r2
 80055c0:	460a      	mov	r2, r1
 80055c2:	805a      	strh	r2, [r3, #2]
    		for (int i=0; i<r_len; i++)
 80055c4:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80055c8:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 80055cc:	681b      	ldr	r3, [r3, #0]
 80055ce:	3301      	adds	r3, #1
 80055d0:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 80055d4:	f102 0230 	add.w	r2, r2, #48	@ 0x30
 80055d8:	6013      	str	r3, [r2, #0]
 80055da:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80055de:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 80055e2:	681b      	ldr	r3, [r3, #0]
 80055e4:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 80055e8:	f102 0220 	add.w	r2, r2, #32
 80055ec:	6812      	ldr	r2, [r2, #0]
 80055ee:	429a      	cmp	r2, r3
 80055f0:	f63f af70 	bhi.w	80054d4 <cliI2S+0x4f4>
    		  }
    		}

    		if (((q_in + 1) % q_len) != q_out)
 80055f4:	4b3e      	ldr	r3, [pc, #248]	@ (80056f0 <cliI2S+0x710>)
 80055f6:	681b      	ldr	r3, [r3, #0]
 80055f8:	3301      	adds	r3, #1
 80055fa:	4a3c      	ldr	r2, [pc, #240]	@ (80056ec <cliI2S+0x70c>)
 80055fc:	6812      	ldr	r2, [r2, #0]
 80055fe:	fbb3 f1f2 	udiv	r1, r3, r2
 8005602:	fb01 f202 	mul.w	r2, r1, r2
 8005606:	1a9a      	subs	r2, r3, r2
 8005608:	4b3a      	ldr	r3, [pc, #232]	@ (80056f4 <cliI2S+0x714>)
 800560a:	681b      	ldr	r3, [r3, #0]
 800560c:	429a      	cmp	r2, r3
 800560e:	d00b      	beq.n	8005628 <cliI2S+0x648>
    		{
    			q_in = (q_in+1) % q_len;
 8005610:	4b37      	ldr	r3, [pc, #220]	@ (80056f0 <cliI2S+0x710>)
 8005612:	681b      	ldr	r3, [r3, #0]
 8005614:	3301      	adds	r3, #1
 8005616:	4a35      	ldr	r2, [pc, #212]	@ (80056ec <cliI2S+0x70c>)
 8005618:	6812      	ldr	r2, [r2, #0]
 800561a:	fbb3 f1f2 	udiv	r1, r3, r2
 800561e:	fb01 f202 	mul.w	r2, r1, r2
 8005622:	1a9b      	subs	r3, r3, r2
 8005624:	4a32      	ldr	r2, [pc, #200]	@ (80056f0 <cliI2S+0x710>)
 8005626:	6013      	str	r3, [r2, #0]
    while(cliKeepLoop())
 8005628:	f7fd ff28 	bl	800347c <cliKeepLoop>
 800562c:	4603      	mov	r3, r0
 800562e:	2b00      	cmp	r3, #0
 8005630:	f47f aede 	bne.w	80053f0 <cliI2S+0x410>
 8005634:	e000      	b.n	8005638 <cliI2S+0x658>
    			break;
 8005636:	bf00      	nop
    		}
    	}
    }

    i2sStop();
 8005638:	f7ff f9dc 	bl	80049f4 <i2sStop>

    fclose(fp);
 800563c:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005640:	f103 0324 	add.w	r3, r3, #36	@ 0x24
 8005644:	6818      	ldr	r0, [r3, #0]
 8005646:	f7fe fb05 	bl	8003c54 <ob_fclose>

    ret = true;
 800564a:	2301      	movs	r3, #1
 800564c:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005650:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 8005654:	7013      	strb	r3, [r2, #0]
 8005656:	46b5      	mov	sp, r6
	}

	if (args->argc == 2 && args->isStr(0, "play_mp3") == true)
 8005658:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800565c:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 8005660:	681b      	ldr	r3, [r3, #0]
 8005662:	881b      	ldrh	r3, [r3, #0]
 8005664:	2b02      	cmp	r3, #2
 8005666:	f040 8365 	bne.w	8005d34 <cliI2S+0xd54>
 800566a:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800566e:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 8005672:	681b      	ldr	r3, [r3, #0]
 8005674:	695b      	ldr	r3, [r3, #20]
 8005676:	4922      	ldr	r1, [pc, #136]	@ (8005700 <cliI2S+0x720>)
 8005678:	2000      	movs	r0, #0
 800567a:	4798      	blx	r3
 800567c:	4603      	mov	r3, r0
 800567e:	2b00      	cmp	r3, #0
 8005680:	f000 8358 	beq.w	8005d34 <cliI2S+0xd54>
	  {
	    HMP3Decoder h_dec;
	    char *file_name;

	    file_name = args->getStr(1);
 8005684:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005688:	f6a3 2334 	subw	r3, r3, #2612	@ 0xa34
 800568c:	681b      	ldr	r3, [r3, #0]
 800568e:	691b      	ldr	r3, [r3, #16]
 8005690:	2001      	movs	r0, #1
 8005692:	4798      	blx	r3
 8005694:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005698:	f103 0308 	add.w	r3, r3, #8
 800569c:	6018      	str	r0, [r3, #0]

	    h_dec = MP3InitDecoder();
 800569e:	f019 f9cb 	bl	801ea38 <MP3InitDecoder>
 80056a2:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80056a6:	f103 0304 	add.w	r3, r3, #4
 80056aa:	6018      	str	r0, [r3, #0]

	    if (h_dec != 0)
 80056ac:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80056b0:	f103 0304 	add.w	r3, r3, #4
 80056b4:	681b      	ldr	r3, [r3, #0]
 80056b6:	2b00      	cmp	r3, #0
 80056b8:	f000 833c 	beq.w	8005d34 <cliI2S+0xd54>
	    {
	      MP3FrameInfo frameInfo;
	      FILE *fp;

	      cliPrintf("init ok\n");
 80056bc:	4811      	ldr	r0, [pc, #68]	@ (8005704 <cliI2S+0x724>)
 80056be:	f7fd fde3 	bl	8003288 <cliPrintf>

	      fp = fopen(file_name, "r");
 80056c2:	4911      	ldr	r1, [pc, #68]	@ (8005708 <cliI2S+0x728>)
 80056c4:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80056c8:	f103 0308 	add.w	r3, r3, #8
 80056cc:	6818      	ldr	r0, [r3, #0]
 80056ce:	f7fe fa6d 	bl	8003bac <ob_fopen>
 80056d2:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80056d6:	6018      	str	r0, [r3, #0]

	      if( fp == NULL )
 80056d8:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80056dc:	681b      	ldr	r3, [r3, #0]
 80056de:	2b00      	cmp	r3, #0
 80056e0:	d116      	bne.n	8005710 <cliI2S+0x730>
	      {
	        cliPrintf( "File is null\n" );
 80056e2:	480a      	ldr	r0, [pc, #40]	@ (800570c <cliI2S+0x72c>)
 80056e4:	f7fd fdd0 	bl	8003288 <cliPrintf>
 80056e8:	e337      	b.n	8005d5a <cliI2S+0xd7a>
 80056ea:	bf00      	nop
 80056ec:	200023c8 	.word	0x200023c8
 80056f0:	200023c0 	.word	0x200023c0
 80056f4:	200023c4 	.word	0x200023c4
 80056f8:	200023cc 	.word	0x200023cc
 80056fc:	200023d0 	.word	0x200023d0
 8005700:	080246cc 	.word	0x080246cc
 8005704:	080246d8 	.word	0x080246d8
 8005708:	080245c4 	.word	0x080245c4
 800570c:	080246e4 	.word	0x080246e4
	        return;
	      }
	      else
	      {
	        cliPrintf( "File is not null\n" );
 8005710:	48a2      	ldr	r0, [pc, #648]	@ (800599c <cliI2S+0x9bc>)
 8005712:	f7fd fdb9 	bl	8003288 <cliPrintf>
	      int err;
	      int n_read;

	      //fread( buf, 4096, 1, fp );

	      i2s_args.bytes_left = 0;
 8005716:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800571a:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 800571e:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005722:	461a      	mov	r2, r3
 8005724:	2300      	movs	r3, #0
 8005726:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
	      i2s_args.read_ptr = i2s_args.read_buf;
 800572a:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800572e:	f6a3 12e4 	subw	r2, r3, #2532	@ 0x9e4
 8005732:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005736:	3b24      	subs	r3, #36	@ 0x24
 8005738:	f8c2 3f28 	str.w	r3, [r2, #3880]	@ 0xf28

	      n_read = fillReadBuffer(i2s_args.read_buf, i2s_args.read_ptr, READBUF_SIZE, i2s_args.bytes_left, fp);
 800573c:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005740:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005744:	f8d3 1f28 	ldr.w	r1, [r3, #3880]	@ 0xf28
 8005748:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800574c:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005750:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005754:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 8005758:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 800575c:	3824      	subs	r0, #36	@ 0x24
 800575e:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005762:	681b      	ldr	r3, [r3, #0]
 8005764:	9300      	str	r3, [sp, #0]
 8005766:	4613      	mov	r3, r2
 8005768:	f240 7294 	movw	r2, #1940	@ 0x794
 800576c:	f7ff fa5a 	bl	8004c24 <fillReadBuffer>
 8005770:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005774:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005778:	6018      	str	r0, [r3, #0]
	      i2s_args.bytes_left += n_read;
 800577a:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800577e:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005782:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005786:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 800578a:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 800578e:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005792:	681b      	ldr	r3, [r3, #0]
 8005794:	4413      	add	r3, r2
 8005796:	f607 2238 	addw	r2, r7, #2616	@ 0xa38
 800579a:	f6a2 12e4 	subw	r2, r2, #2532	@ 0x9e4
 800579e:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 80057a2:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
	      i2s_args.read_ptr = i2s_args.read_buf;
 80057a6:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80057aa:	f6a3 12e4 	subw	r2, r3, #2532	@ 0x9e4
 80057ae:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 80057b2:	3b24      	subs	r3, #36	@ 0x24
 80057b4:	f8c2 3f28 	str.w	r3, [r2, #3880]	@ 0xf28

	      n_read = MP3FindSyncWord(i2s_args.read_ptr, READBUF_SIZE);
 80057b8:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80057bc:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 80057c0:	f8d3 3f28 	ldr.w	r3, [r3, #3880]	@ 0xf28
 80057c4:	f240 7194 	movw	r1, #1940	@ 0x794
 80057c8:	4618      	mov	r0, r3
 80057ca:	f019 f937 	bl	801ea3c <MP3FindSyncWord>
 80057ce:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 80057d2:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 80057d6:	6018      	str	r0, [r3, #0]
	      cliPrintf("Offset: %d\n", n_read);
 80057d8:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 80057dc:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 80057e0:	6819      	ldr	r1, [r3, #0]
 80057e2:	486f      	ldr	r0, [pc, #444]	@ (80059a0 <cliI2S+0x9c0>)
 80057e4:	f7fd fd50 	bl	8003288 <cliPrintf>

	      i2s_args.bytes_left -= n_read;
 80057e8:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80057ec:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 80057f0:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 80057f4:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 80057f8:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 80057fc:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005800:	681b      	ldr	r3, [r3, #0]
 8005802:	1ad3      	subs	r3, r2, r3
 8005804:	f607 2238 	addw	r2, r7, #2616	@ 0xa38
 8005808:	f6a2 12e4 	subw	r2, r2, #2532	@ 0x9e4
 800580c:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 8005810:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
	      i2s_args.read_ptr += n_read;
 8005814:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005818:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 800581c:	f8d3 2f28 	ldr.w	r2, [r3, #3880]	@ 0xf28
 8005820:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005824:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005828:	681b      	ldr	r3, [r3, #0]
 800582a:	441a      	add	r2, r3
 800582c:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005830:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005834:	f8c3 2f28 	str.w	r2, [r3, #3880]	@ 0xf28

	      n_read = fillReadBuffer(i2s_args.read_buf, i2s_args.read_ptr, READBUF_SIZE, i2s_args.bytes_left, fp);
 8005838:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800583c:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005840:	f8d3 1f28 	ldr.w	r1, [r3, #3880]	@ 0xf28
 8005844:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005848:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 800584c:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005850:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 8005854:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 8005858:	3824      	subs	r0, #36	@ 0x24
 800585a:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 800585e:	681b      	ldr	r3, [r3, #0]
 8005860:	9300      	str	r3, [sp, #0]
 8005862:	4613      	mov	r3, r2
 8005864:	f240 7294 	movw	r2, #1940	@ 0x794
 8005868:	f7ff f9dc 	bl	8004c24 <fillReadBuffer>
 800586c:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005870:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005874:	6018      	str	r0, [r3, #0]
	      i2s_args.bytes_left += n_read;
 8005876:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800587a:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 800587e:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005882:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 8005886:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 800588a:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 800588e:	681b      	ldr	r3, [r3, #0]
 8005890:	4413      	add	r3, r2
 8005892:	f607 2238 	addw	r2, r7, #2616	@ 0xa38
 8005896:	f6a2 12e4 	subw	r2, r2, #2532	@ 0x9e4
 800589a:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 800589e:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
	      i2s_args.read_ptr = i2s_args.read_buf;
 80058a2:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80058a6:	f6a3 12e4 	subw	r2, r3, #2532	@ 0x9e4
 80058aa:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 80058ae:	3b24      	subs	r3, #36	@ 0x24
 80058b0:	f8c2 3f28 	str.w	r3, [r2, #3880]	@ 0xf28

	      err = MP3GetNextFrameInfo(h_dec, &frameInfo, i2s_args.read_ptr);
 80058b4:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80058b8:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 80058bc:	f8d3 2f28 	ldr.w	r2, [r3, #3880]	@ 0xf28
 80058c0:	f107 0338 	add.w	r3, r7, #56	@ 0x38
 80058c4:	4619      	mov	r1, r3
 80058c6:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 80058ca:	f103 0304 	add.w	r3, r3, #4
 80058ce:	6818      	ldr	r0, [r3, #0]
 80058d0:	f019 f8ce 	bl	801ea70 <MP3GetNextFrameInfo>
 80058d4:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 80058d8:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 80058dc:	6018      	str	r0, [r3, #0]
	      if (err != ERR_MP3_INVALID_FRAMEHEADER)
 80058de:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 80058e2:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 80058e6:	681b      	ldr	r3, [r3, #0]
 80058e8:	f113 0f06 	cmn.w	r3, #6
 80058ec:	f000 820d 	beq.w	8005d0a <cliI2S+0xd2a>
	      {
	        cliPrintf("samplerate     %d\n", frameInfo.samprate);
 80058f0:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80058f4:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 80058f8:	689b      	ldr	r3, [r3, #8]
 80058fa:	4619      	mov	r1, r3
 80058fc:	4829      	ldr	r0, [pc, #164]	@ (80059a4 <cliI2S+0x9c4>)
 80058fe:	f7fd fcc3 	bl	8003288 <cliPrintf>
	        cliPrintf("bitrate        %d\n", frameInfo.bitrate);
 8005902:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005906:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 800590a:	681b      	ldr	r3, [r3, #0]
 800590c:	4619      	mov	r1, r3
 800590e:	4826      	ldr	r0, [pc, #152]	@ (80059a8 <cliI2S+0x9c8>)
 8005910:	f7fd fcba 	bl	8003288 <cliPrintf>
	        cliPrintf("nChans         %d\n", frameInfo.nChans);
 8005914:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005918:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 800591c:	685b      	ldr	r3, [r3, #4]
 800591e:	4619      	mov	r1, r3
 8005920:	4822      	ldr	r0, [pc, #136]	@ (80059ac <cliI2S+0x9cc>)
 8005922:	f7fd fcb1 	bl	8003288 <cliPrintf>
	        cliPrintf("outputSamps    %d\n", frameInfo.outputSamps);
 8005926:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800592a:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 800592e:	691b      	ldr	r3, [r3, #16]
 8005930:	4619      	mov	r1, r3
 8005932:	481f      	ldr	r0, [pc, #124]	@ (80059b0 <cliI2S+0x9d0>)
 8005934:	f7fd fca8 	bl	8003288 <cliPrintf>
	        cliPrintf("bitsPerSample  %d\n", frameInfo.bitsPerSample);
 8005938:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800593c:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 8005940:	68db      	ldr	r3, [r3, #12]
 8005942:	4619      	mov	r1, r3
 8005944:	481b      	ldr	r0, [pc, #108]	@ (80059b4 <cliI2S+0x9d4>)
 8005946:	f7fd fc9f 	bl	8003288 <cliPrintf>

	        i2sSetSampleRate(_DEF_I2S1, frameInfo.samprate);
 800594a:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800594e:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 8005952:	689b      	ldr	r3, [r3, #8]
 8005954:	4619      	mov	r1, r3
 8005956:	2002      	movs	r0, #2
 8005958:	f7fe ffce 	bl	80048f8 <i2sSetSampleRate>

	        q_buf_len = frameInfo.outputSamps / frameInfo.nChans;
 800595c:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005960:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 8005964:	691a      	ldr	r2, [r3, #16]
 8005966:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 800596a:	f5a3 6320 	sub.w	r3, r3, #2560	@ 0xa00
 800596e:	685b      	ldr	r3, [r3, #4]
 8005970:	fb92 f3f3 	sdiv	r3, r2, r3
 8005974:	461a      	mov	r2, r3
 8005976:	4b10      	ldr	r3, [pc, #64]	@ (80059b8 <cliI2S+0x9d8>)
 8005978:	601a      	str	r2, [r3, #0]
	        q_in  = 0;
 800597a:	4b10      	ldr	r3, [pc, #64]	@ (80059bc <cliI2S+0x9dc>)
 800597c:	2200      	movs	r2, #0
 800597e:	601a      	str	r2, [r3, #0]
	        q_out = 0;
 8005980:	4b0f      	ldr	r3, [pc, #60]	@ (80059c0 <cliI2S+0x9e0>)
 8005982:	2200      	movs	r2, #0
 8005984:	601a      	str	r2, [r3, #0]
	        q_len = I2S_BUF_LEN / q_buf_len;
 8005986:	4b0c      	ldr	r3, [pc, #48]	@ (80059b8 <cliI2S+0x9d8>)
 8005988:	681b      	ldr	r3, [r3, #0]
 800598a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 800598e:	fbb2 f3f3 	udiv	r3, r2, r3
 8005992:	4a0c      	ldr	r2, [pc, #48]	@ (80059c4 <cliI2S+0x9e4>)
 8005994:	6013      	str	r3, [r2, #0]

	        i2sStart();
 8005996:	f7fe fffd 	bl	8004994 <i2sStart>
	      }

	      while(cliKeepLoop())
 800599a:	e1b6      	b.n	8005d0a <cliI2S+0xd2a>
 800599c:	080246f4 	.word	0x080246f4
 80059a0:	08024708 	.word	0x08024708
 80059a4:	08024714 	.word	0x08024714
 80059a8:	08024728 	.word	0x08024728
 80059ac:	0802473c 	.word	0x0802473c
 80059b0:	08024750 	.word	0x08024750
 80059b4:	08024764 	.word	0x08024764
 80059b8:	200023cc 	.word	0x200023cc
 80059bc:	200023c0 	.word	0x200023c0
 80059c0:	200023c4 	.word	0x200023c4
 80059c4:	200023c8 	.word	0x200023c8
	      {
	        if (i2s_args.bytes_left < READBUF_SIZE)
 80059c8:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80059cc:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 80059d0:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 80059d4:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 80059d8:	f240 7293 	movw	r2, #1939	@ 0x793
 80059dc:	4293      	cmp	r3, r2
 80059de:	dc45      	bgt.n	8005a6c <cliI2S+0xa8c>
	        {
	          n_read = fillReadBuffer(i2s_args.read_buf, i2s_args.read_ptr, READBUF_SIZE, i2s_args.bytes_left, fp);
 80059e0:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80059e4:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 80059e8:	f8d3 1f28 	ldr.w	r1, [r3, #3880]	@ 0xf28
 80059ec:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 80059f0:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 80059f4:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 80059f8:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 80059fc:	f107 0078 	add.w	r0, r7, #120	@ 0x78
 8005a00:	3824      	subs	r0, #36	@ 0x24
 8005a02:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005a06:	681b      	ldr	r3, [r3, #0]
 8005a08:	9300      	str	r3, [sp, #0]
 8005a0a:	4613      	mov	r3, r2
 8005a0c:	f240 7294 	movw	r2, #1940	@ 0x794
 8005a10:	f7ff f908 	bl	8004c24 <fillReadBuffer>
 8005a14:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005a18:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005a1c:	6018      	str	r0, [r3, #0]
	          if (n_read == 0 )
 8005a1e:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005a22:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005a26:	681b      	ldr	r3, [r3, #0]
 8005a28:	2b00      	cmp	r3, #0
 8005a2a:	f000 8175 	beq.w	8005d18 <cliI2S+0xd38>
	          {
	            break;
	          }
	          i2s_args.bytes_left += n_read;
 8005a2e:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005a32:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005a36:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005a3a:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 8005a3e:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005a42:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005a46:	681b      	ldr	r3, [r3, #0]
 8005a48:	4413      	add	r3, r2
 8005a4a:	f607 2238 	addw	r2, r7, #2616	@ 0xa38
 8005a4e:	f6a2 12e4 	subw	r2, r2, #2532	@ 0x9e4
 8005a52:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 8005a56:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
	          i2s_args.read_ptr = i2s_args.read_buf;
 8005a5a:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005a5e:	f6a3 12e4 	subw	r2, r3, #2532	@ 0x9e4
 8005a62:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005a66:	3b24      	subs	r3, #36	@ 0x24
 8005a68:	f8c2 3f28 	str.w	r3, [r2, #3880]	@ 0xf28
	        }

	        n_read = MP3FindSyncWord(i2s_args.read_ptr, i2s_args.bytes_left);
 8005a6c:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005a70:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005a74:	f8d3 2f28 	ldr.w	r2, [r3, #3880]	@ 0xf28
 8005a78:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005a7c:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005a80:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005a84:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 8005a88:	4619      	mov	r1, r3
 8005a8a:	4610      	mov	r0, r2
 8005a8c:	f018 ffd6 	bl	801ea3c <MP3FindSyncWord>
 8005a90:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005a94:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005a98:	6018      	str	r0, [r3, #0]
	        if (n_read >= 0)
 8005a9a:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005a9e:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005aa2:	681b      	ldr	r3, [r3, #0]
 8005aa4:	2b00      	cmp	r3, #0
 8005aa6:	f2c0 8130 	blt.w	8005d0a <cliI2S+0xd2a>
	        {
	          i2s_args.read_ptr += n_read;
 8005aaa:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005aae:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005ab2:	f8d3 2f28 	ldr.w	r2, [r3, #3880]	@ 0xf28
 8005ab6:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005aba:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005abe:	681b      	ldr	r3, [r3, #0]
 8005ac0:	441a      	add	r2, r3
 8005ac2:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005ac6:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005aca:	f8c3 2f28 	str.w	r2, [r3, #3880]	@ 0xf28
	          i2s_args.bytes_left -= n_read;
 8005ace:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005ad2:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005ad6:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005ada:	f8d3 212c 	ldr.w	r2, [r3, #300]	@ 0x12c
 8005ade:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005ae2:	f103 033c 	add.w	r3, r3, #60	@ 0x3c
 8005ae6:	681b      	ldr	r3, [r3, #0]
 8005ae8:	1ad3      	subs	r3, r2, r3
 8005aea:	f607 2238 	addw	r2, r7, #2616	@ 0xa38
 8005aee:	f6a2 12e4 	subw	r2, r2, #2532	@ 0x9e4
 8005af2:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 8005af6:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c

	          //fill the inactive outbuffer
	          err = MP3Decode(h_dec, &i2s_args.read_ptr, (int*) &i2s_args.bytes_left, i2s_args.out_buf, 0);
 8005afa:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005afe:	3b24      	subs	r3, #36	@ 0x24
 8005b00:	f603 702c 	addw	r0, r3, #3884	@ 0xf2c
 8005b04:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005b08:	3b24      	subs	r3, #36	@ 0x24
 8005b0a:	f503 5204 	add.w	r2, r3, #8448	@ 0x2100
 8005b0e:	322c      	adds	r2, #44	@ 0x2c
 8005b10:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005b14:	3b24      	subs	r3, #36	@ 0x24
 8005b16:	f603 7128 	addw	r1, r3, #3880	@ 0xf28
 8005b1a:	2300      	movs	r3, #0
 8005b1c:	9300      	str	r3, [sp, #0]
 8005b1e:	4603      	mov	r3, r0
 8005b20:	f507 5028 	add.w	r0, r7, #10752	@ 0x2a00
 8005b24:	f100 0004 	add.w	r0, r0, #4
 8005b28:	6800      	ldr	r0, [r0, #0]
 8005b2a:	f018 ffd1 	bl	801ead0 <MP3Decode>
 8005b2e:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005b32:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 8005b36:	6018      	str	r0, [r3, #0]

	          if (err)
 8005b38:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005b3c:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 8005b40:	681b      	ldr	r3, [r3, #0]
 8005b42:	2b00      	cmp	r3, #0
 8005b44:	d027      	beq.n	8005b96 <cliI2S+0xbb6>
	          {
	            // sometimes we have a bad frame, lets just nudge forward one byte
	            if (err == ERR_MP3_INVALID_FRAMEHEADER)
 8005b46:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005b4a:	f103 0338 	add.w	r3, r3, #56	@ 0x38
 8005b4e:	681b      	ldr	r3, [r3, #0]
 8005b50:	f113 0f06 	cmn.w	r3, #6
 8005b54:	f040 80d9 	bne.w	8005d0a <cliI2S+0xd2a>
	            {
	              i2s_args.read_ptr   += 1;
 8005b58:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005b5c:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005b60:	f8d3 3f28 	ldr.w	r3, [r3, #3880]	@ 0xf28
 8005b64:	1c5a      	adds	r2, r3, #1
 8005b66:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005b6a:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005b6e:	f8c3 2f28 	str.w	r2, [r3, #3880]	@ 0xf28
	              i2s_args.bytes_left -= 1;
 8005b72:	f607 2338 	addw	r3, r7, #2616	@ 0xa38
 8005b76:	f6a3 13e4 	subw	r3, r3, #2532	@ 0x9e4
 8005b7a:	f503 5300 	add.w	r3, r3, #8192	@ 0x2000
 8005b7e:	f8d3 312c 	ldr.w	r3, [r3, #300]	@ 0x12c
 8005b82:	3b01      	subs	r3, #1
 8005b84:	f607 2238 	addw	r2, r7, #2616	@ 0xa38
 8005b88:	f6a2 12e4 	subw	r2, r2, #2532	@ 0x9e4
 8005b8c:	f502 5200 	add.w	r2, r2, #8192	@ 0x2000
 8005b90:	f8c2 312c 	str.w	r3, [r2, #300]	@ 0x12c
 8005b94:	e0b9      	b.n	8005d0a <cliI2S+0xd2a>
	          else
	          {
	            uint32_t pre_time;
	            uint32_t valid_len;

	            pre_time = millis();
 8005b96:	f7fb ff7b 	bl	8001a90 <millis>
 8005b9a:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005b9e:	f103 0334 	add.w	r3, r3, #52	@ 0x34
 8005ba2:	6018      	str	r0, [r3, #0]
	            while(1)
	            {
	              valid_len = (q_len - 1) - ((q_len + q_in - q_out) % q_len);
 8005ba4:	4b70      	ldr	r3, [pc, #448]	@ (8005d68 <cliI2S+0xd88>)
 8005ba6:	6819      	ldr	r1, [r3, #0]
 8005ba8:	4b6f      	ldr	r3, [pc, #444]	@ (8005d68 <cliI2S+0xd88>)
 8005baa:	681a      	ldr	r2, [r3, #0]
 8005bac:	4b6f      	ldr	r3, [pc, #444]	@ (8005d6c <cliI2S+0xd8c>)
 8005bae:	681b      	ldr	r3, [r3, #0]
 8005bb0:	441a      	add	r2, r3
 8005bb2:	4b6f      	ldr	r3, [pc, #444]	@ (8005d70 <cliI2S+0xd90>)
 8005bb4:	681b      	ldr	r3, [r3, #0]
 8005bb6:	1ad3      	subs	r3, r2, r3
 8005bb8:	4a6b      	ldr	r2, [pc, #428]	@ (8005d68 <cliI2S+0xd88>)
 8005bba:	6812      	ldr	r2, [r2, #0]
 8005bbc:	fbb3 f0f2 	udiv	r0, r3, r2
 8005bc0:	fb00 f202 	mul.w	r2, r0, r2
 8005bc4:	1a9b      	subs	r3, r3, r2
 8005bc6:	1acb      	subs	r3, r1, r3
 8005bc8:	3b01      	subs	r3, #1
 8005bca:	f507 5227 	add.w	r2, r7, #10688	@ 0x29c0
 8005bce:	f102 0230 	add.w	r2, r2, #48	@ 0x30
 8005bd2:	6013      	str	r3, [r2, #0]

	              if (valid_len > 0)
 8005bd4:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005bd8:	f103 0330 	add.w	r3, r3, #48	@ 0x30
 8005bdc:	681b      	ldr	r3, [r3, #0]
 8005bde:	2b00      	cmp	r3, #0
 8005be0:	d10b      	bne.n	8005bfa <cliI2S+0xc1a>
	              {
	                break;
	              }
	              if (millis()-pre_time >= 100)
 8005be2:	f7fb ff55 	bl	8001a90 <millis>
 8005be6:	4602      	mov	r2, r0
 8005be8:	f507 5327 	add.w	r3, r7, #10688	@ 0x29c0
 8005bec:	f103 0334 	add.w	r3, r3, #52	@ 0x34
 8005bf0:	681b      	ldr	r3, [r3, #0]
 8005bf2:	1ad3      	subs	r3, r2, r3
 8005bf4:	2b63      	cmp	r3, #99	@ 0x63
 8005bf6:	d802      	bhi.n	8005bfe <cliI2S+0xc1e>
	              valid_len = (q_len - 1) - ((q_len + q_in - q_out) % q_len);
 8005bf8:	e7d4      	b.n	8005ba4 <cliI2S+0xbc4>
	                break;
 8005bfa:	bf00      	nop
 8005bfc:	e000      	b.n	8005c00 <cliI2S+0xc20>
	              {
	                break;
 8005bfe:	bf00      	nop
	              }
	            }

	            uint32_t q_offset;

	            q_offset   = q_in*q_buf_len;
 8005c00:	4b5a      	ldr	r3, [pc, #360]	@ (8005d6c <cliI2S+0xd8c>)
 8005c02:	681b      	ldr	r3, [r3, #0]
 8005c04:	4a5b      	ldr	r2, [pc, #364]	@ (8005d74 <cliI2S+0xd94>)
 8005c06:	6812      	ldr	r2, [r2, #0]
 8005c08:	fb02 f303 	mul.w	r3, r2, r3
 8005c0c:	f507 5227 	add.w	r2, r7, #10688	@ 0x29c0
 8005c10:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
 8005c14:	6013      	str	r3, [r2, #0]

	            for (int j=0; j<q_buf_len; j++)
 8005c16:	2300      	movs	r3, #0
 8005c18:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005c1c:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
 8005c20:	6013      	str	r3, [r2, #0]
 8005c22:	e049      	b.n	8005cb8 <cliI2S+0xcd8>
	            {
	              q_buf[q_offset + j].left  = i2s_args.out_buf[j*2 + 0];
 8005c24:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005c28:	f103 032c 	add.w	r3, r3, #44	@ 0x2c
 8005c2c:	681b      	ldr	r3, [r3, #0]
 8005c2e:	005b      	lsls	r3, r3, #1
 8005c30:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005c34:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
 8005c38:	6811      	ldr	r1, [r2, #0]
 8005c3a:	f507 5227 	add.w	r2, r7, #10688	@ 0x29c0
 8005c3e:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
 8005c42:	6812      	ldr	r2, [r2, #0]
 8005c44:	440a      	add	r2, r1
 8005c46:	f607 2138 	addw	r1, r7, #2616	@ 0xa38
 8005c4a:	f6a1 11e4 	subw	r1, r1, #2532	@ 0x9e4
 8005c4e:	f203 7394 	addw	r3, r3, #1940	@ 0x794
 8005c52:	005b      	lsls	r3, r3, #1
 8005c54:	440b      	add	r3, r1
 8005c56:	f9b3 1004 	ldrsh.w	r1, [r3, #4]
 8005c5a:	4b47      	ldr	r3, [pc, #284]	@ (8005d78 <cliI2S+0xd98>)
 8005c5c:	f823 1022 	strh.w	r1, [r3, r2, lsl #2]
	              q_buf[q_offset + j].right = i2s_args.out_buf[j*2 + 1];
 8005c60:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005c64:	f103 032c 	add.w	r3, r3, #44	@ 0x2c
 8005c68:	681b      	ldr	r3, [r3, #0]
 8005c6a:	005b      	lsls	r3, r3, #1
 8005c6c:	3301      	adds	r3, #1
 8005c6e:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005c72:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
 8005c76:	6811      	ldr	r1, [r2, #0]
 8005c78:	f507 5227 	add.w	r2, r7, #10688	@ 0x29c0
 8005c7c:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
 8005c80:	6812      	ldr	r2, [r2, #0]
 8005c82:	440a      	add	r2, r1
 8005c84:	f607 2138 	addw	r1, r7, #2616	@ 0xa38
 8005c88:	f6a1 11e4 	subw	r1, r1, #2532	@ 0x9e4
 8005c8c:	f203 7394 	addw	r3, r3, #1940	@ 0x794
 8005c90:	005b      	lsls	r3, r3, #1
 8005c92:	440b      	add	r3, r1
 8005c94:	f9b3 0004 	ldrsh.w	r0, [r3, #4]
 8005c98:	4937      	ldr	r1, [pc, #220]	@ (8005d78 <cliI2S+0xd98>)
 8005c9a:	0093      	lsls	r3, r2, #2
 8005c9c:	440b      	add	r3, r1
 8005c9e:	4602      	mov	r2, r0
 8005ca0:	805a      	strh	r2, [r3, #2]
	            for (int j=0; j<q_buf_len; j++)
 8005ca2:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005ca6:	f103 032c 	add.w	r3, r3, #44	@ 0x2c
 8005caa:	681b      	ldr	r3, [r3, #0]
 8005cac:	3301      	adds	r3, #1
 8005cae:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005cb2:	f102 022c 	add.w	r2, r2, #44	@ 0x2c
 8005cb6:	6013      	str	r3, [r2, #0]
 8005cb8:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005cbc:	f103 032c 	add.w	r3, r3, #44	@ 0x2c
 8005cc0:	681a      	ldr	r2, [r3, #0]
 8005cc2:	4b2c      	ldr	r3, [pc, #176]	@ (8005d74 <cliI2S+0xd94>)
 8005cc4:	681b      	ldr	r3, [r3, #0]
 8005cc6:	429a      	cmp	r2, r3
 8005cc8:	d3ac      	bcc.n	8005c24 <cliI2S+0xc44>
	            }
	            if (((q_in + 1) % q_len) != q_out)
 8005cca:	4b28      	ldr	r3, [pc, #160]	@ (8005d6c <cliI2S+0xd8c>)
 8005ccc:	681b      	ldr	r3, [r3, #0]
 8005cce:	3301      	adds	r3, #1
 8005cd0:	4a25      	ldr	r2, [pc, #148]	@ (8005d68 <cliI2S+0xd88>)
 8005cd2:	6812      	ldr	r2, [r2, #0]
 8005cd4:	fbb3 f1f2 	udiv	r1, r3, r2
 8005cd8:	fb01 f202 	mul.w	r2, r1, r2
 8005cdc:	1a9a      	subs	r2, r3, r2
 8005cde:	4b24      	ldr	r3, [pc, #144]	@ (8005d70 <cliI2S+0xd90>)
 8005ce0:	681b      	ldr	r3, [r3, #0]
 8005ce2:	429a      	cmp	r2, r3
 8005ce4:	d00b      	beq.n	8005cfe <cliI2S+0xd1e>
	            {
	              q_in = (q_in+1) % q_len;
 8005ce6:	4b21      	ldr	r3, [pc, #132]	@ (8005d6c <cliI2S+0xd8c>)
 8005ce8:	681b      	ldr	r3, [r3, #0]
 8005cea:	3301      	adds	r3, #1
 8005cec:	4a1e      	ldr	r2, [pc, #120]	@ (8005d68 <cliI2S+0xd88>)
 8005cee:	6812      	ldr	r2, [r2, #0]
 8005cf0:	fbb3 f1f2 	udiv	r1, r3, r2
 8005cf4:	fb01 f202 	mul.w	r2, r1, r2
 8005cf8:	1a9b      	subs	r3, r3, r2
 8005cfa:	4a1c      	ldr	r2, [pc, #112]	@ (8005d6c <cliI2S+0xd8c>)
 8005cfc:	6013      	str	r3, [r2, #0]
	            }

	            lcdUpdate(&i2s_args);
 8005cfe:	f107 0378 	add.w	r3, r7, #120	@ 0x78
 8005d02:	3b24      	subs	r3, #36	@ 0x24
 8005d04:	4618      	mov	r0, r3
 8005d06:	f7fe ffff 	bl	8004d08 <lcdUpdate>
	      while(cliKeepLoop())
 8005d0a:	f7fd fbb7 	bl	800347c <cliKeepLoop>
 8005d0e:	4603      	mov	r3, r0
 8005d10:	2b00      	cmp	r3, #0
 8005d12:	f47f ae59 	bne.w	80059c8 <cliI2S+0x9e8>
 8005d16:	e000      	b.n	8005d1a <cliI2S+0xd3a>
	            break;
 8005d18:	bf00      	nop
	          }
	        }
	      }
	      i2sStop();
 8005d1a:	f7fe fe6b 	bl	80049f4 <i2sStop>
	      fclose(fp);
 8005d1e:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005d22:	6818      	ldr	r0, [r3, #0]
 8005d24:	f7fd ff96 	bl	8003c54 <ob_fclose>
	      ret = true;
 8005d28:	2301      	movs	r3, #1
 8005d2a:	f507 5228 	add.w	r2, r7, #10752	@ 0x2a00
 8005d2e:	f102 0237 	add.w	r2, r2, #55	@ 0x37
 8005d32:	7013      	strb	r3, [r2, #0]
	    }
	  }

	  if (ret != true)
 8005d34:	f507 5328 	add.w	r3, r7, #10752	@ 0x2a00
 8005d38:	f103 0337 	add.w	r3, r3, #55	@ 0x37
 8005d3c:	781b      	ldrb	r3, [r3, #0]
 8005d3e:	f083 0301 	eor.w	r3, r3, #1
 8005d42:	b2db      	uxtb	r3, r3
 8005d44:	2b00      	cmp	r3, #0
 8005d46:	d008      	beq.n	8005d5a <cliI2S+0xd7a>
	  {
	    cliPrintf("i2s info\n");
 8005d48:	480c      	ldr	r0, [pc, #48]	@ (8005d7c <cliI2S+0xd9c>)
 8005d4a:	f7fd fa9d 	bl	8003288 <cliPrintf>
	    cliPrintf("i2s play_wav filename\n");
 8005d4e:	480c      	ldr	r0, [pc, #48]	@ (8005d80 <cliI2S+0xda0>)
 8005d50:	f7fd fa9a 	bl	8003288 <cliPrintf>
	    cliPrintf("i2s play_mp3 filename\n");
 8005d54:	480b      	ldr	r0, [pc, #44]	@ (8005d84 <cliI2S+0xda4>)
 8005d56:	f7fd fa97 	bl	8003288 <cliPrintf>
	  }
}
 8005d5a:	f507 5728 	add.w	r7, r7, #10752	@ 0x2a00
 8005d5e:	373c      	adds	r7, #60	@ 0x3c
 8005d60:	46bd      	mov	sp, r7
 8005d62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8005d66:	bf00      	nop
 8005d68:	200023c8 	.word	0x200023c8
 8005d6c:	200023c0 	.word	0x200023c0
 8005d70:	200023c4 	.word	0x200023c4
 8005d74:	200023cc 	.word	0x200023cc
 8005d78:	200023d0 	.word	0x200023d0
 8005d7c:	08024778 	.word	0x08024778
 8005d80:	08024784 	.word	0x08024784
 8005d84:	0802479c 	.word	0x0802479c

08005d88 <TransferDoneISR>:
#ifdef _USE_HW_CLI
static void cliLcd(cli_args_t *args);
#endif

void TransferDoneISR(void)
{
 8005d88:	b580      	push	{r7, lr}
 8005d8a:	af00      	add	r7, sp, #0
  fps_time = millis() - fps_pre_time;
 8005d8c:	f7fb fe80 	bl	8001a90 <millis>
 8005d90:	4602      	mov	r2, r0
 8005d92:	4b0d      	ldr	r3, [pc, #52]	@ (8005dc8 <TransferDoneISR+0x40>)
 8005d94:	681b      	ldr	r3, [r3, #0]
 8005d96:	1ad3      	subs	r3, r2, r3
 8005d98:	4a0c      	ldr	r2, [pc, #48]	@ (8005dcc <TransferDoneISR+0x44>)
 8005d9a:	6013      	str	r3, [r2, #0]
  fps_pre_time = millis();
 8005d9c:	f7fb fe78 	bl	8001a90 <millis>
 8005da0:	4603      	mov	r3, r0
 8005da2:	4a09      	ldr	r2, [pc, #36]	@ (8005dc8 <TransferDoneISR+0x40>)
 8005da4:	6013      	str	r3, [r2, #0]

  if (fps_time > 0)
 8005da6:	4b09      	ldr	r3, [pc, #36]	@ (8005dcc <TransferDoneISR+0x44>)
 8005da8:	681b      	ldr	r3, [r3, #0]
 8005daa:	2b00      	cmp	r3, #0
 8005dac:	d007      	beq.n	8005dbe <TransferDoneISR+0x36>
  {
    fps_count = 1000 / fps_time;
 8005dae:	4b07      	ldr	r3, [pc, #28]	@ (8005dcc <TransferDoneISR+0x44>)
 8005db0:	681b      	ldr	r3, [r3, #0]
 8005db2:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8005db6:	fbb2 f3f3 	udiv	r3, r2, r3
 8005dba:	4a05      	ldr	r2, [pc, #20]	@ (8005dd0 <TransferDoneISR+0x48>)
 8005dbc:	6013      	str	r3, [r2, #0]
  }

  lcd_request_draw = false;
 8005dbe:	4b05      	ldr	r3, [pc, #20]	@ (8005dd4 <TransferDoneISR+0x4c>)
 8005dc0:	2200      	movs	r2, #0
 8005dc2:	701a      	strb	r2, [r3, #0]
}
 8005dc4:	bf00      	nop
 8005dc6:	bd80      	pop	{r7, pc}
 8005dc8:	20006498 	.word	0x20006498
 8005dcc:	2000649c 	.word	0x2000649c
 8005dd0:	200064a0 	.word	0x200064a0
 8005dd4:	20006496 	.word	0x20006496

08005dd8 <lcdInit>:


bool lcdInit(void)
{
 8005dd8:	b580      	push	{r7, lr}
 8005dda:	b084      	sub	sp, #16
 8005ddc:	af02      	add	r7, sp, #8
  backlight_value = 100;
 8005dde:	4b25      	ldr	r3, [pc, #148]	@ (8005e74 <lcdInit+0x9c>)
 8005de0:	2264      	movs	r2, #100	@ 0x64
 8005de2:	701a      	strb	r2, [r3, #0]
#ifdef _USE_HW_ST7735
  is_init = st7735Init();
  st7735InitDriver(&lcd);
#endif
#ifdef _USE_HW_SSD1306
  is_init = ssd1306Init();
 8005de4:	f7fc faa2 	bl	800232c <ssd1306Init>
 8005de8:	4603      	mov	r3, r0
 8005dea:	461a      	mov	r2, r3
 8005dec:	4b22      	ldr	r3, [pc, #136]	@ (8005e78 <lcdInit+0xa0>)
 8005dee:	701a      	strb	r2, [r3, #0]
  ssd1306InitDriver(&lcd);
 8005df0:	4822      	ldr	r0, [pc, #136]	@ (8005e7c <lcdInit+0xa4>)
 8005df2:	f7fc faa7 	bl	8002344 <ssd1306InitDriver>
#endif

  lcd.setCallBack(TransferDoneISR);
 8005df6:	4b21      	ldr	r3, [pc, #132]	@ (8005e7c <lcdInit+0xa4>)
 8005df8:	695b      	ldr	r3, [r3, #20]
 8005dfa:	4821      	ldr	r0, [pc, #132]	@ (8005e80 <lcdInit+0xa8>)
 8005dfc:	4798      	blx	r3


  for (int i=0; i<LCD_WIDTH*LCD_HEIGHT; i++)
 8005dfe:	2300      	movs	r3, #0
 8005e00:	607b      	str	r3, [r7, #4]
 8005e02:	e007      	b.n	8005e14 <lcdInit+0x3c>
  {
    frame_buffer[0][i] = black;
 8005e04:	4a1f      	ldr	r2, [pc, #124]	@ (8005e84 <lcdInit+0xac>)
 8005e06:	687b      	ldr	r3, [r7, #4]
 8005e08:	2100      	movs	r1, #0
 8005e0a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
  for (int i=0; i<LCD_WIDTH*LCD_HEIGHT; i++)
 8005e0e:	687b      	ldr	r3, [r7, #4]
 8005e10:	3301      	adds	r3, #1
 8005e12:	607b      	str	r3, [r7, #4]
 8005e14:	687b      	ldr	r3, [r7, #4]
 8005e16:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8005e1a:	dbf3      	blt.n	8005e04 <lcdInit+0x2c>
  }
  memset(frame_buffer, 0x00, sizeof(frame_buffer));
 8005e1c:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8005e20:	2100      	movs	r1, #0
 8005e22:	4818      	ldr	r0, [pc, #96]	@ (8005e84 <lcdInit+0xac>)
 8005e24:	f01c f96e 	bl	8022104 <memset>

  p_draw_frame_buf = frame_buffer[frame_index];
 8005e28:	4b17      	ldr	r3, [pc, #92]	@ (8005e88 <lcdInit+0xb0>)
 8005e2a:	781b      	ldrb	r3, [r3, #0]
 8005e2c:	039b      	lsls	r3, r3, #14
 8005e2e:	4a15      	ldr	r2, [pc, #84]	@ (8005e84 <lcdInit+0xac>)
 8005e30:	4413      	add	r3, r2
 8005e32:	4a16      	ldr	r2, [pc, #88]	@ (8005e8c <lcdInit+0xb4>)
 8005e34:	6013      	str	r3, [r2, #0]


  lcdDrawFillRect(0, 0, LCD_WIDTH, LCD_HEIGHT, black);
 8005e36:	2300      	movs	r3, #0
 8005e38:	9300      	str	r3, [sp, #0]
 8005e3a:	2340      	movs	r3, #64	@ 0x40
 8005e3c:	2280      	movs	r2, #128	@ 0x80
 8005e3e:	2100      	movs	r1, #0
 8005e40:	2000      	movs	r0, #0
 8005e42:	f000 fa03 	bl	800624c <lcdDrawFillRect>
  lcdUpdateDraw();
 8005e46:	f000 f8dd 	bl	8006004 <lcdUpdateDraw>

  lcdSetBackLight(100);
 8005e4a:	2064      	movs	r0, #100	@ 0x64
 8005e4c:	f000 f830 	bl	8005eb0 <lcdSetBackLight>


  if (is_init != true)
 8005e50:	4b09      	ldr	r3, [pc, #36]	@ (8005e78 <lcdInit+0xa0>)
 8005e52:	781b      	ldrb	r3, [r3, #0]
 8005e54:	f083 0301 	eor.w	r3, r3, #1
 8005e58:	b2db      	uxtb	r3, r3
 8005e5a:	2b00      	cmp	r3, #0
 8005e5c:	d001      	beq.n	8005e62 <lcdInit+0x8a>
  {
    return false;
 8005e5e:	2300      	movs	r3, #0
 8005e60:	e004      	b.n	8005e6c <lcdInit+0x94>
  }

#ifdef _USE_HW_CLI
  cliAdd("lcd", cliLcd);
 8005e62:	490b      	ldr	r1, [pc, #44]	@ (8005e90 <lcdInit+0xb8>)
 8005e64:	480b      	ldr	r0, [pc, #44]	@ (8005e94 <lcdInit+0xbc>)
 8005e66:	f7fd fb1f 	bl	80034a8 <cliAdd>
#endif

  return true;
 8005e6a:	2301      	movs	r3, #1
}
 8005e6c:	4618      	mov	r0, r3
 8005e6e:	3708      	adds	r7, #8
 8005e70:	46bd      	mov	sp, r7
 8005e72:	bd80      	pop	{r7, pc}
 8005e74:	20000088 	.word	0x20000088
 8005e78:	20006494 	.word	0x20006494
 8005e7c:	20006478 	.word	0x20006478
 8005e80:	08005d89 	.word	0x08005d89
 8005e84:	200064c0 	.word	0x200064c0
 8005e88:	20006495 	.word	0x20006495
 8005e8c:	200064a4 	.word	0x200064a4
 8005e90:	0800666d 	.word	0x0800666d
 8005e94:	08035084 	.word	0x08035084

08005e98 <lcdIsInit>:
{
  return draw_frame_time;
}

bool lcdIsInit(void)
{
 8005e98:	b480      	push	{r7}
 8005e9a:	af00      	add	r7, sp, #0
  return is_init;
 8005e9c:	4b03      	ldr	r3, [pc, #12]	@ (8005eac <lcdIsInit+0x14>)
 8005e9e:	781b      	ldrb	r3, [r3, #0]
}
 8005ea0:	4618      	mov	r0, r3
 8005ea2:	46bd      	mov	sp, r7
 8005ea4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ea8:	4770      	bx	lr
 8005eaa:	bf00      	nop
 8005eac:	20006494 	.word	0x20006494

08005eb0 <lcdSetBackLight>:
{
  return backlight_value;
}

void lcdSetBackLight(uint8_t value)
{
 8005eb0:	b580      	push	{r7, lr}
 8005eb2:	b082      	sub	sp, #8
 8005eb4:	af00      	add	r7, sp, #0
 8005eb6:	4603      	mov	r3, r0
 8005eb8:	71fb      	strb	r3, [r7, #7]
  value = constrain(value, 0, 100);
 8005eba:	79fb      	ldrb	r3, [r7, #7]
 8005ebc:	2b64      	cmp	r3, #100	@ 0x64
 8005ebe:	bf28      	it	cs
 8005ec0:	2364      	movcs	r3, #100	@ 0x64
 8005ec2:	71fb      	strb	r3, [r7, #7]

  if (value != backlight_value)
 8005ec4:	4b0c      	ldr	r3, [pc, #48]	@ (8005ef8 <lcdSetBackLight+0x48>)
 8005ec6:	781b      	ldrb	r3, [r3, #0]
 8005ec8:	79fa      	ldrb	r2, [r7, #7]
 8005eca:	429a      	cmp	r2, r3
 8005ecc:	d002      	beq.n	8005ed4 <lcdSetBackLight+0x24>
  {
    backlight_value = value;
 8005ece:	4a0a      	ldr	r2, [pc, #40]	@ (8005ef8 <lcdSetBackLight+0x48>)
 8005ed0:	79fb      	ldrb	r3, [r7, #7]
 8005ed2:	7013      	strb	r3, [r2, #0]
  }

  if (backlight_value > 0)
 8005ed4:	4b08      	ldr	r3, [pc, #32]	@ (8005ef8 <lcdSetBackLight+0x48>)
 8005ed6:	781b      	ldrb	r3, [r3, #0]
 8005ed8:	2b00      	cmp	r3, #0
 8005eda:	d004      	beq.n	8005ee6 <lcdSetBackLight+0x36>
  {
    gpioPinWrite(_PIN_DEF_BL_CTL, _DEF_HIGH);
 8005edc:	2101      	movs	r1, #1
 8005ede:	2001      	movs	r0, #1
 8005ee0:	f7fd ff42 	bl	8003d68 <gpioPinWrite>
  }
  else
  {
    gpioPinWrite(_PIN_DEF_BL_CTL, _DEF_LOW);
  }
}
 8005ee4:	e003      	b.n	8005eee <lcdSetBackLight+0x3e>
    gpioPinWrite(_PIN_DEF_BL_CTL, _DEF_LOW);
 8005ee6:	2100      	movs	r1, #0
 8005ee8:	2001      	movs	r0, #1
 8005eea:	f7fd ff3d 	bl	8003d68 <gpioPinWrite>
}
 8005eee:	bf00      	nop
 8005ef0:	3708      	adds	r7, #8
 8005ef2:	46bd      	mov	sp, r7
 8005ef4:	bd80      	pop	{r7, pc}
 8005ef6:	bf00      	nop
 8005ef8:	20000088 	.word	0x20000088

08005efc <lcdDrawPixel>:
  return p_draw_frame_buf[y_pos * LCD_WIDTH + x_pos];
}

LCD_OPT_DEF void lcdDrawPixel(uint16_t x_pos, uint16_t y_pos, uint32_t rgb_code)
{
  p_draw_frame_buf[y_pos * LCD_WIDTH + x_pos] = rgb_code;
 8005efc:	4b03      	ldr	r3, [pc, #12]	@ (8005f0c <lcdDrawPixel+0x10>)
 8005efe:	eb00 10c1 	add.w	r0, r0, r1, lsl #7
 8005f02:	681b      	ldr	r3, [r3, #0]
 8005f04:	f823 2010 	strh.w	r2, [r3, r0, lsl #1]
}
 8005f08:	4770      	bx	lr
 8005f0a:	bf00      	nop
 8005f0c:	200064a4 	.word	0x200064a4

08005f10 <lcdClearBuffer>:

  lcdUpdateDraw();
}

LCD_OPT_DEF void lcdClearBuffer(uint32_t rgb_code)
{
 8005f10:	b510      	push	{r4, lr}
 8005f12:	4604      	mov	r4, r0
  uint16_t *p_buf = lcdGetFrameBuffer();
 8005f14:	f000 f8a2 	bl	800605c <lcdGetFrameBuffer>

  for (int i=0; i<LCD_WIDTH * LCD_HEIGHT; i++)
 8005f18:	2300      	movs	r3, #0
  {
    p_buf[i] = rgb_code;
 8005f1a:	b2a1      	uxth	r1, r4
 8005f1c:	461a      	mov	r2, r3
 8005f1e:	f361 020f 	bfi	r2, r1, #0, #16
 8005f22:	f361 030f 	bfi	r3, r1, #0, #16
 8005f26:	f361 431f 	bfi	r3, r1, #16, #16
 8005f2a:	f361 421f 	bfi	r2, r1, #16, #16
 8005f2e:	f500 4180 	add.w	r1, r0, #16384	@ 0x4000
 8005f32:	6003      	str	r3, [r0, #0]
 8005f34:	6042      	str	r2, [r0, #4]
  for (int i=0; i<LCD_WIDTH * LCD_HEIGHT; i++)
 8005f36:	3008      	adds	r0, #8
 8005f38:	4281      	cmp	r1, r0
 8005f3a:	d1fa      	bne.n	8005f32 <lcdClearBuffer+0x22>
  }
}
 8005f3c:	bd10      	pop	{r4, pc}
 8005f3e:	bf00      	nop

08005f40 <lcdGetFps>:
    lcdDrawLine(x1, y1, line[i].x, line[i].y, color);
  }
}

uint32_t lcdGetFps(void)
{
 8005f40:	b480      	push	{r7}
 8005f42:	af00      	add	r7, sp, #0
  return fps_count;
 8005f44:	4b03      	ldr	r3, [pc, #12]	@ (8005f54 <lcdGetFps+0x14>)
 8005f46:	681b      	ldr	r3, [r3, #0]
}
 8005f48:	4618      	mov	r0, r3
 8005f4a:	46bd      	mov	sp, r7
 8005f4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f50:	4770      	bx	lr
 8005f52:	bf00      	nop
 8005f54:	200064a0 	.word	0x200064a0

08005f58 <lcdGetFpsTime>:

uint32_t lcdGetFpsTime(void)
{
 8005f58:	b480      	push	{r7}
 8005f5a:	af00      	add	r7, sp, #0
  return fps_time;
 8005f5c:	4b03      	ldr	r3, [pc, #12]	@ (8005f6c <lcdGetFpsTime+0x14>)
 8005f5e:	681b      	ldr	r3, [r3, #0]
}
 8005f60:	4618      	mov	r0, r3
 8005f62:	46bd      	mov	sp, r7
 8005f64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f68:	4770      	bx	lr
 8005f6a:	bf00      	nop
 8005f6c:	2000649c 	.word	0x2000649c

08005f70 <lcdDrawAvailable>:

bool lcdDrawAvailable(void)
{
 8005f70:	b480      	push	{r7}
 8005f72:	af00      	add	r7, sp, #0
  return !lcd_request_draw;
 8005f74:	4b08      	ldr	r3, [pc, #32]	@ (8005f98 <lcdDrawAvailable+0x28>)
 8005f76:	781b      	ldrb	r3, [r3, #0]
 8005f78:	2b00      	cmp	r3, #0
 8005f7a:	bf14      	ite	ne
 8005f7c:	2301      	movne	r3, #1
 8005f7e:	2300      	moveq	r3, #0
 8005f80:	b2db      	uxtb	r3, r3
 8005f82:	f083 0301 	eor.w	r3, r3, #1
 8005f86:	b2db      	uxtb	r3, r3
 8005f88:	f003 0301 	and.w	r3, r3, #1
 8005f8c:	b2db      	uxtb	r3, r3
}
 8005f8e:	4618      	mov	r0, r3
 8005f90:	46bd      	mov	sp, r7
 8005f92:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005f96:	4770      	bx	lr
 8005f98:	20006496 	.word	0x20006496

08005f9c <lcdRequestDraw>:

bool lcdRequestDraw(void)
{
 8005f9c:	b598      	push	{r3, r4, r7, lr}
 8005f9e:	af00      	add	r7, sp, #0
  if (is_init != true)
 8005fa0:	4b13      	ldr	r3, [pc, #76]	@ (8005ff0 <lcdRequestDraw+0x54>)
 8005fa2:	781b      	ldrb	r3, [r3, #0]
 8005fa4:	f083 0301 	eor.w	r3, r3, #1
 8005fa8:	b2db      	uxtb	r3, r3
 8005faa:	2b00      	cmp	r3, #0
 8005fac:	d001      	beq.n	8005fb2 <lcdRequestDraw+0x16>
  {
    return false;
 8005fae:	2300      	movs	r3, #0
 8005fb0:	e01b      	b.n	8005fea <lcdRequestDraw+0x4e>
  }
  if (lcd_request_draw == true)
 8005fb2:	4b10      	ldr	r3, [pc, #64]	@ (8005ff4 <lcdRequestDraw+0x58>)
 8005fb4:	781b      	ldrb	r3, [r3, #0]
 8005fb6:	2b00      	cmp	r3, #0
 8005fb8:	d001      	beq.n	8005fbe <lcdRequestDraw+0x22>
  {
    return false;
 8005fba:	2300      	movs	r3, #0
 8005fbc:	e015      	b.n	8005fea <lcdRequestDraw+0x4e>
  }

  lcd.setWindow(0, 0, LCD_WIDTH-1, LCD_HEIGHT-1);
 8005fbe:	4b0e      	ldr	r3, [pc, #56]	@ (8005ff8 <lcdRequestDraw+0x5c>)
 8005fc0:	689c      	ldr	r4, [r3, #8]
 8005fc2:	233f      	movs	r3, #63	@ 0x3f
 8005fc4:	227f      	movs	r2, #127	@ 0x7f
 8005fc6:	2100      	movs	r1, #0
 8005fc8:	2000      	movs	r0, #0
 8005fca:	47a0      	blx	r4

  lcd_request_draw = true;
 8005fcc:	4b09      	ldr	r3, [pc, #36]	@ (8005ff4 <lcdRequestDraw+0x58>)
 8005fce:	2201      	movs	r2, #1
 8005fd0:	701a      	strb	r2, [r3, #0]
  lcd.sendBuffer((uint8_t *)frame_buffer[frame_index], LCD_WIDTH * LCD_HEIGHT, 0);
 8005fd2:	4b09      	ldr	r3, [pc, #36]	@ (8005ff8 <lcdRequestDraw+0x5c>)
 8005fd4:	699b      	ldr	r3, [r3, #24]
 8005fd6:	4a09      	ldr	r2, [pc, #36]	@ (8005ffc <lcdRequestDraw+0x60>)
 8005fd8:	7812      	ldrb	r2, [r2, #0]
 8005fda:	0392      	lsls	r2, r2, #14
 8005fdc:	4908      	ldr	r1, [pc, #32]	@ (8006000 <lcdRequestDraw+0x64>)
 8005fde:	1850      	adds	r0, r2, r1
 8005fe0:	2200      	movs	r2, #0
 8005fe2:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 8005fe6:	4798      	blx	r3

  return true;
 8005fe8:	2301      	movs	r3, #1
}
 8005fea:	4618      	mov	r0, r3
 8005fec:	bd98      	pop	{r3, r4, r7, pc}
 8005fee:	bf00      	nop
 8005ff0:	20006494 	.word	0x20006494
 8005ff4:	20006496 	.word	0x20006496
 8005ff8:	20006478 	.word	0x20006478
 8005ffc:	20006495 	.word	0x20006495
 8006000:	200064c0 	.word	0x200064c0

08006004 <lcdUpdateDraw>:

void lcdUpdateDraw(void)
{
 8006004:	b580      	push	{r7, lr}
 8006006:	b082      	sub	sp, #8
 8006008:	af00      	add	r7, sp, #0
  uint32_t pre_time;

  if (is_init != true)
 800600a:	4b13      	ldr	r3, [pc, #76]	@ (8006058 <lcdUpdateDraw+0x54>)
 800600c:	781b      	ldrb	r3, [r3, #0]
 800600e:	f083 0301 	eor.w	r3, r3, #1
 8006012:	b2db      	uxtb	r3, r3
 8006014:	2b00      	cmp	r3, #0
 8006016:	d118      	bne.n	800604a <lcdUpdateDraw+0x46>
  {
    return;
  }

  lcdRequestDraw();
 8006018:	f7ff ffc0 	bl	8005f9c <lcdRequestDraw>

  pre_time = millis();
 800601c:	f7fb fd38 	bl	8001a90 <millis>
 8006020:	6078      	str	r0, [r7, #4]
  while(lcdDrawAvailable() != true)
 8006022:	e009      	b.n	8006038 <lcdUpdateDraw+0x34>
  {
    delay(1);
 8006024:	2001      	movs	r0, #1
 8006026:	f7fb fd28 	bl	8001a7a <delay>
    if (millis()-pre_time >= 100)
 800602a:	f7fb fd31 	bl	8001a90 <millis>
 800602e:	4602      	mov	r2, r0
 8006030:	687b      	ldr	r3, [r7, #4]
 8006032:	1ad3      	subs	r3, r2, r3
 8006034:	2b63      	cmp	r3, #99	@ 0x63
 8006036:	d80a      	bhi.n	800604e <lcdUpdateDraw+0x4a>
  while(lcdDrawAvailable() != true)
 8006038:	f7ff ff9a 	bl	8005f70 <lcdDrawAvailable>
 800603c:	4603      	mov	r3, r0
 800603e:	f083 0301 	eor.w	r3, r3, #1
 8006042:	b2db      	uxtb	r3, r3
 8006044:	2b00      	cmp	r3, #0
 8006046:	d1ed      	bne.n	8006024 <lcdUpdateDraw+0x20>
 8006048:	e002      	b.n	8006050 <lcdUpdateDraw+0x4c>
    return;
 800604a:	bf00      	nop
 800604c:	e000      	b.n	8006050 <lcdUpdateDraw+0x4c>
    {
      break;
 800604e:	bf00      	nop
    }
  }
}
 8006050:	3708      	adds	r7, #8
 8006052:	46bd      	mov	sp, r7
 8006054:	bd80      	pop	{r7, pc}
 8006056:	bf00      	nop
 8006058:	20006494 	.word	0x20006494

0800605c <lcdGetFrameBuffer>:

  lcd.setWindow(x, y, w, h);
}

uint16_t *lcdGetFrameBuffer(void)
{
 800605c:	b480      	push	{r7}
 800605e:	af00      	add	r7, sp, #0
  return (uint16_t *)p_draw_frame_buf;
 8006060:	4b03      	ldr	r3, [pc, #12]	@ (8006070 <lcdGetFrameBuffer+0x14>)
 8006062:	681b      	ldr	r3, [r3, #0]
}
 8006064:	4618      	mov	r0, r3
 8006066:	46bd      	mov	sp, r7
 8006068:	f85d 7b04 	ldr.w	r7, [sp], #4
 800606c:	4770      	bx	lr
 800606e:	bf00      	nop
 8006070:	200064a4 	.word	0x200064a4

08006074 <lcdGetWidth>:
{
  lcdSetBackLight(lcdGetBackLight());
}

int32_t lcdGetWidth(void)
{
 8006074:	b480      	push	{r7}
 8006076:	af00      	add	r7, sp, #0
  return LCD_WIDTH;
 8006078:	2380      	movs	r3, #128	@ 0x80
}
 800607a:	4618      	mov	r0, r3
 800607c:	46bd      	mov	sp, r7
 800607e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006082:	4770      	bx	lr

08006084 <lcdGetHeight>:

int32_t lcdGetHeight(void)
{
 8006084:	b480      	push	{r7}
 8006086:	af00      	add	r7, sp, #0
  return LCD_HEIGHT;
 8006088:	2340      	movs	r3, #64	@ 0x40
}
 800608a:	4618      	mov	r0, r3
 800608c:	46bd      	mov	sp, r7
 800608e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006092:	4770      	bx	lr

08006094 <lcdDrawLine>:


void lcdDrawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color)
{
 8006094:	b590      	push	{r4, r7, lr}
 8006096:	b089      	sub	sp, #36	@ 0x24
 8006098:	af00      	add	r7, sp, #0
 800609a:	4604      	mov	r4, r0
 800609c:	4608      	mov	r0, r1
 800609e:	4611      	mov	r1, r2
 80060a0:	461a      	mov	r2, r3
 80060a2:	4623      	mov	r3, r4
 80060a4:	80fb      	strh	r3, [r7, #6]
 80060a6:	4603      	mov	r3, r0
 80060a8:	80bb      	strh	r3, [r7, #4]
 80060aa:	460b      	mov	r3, r1
 80060ac:	807b      	strh	r3, [r7, #2]
 80060ae:	4613      	mov	r3, r2
 80060b0:	803b      	strh	r3, [r7, #0]
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80060b2:	f9b7 2000 	ldrsh.w	r2, [r7]
 80060b6:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80060ba:	1ad3      	subs	r3, r2, r3
 80060bc:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80060c0:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 80060c4:	f9b7 1002 	ldrsh.w	r1, [r7, #2]
 80060c8:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80060cc:	1acb      	subs	r3, r1, r3
 80060ce:	2b00      	cmp	r3, #0
 80060d0:	bfb8      	it	lt
 80060d2:	425b      	neglt	r3, r3
 80060d4:	429a      	cmp	r2, r3
 80060d6:	bfcc      	ite	gt
 80060d8:	2301      	movgt	r3, #1
 80060da:	2300      	movle	r3, #0
 80060dc:	b2db      	uxtb	r3, r3
 80060de:	837b      	strh	r3, [r7, #26]

  if (x0 < 0) x0 = 0;
 80060e0:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80060e4:	2b00      	cmp	r3, #0
 80060e6:	da01      	bge.n	80060ec <lcdDrawLine+0x58>
 80060e8:	2300      	movs	r3, #0
 80060ea:	80fb      	strh	r3, [r7, #6]
  if (y0 < 0) y0 = 0;
 80060ec:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80060f0:	2b00      	cmp	r3, #0
 80060f2:	da01      	bge.n	80060f8 <lcdDrawLine+0x64>
 80060f4:	2300      	movs	r3, #0
 80060f6:	80bb      	strh	r3, [r7, #4]
  if (x1 < 0) x1 = 0;
 80060f8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80060fc:	2b00      	cmp	r3, #0
 80060fe:	da01      	bge.n	8006104 <lcdDrawLine+0x70>
 8006100:	2300      	movs	r3, #0
 8006102:	807b      	strh	r3, [r7, #2]
  if (y1 < 0) y1 = 0;
 8006104:	f9b7 3000 	ldrsh.w	r3, [r7]
 8006108:	2b00      	cmp	r3, #0
 800610a:	da01      	bge.n	8006110 <lcdDrawLine+0x7c>
 800610c:	2300      	movs	r3, #0
 800610e:	803b      	strh	r3, [r7, #0]


  if (steep)
 8006110:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8006114:	2b00      	cmp	r3, #0
 8006116:	d00b      	beq.n	8006130 <lcdDrawLine+0x9c>
  {
    _swap_int16_t(x0, y0);
 8006118:	88fb      	ldrh	r3, [r7, #6]
 800611a:	833b      	strh	r3, [r7, #24]
 800611c:	88bb      	ldrh	r3, [r7, #4]
 800611e:	80fb      	strh	r3, [r7, #6]
 8006120:	8b3b      	ldrh	r3, [r7, #24]
 8006122:	80bb      	strh	r3, [r7, #4]
    _swap_int16_t(x1, y1);
 8006124:	887b      	ldrh	r3, [r7, #2]
 8006126:	82fb      	strh	r3, [r7, #22]
 8006128:	883b      	ldrh	r3, [r7, #0]
 800612a:	807b      	strh	r3, [r7, #2]
 800612c:	8afb      	ldrh	r3, [r7, #22]
 800612e:	803b      	strh	r3, [r7, #0]
  }

  if (x0 > x1)
 8006130:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8006134:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8006138:	429a      	cmp	r2, r3
 800613a:	dd0b      	ble.n	8006154 <lcdDrawLine+0xc0>
  {
    _swap_int16_t(x0, x1);
 800613c:	88fb      	ldrh	r3, [r7, #6]
 800613e:	82bb      	strh	r3, [r7, #20]
 8006140:	887b      	ldrh	r3, [r7, #2]
 8006142:	80fb      	strh	r3, [r7, #6]
 8006144:	8abb      	ldrh	r3, [r7, #20]
 8006146:	807b      	strh	r3, [r7, #2]
    _swap_int16_t(y0, y1);
 8006148:	88bb      	ldrh	r3, [r7, #4]
 800614a:	827b      	strh	r3, [r7, #18]
 800614c:	883b      	ldrh	r3, [r7, #0]
 800614e:	80bb      	strh	r3, [r7, #4]
 8006150:	8a7b      	ldrh	r3, [r7, #18]
 8006152:	803b      	strh	r3, [r7, #0]
  }

  int16_t dx, dy;
  dx = x1 - x0;
 8006154:	887a      	ldrh	r2, [r7, #2]
 8006156:	88fb      	ldrh	r3, [r7, #6]
 8006158:	1ad3      	subs	r3, r2, r3
 800615a:	b29b      	uxth	r3, r3
 800615c:	823b      	strh	r3, [r7, #16]
  dy = abs(y1 - y0);
 800615e:	f9b7 2000 	ldrsh.w	r2, [r7]
 8006162:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8006166:	1ad3      	subs	r3, r2, r3
 8006168:	2b00      	cmp	r3, #0
 800616a:	bfb8      	it	lt
 800616c:	425b      	neglt	r3, r3
 800616e:	81fb      	strh	r3, [r7, #14]

  int16_t err = dx / 2;
 8006170:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8006174:	0fda      	lsrs	r2, r3, #31
 8006176:	4413      	add	r3, r2
 8006178:	105b      	asrs	r3, r3, #1
 800617a:	83fb      	strh	r3, [r7, #30]
  int16_t ystep;

  if (y0 < y1)
 800617c:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 8006180:	f9b7 3000 	ldrsh.w	r3, [r7]
 8006184:	429a      	cmp	r2, r3
 8006186:	da02      	bge.n	800618e <lcdDrawLine+0xfa>
  {
    ystep = 1;
 8006188:	2301      	movs	r3, #1
 800618a:	83bb      	strh	r3, [r7, #28]
 800618c:	e02d      	b.n	80061ea <lcdDrawLine+0x156>
  } else {
    ystep = -1;
 800618e:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8006192:	83bb      	strh	r3, [r7, #28]
  }

  for (; x0<=x1; x0++)
 8006194:	e029      	b.n	80061ea <lcdDrawLine+0x156>
  {
    if (steep)
 8006196:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 800619a:	2b00      	cmp	r3, #0
 800619c:	d006      	beq.n	80061ac <lcdDrawLine+0x118>
    {
      lcdDrawPixel(y0, x0, color);
 800619e:	88bb      	ldrh	r3, [r7, #4]
 80061a0:	88f9      	ldrh	r1, [r7, #6]
 80061a2:	8e3a      	ldrh	r2, [r7, #48]	@ 0x30
 80061a4:	4618      	mov	r0, r3
 80061a6:	f7ff fea9 	bl	8005efc <lcdDrawPixel>
 80061aa:	e005      	b.n	80061b8 <lcdDrawLine+0x124>
    } else
    {
      lcdDrawPixel(x0, y0, color);
 80061ac:	88fb      	ldrh	r3, [r7, #6]
 80061ae:	88b9      	ldrh	r1, [r7, #4]
 80061b0:	8e3a      	ldrh	r2, [r7, #48]	@ 0x30
 80061b2:	4618      	mov	r0, r3
 80061b4:	f7ff fea2 	bl	8005efc <lcdDrawPixel>
    }
    err -= dy;
 80061b8:	8bfa      	ldrh	r2, [r7, #30]
 80061ba:	89fb      	ldrh	r3, [r7, #14]
 80061bc:	1ad3      	subs	r3, r2, r3
 80061be:	b29b      	uxth	r3, r3
 80061c0:	83fb      	strh	r3, [r7, #30]
    if (err < 0)
 80061c2:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80061c6:	2b00      	cmp	r3, #0
 80061c8:	da09      	bge.n	80061de <lcdDrawLine+0x14a>
    {
      y0 += ystep;
 80061ca:	88ba      	ldrh	r2, [r7, #4]
 80061cc:	8bbb      	ldrh	r3, [r7, #28]
 80061ce:	4413      	add	r3, r2
 80061d0:	b29b      	uxth	r3, r3
 80061d2:	80bb      	strh	r3, [r7, #4]
      err += dx;
 80061d4:	8bfa      	ldrh	r2, [r7, #30]
 80061d6:	8a3b      	ldrh	r3, [r7, #16]
 80061d8:	4413      	add	r3, r2
 80061da:	b29b      	uxth	r3, r3
 80061dc:	83fb      	strh	r3, [r7, #30]
  for (; x0<=x1; x0++)
 80061de:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80061e2:	b29b      	uxth	r3, r3
 80061e4:	3301      	adds	r3, #1
 80061e6:	b29b      	uxth	r3, r3
 80061e8:	80fb      	strh	r3, [r7, #6]
 80061ea:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 80061ee:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80061f2:	429a      	cmp	r2, r3
 80061f4:	ddcf      	ble.n	8006196 <lcdDrawLine+0x102>
    }
  }
}
 80061f6:	bf00      	nop
 80061f8:	bf00      	nop
 80061fa:	3724      	adds	r7, #36	@ 0x24
 80061fc:	46bd      	mov	sp, r7
 80061fe:	bd90      	pop	{r4, r7, pc}

08006200 <lcdDrawVLine>:
    }
  }
}

void lcdDrawVLine(int16_t x, int16_t y, int16_t h, uint16_t color)
{
 8006200:	b590      	push	{r4, r7, lr}
 8006202:	b085      	sub	sp, #20
 8006204:	af02      	add	r7, sp, #8
 8006206:	4604      	mov	r4, r0
 8006208:	4608      	mov	r0, r1
 800620a:	4611      	mov	r1, r2
 800620c:	461a      	mov	r2, r3
 800620e:	4623      	mov	r3, r4
 8006210:	80fb      	strh	r3, [r7, #6]
 8006212:	4603      	mov	r3, r0
 8006214:	80bb      	strh	r3, [r7, #4]
 8006216:	460b      	mov	r3, r1
 8006218:	807b      	strh	r3, [r7, #2]
 800621a:	4613      	mov	r3, r2
 800621c:	803b      	strh	r3, [r7, #0]
  lcdDrawLine(x, y, x, y+h-1, color);
 800621e:	88ba      	ldrh	r2, [r7, #4]
 8006220:	887b      	ldrh	r3, [r7, #2]
 8006222:	4413      	add	r3, r2
 8006224:	b29b      	uxth	r3, r3
 8006226:	3b01      	subs	r3, #1
 8006228:	b29b      	uxth	r3, r3
 800622a:	b21c      	sxth	r4, r3
 800622c:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 8006230:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 8006234:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 8006238:	883b      	ldrh	r3, [r7, #0]
 800623a:	9300      	str	r3, [sp, #0]
 800623c:	4623      	mov	r3, r4
 800623e:	f7ff ff29 	bl	8006094 <lcdDrawLine>
}
 8006242:	bf00      	nop
 8006244:	370c      	adds	r7, #12
 8006246:	46bd      	mov	sp, r7
 8006248:	bd90      	pop	{r4, r7, pc}
 800624a:	bf00      	nop

0800624c <lcdDrawFillRect>:
{
  lcdDrawLine(x, y, x+w-1, y, color);
}

void lcdDrawFillRect(int16_t x, int16_t y, int16_t w, int16_t h, uint16_t color)
{
 800624c:	b590      	push	{r4, r7, lr}
 800624e:	b085      	sub	sp, #20
 8006250:	af00      	add	r7, sp, #0
 8006252:	4604      	mov	r4, r0
 8006254:	4608      	mov	r0, r1
 8006256:	4611      	mov	r1, r2
 8006258:	461a      	mov	r2, r3
 800625a:	4623      	mov	r3, r4
 800625c:	80fb      	strh	r3, [r7, #6]
 800625e:	4603      	mov	r3, r0
 8006260:	80bb      	strh	r3, [r7, #4]
 8006262:	460b      	mov	r3, r1
 8006264:	807b      	strh	r3, [r7, #2]
 8006266:	4613      	mov	r3, r2
 8006268:	803b      	strh	r3, [r7, #0]
  for (int16_t i=x; i<x+w; i++)
 800626a:	88fb      	ldrh	r3, [r7, #6]
 800626c:	81fb      	strh	r3, [r7, #14]
 800626e:	e00e      	b.n	800628e <lcdDrawFillRect+0x42>
  {
    lcdDrawVLine(i, y, h, color);
 8006270:	8c3b      	ldrh	r3, [r7, #32]
 8006272:	f9b7 2000 	ldrsh.w	r2, [r7]
 8006276:	f9b7 1004 	ldrsh.w	r1, [r7, #4]
 800627a:	f9b7 000e 	ldrsh.w	r0, [r7, #14]
 800627e:	f7ff ffbf 	bl	8006200 <lcdDrawVLine>
  for (int16_t i=x; i<x+w; i++)
 8006282:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8006286:	b29b      	uxth	r3, r3
 8006288:	3301      	adds	r3, #1
 800628a:	b29b      	uxth	r3, r3
 800628c:	81fb      	strh	r3, [r7, #14]
 800628e:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8006292:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 8006296:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800629a:	440b      	add	r3, r1
 800629c:	429a      	cmp	r2, r3
 800629e:	dbe7      	blt.n	8006270 <lcdDrawFillRect+0x24>
  }
}
 80062a0:	bf00      	nop
 80062a2:	bf00      	nop
 80062a4:	3714      	adds	r7, #20
 80062a6:	46bd      	mov	sp, r7
 80062a8:	bd90      	pop	{r4, r7, pc}
 80062aa:	bf00      	nop

080062ac <lcdPrintf>:
{
  lcdDrawFillRect(0, 0, HW_LCD_WIDTH, HW_LCD_HEIGHT, color);
}

void lcdPrintf(int x, int y, uint16_t color,  const char *fmt, ...)
{
 80062ac:	b408      	push	{r3}
 80062ae:	b590      	push	{r4, r7, lr}
 80062b0:	b0d8      	sub	sp, #352	@ 0x160
 80062b2:	af02      	add	r7, sp, #8
 80062b4:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80062b8:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 80062bc:	6018      	str	r0, [r3, #0]
 80062be:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80062c2:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 80062c6:	6019      	str	r1, [r3, #0]
 80062c8:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80062cc:	f5a3 73a9 	sub.w	r3, r3, #338	@ 0x152
 80062d0:	801a      	strh	r2, [r3, #0]
  va_list arg;
  va_start (arg, fmt);
 80062d2:	f507 73b4 	add.w	r3, r7, #360	@ 0x168
 80062d6:	f8c7 313c 	str.w	r3, [r7, #316]	@ 0x13c
  int32_t len;
  char print_buffer[256];
  int Size_Char;
  int i, x_Pre = x;
 80062da:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80062de:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 80062e2:	681b      	ldr	r3, [r3, #0]
 80062e4:	f8c7 314c 	str.w	r3, [r7, #332]	@ 0x14c
  han_font_t FontBuf;
  uint8_t font_width;
  uint8_t font_height;


  len = vsnprintf(print_buffer, 255, fmt, arg);
 80062e8:	f107 003c 	add.w	r0, r7, #60	@ 0x3c
 80062ec:	f8d7 313c 	ldr.w	r3, [r7, #316]	@ 0x13c
 80062f0:	f8d7 2164 	ldr.w	r2, [r7, #356]	@ 0x164
 80062f4:	21ff      	movs	r1, #255	@ 0xff
 80062f6:	f01b fe49 	bl	8021f8c <vsniprintf>
 80062fa:	f8c7 0148 	str.w	r0, [r7, #328]	@ 0x148
  va_end (arg);

  if (font_tbl[lcd_font]->data != NULL)
 80062fe:	4b80      	ldr	r3, [pc, #512]	@ (8006500 <lcdPrintf+0x254>)
 8006300:	781b      	ldrb	r3, [r3, #0]
 8006302:	461a      	mov	r2, r3
 8006304:	4b7f      	ldr	r3, [pc, #508]	@ (8006504 <lcdPrintf+0x258>)
 8006306:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800630a:	685b      	ldr	r3, [r3, #4]
 800630c:	2b00      	cmp	r3, #0
 800630e:	d072      	beq.n	80063f6 <lcdPrintf+0x14a>
  {
    for( i=0; i<len; i+=Size_Char )
 8006310:	2300      	movs	r3, #0
 8006312:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 8006316:	e067      	b.n	80063e8 <lcdPrintf+0x13c>
    {
      disEngFont(x, y, print_buffer[i], font_tbl[lcd_font], color);
 8006318:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 800631c:	f5a3 728e 	sub.w	r2, r3, #284	@ 0x11c
 8006320:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8006324:	4413      	add	r3, r2
 8006326:	781a      	ldrb	r2, [r3, #0]
 8006328:	4b75      	ldr	r3, [pc, #468]	@ (8006500 <lcdPrintf+0x254>)
 800632a:	781b      	ldrb	r3, [r3, #0]
 800632c:	4619      	mov	r1, r3
 800632e:	4b75      	ldr	r3, [pc, #468]	@ (8006504 <lcdPrintf+0x258>)
 8006330:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]
 8006334:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 8006338:	f5a3 71a8 	sub.w	r1, r3, #336	@ 0x150
 800633c:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 8006340:	f5a3 70a6 	sub.w	r0, r3, #332	@ 0x14c
 8006344:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 8006348:	f5a3 73a9 	sub.w	r3, r3, #338	@ 0x152
 800634c:	881b      	ldrh	r3, [r3, #0]
 800634e:	9300      	str	r3, [sp, #0]
 8006350:	4623      	mov	r3, r4
 8006352:	6809      	ldr	r1, [r1, #0]
 8006354:	6800      	ldr	r0, [r0, #0]
 8006356:	f000 f92d 	bl	80065b4 <disEngFont>

      Size_Char = 1;
 800635a:	2301      	movs	r3, #1
 800635c:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
      font_width = font_tbl[lcd_font]->width;
 8006360:	4b67      	ldr	r3, [pc, #412]	@ (8006500 <lcdPrintf+0x254>)
 8006362:	781b      	ldrb	r3, [r3, #0]
 8006364:	461a      	mov	r2, r3
 8006366:	4b67      	ldr	r3, [pc, #412]	@ (8006504 <lcdPrintf+0x258>)
 8006368:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800636c:	781b      	ldrb	r3, [r3, #0]
 800636e:	f887 3153 	strb.w	r3, [r7, #339]	@ 0x153
      font_height = font_tbl[lcd_font]->height;
 8006372:	4b63      	ldr	r3, [pc, #396]	@ (8006500 <lcdPrintf+0x254>)
 8006374:	781b      	ldrb	r3, [r3, #0]
 8006376:	461a      	mov	r2, r3
 8006378:	4b62      	ldr	r3, [pc, #392]	@ (8006504 <lcdPrintf+0x258>)
 800637a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800637e:	785b      	ldrb	r3, [r3, #1]
 8006380:	f887 3143 	strb.w	r3, [r7, #323]	@ 0x143
      x += font_width;
 8006384:	f897 2153 	ldrb.w	r2, [r7, #339]	@ 0x153
 8006388:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 800638c:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 8006390:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
 8006394:	f5a1 71a6 	sub.w	r1, r1, #332	@ 0x14c
 8006398:	6809      	ldr	r1, [r1, #0]
 800639a:	440a      	add	r2, r1
 800639c:	601a      	str	r2, [r3, #0]

      if ((x+font_width) > HW_LCD_WIDTH)
 800639e:	f897 2153 	ldrb.w	r2, [r7, #339]	@ 0x153
 80063a2:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80063a6:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 80063aa:	681b      	ldr	r3, [r3, #0]
 80063ac:	4413      	add	r3, r2
 80063ae:	2b80      	cmp	r3, #128	@ 0x80
 80063b0:	dd13      	ble.n	80063da <lcdPrintf+0x12e>
      {
        x  = x_Pre;
 80063b2:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80063b6:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 80063ba:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80063be:	601a      	str	r2, [r3, #0]
        y += font_height;
 80063c0:	f897 2143 	ldrb.w	r2, [r7, #323]	@ 0x143
 80063c4:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80063c8:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 80063cc:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
 80063d0:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
 80063d4:	6809      	ldr	r1, [r1, #0]
 80063d6:	440a      	add	r2, r1
 80063d8:	601a      	str	r2, [r3, #0]
    for( i=0; i<len; i+=Size_Char )
 80063da:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80063de:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80063e2:	4413      	add	r3, r2
 80063e4:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 80063e8:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80063ec:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80063f0:	429a      	cmp	r2, r3
 80063f2:	db91      	blt.n	8006318 <lcdPrintf+0x6c>
      }

      if( FontBuf.Code_Type == PHAN_END_CODE ) break;
    }
  }
}
 80063f4:	e07b      	b.n	80064ee <lcdPrintf+0x242>
    for( i=0; i<len; i+=Size_Char )
 80063f6:	2300      	movs	r3, #0
 80063f8:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 80063fc:	e06f      	b.n	80064de <lcdPrintf+0x232>
      hanFontLoad( &print_buffer[i], &FontBuf );
 80063fe:	f107 023c 	add.w	r2, r7, #60	@ 0x3c
 8006402:	f8d7 3154 	ldr.w	r3, [r7, #340]	@ 0x154
 8006406:	4413      	add	r3, r2
 8006408:	f107 0214 	add.w	r2, r7, #20
 800640c:	4611      	mov	r1, r2
 800640e:	4618      	mov	r0, r3
 8006410:	f7fb fcb6 	bl	8001d80 <hanFontLoad>
      disHanFont( x, y, &FontBuf, color);
 8006414:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 8006418:	f5a3 73a9 	sub.w	r3, r3, #338	@ 0x152
 800641c:	881b      	ldrh	r3, [r3, #0]
 800641e:	f107 0214 	add.w	r2, r7, #20
 8006422:	f507 71ac 	add.w	r1, r7, #344	@ 0x158
 8006426:	f5a1 71a8 	sub.w	r1, r1, #336	@ 0x150
 800642a:	f507 70ac 	add.w	r0, r7, #344	@ 0x158
 800642e:	f5a0 70a6 	sub.w	r0, r0, #332	@ 0x14c
 8006432:	6809      	ldr	r1, [r1, #0]
 8006434:	6800      	ldr	r0, [r0, #0]
 8006436:	f000 f867 	bl	8006508 <disHanFont>
      Size_Char = FontBuf.Size_Char;
 800643a:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 800643e:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 8006442:	885b      	ldrh	r3, [r3, #2]
 8006444:	f8c7 3144 	str.w	r3, [r7, #324]	@ 0x144
      if (Size_Char >= 2)
 8006448:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 800644c:	2b01      	cmp	r3, #1
 800644e:	dd0e      	ble.n	800646e <lcdPrintf+0x1c2>
        font_width = 16;
 8006450:	2310      	movs	r3, #16
 8006452:	f887 3153 	strb.w	r3, [r7, #339]	@ 0x153
        x += 2*8;
 8006456:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 800645a:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 800645e:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
 8006462:	f5a2 72a6 	sub.w	r2, r2, #332	@ 0x14c
 8006466:	6812      	ldr	r2, [r2, #0]
 8006468:	3210      	adds	r2, #16
 800646a:	601a      	str	r2, [r3, #0]
 800646c:	e00d      	b.n	800648a <lcdPrintf+0x1de>
        font_width = 8;
 800646e:	2308      	movs	r3, #8
 8006470:	f887 3153 	strb.w	r3, [r7, #339]	@ 0x153
        x += 1*8;
 8006474:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 8006478:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 800647c:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
 8006480:	f5a2 72a6 	sub.w	r2, r2, #332	@ 0x14c
 8006484:	6812      	ldr	r2, [r2, #0]
 8006486:	3208      	adds	r2, #8
 8006488:	601a      	str	r2, [r3, #0]
      if ((x+font_width) > HW_LCD_WIDTH)
 800648a:	f897 2153 	ldrb.w	r2, [r7, #339]	@ 0x153
 800648e:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 8006492:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 8006496:	681b      	ldr	r3, [r3, #0]
 8006498:	4413      	add	r3, r2
 800649a:	2b80      	cmp	r3, #128	@ 0x80
 800649c:	dd11      	ble.n	80064c2 <lcdPrintf+0x216>
        x  = x_Pre;
 800649e:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80064a2:	f5a3 73a6 	sub.w	r3, r3, #332	@ 0x14c
 80064a6:	f8d7 214c 	ldr.w	r2, [r7, #332]	@ 0x14c
 80064aa:	601a      	str	r2, [r3, #0]
        y += 16;
 80064ac:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80064b0:	f5a3 73a8 	sub.w	r3, r3, #336	@ 0x150
 80064b4:	f507 72ac 	add.w	r2, r7, #344	@ 0x158
 80064b8:	f5a2 72a8 	sub.w	r2, r2, #336	@ 0x150
 80064bc:	6812      	ldr	r2, [r2, #0]
 80064be:	3210      	adds	r2, #16
 80064c0:	601a      	str	r2, [r3, #0]
      if( FontBuf.Code_Type == PHAN_END_CODE ) break;
 80064c2:	f507 73ac 	add.w	r3, r7, #344	@ 0x158
 80064c6:	f5a3 73a2 	sub.w	r3, r3, #324	@ 0x144
 80064ca:	889b      	ldrh	r3, [r3, #4]
 80064cc:	2b04      	cmp	r3, #4
 80064ce:	d00d      	beq.n	80064ec <lcdPrintf+0x240>
    for( i=0; i<len; i+=Size_Char )
 80064d0:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80064d4:	f8d7 3144 	ldr.w	r3, [r7, #324]	@ 0x144
 80064d8:	4413      	add	r3, r2
 80064da:	f8c7 3154 	str.w	r3, [r7, #340]	@ 0x154
 80064de:	f8d7 2154 	ldr.w	r2, [r7, #340]	@ 0x154
 80064e2:	f8d7 3148 	ldr.w	r3, [r7, #328]	@ 0x148
 80064e6:	429a      	cmp	r2, r3
 80064e8:	db89      	blt.n	80063fe <lcdPrintf+0x152>
}
 80064ea:	e000      	b.n	80064ee <lcdPrintf+0x242>
      if( FontBuf.Code_Type == PHAN_END_CODE ) break;
 80064ec:	bf00      	nop
}
 80064ee:	bf00      	nop
 80064f0:	f507 77ac 	add.w	r7, r7, #344	@ 0x158
 80064f4:	46bd      	mov	sp, r7
 80064f6:	e8bd 4090 	ldmia.w	sp!, {r4, r7, lr}
 80064fa:	b001      	add	sp, #4
 80064fc:	4770      	bx	lr
 80064fe:	bf00      	nop
 8006500:	20000089 	.word	0x20000089
 8006504:	2000008c 	.word	0x2000008c

08006508 <disHanFont>:

  return str_len;
}

void disHanFont(int x, int y, han_font_t *FontPtr, uint16_t textcolor)
{
 8006508:	b580      	push	{r7, lr}
 800650a:	b088      	sub	sp, #32
 800650c:	af00      	add	r7, sp, #0
 800650e:	60f8      	str	r0, [r7, #12]
 8006510:	60b9      	str	r1, [r7, #8]
 8006512:	607a      	str	r2, [r7, #4]
 8006514:	807b      	strh	r3, [r7, #2]
  uint16_t    i, j, Loop;
  uint16_t  FontSize = FontPtr->Size_Char;
 8006516:	687b      	ldr	r3, [r7, #4]
 8006518:	885b      	ldrh	r3, [r3, #2]
 800651a:	833b      	strh	r3, [r7, #24]
  uint16_t index_x;

  if (FontSize > 2)
 800651c:	8b3b      	ldrh	r3, [r7, #24]
 800651e:	2b02      	cmp	r3, #2
 8006520:	d901      	bls.n	8006526 <disHanFont+0x1e>
  {
    FontSize = 2;
 8006522:	2302      	movs	r3, #2
 8006524:	833b      	strh	r3, [r7, #24]
  }

  for ( i = 0 ; i < 16 ; i++ )        // 16 Lines per Font/Char
 8006526:	2300      	movs	r3, #0
 8006528:	83fb      	strh	r3, [r7, #30]
 800652a:	e03a      	b.n	80065a2 <disHanFont+0x9a>
  {
    index_x = 0;
 800652c:	2300      	movs	r3, #0
 800652e:	82fb      	strh	r3, [r7, #22]
    for ( j = 0 ; j < FontSize ; j++ )      // 16 x 16 (2 Bytes)
 8006530:	2300      	movs	r3, #0
 8006532:	83bb      	strh	r3, [r7, #28]
 8006534:	e02e      	b.n	8006594 <disHanFont+0x8c>
    {
      uint8_t font_data;

      font_data = FontPtr->FontBuffer[i*FontSize +j];
 8006536:	8bfb      	ldrh	r3, [r7, #30]
 8006538:	8b3a      	ldrh	r2, [r7, #24]
 800653a:	fb03 f202 	mul.w	r2, r3, r2
 800653e:	8bbb      	ldrh	r3, [r7, #28]
 8006540:	4413      	add	r3, r2
 8006542:	687a      	ldr	r2, [r7, #4]
 8006544:	4413      	add	r3, r2
 8006546:	799b      	ldrb	r3, [r3, #6]
 8006548:	757b      	strb	r3, [r7, #21]

      for( Loop=0; Loop<8; Loop++ )
 800654a:	2300      	movs	r3, #0
 800654c:	837b      	strh	r3, [r7, #26]
 800654e:	e01b      	b.n	8006588 <disHanFont+0x80>
      {
        if( (font_data<<Loop) & (0x80))
 8006550:	7d7a      	ldrb	r2, [r7, #21]
 8006552:	8b7b      	ldrh	r3, [r7, #26]
 8006554:	fa02 f303 	lsl.w	r3, r2, r3
 8006558:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800655c:	2b00      	cmp	r3, #0
 800655e:	d00d      	beq.n	800657c <disHanFont+0x74>
        {
          lcdDrawPixel(x + index_x, y + i, textcolor);
 8006560:	68fb      	ldr	r3, [r7, #12]
 8006562:	b29a      	uxth	r2, r3
 8006564:	8afb      	ldrh	r3, [r7, #22]
 8006566:	4413      	add	r3, r2
 8006568:	b298      	uxth	r0, r3
 800656a:	68bb      	ldr	r3, [r7, #8]
 800656c:	b29a      	uxth	r2, r3
 800656e:	8bfb      	ldrh	r3, [r7, #30]
 8006570:	4413      	add	r3, r2
 8006572:	b29b      	uxth	r3, r3
 8006574:	887a      	ldrh	r2, [r7, #2]
 8006576:	4619      	mov	r1, r3
 8006578:	f7ff fcc0 	bl	8005efc <lcdDrawPixel>
        }
        index_x++;
 800657c:	8afb      	ldrh	r3, [r7, #22]
 800657e:	3301      	adds	r3, #1
 8006580:	82fb      	strh	r3, [r7, #22]
      for( Loop=0; Loop<8; Loop++ )
 8006582:	8b7b      	ldrh	r3, [r7, #26]
 8006584:	3301      	adds	r3, #1
 8006586:	837b      	strh	r3, [r7, #26]
 8006588:	8b7b      	ldrh	r3, [r7, #26]
 800658a:	2b07      	cmp	r3, #7
 800658c:	d9e0      	bls.n	8006550 <disHanFont+0x48>
    for ( j = 0 ; j < FontSize ; j++ )      // 16 x 16 (2 Bytes)
 800658e:	8bbb      	ldrh	r3, [r7, #28]
 8006590:	3301      	adds	r3, #1
 8006592:	83bb      	strh	r3, [r7, #28]
 8006594:	8bba      	ldrh	r2, [r7, #28]
 8006596:	8b3b      	ldrh	r3, [r7, #24]
 8006598:	429a      	cmp	r2, r3
 800659a:	d3cc      	bcc.n	8006536 <disHanFont+0x2e>
  for ( i = 0 ; i < 16 ; i++ )        // 16 Lines per Font/Char
 800659c:	8bfb      	ldrh	r3, [r7, #30]
 800659e:	3301      	adds	r3, #1
 80065a0:	83fb      	strh	r3, [r7, #30]
 80065a2:	8bfb      	ldrh	r3, [r7, #30]
 80065a4:	2b0f      	cmp	r3, #15
 80065a6:	d9c1      	bls.n	800652c <disHanFont+0x24>
      }
    }
  }
}
 80065a8:	bf00      	nop
 80065aa:	bf00      	nop
 80065ac:	3720      	adds	r7, #32
 80065ae:	46bd      	mov	sp, r7
 80065b0:	bd80      	pop	{r7, pc}
 80065b2:	bf00      	nop

080065b4 <disEngFont>:

void disEngFont(int x, int y, char ch, lcd_font_t *font, uint16_t textcolor)
{
 80065b4:	b580      	push	{r7, lr}
 80065b6:	b088      	sub	sp, #32
 80065b8:	af00      	add	r7, sp, #0
 80065ba:	60f8      	str	r0, [r7, #12]
 80065bc:	60b9      	str	r1, [r7, #8]
 80065be:	603b      	str	r3, [r7, #0]
 80065c0:	4613      	mov	r3, r2
 80065c2:	71fb      	strb	r3, [r7, #7]
  uint32_t i, b, j;


  // We gaan door het font
  for (i = 0; i < font->height; i++)
 80065c4:	2300      	movs	r3, #0
 80065c6:	61fb      	str	r3, [r7, #28]
 80065c8:	e035      	b.n	8006636 <disEngFont+0x82>
  {
    b = font->data[(ch - 32) * font->height + i];
 80065ca:	683b      	ldr	r3, [r7, #0]
 80065cc:	685a      	ldr	r2, [r3, #4]
 80065ce:	79fb      	ldrb	r3, [r7, #7]
 80065d0:	3b20      	subs	r3, #32
 80065d2:	6839      	ldr	r1, [r7, #0]
 80065d4:	7849      	ldrb	r1, [r1, #1]
 80065d6:	fb01 f303 	mul.w	r3, r1, r3
 80065da:	4619      	mov	r1, r3
 80065dc:	69fb      	ldr	r3, [r7, #28]
 80065de:	440b      	add	r3, r1
 80065e0:	005b      	lsls	r3, r3, #1
 80065e2:	4413      	add	r3, r2
 80065e4:	881b      	ldrh	r3, [r3, #0]
 80065e6:	617b      	str	r3, [r7, #20]
    for (j = 0; j < font->width; j++)
 80065e8:	2300      	movs	r3, #0
 80065ea:	61bb      	str	r3, [r7, #24]
 80065ec:	e01a      	b.n	8006624 <disEngFont+0x70>
    {
      if ((b << j) & 0x8000)
 80065ee:	697a      	ldr	r2, [r7, #20]
 80065f0:	69bb      	ldr	r3, [r7, #24]
 80065f2:	fa02 f303 	lsl.w	r3, r2, r3
 80065f6:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80065fa:	2b00      	cmp	r3, #0
 80065fc:	d00f      	beq.n	800661e <disEngFont+0x6a>
      {
        lcdDrawPixel(x + j, (y + i), textcolor);
 80065fe:	68fb      	ldr	r3, [r7, #12]
 8006600:	b29a      	uxth	r2, r3
 8006602:	69bb      	ldr	r3, [r7, #24]
 8006604:	b29b      	uxth	r3, r3
 8006606:	4413      	add	r3, r2
 8006608:	b298      	uxth	r0, r3
 800660a:	68bb      	ldr	r3, [r7, #8]
 800660c:	b29a      	uxth	r2, r3
 800660e:	69fb      	ldr	r3, [r7, #28]
 8006610:	b29b      	uxth	r3, r3
 8006612:	4413      	add	r3, r2
 8006614:	b29b      	uxth	r3, r3
 8006616:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 8006618:	4619      	mov	r1, r3
 800661a:	f7ff fc6f 	bl	8005efc <lcdDrawPixel>
    for (j = 0; j < font->width; j++)
 800661e:	69bb      	ldr	r3, [r7, #24]
 8006620:	3301      	adds	r3, #1
 8006622:	61bb      	str	r3, [r7, #24]
 8006624:	683b      	ldr	r3, [r7, #0]
 8006626:	781b      	ldrb	r3, [r3, #0]
 8006628:	461a      	mov	r2, r3
 800662a:	69bb      	ldr	r3, [r7, #24]
 800662c:	4293      	cmp	r3, r2
 800662e:	d3de      	bcc.n	80065ee <disEngFont+0x3a>
  for (i = 0; i < font->height; i++)
 8006630:	69fb      	ldr	r3, [r7, #28]
 8006632:	3301      	adds	r3, #1
 8006634:	61fb      	str	r3, [r7, #28]
 8006636:	683b      	ldr	r3, [r7, #0]
 8006638:	785b      	ldrb	r3, [r3, #1]
 800663a:	461a      	mov	r2, r3
 800663c:	69fb      	ldr	r3, [r7, #28]
 800663e:	4293      	cmp	r3, r2
 8006640:	d3c3      	bcc.n	80065ca <disEngFont+0x16>
      }
    }
  }
}
 8006642:	bf00      	nop
 8006644:	bf00      	nop
 8006646:	3720      	adds	r7, #32
 8006648:	46bd      	mov	sp, r7
 800664a:	bd80      	pop	{r7, pc}

0800664c <lcdSetFont>:

void lcdSetFont(LcdFont font)
{
 800664c:	b480      	push	{r7}
 800664e:	b083      	sub	sp, #12
 8006650:	af00      	add	r7, sp, #0
 8006652:	4603      	mov	r3, r0
 8006654:	71fb      	strb	r3, [r7, #7]
  lcd_font = font;
 8006656:	4a04      	ldr	r2, [pc, #16]	@ (8006668 <lcdSetFont+0x1c>)
 8006658:	79fb      	ldrb	r3, [r7, #7]
 800665a:	7013      	strb	r3, [r2, #0]
}
 800665c:	bf00      	nop
 800665e:	370c      	adds	r7, #12
 8006660:	46bd      	mov	sp, r7
 8006662:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006666:	4770      	bx	lr
 8006668:	20000089 	.word	0x20000089

0800666c <cliLcd>:
}

#ifdef _USE_HW_CLI

void cliLcd(cli_args_t *args)
{
 800666c:	b580      	push	{r7, lr}
 800666e:	b086      	sub	sp, #24
 8006670:	af02      	add	r7, sp, #8
 8006672:	6078      	str	r0, [r7, #4]
	bool ret = false;
 8006674:	2300      	movs	r3, #0
 8006676:	73fb      	strb	r3, [r7, #15]

	if(args->argc == 1 && args->isStr(0, "test") == true)
 8006678:	687b      	ldr	r3, [r7, #4]
 800667a:	881b      	ldrh	r3, [r3, #0]
 800667c:	2b01      	cmp	r3, #1
 800667e:	d163      	bne.n	8006748 <cliLcd+0xdc>
 8006680:	687b      	ldr	r3, [r7, #4]
 8006682:	695b      	ldr	r3, [r3, #20]
 8006684:	494e      	ldr	r1, [pc, #312]	@ (80067c0 <cliLcd+0x154>)
 8006686:	2000      	movs	r0, #0
 8006688:	4798      	blx	r3
 800668a:	4603      	mov	r3, r0
 800668c:	2b00      	cmp	r3, #0
 800668e:	d05b      	beq.n	8006748 <cliLcd+0xdc>
	{
		lcdSetFont(LCD_FONT_HAN);
 8006690:	2003      	movs	r0, #3
 8006692:	f7ff ffdb 	bl	800664c <lcdSetFont>

		while(cliKeepLoop())
 8006696:	e04b      	b.n	8006730 <cliLcd+0xc4>
		{
			if(lcdDrawAvailable() == true)
 8006698:	f7ff fc6a 	bl	8005f70 <lcdDrawAvailable>
 800669c:	4603      	mov	r3, r0
 800669e:	2b00      	cmp	r3, #0
 80066a0:	d046      	beq.n	8006730 <cliLcd+0xc4>
			{
				lcdClearBuffer(black);
 80066a2:	2000      	movs	r0, #0
 80066a4:	f7ff fc34 	bl	8005f10 <lcdClearBuffer>

				lcdPrintf(25, 16*0, green, "[LCD Test]");
 80066a8:	4b46      	ldr	r3, [pc, #280]	@ (80067c4 <cliLcd+0x158>)
 80066aa:	f44f 62fc 	mov.w	r2, #2016	@ 0x7e0
 80066ae:	2100      	movs	r1, #0
 80066b0:	2019      	movs	r0, #25
 80066b2:	f7ff fdfb 	bl	80062ac <lcdPrintf>

				lcdPrintf(0, 16*1, white, "%d fps", lcdGetFps());
 80066b6:	f7ff fc43 	bl	8005f40 <lcdGetFps>
 80066ba:	4603      	mov	r3, r0
 80066bc:	9300      	str	r3, [sp, #0]
 80066be:	4b42      	ldr	r3, [pc, #264]	@ (80067c8 <cliLcd+0x15c>)
 80066c0:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80066c4:	2110      	movs	r1, #16
 80066c6:	2000      	movs	r0, #0
 80066c8:	f7ff fdf0 	bl	80062ac <lcdPrintf>
				lcdPrintf(0, 16*2, white, "%d ms", lcdGetFpsTime());
 80066cc:	f7ff fc44 	bl	8005f58 <lcdGetFpsTime>
 80066d0:	4603      	mov	r3, r0
 80066d2:	9300      	str	r3, [sp, #0]
 80066d4:	4b3d      	ldr	r3, [pc, #244]	@ (80067cc <cliLcd+0x160>)
 80066d6:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80066da:	2120      	movs	r1, #32
 80066dc:	2000      	movs	r0, #0
 80066de:	f7ff fde5 	bl	80062ac <lcdPrintf>
				lcdPrintf(0, 16*3, white, "%d ms", millis());
 80066e2:	f7fb f9d5 	bl	8001a90 <millis>
 80066e6:	4603      	mov	r3, r0
 80066e8:	9300      	str	r3, [sp, #0]
 80066ea:	4b38      	ldr	r3, [pc, #224]	@ (80067cc <cliLcd+0x160>)
 80066ec:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80066f0:	2130      	movs	r1, #48	@ 0x30
 80066f2:	2000      	movs	r0, #0
 80066f4:	f7ff fdda 	bl	80062ac <lcdPrintf>

				lcdDrawFillRect(0, 70, 10, 10, red);
 80066f8:	f44f 4378 	mov.w	r3, #63488	@ 0xf800
 80066fc:	9300      	str	r3, [sp, #0]
 80066fe:	230a      	movs	r3, #10
 8006700:	220a      	movs	r2, #10
 8006702:	2146      	movs	r1, #70	@ 0x46
 8006704:	2000      	movs	r0, #0
 8006706:	f7ff fda1 	bl	800624c <lcdDrawFillRect>
				lcdDrawFillRect(10, 70, 10, 10, green);
 800670a:	f44f 63fc 	mov.w	r3, #2016	@ 0x7e0
 800670e:	9300      	str	r3, [sp, #0]
 8006710:	230a      	movs	r3, #10
 8006712:	220a      	movs	r2, #10
 8006714:	2146      	movs	r1, #70	@ 0x46
 8006716:	200a      	movs	r0, #10
 8006718:	f7ff fd98 	bl	800624c <lcdDrawFillRect>
				lcdDrawFillRect(20, 70, 10, 10, blue);
 800671c:	231f      	movs	r3, #31
 800671e:	9300      	str	r3, [sp, #0]
 8006720:	230a      	movs	r3, #10
 8006722:	220a      	movs	r2, #10
 8006724:	2146      	movs	r1, #70	@ 0x46
 8006726:	2014      	movs	r0, #20
 8006728:	f7ff fd90 	bl	800624c <lcdDrawFillRect>

				lcdRequestDraw();
 800672c:	f7ff fc36 	bl	8005f9c <lcdRequestDraw>
		while(cliKeepLoop())
 8006730:	f7fc fea4 	bl	800347c <cliKeepLoop>
 8006734:	4603      	mov	r3, r0
 8006736:	2b00      	cmp	r3, #0
 8006738:	d1ae      	bne.n	8006698 <cliLcd+0x2c>
			}
		}

		lcdClearBuffer(black);
 800673a:	2000      	movs	r0, #0
 800673c:	f7ff fbe8 	bl	8005f10 <lcdClearBuffer>
		lcdUpdateDraw();
 8006740:	f7ff fc60 	bl	8006004 <lcdUpdateDraw>

		ret = true;
 8006744:	2301      	movs	r3, #1
 8006746:	73fb      	strb	r3, [r7, #15]
	}

	if(args->argc == 2 && args->isStr(0, "bl") == true)
 8006748:	687b      	ldr	r3, [r7, #4]
 800674a:	881b      	ldrh	r3, [r3, #0]
 800674c:	2b02      	cmp	r3, #2
 800674e:	d126      	bne.n	800679e <cliLcd+0x132>
 8006750:	687b      	ldr	r3, [r7, #4]
 8006752:	695b      	ldr	r3, [r3, #20]
 8006754:	491e      	ldr	r1, [pc, #120]	@ (80067d0 <cliLcd+0x164>)
 8006756:	2000      	movs	r0, #0
 8006758:	4798      	blx	r3
 800675a:	4603      	mov	r3, r0
 800675c:	2b00      	cmp	r3, #0
 800675e:	d01e      	beq.n	800679e <cliLcd+0x132>
	{
		char *bl_status;

		bl_status = args->getStr(1);
 8006760:	687b      	ldr	r3, [r7, #4]
 8006762:	691b      	ldr	r3, [r3, #16]
 8006764:	2001      	movs	r0, #1
 8006766:	4798      	blx	r3
 8006768:	60b8      	str	r0, [r7, #8]

		if(bl_status != NULL)
 800676a:	68bb      	ldr	r3, [r7, #8]
 800676c:	2b00      	cmp	r3, #0
 800676e:	d014      	beq.n	800679a <cliLcd+0x12e>
		{
			if(strcmp(bl_status, "on") == 0)
 8006770:	4918      	ldr	r1, [pc, #96]	@ (80067d4 <cliLcd+0x168>)
 8006772:	68b8      	ldr	r0, [r7, #8]
 8006774:	f7f9 fd94 	bl	80002a0 <strcmp>
 8006778:	4603      	mov	r3, r0
 800677a:	2b00      	cmp	r3, #0
 800677c:	d103      	bne.n	8006786 <cliLcd+0x11a>
			{
				lcdSetBackLight(100);
 800677e:	2064      	movs	r0, #100	@ 0x64
 8006780:	f7ff fb96 	bl	8005eb0 <lcdSetBackLight>
 8006784:	e009      	b.n	800679a <cliLcd+0x12e>
			}
			else if(strcmp(bl_status, "off") == 0)
 8006786:	4914      	ldr	r1, [pc, #80]	@ (80067d8 <cliLcd+0x16c>)
 8006788:	68b8      	ldr	r0, [r7, #8]
 800678a:	f7f9 fd89 	bl	80002a0 <strcmp>
 800678e:	4603      	mov	r3, r0
 8006790:	2b00      	cmp	r3, #0
 8006792:	d102      	bne.n	800679a <cliLcd+0x12e>
			{
				lcdSetBackLight(0);
 8006794:	2000      	movs	r0, #0
 8006796:	f7ff fb8b 	bl	8005eb0 <lcdSetBackLight>
			else
			{
			}
		}

		ret = true;
 800679a:	2301      	movs	r3, #1
 800679c:	73fb      	strb	r3, [r7, #15]
	}

	if(ret != true)
 800679e:	7bfb      	ldrb	r3, [r7, #15]
 80067a0:	f083 0301 	eor.w	r3, r3, #1
 80067a4:	b2db      	uxtb	r3, r3
 80067a6:	2b00      	cmp	r3, #0
 80067a8:	d005      	beq.n	80067b6 <cliLcd+0x14a>
	{
		cliPrintf("lcd test\n");
 80067aa:	480c      	ldr	r0, [pc, #48]	@ (80067dc <cliLcd+0x170>)
 80067ac:	f7fc fd6c 	bl	8003288 <cliPrintf>
		cliPrintf("lcd bl on/off\n");
 80067b0:	480b      	ldr	r0, [pc, #44]	@ (80067e0 <cliLcd+0x174>)
 80067b2:	f7fc fd69 	bl	8003288 <cliPrintf>
	}
}
 80067b6:	bf00      	nop
 80067b8:	3710      	adds	r7, #16
 80067ba:	46bd      	mov	sp, r7
 80067bc:	bd80      	pop	{r7, pc}
 80067be:	bf00      	nop
 80067c0:	08035088 	.word	0x08035088
 80067c4:	08035090 	.word	0x08035090
 80067c8:	0803509c 	.word	0x0803509c
 80067cc:	080350a4 	.word	0x080350a4
 80067d0:	080350ac 	.word	0x080350ac
 80067d4:	080350b0 	.word	0x080350b0
 80067d8:	080350b4 	.word	0x080350b4
 80067dc:	080350b8 	.word	0x080350b8
 80067e0:	080350c4 	.word	0x080350c4

080067e4 <ledInit>:
				{GPIOC, GPIO_PIN_13, GPIO_PIN_RESET, GPIO_PIN_SET},
		};


bool ledInit(void)
{
 80067e4:	b580      	push	{r7, lr}
 80067e6:	b082      	sub	sp, #8
 80067e8:	af00      	add	r7, sp, #0
	for(int i=0; i<LED_MAX_CH; i++)
 80067ea:	2300      	movs	r3, #0
 80067ec:	607b      	str	r3, [r7, #4]
 80067ee:	e007      	b.n	8006800 <ledInit+0x1c>
	{
		ledOff(i);
 80067f0:	687b      	ldr	r3, [r7, #4]
 80067f2:	b2db      	uxtb	r3, r3
 80067f4:	4618      	mov	r0, r3
 80067f6:	f000 f813 	bl	8006820 <ledOff>
	for(int i=0; i<LED_MAX_CH; i++)
 80067fa:	687b      	ldr	r3, [r7, #4]
 80067fc:	3301      	adds	r3, #1
 80067fe:	607b      	str	r3, [r7, #4]
 8006800:	687b      	ldr	r3, [r7, #4]
 8006802:	2b00      	cmp	r3, #0
 8006804:	ddf4      	ble.n	80067f0 <ledInit+0xc>
	}

#ifdef _USE_HW_CLI
	cliAdd("led", cliLed);
 8006806:	4904      	ldr	r1, [pc, #16]	@ (8006818 <ledInit+0x34>)
 8006808:	4804      	ldr	r0, [pc, #16]	@ (800681c <ledInit+0x38>)
 800680a:	f7fc fe4d 	bl	80034a8 <cliAdd>
#endif

	return true;
 800680e:	2301      	movs	r3, #1
}
 8006810:	4618      	mov	r0, r3
 8006812:	3708      	adds	r7, #8
 8006814:	46bd      	mov	sp, r7
 8006816:	bd80      	pop	{r7, pc}
 8006818:	08006899 	.word	0x08006899
 800681c:	080247b4 	.word	0x080247b4

08006820 <ledOff>:

	HAL_GPIO_WritePin(led_tbl[ch].port, led_tbl[ch].pin, led_tbl[ch].on_state);
}

void ledOff(uint8_t ch)
{
 8006820:	b580      	push	{r7, lr}
 8006822:	b082      	sub	sp, #8
 8006824:	af00      	add	r7, sp, #0
 8006826:	4603      	mov	r3, r0
 8006828:	71fb      	strb	r3, [r7, #7]
	if(ch >= LED_MAX_CH) return;
 800682a:	79fb      	ldrb	r3, [r7, #7]
 800682c:	2b00      	cmp	r3, #0
 800682e:	d111      	bne.n	8006854 <ledOff+0x34>

	HAL_GPIO_WritePin(led_tbl[ch].port, led_tbl[ch].pin, led_tbl[ch].off_state);
 8006830:	79fb      	ldrb	r3, [r7, #7]
 8006832:	4a0a      	ldr	r2, [pc, #40]	@ (800685c <ledOff+0x3c>)
 8006834:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
 8006838:	79fb      	ldrb	r3, [r7, #7]
 800683a:	4a08      	ldr	r2, [pc, #32]	@ (800685c <ledOff+0x3c>)
 800683c:	00db      	lsls	r3, r3, #3
 800683e:	4413      	add	r3, r2
 8006840:	8899      	ldrh	r1, [r3, #4]
 8006842:	79fb      	ldrb	r3, [r7, #7]
 8006844:	4a05      	ldr	r2, [pc, #20]	@ (800685c <ledOff+0x3c>)
 8006846:	00db      	lsls	r3, r3, #3
 8006848:	4413      	add	r3, r2
 800684a:	79db      	ldrb	r3, [r3, #7]
 800684c:	461a      	mov	r2, r3
 800684e:	f003 fd6f 	bl	800a330 <HAL_GPIO_WritePin>
 8006852:	e000      	b.n	8006856 <ledOff+0x36>
	if(ch >= LED_MAX_CH) return;
 8006854:	bf00      	nop
}
 8006856:	3708      	adds	r7, #8
 8006858:	46bd      	mov	sp, r7
 800685a:	bd80      	pop	{r7, pc}
 800685c:	2000009c 	.word	0x2000009c

08006860 <ledToggle>:

void ledToggle(uint8_t ch)
{
 8006860:	b580      	push	{r7, lr}
 8006862:	b082      	sub	sp, #8
 8006864:	af00      	add	r7, sp, #0
 8006866:	4603      	mov	r3, r0
 8006868:	71fb      	strb	r3, [r7, #7]
	if(ch >= LED_MAX_CH) return;
 800686a:	79fb      	ldrb	r3, [r7, #7]
 800686c:	2b00      	cmp	r3, #0
 800686e:	d10d      	bne.n	800688c <ledToggle+0x2c>

	HAL_GPIO_TogglePin(led_tbl[ch].port, led_tbl[ch].pin);
 8006870:	79fb      	ldrb	r3, [r7, #7]
 8006872:	4a08      	ldr	r2, [pc, #32]	@ (8006894 <ledToggle+0x34>)
 8006874:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8006878:	79fb      	ldrb	r3, [r7, #7]
 800687a:	4906      	ldr	r1, [pc, #24]	@ (8006894 <ledToggle+0x34>)
 800687c:	00db      	lsls	r3, r3, #3
 800687e:	440b      	add	r3, r1
 8006880:	889b      	ldrh	r3, [r3, #4]
 8006882:	4619      	mov	r1, r3
 8006884:	4610      	mov	r0, r2
 8006886:	f003 fd6c 	bl	800a362 <HAL_GPIO_TogglePin>
 800688a:	e000      	b.n	800688e <ledToggle+0x2e>
	if(ch >= LED_MAX_CH) return;
 800688c:	bf00      	nop
}
 800688e:	3708      	adds	r7, #8
 8006890:	46bd      	mov	sp, r7
 8006892:	bd80      	pop	{r7, pc}
 8006894:	2000009c 	.word	0x2000009c

08006898 <cliLed>:


#ifdef _USE_HW_CLI

void cliLed(cli_args_t *args)
{
 8006898:	b580      	push	{r7, lr}
 800689a:	b086      	sub	sp, #24
 800689c:	af00      	add	r7, sp, #0
 800689e:	6078      	str	r0, [r7, #4]
	bool ret = false;
 80068a0:	2300      	movs	r3, #0
 80068a2:	75fb      	strb	r3, [r7, #23]

	if(args->argc == 3 && args->isStr(0, "toggle") == true)
 80068a4:	687b      	ldr	r3, [r7, #4]
 80068a6:	881b      	ldrh	r3, [r3, #0]
 80068a8:	2b03      	cmp	r3, #3
 80068aa:	d133      	bne.n	8006914 <cliLed+0x7c>
 80068ac:	687b      	ldr	r3, [r7, #4]
 80068ae:	695b      	ldr	r3, [r3, #20]
 80068b0:	491f      	ldr	r1, [pc, #124]	@ (8006930 <cliLed+0x98>)
 80068b2:	2000      	movs	r0, #0
 80068b4:	4798      	blx	r3
 80068b6:	4603      	mov	r3, r0
 80068b8:	2b00      	cmp	r3, #0
 80068ba:	d02b      	beq.n	8006914 <cliLed+0x7c>
	{
		uint8_t led_ch;
		uint32_t toggle_time;
		uint32_t pre_time;

		led_ch = (uint8_t)args->getData(1);
 80068bc:	687b      	ldr	r3, [r7, #4]
 80068be:	689b      	ldr	r3, [r3, #8]
 80068c0:	2001      	movs	r0, #1
 80068c2:	4798      	blx	r3
 80068c4:	4603      	mov	r3, r0
 80068c6:	75bb      	strb	r3, [r7, #22]
		toggle_time = (uint32_t)args->getData(2);
 80068c8:	687b      	ldr	r3, [r7, #4]
 80068ca:	689b      	ldr	r3, [r3, #8]
 80068cc:	2002      	movs	r0, #2
 80068ce:	4798      	blx	r3
 80068d0:	4603      	mov	r3, r0
 80068d2:	60fb      	str	r3, [r7, #12]

		if(led_ch > 0)
 80068d4:	7dbb      	ldrb	r3, [r7, #22]
 80068d6:	2b00      	cmp	r3, #0
 80068d8:	d002      	beq.n	80068e0 <cliLed+0x48>
		{
			led_ch--;
 80068da:	7dbb      	ldrb	r3, [r7, #22]
 80068dc:	3b01      	subs	r3, #1
 80068de:	75bb      	strb	r3, [r7, #22]
		}

		pre_time = millis();
 80068e0:	f7fb f8d6 	bl	8001a90 <millis>
 80068e4:	6138      	str	r0, [r7, #16]
		while(cliKeepLoop())
 80068e6:	e00e      	b.n	8006906 <cliLed+0x6e>
		{
			if(millis() - pre_time >= toggle_time)
 80068e8:	f7fb f8d2 	bl	8001a90 <millis>
 80068ec:	4602      	mov	r2, r0
 80068ee:	693b      	ldr	r3, [r7, #16]
 80068f0:	1ad3      	subs	r3, r2, r3
 80068f2:	68fa      	ldr	r2, [r7, #12]
 80068f4:	429a      	cmp	r2, r3
 80068f6:	d806      	bhi.n	8006906 <cliLed+0x6e>
			{
				pre_time = millis();
 80068f8:	f7fb f8ca 	bl	8001a90 <millis>
 80068fc:	6138      	str	r0, [r7, #16]
				ledToggle(led_ch);
 80068fe:	7dbb      	ldrb	r3, [r7, #22]
 8006900:	4618      	mov	r0, r3
 8006902:	f7ff ffad 	bl	8006860 <ledToggle>
		while(cliKeepLoop())
 8006906:	f7fc fdb9 	bl	800347c <cliKeepLoop>
 800690a:	4603      	mov	r3, r0
 800690c:	2b00      	cmp	r3, #0
 800690e:	d1eb      	bne.n	80068e8 <cliLed+0x50>
			}
		}

		ret = true;
 8006910:	2301      	movs	r3, #1
 8006912:	75fb      	strb	r3, [r7, #23]
	}

	if(ret != true)
 8006914:	7dfb      	ldrb	r3, [r7, #23]
 8006916:	f083 0301 	eor.w	r3, r3, #1
 800691a:	b2db      	uxtb	r3, r3
 800691c:	2b00      	cmp	r3, #0
 800691e:	d003      	beq.n	8006928 <cliLed+0x90>
	{
		cliPrintf("led toggle ch[1~%d] time_ms\n", LED_MAX_CH);
 8006920:	2101      	movs	r1, #1
 8006922:	4804      	ldr	r0, [pc, #16]	@ (8006934 <cliLed+0x9c>)
 8006924:	f7fc fcb0 	bl	8003288 <cliPrintf>
	}
}
 8006928:	bf00      	nop
 800692a:	3718      	adds	r7, #24
 800692c:	46bd      	mov	sp, r7
 800692e:	bd80      	pop	{r7, pc}
 8006930:	080247b8 	.word	0x080247b8
 8006934:	080247c0 	.word	0x080247c0

08006938 <TransferDoneISR>:
#ifdef _USE_HW_CLI
static void cliMCP2515(cli_args_t *args);
#endif

static void TransferDoneISR(void)
{
 8006938:	b480      	push	{r7}
 800693a:	af00      	add	r7, sp, #0

}
 800693c:	bf00      	nop
 800693e:	46bd      	mov	sp, r7
 8006940:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006944:	4770      	bx	lr
	...

08006948 <mcp2515Init>:

bool mcp2515Init(void)
{
 8006948:	b580      	push	{r7, lr}
 800694a:	b088      	sub	sp, #32
 800694c:	af00      	add	r7, sp, #0
	bool ret = true;
 800694e:	2301      	movs	r3, #1
 8006950:	74fb      	strb	r3, [r7, #19]

	ret = spiBegin(spi_ch);
 8006952:	2301      	movs	r3, #1
 8006954:	4618      	mov	r0, r3
 8006956:	f001 fd9b 	bl	8008490 <spiBegin>
 800695a:	4603      	mov	r3, r0
 800695c:	74fb      	strb	r3, [r7, #19]
	spiAttachTxInterrupt(spi_ch, TransferDoneISR);
 800695e:	2301      	movs	r3, #1
 8006960:	4945      	ldr	r1, [pc, #276]	@ (8006a78 <mcp2515Init+0x130>)
 8006962:	4618      	mov	r0, r3
 8006964:	f001 fe80 	bl	8008668 <spiAttachTxInterrupt>

	gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 8006968:	2101      	movs	r1, #1
 800696a:	2004      	movs	r0, #4
 800696c:	f7fd f9fc 	bl	8003d68 <gpioPinWrite>

	is_init = mcp2515Reset();
 8006970:	f000 f88a 	bl	8006a88 <mcp2515Reset>
 8006974:	4603      	mov	r3, r0
 8006976:	461a      	mov	r2, r3
 8006978:	4b40      	ldr	r3, [pc, #256]	@ (8006a7c <mcp2515Init+0x134>)
 800697a:	701a      	strb	r2, [r3, #0]

	if(is_init == true)
 800697c:	4b3f      	ldr	r3, [pc, #252]	@ (8006a7c <mcp2515Init+0x134>)
 800697e:	781b      	ldrb	r3, [r3, #0]
 8006980:	2b00      	cmp	r3, #0
 8006982:	d06f      	beq.n	8006a64 <mcp2515Init+0x11c>
	{
		uint8_t zeros[14];

		memset(zeros, 0, sizeof(zeros));
 8006984:	1d3b      	adds	r3, r7, #4
 8006986:	220e      	movs	r2, #14
 8006988:	2100      	movs	r1, #0
 800698a:	4618      	mov	r0, r3
 800698c:	f01b fbba 	bl	8022104 <memset>
		mcp2515WriteRegs(MCP_TXB0CTRL, zeros, 14);
 8006990:	1d3b      	adds	r3, r7, #4
 8006992:	220e      	movs	r2, #14
 8006994:	4619      	mov	r1, r3
 8006996:	2030      	movs	r0, #48	@ 0x30
 8006998:	f000 fbf5 	bl	8007186 <mcp2515WriteRegs>
		mcp2515WriteRegs(MCP_TXB1CTRL, zeros, 14);
 800699c:	1d3b      	adds	r3, r7, #4
 800699e:	220e      	movs	r2, #14
 80069a0:	4619      	mov	r1, r3
 80069a2:	2040      	movs	r0, #64	@ 0x40
 80069a4:	f000 fbef 	bl	8007186 <mcp2515WriteRegs>
    mcp2515WriteRegs(MCP_TXB2CTRL, zeros, 14);
 80069a8:	1d3b      	adds	r3, r7, #4
 80069aa:	220e      	movs	r2, #14
 80069ac:	4619      	mov	r1, r3
 80069ae:	2050      	movs	r0, #80	@ 0x50
 80069b0:	f000 fbe9 	bl	8007186 <mcp2515WriteRegs>

    mcp2515WriteReg(MCP_RXB0CTRL, 0);
 80069b4:	2100      	movs	r1, #0
 80069b6:	2060      	movs	r0, #96	@ 0x60
 80069b8:	f000 fbbc 	bl	8007134 <mcp2515WriteReg>
    mcp2515WriteReg(MCP_RXB1CTRL, 0);
 80069bc:	2100      	movs	r1, #0
 80069be:	2070      	movs	r0, #112	@ 0x70
 80069c0:	f000 fbb8 	bl	8007134 <mcp2515WriteReg>

    mcp2515WriteReg(MCP_CANINTE, CANINTF_RX0IF | CANINTF_RX1IF | CANINTF_ERRIF | CANINTF_MERRF);
 80069c4:	21a3      	movs	r1, #163	@ 0xa3
 80069c6:	202b      	movs	r0, #43	@ 0x2b
 80069c8:	f000 fbb4 	bl	8007134 <mcp2515WriteReg>

    // receives all valid messages using either Standard or Extended Identifiers that
    // meet filter criteria. RXF0 is applied for RXB0, RXF1 is applied for RXB1
    mcp2515ModifyReg(MCP_RXB0CTRL,
 80069cc:	2260      	movs	r2, #96	@ 0x60
 80069ce:	2304      	movs	r3, #4
 80069d0:	4313      	orrs	r3, r2
 80069d2:	b2db      	uxtb	r3, r3
 80069d4:	2203      	movs	r2, #3
 80069d6:	4313      	orrs	r3, r2
 80069d8:	b2d9      	uxtb	r1, r3
 80069da:	2200      	movs	r2, #0
 80069dc:	2304      	movs	r3, #4
 80069de:	4313      	orrs	r3, r2
 80069e0:	b2db      	uxtb	r3, r3
 80069e2:	2200      	movs	r2, #0
 80069e4:	4313      	orrs	r3, r2
 80069e6:	b2db      	uxtb	r3, r3
 80069e8:	461a      	mov	r2, r3
 80069ea:	2060      	movs	r0, #96	@ 0x60
 80069ec:	f000 fbf8 	bl	80071e0 <mcp2515ModifyReg>
                   RXBnCTRL_RXM_MASK | RXB0CTRL_BUKT | RXB0CTRL_FILHIT_MASK,
									 RXBnCTRL_RXM_STDEXT | RXB0CTRL_BUKT | RXB0CTRL_FILHIT);
    mcp2515ModifyReg(MCP_RXB1CTRL,
 80069f0:	2260      	movs	r2, #96	@ 0x60
 80069f2:	2307      	movs	r3, #7
 80069f4:	4313      	orrs	r3, r2
 80069f6:	b2db      	uxtb	r3, r3
 80069f8:	2100      	movs	r1, #0
 80069fa:	2201      	movs	r2, #1
 80069fc:	430a      	orrs	r2, r1
 80069fe:	b2d2      	uxtb	r2, r2
 8006a00:	4619      	mov	r1, r3
 8006a02:	2070      	movs	r0, #112	@ 0x70
 8006a04:	f000 fbec 	bl	80071e0 <mcp2515ModifyReg>
	                 RXBnCTRL_RXM_MASK | RXB1CTRL_FILHIT_MASK,
                   RXBnCTRL_RXM_STDEXT | RXB1CTRL_FILHIT);

    for(int i=0; i<MCP_FILTER_MAX; i++)
 8006a08:	2300      	movs	r3, #0
 8006a0a:	61fb      	str	r3, [r7, #28]
 8006a0c:	e011      	b.n	8006a32 <mcp2515Init+0xea>
    {
    	bool ext;

    	if(i == 1)
 8006a0e:	69fb      	ldr	r3, [r7, #28]
 8006a10:	2b01      	cmp	r3, #1
 8006a12:	d102      	bne.n	8006a1a <mcp2515Init+0xd2>
    	{
    		ext = true;
 8006a14:	2301      	movs	r3, #1
 8006a16:	76fb      	strb	r3, [r7, #27]
 8006a18:	e001      	b.n	8006a1e <mcp2515Init+0xd6>
    	}
    	else
    	{
    		ext = false;
 8006a1a:	2300      	movs	r3, #0
 8006a1c:	76fb      	strb	r3, [r7, #27]
    	}
    	mcp2515SetFilter(i, ext, 0);
 8006a1e:	69fb      	ldr	r3, [r7, #28]
 8006a20:	b2db      	uxtb	r3, r3
 8006a22:	7ef9      	ldrb	r1, [r7, #27]
 8006a24:	2200      	movs	r2, #0
 8006a26:	4618      	mov	r0, r3
 8006a28:	f000 f9ce 	bl	8006dc8 <mcp2515SetFilter>
    for(int i=0; i<MCP_FILTER_MAX; i++)
 8006a2c:	69fb      	ldr	r3, [r7, #28]
 8006a2e:	3301      	adds	r3, #1
 8006a30:	61fb      	str	r3, [r7, #28]
 8006a32:	69fb      	ldr	r3, [r7, #28]
 8006a34:	2b05      	cmp	r3, #5
 8006a36:	ddea      	ble.n	8006a0e <mcp2515Init+0xc6>
    }
  	for(int i=0; i<MCP_MASK_MAX; i++)
 8006a38:	2300      	movs	r3, #0
 8006a3a:	617b      	str	r3, [r7, #20]
 8006a3c:	e009      	b.n	8006a52 <mcp2515Init+0x10a>
  	{
  		mcp2515SetFilterMask(i, true, 0);
 8006a3e:	697b      	ldr	r3, [r7, #20]
 8006a40:	b2db      	uxtb	r3, r3
 8006a42:	2200      	movs	r2, #0
 8006a44:	2101      	movs	r1, #1
 8006a46:	4618      	mov	r0, r3
 8006a48:	f000 f98c 	bl	8006d64 <mcp2515SetFilterMask>
  	for(int i=0; i<MCP_MASK_MAX; i++)
 8006a4c:	697b      	ldr	r3, [r7, #20]
 8006a4e:	3301      	adds	r3, #1
 8006a50:	617b      	str	r3, [r7, #20]
 8006a52:	697b      	ldr	r3, [r7, #20]
 8006a54:	2b01      	cmp	r3, #1
 8006a56:	ddf2      	ble.n	8006a3e <mcp2515Init+0xf6>
  	}

  	mcp2515SetMode(MCP_MODE_LOOPBACK);
 8006a58:	2002      	movs	r0, #2
 8006a5a:	f000 f834 	bl	8006ac6 <mcp2515SetMode>
  	mcp2515SetBaud(MCP_BAUD_125K);
 8006a5e:	2000      	movs	r0, #0
 8006a60:	f000 f878 	bl	8006b54 <mcp2515SetBaud>
	}

#ifdef _USE_HW_CLI
	cliAdd("mcp2515", cliMCP2515);
 8006a64:	4906      	ldr	r1, [pc, #24]	@ (8006a80 <mcp2515Init+0x138>)
 8006a66:	4807      	ldr	r0, [pc, #28]	@ (8006a84 <mcp2515Init+0x13c>)
 8006a68:	f7fc fd1e 	bl	80034a8 <cliAdd>
#endif

	return ret;
 8006a6c:	7cfb      	ldrb	r3, [r7, #19]
}
 8006a6e:	4618      	mov	r0, r3
 8006a70:	3720      	adds	r7, #32
 8006a72:	46bd      	mov	sp, r7
 8006a74:	bd80      	pop	{r7, pc}
 8006a76:	bf00      	nop
 8006a78:	08006939 	.word	0x08006939
 8006a7c:	2000a4c0 	.word	0x2000a4c0
 8006a80:	08007421 	.word	0x08007421
 8006a84:	080247e0 	.word	0x080247e0

08006a88 <mcp2515Reset>:

bool mcp2515Reset(void)
{
 8006a88:	b580      	push	{r7, lr}
 8006a8a:	b084      	sub	sp, #16
 8006a8c:	af02      	add	r7, sp, #8
	bool ret;
	uint8_t buf[1];

	buf[0] = MCP_INST_RESET;
 8006a8e:	23c0      	movs	r3, #192	@ 0xc0
 8006a90:	713b      	strb	r3, [r7, #4]
	gpioPinWrite(_PIN_DEF_CS, _DEF_LOW);
 8006a92:	2100      	movs	r1, #0
 8006a94:	2004      	movs	r0, #4
 8006a96:	f7fd f967 	bl	8003d68 <gpioPinWrite>
	ret = spiTransfer(spi_ch, buf, buf, 1, 10);
 8006a9a:	2001      	movs	r0, #1
 8006a9c:	1d3a      	adds	r2, r7, #4
 8006a9e:	1d39      	adds	r1, r7, #4
 8006aa0:	230a      	movs	r3, #10
 8006aa2:	9300      	str	r3, [sp, #0]
 8006aa4:	2301      	movs	r3, #1
 8006aa6:	f001 fd8f 	bl	80085c8 <spiTransfer>
 8006aaa:	4603      	mov	r3, r0
 8006aac:	71fb      	strb	r3, [r7, #7]
	gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 8006aae:	2101      	movs	r1, #1
 8006ab0:	2004      	movs	r0, #4
 8006ab2:	f7fd f959 	bl	8003d68 <gpioPinWrite>

	delay(10);
 8006ab6:	200a      	movs	r0, #10
 8006ab8:	f7fa ffdf 	bl	8001a7a <delay>

	return ret;
 8006abc:	79fb      	ldrb	r3, [r7, #7]
}
 8006abe:	4618      	mov	r0, r3
 8006ac0:	3708      	adds	r7, #8
 8006ac2:	46bd      	mov	sp, r7
 8006ac4:	bd80      	pop	{r7, pc}

08006ac6 <mcp2515SetMode>:

bool mcp2515SetMode(McpMode mode)
{
 8006ac6:	b580      	push	{r7, lr}
 8006ac8:	b084      	sub	sp, #16
 8006aca:	af00      	add	r7, sp, #0
 8006acc:	4603      	mov	r3, r0
 8006ace:	71fb      	strb	r3, [r7, #7]
	bool ret;
	uint8_t data = 0;
 8006ad0:	2300      	movs	r3, #0
 8006ad2:	73fb      	strb	r3, [r7, #15]
	uint8_t mask = 0;
 8006ad4:	2300      	movs	r3, #0
 8006ad6:	73bb      	strb	r3, [r7, #14]
	uint32_t pre_time;

	data = ((uint8_t)mode)<<5;
 8006ad8:	79fb      	ldrb	r3, [r7, #7]
 8006ada:	015b      	lsls	r3, r3, #5
 8006adc:	73fb      	strb	r3, [r7, #15]
	mask = 0x07<<5;
 8006ade:	23e0      	movs	r3, #224	@ 0xe0
 8006ae0:	73bb      	strb	r3, [r7, #14]

	ret = mcp2515ModifyReg(MCP_CANCTRL, mask, data);
 8006ae2:	7bfa      	ldrb	r2, [r7, #15]
 8006ae4:	7bbb      	ldrb	r3, [r7, #14]
 8006ae6:	4619      	mov	r1, r3
 8006ae8:	200f      	movs	r0, #15
 8006aea:	f000 fb79 	bl	80071e0 <mcp2515ModifyReg>
 8006aee:	4603      	mov	r3, r0
 8006af0:	737b      	strb	r3, [r7, #13]

	pre_time = millis();
 8006af2:	f7fa ffcd 	bl	8001a90 <millis>
 8006af6:	60b8      	str	r0, [r7, #8]
	while(millis()-pre_time < 10)
 8006af8:	e00a      	b.n	8006b10 <mcp2515SetMode+0x4a>
	{
		if((mcp2515ReadReg(MCP_CANSTAT)&mask) == data)
 8006afa:	200e      	movs	r0, #14
 8006afc:	f000 fac6 	bl	800708c <mcp2515ReadReg>
 8006b00:	4603      	mov	r3, r0
 8006b02:	461a      	mov	r2, r3
 8006b04:	7bbb      	ldrb	r3, [r7, #14]
 8006b06:	4013      	ands	r3, r2
 8006b08:	b2db      	uxtb	r3, r3
 8006b0a:	7bfa      	ldrb	r2, [r7, #15]
 8006b0c:	429a      	cmp	r2, r3
 8006b0e:	d007      	beq.n	8006b20 <mcp2515SetMode+0x5a>
	while(millis()-pre_time < 10)
 8006b10:	f7fa ffbe 	bl	8001a90 <millis>
 8006b14:	4602      	mov	r2, r0
 8006b16:	68bb      	ldr	r3, [r7, #8]
 8006b18:	1ad3      	subs	r3, r2, r3
 8006b1a:	2b09      	cmp	r3, #9
 8006b1c:	d9ed      	bls.n	8006afa <mcp2515SetMode+0x34>
 8006b1e:	e000      	b.n	8006b22 <mcp2515SetMode+0x5c>
		{
			break;
 8006b20:	bf00      	nop
		}
	}

	return ret;
 8006b22:	7b7b      	ldrb	r3, [r7, #13]
}
 8006b24:	4618      	mov	r0, r3
 8006b26:	3710      	adds	r7, #16
 8006b28:	46bd      	mov	sp, r7
 8006b2a:	bd80      	pop	{r7, pc}

08006b2c <mcp2515GetMode>:

McpMode mcp2515GetMode(void)
{
 8006b2c:	b580      	push	{r7, lr}
 8006b2e:	b082      	sub	sp, #8
 8006b30:	af00      	add	r7, sp, #0
	McpMode ret;
	uint8_t data;

	data = (mcp2515ReadReg(MCP_CANSTAT) >> 5) & 0x07;
 8006b32:	200e      	movs	r0, #14
 8006b34:	f000 faaa 	bl	800708c <mcp2515ReadReg>
 8006b38:	4603      	mov	r3, r0
 8006b3a:	095b      	lsrs	r3, r3, #5
 8006b3c:	b2db      	uxtb	r3, r3
 8006b3e:	f003 0307 	and.w	r3, r3, #7
 8006b42:	71fb      	strb	r3, [r7, #7]
	ret = data;
 8006b44:	79fb      	ldrb	r3, [r7, #7]
 8006b46:	71bb      	strb	r3, [r7, #6]

	return ret;
 8006b48:	79bb      	ldrb	r3, [r7, #6]
}
 8006b4a:	4618      	mov	r0, r3
 8006b4c:	3708      	adds	r7, #8
 8006b4e:	46bd      	mov	sp, r7
 8006b50:	bd80      	pop	{r7, pc}
	...

08006b54 <mcp2515SetBaud>:

bool mcp2515SetBaud(McpBaud baud)
{
 8006b54:	b580      	push	{r7, lr}
 8006b56:	b084      	sub	sp, #16
 8006b58:	af00      	add	r7, sp, #0
 8006b5a:	4603      	mov	r3, r0
 8006b5c:	71fb      	strb	r3, [r7, #7]
	uint8_t cfg1;
	uint8_t cfg2;
	uint8_t cfg3;
	McpMode mode;

	mode = mcp2515GetMode();
 8006b5e:	f7ff ffe5 	bl	8006b2c <mcp2515GetMode>
 8006b62:	4603      	mov	r3, r0
 8006b64:	733b      	strb	r3, [r7, #12]

	switch(baud)
 8006b66:	79fb      	ldrb	r3, [r7, #7]
 8006b68:	2b03      	cmp	r3, #3
 8006b6a:	d827      	bhi.n	8006bbc <mcp2515SetBaud+0x68>
 8006b6c:	a201      	add	r2, pc, #4	@ (adr r2, 8006b74 <mcp2515SetBaud+0x20>)
 8006b6e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006b72:	bf00      	nop
 8006b74:	08006b85 	.word	0x08006b85
 8006b78:	08006b93 	.word	0x08006b93
 8006b7c:	08006ba1 	.word	0x08006ba1
 8006b80:	08006baf 	.word	0x08006baf
	{
		case MCP_BAUD_125K:
			cfg1 = 0x01;
 8006b84:	2301      	movs	r3, #1
 8006b86:	73fb      	strb	r3, [r7, #15]
			cfg2 = 0xB1;
 8006b88:	23b1      	movs	r3, #177	@ 0xb1
 8006b8a:	73bb      	strb	r3, [r7, #14]
			cfg3 = 0x85;
 8006b8c:	2385      	movs	r3, #133	@ 0x85
 8006b8e:	737b      	strb	r3, [r7, #13]
			break;
 8006b90:	e014      	b.n	8006bbc <mcp2515SetBaud+0x68>

    case MCP_BAUD_250K:
      cfg1 = 0x00;
 8006b92:	2300      	movs	r3, #0
 8006b94:	73fb      	strb	r3, [r7, #15]
      cfg2 = 0xB1;
 8006b96:	23b1      	movs	r3, #177	@ 0xb1
 8006b98:	73bb      	strb	r3, [r7, #14]
      cfg3 = 0x85;
 8006b9a:	2385      	movs	r3, #133	@ 0x85
 8006b9c:	737b      	strb	r3, [r7, #13]
      break;
 8006b9e:	e00d      	b.n	8006bbc <mcp2515SetBaud+0x68>

    case MCP_BAUD_500K:
      cfg1 = 0x00;
 8006ba0:	2300      	movs	r3, #0
 8006ba2:	73fb      	strb	r3, [r7, #15]
      cfg2 = 0x90;
 8006ba4:	2390      	movs	r3, #144	@ 0x90
 8006ba6:	73bb      	strb	r3, [r7, #14]
      cfg3 = 0x82;
 8006ba8:	2382      	movs	r3, #130	@ 0x82
 8006baa:	737b      	strb	r3, [r7, #13]
      break;
 8006bac:	e006      	b.n	8006bbc <mcp2515SetBaud+0x68>

    case MCP_BAUD_1000K:
      cfg1 = 0x00;
 8006bae:	2300      	movs	r3, #0
 8006bb0:	73fb      	strb	r3, [r7, #15]
      cfg2 = 0x80;
 8006bb2:	2380      	movs	r3, #128	@ 0x80
 8006bb4:	73bb      	strb	r3, [r7, #14]
      cfg3 = 0x80;
 8006bb6:	2380      	movs	r3, #128	@ 0x80
 8006bb8:	737b      	strb	r3, [r7, #13]
      break;
 8006bba:	bf00      	nop
	}

	mcp2515SetMode(MCP_MODE_CONFIG);
 8006bbc:	2004      	movs	r0, #4
 8006bbe:	f7ff ff82 	bl	8006ac6 <mcp2515SetMode>

	ret = mcp2515WriteReg(MCP_CNF1, cfg1);
 8006bc2:	7bfb      	ldrb	r3, [r7, #15]
 8006bc4:	4619      	mov	r1, r3
 8006bc6:	202a      	movs	r0, #42	@ 0x2a
 8006bc8:	f000 fab4 	bl	8007134 <mcp2515WriteReg>
 8006bcc:	4603      	mov	r3, r0
 8006bce:	72fb      	strb	r3, [r7, #11]
	ret = mcp2515WriteReg(MCP_CNF2, cfg2);
 8006bd0:	7bbb      	ldrb	r3, [r7, #14]
 8006bd2:	4619      	mov	r1, r3
 8006bd4:	2029      	movs	r0, #41	@ 0x29
 8006bd6:	f000 faad 	bl	8007134 <mcp2515WriteReg>
 8006bda:	4603      	mov	r3, r0
 8006bdc:	72fb      	strb	r3, [r7, #11]
	ret = mcp2515WriteReg(MCP_CNF3, cfg3);
 8006bde:	7b7b      	ldrb	r3, [r7, #13]
 8006be0:	4619      	mov	r1, r3
 8006be2:	2028      	movs	r0, #40	@ 0x28
 8006be4:	f000 faa6 	bl	8007134 <mcp2515WriteReg>
 8006be8:	4603      	mov	r3, r0
 8006bea:	72fb      	strb	r3, [r7, #11]
	is_baud = baud;
 8006bec:	4a05      	ldr	r2, [pc, #20]	@ (8006c04 <mcp2515SetBaud+0xb0>)
 8006bee:	79fb      	ldrb	r3, [r7, #7]
 8006bf0:	7013      	strb	r3, [r2, #0]

	mcp2515SetMode(mode);
 8006bf2:	7b3b      	ldrb	r3, [r7, #12]
 8006bf4:	4618      	mov	r0, r3
 8006bf6:	f7ff ff66 	bl	8006ac6 <mcp2515SetMode>

	return ret;
 8006bfa:	7afb      	ldrb	r3, [r7, #11]
}
 8006bfc:	4618      	mov	r0, r3
 8006bfe:	3710      	adds	r7, #16
 8006c00:	46bd      	mov	sp, r7
 8006c02:	bd80      	pop	{r7, pc}
 8006c04:	2000a4c1 	.word	0x2000a4c1

08006c08 <mcp2515GetBaud>:

McpBaud mcp2515GetBaud(void)
{
 8006c08:	b480      	push	{r7}
 8006c0a:	af00      	add	r7, sp, #0
	return is_baud;
 8006c0c:	4b03      	ldr	r3, [pc, #12]	@ (8006c1c <mcp2515GetBaud+0x14>)
 8006c0e:	781b      	ldrb	r3, [r3, #0]
}
 8006c10:	4618      	mov	r0, r3
 8006c12:	46bd      	mov	sp, r7
 8006c14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c18:	4770      	bx	lr
 8006c1a:	bf00      	nop
 8006c1c:	2000a4c1 	.word	0x2000a4c1

08006c20 <mcp2515ReadStatus>:

uint8_t mcp2515ReadStatus(void)
{
 8006c20:	b580      	push	{r7, lr}
 8006c22:	b084      	sub	sp, #16
 8006c24:	af02      	add	r7, sp, #8
	uint8_t ret = 0;
 8006c26:	2300      	movs	r3, #0
 8006c28:	71fb      	strb	r3, [r7, #7]
	uint8_t buf[2];

	buf[0] = MCP_INST_READ_STATUS;
 8006c2a:	23a0      	movs	r3, #160	@ 0xa0
 8006c2c:	713b      	strb	r3, [r7, #4]
	buf[1] = 0;
 8006c2e:	2300      	movs	r3, #0
 8006c30:	717b      	strb	r3, [r7, #5]

	gpioPinWrite(_PIN_DEF_CS, _DEF_LOW);
 8006c32:	2100      	movs	r1, #0
 8006c34:	2004      	movs	r0, #4
 8006c36:	f7fd f897 	bl	8003d68 <gpioPinWrite>
	if(spiTransfer(spi_ch, buf, buf, 2, 10) == true)
 8006c3a:	2001      	movs	r0, #1
 8006c3c:	1d3a      	adds	r2, r7, #4
 8006c3e:	1d39      	adds	r1, r7, #4
 8006c40:	230a      	movs	r3, #10
 8006c42:	9300      	str	r3, [sp, #0]
 8006c44:	2302      	movs	r3, #2
 8006c46:	f001 fcbf 	bl	80085c8 <spiTransfer>
 8006c4a:	4603      	mov	r3, r0
 8006c4c:	2b00      	cmp	r3, #0
 8006c4e:	d001      	beq.n	8006c54 <mcp2515ReadStatus+0x34>
	{
		ret = buf[1];
 8006c50:	797b      	ldrb	r3, [r7, #5]
 8006c52:	71fb      	strb	r3, [r7, #7]
	}
	gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 8006c54:	2101      	movs	r1, #1
 8006c56:	2004      	movs	r0, #4
 8006c58:	f7fd f886 	bl	8003d68 <gpioPinWrite>

	return ret;
 8006c5c:	79fb      	ldrb	r3, [r7, #7]
}
 8006c5e:	4618      	mov	r0, r3
 8006c60:	3708      	adds	r7, #8
 8006c62:	46bd      	mov	sp, r7
 8006c64:	bd80      	pop	{r7, pc}

08006c66 <mcp2515ReadErrorFlags>:

uint8_t mcp2515ReadErrorFlags(void)
{
 8006c66:	b580      	push	{r7, lr}
 8006c68:	af00      	add	r7, sp, #0
	return mcp2515ReadReg(MCP_EFLG);
 8006c6a:	202d      	movs	r0, #45	@ 0x2d
 8006c6c:	f000 fa0e 	bl	800708c <mcp2515ReadReg>
 8006c70:	4603      	mov	r3, r0
}
 8006c72:	4618      	mov	r0, r3
 8006c74:	bd80      	pop	{r7, pc}

08006c76 <mcp2515PrepareID>:

void mcp2515PrepareID(uint8_t *buffer, const bool ext, const uint32_t id)
{
 8006c76:	b480      	push	{r7}
 8006c78:	b087      	sub	sp, #28
 8006c7a:	af00      	add	r7, sp, #0
 8006c7c:	60f8      	str	r0, [r7, #12]
 8006c7e:	460b      	mov	r3, r1
 8006c80:	607a      	str	r2, [r7, #4]
 8006c82:	72fb      	strb	r3, [r7, #11]
	uint16_t canid = (uint16_t)(id & 0x0FFFF);
 8006c84:	687b      	ldr	r3, [r7, #4]
 8006c86:	82fb      	strh	r3, [r7, #22]

	if(ext)
 8006c88:	7afb      	ldrb	r3, [r7, #11]
 8006c8a:	2b00      	cmp	r3, #0
 8006c8c:	d046      	beq.n	8006d1c <mcp2515PrepareID+0xa6>
	{
		buffer[MCP_EID0] = (uint8_t)(canid & 0xFF);
 8006c8e:	2303      	movs	r3, #3
 8006c90:	461a      	mov	r2, r3
 8006c92:	68fb      	ldr	r3, [r7, #12]
 8006c94:	4413      	add	r3, r2
 8006c96:	8afa      	ldrh	r2, [r7, #22]
 8006c98:	b2d2      	uxtb	r2, r2
 8006c9a:	701a      	strb	r2, [r3, #0]
    buffer[MCP_EID8] = (uint8_t) (canid >> 8);
 8006c9c:	8afb      	ldrh	r3, [r7, #22]
 8006c9e:	0a1b      	lsrs	r3, r3, #8
 8006ca0:	b29a      	uxth	r2, r3
 8006ca2:	2302      	movs	r3, #2
 8006ca4:	4619      	mov	r1, r3
 8006ca6:	68fb      	ldr	r3, [r7, #12]
 8006ca8:	440b      	add	r3, r1
 8006caa:	b2d2      	uxtb	r2, r2
 8006cac:	701a      	strb	r2, [r3, #0]
    canid = (uint16_t)(id >> 16);
 8006cae:	687b      	ldr	r3, [r7, #4]
 8006cb0:	0c1b      	lsrs	r3, r3, #16
 8006cb2:	82fb      	strh	r3, [r7, #22]
    buffer[MCP_SIDL] = (uint8_t) (canid & 0x03);
 8006cb4:	8afb      	ldrh	r3, [r7, #22]
 8006cb6:	b2da      	uxtb	r2, r3
 8006cb8:	2301      	movs	r3, #1
 8006cba:	4619      	mov	r1, r3
 8006cbc:	68fb      	ldr	r3, [r7, #12]
 8006cbe:	440b      	add	r3, r1
 8006cc0:	f002 0203 	and.w	r2, r2, #3
 8006cc4:	b2d2      	uxtb	r2, r2
 8006cc6:	701a      	strb	r2, [r3, #0]
    buffer[MCP_SIDL] += (uint8_t) ((canid & 0x1C) << 3);
 8006cc8:	2301      	movs	r3, #1
 8006cca:	461a      	mov	r2, r3
 8006ccc:	68fb      	ldr	r3, [r7, #12]
 8006cce:	4413      	add	r3, r2
 8006cd0:	7819      	ldrb	r1, [r3, #0]
 8006cd2:	8afb      	ldrh	r3, [r7, #22]
 8006cd4:	b2db      	uxtb	r3, r3
 8006cd6:	00db      	lsls	r3, r3, #3
 8006cd8:	b2db      	uxtb	r3, r3
 8006cda:	f023 031f 	bic.w	r3, r3, #31
 8006cde:	b2da      	uxtb	r2, r3
 8006ce0:	2301      	movs	r3, #1
 8006ce2:	4618      	mov	r0, r3
 8006ce4:	68fb      	ldr	r3, [r7, #12]
 8006ce6:	4403      	add	r3, r0
 8006ce8:	440a      	add	r2, r1
 8006cea:	b2d2      	uxtb	r2, r2
 8006cec:	701a      	strb	r2, [r3, #0]
    buffer[MCP_SIDL] |= 0x08;
 8006cee:	2301      	movs	r3, #1
 8006cf0:	461a      	mov	r2, r3
 8006cf2:	68fb      	ldr	r3, [r7, #12]
 8006cf4:	4413      	add	r3, r2
 8006cf6:	781a      	ldrb	r2, [r3, #0]
 8006cf8:	2301      	movs	r3, #1
 8006cfa:	4619      	mov	r1, r3
 8006cfc:	68fb      	ldr	r3, [r7, #12]
 8006cfe:	440b      	add	r3, r1
 8006d00:	f042 0208 	orr.w	r2, r2, #8
 8006d04:	b2d2      	uxtb	r2, r2
 8006d06:	701a      	strb	r2, [r3, #0]
    buffer[MCP_SIDH] = (uint8_t) (canid >> 5);
 8006d08:	8afb      	ldrh	r3, [r7, #22]
 8006d0a:	095b      	lsrs	r3, r3, #5
 8006d0c:	b29a      	uxth	r2, r3
 8006d0e:	2300      	movs	r3, #0
 8006d10:	4619      	mov	r1, r3
 8006d12:	68fb      	ldr	r3, [r7, #12]
 8006d14:	440b      	add	r3, r1
 8006d16:	b2d2      	uxtb	r2, r2
 8006d18:	701a      	strb	r2, [r3, #0]
    buffer[MCP_SIDH] = (uint8_t) (canid >> 3);
    buffer[MCP_SIDL] = (uint8_t) ((canid & 0x07 ) << 5);
    buffer[MCP_EID0] = 0;
    buffer[MCP_EID8] = 0;
	}
}
 8006d1a:	e01d      	b.n	8006d58 <mcp2515PrepareID+0xe2>
    buffer[MCP_SIDH] = (uint8_t) (canid >> 3);
 8006d1c:	8afb      	ldrh	r3, [r7, #22]
 8006d1e:	08db      	lsrs	r3, r3, #3
 8006d20:	b29a      	uxth	r2, r3
 8006d22:	2300      	movs	r3, #0
 8006d24:	4619      	mov	r1, r3
 8006d26:	68fb      	ldr	r3, [r7, #12]
 8006d28:	440b      	add	r3, r1
 8006d2a:	b2d2      	uxtb	r2, r2
 8006d2c:	701a      	strb	r2, [r3, #0]
    buffer[MCP_SIDL] = (uint8_t) ((canid & 0x07 ) << 5);
 8006d2e:	8afb      	ldrh	r3, [r7, #22]
 8006d30:	b2da      	uxtb	r2, r3
 8006d32:	2301      	movs	r3, #1
 8006d34:	4619      	mov	r1, r3
 8006d36:	68fb      	ldr	r3, [r7, #12]
 8006d38:	440b      	add	r3, r1
 8006d3a:	0152      	lsls	r2, r2, #5
 8006d3c:	b2d2      	uxtb	r2, r2
 8006d3e:	701a      	strb	r2, [r3, #0]
    buffer[MCP_EID0] = 0;
 8006d40:	2303      	movs	r3, #3
 8006d42:	461a      	mov	r2, r3
 8006d44:	68fb      	ldr	r3, [r7, #12]
 8006d46:	4413      	add	r3, r2
 8006d48:	2200      	movs	r2, #0
 8006d4a:	701a      	strb	r2, [r3, #0]
    buffer[MCP_EID8] = 0;
 8006d4c:	2302      	movs	r3, #2
 8006d4e:	461a      	mov	r2, r3
 8006d50:	68fb      	ldr	r3, [r7, #12]
 8006d52:	4413      	add	r3, r2
 8006d54:	2200      	movs	r2, #0
 8006d56:	701a      	strb	r2, [r3, #0]
}
 8006d58:	bf00      	nop
 8006d5a:	371c      	adds	r7, #28
 8006d5c:	46bd      	mov	sp, r7
 8006d5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d62:	4770      	bx	lr

08006d64 <mcp2515SetFilterMask>:

bool mcp2515SetFilterMask(uint8_t index, const bool ext, const uint32_t data)
{
 8006d64:	b580      	push	{r7, lr}
 8006d66:	b084      	sub	sp, #16
 8006d68:	af00      	add	r7, sp, #0
 8006d6a:	4603      	mov	r3, r0
 8006d6c:	603a      	str	r2, [r7, #0]
 8006d6e:	71fb      	strb	r3, [r7, #7]
 8006d70:	460b      	mov	r3, r1
 8006d72:	71bb      	strb	r3, [r7, #6]
	bool ret;
	uint8_t buf[4];
	McpMode mode;

	if(index >= MCP_MASK_MAX) return false;
 8006d74:	79fb      	ldrb	r3, [r7, #7]
 8006d76:	2b01      	cmp	r3, #1
 8006d78:	d901      	bls.n	8006d7e <mcp2515SetFilterMask+0x1a>
 8006d7a:	2300      	movs	r3, #0
 8006d7c:	e01f      	b.n	8006dbe <mcp2515SetFilterMask+0x5a>

	mcp2515PrepareID(buf, ext, data);
 8006d7e:	79b9      	ldrb	r1, [r7, #6]
 8006d80:	f107 0308 	add.w	r3, r7, #8
 8006d84:	683a      	ldr	r2, [r7, #0]
 8006d86:	4618      	mov	r0, r3
 8006d88:	f7ff ff75 	bl	8006c76 <mcp2515PrepareID>

	mode = mcp2515GetMode();
 8006d8c:	f7ff fece 	bl	8006b2c <mcp2515GetMode>
 8006d90:	4603      	mov	r3, r0
 8006d92:	73fb      	strb	r3, [r7, #15]
	mcp2515SetMode(MCP_MODE_CONFIG);
 8006d94:	2004      	movs	r0, #4
 8006d96:	f7ff fe96 	bl	8006ac6 <mcp2515SetMode>

	ret = mcp2515WriteRegs(MCP_RXMSIDH(index), buf, 4);
 8006d9a:	79fb      	ldrb	r3, [r7, #7]
 8006d9c:	3308      	adds	r3, #8
 8006d9e:	b2db      	uxtb	r3, r3
 8006da0:	009b      	lsls	r3, r3, #2
 8006da2:	b2db      	uxtb	r3, r3
 8006da4:	f107 0108 	add.w	r1, r7, #8
 8006da8:	2204      	movs	r2, #4
 8006daa:	4618      	mov	r0, r3
 8006dac:	f000 f9eb 	bl	8007186 <mcp2515WriteRegs>
 8006db0:	4603      	mov	r3, r0
 8006db2:	73bb      	strb	r3, [r7, #14]

	mcp2515SetMode(mode);
 8006db4:	7bfb      	ldrb	r3, [r7, #15]
 8006db6:	4618      	mov	r0, r3
 8006db8:	f7ff fe85 	bl	8006ac6 <mcp2515SetMode>

	return ret;
 8006dbc:	7bbb      	ldrb	r3, [r7, #14]
}
 8006dbe:	4618      	mov	r0, r3
 8006dc0:	3710      	adds	r7, #16
 8006dc2:	46bd      	mov	sp, r7
 8006dc4:	bd80      	pop	{r7, pc}
	...

08006dc8 <mcp2515SetFilter>:

bool mcp2515SetFilter(uint8_t index, const bool ext, const uint32_t data)
{
 8006dc8:	b580      	push	{r7, lr}
 8006dca:	b086      	sub	sp, #24
 8006dcc:	af00      	add	r7, sp, #0
 8006dce:	4603      	mov	r3, r0
 8006dd0:	603a      	str	r2, [r7, #0]
 8006dd2:	71fb      	strb	r3, [r7, #7]
 8006dd4:	460b      	mov	r3, r1
 8006dd6:	71bb      	strb	r3, [r7, #6]
	bool ret;
	uint8_t buf[4];
	McpMode mode;
	const uint8_t rxf_addr[MCP_FILTER_MAX] = {0x00, 0x04, 0x08, 0x10, 0x14, 0x18};
 8006dd8:	4a18      	ldr	r2, [pc, #96]	@ (8006e3c <mcp2515SetFilter+0x74>)
 8006dda:	f107 0308 	add.w	r3, r7, #8
 8006dde:	e892 0003 	ldmia.w	r2, {r0, r1}
 8006de2:	6018      	str	r0, [r3, #0]
 8006de4:	3304      	adds	r3, #4
 8006de6:	8019      	strh	r1, [r3, #0]

	if(index >= MCP_FILTER_MAX) return false;
 8006de8:	79fb      	ldrb	r3, [r7, #7]
 8006dea:	2b05      	cmp	r3, #5
 8006dec:	d901      	bls.n	8006df2 <mcp2515SetFilter+0x2a>
 8006dee:	2300      	movs	r3, #0
 8006df0:	e01f      	b.n	8006e32 <mcp2515SetFilter+0x6a>

	mcp2515PrepareID(buf, ext, data);
 8006df2:	79b9      	ldrb	r1, [r7, #6]
 8006df4:	f107 0310 	add.w	r3, r7, #16
 8006df8:	683a      	ldr	r2, [r7, #0]
 8006dfa:	4618      	mov	r0, r3
 8006dfc:	f7ff ff3b 	bl	8006c76 <mcp2515PrepareID>

	mode = mcp2515GetMode();
 8006e00:	f7ff fe94 	bl	8006b2c <mcp2515GetMode>
 8006e04:	4603      	mov	r3, r0
 8006e06:	75fb      	strb	r3, [r7, #23]
	mcp2515SetMode(MCP_MODE_CONFIG);
 8006e08:	2004      	movs	r0, #4
 8006e0a:	f7ff fe5c 	bl	8006ac6 <mcp2515SetMode>

	ret = mcp2515WriteRegs(rxf_addr[index], buf, 4);
 8006e0e:	79fb      	ldrb	r3, [r7, #7]
 8006e10:	3318      	adds	r3, #24
 8006e12:	443b      	add	r3, r7
 8006e14:	f813 3c10 	ldrb.w	r3, [r3, #-16]
 8006e18:	f107 0110 	add.w	r1, r7, #16
 8006e1c:	2204      	movs	r2, #4
 8006e1e:	4618      	mov	r0, r3
 8006e20:	f000 f9b1 	bl	8007186 <mcp2515WriteRegs>
 8006e24:	4603      	mov	r3, r0
 8006e26:	75bb      	strb	r3, [r7, #22]

	mcp2515SetMode(mode);
 8006e28:	7dfb      	ldrb	r3, [r7, #23]
 8006e2a:	4618      	mov	r0, r3
 8006e2c:	f7ff fe4b 	bl	8006ac6 <mcp2515SetMode>

	return ret;
 8006e30:	7dbb      	ldrb	r3, [r7, #22]
}
 8006e32:	4618      	mov	r0, r3
 8006e34:	3718      	adds	r7, #24
 8006e36:	46bd      	mov	sp, r7
 8006e38:	bd80      	pop	{r7, pc}
 8006e3a:	bf00      	nop
 8006e3c:	080247e8 	.word	0x080247e8

08006e40 <mcp2515SendMsg>:

bool mcp2515SendMsg(mcp_msg_t *p_msg)
{
 8006e40:	b580      	push	{r7, lr}
 8006e42:	b088      	sub	sp, #32
 8006e44:	af00      	add	r7, sp, #0
 8006e46:	6078      	str	r0, [r7, #4]
	bool ret = false;
 8006e48:	2300      	movs	r3, #0
 8006e4a:	77fb      	strb	r3, [r7, #31]
	uint8_t tx_i;
	uint8_t reg;

	for(int i=0; i<3; i++)
 8006e4c:	2300      	movs	r3, #0
 8006e4e:	61bb      	str	r3, [r7, #24]
 8006e50:	e017      	b.n	8006e82 <mcp2515SendMsg+0x42>
	{
		reg = mcp2515ReadReg(MCP_TXBCTRL(i));
 8006e52:	69bb      	ldr	r3, [r7, #24]
 8006e54:	b2db      	uxtb	r3, r3
 8006e56:	011b      	lsls	r3, r3, #4
 8006e58:	b2db      	uxtb	r3, r3
 8006e5a:	3330      	adds	r3, #48	@ 0x30
 8006e5c:	b2db      	uxtb	r3, r3
 8006e5e:	4618      	mov	r0, r3
 8006e60:	f000 f914 	bl	800708c <mcp2515ReadReg>
 8006e64:	4603      	mov	r3, r0
 8006e66:	75fb      	strb	r3, [r7, #23]

		if((ret & (1<<3)) == 0x00)
 8006e68:	7ffb      	ldrb	r3, [r7, #31]
 8006e6a:	f003 0308 	and.w	r3, r3, #8
 8006e6e:	2b00      	cmp	r3, #0
 8006e70:	d104      	bne.n	8006e7c <mcp2515SendMsg+0x3c>
		{
			tx_i = i;
 8006e72:	69bb      	ldr	r3, [r7, #24]
 8006e74:	77bb      	strb	r3, [r7, #30]
			ret = true;
 8006e76:	2301      	movs	r3, #1
 8006e78:	77fb      	strb	r3, [r7, #31]
			break;
 8006e7a:	e005      	b.n	8006e88 <mcp2515SendMsg+0x48>
	for(int i=0; i<3; i++)
 8006e7c:	69bb      	ldr	r3, [r7, #24]
 8006e7e:	3301      	adds	r3, #1
 8006e80:	61bb      	str	r3, [r7, #24]
 8006e82:	69bb      	ldr	r3, [r7, #24]
 8006e84:	2b02      	cmp	r3, #2
 8006e86:	dde4      	ble.n	8006e52 <mcp2515SendMsg+0x12>
		}
	}

	if(ret != true)
 8006e88:	7ffb      	ldrb	r3, [r7, #31]
 8006e8a:	f083 0301 	eor.w	r3, r3, #1
 8006e8e:	b2db      	uxtb	r3, r3
 8006e90:	2b00      	cmp	r3, #0
 8006e92:	d001      	beq.n	8006e98 <mcp2515SendMsg+0x58>
	{
		return false;
 8006e94:	2300      	movs	r3, #0
 8006e96:	e04f      	b.n	8006f38 <mcp2515SendMsg+0xf8>
	}

	uint8_t data[13];

  mcp2515PrepareID(data, p_msg->ext, p_msg->id);
 8006e98:	687b      	ldr	r3, [r7, #4]
 8006e9a:	7899      	ldrb	r1, [r3, #2]
 8006e9c:	687b      	ldr	r3, [r7, #4]
 8006e9e:	881b      	ldrh	r3, [r3, #0]
 8006ea0:	461a      	mov	r2, r3
 8006ea2:	f107 0308 	add.w	r3, r7, #8
 8006ea6:	4618      	mov	r0, r3
 8006ea8:	f7ff fee5 	bl	8006c76 <mcp2515PrepareID>
  data[MCP_DLC] = p_msg->dlc;
 8006eac:	2304      	movs	r3, #4
 8006eae:	4619      	mov	r1, r3
 8006eb0:	687b      	ldr	r3, [r7, #4]
 8006eb2:	78da      	ldrb	r2, [r3, #3]
 8006eb4:	f101 0320 	add.w	r3, r1, #32
 8006eb8:	443b      	add	r3, r7
 8006eba:	f803 2c18 	strb.w	r2, [r3, #-24]

  memcpy(&data[MCP_DATA], p_msg->data, p_msg->dlc);
 8006ebe:	2305      	movs	r3, #5
 8006ec0:	461a      	mov	r2, r3
 8006ec2:	f107 0308 	add.w	r3, r7, #8
 8006ec6:	1898      	adds	r0, r3, r2
 8006ec8:	687b      	ldr	r3, [r7, #4]
 8006eca:	1d19      	adds	r1, r3, #4
 8006ecc:	687b      	ldr	r3, [r7, #4]
 8006ece:	78db      	ldrb	r3, [r3, #3]
 8006ed0:	461a      	mov	r2, r3
 8006ed2:	f01b f9e8 	bl	80222a6 <memcpy>

  ret = mcp2515WriteRegs(MCP_TXBSIDH(tx_i), data, 5 + p_msg->dlc);
 8006ed6:	7fbb      	ldrb	r3, [r7, #30]
 8006ed8:	011b      	lsls	r3, r3, #4
 8006eda:	b2db      	uxtb	r3, r3
 8006edc:	3331      	adds	r3, #49	@ 0x31
 8006ede:	b2d8      	uxtb	r0, r3
 8006ee0:	687b      	ldr	r3, [r7, #4]
 8006ee2:	78db      	ldrb	r3, [r3, #3]
 8006ee4:	3305      	adds	r3, #5
 8006ee6:	b29a      	uxth	r2, r3
 8006ee8:	f107 0308 	add.w	r3, r7, #8
 8006eec:	4619      	mov	r1, r3
 8006eee:	f000 f94a 	bl	8007186 <mcp2515WriteRegs>
 8006ef2:	4603      	mov	r3, r0
 8006ef4:	77fb      	strb	r3, [r7, #31]

  ret = mcp2515ModifyReg(MCP_TXBCTRL(tx_i), (1<<3), (1<<3));
 8006ef6:	7fbb      	ldrb	r3, [r7, #30]
 8006ef8:	011b      	lsls	r3, r3, #4
 8006efa:	b2db      	uxtb	r3, r3
 8006efc:	3330      	adds	r3, #48	@ 0x30
 8006efe:	b2db      	uxtb	r3, r3
 8006f00:	2208      	movs	r2, #8
 8006f02:	2108      	movs	r1, #8
 8006f04:	4618      	mov	r0, r3
 8006f06:	f000 f96b 	bl	80071e0 <mcp2515ModifyReg>
 8006f0a:	4603      	mov	r3, r0
 8006f0c:	77fb      	strb	r3, [r7, #31]
  if (ret == true)
 8006f0e:	7ffb      	ldrb	r3, [r7, #31]
 8006f10:	2b00      	cmp	r3, #0
 8006f12:	d010      	beq.n	8006f36 <mcp2515SendMsg+0xf6>
  {
    reg = mcp2515ReadReg(MCP_TXBCTRL(tx_i));
 8006f14:	7fbb      	ldrb	r3, [r7, #30]
 8006f16:	011b      	lsls	r3, r3, #4
 8006f18:	b2db      	uxtb	r3, r3
 8006f1a:	3330      	adds	r3, #48	@ 0x30
 8006f1c:	b2db      	uxtb	r3, r3
 8006f1e:	4618      	mov	r0, r3
 8006f20:	f000 f8b4 	bl	800708c <mcp2515ReadReg>
 8006f24:	4603      	mov	r3, r0
 8006f26:	75fb      	strb	r3, [r7, #23]

    if (reg & (0x70))
 8006f28:	7dfb      	ldrb	r3, [r7, #23]
 8006f2a:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8006f2e:	2b00      	cmp	r3, #0
 8006f30:	d001      	beq.n	8006f36 <mcp2515SendMsg+0xf6>
    {
      ret = false;
 8006f32:	2300      	movs	r3, #0
 8006f34:	77fb      	strb	r3, [r7, #31]
    }
  }

  return ret;
 8006f36:	7ffb      	ldrb	r3, [r7, #31]
}
 8006f38:	4618      	mov	r0, r3
 8006f3a:	3720      	adds	r7, #32
 8006f3c:	46bd      	mov	sp, r7
 8006f3e:	bd80      	pop	{r7, pc}

08006f40 <mcp2515ReadMsg>:

bool mcp2515ReadMsg(mcp_msg_t *p_msg)
{
 8006f40:	b580      	push	{r7, lr}
 8006f42:	b08a      	sub	sp, #40	@ 0x28
 8006f44:	af00      	add	r7, sp, #0
 8006f46:	6078      	str	r0, [r7, #4]
	bool ret = false;
 8006f48:	2300      	movs	r3, #0
 8006f4a:	76fb      	strb	r3, [r7, #27]
	uint8_t rx_i = 0;
 8006f4c:	2300      	movs	r3, #0
 8006f4e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	uint8_t reg;

	reg = mcp2515ReadStatus();
 8006f52:	f7ff fe65 	bl	8006c20 <mcp2515ReadStatus>
 8006f56:	4603      	mov	r3, r0
 8006f58:	76bb      	strb	r3, [r7, #26]

	if(reg & (1<<0))
 8006f5a:	7ebb      	ldrb	r3, [r7, #26]
 8006f5c:	f003 0301 	and.w	r3, r3, #1
 8006f60:	2b00      	cmp	r3, #0
 8006f62:	d003      	beq.n	8006f6c <mcp2515ReadMsg+0x2c>
	{
		rx_i = 0;
 8006f64:	2300      	movs	r3, #0
 8006f66:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8006f6a:	e00a      	b.n	8006f82 <mcp2515ReadMsg+0x42>
	}
	else if (reg & (1<<1))
 8006f6c:	7ebb      	ldrb	r3, [r7, #26]
 8006f6e:	f003 0302 	and.w	r3, r3, #2
 8006f72:	2b00      	cmp	r3, #0
 8006f74:	d003      	beq.n	8006f7e <mcp2515ReadMsg+0x3e>
	{
		rx_i = 1;
 8006f76:	2301      	movs	r3, #1
 8006f78:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8006f7c:	e001      	b.n	8006f82 <mcp2515ReadMsg+0x42>
	}
	else
	{
		return false;
 8006f7e:	2300      	movs	r3, #0
 8006f80:	e080      	b.n	8007084 <mcp2515ReadMsg+0x144>
	}

	uint8_t tbufdata[13];

	mcp2515ReadRegs(MCP_RXBSIDH(rx_i), tbufdata, 13);
 8006f82:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8006f86:	011b      	lsls	r3, r3, #4
 8006f88:	b2db      	uxtb	r3, r3
 8006f8a:	3361      	adds	r3, #97	@ 0x61
 8006f8c:	b2db      	uxtb	r3, r3
 8006f8e:	f107 010c 	add.w	r1, r7, #12
 8006f92:	220d      	movs	r2, #13
 8006f94:	4618      	mov	r0, r3
 8006f96:	f000 f8a0 	bl	80070da <mcp2515ReadRegs>

	uint32_t id;

	id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
 8006f9a:	2300      	movs	r3, #0
 8006f9c:	3328      	adds	r3, #40	@ 0x28
 8006f9e:	443b      	add	r3, r7
 8006fa0:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
 8006fa4:	00db      	lsls	r3, r3, #3
 8006fa6:	2201      	movs	r2, #1
 8006fa8:	3228      	adds	r2, #40	@ 0x28
 8006faa:	443a      	add	r2, r7
 8006fac:	f812 2c1c 	ldrb.w	r2, [r2, #-28]
 8006fb0:	0952      	lsrs	r2, r2, #5
 8006fb2:	b2d2      	uxtb	r2, r2
 8006fb4:	4413      	add	r3, r2
 8006fb6:	623b      	str	r3, [r7, #32]
	p_msg->ext = false;
 8006fb8:	687b      	ldr	r3, [r7, #4]
 8006fba:	2200      	movs	r2, #0
 8006fbc:	709a      	strb	r2, [r3, #2]

	if((tbufdata[MCP_SIDL] & TXB_EXIDE_MASK) == TXB_EXIDE_MASK)
 8006fbe:	2301      	movs	r3, #1
 8006fc0:	3328      	adds	r3, #40	@ 0x28
 8006fc2:	443b      	add	r3, r7
 8006fc4:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
 8006fc8:	2208      	movs	r2, #8
 8006fca:	4013      	ands	r3, r2
 8006fcc:	b2db      	uxtb	r3, r3
 8006fce:	2208      	movs	r2, #8
 8006fd0:	4293      	cmp	r3, r2
 8006fd2:	d11f      	bne.n	8007014 <mcp2515ReadMsg+0xd4>
	{
		id = (id<<2) + (tbufdata[MCP_SIDL] & 0x03);
 8006fd4:	6a3b      	ldr	r3, [r7, #32]
 8006fd6:	009a      	lsls	r2, r3, #2
 8006fd8:	2301      	movs	r3, #1
 8006fda:	3328      	adds	r3, #40	@ 0x28
 8006fdc:	443b      	add	r3, r7
 8006fde:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
 8006fe2:	f003 0303 	and.w	r3, r3, #3
 8006fe6:	4413      	add	r3, r2
 8006fe8:	623b      	str	r3, [r7, #32]
		id = (id<<8) + tbufdata[MCP_EID8];
 8006fea:	6a3b      	ldr	r3, [r7, #32]
 8006fec:	021b      	lsls	r3, r3, #8
 8006fee:	2202      	movs	r2, #2
 8006ff0:	3228      	adds	r2, #40	@ 0x28
 8006ff2:	443a      	add	r2, r7
 8006ff4:	f812 2c1c 	ldrb.w	r2, [r2, #-28]
 8006ff8:	4413      	add	r3, r2
 8006ffa:	623b      	str	r3, [r7, #32]
		id = (id<<8) + tbufdata[MCP_EID0];
 8006ffc:	6a3b      	ldr	r3, [r7, #32]
 8006ffe:	021b      	lsls	r3, r3, #8
 8007000:	2203      	movs	r2, #3
 8007002:	3228      	adds	r2, #40	@ 0x28
 8007004:	443a      	add	r2, r7
 8007006:	f812 2c1c 	ldrb.w	r2, [r2, #-28]
 800700a:	4413      	add	r3, r2
 800700c:	623b      	str	r3, [r7, #32]
		p_msg->ext = true;
 800700e:	687b      	ldr	r3, [r7, #4]
 8007010:	2201      	movs	r2, #1
 8007012:	709a      	strb	r2, [r3, #2]
	}

	uint8_t dlc = (tbufdata[MCP_DLC] & DLC_MASK);
 8007014:	2304      	movs	r3, #4
 8007016:	3328      	adds	r3, #40	@ 0x28
 8007018:	443b      	add	r3, r7
 800701a:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
 800701e:	220f      	movs	r2, #15
 8007020:	4013      	ands	r3, r2
 8007022:	767b      	strb	r3, [r7, #25]
	if(dlc > 8)
 8007024:	7e7b      	ldrb	r3, [r7, #25]
 8007026:	2b08      	cmp	r3, #8
 8007028:	d901      	bls.n	800702e <mcp2515ReadMsg+0xee>
	{
		return false;
 800702a:	2300      	movs	r3, #0
 800702c:	e02a      	b.n	8007084 <mcp2515ReadMsg+0x144>
	}

	p_msg->id = id;
 800702e:	6a3b      	ldr	r3, [r7, #32]
 8007030:	b29a      	uxth	r2, r3
 8007032:	687b      	ldr	r3, [r7, #4]
 8007034:	801a      	strh	r2, [r3, #0]
	p_msg->dlc = dlc;
 8007036:	687b      	ldr	r3, [r7, #4]
 8007038:	7e7a      	ldrb	r2, [r7, #25]
 800703a:	70da      	strb	r2, [r3, #3]

	for(int i=0; i<dlc; i++)
 800703c:	2300      	movs	r3, #0
 800703e:	61fb      	str	r3, [r7, #28]
 8007040:	e00e      	b.n	8007060 <mcp2515ReadMsg+0x120>
	{
		p_msg->data[i] = tbufdata[5 + i];
 8007042:	69fb      	ldr	r3, [r7, #28]
 8007044:	3305      	adds	r3, #5
 8007046:	3328      	adds	r3, #40	@ 0x28
 8007048:	443b      	add	r3, r7
 800704a:	f813 1c1c 	ldrb.w	r1, [r3, #-28]
 800704e:	687a      	ldr	r2, [r7, #4]
 8007050:	69fb      	ldr	r3, [r7, #28]
 8007052:	4413      	add	r3, r2
 8007054:	3304      	adds	r3, #4
 8007056:	460a      	mov	r2, r1
 8007058:	701a      	strb	r2, [r3, #0]
	for(int i=0; i<dlc; i++)
 800705a:	69fb      	ldr	r3, [r7, #28]
 800705c:	3301      	adds	r3, #1
 800705e:	61fb      	str	r3, [r7, #28]
 8007060:	7e7b      	ldrb	r3, [r7, #25]
 8007062:	69fa      	ldr	r2, [r7, #28]
 8007064:	429a      	cmp	r2, r3
 8007066:	dbec      	blt.n	8007042 <mcp2515ReadMsg+0x102>
	}

	ret = mcp2515ModifyReg(MCP_CANINTF, 1<<rx_i, 0);
 8007068:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800706c:	2201      	movs	r2, #1
 800706e:	fa02 f303 	lsl.w	r3, r2, r3
 8007072:	b2db      	uxtb	r3, r3
 8007074:	2200      	movs	r2, #0
 8007076:	4619      	mov	r1, r3
 8007078:	202c      	movs	r0, #44	@ 0x2c
 800707a:	f000 f8b1 	bl	80071e0 <mcp2515ModifyReg>
 800707e:	4603      	mov	r3, r0
 8007080:	76fb      	strb	r3, [r7, #27]

	return ret;
 8007082:	7efb      	ldrb	r3, [r7, #27]
}
 8007084:	4618      	mov	r0, r3
 8007086:	3728      	adds	r7, #40	@ 0x28
 8007088:	46bd      	mov	sp, r7
 800708a:	bd80      	pop	{r7, pc}

0800708c <mcp2515ReadReg>:

uint8_t mcp2515ReadReg(uint8_t addr)
{
 800708c:	b580      	push	{r7, lr}
 800708e:	b086      	sub	sp, #24
 8007090:	af02      	add	r7, sp, #8
 8007092:	4603      	mov	r3, r0
 8007094:	71fb      	strb	r3, [r7, #7]
	uint8_t ret = 0;
 8007096:	2300      	movs	r3, #0
 8007098:	73fb      	strb	r3, [r7, #15]
	uint8_t buf[3];

	buf[0] = MCP_INST_READ;
 800709a:	2303      	movs	r3, #3
 800709c:	733b      	strb	r3, [r7, #12]
	buf[1] = addr;
 800709e:	79fb      	ldrb	r3, [r7, #7]
 80070a0:	737b      	strb	r3, [r7, #13]

	gpioPinWrite(_PIN_DEF_CS, _DEF_LOW);
 80070a2:	2100      	movs	r1, #0
 80070a4:	2004      	movs	r0, #4
 80070a6:	f7fc fe5f 	bl	8003d68 <gpioPinWrite>
	if(spiTransfer(spi_ch, buf, buf, 3, 10) == true)
 80070aa:	2001      	movs	r0, #1
 80070ac:	f107 020c 	add.w	r2, r7, #12
 80070b0:	f107 010c 	add.w	r1, r7, #12
 80070b4:	230a      	movs	r3, #10
 80070b6:	9300      	str	r3, [sp, #0]
 80070b8:	2303      	movs	r3, #3
 80070ba:	f001 fa85 	bl	80085c8 <spiTransfer>
 80070be:	4603      	mov	r3, r0
 80070c0:	2b00      	cmp	r3, #0
 80070c2:	d001      	beq.n	80070c8 <mcp2515ReadReg+0x3c>
	{
		ret = buf[2];
 80070c4:	7bbb      	ldrb	r3, [r7, #14]
 80070c6:	73fb      	strb	r3, [r7, #15]
	}
	gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 80070c8:	2101      	movs	r1, #1
 80070ca:	2004      	movs	r0, #4
 80070cc:	f7fc fe4c 	bl	8003d68 <gpioPinWrite>

	return ret;
 80070d0:	7bfb      	ldrb	r3, [r7, #15]
}
 80070d2:	4618      	mov	r0, r3
 80070d4:	3710      	adds	r7, #16
 80070d6:	46bd      	mov	sp, r7
 80070d8:	bd80      	pop	{r7, pc}

080070da <mcp2515ReadRegs>:

bool mcp2515ReadRegs(uint8_t addr, uint8_t *p_data, uint16_t length)
{
 80070da:	b580      	push	{r7, lr}
 80070dc:	b086      	sub	sp, #24
 80070de:	af02      	add	r7, sp, #8
 80070e0:	4603      	mov	r3, r0
 80070e2:	6039      	str	r1, [r7, #0]
 80070e4:	71fb      	strb	r3, [r7, #7]
 80070e6:	4613      	mov	r3, r2
 80070e8:	80bb      	strh	r3, [r7, #4]
  bool ret;
  uint8_t buf[2];


  buf[0] = MCP_INST_READ;
 80070ea:	2303      	movs	r3, #3
 80070ec:	733b      	strb	r3, [r7, #12]
  buf[1] = addr;
 80070ee:	79fb      	ldrb	r3, [r7, #7]
 80070f0:	737b      	strb	r3, [r7, #13]

  gpioPinWrite(_PIN_DEF_CS, _DEF_LOW);
 80070f2:	2100      	movs	r1, #0
 80070f4:	2004      	movs	r0, #4
 80070f6:	f7fc fe37 	bl	8003d68 <gpioPinWrite>

  spiTransfer(spi_ch, buf, buf, 2, 10);
 80070fa:	2001      	movs	r0, #1
 80070fc:	f107 020c 	add.w	r2, r7, #12
 8007100:	f107 010c 	add.w	r1, r7, #12
 8007104:	230a      	movs	r3, #10
 8007106:	9300      	str	r3, [sp, #0]
 8007108:	2302      	movs	r3, #2
 800710a:	f001 fa5d 	bl	80085c8 <spiTransfer>

  ret = spiTransfer(spi_ch, p_data, p_data, length, 10);
 800710e:	2001      	movs	r0, #1
 8007110:	88bb      	ldrh	r3, [r7, #4]
 8007112:	220a      	movs	r2, #10
 8007114:	9200      	str	r2, [sp, #0]
 8007116:	683a      	ldr	r2, [r7, #0]
 8007118:	6839      	ldr	r1, [r7, #0]
 800711a:	f001 fa55 	bl	80085c8 <spiTransfer>
 800711e:	4603      	mov	r3, r0
 8007120:	73fb      	strb	r3, [r7, #15]

  gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 8007122:	2101      	movs	r1, #1
 8007124:	2004      	movs	r0, #4
 8007126:	f7fc fe1f 	bl	8003d68 <gpioPinWrite>

  return ret;
 800712a:	7bfb      	ldrb	r3, [r7, #15]
}
 800712c:	4618      	mov	r0, r3
 800712e:	3710      	adds	r7, #16
 8007130:	46bd      	mov	sp, r7
 8007132:	bd80      	pop	{r7, pc}

08007134 <mcp2515WriteReg>:

bool mcp2515WriteReg(uint8_t addr, uint8_t data)
{
 8007134:	b580      	push	{r7, lr}
 8007136:	b086      	sub	sp, #24
 8007138:	af02      	add	r7, sp, #8
 800713a:	4603      	mov	r3, r0
 800713c:	460a      	mov	r2, r1
 800713e:	71fb      	strb	r3, [r7, #7]
 8007140:	4613      	mov	r3, r2
 8007142:	71bb      	strb	r3, [r7, #6]
	bool ret = 0;
 8007144:	2300      	movs	r3, #0
 8007146:	73fb      	strb	r3, [r7, #15]
	uint8_t buf[3];

	buf[0] = MCP_INST_WRITE;
 8007148:	2302      	movs	r3, #2
 800714a:	733b      	strb	r3, [r7, #12]
	buf[1] = addr;
 800714c:	79fb      	ldrb	r3, [r7, #7]
 800714e:	737b      	strb	r3, [r7, #13]
	buf[2] = data;
 8007150:	79bb      	ldrb	r3, [r7, #6]
 8007152:	73bb      	strb	r3, [r7, #14]

	gpioPinWrite(_PIN_DEF_CS, _DEF_LOW);
 8007154:	2100      	movs	r1, #0
 8007156:	2004      	movs	r0, #4
 8007158:	f7fc fe06 	bl	8003d68 <gpioPinWrite>
	ret = spiTransfer(spi_ch, buf, buf, 3, 10);
 800715c:	2001      	movs	r0, #1
 800715e:	f107 020c 	add.w	r2, r7, #12
 8007162:	f107 010c 	add.w	r1, r7, #12
 8007166:	230a      	movs	r3, #10
 8007168:	9300      	str	r3, [sp, #0]
 800716a:	2303      	movs	r3, #3
 800716c:	f001 fa2c 	bl	80085c8 <spiTransfer>
 8007170:	4603      	mov	r3, r0
 8007172:	73fb      	strb	r3, [r7, #15]
	gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 8007174:	2101      	movs	r1, #1
 8007176:	2004      	movs	r0, #4
 8007178:	f7fc fdf6 	bl	8003d68 <gpioPinWrite>

	return ret;
 800717c:	7bfb      	ldrb	r3, [r7, #15]
}
 800717e:	4618      	mov	r0, r3
 8007180:	3710      	adds	r7, #16
 8007182:	46bd      	mov	sp, r7
 8007184:	bd80      	pop	{r7, pc}

08007186 <mcp2515WriteRegs>:

bool mcp2515WriteRegs(uint8_t addr, uint8_t *p_data, uint16_t length)
{
 8007186:	b580      	push	{r7, lr}
 8007188:	b086      	sub	sp, #24
 800718a:	af02      	add	r7, sp, #8
 800718c:	4603      	mov	r3, r0
 800718e:	6039      	str	r1, [r7, #0]
 8007190:	71fb      	strb	r3, [r7, #7]
 8007192:	4613      	mov	r3, r2
 8007194:	80bb      	strh	r3, [r7, #4]
	bool ret;
	uint8_t buf[2];

	buf[0] = MCP_INST_WRITE;
 8007196:	2302      	movs	r3, #2
 8007198:	733b      	strb	r3, [r7, #12]
	buf[1] = addr;
 800719a:	79fb      	ldrb	r3, [r7, #7]
 800719c:	737b      	strb	r3, [r7, #13]

	gpioPinWrite(_PIN_DEF_CS, _DEF_LOW);
 800719e:	2100      	movs	r1, #0
 80071a0:	2004      	movs	r0, #4
 80071a2:	f7fc fde1 	bl	8003d68 <gpioPinWrite>

	spiTransfer(spi_ch, buf, buf, 2, 10);
 80071a6:	2001      	movs	r0, #1
 80071a8:	f107 020c 	add.w	r2, r7, #12
 80071ac:	f107 010c 	add.w	r1, r7, #12
 80071b0:	230a      	movs	r3, #10
 80071b2:	9300      	str	r3, [sp, #0]
 80071b4:	2302      	movs	r3, #2
 80071b6:	f001 fa07 	bl	80085c8 <spiTransfer>

	ret = spiTransfer(spi_ch, p_data, NULL, length, 10);
 80071ba:	2001      	movs	r0, #1
 80071bc:	88bb      	ldrh	r3, [r7, #4]
 80071be:	220a      	movs	r2, #10
 80071c0:	9200      	str	r2, [sp, #0]
 80071c2:	2200      	movs	r2, #0
 80071c4:	6839      	ldr	r1, [r7, #0]
 80071c6:	f001 f9ff 	bl	80085c8 <spiTransfer>
 80071ca:	4603      	mov	r3, r0
 80071cc:	73fb      	strb	r3, [r7, #15]

	gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 80071ce:	2101      	movs	r1, #1
 80071d0:	2004      	movs	r0, #4
 80071d2:	f7fc fdc9 	bl	8003d68 <gpioPinWrite>

	return ret;
 80071d6:	7bfb      	ldrb	r3, [r7, #15]
}
 80071d8:	4618      	mov	r0, r3
 80071da:	3710      	adds	r7, #16
 80071dc:	46bd      	mov	sp, r7
 80071de:	bd80      	pop	{r7, pc}

080071e0 <mcp2515ModifyReg>:

bool mcp2515ModifyReg(uint8_t addr, uint8_t mask, uint8_t data)
{
 80071e0:	b580      	push	{r7, lr}
 80071e2:	b086      	sub	sp, #24
 80071e4:	af02      	add	r7, sp, #8
 80071e6:	4603      	mov	r3, r0
 80071e8:	71fb      	strb	r3, [r7, #7]
 80071ea:	460b      	mov	r3, r1
 80071ec:	71bb      	strb	r3, [r7, #6]
 80071ee:	4613      	mov	r3, r2
 80071f0:	717b      	strb	r3, [r7, #5]
	bool ret = 0;
 80071f2:	2300      	movs	r3, #0
 80071f4:	73fb      	strb	r3, [r7, #15]
	uint8_t buf[4];

	buf[0] = MCP_INST_BIT_MODIFY;
 80071f6:	2305      	movs	r3, #5
 80071f8:	723b      	strb	r3, [r7, #8]
	buf[1] = addr;
 80071fa:	79fb      	ldrb	r3, [r7, #7]
 80071fc:	727b      	strb	r3, [r7, #9]
	buf[2] = mask;
 80071fe:	79bb      	ldrb	r3, [r7, #6]
 8007200:	72bb      	strb	r3, [r7, #10]
	buf[3] = data;
 8007202:	797b      	ldrb	r3, [r7, #5]
 8007204:	72fb      	strb	r3, [r7, #11]

	gpioPinWrite(_PIN_DEF_CS, _DEF_LOW);
 8007206:	2100      	movs	r1, #0
 8007208:	2004      	movs	r0, #4
 800720a:	f7fc fdad 	bl	8003d68 <gpioPinWrite>
	ret = spiTransfer(spi_ch, buf, buf, 4, 10);
 800720e:	2001      	movs	r0, #1
 8007210:	f107 0208 	add.w	r2, r7, #8
 8007214:	f107 0108 	add.w	r1, r7, #8
 8007218:	230a      	movs	r3, #10
 800721a:	9300      	str	r3, [sp, #0]
 800721c:	2304      	movs	r3, #4
 800721e:	f001 f9d3 	bl	80085c8 <spiTransfer>
 8007222:	4603      	mov	r3, r0
 8007224:	73fb      	strb	r3, [r7, #15]
	gpioPinWrite(_PIN_DEF_CS, _DEF_HIGH);
 8007226:	2101      	movs	r1, #1
 8007228:	2004      	movs	r0, #4
 800722a:	f7fc fd9d 	bl	8003d68 <gpioPinWrite>

	return ret;
 800722e:	7bfb      	ldrb	r3, [r7, #15]
}
 8007230:	4618      	mov	r0, r3
 8007232:	3710      	adds	r7, #16
 8007234:	46bd      	mov	sp, r7
 8007236:	bd80      	pop	{r7, pc}

08007238 <mcp2515info>:

#ifdef _USE_HW_CLI

void mcp2515info(void)
{
 8007238:	b580      	push	{r7, lr}
 800723a:	b08c      	sub	sp, #48	@ 0x30
 800723c:	af00      	add	r7, sp, #0
	uint8_t reg;
	uint8_t reg_bits;

	reg = mcp2515ReadReg(0x0E);
 800723e:	200e      	movs	r0, #14
 8007240:	f7ff ff24 	bl	800708c <mcp2515ReadReg>
 8007244:	4603      	mov	r3, r0
 8007246:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
	reg_bits = (reg >> 5) & 0x07;
 800724a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 800724e:	095b      	lsrs	r3, r3, #5
 8007250:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e

	cliPrintf("is_init \t: %d\n", is_init);
 8007254:	4b5d      	ldr	r3, [pc, #372]	@ (80073cc <mcp2515info+0x194>)
 8007256:	781b      	ldrb	r3, [r3, #0]
 8007258:	4619      	mov	r1, r3
 800725a:	485d      	ldr	r0, [pc, #372]	@ (80073d0 <mcp2515info+0x198>)
 800725c:	f7fc f814 	bl	8003288 <cliPrintf>

	cliPrintf("Operation Mode \t: ");
 8007260:	485c      	ldr	r0, [pc, #368]	@ (80073d4 <mcp2515info+0x19c>)
 8007262:	f7fc f811 	bl	8003288 <cliPrintf>
	if(reg_bits == 0x00) cliPrintf("Normal");
 8007266:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 800726a:	2b00      	cmp	r3, #0
 800726c:	d102      	bne.n	8007274 <mcp2515info+0x3c>
 800726e:	485a      	ldr	r0, [pc, #360]	@ (80073d8 <mcp2515info+0x1a0>)
 8007270:	f7fc f80a 	bl	8003288 <cliPrintf>
	if(reg_bits == 0x01) cliPrintf("Sleep");
 8007274:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8007278:	2b01      	cmp	r3, #1
 800727a:	d102      	bne.n	8007282 <mcp2515info+0x4a>
 800727c:	4857      	ldr	r0, [pc, #348]	@ (80073dc <mcp2515info+0x1a4>)
 800727e:	f7fc f803 	bl	8003288 <cliPrintf>
	if(reg_bits == 0x02) cliPrintf("Loopback");
 8007282:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8007286:	2b02      	cmp	r3, #2
 8007288:	d102      	bne.n	8007290 <mcp2515info+0x58>
 800728a:	4855      	ldr	r0, [pc, #340]	@ (80073e0 <mcp2515info+0x1a8>)
 800728c:	f7fb fffc 	bl	8003288 <cliPrintf>
	if(reg_bits == 0x03) cliPrintf("Listen-Only");
 8007290:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8007294:	2b03      	cmp	r3, #3
 8007296:	d102      	bne.n	800729e <mcp2515info+0x66>
 8007298:	4852      	ldr	r0, [pc, #328]	@ (80073e4 <mcp2515info+0x1ac>)
 800729a:	f7fb fff5 	bl	8003288 <cliPrintf>
	if(reg_bits == 0x04) cliPrintf("Configuration");
 800729e:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 80072a2:	2b04      	cmp	r3, #4
 80072a4:	d102      	bne.n	80072ac <mcp2515info+0x74>
 80072a6:	4850      	ldr	r0, [pc, #320]	@ (80073e8 <mcp2515info+0x1b0>)
 80072a8:	f7fb ffee 	bl	8003288 <cliPrintf>
	cliPrintf("\n");
 80072ac:	484f      	ldr	r0, [pc, #316]	@ (80073ec <mcp2515info+0x1b4>)
 80072ae:	f7fb ffeb 	bl	8003288 <cliPrintf>

  uint32_t Fosc;
  uint32_t BRP;
  uint32_t Tq;
  uint32_t SJW;
  uint32_t SyncSeg = 1;
 80072b2:	2301      	movs	r3, #1
 80072b4:	62bb      	str	r3, [r7, #40]	@ 0x28
  uint32_t PhaseSeg1;
  uint32_t PhaseSeg2;
  uint32_t Tbit;
  uint32_t NBR;

  Fosc = 8;
 80072b6:	2308      	movs	r3, #8
 80072b8:	627b      	str	r3, [r7, #36]	@ 0x24
  BRP = ((mcp2515ReadReg(0x2A) >> 0) & 0x3F) + 1;
 80072ba:	202a      	movs	r0, #42	@ 0x2a
 80072bc:	f7ff fee6 	bl	800708c <mcp2515ReadReg>
 80072c0:	4603      	mov	r3, r0
 80072c2:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 80072c6:	3301      	adds	r3, #1
 80072c8:	623b      	str	r3, [r7, #32]
  Tq = 2 * BRP * 1000 / 8;
 80072ca:	6a3b      	ldr	r3, [r7, #32]
 80072cc:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 80072d0:	fb02 f303 	mul.w	r3, r2, r3
 80072d4:	08db      	lsrs	r3, r3, #3
 80072d6:	61fb      	str	r3, [r7, #28]
  SJW = ((mcp2515ReadReg(0x2A) >> 6) & 0x03) + 1;
 80072d8:	202a      	movs	r0, #42	@ 0x2a
 80072da:	f7ff fed7 	bl	800708c <mcp2515ReadReg>
 80072de:	4603      	mov	r3, r0
 80072e0:	099b      	lsrs	r3, r3, #6
 80072e2:	b2db      	uxtb	r3, r3
 80072e4:	f003 0303 	and.w	r3, r3, #3
 80072e8:	3301      	adds	r3, #1
 80072ea:	61bb      	str	r3, [r7, #24]

  cliPrintf("Fosc \t\t: %dMhz\n", Fosc);
 80072ec:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 80072ee:	4840      	ldr	r0, [pc, #256]	@ (80073f0 <mcp2515info+0x1b8>)
 80072f0:	f7fb ffca 	bl	8003288 <cliPrintf>
  cliPrintf("BRP  \t\t: %d\n", BRP);
 80072f4:	6a39      	ldr	r1, [r7, #32]
 80072f6:	483f      	ldr	r0, [pc, #252]	@ (80073f4 <mcp2515info+0x1bc>)
 80072f8:	f7fb ffc6 	bl	8003288 <cliPrintf>
  cliPrintf("Tq   \t\t: %d ns, %d Mhz\n", Tq, 1000/Tq);
 80072fc:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8007300:	69fb      	ldr	r3, [r7, #28]
 8007302:	fbb2 f3f3 	udiv	r3, r2, r3
 8007306:	461a      	mov	r2, r3
 8007308:	69f9      	ldr	r1, [r7, #28]
 800730a:	483b      	ldr	r0, [pc, #236]	@ (80073f8 <mcp2515info+0x1c0>)
 800730c:	f7fb ffbc 	bl	8003288 <cliPrintf>
  cliPrintf("SJW  \t\t: %d Tq\n", SJW);
 8007310:	69b9      	ldr	r1, [r7, #24]
 8007312:	483a      	ldr	r0, [pc, #232]	@ (80073fc <mcp2515info+0x1c4>)
 8007314:	f7fb ffb8 	bl	8003288 <cliPrintf>

  PropSeg = ((mcp2515ReadReg(0x29) >> 0) & 0x07) + 1;
 8007318:	2029      	movs	r0, #41	@ 0x29
 800731a:	f7ff feb7 	bl	800708c <mcp2515ReadReg>
 800731e:	4603      	mov	r3, r0
 8007320:	f003 0307 	and.w	r3, r3, #7
 8007324:	3301      	adds	r3, #1
 8007326:	617b      	str	r3, [r7, #20]
  PhaseSeg1 = ((mcp2515ReadReg(0x29) >> 3) & 0x07) + 1;
 8007328:	2029      	movs	r0, #41	@ 0x29
 800732a:	f7ff feaf 	bl	800708c <mcp2515ReadReg>
 800732e:	4603      	mov	r3, r0
 8007330:	08db      	lsrs	r3, r3, #3
 8007332:	b2db      	uxtb	r3, r3
 8007334:	f003 0307 	and.w	r3, r3, #7
 8007338:	3301      	adds	r3, #1
 800733a:	613b      	str	r3, [r7, #16]
  PhaseSeg2 = ((mcp2515ReadReg(0x28) >> 0) & 0x07) + 1;
 800733c:	2028      	movs	r0, #40	@ 0x28
 800733e:	f7ff fea5 	bl	800708c <mcp2515ReadReg>
 8007342:	4603      	mov	r3, r0
 8007344:	f003 0307 	and.w	r3, r3, #7
 8007348:	3301      	adds	r3, #1
 800734a:	60fb      	str	r3, [r7, #12]
  Tbit = SyncSeg + PropSeg + PhaseSeg1 + PhaseSeg2;
 800734c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800734e:	697b      	ldr	r3, [r7, #20]
 8007350:	441a      	add	r2, r3
 8007352:	693b      	ldr	r3, [r7, #16]
 8007354:	4413      	add	r3, r2
 8007356:	68fa      	ldr	r2, [r7, #12]
 8007358:	4413      	add	r3, r2
 800735a:	60bb      	str	r3, [r7, #8]
  NBR = 1000000 / (Tbit * Tq);
 800735c:	68bb      	ldr	r3, [r7, #8]
 800735e:	69fa      	ldr	r2, [r7, #28]
 8007360:	fb02 f303 	mul.w	r3, r2, r3
 8007364:	4a26      	ldr	r2, [pc, #152]	@ (8007400 <mcp2515info+0x1c8>)
 8007366:	fbb2 f3f3 	udiv	r3, r2, r3
 800736a:	607b      	str	r3, [r7, #4]

  cliPrintf("SyncSeg        \t: %d Tq\n", SyncSeg);
 800736c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800736e:	4825      	ldr	r0, [pc, #148]	@ (8007404 <mcp2515info+0x1cc>)
 8007370:	f7fb ff8a 	bl	8003288 <cliPrintf>
  cliPrintf("PropSeg        \t: %d Tq\n", PropSeg);
 8007374:	6979      	ldr	r1, [r7, #20]
 8007376:	4824      	ldr	r0, [pc, #144]	@ (8007408 <mcp2515info+0x1d0>)
 8007378:	f7fb ff86 	bl	8003288 <cliPrintf>
  cliPrintf("PhaseSeg1(PS1) \t: %d Tq\n", PhaseSeg1);
 800737c:	6939      	ldr	r1, [r7, #16]
 800737e:	4823      	ldr	r0, [pc, #140]	@ (800740c <mcp2515info+0x1d4>)
 8007380:	f7fb ff82 	bl	8003288 <cliPrintf>
  cliPrintf("PhaseSeg2(PS2) \t: %d Tq\n", PhaseSeg2);
 8007384:	68f9      	ldr	r1, [r7, #12]
 8007386:	4822      	ldr	r0, [pc, #136]	@ (8007410 <mcp2515info+0x1d8>)
 8007388:	f7fb ff7e 	bl	8003288 <cliPrintf>
  cliPrintf("Tbit           \t: %d Tq, %d ns\n", Tbit, Tbit * Tq);
 800738c:	68bb      	ldr	r3, [r7, #8]
 800738e:	69fa      	ldr	r2, [r7, #28]
 8007390:	fb02 f303 	mul.w	r3, r2, r3
 8007394:	461a      	mov	r2, r3
 8007396:	68b9      	ldr	r1, [r7, #8]
 8007398:	481e      	ldr	r0, [pc, #120]	@ (8007414 <mcp2515info+0x1dc>)
 800739a:	f7fb ff75 	bl	8003288 <cliPrintf>
  cliPrintf("Sample Point   \t: %d%% \n", (SyncSeg+PropSeg+PhaseSeg1) * 100 / Tbit);
 800739e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80073a0:	697b      	ldr	r3, [r7, #20]
 80073a2:	441a      	add	r2, r3
 80073a4:	693b      	ldr	r3, [r7, #16]
 80073a6:	4413      	add	r3, r2
 80073a8:	2264      	movs	r2, #100	@ 0x64
 80073aa:	fb03 f202 	mul.w	r2, r3, r2
 80073ae:	68bb      	ldr	r3, [r7, #8]
 80073b0:	fbb2 f3f3 	udiv	r3, r2, r3
 80073b4:	4619      	mov	r1, r3
 80073b6:	4818      	ldr	r0, [pc, #96]	@ (8007418 <mcp2515info+0x1e0>)
 80073b8:	f7fb ff66 	bl	8003288 <cliPrintf>
  cliPrintf("NBR            \t: %d Kbps\n", NBR);
 80073bc:	6879      	ldr	r1, [r7, #4]
 80073be:	4817      	ldr	r0, [pc, #92]	@ (800741c <mcp2515info+0x1e4>)
 80073c0:	f7fb ff62 	bl	8003288 <cliPrintf>
}
 80073c4:	bf00      	nop
 80073c6:	3730      	adds	r7, #48	@ 0x30
 80073c8:	46bd      	mov	sp, r7
 80073ca:	bd80      	pop	{r7, pc}
 80073cc:	2000a4c0 	.word	0x2000a4c0
 80073d0:	080247f0 	.word	0x080247f0
 80073d4:	08024800 	.word	0x08024800
 80073d8:	08024814 	.word	0x08024814
 80073dc:	0802481c 	.word	0x0802481c
 80073e0:	08024824 	.word	0x08024824
 80073e4:	08024830 	.word	0x08024830
 80073e8:	0802483c 	.word	0x0802483c
 80073ec:	0802484c 	.word	0x0802484c
 80073f0:	08024850 	.word	0x08024850
 80073f4:	08024860 	.word	0x08024860
 80073f8:	08024870 	.word	0x08024870
 80073fc:	08024888 	.word	0x08024888
 8007400:	000f4240 	.word	0x000f4240
 8007404:	08024898 	.word	0x08024898
 8007408:	080248b4 	.word	0x080248b4
 800740c:	080248d0 	.word	0x080248d0
 8007410:	080248ec 	.word	0x080248ec
 8007414:	08024908 	.word	0x08024908
 8007418:	08024928 	.word	0x08024928
 800741c:	08024944 	.word	0x08024944

08007420 <cliMCP2515>:

void cliMCP2515(cli_args_t *args)
{
 8007420:	b580      	push	{r7, lr}
 8007422:	b094      	sub	sp, #80	@ 0x50
 8007424:	af00      	add	r7, sp, #0
 8007426:	6078      	str	r0, [r7, #4]
	bool ret = false;
 8007428:	2300      	movs	r3, #0
 800742a:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f

	if(args->argc == 1 && args->isStr(0, "info") == true)
 800742e:	687b      	ldr	r3, [r7, #4]
 8007430:	881b      	ldrh	r3, [r3, #0]
 8007432:	2b01      	cmp	r3, #1
 8007434:	d10c      	bne.n	8007450 <cliMCP2515+0x30>
 8007436:	687b      	ldr	r3, [r7, #4]
 8007438:	695b      	ldr	r3, [r3, #20]
 800743a:	49b5      	ldr	r1, [pc, #724]	@ (8007710 <cliMCP2515+0x2f0>)
 800743c:	2000      	movs	r0, #0
 800743e:	4798      	blx	r3
 8007440:	4603      	mov	r3, r0
 8007442:	2b00      	cmp	r3, #0
 8007444:	d004      	beq.n	8007450 <cliMCP2515+0x30>
	{
		mcp2515info();
 8007446:	f7ff fef7 	bl	8007238 <mcp2515info>
		ret = true;
 800744a:	2301      	movs	r3, #1
 800744c:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	}

	if(args->argc == 1 && args->isStr(0, "reg_info") == true)
 8007450:	687b      	ldr	r3, [r7, #4]
 8007452:	881b      	ldrh	r3, [r3, #0]
 8007454:	2b01      	cmp	r3, #1
 8007456:	f040 80be 	bne.w	80075d6 <cliMCP2515+0x1b6>
 800745a:	687b      	ldr	r3, [r7, #4]
 800745c:	695b      	ldr	r3, [r3, #20]
 800745e:	49ad      	ldr	r1, [pc, #692]	@ (8007714 <cliMCP2515+0x2f4>)
 8007460:	2000      	movs	r0, #0
 8007462:	4798      	blx	r3
 8007464:	4603      	mov	r3, r0
 8007466:	2b00      	cmp	r3, #0
 8007468:	f000 80b5 	beq.w	80075d6 <cliMCP2515+0x1b6>
	{
    cliPrintf("BFPCTRL    0x%02X : 0x%02X\n", 0x0C, mcp2515ReadReg(0x0C));
 800746c:	200c      	movs	r0, #12
 800746e:	f7ff fe0d 	bl	800708c <mcp2515ReadReg>
 8007472:	4603      	mov	r3, r0
 8007474:	461a      	mov	r2, r3
 8007476:	210c      	movs	r1, #12
 8007478:	48a7      	ldr	r0, [pc, #668]	@ (8007718 <cliMCP2515+0x2f8>)
 800747a:	f7fb ff05 	bl	8003288 <cliPrintf>
    cliPrintf("TXRTSCTRL  0x%02X : 0x%02X\n", 0x0D, mcp2515ReadReg(0x0D));
 800747e:	200d      	movs	r0, #13
 8007480:	f7ff fe04 	bl	800708c <mcp2515ReadReg>
 8007484:	4603      	mov	r3, r0
 8007486:	461a      	mov	r2, r3
 8007488:	210d      	movs	r1, #13
 800748a:	48a4      	ldr	r0, [pc, #656]	@ (800771c <cliMCP2515+0x2fc>)
 800748c:	f7fb fefc 	bl	8003288 <cliPrintf>
    cliPrintf("CANSTAT    0x%02X : 0x%02X\n", 0x0E, mcp2515ReadReg(0x0E));
 8007490:	200e      	movs	r0, #14
 8007492:	f7ff fdfb 	bl	800708c <mcp2515ReadReg>
 8007496:	4603      	mov	r3, r0
 8007498:	461a      	mov	r2, r3
 800749a:	210e      	movs	r1, #14
 800749c:	48a0      	ldr	r0, [pc, #640]	@ (8007720 <cliMCP2515+0x300>)
 800749e:	f7fb fef3 	bl	8003288 <cliPrintf>
    cliPrintf("CANCTRL    0x%02X : 0x%02X\n", 0x0F, mcp2515ReadReg(0x0F));
 80074a2:	200f      	movs	r0, #15
 80074a4:	f7ff fdf2 	bl	800708c <mcp2515ReadReg>
 80074a8:	4603      	mov	r3, r0
 80074aa:	461a      	mov	r2, r3
 80074ac:	210f      	movs	r1, #15
 80074ae:	489d      	ldr	r0, [pc, #628]	@ (8007724 <cliMCP2515+0x304>)
 80074b0:	f7fb feea 	bl	8003288 <cliPrintf>
    cliPrintf("TEC        0x%02X : 0x%02X\n", 0x1C, mcp2515ReadReg(0x1C));
 80074b4:	201c      	movs	r0, #28
 80074b6:	f7ff fde9 	bl	800708c <mcp2515ReadReg>
 80074ba:	4603      	mov	r3, r0
 80074bc:	461a      	mov	r2, r3
 80074be:	211c      	movs	r1, #28
 80074c0:	4899      	ldr	r0, [pc, #612]	@ (8007728 <cliMCP2515+0x308>)
 80074c2:	f7fb fee1 	bl	8003288 <cliPrintf>
    cliPrintf("REC        0x%02X : 0x%02X\n", 0x1D, mcp2515ReadReg(0x1D));
 80074c6:	201d      	movs	r0, #29
 80074c8:	f7ff fde0 	bl	800708c <mcp2515ReadReg>
 80074cc:	4603      	mov	r3, r0
 80074ce:	461a      	mov	r2, r3
 80074d0:	211d      	movs	r1, #29
 80074d2:	4896      	ldr	r0, [pc, #600]	@ (800772c <cliMCP2515+0x30c>)
 80074d4:	f7fb fed8 	bl	8003288 <cliPrintf>
    cliPrintf("CNF3       0x%02X : 0x%02X\n", 0x28, mcp2515ReadReg(0x28));
 80074d8:	2028      	movs	r0, #40	@ 0x28
 80074da:	f7ff fdd7 	bl	800708c <mcp2515ReadReg>
 80074de:	4603      	mov	r3, r0
 80074e0:	461a      	mov	r2, r3
 80074e2:	2128      	movs	r1, #40	@ 0x28
 80074e4:	4892      	ldr	r0, [pc, #584]	@ (8007730 <cliMCP2515+0x310>)
 80074e6:	f7fb fecf 	bl	8003288 <cliPrintf>
    cliPrintf("CNF2       0x%02X : 0x%02X\n", 0x29, mcp2515ReadReg(0x29));
 80074ea:	2029      	movs	r0, #41	@ 0x29
 80074ec:	f7ff fdce 	bl	800708c <mcp2515ReadReg>
 80074f0:	4603      	mov	r3, r0
 80074f2:	461a      	mov	r2, r3
 80074f4:	2129      	movs	r1, #41	@ 0x29
 80074f6:	488f      	ldr	r0, [pc, #572]	@ (8007734 <cliMCP2515+0x314>)
 80074f8:	f7fb fec6 	bl	8003288 <cliPrintf>
    cliPrintf("CNF1       0x%02X : 0x%02X\n", 0x2A, mcp2515ReadReg(0x2A));
 80074fc:	202a      	movs	r0, #42	@ 0x2a
 80074fe:	f7ff fdc5 	bl	800708c <mcp2515ReadReg>
 8007502:	4603      	mov	r3, r0
 8007504:	461a      	mov	r2, r3
 8007506:	212a      	movs	r1, #42	@ 0x2a
 8007508:	488b      	ldr	r0, [pc, #556]	@ (8007738 <cliMCP2515+0x318>)
 800750a:	f7fb febd 	bl	8003288 <cliPrintf>
    cliPrintf("CANINTE    0x%02X : 0x%02X\n", 0x2B, mcp2515ReadReg(0x2B));
 800750e:	202b      	movs	r0, #43	@ 0x2b
 8007510:	f7ff fdbc 	bl	800708c <mcp2515ReadReg>
 8007514:	4603      	mov	r3, r0
 8007516:	461a      	mov	r2, r3
 8007518:	212b      	movs	r1, #43	@ 0x2b
 800751a:	4888      	ldr	r0, [pc, #544]	@ (800773c <cliMCP2515+0x31c>)
 800751c:	f7fb feb4 	bl	8003288 <cliPrintf>
    cliPrintf("CANINTF    0x%02X : 0x%02X\n", 0x2C, mcp2515ReadReg(0x2C));
 8007520:	202c      	movs	r0, #44	@ 0x2c
 8007522:	f7ff fdb3 	bl	800708c <mcp2515ReadReg>
 8007526:	4603      	mov	r3, r0
 8007528:	461a      	mov	r2, r3
 800752a:	212c      	movs	r1, #44	@ 0x2c
 800752c:	4884      	ldr	r0, [pc, #528]	@ (8007740 <cliMCP2515+0x320>)
 800752e:	f7fb feab 	bl	8003288 <cliPrintf>
    cliPrintf("EFLG       0x%02X : 0x%02X\n", 0x2D, mcp2515ReadReg(0x2D));
 8007532:	202d      	movs	r0, #45	@ 0x2d
 8007534:	f7ff fdaa 	bl	800708c <mcp2515ReadReg>
 8007538:	4603      	mov	r3, r0
 800753a:	461a      	mov	r2, r3
 800753c:	212d      	movs	r1, #45	@ 0x2d
 800753e:	4881      	ldr	r0, [pc, #516]	@ (8007744 <cliMCP2515+0x324>)
 8007540:	f7fb fea2 	bl	8003288 <cliPrintf>
    cliPrintf("TXB0CTRL   0x%02X : 0x%02X\n", 0x30, mcp2515ReadReg(0x30));
 8007544:	2030      	movs	r0, #48	@ 0x30
 8007546:	f7ff fda1 	bl	800708c <mcp2515ReadReg>
 800754a:	4603      	mov	r3, r0
 800754c:	461a      	mov	r2, r3
 800754e:	2130      	movs	r1, #48	@ 0x30
 8007550:	487d      	ldr	r0, [pc, #500]	@ (8007748 <cliMCP2515+0x328>)
 8007552:	f7fb fe99 	bl	8003288 <cliPrintf>
    cliPrintf("TXB1CTRL   0x%02X : 0x%02X\n", 0x40, mcp2515ReadReg(0x40));
 8007556:	2040      	movs	r0, #64	@ 0x40
 8007558:	f7ff fd98 	bl	800708c <mcp2515ReadReg>
 800755c:	4603      	mov	r3, r0
 800755e:	461a      	mov	r2, r3
 8007560:	2140      	movs	r1, #64	@ 0x40
 8007562:	487a      	ldr	r0, [pc, #488]	@ (800774c <cliMCP2515+0x32c>)
 8007564:	f7fb fe90 	bl	8003288 <cliPrintf>
    cliPrintf("TXB2CTRL   0x%02X : 0x%02X\n", 0x50, mcp2515ReadReg(0x50));
 8007568:	2050      	movs	r0, #80	@ 0x50
 800756a:	f7ff fd8f 	bl	800708c <mcp2515ReadReg>
 800756e:	4603      	mov	r3, r0
 8007570:	461a      	mov	r2, r3
 8007572:	2150      	movs	r1, #80	@ 0x50
 8007574:	4876      	ldr	r0, [pc, #472]	@ (8007750 <cliMCP2515+0x330>)
 8007576:	f7fb fe87 	bl	8003288 <cliPrintf>
    cliPrintf("RXB0CTRL   0x%02X : 0x%02X\n", 0x60, mcp2515ReadReg(0x60));
 800757a:	2060      	movs	r0, #96	@ 0x60
 800757c:	f7ff fd86 	bl	800708c <mcp2515ReadReg>
 8007580:	4603      	mov	r3, r0
 8007582:	461a      	mov	r2, r3
 8007584:	2160      	movs	r1, #96	@ 0x60
 8007586:	4873      	ldr	r0, [pc, #460]	@ (8007754 <cliMCP2515+0x334>)
 8007588:	f7fb fe7e 	bl	8003288 <cliPrintf>
    cliPrintf("RXB1CTRL   0x%02X : 0x%02X\n", 0x70, mcp2515ReadReg(0x70));
 800758c:	2070      	movs	r0, #112	@ 0x70
 800758e:	f7ff fd7d 	bl	800708c <mcp2515ReadReg>
 8007592:	4603      	mov	r3, r0
 8007594:	461a      	mov	r2, r3
 8007596:	2170      	movs	r1, #112	@ 0x70
 8007598:	486f      	ldr	r0, [pc, #444]	@ (8007758 <cliMCP2515+0x338>)
 800759a:	f7fb fe75 	bl	8003288 <cliPrintf>

    uint32_t pre_time;

    pre_time = millis();
 800759e:	f7fa fa77 	bl	8001a90 <millis>
 80075a2:	6338      	str	r0, [r7, #48]	@ 0x30
    for(int i=0; i<1000; i++)
 80075a4:	2300      	movs	r3, #0
 80075a6:	64bb      	str	r3, [r7, #72]	@ 0x48
 80075a8:	e005      	b.n	80075b6 <cliMCP2515+0x196>
    {
    	mcp2515ReadReg(0x2A);
 80075aa:	202a      	movs	r0, #42	@ 0x2a
 80075ac:	f7ff fd6e 	bl	800708c <mcp2515ReadReg>
    for(int i=0; i<1000; i++)
 80075b0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80075b2:	3301      	adds	r3, #1
 80075b4:	64bb      	str	r3, [r7, #72]	@ 0x48
 80075b6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80075b8:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80075bc:	dbf5      	blt.n	80075aa <cliMCP2515+0x18a>
    }
    cliPrintf("%d ms\n", millis()-pre_time);
 80075be:	f7fa fa67 	bl	8001a90 <millis>
 80075c2:	4602      	mov	r2, r0
 80075c4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80075c6:	1ad3      	subs	r3, r2, r3
 80075c8:	4619      	mov	r1, r3
 80075ca:	4864      	ldr	r0, [pc, #400]	@ (800775c <cliMCP2515+0x33c>)
 80075cc:	f7fb fe5c 	bl	8003288 <cliPrintf>

    ret = true;
 80075d0:	2301      	movs	r3, #1
 80075d2:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	}

	if(args->argc == 3 && args->isStr(0, "read_reg") == true)
 80075d6:	687b      	ldr	r3, [r7, #4]
 80075d8:	881b      	ldrh	r3, [r3, #0]
 80075da:	2b03      	cmp	r3, #3
 80075dc:	d140      	bne.n	8007660 <cliMCP2515+0x240>
 80075de:	687b      	ldr	r3, [r7, #4]
 80075e0:	695b      	ldr	r3, [r3, #20]
 80075e2:	495f      	ldr	r1, [pc, #380]	@ (8007760 <cliMCP2515+0x340>)
 80075e4:	2000      	movs	r0, #0
 80075e6:	4798      	blx	r3
 80075e8:	4603      	mov	r3, r0
 80075ea:	2b00      	cmp	r3, #0
 80075ec:	d038      	beq.n	8007660 <cliMCP2515+0x240>
	{
		uint8_t addr;
		uint16_t length;
		uint8_t buf[2];

		addr = (uint8_t)args->getData(1);
 80075ee:	687b      	ldr	r3, [r7, #4]
 80075f0:	689b      	ldr	r3, [r3, #8]
 80075f2:	2001      	movs	r0, #1
 80075f4:	4798      	blx	r3
 80075f6:	4603      	mov	r3, r0
 80075f8:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
		length = (uint8_t)args->getData(2);
 80075fc:	687b      	ldr	r3, [r7, #4]
 80075fe:	689b      	ldr	r3, [r3, #8]
 8007600:	2002      	movs	r0, #2
 8007602:	4798      	blx	r3
 8007604:	4603      	mov	r3, r0
 8007606:	b2db      	uxtb	r3, r3
 8007608:	85bb      	strh	r3, [r7, #44]	@ 0x2c

		for(int i=0; i<length; i++)
 800760a:	2300      	movs	r3, #0
 800760c:	647b      	str	r3, [r7, #68]	@ 0x44
 800760e:	e023      	b.n	8007658 <cliMCP2515+0x238>
		{
			if(mcp2515ReadRegs(addr + i, buf, 1) == true)
 8007610:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8007612:	b2da      	uxtb	r2, r3
 8007614:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8007618:	4413      	add	r3, r2
 800761a:	b2db      	uxtb	r3, r3
 800761c:	f107 0120 	add.w	r1, r7, #32
 8007620:	2201      	movs	r2, #1
 8007622:	4618      	mov	r0, r3
 8007624:	f7ff fd59 	bl	80070da <mcp2515ReadRegs>
 8007628:	4603      	mov	r3, r0
 800762a:	2b00      	cmp	r3, #0
 800762c:	d00a      	beq.n	8007644 <cliMCP2515+0x224>
			{
				cliPrintf("0x%02X : 0x%02X\n", addr + i, buf[0]);
 800762e:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8007632:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8007634:	4413      	add	r3, r2
 8007636:	f897 2020 	ldrb.w	r2, [r7, #32]
 800763a:	4619      	mov	r1, r3
 800763c:	4849      	ldr	r0, [pc, #292]	@ (8007764 <cliMCP2515+0x344>)
 800763e:	f7fb fe23 	bl	8003288 <cliPrintf>
 8007642:	e003      	b.n	800764c <cliMCP2515+0x22c>
			}
			else
			{
				cliPrintf("spi fail\n");
 8007644:	4848      	ldr	r0, [pc, #288]	@ (8007768 <cliMCP2515+0x348>)
 8007646:	f7fb fe1f 	bl	8003288 <cliPrintf>
				break;
 800764a:	e009      	b.n	8007660 <cliMCP2515+0x240>
			}

			ret = true;
 800764c:	2301      	movs	r3, #1
 800764e:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
		for(int i=0; i<length; i++)
 8007652:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8007654:	3301      	adds	r3, #1
 8007656:	647b      	str	r3, [r7, #68]	@ 0x44
 8007658:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 800765a:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800765c:	429a      	cmp	r2, r3
 800765e:	dbd7      	blt.n	8007610 <cliMCP2515+0x1f0>
		}
	}

	if(args->argc == 2 && args->isStr(0, "set_baud") == true)
 8007660:	687b      	ldr	r3, [r7, #4]
 8007662:	881b      	ldrh	r3, [r3, #0]
 8007664:	2b02      	cmp	r3, #2
 8007666:	f040 8093 	bne.w	8007790 <cliMCP2515+0x370>
 800766a:	687b      	ldr	r3, [r7, #4]
 800766c:	695b      	ldr	r3, [r3, #20]
 800766e:	493f      	ldr	r1, [pc, #252]	@ (800776c <cliMCP2515+0x34c>)
 8007670:	2000      	movs	r0, #0
 8007672:	4798      	blx	r3
 8007674:	4603      	mov	r3, r0
 8007676:	2b00      	cmp	r3, #0
 8007678:	f000 808a 	beq.w	8007790 <cliMCP2515+0x370>
	{
		bool update = false;
 800767c:	2300      	movs	r3, #0
 800767e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43

		if(args->isStr(1, "125k"))
 8007682:	687b      	ldr	r3, [r7, #4]
 8007684:	695b      	ldr	r3, [r3, #20]
 8007686:	493a      	ldr	r1, [pc, #232]	@ (8007770 <cliMCP2515+0x350>)
 8007688:	2001      	movs	r0, #1
 800768a:	4798      	blx	r3
 800768c:	4603      	mov	r3, r0
 800768e:	2b00      	cmp	r3, #0
 8007690:	d005      	beq.n	800769e <cliMCP2515+0x27e>
		{
			mcp2515SetBaud(MCP_BAUD_125K);
 8007692:	2000      	movs	r0, #0
 8007694:	f7ff fa5e 	bl	8006b54 <mcp2515SetBaud>
			update = true;
 8007698:	2301      	movs	r3, #1
 800769a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
		}
    if (args->isStr(1, "250k"))
 800769e:	687b      	ldr	r3, [r7, #4]
 80076a0:	695b      	ldr	r3, [r3, #20]
 80076a2:	4934      	ldr	r1, [pc, #208]	@ (8007774 <cliMCP2515+0x354>)
 80076a4:	2001      	movs	r0, #1
 80076a6:	4798      	blx	r3
 80076a8:	4603      	mov	r3, r0
 80076aa:	2b00      	cmp	r3, #0
 80076ac:	d005      	beq.n	80076ba <cliMCP2515+0x29a>
    {
      mcp2515SetBaud(MCP_BAUD_250K);
 80076ae:	2001      	movs	r0, #1
 80076b0:	f7ff fa50 	bl	8006b54 <mcp2515SetBaud>
      update = true;
 80076b4:	2301      	movs	r3, #1
 80076b6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
    }
    if (args->isStr(1, "500k"))
 80076ba:	687b      	ldr	r3, [r7, #4]
 80076bc:	695b      	ldr	r3, [r3, #20]
 80076be:	492e      	ldr	r1, [pc, #184]	@ (8007778 <cliMCP2515+0x358>)
 80076c0:	2001      	movs	r0, #1
 80076c2:	4798      	blx	r3
 80076c4:	4603      	mov	r3, r0
 80076c6:	2b00      	cmp	r3, #0
 80076c8:	d005      	beq.n	80076d6 <cliMCP2515+0x2b6>
    {
      mcp2515SetBaud(MCP_BAUD_500K);
 80076ca:	2002      	movs	r0, #2
 80076cc:	f7ff fa42 	bl	8006b54 <mcp2515SetBaud>
      update = true;
 80076d0:	2301      	movs	r3, #1
 80076d2:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
    }
    if (args->isStr(1, "1000k"))
 80076d6:	687b      	ldr	r3, [r7, #4]
 80076d8:	695b      	ldr	r3, [r3, #20]
 80076da:	4928      	ldr	r1, [pc, #160]	@ (800777c <cliMCP2515+0x35c>)
 80076dc:	2001      	movs	r0, #1
 80076de:	4798      	blx	r3
 80076e0:	4603      	mov	r3, r0
 80076e2:	2b00      	cmp	r3, #0
 80076e4:	d005      	beq.n	80076f2 <cliMCP2515+0x2d2>
    {
      mcp2515SetBaud(MCP_BAUD_1000K);
 80076e6:	2003      	movs	r0, #3
 80076e8:	f7ff fa34 	bl	8006b54 <mcp2515SetBaud>
      update = true;
 80076ec:	2301      	movs	r3, #1
 80076ee:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
    }

    if(update == true)
 80076f2:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 80076f6:	2b00      	cmp	r3, #0
 80076f8:	d044      	beq.n	8007784 <cliMCP2515+0x364>
    {
    	cliPrintf("Baud %s OK\n", args->getStr(1));
 80076fa:	687b      	ldr	r3, [r7, #4]
 80076fc:	691b      	ldr	r3, [r3, #16]
 80076fe:	2001      	movs	r0, #1
 8007700:	4798      	blx	r3
 8007702:	4603      	mov	r3, r0
 8007704:	4619      	mov	r1, r3
 8007706:	481e      	ldr	r0, [pc, #120]	@ (8007780 <cliMCP2515+0x360>)
 8007708:	f7fb fdbe 	bl	8003288 <cliPrintf>
 800770c:	e03d      	b.n	800778a <cliMCP2515+0x36a>
 800770e:	bf00      	nop
 8007710:	08024960 	.word	0x08024960
 8007714:	08024968 	.word	0x08024968
 8007718:	08024974 	.word	0x08024974
 800771c:	08024990 	.word	0x08024990
 8007720:	080249ac 	.word	0x080249ac
 8007724:	080249c8 	.word	0x080249c8
 8007728:	080249e4 	.word	0x080249e4
 800772c:	08024a00 	.word	0x08024a00
 8007730:	08024a1c 	.word	0x08024a1c
 8007734:	08024a38 	.word	0x08024a38
 8007738:	08024a54 	.word	0x08024a54
 800773c:	08024a70 	.word	0x08024a70
 8007740:	08024a8c 	.word	0x08024a8c
 8007744:	08024aa8 	.word	0x08024aa8
 8007748:	08024ac4 	.word	0x08024ac4
 800774c:	08024ae0 	.word	0x08024ae0
 8007750:	08024afc 	.word	0x08024afc
 8007754:	08024b18 	.word	0x08024b18
 8007758:	08024b34 	.word	0x08024b34
 800775c:	08024b50 	.word	0x08024b50
 8007760:	08024b58 	.word	0x08024b58
 8007764:	08024b64 	.word	0x08024b64
 8007768:	08024b78 	.word	0x08024b78
 800776c:	08024b84 	.word	0x08024b84
 8007770:	08024b90 	.word	0x08024b90
 8007774:	08024b98 	.word	0x08024b98
 8007778:	08024ba0 	.word	0x08024ba0
 800777c:	08024ba8 	.word	0x08024ba8
 8007780:	08024bb0 	.word	0x08024bb0
    }
    else
    {
    	cliPrintf("Wrong Baud\n");
 8007784:	48bc      	ldr	r0, [pc, #752]	@ (8007a78 <cliMCP2515+0x658>)
 8007786:	f7fb fd7f 	bl	8003288 <cliPrintf>
    }

    ret = true;
 800778a:	2301      	movs	r3, #1
 800778c:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	}

	if(args->argc == 2 && args->isStr(0, "set_mode") == true)
 8007790:	687b      	ldr	r3, [r7, #4]
 8007792:	881b      	ldrh	r3, [r3, #0]
 8007794:	2b02      	cmp	r3, #2
 8007796:	d156      	bne.n	8007846 <cliMCP2515+0x426>
 8007798:	687b      	ldr	r3, [r7, #4]
 800779a:	695b      	ldr	r3, [r3, #20]
 800779c:	49b7      	ldr	r1, [pc, #732]	@ (8007a7c <cliMCP2515+0x65c>)
 800779e:	2000      	movs	r0, #0
 80077a0:	4798      	blx	r3
 80077a2:	4603      	mov	r3, r0
 80077a4:	2b00      	cmp	r3, #0
 80077a6:	d04e      	beq.n	8007846 <cliMCP2515+0x426>
	{
		bool update = false;
 80077a8:	2300      	movs	r3, #0
 80077aa:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42

    if (args->isStr(1, "normal"))
 80077ae:	687b      	ldr	r3, [r7, #4]
 80077b0:	695b      	ldr	r3, [r3, #20]
 80077b2:	49b3      	ldr	r1, [pc, #716]	@ (8007a80 <cliMCP2515+0x660>)
 80077b4:	2001      	movs	r0, #1
 80077b6:	4798      	blx	r3
 80077b8:	4603      	mov	r3, r0
 80077ba:	2b00      	cmp	r3, #0
 80077bc:	d005      	beq.n	80077ca <cliMCP2515+0x3aa>
    {
      mcp2515SetMode(MCP_MODE_NORMAL);
 80077be:	2000      	movs	r0, #0
 80077c0:	f7ff f981 	bl	8006ac6 <mcp2515SetMode>
      update = true;
 80077c4:	2301      	movs	r3, #1
 80077c6:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
    }
    if (args->isStr(1, "loopback"))
 80077ca:	687b      	ldr	r3, [r7, #4]
 80077cc:	695b      	ldr	r3, [r3, #20]
 80077ce:	49ad      	ldr	r1, [pc, #692]	@ (8007a84 <cliMCP2515+0x664>)
 80077d0:	2001      	movs	r0, #1
 80077d2:	4798      	blx	r3
 80077d4:	4603      	mov	r3, r0
 80077d6:	2b00      	cmp	r3, #0
 80077d8:	d005      	beq.n	80077e6 <cliMCP2515+0x3c6>
    {
      mcp2515SetMode(MCP_MODE_LOOPBACK);
 80077da:	2002      	movs	r0, #2
 80077dc:	f7ff f973 	bl	8006ac6 <mcp2515SetMode>
      update = true;
 80077e0:	2301      	movs	r3, #1
 80077e2:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
    }
    if (args->isStr(1, "listen"))
 80077e6:	687b      	ldr	r3, [r7, #4]
 80077e8:	695b      	ldr	r3, [r3, #20]
 80077ea:	49a7      	ldr	r1, [pc, #668]	@ (8007a88 <cliMCP2515+0x668>)
 80077ec:	2001      	movs	r0, #1
 80077ee:	4798      	blx	r3
 80077f0:	4603      	mov	r3, r0
 80077f2:	2b00      	cmp	r3, #0
 80077f4:	d005      	beq.n	8007802 <cliMCP2515+0x3e2>
    {
      mcp2515SetMode(MCP_MODE_LISTEN);
 80077f6:	2003      	movs	r0, #3
 80077f8:	f7ff f965 	bl	8006ac6 <mcp2515SetMode>
      update = true;
 80077fc:	2301      	movs	r3, #1
 80077fe:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
    }
    if (args->isStr(1, "config"))
 8007802:	687b      	ldr	r3, [r7, #4]
 8007804:	695b      	ldr	r3, [r3, #20]
 8007806:	49a1      	ldr	r1, [pc, #644]	@ (8007a8c <cliMCP2515+0x66c>)
 8007808:	2001      	movs	r0, #1
 800780a:	4798      	blx	r3
 800780c:	4603      	mov	r3, r0
 800780e:	2b00      	cmp	r3, #0
 8007810:	d005      	beq.n	800781e <cliMCP2515+0x3fe>
    {
      mcp2515SetMode(MCP_MODE_CONFIG);
 8007812:	2004      	movs	r0, #4
 8007814:	f7ff f957 	bl	8006ac6 <mcp2515SetMode>
      update = true;
 8007818:	2301      	movs	r3, #1
 800781a:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
    }
    if (update == true)
 800781e:	f897 3042 	ldrb.w	r3, [r7, #66]	@ 0x42
 8007822:	2b00      	cmp	r3, #0
 8007824:	d009      	beq.n	800783a <cliMCP2515+0x41a>
    {
      cliPrintf("Mode %s OK\n", args->getStr(1));
 8007826:	687b      	ldr	r3, [r7, #4]
 8007828:	691b      	ldr	r3, [r3, #16]
 800782a:	2001      	movs	r0, #1
 800782c:	4798      	blx	r3
 800782e:	4603      	mov	r3, r0
 8007830:	4619      	mov	r1, r3
 8007832:	4897      	ldr	r0, [pc, #604]	@ (8007a90 <cliMCP2515+0x670>)
 8007834:	f7fb fd28 	bl	8003288 <cliPrintf>
 8007838:	e002      	b.n	8007840 <cliMCP2515+0x420>
    }
    else
    {
      cliPrintf("Wrong Mode\n");
 800783a:	4896      	ldr	r0, [pc, #600]	@ (8007a94 <cliMCP2515+0x674>)
 800783c:	f7fb fd24 	bl	8003288 <cliPrintf>
    }

    ret = true;
 8007840:	2301      	movs	r3, #1
 8007842:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	}

	if(args->argc == 1 && args->isStr(0, "test") == true)
 8007846:	687b      	ldr	r3, [r7, #4]
 8007848:	881b      	ldrh	r3, [r3, #0]
 800784a:	2b01      	cmp	r3, #1
 800784c:	f040 809b 	bne.w	8007986 <cliMCP2515+0x566>
 8007850:	687b      	ldr	r3, [r7, #4]
 8007852:	695b      	ldr	r3, [r3, #20]
 8007854:	4990      	ldr	r1, [pc, #576]	@ (8007a98 <cliMCP2515+0x678>)
 8007856:	2000      	movs	r0, #0
 8007858:	4798      	blx	r3
 800785a:	4603      	mov	r3, r0
 800785c:	2b00      	cmp	r3, #0
 800785e:	f000 8092 	beq.w	8007986 <cliMCP2515+0x566>
	{
		uint8_t rx_data;
		mcp_msg_t rx_msg;
		uint8_t cnt = 0;
 8007862:	2300      	movs	r3, #0
 8007864:	f887 3041 	strb.w	r3, [r7, #65]	@ 0x41

		while(1)
		{
			if(mcp2515ReadMsg(&rx_msg) == true)
 8007868:	f107 0314 	add.w	r3, r7, #20
 800786c:	4618      	mov	r0, r3
 800786e:	f7ff fb67 	bl	8006f40 <mcp2515ReadMsg>
 8007872:	4603      	mov	r3, r0
 8007874:	2b00      	cmp	r3, #0
 8007876:	d01e      	beq.n	80078b6 <cliMCP2515+0x496>
			{
				cliPrintf("id : 0x%X, dlc : %d, ext : %d", rx_msg.id, rx_msg.dlc, rx_msg.ext);
 8007878:	8abb      	ldrh	r3, [r7, #20]
 800787a:	4619      	mov	r1, r3
 800787c:	7dfb      	ldrb	r3, [r7, #23]
 800787e:	461a      	mov	r2, r3
 8007880:	7dbb      	ldrb	r3, [r7, #22]
 8007882:	4886      	ldr	r0, [pc, #536]	@ (8007a9c <cliMCP2515+0x67c>)
 8007884:	f7fb fd00 	bl	8003288 <cliPrintf>

				for(int i=0; i<rx_msg.dlc; i++)
 8007888:	2300      	movs	r3, #0
 800788a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800788c:	e00b      	b.n	80078a6 <cliMCP2515+0x486>
				{
					cliPrintf("0x%02X ", rx_msg.data[i]);
 800788e:	f107 0218 	add.w	r2, r7, #24
 8007892:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8007894:	4413      	add	r3, r2
 8007896:	781b      	ldrb	r3, [r3, #0]
 8007898:	4619      	mov	r1, r3
 800789a:	4881      	ldr	r0, [pc, #516]	@ (8007aa0 <cliMCP2515+0x680>)
 800789c:	f7fb fcf4 	bl	8003288 <cliPrintf>
				for(int i=0; i<rx_msg.dlc; i++)
 80078a0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80078a2:	3301      	adds	r3, #1
 80078a4:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80078a6:	7dfb      	ldrb	r3, [r7, #23]
 80078a8:	461a      	mov	r2, r3
 80078aa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80078ac:	4293      	cmp	r3, r2
 80078ae:	dbee      	blt.n	800788e <cliMCP2515+0x46e>
				}
				cliPrintf("\n");
 80078b0:	487c      	ldr	r0, [pc, #496]	@ (8007aa4 <cliMCP2515+0x684>)
 80078b2:	f7fb fce9 	bl	8003288 <cliPrintf>
			}

			if(cliAvailable() > 0)
 80078b6:	f7fb f8dd 	bl	8002a74 <cliAvailable>
 80078ba:	4603      	mov	r3, r0
 80078bc:	2b00      	cmp	r3, #0
 80078be:	d0d3      	beq.n	8007868 <cliMCP2515+0x448>
			{
				rx_data = cliRead();
 80078c0:	f7fb f8e4 	bl	8002a8c <cliRead>
 80078c4:	4603      	mov	r3, r0
 80078c6:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b

				if(rx_data <= 0x20)
 80078ca:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 80078ce:	2b20      	cmp	r3, #32
 80078d0:	d955      	bls.n	800797e <cliMCP2515+0x55e>
				{
					break;
				}
				if(rx_data == '1')
 80078d2:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 80078d6:	2b31      	cmp	r3, #49	@ 0x31
 80078d8:	d129      	bne.n	800792e <cliMCP2515+0x50e>
				{
          mcp_msg_t msg;
          msg.id  = 0x123;
 80078da:	f240 1323 	movw	r3, #291	@ 0x123
 80078de:	813b      	strh	r3, [r7, #8]
          msg.ext = true;
 80078e0:	2301      	movs	r3, #1
 80078e2:	72bb      	strb	r3, [r7, #10]
          msg.dlc = 8;
 80078e4:	2308      	movs	r3, #8
 80078e6:	72fb      	strb	r3, [r7, #11]
          msg.data[0] = 0;
 80078e8:	2300      	movs	r3, #0
 80078ea:	733b      	strb	r3, [r7, #12]
          msg.data[1] = 1;
 80078ec:	2301      	movs	r3, #1
 80078ee:	737b      	strb	r3, [r7, #13]
          msg.data[2] = 2;
 80078f0:	2302      	movs	r3, #2
 80078f2:	73bb      	strb	r3, [r7, #14]
          msg.data[3] = 3;
 80078f4:	2303      	movs	r3, #3
 80078f6:	73fb      	strb	r3, [r7, #15]
          msg.data[4] = 4;
 80078f8:	2304      	movs	r3, #4
 80078fa:	743b      	strb	r3, [r7, #16]
          msg.data[5] = 5;
 80078fc:	2305      	movs	r3, #5
 80078fe:	747b      	strb	r3, [r7, #17]
          msg.data[6] = 6;
 8007900:	2306      	movs	r3, #6
 8007902:	74bb      	strb	r3, [r7, #18]
          msg.data[7] = cnt++;
 8007904:	f897 3041 	ldrb.w	r3, [r7, #65]	@ 0x41
 8007908:	1c5a      	adds	r2, r3, #1
 800790a:	f887 2041 	strb.w	r2, [r7, #65]	@ 0x41
 800790e:	74fb      	strb	r3, [r7, #19]

          if(mcp2515SendMsg(&msg) == true)
 8007910:	f107 0308 	add.w	r3, r7, #8
 8007914:	4618      	mov	r0, r3
 8007916:	f7ff fa93 	bl	8006e40 <mcp2515SendMsg>
 800791a:	4603      	mov	r3, r0
 800791c:	2b00      	cmp	r3, #0
 800791e:	d003      	beq.n	8007928 <cliMCP2515+0x508>
          {
          	cliPrintf("SendMsg OK\n");
 8007920:	4861      	ldr	r0, [pc, #388]	@ (8007aa8 <cliMCP2515+0x688>)
 8007922:	f7fb fcb1 	bl	8003288 <cliPrintf>
 8007926:	e002      	b.n	800792e <cliMCP2515+0x50e>
          }
          else
          {
          	cliPrintf("SendMsg Fail\n");
 8007928:	4860      	ldr	r0, [pc, #384]	@ (8007aac <cliMCP2515+0x68c>)
 800792a:	f7fb fcad 	bl	8003288 <cliPrintf>
          }
				}
				if(rx_data == 's')
 800792e:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 8007932:	2b73      	cmp	r3, #115	@ 0x73
 8007934:	d198      	bne.n	8007868 <cliMCP2515+0x448>
				{
					uint8_t status;

					cliPrintf("Status : ");
 8007936:	485e      	ldr	r0, [pc, #376]	@ (8007ab0 <cliMCP2515+0x690>)
 8007938:	f7fb fca6 	bl	8003288 <cliPrintf>

					status = mcp2515ReadStatus();
 800793c:	f7ff f970 	bl	8006c20 <mcp2515ReadStatus>
 8007940:	4603      	mov	r3, r0
 8007942:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
					for(int i=0; i<8; i++)
 8007946:	2300      	movs	r3, #0
 8007948:	637b      	str	r3, [r7, #52]	@ 0x34
 800794a:	e00a      	b.n	8007962 <cliMCP2515+0x542>
						{
							cliPrintf("1");
						}
						else
						{
							cliPrintf("0");
 800794c:	4859      	ldr	r0, [pc, #356]	@ (8007ab4 <cliMCP2515+0x694>)
 800794e:	f7fb fc9b 	bl	8003288 <cliPrintf>
						}
						status <<= 1;
 8007952:	f897 303b 	ldrb.w	r3, [r7, #59]	@ 0x3b
 8007956:	005b      	lsls	r3, r3, #1
 8007958:	f887 303b 	strb.w	r3, [r7, #59]	@ 0x3b
					for(int i=0; i<8; i++)
 800795c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800795e:	3301      	adds	r3, #1
 8007960:	637b      	str	r3, [r7, #52]	@ 0x34
 8007962:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8007964:	2b07      	cmp	r3, #7
 8007966:	ddf1      	ble.n	800794c <cliMCP2515+0x52c>
					}
					cliPrintf("  ErrFlag : 0x%X", mcp2515ReadErrorFlags());
 8007968:	f7ff f97d 	bl	8006c66 <mcp2515ReadErrorFlags>
 800796c:	4603      	mov	r3, r0
 800796e:	4619      	mov	r1, r3
 8007970:	4851      	ldr	r0, [pc, #324]	@ (8007ab8 <cliMCP2515+0x698>)
 8007972:	f7fb fc89 	bl	8003288 <cliPrintf>
					cliPrintf("\n");
 8007976:	484b      	ldr	r0, [pc, #300]	@ (8007aa4 <cliMCP2515+0x684>)
 8007978:	f7fb fc86 	bl	8003288 <cliPrintf>
			if(mcp2515ReadMsg(&rx_msg) == true)
 800797c:	e774      	b.n	8007868 <cliMCP2515+0x448>
					break;
 800797e:	bf00      	nop
				}
			}
		}

		ret = true;
 8007980:	2301      	movs	r3, #1
 8007982:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	}

	if(args->argc == 1 && args->isStr(0, "show") == true)
 8007986:	687b      	ldr	r3, [r7, #4]
 8007988:	881b      	ldrh	r3, [r3, #0]
 800798a:	2b01      	cmp	r3, #1
 800798c:	f040 80f7 	bne.w	8007b7e <cliMCP2515+0x75e>
 8007990:	687b      	ldr	r3, [r7, #4]
 8007992:	695b      	ldr	r3, [r3, #20]
 8007994:	4949      	ldr	r1, [pc, #292]	@ (8007abc <cliMCP2515+0x69c>)
 8007996:	2000      	movs	r0, #0
 8007998:	4798      	blx	r3
 800799a:	4603      	mov	r3, r0
 800799c:	2b00      	cmp	r3, #0
 800799e:	f000 80ee 	beq.w	8007b7e <cliMCP2515+0x75e>
	  McpMode mode;
	  McpBaud baud;
	  int16_t x;
	  int16_t y;

	  if (lcdIsInit() != true)
 80079a2:	f7fe fa79 	bl	8005e98 <lcdIsInit>
 80079a6:	4603      	mov	r3, r0
 80079a8:	f083 0301 	eor.w	r3, r3, #1
 80079ac:	b2db      	uxtb	r3, r3
 80079ae:	2b00      	cmp	r3, #0
 80079b0:	f040 8102 	bne.w	8007bb8 <cliMCP2515+0x798>
	  {
	    return;
	  }

	  if (millis()-pre_time >= (1000/30) && lcdDrawAvailable() == true)
 80079b4:	f7fa f86c 	bl	8001a90 <millis>
 80079b8:	4602      	mov	r2, r0
 80079ba:	4b41      	ldr	r3, [pc, #260]	@ (8007ac0 <cliMCP2515+0x6a0>)
 80079bc:	681b      	ldr	r3, [r3, #0]
 80079be:	1ad3      	subs	r3, r2, r3
 80079c0:	2b20      	cmp	r3, #32
 80079c2:	f240 80dc 	bls.w	8007b7e <cliMCP2515+0x75e>
 80079c6:	f7fe fad3 	bl	8005f70 <lcdDrawAvailable>
 80079ca:	4603      	mov	r3, r0
 80079cc:	2b00      	cmp	r3, #0
 80079ce:	f000 80d6 	beq.w	8007b7e <cliMCP2515+0x75e>
	  {
	    pre_time = millis();
 80079d2:	f7fa f85d 	bl	8001a90 <millis>
 80079d6:	4603      	mov	r3, r0
 80079d8:	4a39      	ldr	r2, [pc, #228]	@ (8007ac0 <cliMCP2515+0x6a0>)
 80079da:	6013      	str	r3, [r2, #0]

	    lcdClearBuffer(black);
 80079dc:	2000      	movs	r0, #0
 80079de:	f7fe fa97 	bl	8005f10 <lcdClearBuffer>
	    lcdSetFont(LCD_FONT_HAN);
 80079e2:	2003      	movs	r0, #3
 80079e4:	f7fe fe32 	bl	800664c <lcdSetFont>
	    lcdPrintf(24,16*0, white, " [CAN ]");
 80079e8:	4b36      	ldr	r3, [pc, #216]	@ (8007ac4 <cliMCP2515+0x6a4>)
 80079ea:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80079ee:	2100      	movs	r1, #0
 80079f0:	2018      	movs	r0, #24
 80079f2:	f7fe fc5b 	bl	80062ac <lcdPrintf>
	    lcdSetFont(LCD_FONT_07x10);
 80079f6:	2000      	movs	r0, #0
 80079f8:	f7fe fe28 	bl	800664c <lcdSetFont>

	    mode = mcp2515GetMode();
 80079fc:	f7ff f896 	bl	8006b2c <mcp2515GetMode>
 8007a00:	4603      	mov	r3, r0
 8007a02:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
	    baud = mcp2515GetBaud();
 8007a06:	f7ff f8ff 	bl	8006c08 <mcp2515GetBaud>
 8007a0a:	4603      	mov	r3, r0
 8007a0c:	f887 3029 	strb.w	r3, [r7, #41]	@ 0x29

	    x = 0;
 8007a10:	2300      	movs	r3, #0
 8007a12:	84fb      	strh	r3, [r7, #38]	@ 0x26
	    y = 18 + 12*0;
 8007a14:	2312      	movs	r3, #18
 8007a16:	84bb      	strh	r3, [r7, #36]	@ 0x24
	    switch(mode)
 8007a18:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 8007a1c:	2b04      	cmp	r3, #4
 8007a1e:	d86d      	bhi.n	8007afc <cliMCP2515+0x6dc>
 8007a20:	a201      	add	r2, pc, #4	@ (adr r2, 8007a28 <cliMCP2515+0x608>)
 8007a22:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007a26:	bf00      	nop
 8007a28:	08007a3d 	.word	0x08007a3d
 8007a2c:	08007a51 	.word	0x08007a51
 8007a30:	08007a65 	.word	0x08007a65
 8007a34:	08007ad5 	.word	0x08007ad5
 8007a38:	08007ae9 	.word	0x08007ae9
	    {
	      case MCP_MODE_NORMAL:
	        lcdPrintf(x, y, white, "Mode : Normal");
 8007a3c:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007a40:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007a44:	4b20      	ldr	r3, [pc, #128]	@ (8007ac8 <cliMCP2515+0x6a8>)
 8007a46:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007a4a:	f7fe fc2f 	bl	80062ac <lcdPrintf>
	        break;
 8007a4e:	e055      	b.n	8007afc <cliMCP2515+0x6dc>
	      case MCP_MODE_SLEEP:
	        lcdPrintf(x, y, white, "Mode : Sleep");
 8007a50:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007a54:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007a58:	4b1c      	ldr	r3, [pc, #112]	@ (8007acc <cliMCP2515+0x6ac>)
 8007a5a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007a5e:	f7fe fc25 	bl	80062ac <lcdPrintf>
	        break;
 8007a62:	e04b      	b.n	8007afc <cliMCP2515+0x6dc>
	      case MCP_MODE_LOOPBACK:
	        lcdPrintf(x, y, white, "Mode : Loopback");
 8007a64:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007a68:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007a6c:	4b18      	ldr	r3, [pc, #96]	@ (8007ad0 <cliMCP2515+0x6b0>)
 8007a6e:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007a72:	f7fe fc1b 	bl	80062ac <lcdPrintf>
	        break;
 8007a76:	e041      	b.n	8007afc <cliMCP2515+0x6dc>
 8007a78:	08024bbc 	.word	0x08024bbc
 8007a7c:	08024bc8 	.word	0x08024bc8
 8007a80:	08024bd4 	.word	0x08024bd4
 8007a84:	08024bdc 	.word	0x08024bdc
 8007a88:	08024be8 	.word	0x08024be8
 8007a8c:	08024bf0 	.word	0x08024bf0
 8007a90:	08024bf8 	.word	0x08024bf8
 8007a94:	08024c04 	.word	0x08024c04
 8007a98:	08024c10 	.word	0x08024c10
 8007a9c:	08024c18 	.word	0x08024c18
 8007aa0:	08024c38 	.word	0x08024c38
 8007aa4:	0802484c 	.word	0x0802484c
 8007aa8:	08024c40 	.word	0x08024c40
 8007aac:	08024c4c 	.word	0x08024c4c
 8007ab0:	08024c5c 	.word	0x08024c5c
 8007ab4:	08024c68 	.word	0x08024c68
 8007ab8:	08024c6c 	.word	0x08024c6c
 8007abc:	08024c80 	.word	0x08024c80
 8007ac0:	2000a4c4 	.word	0x2000a4c4
 8007ac4:	08024c88 	.word	0x08024c88
 8007ac8:	08024c98 	.word	0x08024c98
 8007acc:	08024ca8 	.word	0x08024ca8
 8007ad0:	08024cb8 	.word	0x08024cb8
	      case MCP_MODE_LISTEN:
	        lcdPrintf(x, y, white, "Mode : Listen");
 8007ad4:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007ad8:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007adc:	4b38      	ldr	r3, [pc, #224]	@ (8007bc0 <cliMCP2515+0x7a0>)
 8007ade:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007ae2:	f7fe fbe3 	bl	80062ac <lcdPrintf>
	        break;
 8007ae6:	e009      	b.n	8007afc <cliMCP2515+0x6dc>
	      case MCP_MODE_CONFIG:
	        lcdPrintf(x, y, white, "Mode : Config");
 8007ae8:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007aec:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007af0:	4b34      	ldr	r3, [pc, #208]	@ (8007bc4 <cliMCP2515+0x7a4>)
 8007af2:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007af6:	f7fe fbd9 	bl	80062ac <lcdPrintf>
	        break;
 8007afa:	bf00      	nop
	    }

	    x = 0;
 8007afc:	2300      	movs	r3, #0
 8007afe:	84fb      	strh	r3, [r7, #38]	@ 0x26
	    y = 18 + 12*1;
 8007b00:	231e      	movs	r3, #30
 8007b02:	84bb      	strh	r3, [r7, #36]	@ 0x24
	    switch(baud)
 8007b04:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 8007b08:	2b03      	cmp	r3, #3
 8007b0a:	d833      	bhi.n	8007b74 <cliMCP2515+0x754>
 8007b0c:	a201      	add	r2, pc, #4	@ (adr r2, 8007b14 <cliMCP2515+0x6f4>)
 8007b0e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007b12:	bf00      	nop
 8007b14:	08007b25 	.word	0x08007b25
 8007b18:	08007b39 	.word	0x08007b39
 8007b1c:	08007b4d 	.word	0x08007b4d
 8007b20:	08007b61 	.word	0x08007b61
	    {
	      case MCP_BAUD_125K:
	        lcdPrintf(x, y, white, "Baud : 125Kbps");
 8007b24:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007b28:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007b2c:	4b26      	ldr	r3, [pc, #152]	@ (8007bc8 <cliMCP2515+0x7a8>)
 8007b2e:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007b32:	f7fe fbbb 	bl	80062ac <lcdPrintf>
	        break;
 8007b36:	e01d      	b.n	8007b74 <cliMCP2515+0x754>
	      case MCP_BAUD_250K:
	        lcdPrintf(x, y, white, "Baud : 250Kbps");
 8007b38:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007b3c:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007b40:	4b22      	ldr	r3, [pc, #136]	@ (8007bcc <cliMCP2515+0x7ac>)
 8007b42:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007b46:	f7fe fbb1 	bl	80062ac <lcdPrintf>
	        break;
 8007b4a:	e013      	b.n	8007b74 <cliMCP2515+0x754>
	      case MCP_BAUD_500K:
	        lcdPrintf(x, y, white, "Baud : 500Kbps");
 8007b4c:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007b50:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007b54:	4b1e      	ldr	r3, [pc, #120]	@ (8007bd0 <cliMCP2515+0x7b0>)
 8007b56:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007b5a:	f7fe fba7 	bl	80062ac <lcdPrintf>
	        break;
 8007b5e:	e009      	b.n	8007b74 <cliMCP2515+0x754>
	      case MCP_BAUD_1000K:
	        lcdPrintf(x, y, white, "Baud : 1Mbps");
 8007b60:	f9b7 0026 	ldrsh.w	r0, [r7, #38]	@ 0x26
 8007b64:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	@ 0x24
 8007b68:	4b1a      	ldr	r3, [pc, #104]	@ (8007bd4 <cliMCP2515+0x7b4>)
 8007b6a:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8007b6e:	f7fe fb9d 	bl	80062ac <lcdPrintf>
	        break;
 8007b72:	bf00      	nop
	    }

	    lcdRequestDraw();
 8007b74:	f7fe fa12 	bl	8005f9c <lcdRequestDraw>

	    ret = true;
 8007b78:	2301      	movs	r3, #1
 8007b7a:	f887 304f 	strb.w	r3, [r7, #79]	@ 0x4f
	  }
	}

	if(ret != true)
 8007b7e:	f897 304f 	ldrb.w	r3, [r7, #79]	@ 0x4f
 8007b82:	f083 0301 	eor.w	r3, r3, #1
 8007b86:	b2db      	uxtb	r3, r3
 8007b88:	2b00      	cmp	r3, #0
 8007b8a:	d016      	beq.n	8007bba <cliMCP2515+0x79a>
	{
    cliPrintf("mcp2515 info\n");
 8007b8c:	4812      	ldr	r0, [pc, #72]	@ (8007bd8 <cliMCP2515+0x7b8>)
 8007b8e:	f7fb fb7b 	bl	8003288 <cliPrintf>
    cliPrintf("mcp2515 reg_info\n");
 8007b92:	4812      	ldr	r0, [pc, #72]	@ (8007bdc <cliMCP2515+0x7bc>)
 8007b94:	f7fb fb78 	bl	8003288 <cliPrintf>
    cliPrintf("mcp2515 read_reg addr length\n");
 8007b98:	4811      	ldr	r0, [pc, #68]	@ (8007be0 <cliMCP2515+0x7c0>)
 8007b9a:	f7fb fb75 	bl	8003288 <cliPrintf>
    cliPrintf("mcp2515 set_baud 125k:250k:500k:1000k\n");
 8007b9e:	4811      	ldr	r0, [pc, #68]	@ (8007be4 <cliMCP2515+0x7c4>)
 8007ba0:	f7fb fb72 	bl	8003288 <cliPrintf>
    cliPrintf("mcp2515 set_mode normal:loopback:listen:config\n");
 8007ba4:	4810      	ldr	r0, [pc, #64]	@ (8007be8 <cliMCP2515+0x7c8>)
 8007ba6:	f7fb fb6f 	bl	8003288 <cliPrintf>
    cliPrintf("mcp2515 test\n");
 8007baa:	4810      	ldr	r0, [pc, #64]	@ (8007bec <cliMCP2515+0x7cc>)
 8007bac:	f7fb fb6c 	bl	8003288 <cliPrintf>
    cliPrintf("mcp2515 show\n");
 8007bb0:	480f      	ldr	r0, [pc, #60]	@ (8007bf0 <cliMCP2515+0x7d0>)
 8007bb2:	f7fb fb69 	bl	8003288 <cliPrintf>
 8007bb6:	e000      	b.n	8007bba <cliMCP2515+0x79a>
	    return;
 8007bb8:	bf00      	nop
	}
}
 8007bba:	3750      	adds	r7, #80	@ 0x50
 8007bbc:	46bd      	mov	sp, r7
 8007bbe:	bd80      	pop	{r7, pc}
 8007bc0:	08024cc8 	.word	0x08024cc8
 8007bc4:	08024cd8 	.word	0x08024cd8
 8007bc8:	08024ce8 	.word	0x08024ce8
 8007bcc:	08024cf8 	.word	0x08024cf8
 8007bd0:	08024d08 	.word	0x08024d08
 8007bd4:	08024d18 	.word	0x08024d18
 8007bd8:	08024d28 	.word	0x08024d28
 8007bdc:	08024d38 	.word	0x08024d38
 8007be0:	08024d4c 	.word	0x08024d4c
 8007be4:	08024d6c 	.word	0x08024d6c
 8007be8:	08024d94 	.word	0x08024d94
 8007bec:	08024dc4 	.word	0x08024dc4
 8007bf0:	08024dd4 	.word	0x08024dd4

08007bf4 <sdInit>:
static void cliSd(cli_args_t *args);
#endif


bool sdInit(void)
{
 8007bf4:	b580      	push	{r7, lr}
 8007bf6:	b082      	sub	sp, #8
 8007bf8:	af00      	add	r7, sp, #0
	bool ret = false;
 8007bfa:	2300      	movs	r3, #0
 8007bfc:	71fb      	strb	r3, [r7, #7]


	hsd.Instance            = SDIO;
 8007bfe:	4b20      	ldr	r3, [pc, #128]	@ (8007c80 <sdInit+0x8c>)
 8007c00:	4a20      	ldr	r2, [pc, #128]	@ (8007c84 <sdInit+0x90>)
 8007c02:	601a      	str	r2, [r3, #0]
	hsd.Init.ClockEdge      = SDIO_CLOCK_EDGE_RISING;
 8007c04:	4b1e      	ldr	r3, [pc, #120]	@ (8007c80 <sdInit+0x8c>)
 8007c06:	2200      	movs	r2, #0
 8007c08:	605a      	str	r2, [r3, #4]
	hsd.Init.ClockBypass    = SDIO_CLOCK_BYPASS_DISABLE;
 8007c0a:	4b1d      	ldr	r3, [pc, #116]	@ (8007c80 <sdInit+0x8c>)
 8007c0c:	2200      	movs	r2, #0
 8007c0e:	609a      	str	r2, [r3, #8]
	hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
 8007c10:	4b1b      	ldr	r3, [pc, #108]	@ (8007c80 <sdInit+0x8c>)
 8007c12:	2200      	movs	r2, #0
 8007c14:	60da      	str	r2, [r3, #12]
	hsd.Init.BusWide        = SDIO_BUS_WIDE_1B;
 8007c16:	4b1a      	ldr	r3, [pc, #104]	@ (8007c80 <sdInit+0x8c>)
 8007c18:	2200      	movs	r2, #0
 8007c1a:	611a      	str	r2, [r3, #16]
  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 8007c1c:	4b18      	ldr	r3, [pc, #96]	@ (8007c80 <sdInit+0x8c>)
 8007c1e:	2200      	movs	r2, #0
 8007c20:	615a      	str	r2, [r3, #20]
  hsd.Init.ClockDiv       = SDIO_TRANSFER_CLK_DIV;
 8007c22:	4b17      	ldr	r3, [pc, #92]	@ (8007c80 <sdInit+0x8c>)
 8007c24:	2200      	movs	r2, #0
 8007c26:	619a      	str	r2, [r3, #24]

	is_detected = false;
 8007c28:	4b17      	ldr	r3, [pc, #92]	@ (8007c88 <sdInit+0x94>)
 8007c2a:	2200      	movs	r2, #0
 8007c2c:	701a      	strb	r2, [r3, #0]
	if (gpioPinRead(_PIN_GPIO_SDCARD_DETECT) == true)
 8007c2e:	2000      	movs	r0, #0
 8007c30:	f7fc f8ec 	bl	8003e0c <gpioPinRead>
 8007c34:	4603      	mov	r3, r0
 8007c36:	2b00      	cmp	r3, #0
 8007c38:	d002      	beq.n	8007c40 <sdInit+0x4c>
	{
	  is_detected = true;
 8007c3a:	4b13      	ldr	r3, [pc, #76]	@ (8007c88 <sdInit+0x94>)
 8007c3c:	2201      	movs	r2, #1
 8007c3e:	701a      	strb	r2, [r3, #0]
	}

	if (is_detected == true)
 8007c40:	4b11      	ldr	r3, [pc, #68]	@ (8007c88 <sdInit+0x94>)
 8007c42:	781b      	ldrb	r3, [r3, #0]
 8007c44:	2b00      	cmp	r3, #0
 8007c46:	d00f      	beq.n	8007c68 <sdInit+0x74>
	{
	  if (HAL_SD_Init(&hsd) == HAL_OK)
 8007c48:	480d      	ldr	r0, [pc, #52]	@ (8007c80 <sdInit+0x8c>)
 8007c4a:	f008 f803 	bl	800fc54 <HAL_SD_Init>
 8007c4e:	4603      	mov	r3, r0
 8007c50:	2b00      	cmp	r3, #0
 8007c52:	d109      	bne.n	8007c68 <sdInit+0x74>
	  {
	    if (HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B) == HAL_OK)
 8007c54:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8007c58:	4809      	ldr	r0, [pc, #36]	@ (8007c80 <sdInit+0x8c>)
 8007c5a:	f008 fddd 	bl	8010818 <HAL_SD_ConfigWideBusOperation>
 8007c5e:	4603      	mov	r3, r0
 8007c60:	2b00      	cmp	r3, #0
 8007c62:	d101      	bne.n	8007c68 <sdInit+0x74>
	    {
	      ret = true;
 8007c64:	2301      	movs	r3, #1
 8007c66:	71fb      	strb	r3, [r7, #7]
	    }
	  }
	}

	is_init = ret;
 8007c68:	4a08      	ldr	r2, [pc, #32]	@ (8007c8c <sdInit+0x98>)
 8007c6a:	79fb      	ldrb	r3, [r7, #7]
 8007c6c:	7013      	strb	r3, [r2, #0]

#ifdef _USE_HW_CLI
  cliAdd("sd", cliSd);
 8007c6e:	4908      	ldr	r1, [pc, #32]	@ (8007c90 <sdInit+0x9c>)
 8007c70:	4808      	ldr	r0, [pc, #32]	@ (8007c94 <sdInit+0xa0>)
 8007c72:	f7fb fc19 	bl	80034a8 <cliAdd>
#endif

  return ret;
 8007c76:	79fb      	ldrb	r3, [r7, #7]
}
 8007c78:	4618      	mov	r0, r3
 8007c7a:	3708      	adds	r7, #8
 8007c7c:	46bd      	mov	sp, r7
 8007c7e:	bd80      	pop	{r7, pc}
 8007c80:	2000039c 	.word	0x2000039c
 8007c84:	40012c00 	.word	0x40012c00
 8007c88:	2000a4c9 	.word	0x2000a4c9
 8007c8c:	2000a4c8 	.word	0x2000a4c8
 8007c90:	08008181 	.word	0x08008181
 8007c94:	08024de4 	.word	0x08024de4

08007c98 <sdIsInit>:

  return ret;
}

bool sdIsInit(void)
{
 8007c98:	b480      	push	{r7}
 8007c9a:	af00      	add	r7, sp, #0
  return is_init;
 8007c9c:	4b03      	ldr	r3, [pc, #12]	@ (8007cac <sdIsInit+0x14>)
 8007c9e:	781b      	ldrb	r3, [r3, #0]
}
 8007ca0:	4618      	mov	r0, r3
 8007ca2:	46bd      	mov	sp, r7
 8007ca4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ca8:	4770      	bx	lr
 8007caa:	bf00      	nop
 8007cac:	2000a4c8 	.word	0x2000a4c8

08007cb0 <sdIsDetected>:

bool sdIsDetected(void)
{
 8007cb0:	b580      	push	{r7, lr}
 8007cb2:	af00      	add	r7, sp, #0
  if (gpioPinRead(_PIN_GPIO_SDCARD_DETECT) == true)
 8007cb4:	2000      	movs	r0, #0
 8007cb6:	f7fc f8a9 	bl	8003e0c <gpioPinRead>
 8007cba:	4603      	mov	r3, r0
 8007cbc:	2b00      	cmp	r3, #0
 8007cbe:	d003      	beq.n	8007cc8 <sdIsDetected+0x18>
  {
    is_detected = true;
 8007cc0:	4b05      	ldr	r3, [pc, #20]	@ (8007cd8 <sdIsDetected+0x28>)
 8007cc2:	2201      	movs	r2, #1
 8007cc4:	701a      	strb	r2, [r3, #0]
 8007cc6:	e002      	b.n	8007cce <sdIsDetected+0x1e>
  }
  else
  {
    is_detected = false;
 8007cc8:	4b03      	ldr	r3, [pc, #12]	@ (8007cd8 <sdIsDetected+0x28>)
 8007cca:	2200      	movs	r2, #0
 8007ccc:	701a      	strb	r2, [r3, #0]
  }

  return is_detected;
 8007cce:	4b02      	ldr	r3, [pc, #8]	@ (8007cd8 <sdIsDetected+0x28>)
 8007cd0:	781b      	ldrb	r3, [r3, #0]
}
 8007cd2:	4618      	mov	r0, r3
 8007cd4:	bd80      	pop	{r7, pc}
 8007cd6:	bf00      	nop
 8007cd8:	2000a4c9 	.word	0x2000a4c9

08007cdc <sdGetInfo>:

bool sdGetInfo(sd_info_t *p_info)
{
 8007cdc:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8007ce0:	b08c      	sub	sp, #48	@ 0x30
 8007ce2:	af00      	add	r7, sp, #0
 8007ce4:	6078      	str	r0, [r7, #4]
  bool ret = false;
 8007ce6:	2300      	movs	r3, #0
 8007ce8:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  sd_info_t *p_sd_info = (sd_info_t *)p_info;
 8007cec:	687b      	ldr	r3, [r7, #4]
 8007cee:	62bb      	str	r3, [r7, #40]	@ 0x28

  HAL_SD_CardInfoTypeDef card_info;


  if (is_init == true)
 8007cf0:	4b24      	ldr	r3, [pc, #144]	@ (8007d84 <sdGetInfo+0xa8>)
 8007cf2:	781b      	ldrb	r3, [r3, #0]
 8007cf4:	2b00      	cmp	r3, #0
 8007cf6:	d03d      	beq.n	8007d74 <sdGetInfo+0x98>
  {
    HAL_SD_GetCardInfo(&hsd, &card_info);
 8007cf8:	f107 0308 	add.w	r3, r7, #8
 8007cfc:	4619      	mov	r1, r3
 8007cfe:	4822      	ldr	r0, [pc, #136]	@ (8007d88 <sdGetInfo+0xac>)
 8007d00:	f008 fd5e 	bl	80107c0 <HAL_SD_GetCardInfo>

    p_sd_info->card_type          = card_info.CardType;
 8007d04:	68ba      	ldr	r2, [r7, #8]
 8007d06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d08:	601a      	str	r2, [r3, #0]
    p_sd_info->card_version       = card_info.CardVersion;
 8007d0a:	68fa      	ldr	r2, [r7, #12]
 8007d0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d0e:	605a      	str	r2, [r3, #4]
    p_sd_info->card_class         = card_info.Class;
 8007d10:	693a      	ldr	r2, [r7, #16]
 8007d12:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d14:	609a      	str	r2, [r3, #8]
    p_sd_info->rel_card_Add       = card_info.RelCardAdd;
 8007d16:	697a      	ldr	r2, [r7, #20]
 8007d18:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d1a:	60da      	str	r2, [r3, #12]
    p_sd_info->block_numbers      = card_info.BlockNbr;
 8007d1c:	69ba      	ldr	r2, [r7, #24]
 8007d1e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d20:	611a      	str	r2, [r3, #16]
    p_sd_info->block_size         = card_info.BlockSize;
 8007d22:	69fa      	ldr	r2, [r7, #28]
 8007d24:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d26:	615a      	str	r2, [r3, #20]
    p_sd_info->log_block_numbers  = card_info.LogBlockNbr;
 8007d28:	6a3a      	ldr	r2, [r7, #32]
 8007d2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d2c:	619a      	str	r2, [r3, #24]
    p_sd_info->log_block_size     = card_info.LogBlockSize;
 8007d2e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8007d30:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d32:	61da      	str	r2, [r3, #28]
    p_sd_info->card_size          =  (uint32_t)((uint64_t)p_sd_info->block_numbers * (uint64_t) p_sd_info->block_size / (uint64_t)1024 / (uint64_t)1024);
 8007d34:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d36:	691b      	ldr	r3, [r3, #16]
 8007d38:	2200      	movs	r2, #0
 8007d3a:	469a      	mov	sl, r3
 8007d3c:	4693      	mov	fp, r2
 8007d3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d40:	695b      	ldr	r3, [r3, #20]
 8007d42:	2200      	movs	r2, #0
 8007d44:	4698      	mov	r8, r3
 8007d46:	4691      	mov	r9, r2
 8007d48:	fb08 f20b 	mul.w	r2, r8, fp
 8007d4c:	fb0a f309 	mul.w	r3, sl, r9
 8007d50:	4413      	add	r3, r2
 8007d52:	fbaa 4508 	umull	r4, r5, sl, r8
 8007d56:	442b      	add	r3, r5
 8007d58:	461d      	mov	r5, r3
 8007d5a:	f04f 0200 	mov.w	r2, #0
 8007d5e:	f04f 0300 	mov.w	r3, #0
 8007d62:	0d22      	lsrs	r2, r4, #20
 8007d64:	ea42 3205 	orr.w	r2, r2, r5, lsl #12
 8007d68:	0d2b      	lsrs	r3, r5, #20
 8007d6a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8007d6c:	621a      	str	r2, [r3, #32]
    ret = true;
 8007d6e:	2301      	movs	r3, #1
 8007d70:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  }

  return ret;
 8007d74:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 8007d78:	4618      	mov	r0, r3
 8007d7a:	3730      	adds	r7, #48	@ 0x30
 8007d7c:	46bd      	mov	sp, r7
 8007d7e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8007d82:	bf00      	nop
 8007d84:	2000a4c8 	.word	0x2000a4c8
 8007d88:	2000039c 	.word	0x2000039c

08007d8c <sdIsBusy>:

bool sdIsBusy(void)
{
 8007d8c:	b580      	push	{r7, lr}
 8007d8e:	b082      	sub	sp, #8
 8007d90:	af00      	add	r7, sp, #0
  bool is_busy;


  if (HAL_SD_GetCardState(&hsd) == HAL_SD_CARD_TRANSFER )
 8007d92:	4808      	ldr	r0, [pc, #32]	@ (8007db4 <sdIsBusy+0x28>)
 8007d94:	f008 fdda 	bl	801094c <HAL_SD_GetCardState>
 8007d98:	4603      	mov	r3, r0
 8007d9a:	2b04      	cmp	r3, #4
 8007d9c:	d102      	bne.n	8007da4 <sdIsBusy+0x18>
  {
    is_busy = false;
 8007d9e:	2300      	movs	r3, #0
 8007da0:	71fb      	strb	r3, [r7, #7]
 8007da2:	e001      	b.n	8007da8 <sdIsBusy+0x1c>
  }
  else
  {
    is_busy = true;
 8007da4:	2301      	movs	r3, #1
 8007da6:	71fb      	strb	r3, [r7, #7]
  }

  return is_busy;
 8007da8:	79fb      	ldrb	r3, [r7, #7]
}
 8007daa:	4618      	mov	r0, r3
 8007dac:	3708      	adds	r7, #8
 8007dae:	46bd      	mov	sp, r7
 8007db0:	bd80      	pop	{r7, pc}
 8007db2:	bf00      	nop
 8007db4:	2000039c 	.word	0x2000039c

08007db8 <sdIsReady>:

bool sdIsReady(uint32_t timeout)
{
 8007db8:	b580      	push	{r7, lr}
 8007dba:	b084      	sub	sp, #16
 8007dbc:	af00      	add	r7, sp, #0
 8007dbe:	6078      	str	r0, [r7, #4]
  uint32_t pre_time;

  pre_time = millis();
 8007dc0:	f7f9 fe66 	bl	8001a90 <millis>
 8007dc4:	60f8      	str	r0, [r7, #12]

  while(millis() - pre_time < timeout)
 8007dc6:	e009      	b.n	8007ddc <sdIsReady+0x24>
  {
    if (sdIsBusy() == false)
 8007dc8:	f7ff ffe0 	bl	8007d8c <sdIsBusy>
 8007dcc:	4603      	mov	r3, r0
 8007dce:	f083 0301 	eor.w	r3, r3, #1
 8007dd2:	b2db      	uxtb	r3, r3
 8007dd4:	2b00      	cmp	r3, #0
 8007dd6:	d001      	beq.n	8007ddc <sdIsReady+0x24>
    {
      return true;
 8007dd8:	2301      	movs	r3, #1
 8007dda:	e008      	b.n	8007dee <sdIsReady+0x36>
  while(millis() - pre_time < timeout)
 8007ddc:	f7f9 fe58 	bl	8001a90 <millis>
 8007de0:	4602      	mov	r2, r0
 8007de2:	68fb      	ldr	r3, [r7, #12]
 8007de4:	1ad3      	subs	r3, r2, r3
 8007de6:	687a      	ldr	r2, [r7, #4]
 8007de8:	429a      	cmp	r2, r3
 8007dea:	d8ed      	bhi.n	8007dc8 <sdIsReady+0x10>
    }
  }

  return false;
 8007dec:	2300      	movs	r3, #0
}
 8007dee:	4618      	mov	r0, r3
 8007df0:	3710      	adds	r7, #16
 8007df2:	46bd      	mov	sp, r7
 8007df4:	bd80      	pop	{r7, pc}
	...

08007df8 <sdReadBlocks>:

bool sdReadBlocks(uint32_t block_addr, uint8_t *p_data, uint32_t num_of_blocks, uint32_t timeout_ms)
{
 8007df8:	b580      	push	{r7, lr}
 8007dfa:	b086      	sub	sp, #24
 8007dfc:	af00      	add	r7, sp, #0
 8007dfe:	60f8      	str	r0, [r7, #12]
 8007e00:	60b9      	str	r1, [r7, #8]
 8007e02:	607a      	str	r2, [r7, #4]
 8007e04:	603b      	str	r3, [r7, #0]
  bool ret = false;
 8007e06:	2300      	movs	r3, #0
 8007e08:	75fb      	strb	r3, [r7, #23]
  uint32_t pre_time;


  is_rx_done = false;
 8007e0a:	4b1e      	ldr	r3, [pc, #120]	@ (8007e84 <sdReadBlocks+0x8c>)
 8007e0c:	2200      	movs	r2, #0
 8007e0e:	701a      	strb	r2, [r3, #0]
  if(HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)p_data, block_addr, num_of_blocks) == HAL_OK)
 8007e10:	687b      	ldr	r3, [r7, #4]
 8007e12:	68fa      	ldr	r2, [r7, #12]
 8007e14:	68b9      	ldr	r1, [r7, #8]
 8007e16:	481c      	ldr	r0, [pc, #112]	@ (8007e88 <sdReadBlocks+0x90>)
 8007e18:	f007 ffcc 	bl	800fdb4 <HAL_SD_ReadBlocks_DMA>
 8007e1c:	4603      	mov	r3, r0
 8007e1e:	2b00      	cmp	r3, #0
 8007e20:	d12a      	bne.n	8007e78 <sdReadBlocks+0x80>
  {

    pre_time = millis();
 8007e22:	f7f9 fe35 	bl	8001a90 <millis>
 8007e26:	6138      	str	r0, [r7, #16]
    while(is_rx_done == false)
 8007e28:	e007      	b.n	8007e3a <sdReadBlocks+0x42>
    {
      if (millis()-pre_time >= timeout_ms)
 8007e2a:	f7f9 fe31 	bl	8001a90 <millis>
 8007e2e:	4602      	mov	r2, r0
 8007e30:	693b      	ldr	r3, [r7, #16]
 8007e32:	1ad3      	subs	r3, r2, r3
 8007e34:	683a      	ldr	r2, [r7, #0]
 8007e36:	429a      	cmp	r2, r3
 8007e38:	d908      	bls.n	8007e4c <sdReadBlocks+0x54>
    while(is_rx_done == false)
 8007e3a:	4b12      	ldr	r3, [pc, #72]	@ (8007e84 <sdReadBlocks+0x8c>)
 8007e3c:	781b      	ldrb	r3, [r3, #0]
 8007e3e:	b2db      	uxtb	r3, r3
 8007e40:	f083 0301 	eor.w	r3, r3, #1
 8007e44:	b2db      	uxtb	r3, r3
 8007e46:	2b00      	cmp	r3, #0
 8007e48:	d1ef      	bne.n	8007e2a <sdReadBlocks+0x32>
 8007e4a:	e00d      	b.n	8007e68 <sdReadBlocks+0x70>
      {
        break;
 8007e4c:	bf00      	nop
      }
    }
    while(sdIsBusy() == true)
 8007e4e:	e00b      	b.n	8007e68 <sdReadBlocks+0x70>
    {
      if (millis()-pre_time >= timeout_ms)
 8007e50:	f7f9 fe1e 	bl	8001a90 <millis>
 8007e54:	4602      	mov	r2, r0
 8007e56:	693b      	ldr	r3, [r7, #16]
 8007e58:	1ad3      	subs	r3, r2, r3
 8007e5a:	683a      	ldr	r2, [r7, #0]
 8007e5c:	429a      	cmp	r2, r3
 8007e5e:	d803      	bhi.n	8007e68 <sdReadBlocks+0x70>
      {
        is_rx_done = false;
 8007e60:	4b08      	ldr	r3, [pc, #32]	@ (8007e84 <sdReadBlocks+0x8c>)
 8007e62:	2200      	movs	r2, #0
 8007e64:	701a      	strb	r2, [r3, #0]
        break;
 8007e66:	e004      	b.n	8007e72 <sdReadBlocks+0x7a>
    while(sdIsBusy() == true)
 8007e68:	f7ff ff90 	bl	8007d8c <sdIsBusy>
 8007e6c:	4603      	mov	r3, r0
 8007e6e:	2b00      	cmp	r3, #0
 8007e70:	d1ee      	bne.n	8007e50 <sdReadBlocks+0x58>
      }
    }
    ret = is_rx_done;
 8007e72:	4b04      	ldr	r3, [pc, #16]	@ (8007e84 <sdReadBlocks+0x8c>)
 8007e74:	781b      	ldrb	r3, [r3, #0]
 8007e76:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
 8007e78:	7dfb      	ldrb	r3, [r7, #23]
}
 8007e7a:	4618      	mov	r0, r3
 8007e7c:	3718      	adds	r7, #24
 8007e7e:	46bd      	mov	sp, r7
 8007e80:	bd80      	pop	{r7, pc}
 8007e82:	bf00      	nop
 8007e84:	2000a4ca 	.word	0x2000a4ca
 8007e88:	2000039c 	.word	0x2000039c

08007e8c <sdWriteBlocks>:

bool sdWriteBlocks(uint32_t block_addr, uint8_t *p_data, uint32_t num_of_blocks, uint32_t timeout_ms)
{
 8007e8c:	b580      	push	{r7, lr}
 8007e8e:	b086      	sub	sp, #24
 8007e90:	af00      	add	r7, sp, #0
 8007e92:	60f8      	str	r0, [r7, #12]
 8007e94:	60b9      	str	r1, [r7, #8]
 8007e96:	607a      	str	r2, [r7, #4]
 8007e98:	603b      	str	r3, [r7, #0]
  bool ret = false;
 8007e9a:	2300      	movs	r3, #0
 8007e9c:	75fb      	strb	r3, [r7, #23]
  uint32_t pre_time;


  is_tx_done = false;
 8007e9e:	4b1f      	ldr	r3, [pc, #124]	@ (8007f1c <sdWriteBlocks+0x90>)
 8007ea0:	2200      	movs	r2, #0
 8007ea2:	701a      	strb	r2, [r3, #0]
  if(HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)p_data, block_addr, num_of_blocks) == HAL_OK)
 8007ea4:	687b      	ldr	r3, [r7, #4]
 8007ea6:	68fa      	ldr	r2, [r7, #12]
 8007ea8:	68b9      	ldr	r1, [r7, #8]
 8007eaa:	481d      	ldr	r0, [pc, #116]	@ (8007f20 <sdWriteBlocks+0x94>)
 8007eac:	f008 f864 	bl	800ff78 <HAL_SD_WriteBlocks_DMA>
 8007eb0:	4603      	mov	r3, r0
 8007eb2:	2b00      	cmp	r3, #0
 8007eb4:	d12d      	bne.n	8007f12 <sdWriteBlocks+0x86>
  {
    pre_time = millis();
 8007eb6:	f7f9 fdeb 	bl	8001a90 <millis>
 8007eba:	6138      	str	r0, [r7, #16]
    while(is_tx_done == false)
 8007ebc:	e007      	b.n	8007ece <sdWriteBlocks+0x42>
    {
      if (millis()-pre_time >= timeout_ms)
 8007ebe:	f7f9 fde7 	bl	8001a90 <millis>
 8007ec2:	4602      	mov	r2, r0
 8007ec4:	693b      	ldr	r3, [r7, #16]
 8007ec6:	1ad3      	subs	r3, r2, r3
 8007ec8:	683a      	ldr	r2, [r7, #0]
 8007eca:	429a      	cmp	r2, r3
 8007ecc:	d908      	bls.n	8007ee0 <sdWriteBlocks+0x54>
    while(is_tx_done == false)
 8007ece:	4b13      	ldr	r3, [pc, #76]	@ (8007f1c <sdWriteBlocks+0x90>)
 8007ed0:	781b      	ldrb	r3, [r3, #0]
 8007ed2:	b2db      	uxtb	r3, r3
 8007ed4:	f083 0301 	eor.w	r3, r3, #1
 8007ed8:	b2db      	uxtb	r3, r3
 8007eda:	2b00      	cmp	r3, #0
 8007edc:	d1ef      	bne.n	8007ebe <sdWriteBlocks+0x32>
 8007ede:	e000      	b.n	8007ee2 <sdWriteBlocks+0x56>
      {
        break;
 8007ee0:	bf00      	nop
      }
    }
    pre_time = millis();
 8007ee2:	f7f9 fdd5 	bl	8001a90 <millis>
 8007ee6:	6138      	str	r0, [r7, #16]
    while(sdIsBusy() == true)
 8007ee8:	e00b      	b.n	8007f02 <sdWriteBlocks+0x76>
    {
      if (millis()-pre_time >= timeout_ms)
 8007eea:	f7f9 fdd1 	bl	8001a90 <millis>
 8007eee:	4602      	mov	r2, r0
 8007ef0:	693b      	ldr	r3, [r7, #16]
 8007ef2:	1ad3      	subs	r3, r2, r3
 8007ef4:	683a      	ldr	r2, [r7, #0]
 8007ef6:	429a      	cmp	r2, r3
 8007ef8:	d803      	bhi.n	8007f02 <sdWriteBlocks+0x76>
      {
        is_tx_done = false;
 8007efa:	4b08      	ldr	r3, [pc, #32]	@ (8007f1c <sdWriteBlocks+0x90>)
 8007efc:	2200      	movs	r2, #0
 8007efe:	701a      	strb	r2, [r3, #0]
        break;
 8007f00:	e004      	b.n	8007f0c <sdWriteBlocks+0x80>
    while(sdIsBusy() == true)
 8007f02:	f7ff ff43 	bl	8007d8c <sdIsBusy>
 8007f06:	4603      	mov	r3, r0
 8007f08:	2b00      	cmp	r3, #0
 8007f0a:	d1ee      	bne.n	8007eea <sdWriteBlocks+0x5e>
      }
    }
    ret = is_tx_done;
 8007f0c:	4b03      	ldr	r3, [pc, #12]	@ (8007f1c <sdWriteBlocks+0x90>)
 8007f0e:	781b      	ldrb	r3, [r3, #0]
 8007f10:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
 8007f12:	7dfb      	ldrb	r3, [r7, #23]
}
 8007f14:	4618      	mov	r0, r3
 8007f16:	3718      	adds	r7, #24
 8007f18:	46bd      	mov	sp, r7
 8007f1a:	bd80      	pop	{r7, pc}
 8007f1c:	2000a4cb 	.word	0x2000a4cb
 8007f20:	2000039c 	.word	0x2000039c

08007f24 <HAL_SD_RxCpltCallback>:




void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
{
 8007f24:	b480      	push	{r7}
 8007f26:	b083      	sub	sp, #12
 8007f28:	af00      	add	r7, sp, #0
 8007f2a:	6078      	str	r0, [r7, #4]
  is_rx_done = true;
 8007f2c:	4b04      	ldr	r3, [pc, #16]	@ (8007f40 <HAL_SD_RxCpltCallback+0x1c>)
 8007f2e:	2201      	movs	r2, #1
 8007f30:	701a      	strb	r2, [r3, #0]
}
 8007f32:	bf00      	nop
 8007f34:	370c      	adds	r7, #12
 8007f36:	46bd      	mov	sp, r7
 8007f38:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f3c:	4770      	bx	lr
 8007f3e:	bf00      	nop
 8007f40:	2000a4ca 	.word	0x2000a4ca

08007f44 <HAL_SD_TxCpltCallback>:

void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
{
 8007f44:	b480      	push	{r7}
 8007f46:	b083      	sub	sp, #12
 8007f48:	af00      	add	r7, sp, #0
 8007f4a:	6078      	str	r0, [r7, #4]
  is_tx_done = true;
 8007f4c:	4b04      	ldr	r3, [pc, #16]	@ (8007f60 <HAL_SD_TxCpltCallback+0x1c>)
 8007f4e:	2201      	movs	r2, #1
 8007f50:	701a      	strb	r2, [r3, #0]
}
 8007f52:	bf00      	nop
 8007f54:	370c      	adds	r7, #12
 8007f56:	46bd      	mov	sp, r7
 8007f58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f5c:	4770      	bx	lr
 8007f5e:	bf00      	nop
 8007f60:	2000a4cb 	.word	0x2000a4cb

08007f64 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
 8007f64:	b580      	push	{r7, lr}
 8007f66:	b08c      	sub	sp, #48	@ 0x30
 8007f68:	af00      	add	r7, sp, #0
 8007f6a:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8007f6c:	f107 031c 	add.w	r3, r7, #28
 8007f70:	2200      	movs	r2, #0
 8007f72:	601a      	str	r2, [r3, #0]
 8007f74:	605a      	str	r2, [r3, #4]
 8007f76:	609a      	str	r2, [r3, #8]
 8007f78:	60da      	str	r2, [r3, #12]
 8007f7a:	611a      	str	r2, [r3, #16]
  if(sdHandle->Instance==SDIO)
 8007f7c:	687b      	ldr	r3, [r7, #4]
 8007f7e:	681b      	ldr	r3, [r3, #0]
 8007f80:	4a77      	ldr	r2, [pc, #476]	@ (8008160 <HAL_SD_MspInit+0x1fc>)
 8007f82:	4293      	cmp	r3, r2
 8007f84:	f040 80e8 	bne.w	8008158 <HAL_SD_MspInit+0x1f4>
  {
  /* USER CODE BEGIN SDIO_MspInit 0 */
    __HAL_RCC_DMA2_CLK_ENABLE();
 8007f88:	2300      	movs	r3, #0
 8007f8a:	61bb      	str	r3, [r7, #24]
 8007f8c:	4b75      	ldr	r3, [pc, #468]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007f8e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007f90:	4a74      	ldr	r2, [pc, #464]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007f92:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8007f96:	6313      	str	r3, [r2, #48]	@ 0x30
 8007f98:	4b72      	ldr	r3, [pc, #456]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007f9a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007f9c:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8007fa0:	61bb      	str	r3, [r7, #24]
 8007fa2:	69bb      	ldr	r3, [r7, #24]
  /* USER CODE END SDIO_MspInit 0 */
    /* SDIO clock enable */
    __HAL_RCC_SDIO_CLK_ENABLE();
 8007fa4:	2300      	movs	r3, #0
 8007fa6:	617b      	str	r3, [r7, #20]
 8007fa8:	4b6e      	ldr	r3, [pc, #440]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007faa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8007fac:	4a6d      	ldr	r2, [pc, #436]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fae:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8007fb2:	6453      	str	r3, [r2, #68]	@ 0x44
 8007fb4:	4b6b      	ldr	r3, [pc, #428]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fb6:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8007fb8:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8007fbc:	617b      	str	r3, [r7, #20]
 8007fbe:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8007fc0:	2300      	movs	r3, #0
 8007fc2:	613b      	str	r3, [r7, #16]
 8007fc4:	4b67      	ldr	r3, [pc, #412]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fc6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007fc8:	4a66      	ldr	r2, [pc, #408]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fca:	f043 0301 	orr.w	r3, r3, #1
 8007fce:	6313      	str	r3, [r2, #48]	@ 0x30
 8007fd0:	4b64      	ldr	r3, [pc, #400]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fd2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007fd4:	f003 0301 	and.w	r3, r3, #1
 8007fd8:	613b      	str	r3, [r7, #16]
 8007fda:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8007fdc:	2300      	movs	r3, #0
 8007fde:	60fb      	str	r3, [r7, #12]
 8007fe0:	4b60      	ldr	r3, [pc, #384]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fe2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007fe4:	4a5f      	ldr	r2, [pc, #380]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fe6:	f043 0302 	orr.w	r3, r3, #2
 8007fea:	6313      	str	r3, [r2, #48]	@ 0x30
 8007fec:	4b5d      	ldr	r3, [pc, #372]	@ (8008164 <HAL_SD_MspInit+0x200>)
 8007fee:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007ff0:	f003 0302 	and.w	r3, r3, #2
 8007ff4:	60fb      	str	r3, [r7, #12]
 8007ff6:	68fb      	ldr	r3, [r7, #12]
    PA8     ------> SDIO_D1
    PA9     ------> SDIO_D2
    PB5     ------> SDIO_D3
    PB7     ------> SDIO_D0
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9;
 8007ff8:	f44f 7350 	mov.w	r3, #832	@ 0x340
 8007ffc:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007ffe:	2302      	movs	r3, #2
 8008000:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8008002:	2301      	movs	r3, #1
 8008004:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8008006:	2301      	movs	r3, #1
 8008008:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 800800a:	230c      	movs	r3, #12
 800800c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800800e:	f107 031c 	add.w	r3, r7, #28
 8008012:	4619      	mov	r1, r3
 8008014:	4854      	ldr	r0, [pc, #336]	@ (8008168 <HAL_SD_MspInit+0x204>)
 8008016:	f001 ff0b 	bl	8009e30 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_15|GPIO_PIN_5|GPIO_PIN_7;
 800801a:	f248 03a0 	movw	r3, #32928	@ 0x80a0
 800801e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008020:	2302      	movs	r3, #2
 8008022:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8008024:	2301      	movs	r3, #1
 8008026:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8008028:	2301      	movs	r3, #1
 800802a:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
 800802c:	230c      	movs	r3, #12
 800802e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008030:	f107 031c 	add.w	r3, r7, #28
 8008034:	4619      	mov	r1, r3
 8008036:	484d      	ldr	r0, [pc, #308]	@ (800816c <HAL_SD_MspInit+0x208>)
 8008038:	f001 fefa 	bl	8009e30 <HAL_GPIO_Init>

    /* SDIO DMA Init */
    /* SDIO_RX Init */
    hdma_sdio_rx.Instance = DMA2_Stream3;
 800803c:	4b4c      	ldr	r3, [pc, #304]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 800803e:	4a4d      	ldr	r2, [pc, #308]	@ (8008174 <HAL_SD_MspInit+0x210>)
 8008040:	601a      	str	r2, [r3, #0]
    hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
 8008042:	4b4b      	ldr	r3, [pc, #300]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008044:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 8008048:	605a      	str	r2, [r3, #4]
    hdma_sdio_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800804a:	4b49      	ldr	r3, [pc, #292]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 800804c:	2200      	movs	r2, #0
 800804e:	609a      	str	r2, [r3, #8]
    hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8008050:	4b47      	ldr	r3, [pc, #284]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008052:	2200      	movs	r2, #0
 8008054:	60da      	str	r2, [r3, #12]
    hdma_sdio_rx.Init.MemInc = DMA_MINC_ENABLE;
 8008056:	4b46      	ldr	r3, [pc, #280]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008058:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 800805c:	611a      	str	r2, [r3, #16]
    hdma_sdio_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800805e:	4b44      	ldr	r3, [pc, #272]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008060:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8008064:	615a      	str	r2, [r3, #20]
    hdma_sdio_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8008066:	4b42      	ldr	r3, [pc, #264]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008068:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 800806c:	619a      	str	r2, [r3, #24]
    hdma_sdio_rx.Init.Mode = DMA_PFCTRL;
 800806e:	4b40      	ldr	r3, [pc, #256]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008070:	2220      	movs	r2, #32
 8008072:	61da      	str	r2, [r3, #28]
    hdma_sdio_rx.Init.Priority = DMA_PRIORITY_LOW;
 8008074:	4b3e      	ldr	r3, [pc, #248]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008076:	2200      	movs	r2, #0
 8008078:	621a      	str	r2, [r3, #32]
    hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 800807a:	4b3d      	ldr	r3, [pc, #244]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 800807c:	2204      	movs	r2, #4
 800807e:	625a      	str	r2, [r3, #36]	@ 0x24
    hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 8008080:	4b3b      	ldr	r3, [pc, #236]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008082:	2203      	movs	r2, #3
 8008084:	629a      	str	r2, [r3, #40]	@ 0x28
    hdma_sdio_rx.Init.MemBurst = DMA_MBURST_INC4;
 8008086:	4b3a      	ldr	r3, [pc, #232]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008088:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 800808c:	62da      	str	r2, [r3, #44]	@ 0x2c
    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
 800808e:	4b38      	ldr	r3, [pc, #224]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008090:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 8008094:	631a      	str	r2, [r3, #48]	@ 0x30
    if (HAL_DMA_Init(&hdma_sdio_rx) != HAL_OK)
 8008096:	4836      	ldr	r0, [pc, #216]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 8008098:	f000 ff68 	bl	8008f6c <HAL_DMA_Init>
 800809c:	4603      	mov	r3, r0
 800809e:	2b00      	cmp	r3, #0
 80080a0:	d001      	beq.n	80080a6 <HAL_SD_MspInit+0x142>
    {
      Error_Handler();
 80080a2:	f7f9 fb1f 	bl	80016e4 <Error_Handler>
    }

    __HAL_LINKDMA(sdHandle,hdmarx,hdma_sdio_rx);
 80080a6:	687b      	ldr	r3, [r7, #4]
 80080a8:	4a31      	ldr	r2, [pc, #196]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 80080aa:	641a      	str	r2, [r3, #64]	@ 0x40
 80080ac:	4a30      	ldr	r2, [pc, #192]	@ (8008170 <HAL_SD_MspInit+0x20c>)
 80080ae:	687b      	ldr	r3, [r7, #4]
 80080b0:	6393      	str	r3, [r2, #56]	@ 0x38

    /* SDIO_TX Init */
    hdma_sdio_tx.Instance = DMA2_Stream6;
 80080b2:	4b31      	ldr	r3, [pc, #196]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080b4:	4a31      	ldr	r2, [pc, #196]	@ (800817c <HAL_SD_MspInit+0x218>)
 80080b6:	601a      	str	r2, [r3, #0]
    hdma_sdio_tx.Init.Channel = DMA_CHANNEL_4;
 80080b8:	4b2f      	ldr	r3, [pc, #188]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080ba:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 80080be:	605a      	str	r2, [r3, #4]
    hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80080c0:	4b2d      	ldr	r3, [pc, #180]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080c2:	2240      	movs	r2, #64	@ 0x40
 80080c4:	609a      	str	r2, [r3, #8]
    hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80080c6:	4b2c      	ldr	r3, [pc, #176]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080c8:	2200      	movs	r2, #0
 80080ca:	60da      	str	r2, [r3, #12]
    hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
 80080cc:	4b2a      	ldr	r3, [pc, #168]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080ce:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80080d2:	611a      	str	r2, [r3, #16]
    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80080d4:	4b28      	ldr	r3, [pc, #160]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080d6:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 80080da:	615a      	str	r2, [r3, #20]
    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 80080dc:	4b26      	ldr	r3, [pc, #152]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080de:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 80080e2:	619a      	str	r2, [r3, #24]
    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
 80080e4:	4b24      	ldr	r3, [pc, #144]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080e6:	2220      	movs	r2, #32
 80080e8:	61da      	str	r2, [r3, #28]
    hdma_sdio_tx.Init.Priority = DMA_PRIORITY_LOW;
 80080ea:	4b23      	ldr	r3, [pc, #140]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080ec:	2200      	movs	r2, #0
 80080ee:	621a      	str	r2, [r3, #32]
    hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80080f0:	4b21      	ldr	r3, [pc, #132]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080f2:	2204      	movs	r2, #4
 80080f4:	625a      	str	r2, [r3, #36]	@ 0x24
    hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
 80080f6:	4b20      	ldr	r3, [pc, #128]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080f8:	2203      	movs	r2, #3
 80080fa:	629a      	str	r2, [r3, #40]	@ 0x28
    hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
 80080fc:	4b1e      	ldr	r3, [pc, #120]	@ (8008178 <HAL_SD_MspInit+0x214>)
 80080fe:	f44f 0200 	mov.w	r2, #8388608	@ 0x800000
 8008102:	62da      	str	r2, [r3, #44]	@ 0x2c
    hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;
 8008104:	4b1c      	ldr	r3, [pc, #112]	@ (8008178 <HAL_SD_MspInit+0x214>)
 8008106:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 800810a:	631a      	str	r2, [r3, #48]	@ 0x30
    if (HAL_DMA_Init(&hdma_sdio_tx) != HAL_OK)
 800810c:	481a      	ldr	r0, [pc, #104]	@ (8008178 <HAL_SD_MspInit+0x214>)
 800810e:	f000 ff2d 	bl	8008f6c <HAL_DMA_Init>
 8008112:	4603      	mov	r3, r0
 8008114:	2b00      	cmp	r3, #0
 8008116:	d001      	beq.n	800811c <HAL_SD_MspInit+0x1b8>
    {
      Error_Handler();
 8008118:	f7f9 fae4 	bl	80016e4 <Error_Handler>
    }

    __HAL_LINKDMA(sdHandle,hdmatx,hdma_sdio_tx);
 800811c:	687b      	ldr	r3, [r7, #4]
 800811e:	4a16      	ldr	r2, [pc, #88]	@ (8008178 <HAL_SD_MspInit+0x214>)
 8008120:	63da      	str	r2, [r3, #60]	@ 0x3c
 8008122:	4a15      	ldr	r2, [pc, #84]	@ (8008178 <HAL_SD_MspInit+0x214>)
 8008124:	687b      	ldr	r3, [r7, #4]
 8008126:	6393      	str	r3, [r2, #56]	@ 0x38

    /* SDIO interrupt Init */
    HAL_NVIC_SetPriority(SDIO_IRQn, 4, 0);
 8008128:	2200      	movs	r2, #0
 800812a:	2104      	movs	r1, #4
 800812c:	2031      	movs	r0, #49	@ 0x31
 800812e:	f000 fed8 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDIO_IRQn);
 8008132:	2031      	movs	r0, #49	@ 0x31
 8008134:	f000 fef1 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SDIO_MspInit 1 */

    /* DMA interrupt init */
    /* DMA2_Stream3_IRQn interrupt configuration */
    HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 3, 0);
 8008138:	2200      	movs	r2, #0
 800813a:	2103      	movs	r1, #3
 800813c:	203b      	movs	r0, #59	@ 0x3b
 800813e:	f000 fed0 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
 8008142:	203b      	movs	r0, #59	@ 0x3b
 8008144:	f000 fee9 	bl	8008f1a <HAL_NVIC_EnableIRQ>
    /* DMA2_Stream6_IRQn interrupt configuration */
    HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 3, 0);
 8008148:	2200      	movs	r2, #0
 800814a:	2103      	movs	r1, #3
 800814c:	2045      	movs	r0, #69	@ 0x45
 800814e:	f000 fec8 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
 8008152:	2045      	movs	r0, #69	@ 0x45
 8008154:	f000 fee1 	bl	8008f1a <HAL_NVIC_EnableIRQ>

  /* USER CODE END SDIO_MspInit 1 */
  }
}
 8008158:	bf00      	nop
 800815a:	3730      	adds	r7, #48	@ 0x30
 800815c:	46bd      	mov	sp, r7
 800815e:	bd80      	pop	{r7, pc}
 8008160:	40012c00 	.word	0x40012c00
 8008164:	40023800 	.word	0x40023800
 8008168:	40020000 	.word	0x40020000
 800816c:	40020400 	.word	0x40020400
 8008170:	20000420 	.word	0x20000420
 8008174:	40026458 	.word	0x40026458
 8008178:	20000480 	.word	0x20000480
 800817c:	400264a0 	.word	0x400264a0

08008180 <cliSd>:



#ifdef _USE_HW_CLI
void cliSd(cli_args_t *args)
{
 8008180:	b590      	push	{r4, r7, lr}
 8008182:	f5ad 7d07 	sub.w	sp, sp, #540	@ 0x21c
 8008186:	af00      	add	r7, sp, #0
 8008188:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 800818c:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008190:	6018      	str	r0, [r3, #0]
  bool ret = false;
 8008192:	2300      	movs	r3, #0
 8008194:	f887 3217 	strb.w	r3, [r7, #535]	@ 0x217


  if (args->argc == 1 && args->isStr(0, "info") == true)
 8008198:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 800819c:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 80081a0:	681b      	ldr	r3, [r3, #0]
 80081a2:	881b      	ldrh	r3, [r3, #0]
 80081a4:	2b01      	cmp	r3, #1
 80081a6:	f040 8094 	bne.w	80082d2 <cliSd+0x152>
 80081aa:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 80081ae:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 80081b2:	681b      	ldr	r3, [r3, #0]
 80081b4:	695b      	ldr	r3, [r3, #20]
 80081b6:	4979      	ldr	r1, [pc, #484]	@ (800839c <cliSd+0x21c>)
 80081b8:	2000      	movs	r0, #0
 80081ba:	4798      	blx	r3
 80081bc:	4603      	mov	r3, r0
 80081be:	2b00      	cmp	r3, #0
 80081c0:	f000 8087 	beq.w	80082d2 <cliSd+0x152>
  {
    sd_info_t sd_info;

    cliPrintf("sd init      : %d\n", is_init);
 80081c4:	4b76      	ldr	r3, [pc, #472]	@ (80083a0 <cliSd+0x220>)
 80081c6:	781b      	ldrb	r3, [r3, #0]
 80081c8:	4619      	mov	r1, r3
 80081ca:	4876      	ldr	r0, [pc, #472]	@ (80083a4 <cliSd+0x224>)
 80081cc:	f7fb f85c 	bl	8003288 <cliPrintf>
    cliPrintf("sd connected : %d\n", is_detected);
 80081d0:	4b75      	ldr	r3, [pc, #468]	@ (80083a8 <cliSd+0x228>)
 80081d2:	781b      	ldrb	r3, [r3, #0]
 80081d4:	4619      	mov	r1, r3
 80081d6:	4875      	ldr	r0, [pc, #468]	@ (80083ac <cliSd+0x22c>)
 80081d8:	f7fb f856 	bl	8003288 <cliPrintf>

    if (is_init == true)
 80081dc:	4b70      	ldr	r3, [pc, #448]	@ (80083a0 <cliSd+0x220>)
 80081de:	781b      	ldrb	r3, [r3, #0]
 80081e0:	2b00      	cmp	r3, #0
 80081e2:	d073      	beq.n	80082cc <cliSd+0x14c>
    {
      if (sdGetInfo(&sd_info) == true)
 80081e4:	f107 030c 	add.w	r3, r7, #12
 80081e8:	4618      	mov	r0, r3
 80081ea:	f7ff fd77 	bl	8007cdc <sdGetInfo>
 80081ee:	4603      	mov	r3, r0
 80081f0:	2b00      	cmp	r3, #0
 80081f2:	d06b      	beq.n	80082cc <cliSd+0x14c>
      {
        cliPrintf("   card_type            : %d\n", sd_info.card_type);
 80081f4:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 80081f8:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 80081fc:	681b      	ldr	r3, [r3, #0]
 80081fe:	4619      	mov	r1, r3
 8008200:	486b      	ldr	r0, [pc, #428]	@ (80083b0 <cliSd+0x230>)
 8008202:	f7fb f841 	bl	8003288 <cliPrintf>
        cliPrintf("   card_version         : %d\n", sd_info.card_version);
 8008206:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 800820a:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 800820e:	685b      	ldr	r3, [r3, #4]
 8008210:	4619      	mov	r1, r3
 8008212:	4868      	ldr	r0, [pc, #416]	@ (80083b4 <cliSd+0x234>)
 8008214:	f7fb f838 	bl	8003288 <cliPrintf>
        cliPrintf("   card_class           : %d\n", sd_info.card_class);
 8008218:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 800821c:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 8008220:	689b      	ldr	r3, [r3, #8]
 8008222:	4619      	mov	r1, r3
 8008224:	4864      	ldr	r0, [pc, #400]	@ (80083b8 <cliSd+0x238>)
 8008226:	f7fb f82f 	bl	8003288 <cliPrintf>
        cliPrintf("   rel_card_Add         : %d\n", sd_info.rel_card_Add);
 800822a:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 800822e:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 8008232:	68db      	ldr	r3, [r3, #12]
 8008234:	4619      	mov	r1, r3
 8008236:	4861      	ldr	r0, [pc, #388]	@ (80083bc <cliSd+0x23c>)
 8008238:	f7fb f826 	bl	8003288 <cliPrintf>
        cliPrintf("   block_numbers        : %d\n", sd_info.block_numbers);
 800823c:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008240:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 8008244:	691b      	ldr	r3, [r3, #16]
 8008246:	4619      	mov	r1, r3
 8008248:	485d      	ldr	r0, [pc, #372]	@ (80083c0 <cliSd+0x240>)
 800824a:	f7fb f81d 	bl	8003288 <cliPrintf>
        cliPrintf("   block_size           : %d\n", sd_info.block_size);
 800824e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008252:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 8008256:	695b      	ldr	r3, [r3, #20]
 8008258:	4619      	mov	r1, r3
 800825a:	485a      	ldr	r0, [pc, #360]	@ (80083c4 <cliSd+0x244>)
 800825c:	f7fb f814 	bl	8003288 <cliPrintf>
        cliPrintf("   log_block_numbers    : %d\n", sd_info.log_block_numbers);
 8008260:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008264:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 8008268:	699b      	ldr	r3, [r3, #24]
 800826a:	4619      	mov	r1, r3
 800826c:	4856      	ldr	r0, [pc, #344]	@ (80083c8 <cliSd+0x248>)
 800826e:	f7fb f80b 	bl	8003288 <cliPrintf>
        cliPrintf("   log_block_size       : %d\n", sd_info.log_block_size);
 8008272:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008276:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 800827a:	69db      	ldr	r3, [r3, #28]
 800827c:	4619      	mov	r1, r3
 800827e:	4853      	ldr	r0, [pc, #332]	@ (80083cc <cliSd+0x24c>)
 8008280:	f7fb f802 	bl	8003288 <cliPrintf>
        cliPrintf("   card_size            : %d MB, %d.%d GB\n", sd_info.card_size, sd_info.card_size/1024, ((sd_info.card_size * 10)/1024) % 10);
 8008284:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008288:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 800828c:	6a18      	ldr	r0, [r3, #32]
 800828e:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008292:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 8008296:	6a1b      	ldr	r3, [r3, #32]
 8008298:	0a9c      	lsrs	r4, r3, #10
 800829a:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 800829e:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 80082a2:	6a1a      	ldr	r2, [r3, #32]
 80082a4:	4613      	mov	r3, r2
 80082a6:	009b      	lsls	r3, r3, #2
 80082a8:	4413      	add	r3, r2
 80082aa:	005b      	lsls	r3, r3, #1
 80082ac:	0a99      	lsrs	r1, r3, #10
 80082ae:	4b48      	ldr	r3, [pc, #288]	@ (80083d0 <cliSd+0x250>)
 80082b0:	fba3 2301 	umull	r2, r3, r3, r1
 80082b4:	08da      	lsrs	r2, r3, #3
 80082b6:	4613      	mov	r3, r2
 80082b8:	009b      	lsls	r3, r3, #2
 80082ba:	4413      	add	r3, r2
 80082bc:	005b      	lsls	r3, r3, #1
 80082be:	1aca      	subs	r2, r1, r3
 80082c0:	4613      	mov	r3, r2
 80082c2:	4622      	mov	r2, r4
 80082c4:	4601      	mov	r1, r0
 80082c6:	4843      	ldr	r0, [pc, #268]	@ (80083d4 <cliSd+0x254>)
 80082c8:	f7fa ffde 	bl	8003288 <cliPrintf>
      }
    }
    ret = true;
 80082cc:	2301      	movs	r3, #1
 80082ce:	f887 3217 	strb.w	r3, [r7, #535]	@ 0x217
  }

  if (args->argc == 2 && args->isStr(0, "read") == true)
 80082d2:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 80082d6:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 80082da:	681b      	ldr	r3, [r3, #0]
 80082dc:	881b      	ldrh	r3, [r3, #0]
 80082de:	2b02      	cmp	r3, #2
 80082e0:	d146      	bne.n	8008370 <cliSd+0x1f0>
 80082e2:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 80082e6:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 80082ea:	681b      	ldr	r3, [r3, #0]
 80082ec:	695b      	ldr	r3, [r3, #20]
 80082ee:	493a      	ldr	r1, [pc, #232]	@ (80083d8 <cliSd+0x258>)
 80082f0:	2000      	movs	r0, #0
 80082f2:	4798      	blx	r3
 80082f4:	4603      	mov	r3, r0
 80082f6:	2b00      	cmp	r3, #0
 80082f8:	d03a      	beq.n	8008370 <cliSd+0x1f0>
  {
    uint32_t number;
    uint32_t buf[512/4];

    number = args->getData(1);
 80082fa:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 80082fe:	f5a3 7305 	sub.w	r3, r3, #532	@ 0x214
 8008302:	681b      	ldr	r3, [r3, #0]
 8008304:	689b      	ldr	r3, [r3, #8]
 8008306:	2001      	movs	r0, #1
 8008308:	4798      	blx	r3
 800830a:	4603      	mov	r3, r0
 800830c:	f8c7 320c 	str.w	r3, [r7, #524]	@ 0x20c

    if (sdReadBlocks(number, (uint8_t *)buf, 1, 100) == true)
 8008310:	f107 010c 	add.w	r1, r7, #12
 8008314:	2364      	movs	r3, #100	@ 0x64
 8008316:	2201      	movs	r2, #1
 8008318:	f8d7 020c 	ldr.w	r0, [r7, #524]	@ 0x20c
 800831c:	f7ff fd6c 	bl	8007df8 <sdReadBlocks>
 8008320:	4603      	mov	r3, r0
 8008322:	2b00      	cmp	r3, #0
 8008324:	d01e      	beq.n	8008364 <cliSd+0x1e4>
    {
      for (int i=0; i<512/4; i++)
 8008326:	2300      	movs	r3, #0
 8008328:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
 800832c:	e015      	b.n	800835a <cliSd+0x1da>
      {
        cliPrintf("%d:%04d : 0x%08X\n", number, i*4, buf[i]);
 800832e:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8008332:	0099      	lsls	r1, r3, #2
 8008334:	f507 7306 	add.w	r3, r7, #536	@ 0x218
 8008338:	f5a3 7303 	sub.w	r3, r3, #524	@ 0x20c
 800833c:	f8d7 2210 	ldr.w	r2, [r7, #528]	@ 0x210
 8008340:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8008344:	460a      	mov	r2, r1
 8008346:	f8d7 120c 	ldr.w	r1, [r7, #524]	@ 0x20c
 800834a:	4824      	ldr	r0, [pc, #144]	@ (80083dc <cliSd+0x25c>)
 800834c:	f7fa ff9c 	bl	8003288 <cliPrintf>
      for (int i=0; i<512/4; i++)
 8008350:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 8008354:	3301      	adds	r3, #1
 8008356:	f8c7 3210 	str.w	r3, [r7, #528]	@ 0x210
 800835a:	f8d7 3210 	ldr.w	r3, [r7, #528]	@ 0x210
 800835e:	2b7f      	cmp	r3, #127	@ 0x7f
 8008360:	dde5      	ble.n	800832e <cliSd+0x1ae>
 8008362:	e002      	b.n	800836a <cliSd+0x1ea>
      }
    }
    else
    {
      cliPrintf("sdRead Fail\n");
 8008364:	481e      	ldr	r0, [pc, #120]	@ (80083e0 <cliSd+0x260>)
 8008366:	f7fa ff8f 	bl	8003288 <cliPrintf>
    }

    ret = true;
 800836a:	2301      	movs	r3, #1
 800836c:	f887 3217 	strb.w	r3, [r7, #535]	@ 0x217
  }

  if (ret != true)
 8008370:	f897 3217 	ldrb.w	r3, [r7, #535]	@ 0x217
 8008374:	f083 0301 	eor.w	r3, r3, #1
 8008378:	b2db      	uxtb	r3, r3
 800837a:	2b00      	cmp	r3, #0
 800837c:	d009      	beq.n	8008392 <cliSd+0x212>
  {
    cliPrintf("sd info\n");
 800837e:	4819      	ldr	r0, [pc, #100]	@ (80083e4 <cliSd+0x264>)
 8008380:	f7fa ff82 	bl	8003288 <cliPrintf>

    if (is_init == true)
 8008384:	4b06      	ldr	r3, [pc, #24]	@ (80083a0 <cliSd+0x220>)
 8008386:	781b      	ldrb	r3, [r3, #0]
 8008388:	2b00      	cmp	r3, #0
 800838a:	d002      	beq.n	8008392 <cliSd+0x212>
    {
      cliPrintf("sd read block_number\n");
 800838c:	4816      	ldr	r0, [pc, #88]	@ (80083e8 <cliSd+0x268>)
 800838e:	f7fa ff7b 	bl	8003288 <cliPrintf>
    }
  }
}
 8008392:	bf00      	nop
 8008394:	f507 7707 	add.w	r7, r7, #540	@ 0x21c
 8008398:	46bd      	mov	sp, r7
 800839a:	bd90      	pop	{r4, r7, pc}
 800839c:	08024de8 	.word	0x08024de8
 80083a0:	2000a4c8 	.word	0x2000a4c8
 80083a4:	08024df0 	.word	0x08024df0
 80083a8:	2000a4c9 	.word	0x2000a4c9
 80083ac:	08024e04 	.word	0x08024e04
 80083b0:	08024e18 	.word	0x08024e18
 80083b4:	08024e38 	.word	0x08024e38
 80083b8:	08024e58 	.word	0x08024e58
 80083bc:	08024e78 	.word	0x08024e78
 80083c0:	08024e98 	.word	0x08024e98
 80083c4:	08024eb8 	.word	0x08024eb8
 80083c8:	08024ed8 	.word	0x08024ed8
 80083cc:	08024ef8 	.word	0x08024ef8
 80083d0:	cccccccd 	.word	0xcccccccd
 80083d4:	08024f18 	.word	0x08024f18
 80083d8:	08024f44 	.word	0x08024f44
 80083dc:	08024f4c 	.word	0x08024f4c
 80083e0:	08024f60 	.word	0x08024f60
 80083e4:	08024f70 	.word	0x08024f70
 80083e8:	08024f7c 	.word	0x08024f7c

080083ec <spiInit>:
SPI_HandleTypeDef hspi4;
DMA_HandleTypeDef hdma_spi4_tx;


bool spiInit(void)
{
 80083ec:	b480      	push	{r7}
 80083ee:	b083      	sub	sp, #12
 80083f0:	af00      	add	r7, sp, #0
  bool ret = true;
 80083f2:	2301      	movs	r3, #1
 80083f4:	70fb      	strb	r3, [r7, #3]


  for (int i=0; i<SPI_MAX_CH; i++)
 80083f6:	2300      	movs	r3, #0
 80083f8:	607b      	str	r3, [r7, #4]
 80083fa:	e03d      	b.n	8008478 <spiInit+0x8c>
  {
    spi_tbl[i].is_open = false;
 80083fc:	4923      	ldr	r1, [pc, #140]	@ (800848c <spiInit+0xa0>)
 80083fe:	687a      	ldr	r2, [r7, #4]
 8008400:	4613      	mov	r3, r2
 8008402:	009b      	lsls	r3, r3, #2
 8008404:	4413      	add	r3, r2
 8008406:	009b      	lsls	r3, r3, #2
 8008408:	440b      	add	r3, r1
 800840a:	2200      	movs	r2, #0
 800840c:	701a      	strb	r2, [r3, #0]
    spi_tbl[i].is_tx_done = true;
 800840e:	491f      	ldr	r1, [pc, #124]	@ (800848c <spiInit+0xa0>)
 8008410:	687a      	ldr	r2, [r7, #4]
 8008412:	4613      	mov	r3, r2
 8008414:	009b      	lsls	r3, r3, #2
 8008416:	4413      	add	r3, r2
 8008418:	009b      	lsls	r3, r3, #2
 800841a:	440b      	add	r3, r1
 800841c:	3301      	adds	r3, #1
 800841e:	2201      	movs	r2, #1
 8008420:	701a      	strb	r2, [r3, #0]
    spi_tbl[i].is_error = false;
 8008422:	491a      	ldr	r1, [pc, #104]	@ (800848c <spiInit+0xa0>)
 8008424:	687a      	ldr	r2, [r7, #4]
 8008426:	4613      	mov	r3, r2
 8008428:	009b      	lsls	r3, r3, #2
 800842a:	4413      	add	r3, r2
 800842c:	009b      	lsls	r3, r3, #2
 800842e:	440b      	add	r3, r1
 8008430:	3302      	adds	r3, #2
 8008432:	2200      	movs	r2, #0
 8008434:	701a      	strb	r2, [r3, #0]
    spi_tbl[i].func_tx = NULL;
 8008436:	4915      	ldr	r1, [pc, #84]	@ (800848c <spiInit+0xa0>)
 8008438:	687a      	ldr	r2, [r7, #4]
 800843a:	4613      	mov	r3, r2
 800843c:	009b      	lsls	r3, r3, #2
 800843e:	4413      	add	r3, r2
 8008440:	009b      	lsls	r3, r3, #2
 8008442:	440b      	add	r3, r1
 8008444:	3304      	adds	r3, #4
 8008446:	2200      	movs	r2, #0
 8008448:	601a      	str	r2, [r3, #0]
    spi_tbl[i].h_dma_rx = NULL;
 800844a:	4910      	ldr	r1, [pc, #64]	@ (800848c <spiInit+0xa0>)
 800844c:	687a      	ldr	r2, [r7, #4]
 800844e:	4613      	mov	r3, r2
 8008450:	009b      	lsls	r3, r3, #2
 8008452:	4413      	add	r3, r2
 8008454:	009b      	lsls	r3, r3, #2
 8008456:	440b      	add	r3, r1
 8008458:	3310      	adds	r3, #16
 800845a:	2200      	movs	r2, #0
 800845c:	601a      	str	r2, [r3, #0]
    spi_tbl[i].h_dma_tx = NULL;
 800845e:	490b      	ldr	r1, [pc, #44]	@ (800848c <spiInit+0xa0>)
 8008460:	687a      	ldr	r2, [r7, #4]
 8008462:	4613      	mov	r3, r2
 8008464:	009b      	lsls	r3, r3, #2
 8008466:	4413      	add	r3, r2
 8008468:	009b      	lsls	r3, r3, #2
 800846a:	440b      	add	r3, r1
 800846c:	330c      	adds	r3, #12
 800846e:	2200      	movs	r2, #0
 8008470:	601a      	str	r2, [r3, #0]
  for (int i=0; i<SPI_MAX_CH; i++)
 8008472:	687b      	ldr	r3, [r7, #4]
 8008474:	3301      	adds	r3, #1
 8008476:	607b      	str	r3, [r7, #4]
 8008478:	687b      	ldr	r3, [r7, #4]
 800847a:	2b00      	cmp	r3, #0
 800847c:	ddbe      	ble.n	80083fc <spiInit+0x10>
  }

  return ret;
 800847e:	78fb      	ldrb	r3, [r7, #3]
}
 8008480:	4618      	mov	r0, r3
 8008482:	370c      	adds	r7, #12
 8008484:	46bd      	mov	sp, r7
 8008486:	f85d 7b04 	ldr.w	r7, [sp], #4
 800848a:	4770      	bx	lr
 800848c:	2000a4cc 	.word	0x2000a4cc

08008490 <spiBegin>:

bool spiBegin(uint8_t ch)
{
 8008490:	b580      	push	{r7, lr}
 8008492:	b084      	sub	sp, #16
 8008494:	af00      	add	r7, sp, #0
 8008496:	4603      	mov	r3, r0
 8008498:	71fb      	strb	r3, [r7, #7]
  bool ret = false;
 800849a:	2300      	movs	r3, #0
 800849c:	73fb      	strb	r3, [r7, #15]
  spi_t *p_spi = &spi_tbl[ch];
 800849e:	79fa      	ldrb	r2, [r7, #7]
 80084a0:	4613      	mov	r3, r2
 80084a2:	009b      	lsls	r3, r3, #2
 80084a4:	4413      	add	r3, r2
 80084a6:	009b      	lsls	r3, r3, #2
 80084a8:	4a41      	ldr	r2, [pc, #260]	@ (80085b0 <spiBegin+0x120>)
 80084aa:	4413      	add	r3, r2
 80084ac:	60bb      	str	r3, [r7, #8]

  switch(ch)
 80084ae:	79fb      	ldrb	r3, [r7, #7]
 80084b0:	2b00      	cmp	r3, #0
 80084b2:	d002      	beq.n	80084ba <spiBegin+0x2a>
 80084b4:	2b01      	cmp	r3, #1
 80084b6:	d03b      	beq.n	8008530 <spiBegin+0xa0>
 80084b8:	e075      	b.n	80085a6 <spiBegin+0x116>
  {
    case _DEF_SPI1:
      p_spi->h_spi = &hspi4;
 80084ba:	68bb      	ldr	r3, [r7, #8]
 80084bc:	4a3d      	ldr	r2, [pc, #244]	@ (80085b4 <spiBegin+0x124>)
 80084be:	609a      	str	r2, [r3, #8]
      p_spi->h_dma_tx = &hdma_spi4_tx;
 80084c0:	68bb      	ldr	r3, [r7, #8]
 80084c2:	4a3d      	ldr	r2, [pc, #244]	@ (80085b8 <spiBegin+0x128>)
 80084c4:	60da      	str	r2, [r3, #12]

      hspi4.Instance              = SPI4;
 80084c6:	4b3b      	ldr	r3, [pc, #236]	@ (80085b4 <spiBegin+0x124>)
 80084c8:	4a3c      	ldr	r2, [pc, #240]	@ (80085bc <spiBegin+0x12c>)
 80084ca:	601a      	str	r2, [r3, #0]
      hspi4.Init.Mode             = SPI_MODE_MASTER;
 80084cc:	4b39      	ldr	r3, [pc, #228]	@ (80085b4 <spiBegin+0x124>)
 80084ce:	f44f 7282 	mov.w	r2, #260	@ 0x104
 80084d2:	605a      	str	r2, [r3, #4]
      hspi4.Init.Direction        = SPI_DIRECTION_2LINES;
 80084d4:	4b37      	ldr	r3, [pc, #220]	@ (80085b4 <spiBegin+0x124>)
 80084d6:	2200      	movs	r2, #0
 80084d8:	609a      	str	r2, [r3, #8]
      hspi4.Init.DataSize         = SPI_DATASIZE_8BIT;
 80084da:	4b36      	ldr	r3, [pc, #216]	@ (80085b4 <spiBegin+0x124>)
 80084dc:	2200      	movs	r2, #0
 80084de:	60da      	str	r2, [r3, #12]
      hspi4.Init.CLKPolarity      = SPI_POLARITY_LOW;
 80084e0:	4b34      	ldr	r3, [pc, #208]	@ (80085b4 <spiBegin+0x124>)
 80084e2:	2200      	movs	r2, #0
 80084e4:	611a      	str	r2, [r3, #16]
      hspi4.Init.CLKPhase         = SPI_PHASE_1EDGE;
 80084e6:	4b33      	ldr	r3, [pc, #204]	@ (80085b4 <spiBegin+0x124>)
 80084e8:	2200      	movs	r2, #0
 80084ea:	615a      	str	r2, [r3, #20]
      hspi4.Init.NSS              = SPI_NSS_SOFT;
 80084ec:	4b31      	ldr	r3, [pc, #196]	@ (80085b4 <spiBegin+0x124>)
 80084ee:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80084f2:	619a      	str	r2, [r3, #24]
      hspi4.Init.BaudRatePrescaler= SPI_BAUDRATEPRESCALER_2;
 80084f4:	4b2f      	ldr	r3, [pc, #188]	@ (80085b4 <spiBegin+0x124>)
 80084f6:	2200      	movs	r2, #0
 80084f8:	61da      	str	r2, [r3, #28]
      hspi4.Init.FirstBit         = SPI_FIRSTBIT_MSB;
 80084fa:	4b2e      	ldr	r3, [pc, #184]	@ (80085b4 <spiBegin+0x124>)
 80084fc:	2200      	movs	r2, #0
 80084fe:	621a      	str	r2, [r3, #32]
      hspi4.Init.TIMode           = SPI_TIMODE_DISABLE;
 8008500:	4b2c      	ldr	r3, [pc, #176]	@ (80085b4 <spiBegin+0x124>)
 8008502:	2200      	movs	r2, #0
 8008504:	625a      	str	r2, [r3, #36]	@ 0x24
      hspi4.Init.CRCCalculation   = SPI_CRCCALCULATION_DISABLE;
 8008506:	4b2b      	ldr	r3, [pc, #172]	@ (80085b4 <spiBegin+0x124>)
 8008508:	2200      	movs	r2, #0
 800850a:	629a      	str	r2, [r3, #40]	@ 0x28
      hspi4.Init.CRCPolynomial    = 10;
 800850c:	4b29      	ldr	r3, [pc, #164]	@ (80085b4 <spiBegin+0x124>)
 800850e:	220a      	movs	r2, #10
 8008510:	62da      	str	r2, [r3, #44]	@ 0x2c

      HAL_SPI_DeInit(&hspi4);
 8008512:	4828      	ldr	r0, [pc, #160]	@ (80085b4 <spiBegin+0x124>)
 8008514:	f008 ff6b 	bl	80113ee <HAL_SPI_DeInit>
      if (HAL_SPI_Init(&hspi4) == HAL_OK)
 8008518:	4826      	ldr	r0, [pc, #152]	@ (80085b4 <spiBegin+0x124>)
 800851a:	f008 fedf 	bl	80112dc <HAL_SPI_Init>
 800851e:	4603      	mov	r3, r0
 8008520:	2b00      	cmp	r3, #0
 8008522:	d13d      	bne.n	80085a0 <spiBegin+0x110>
      {
        p_spi->is_open = true;
 8008524:	68bb      	ldr	r3, [r7, #8]
 8008526:	2201      	movs	r2, #1
 8008528:	701a      	strb	r2, [r3, #0]
        ret = true;
 800852a:	2301      	movs	r3, #1
 800852c:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800852e:	e037      	b.n	80085a0 <spiBegin+0x110>

    case _DEF_SPI2:
      p_spi->h_spi = &hspi1;
 8008530:	68bb      	ldr	r3, [r7, #8]
 8008532:	4a23      	ldr	r2, [pc, #140]	@ (80085c0 <spiBegin+0x130>)
 8008534:	609a      	str	r2, [r3, #8]

      hspi1.Instance              = SPI1;
 8008536:	4b22      	ldr	r3, [pc, #136]	@ (80085c0 <spiBegin+0x130>)
 8008538:	4a22      	ldr	r2, [pc, #136]	@ (80085c4 <spiBegin+0x134>)
 800853a:	601a      	str	r2, [r3, #0]
      hspi1.Init.Mode             = SPI_MODE_MASTER;
 800853c:	4b20      	ldr	r3, [pc, #128]	@ (80085c0 <spiBegin+0x130>)
 800853e:	f44f 7282 	mov.w	r2, #260	@ 0x104
 8008542:	605a      	str	r2, [r3, #4]
      hspi1.Init.Direction        = SPI_DIRECTION_2LINES;
 8008544:	4b1e      	ldr	r3, [pc, #120]	@ (80085c0 <spiBegin+0x130>)
 8008546:	2200      	movs	r2, #0
 8008548:	609a      	str	r2, [r3, #8]
      hspi1.Init.DataSize         = SPI_DATASIZE_8BIT;
 800854a:	4b1d      	ldr	r3, [pc, #116]	@ (80085c0 <spiBegin+0x130>)
 800854c:	2200      	movs	r2, #0
 800854e:	60da      	str	r2, [r3, #12]
      hspi1.Init.CLKPolarity      = SPI_POLARITY_LOW;
 8008550:	4b1b      	ldr	r3, [pc, #108]	@ (80085c0 <spiBegin+0x130>)
 8008552:	2200      	movs	r2, #0
 8008554:	611a      	str	r2, [r3, #16]
      hspi1.Init.CLKPhase         = SPI_PHASE_1EDGE;
 8008556:	4b1a      	ldr	r3, [pc, #104]	@ (80085c0 <spiBegin+0x130>)
 8008558:	2200      	movs	r2, #0
 800855a:	615a      	str	r2, [r3, #20]
      hspi1.Init.NSS              = SPI_NSS_SOFT;
 800855c:	4b18      	ldr	r3, [pc, #96]	@ (80085c0 <spiBegin+0x130>)
 800855e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8008562:	619a      	str	r2, [r3, #24]
      hspi1.Init.BaudRatePrescaler= SPI_BAUDRATEPRESCALER_16;
 8008564:	4b16      	ldr	r3, [pc, #88]	@ (80085c0 <spiBegin+0x130>)
 8008566:	2218      	movs	r2, #24
 8008568:	61da      	str	r2, [r3, #28]
      hspi1.Init.FirstBit         = SPI_FIRSTBIT_MSB;
 800856a:	4b15      	ldr	r3, [pc, #84]	@ (80085c0 <spiBegin+0x130>)
 800856c:	2200      	movs	r2, #0
 800856e:	621a      	str	r2, [r3, #32]
      hspi1.Init.TIMode           = SPI_TIMODE_DISABLE;
 8008570:	4b13      	ldr	r3, [pc, #76]	@ (80085c0 <spiBegin+0x130>)
 8008572:	2200      	movs	r2, #0
 8008574:	625a      	str	r2, [r3, #36]	@ 0x24
      hspi1.Init.CRCCalculation   = SPI_CRCCALCULATION_DISABLE;
 8008576:	4b12      	ldr	r3, [pc, #72]	@ (80085c0 <spiBegin+0x130>)
 8008578:	2200      	movs	r2, #0
 800857a:	629a      	str	r2, [r3, #40]	@ 0x28
      hspi1.Init.CRCPolynomial    = 10;
 800857c:	4b10      	ldr	r3, [pc, #64]	@ (80085c0 <spiBegin+0x130>)
 800857e:	220a      	movs	r2, #10
 8008580:	62da      	str	r2, [r3, #44]	@ 0x2c

      HAL_SPI_DeInit(&hspi1);
 8008582:	480f      	ldr	r0, [pc, #60]	@ (80085c0 <spiBegin+0x130>)
 8008584:	f008 ff33 	bl	80113ee <HAL_SPI_DeInit>
      if (HAL_SPI_Init(&hspi1) == HAL_OK)
 8008588:	480d      	ldr	r0, [pc, #52]	@ (80085c0 <spiBegin+0x130>)
 800858a:	f008 fea7 	bl	80112dc <HAL_SPI_Init>
 800858e:	4603      	mov	r3, r0
 8008590:	2b00      	cmp	r3, #0
 8008592:	d107      	bne.n	80085a4 <spiBegin+0x114>
      {
        p_spi->is_open = true;
 8008594:	68bb      	ldr	r3, [r7, #8]
 8008596:	2201      	movs	r2, #1
 8008598:	701a      	strb	r2, [r3, #0]
        ret = true;
 800859a:	2301      	movs	r3, #1
 800859c:	73fb      	strb	r3, [r7, #15]
      }
      break;
 800859e:	e001      	b.n	80085a4 <spiBegin+0x114>
      break;
 80085a0:	bf00      	nop
 80085a2:	e000      	b.n	80085a6 <spiBegin+0x116>
      break;
 80085a4:	bf00      	nop
  }

  return ret;
 80085a6:	7bfb      	ldrb	r3, [r7, #15]
}
 80085a8:	4618      	mov	r0, r3
 80085aa:	3710      	adds	r7, #16
 80085ac:	46bd      	mov	sp, r7
 80085ae:	bd80      	pop	{r7, pc}
 80085b0:	2000a4cc 	.word	0x2000a4cc
 80085b4:	2000a538 	.word	0x2000a538
 80085b8:	2000a590 	.word	0x2000a590
 80085bc:	40013400 	.word	0x40013400
 80085c0:	2000a4e0 	.word	0x2000a4e0
 80085c4:	40013000 	.word	0x40013000

080085c8 <spiTransfer>:

  return ret;
}

bool spiTransfer(uint8_t ch, uint8_t *tx_buf, uint8_t *rx_buf, uint32_t length, uint32_t timeout)
{
 80085c8:	b580      	push	{r7, lr}
 80085ca:	b088      	sub	sp, #32
 80085cc:	af02      	add	r7, sp, #8
 80085ce:	60b9      	str	r1, [r7, #8]
 80085d0:	607a      	str	r2, [r7, #4]
 80085d2:	603b      	str	r3, [r7, #0]
 80085d4:	4603      	mov	r3, r0
 80085d6:	73fb      	strb	r3, [r7, #15]
  bool ret = true;
 80085d8:	2301      	movs	r3, #1
 80085da:	75bb      	strb	r3, [r7, #22]
  HAL_StatusTypeDef status;
  spi_t  *p_spi = &spi_tbl[ch];
 80085dc:	7bfa      	ldrb	r2, [r7, #15]
 80085de:	4613      	mov	r3, r2
 80085e0:	009b      	lsls	r3, r3, #2
 80085e2:	4413      	add	r3, r2
 80085e4:	009b      	lsls	r3, r3, #2
 80085e6:	4a1f      	ldr	r2, [pc, #124]	@ (8008664 <spiTransfer+0x9c>)
 80085e8:	4413      	add	r3, r2
 80085ea:	613b      	str	r3, [r7, #16]

  if (p_spi->is_open == false) return false;
 80085ec:	693b      	ldr	r3, [r7, #16]
 80085ee:	781b      	ldrb	r3, [r3, #0]
 80085f0:	f083 0301 	eor.w	r3, r3, #1
 80085f4:	b2db      	uxtb	r3, r3
 80085f6:	2b00      	cmp	r3, #0
 80085f8:	d001      	beq.n	80085fe <spiTransfer+0x36>
 80085fa:	2300      	movs	r3, #0
 80085fc:	e02e      	b.n	800865c <spiTransfer+0x94>

  if (rx_buf == NULL)
 80085fe:	687b      	ldr	r3, [r7, #4]
 8008600:	2b00      	cmp	r3, #0
 8008602:	d10a      	bne.n	800861a <spiTransfer+0x52>
  {
    status =  HAL_SPI_Transmit(p_spi->h_spi, tx_buf, length, timeout);
 8008604:	693b      	ldr	r3, [r7, #16]
 8008606:	6898      	ldr	r0, [r3, #8]
 8008608:	683b      	ldr	r3, [r7, #0]
 800860a:	b29a      	uxth	r2, r3
 800860c:	6a3b      	ldr	r3, [r7, #32]
 800860e:	68b9      	ldr	r1, [r7, #8]
 8008610:	f008 ff15 	bl	801143e <HAL_SPI_Transmit>
 8008614:	4603      	mov	r3, r0
 8008616:	75fb      	strb	r3, [r7, #23]
 8008618:	e01a      	b.n	8008650 <spiTransfer+0x88>
  }
  else if (tx_buf == NULL)
 800861a:	68bb      	ldr	r3, [r7, #8]
 800861c:	2b00      	cmp	r3, #0
 800861e:	d10a      	bne.n	8008636 <spiTransfer+0x6e>
  {
    status =  HAL_SPI_Receive(p_spi->h_spi, rx_buf, length, timeout);
 8008620:	693b      	ldr	r3, [r7, #16]
 8008622:	6898      	ldr	r0, [r3, #8]
 8008624:	683b      	ldr	r3, [r7, #0]
 8008626:	b29a      	uxth	r2, r3
 8008628:	6a3b      	ldr	r3, [r7, #32]
 800862a:	6879      	ldr	r1, [r7, #4]
 800862c:	f009 f84a 	bl	80116c4 <HAL_SPI_Receive>
 8008630:	4603      	mov	r3, r0
 8008632:	75fb      	strb	r3, [r7, #23]
 8008634:	e00c      	b.n	8008650 <spiTransfer+0x88>
  }
  else
  {
    status =  HAL_SPI_TransmitReceive(p_spi->h_spi, tx_buf, rx_buf, length, timeout);
 8008636:	693b      	ldr	r3, [r7, #16]
 8008638:	6898      	ldr	r0, [r3, #8]
 800863a:	683b      	ldr	r3, [r7, #0]
 800863c:	b29a      	uxth	r2, r3
 800863e:	6a3b      	ldr	r3, [r7, #32]
 8008640:	9300      	str	r3, [sp, #0]
 8008642:	4613      	mov	r3, r2
 8008644:	687a      	ldr	r2, [r7, #4]
 8008646:	68b9      	ldr	r1, [r7, #8]
 8008648:	f009 f954 	bl	80118f4 <HAL_SPI_TransmitReceive>
 800864c:	4603      	mov	r3, r0
 800864e:	75fb      	strb	r3, [r7, #23]
  }

  if (status != HAL_OK)
 8008650:	7dfb      	ldrb	r3, [r7, #23]
 8008652:	2b00      	cmp	r3, #0
 8008654:	d001      	beq.n	800865a <spiTransfer+0x92>
  {
    return false;
 8008656:	2300      	movs	r3, #0
 8008658:	e000      	b.n	800865c <spiTransfer+0x94>
  }

  return ret;
 800865a:	7dbb      	ldrb	r3, [r7, #22]
}
 800865c:	4618      	mov	r0, r3
 800865e:	3718      	adds	r7, #24
 8008660:	46bd      	mov	sp, r7
 8008662:	bd80      	pop	{r7, pc}
 8008664:	2000a4cc 	.word	0x2000a4cc

08008668 <spiAttachTxInterrupt>:

  return p_spi->is_tx_done;
}

void spiAttachTxInterrupt(uint8_t ch, void (*func)())
{
 8008668:	b480      	push	{r7}
 800866a:	b085      	sub	sp, #20
 800866c:	af00      	add	r7, sp, #0
 800866e:	4603      	mov	r3, r0
 8008670:	6039      	str	r1, [r7, #0]
 8008672:	71fb      	strb	r3, [r7, #7]
  spi_t  *p_spi = &spi_tbl[ch];
 8008674:	79fa      	ldrb	r2, [r7, #7]
 8008676:	4613      	mov	r3, r2
 8008678:	009b      	lsls	r3, r3, #2
 800867a:	4413      	add	r3, r2
 800867c:	009b      	lsls	r3, r3, #2
 800867e:	4a0a      	ldr	r2, [pc, #40]	@ (80086a8 <spiAttachTxInterrupt+0x40>)
 8008680:	4413      	add	r3, r2
 8008682:	60fb      	str	r3, [r7, #12]


  if (p_spi->is_open == false)     return;
 8008684:	68fb      	ldr	r3, [r7, #12]
 8008686:	781b      	ldrb	r3, [r3, #0]
 8008688:	f083 0301 	eor.w	r3, r3, #1
 800868c:	b2db      	uxtb	r3, r3
 800868e:	2b00      	cmp	r3, #0
 8008690:	d103      	bne.n	800869a <spiAttachTxInterrupt+0x32>

  p_spi->func_tx = func;
 8008692:	68fb      	ldr	r3, [r7, #12]
 8008694:	683a      	ldr	r2, [r7, #0]
 8008696:	605a      	str	r2, [r3, #4]
 8008698:	e000      	b.n	800869c <spiAttachTxInterrupt+0x34>
  if (p_spi->is_open == false)     return;
 800869a:	bf00      	nop
}
 800869c:	3714      	adds	r7, #20
 800869e:	46bd      	mov	sp, r7
 80086a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086a4:	4770      	bx	lr
 80086a6:	bf00      	nop
 80086a8:	2000a4cc 	.word	0x2000a4cc

080086ac <HAL_SPI_ErrorCallback>:



void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
 80086ac:	b480      	push	{r7}
 80086ae:	b083      	sub	sp, #12
 80086b0:	af00      	add	r7, sp, #0
 80086b2:	6078      	str	r0, [r7, #4]
  if (hspi->Instance == spi_tbl[_DEF_SPI1].h_spi->Instance)
 80086b4:	687b      	ldr	r3, [r7, #4]
 80086b6:	681a      	ldr	r2, [r3, #0]
 80086b8:	4b06      	ldr	r3, [pc, #24]	@ (80086d4 <HAL_SPI_ErrorCallback+0x28>)
 80086ba:	689b      	ldr	r3, [r3, #8]
 80086bc:	681b      	ldr	r3, [r3, #0]
 80086be:	429a      	cmp	r2, r3
 80086c0:	d102      	bne.n	80086c8 <HAL_SPI_ErrorCallback+0x1c>
  {
    spi_tbl[_DEF_SPI1].is_error = true;
 80086c2:	4b04      	ldr	r3, [pc, #16]	@ (80086d4 <HAL_SPI_ErrorCallback+0x28>)
 80086c4:	2201      	movs	r2, #1
 80086c6:	709a      	strb	r2, [r3, #2]
  }
}
 80086c8:	bf00      	nop
 80086ca:	370c      	adds	r7, #12
 80086cc:	46bd      	mov	sp, r7
 80086ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80086d2:	4770      	bx	lr
 80086d4:	2000a4cc 	.word	0x2000a4cc

080086d8 <HAL_SPI_MspInit>:
    }
  }
}

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 80086d8:	b580      	push	{r7, lr}
 80086da:	b08e      	sub	sp, #56	@ 0x38
 80086dc:	af00      	add	r7, sp, #0
 80086de:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80086e0:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80086e4:	2200      	movs	r2, #0
 80086e6:	601a      	str	r2, [r3, #0]
 80086e8:	605a      	str	r2, [r3, #4]
 80086ea:	609a      	str	r2, [r3, #8]
 80086ec:	60da      	str	r2, [r3, #12]
 80086ee:	611a      	str	r2, [r3, #16]
  if(spiHandle->Instance==SPI1)
 80086f0:	687b      	ldr	r3, [r7, #4]
 80086f2:	681b      	ldr	r3, [r3, #0]
 80086f4:	4a7c      	ldr	r2, [pc, #496]	@ (80088e8 <HAL_SPI_MspInit+0x210>)
 80086f6:	4293      	cmp	r3, r2
 80086f8:	d152      	bne.n	80087a0 <HAL_SPI_MspInit+0xc8>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */
  /* USER CODE END SPI1_MspInit 0 */
    /* SPI1 clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 80086fa:	2300      	movs	r3, #0
 80086fc:	623b      	str	r3, [r7, #32]
 80086fe:	4b7b      	ldr	r3, [pc, #492]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008700:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8008702:	4a7a      	ldr	r2, [pc, #488]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008704:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8008708:	6453      	str	r3, [r2, #68]	@ 0x44
 800870a:	4b78      	ldr	r3, [pc, #480]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 800870c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800870e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8008712:	623b      	str	r3, [r7, #32]
 8008714:	6a3b      	ldr	r3, [r7, #32]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008716:	2300      	movs	r3, #0
 8008718:	61fb      	str	r3, [r7, #28]
 800871a:	4b74      	ldr	r3, [pc, #464]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 800871c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800871e:	4a73      	ldr	r2, [pc, #460]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008720:	f043 0301 	orr.w	r3, r3, #1
 8008724:	6313      	str	r3, [r2, #48]	@ 0x30
 8008726:	4b71      	ldr	r3, [pc, #452]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008728:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800872a:	f003 0301 	and.w	r3, r3, #1
 800872e:	61fb      	str	r3, [r7, #28]
 8008730:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008732:	2300      	movs	r3, #0
 8008734:	61bb      	str	r3, [r7, #24]
 8008736:	4b6d      	ldr	r3, [pc, #436]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008738:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800873a:	4a6c      	ldr	r2, [pc, #432]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 800873c:	f043 0302 	orr.w	r3, r3, #2
 8008740:	6313      	str	r3, [r2, #48]	@ 0x30
 8008742:	4b6a      	ldr	r3, [pc, #424]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008744:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8008746:	f003 0302 	and.w	r3, r3, #2
 800874a:	61bb      	str	r3, [r7, #24]
 800874c:	69bb      	ldr	r3, [r7, #24]
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA7     ------> SPI1_MOSI
    PB4     ------> SPI1_MISO
    */
    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_7;
 800874e:	23a0      	movs	r3, #160	@ 0xa0
 8008750:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008752:	2302      	movs	r3, #2
 8008754:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008756:	2300      	movs	r3, #0
 8008758:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800875a:	2303      	movs	r3, #3
 800875c:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 800875e:	2305      	movs	r3, #5
 8008760:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008762:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8008766:	4619      	mov	r1, r3
 8008768:	4861      	ldr	r0, [pc, #388]	@ (80088f0 <HAL_SPI_MspInit+0x218>)
 800876a:	f001 fb61 	bl	8009e30 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_4;
 800876e:	2310      	movs	r3, #16
 8008770:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008772:	2302      	movs	r3, #2
 8008774:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008776:	2300      	movs	r3, #0
 8008778:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800877a:	2303      	movs	r3, #3
 800877c:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 800877e:	2305      	movs	r3, #5
 8008780:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008782:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8008786:	4619      	mov	r1, r3
 8008788:	485a      	ldr	r0, [pc, #360]	@ (80088f4 <HAL_SPI_MspInit+0x21c>)
 800878a:	f001 fb51 	bl	8009e30 <HAL_GPIO_Init>

    /* SPI1 interrupt Init */
    HAL_NVIC_SetPriority(SPI1_IRQn, 5, 0);
 800878e:	2200      	movs	r2, #0
 8008790:	2105      	movs	r1, #5
 8008792:	2023      	movs	r0, #35	@ 0x23
 8008794:	f000 fba5 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI1_IRQn);
 8008798:	2023      	movs	r0, #35	@ 0x23
 800879a:	f000 fbbe 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SPI4_MspInit 1 */
    HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
  /* USER CODE END SPI4_MspInit 1 */
  }
}
 800879e:	e09e      	b.n	80088de <HAL_SPI_MspInit+0x206>
  else if(spiHandle->Instance==SPI4)
 80087a0:	687b      	ldr	r3, [r7, #4]
 80087a2:	681b      	ldr	r3, [r3, #0]
 80087a4:	4a54      	ldr	r2, [pc, #336]	@ (80088f8 <HAL_SPI_MspInit+0x220>)
 80087a6:	4293      	cmp	r3, r2
 80087a8:	f040 8099 	bne.w	80088de <HAL_SPI_MspInit+0x206>
    __HAL_RCC_DMA2_CLK_ENABLE();
 80087ac:	2300      	movs	r3, #0
 80087ae:	617b      	str	r3, [r7, #20]
 80087b0:	4b4e      	ldr	r3, [pc, #312]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087b2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80087b4:	4a4d      	ldr	r2, [pc, #308]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087b6:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 80087ba:	6313      	str	r3, [r2, #48]	@ 0x30
 80087bc:	4b4b      	ldr	r3, [pc, #300]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087be:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80087c0:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 80087c4:	617b      	str	r3, [r7, #20]
 80087c6:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_SPI4_CLK_ENABLE();
 80087c8:	2300      	movs	r3, #0
 80087ca:	613b      	str	r3, [r7, #16]
 80087cc:	4b47      	ldr	r3, [pc, #284]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087ce:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80087d0:	4a46      	ldr	r2, [pc, #280]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087d2:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 80087d6:	6453      	str	r3, [r2, #68]	@ 0x44
 80087d8:	4b44      	ldr	r3, [pc, #272]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087da:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80087dc:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80087e0:	613b      	str	r3, [r7, #16]
 80087e2:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80087e4:	2300      	movs	r3, #0
 80087e6:	60fb      	str	r3, [r7, #12]
 80087e8:	4b40      	ldr	r3, [pc, #256]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087ea:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80087ec:	4a3f      	ldr	r2, [pc, #252]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087ee:	f043 0301 	orr.w	r3, r3, #1
 80087f2:	6313      	str	r3, [r2, #48]	@ 0x30
 80087f4:	4b3d      	ldr	r3, [pc, #244]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 80087f6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80087f8:	f003 0301 	and.w	r3, r3, #1
 80087fc:	60fb      	str	r3, [r7, #12]
 80087fe:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8008800:	2300      	movs	r3, #0
 8008802:	60bb      	str	r3, [r7, #8]
 8008804:	4b39      	ldr	r3, [pc, #228]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008806:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8008808:	4a38      	ldr	r2, [pc, #224]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 800880a:	f043 0302 	orr.w	r3, r3, #2
 800880e:	6313      	str	r3, [r2, #48]	@ 0x30
 8008810:	4b36      	ldr	r3, [pc, #216]	@ (80088ec <HAL_SPI_MspInit+0x214>)
 8008812:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8008814:	f003 0302 	and.w	r3, r3, #2
 8008818:	60bb      	str	r3, [r7, #8]
 800881a:	68bb      	ldr	r3, [r7, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_1;
 800881c:	2302      	movs	r3, #2
 800881e:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008820:	2302      	movs	r3, #2
 8008822:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008824:	2300      	movs	r3, #0
 8008826:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8008828:	2303      	movs	r3, #3
 800882a:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
 800882c:	2305      	movs	r3, #5
 800882e:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008830:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8008834:	4619      	mov	r1, r3
 8008836:	482e      	ldr	r0, [pc, #184]	@ (80088f0 <HAL_SPI_MspInit+0x218>)
 8008838:	f001 fafa 	bl	8009e30 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_13;
 800883c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8008840:	627b      	str	r3, [r7, #36]	@ 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008842:	2302      	movs	r3, #2
 8008844:	62bb      	str	r3, [r7, #40]	@ 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008846:	2300      	movs	r3, #0
 8008848:	62fb      	str	r3, [r7, #44]	@ 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800884a:	2303      	movs	r3, #3
 800884c:	633b      	str	r3, [r7, #48]	@ 0x30
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI4;
 800884e:	2306      	movs	r3, #6
 8008850:	637b      	str	r3, [r7, #52]	@ 0x34
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008852:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8008856:	4619      	mov	r1, r3
 8008858:	4826      	ldr	r0, [pc, #152]	@ (80088f4 <HAL_SPI_MspInit+0x21c>)
 800885a:	f001 fae9 	bl	8009e30 <HAL_GPIO_Init>
    hdma_spi4_tx.Instance = DMA2_Stream1;
 800885e:	4b27      	ldr	r3, [pc, #156]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 8008860:	4a27      	ldr	r2, [pc, #156]	@ (8008900 <HAL_SPI_MspInit+0x228>)
 8008862:	601a      	str	r2, [r3, #0]
    hdma_spi4_tx.Init.Channel = DMA_CHANNEL_4;
 8008864:	4b25      	ldr	r3, [pc, #148]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 8008866:	f04f 6200 	mov.w	r2, #134217728	@ 0x8000000
 800886a:	605a      	str	r2, [r3, #4]
    hdma_spi4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800886c:	4b23      	ldr	r3, [pc, #140]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 800886e:	2240      	movs	r2, #64	@ 0x40
 8008870:	609a      	str	r2, [r3, #8]
    hdma_spi4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8008872:	4b22      	ldr	r3, [pc, #136]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 8008874:	2200      	movs	r2, #0
 8008876:	60da      	str	r2, [r3, #12]
    hdma_spi4_tx.Init.MemInc = DMA_MINC_ENABLE;
 8008878:	4b20      	ldr	r3, [pc, #128]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 800887a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 800887e:	611a      	str	r2, [r3, #16]
    hdma_spi4_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 8008880:	4b1e      	ldr	r3, [pc, #120]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 8008882:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8008886:	615a      	str	r2, [r3, #20]
    hdma_spi4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8008888:	4b1c      	ldr	r3, [pc, #112]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 800888a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800888e:	619a      	str	r2, [r3, #24]
    hdma_spi4_tx.Init.Mode = DMA_NORMAL;
 8008890:	4b1a      	ldr	r3, [pc, #104]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 8008892:	2200      	movs	r2, #0
 8008894:	61da      	str	r2, [r3, #28]
    hdma_spi4_tx.Init.Priority = DMA_PRIORITY_LOW;
 8008896:	4b19      	ldr	r3, [pc, #100]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 8008898:	2200      	movs	r2, #0
 800889a:	621a      	str	r2, [r3, #32]
    hdma_spi4_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800889c:	4b17      	ldr	r3, [pc, #92]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 800889e:	2200      	movs	r2, #0
 80088a0:	625a      	str	r2, [r3, #36]	@ 0x24
    if (HAL_DMA_Init(&hdma_spi4_tx) != HAL_OK)
 80088a2:	4816      	ldr	r0, [pc, #88]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 80088a4:	f000 fb62 	bl	8008f6c <HAL_DMA_Init>
 80088a8:	4603      	mov	r3, r0
 80088aa:	2b00      	cmp	r3, #0
 80088ac:	d001      	beq.n	80088b2 <HAL_SPI_MspInit+0x1da>
      Error_Handler();
 80088ae:	f7f8 ff19 	bl	80016e4 <Error_Handler>
    __HAL_LINKDMA(spiHandle,hdmatx,hdma_spi4_tx);
 80088b2:	687b      	ldr	r3, [r7, #4]
 80088b4:	4a11      	ldr	r2, [pc, #68]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 80088b6:	649a      	str	r2, [r3, #72]	@ 0x48
 80088b8:	4a10      	ldr	r2, [pc, #64]	@ (80088fc <HAL_SPI_MspInit+0x224>)
 80088ba:	687b      	ldr	r3, [r7, #4]
 80088bc:	6393      	str	r3, [r2, #56]	@ 0x38
    HAL_NVIC_SetPriority(SPI4_IRQn, 5, 0);
 80088be:	2200      	movs	r2, #0
 80088c0:	2105      	movs	r1, #5
 80088c2:	2054      	movs	r0, #84	@ 0x54
 80088c4:	f000 fb0d 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI4_IRQn);
 80088c8:	2054      	movs	r0, #84	@ 0x54
 80088ca:	f000 fb26 	bl	8008f1a <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
 80088ce:	2200      	movs	r2, #0
 80088d0:	2105      	movs	r1, #5
 80088d2:	2039      	movs	r0, #57	@ 0x39
 80088d4:	f000 fb05 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
 80088d8:	2039      	movs	r0, #57	@ 0x39
 80088da:	f000 fb1e 	bl	8008f1a <HAL_NVIC_EnableIRQ>
}
 80088de:	bf00      	nop
 80088e0:	3738      	adds	r7, #56	@ 0x38
 80088e2:	46bd      	mov	sp, r7
 80088e4:	bd80      	pop	{r7, pc}
 80088e6:	bf00      	nop
 80088e8:	40013000 	.word	0x40013000
 80088ec:	40023800 	.word	0x40023800
 80088f0:	40020000 	.word	0x40020000
 80088f4:	40020400 	.word	0x40020400
 80088f8:	40013400 	.word	0x40013400
 80088fc:	2000a590 	.word	0x2000a590
 8008900:	40026428 	.word	0x40026428

08008904 <HAL_SPI_MspDeInit>:

void HAL_SPI_MspDeInit(SPI_HandleTypeDef* spiHandle)
{
 8008904:	b580      	push	{r7, lr}
 8008906:	b082      	sub	sp, #8
 8008908:	af00      	add	r7, sp, #0
 800890a:	6078      	str	r0, [r7, #4]

  if(spiHandle->Instance==SPI1)
 800890c:	687b      	ldr	r3, [r7, #4]
 800890e:	681b      	ldr	r3, [r3, #0]
 8008910:	4a1a      	ldr	r2, [pc, #104]	@ (800897c <HAL_SPI_MspDeInit+0x78>)
 8008912:	4293      	cmp	r3, r2
 8008914:	d111      	bne.n	800893a <HAL_SPI_MspDeInit+0x36>
  {
  /* USER CODE BEGIN SPI1_MspDeInit 0 */

  /* USER CODE END SPI1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI1_CLK_DISABLE();
 8008916:	4b1a      	ldr	r3, [pc, #104]	@ (8008980 <HAL_SPI_MspDeInit+0x7c>)
 8008918:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800891a:	4a19      	ldr	r2, [pc, #100]	@ (8008980 <HAL_SPI_MspDeInit+0x7c>)
 800891c:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8008920:	6453      	str	r3, [r2, #68]	@ 0x44
    /**SPI1 GPIO Configuration
    PA5     ------> SPI1_SCK
    PA7     ------> SPI1_MOSI
    PB4     ------> SPI1_MISO
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_5|GPIO_PIN_7);
 8008922:	21a0      	movs	r1, #160	@ 0xa0
 8008924:	4817      	ldr	r0, [pc, #92]	@ (8008984 <HAL_SPI_MspDeInit+0x80>)
 8008926:	f001 fc07 	bl	800a138 <HAL_GPIO_DeInit>

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_4);
 800892a:	2110      	movs	r1, #16
 800892c:	4816      	ldr	r0, [pc, #88]	@ (8008988 <HAL_SPI_MspDeInit+0x84>)
 800892e:	f001 fc03 	bl	800a138 <HAL_GPIO_DeInit>

    /* SPI1 interrupt Deinit */
    HAL_NVIC_DisableIRQ(SPI1_IRQn);
 8008932:	2023      	movs	r0, #35	@ 0x23
 8008934:	f000 faff 	bl	8008f36 <HAL_NVIC_DisableIRQ>
    HAL_NVIC_DisableIRQ(SPI4_IRQn);
  /* USER CODE BEGIN SPI4_MspDeInit 1 */

  /* USER CODE END SPI4_MspDeInit 1 */
  }
}
 8008938:	e01b      	b.n	8008972 <HAL_SPI_MspDeInit+0x6e>
  else if(spiHandle->Instance==SPI4)
 800893a:	687b      	ldr	r3, [r7, #4]
 800893c:	681b      	ldr	r3, [r3, #0]
 800893e:	4a13      	ldr	r2, [pc, #76]	@ (800898c <HAL_SPI_MspDeInit+0x88>)
 8008940:	4293      	cmp	r3, r2
 8008942:	d116      	bne.n	8008972 <HAL_SPI_MspDeInit+0x6e>
    __HAL_RCC_SPI4_CLK_DISABLE();
 8008944:	4b0e      	ldr	r3, [pc, #56]	@ (8008980 <HAL_SPI_MspDeInit+0x7c>)
 8008946:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8008948:	4a0d      	ldr	r2, [pc, #52]	@ (8008980 <HAL_SPI_MspDeInit+0x7c>)
 800894a:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 800894e:	6453      	str	r3, [r2, #68]	@ 0x44
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_1);
 8008950:	2102      	movs	r1, #2
 8008952:	480c      	ldr	r0, [pc, #48]	@ (8008984 <HAL_SPI_MspDeInit+0x80>)
 8008954:	f001 fbf0 	bl	800a138 <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_13);
 8008958:	f44f 5100 	mov.w	r1, #8192	@ 0x2000
 800895c:	480a      	ldr	r0, [pc, #40]	@ (8008988 <HAL_SPI_MspDeInit+0x84>)
 800895e:	f001 fbeb 	bl	800a138 <HAL_GPIO_DeInit>
    HAL_DMA_DeInit(spiHandle->hdmatx);
 8008962:	687b      	ldr	r3, [r7, #4]
 8008964:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8008966:	4618      	mov	r0, r3
 8008968:	f000 fbae 	bl	80090c8 <HAL_DMA_DeInit>
    HAL_NVIC_DisableIRQ(SPI4_IRQn);
 800896c:	2054      	movs	r0, #84	@ 0x54
 800896e:	f000 fae2 	bl	8008f36 <HAL_NVIC_DisableIRQ>
}
 8008972:	bf00      	nop
 8008974:	3708      	adds	r7, #8
 8008976:	46bd      	mov	sp, r7
 8008978:	bd80      	pop	{r7, pc}
 800897a:	bf00      	nop
 800897c:	40013000 	.word	0x40013000
 8008980:	40023800 	.word	0x40023800
 8008984:	40020000 	.word	0x40020000
 8008988:	40020400 	.word	0x40020400
 800898c:	40013400 	.word	0x40013400

08008990 <uartInit>:
DMA_HandleTypeDef  hdma_usart1_rx;

#endif

bool uartInit(void)
{
 8008990:	b480      	push	{r7}
 8008992:	af00      	add	r7, sp, #0
	return true;
 8008994:	2301      	movs	r3, #1
}
 8008996:	4618      	mov	r0, r3
 8008998:	46bd      	mov	sp, r7
 800899a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800899e:	4770      	bx	lr

080089a0 <uartOpen>:

bool uartOpen(uint8_t ch, uint32_t baud)
{
 80089a0:	b580      	push	{r7, lr}
 80089a2:	b084      	sub	sp, #16
 80089a4:	af00      	add	r7, sp, #0
 80089a6:	4603      	mov	r3, r0
 80089a8:	6039      	str	r1, [r7, #0]
 80089aa:	71fb      	strb	r3, [r7, #7]
	bool ret = false;
 80089ac:	2300      	movs	r3, #0
 80089ae:	73fb      	strb	r3, [r7, #15]

	switch(ch)
 80089b0:	79fb      	ldrb	r3, [r7, #7]
 80089b2:	2b00      	cmp	r3, #0
 80089b4:	d002      	beq.n	80089bc <uartOpen+0x1c>
 80089b6:	2b01      	cmp	r3, #1
 80089b8:	d007      	beq.n	80089ca <uartOpen+0x2a>
 80089ba:	e03c      	b.n	8008a36 <uartOpen+0x96>
	{
		case _DEF_UART1:
			is_open[ch] = true;
 80089bc:	79fb      	ldrb	r3, [r7, #7]
 80089be:	4a20      	ldr	r2, [pc, #128]	@ (8008a40 <uartOpen+0xa0>)
 80089c0:	2101      	movs	r1, #1
 80089c2:	54d1      	strb	r1, [r2, r3]
			ret = true;
 80089c4:	2301      	movs	r3, #1
 80089c6:	73fb      	strb	r3, [r7, #15]
			break;
 80089c8:	e035      	b.n	8008a36 <uartOpen+0x96>

		case _DEF_UART2:
			#ifdef _USE_UART2
			ret = true;
 80089ca:	2301      	movs	r3, #1
 80089cc:	73fb      	strb	r3, [r7, #15]
			is_open[ch] = true;
 80089ce:	79fb      	ldrb	r3, [r7, #7]
 80089d0:	4a1b      	ldr	r2, [pc, #108]	@ (8008a40 <uartOpen+0xa0>)
 80089d2:	2101      	movs	r1, #1
 80089d4:	54d1      	strb	r1, [r2, r3]

			qbufferCreate(&qbuffer[ch], &rx_buf[0], 256);
 80089d6:	79fb      	ldrb	r3, [r7, #7]
 80089d8:	011b      	lsls	r3, r3, #4
 80089da:	4a1a      	ldr	r2, [pc, #104]	@ (8008a44 <uartOpen+0xa4>)
 80089dc:	4413      	add	r3, r2
 80089de:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80089e2:	4919      	ldr	r1, [pc, #100]	@ (8008a48 <uartOpen+0xa8>)
 80089e4:	4618      	mov	r0, r3
 80089e6:	f7f9 f85a 	bl	8001a9e <qbufferCreate>

			if(HAL_UART_Receive_DMA(&huart1, (uint8_t *)&rx_buf[0], 256) != HAL_OK)
 80089ea:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80089ee:	4916      	ldr	r1, [pc, #88]	@ (8008a48 <uartOpen+0xa8>)
 80089f0:	4816      	ldr	r0, [pc, #88]	@ (8008a4c <uartOpen+0xac>)
 80089f2:	f009 fc04 	bl	80121fe <HAL_UART_Receive_DMA>
 80089f6:	4603      	mov	r3, r0
 80089f8:	2b00      	cmp	r3, #0
 80089fa:	d001      	beq.n	8008a00 <uartOpen+0x60>
				{
					 ret = false;
 80089fc:	2300      	movs	r3, #0
 80089fe:	73fb      	strb	r3, [r7, #15]
			  }

			qbuffer[ch].in = qbuffer[ch].len - hdma_usart1_rx.Instance->NDTR;
 8008a00:	79fb      	ldrb	r3, [r7, #7]
 8008a02:	4a10      	ldr	r2, [pc, #64]	@ (8008a44 <uartOpen+0xa4>)
 8008a04:	011b      	lsls	r3, r3, #4
 8008a06:	4413      	add	r3, r2
 8008a08:	3308      	adds	r3, #8
 8008a0a:	6819      	ldr	r1, [r3, #0]
 8008a0c:	4b10      	ldr	r3, [pc, #64]	@ (8008a50 <uartOpen+0xb0>)
 8008a0e:	681b      	ldr	r3, [r3, #0]
 8008a10:	685a      	ldr	r2, [r3, #4]
 8008a12:	79fb      	ldrb	r3, [r7, #7]
 8008a14:	1a8a      	subs	r2, r1, r2
 8008a16:	490b      	ldr	r1, [pc, #44]	@ (8008a44 <uartOpen+0xa4>)
 8008a18:	011b      	lsls	r3, r3, #4
 8008a1a:	440b      	add	r3, r1
 8008a1c:	601a      	str	r2, [r3, #0]
			qbuffer[ch].out = qbuffer[ch].in;
 8008a1e:	79fa      	ldrb	r2, [r7, #7]
 8008a20:	79fb      	ldrb	r3, [r7, #7]
 8008a22:	4908      	ldr	r1, [pc, #32]	@ (8008a44 <uartOpen+0xa4>)
 8008a24:	0112      	lsls	r2, r2, #4
 8008a26:	440a      	add	r2, r1
 8008a28:	6812      	ldr	r2, [r2, #0]
 8008a2a:	4906      	ldr	r1, [pc, #24]	@ (8008a44 <uartOpen+0xa4>)
 8008a2c:	011b      	lsls	r3, r3, #4
 8008a2e:	440b      	add	r3, r1
 8008a30:	3304      	adds	r3, #4
 8008a32:	601a      	str	r2, [r3, #0]
			break;
 8008a34:	bf00      	nop
			#endif
	}

	return ret;
 8008a36:	7bfb      	ldrb	r3, [r7, #15]
}
 8008a38:	4618      	mov	r0, r3
 8008a3a:	3710      	adds	r7, #16
 8008a3c:	46bd      	mov	sp, r7
 8008a3e:	bd80      	pop	{r7, pc}
 8008a40:	2000a5f0 	.word	0x2000a5f0
 8008a44:	2000a5f4 	.word	0x2000a5f4
 8008a48:	2000a614 	.word	0x2000a614
 8008a4c:	2000a714 	.word	0x2000a714
 8008a50:	2000a75c 	.word	0x2000a75c

08008a54 <uartAvailable>:

uint32_t uartAvailable(uint8_t ch)
{
 8008a54:	b580      	push	{r7, lr}
 8008a56:	b084      	sub	sp, #16
 8008a58:	af00      	add	r7, sp, #0
 8008a5a:	4603      	mov	r3, r0
 8008a5c:	71fb      	strb	r3, [r7, #7]
	uint32_t ret;

	switch(ch)
 8008a5e:	79fb      	ldrb	r3, [r7, #7]
 8008a60:	2b00      	cmp	r3, #0
 8008a62:	d002      	beq.n	8008a6a <uartAvailable+0x16>
 8008a64:	2b01      	cmp	r3, #1
 8008a66:	d004      	beq.n	8008a72 <uartAvailable+0x1e>
 8008a68:	e01b      	b.n	8008aa2 <uartAvailable+0x4e>
	{
		case _DEF_UART1:
			ret = cdcAvailable();
 8008a6a:	f7f9 fe55 	bl	8002718 <cdcAvailable>
 8008a6e:	60f8      	str	r0, [r7, #12]
			break;
 8008a70:	e017      	b.n	8008aa2 <uartAvailable+0x4e>

		case _DEF_UART2:
			#ifdef _USE_UART2
			qbuffer[ch].in = (qbuffer[ch].len - hdma_usart1_rx.Instance->NDTR);
 8008a72:	79fb      	ldrb	r3, [r7, #7]
 8008a74:	4a0d      	ldr	r2, [pc, #52]	@ (8008aac <uartAvailable+0x58>)
 8008a76:	011b      	lsls	r3, r3, #4
 8008a78:	4413      	add	r3, r2
 8008a7a:	3308      	adds	r3, #8
 8008a7c:	6819      	ldr	r1, [r3, #0]
 8008a7e:	4b0c      	ldr	r3, [pc, #48]	@ (8008ab0 <uartAvailable+0x5c>)
 8008a80:	681b      	ldr	r3, [r3, #0]
 8008a82:	685a      	ldr	r2, [r3, #4]
 8008a84:	79fb      	ldrb	r3, [r7, #7]
 8008a86:	1a8a      	subs	r2, r1, r2
 8008a88:	4908      	ldr	r1, [pc, #32]	@ (8008aac <uartAvailable+0x58>)
 8008a8a:	011b      	lsls	r3, r3, #4
 8008a8c:	440b      	add	r3, r1
 8008a8e:	601a      	str	r2, [r3, #0]
			ret = qbufferAvailable(&qbuffer[ch]);
 8008a90:	79fb      	ldrb	r3, [r7, #7]
 8008a92:	011b      	lsls	r3, r3, #4
 8008a94:	4a05      	ldr	r2, [pc, #20]	@ (8008aac <uartAvailable+0x58>)
 8008a96:	4413      	add	r3, r2
 8008a98:	4618      	mov	r0, r3
 8008a9a:	f7f9 f858 	bl	8001b4e <qbufferAvailable>
 8008a9e:	60f8      	str	r0, [r7, #12]
			#endif
			break;
 8008aa0:	bf00      	nop
	}

	return ret;
 8008aa2:	68fb      	ldr	r3, [r7, #12]
}
 8008aa4:	4618      	mov	r0, r3
 8008aa6:	3710      	adds	r7, #16
 8008aa8:	46bd      	mov	sp, r7
 8008aaa:	bd80      	pop	{r7, pc}
 8008aac:	2000a5f4 	.word	0x2000a5f4
 8008ab0:	2000a75c 	.word	0x2000a75c

08008ab4 <uartRead>:

uint8_t uartRead(uint8_t ch)
{
 8008ab4:	b580      	push	{r7, lr}
 8008ab6:	b084      	sub	sp, #16
 8008ab8:	af00      	add	r7, sp, #0
 8008aba:	4603      	mov	r3, r0
 8008abc:	71fb      	strb	r3, [r7, #7]
	uint8_t ret;

	switch(ch)
 8008abe:	79fb      	ldrb	r3, [r7, #7]
 8008ac0:	2b00      	cmp	r3, #0
 8008ac2:	d002      	beq.n	8008aca <uartRead+0x16>
 8008ac4:	2b01      	cmp	r3, #1
 8008ac6:	d005      	beq.n	8008ad4 <uartRead+0x20>
 8008ac8:	e00c      	b.n	8008ae4 <uartRead+0x30>
	{
		case _DEF_UART1:
			ret = cdcRead();
 8008aca:	f7f9 fe3b 	bl	8002744 <cdcRead>
 8008ace:	4603      	mov	r3, r0
 8008ad0:	73fb      	strb	r3, [r7, #15]
			break;
 8008ad2:	e007      	b.n	8008ae4 <uartRead+0x30>

		case _DEF_UART2:
			#ifdef _USE_UART2
			qbufferRead(&qbuffer[_DEF_UART2], &ret, 1);
 8008ad4:	f107 030f 	add.w	r3, r7, #15
 8008ad8:	2201      	movs	r2, #1
 8008ada:	4619      	mov	r1, r3
 8008adc:	4804      	ldr	r0, [pc, #16]	@ (8008af0 <uartRead+0x3c>)
 8008ade:	f7f8 fff9 	bl	8001ad4 <qbufferRead>
			#endif
			break;
 8008ae2:	bf00      	nop
	}

	return ret;
 8008ae4:	7bfb      	ldrb	r3, [r7, #15]
}
 8008ae6:	4618      	mov	r0, r3
 8008ae8:	3710      	adds	r7, #16
 8008aea:	46bd      	mov	sp, r7
 8008aec:	bd80      	pop	{r7, pc}
 8008aee:	bf00      	nop
 8008af0:	2000a604 	.word	0x2000a604

08008af4 <uartWrite>:

uint32_t uartWrite(uint8_t ch, uint8_t *p_data, uint32_t length)
{
 8008af4:	b580      	push	{r7, lr}
 8008af6:	b086      	sub	sp, #24
 8008af8:	af00      	add	r7, sp, #0
 8008afa:	4603      	mov	r3, r0
 8008afc:	60b9      	str	r1, [r7, #8]
 8008afe:	607a      	str	r2, [r7, #4]
 8008b00:	73fb      	strb	r3, [r7, #15]

	#ifdef _USE_UART2
	HAL_StatusTypeDef status;
	#endif

	switch(ch)
 8008b02:	7bfb      	ldrb	r3, [r7, #15]
 8008b04:	2b00      	cmp	r3, #0
 8008b06:	d002      	beq.n	8008b0e <uartWrite+0x1a>
 8008b08:	2b01      	cmp	r3, #1
 8008b0a:	d006      	beq.n	8008b1a <uartWrite+0x26>
 8008b0c:	e014      	b.n	8008b38 <uartWrite+0x44>
	{
		case _DEF_UART1:
			ret = cdcWrite(p_data, length);
 8008b0e:	6879      	ldr	r1, [r7, #4]
 8008b10:	68b8      	ldr	r0, [r7, #8]
 8008b12:	f7f9 fe5f 	bl	80027d4 <cdcWrite>
 8008b16:	6178      	str	r0, [r7, #20]
			break;
 8008b18:	e00e      	b.n	8008b38 <uartWrite+0x44>

		case _DEF_UART2:
			#ifdef _USE_UART2
			status = HAL_UART_Transmit(&huart1, p_data, length, 100);
 8008b1a:	687b      	ldr	r3, [r7, #4]
 8008b1c:	b29a      	uxth	r2, r3
 8008b1e:	2364      	movs	r3, #100	@ 0x64
 8008b20:	68b9      	ldr	r1, [r7, #8]
 8008b22:	4808      	ldr	r0, [pc, #32]	@ (8008b44 <uartWrite+0x50>)
 8008b24:	f009 fae0 	bl	80120e8 <HAL_UART_Transmit>
 8008b28:	4603      	mov	r3, r0
 8008b2a:	74fb      	strb	r3, [r7, #19]
			if(status == HAL_OK)
 8008b2c:	7cfb      	ldrb	r3, [r7, #19]
 8008b2e:	2b00      	cmp	r3, #0
 8008b30:	d101      	bne.n	8008b36 <uartWrite+0x42>
			{
				ret = length;
 8008b32:	687b      	ldr	r3, [r7, #4]
 8008b34:	617b      	str	r3, [r7, #20]
			}
			#endif
			break;
 8008b36:	bf00      	nop
	}

	return ret;
 8008b38:	697b      	ldr	r3, [r7, #20]
}
 8008b3a:	4618      	mov	r0, r3
 8008b3c:	3718      	adds	r7, #24
 8008b3e:	46bd      	mov	sp, r7
 8008b40:	bd80      	pop	{r7, pc}
 8008b42:	bf00      	nop
 8008b44:	2000a714 	.word	0x2000a714

08008b48 <uartPrintf>:

uint32_t uartPrintf(uint8_t ch, char *fmt, ...)
{
 8008b48:	b40e      	push	{r1, r2, r3}
 8008b4a:	b580      	push	{r7, lr}
 8008b4c:	b0c7      	sub	sp, #284	@ 0x11c
 8008b4e:	af00      	add	r7, sp, #0
 8008b50:	4602      	mov	r2, r0
 8008b52:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 8008b56:	f2a3 1311 	subw	r3, r3, #273	@ 0x111
 8008b5a:	701a      	strb	r2, [r3, #0]
	char buf[256];
	va_list args;
	int len;
	uint32_t ret;

	va_start(args, fmt);
 8008b5c:	f507 7294 	add.w	r2, r7, #296	@ 0x128
 8008b60:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 8008b64:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8008b68:	601a      	str	r2, [r3, #0]
	len = vsnprintf(buf, 256, fmt, args);
 8008b6a:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 8008b6e:	f5a3 7386 	sub.w	r3, r3, #268	@ 0x10c
 8008b72:	f107 0010 	add.w	r0, r7, #16
 8008b76:	681b      	ldr	r3, [r3, #0]
 8008b78:	f8d7 2124 	ldr.w	r2, [r7, #292]	@ 0x124
 8008b7c:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8008b80:	f019 fa04 	bl	8021f8c <vsniprintf>
 8008b84:	f8c7 0114 	str.w	r0, [r7, #276]	@ 0x114

	ret = uartWrite(ch, (uint8_t *)buf, len);
 8008b88:	f8d7 2114 	ldr.w	r2, [r7, #276]	@ 0x114
 8008b8c:	f107 0110 	add.w	r1, r7, #16
 8008b90:	f507 738c 	add.w	r3, r7, #280	@ 0x118
 8008b94:	f2a3 1311 	subw	r3, r3, #273	@ 0x111
 8008b98:	781b      	ldrb	r3, [r3, #0]
 8008b9a:	4618      	mov	r0, r3
 8008b9c:	f7ff ffaa 	bl	8008af4 <uartWrite>
 8008ba0:	f8c7 0110 	str.w	r0, [r7, #272]	@ 0x110

	va_end(args);

	return ret;
 8008ba4:	f8d7 3110 	ldr.w	r3, [r7, #272]	@ 0x110
}
 8008ba8:	4618      	mov	r0, r3
 8008baa:	f507 778e 	add.w	r7, r7, #284	@ 0x11c
 8008bae:	46bd      	mov	sp, r7
 8008bb0:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8008bb4:	b003      	add	sp, #12
 8008bb6:	4770      	bx	lr

08008bb8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8008bb8:	b580      	push	{r7, lr}
 8008bba:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8008bbc:	4b0e      	ldr	r3, [pc, #56]	@ (8008bf8 <HAL_Init+0x40>)
 8008bbe:	681b      	ldr	r3, [r3, #0]
 8008bc0:	4a0d      	ldr	r2, [pc, #52]	@ (8008bf8 <HAL_Init+0x40>)
 8008bc2:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8008bc6:	6013      	str	r3, [r2, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
  __HAL_FLASH_DATA_CACHE_ENABLE();
 8008bc8:	4b0b      	ldr	r3, [pc, #44]	@ (8008bf8 <HAL_Init+0x40>)
 8008bca:	681b      	ldr	r3, [r3, #0]
 8008bcc:	4a0a      	ldr	r2, [pc, #40]	@ (8008bf8 <HAL_Init+0x40>)
 8008bce:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8008bd2:	6013      	str	r3, [r2, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8008bd4:	4b08      	ldr	r3, [pc, #32]	@ (8008bf8 <HAL_Init+0x40>)
 8008bd6:	681b      	ldr	r3, [r3, #0]
 8008bd8:	4a07      	ldr	r2, [pc, #28]	@ (8008bf8 <HAL_Init+0x40>)
 8008bda:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8008bde:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008be0:	2003      	movs	r0, #3
 8008be2:	f000 f973 	bl	8008ecc <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8008be6:	2000      	movs	r0, #0
 8008be8:	f000 f808 	bl	8008bfc <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8008bec:	f7f8 fd80 	bl	80016f0 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8008bf0:	2300      	movs	r3, #0
}
 8008bf2:	4618      	mov	r0, r3
 8008bf4:	bd80      	pop	{r7, pc}
 8008bf6:	bf00      	nop
 8008bf8:	40023c00 	.word	0x40023c00

08008bfc <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8008bfc:	b580      	push	{r7, lr}
 8008bfe:	b082      	sub	sp, #8
 8008c00:	af00      	add	r7, sp, #0
 8008c02:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8008c04:	4b12      	ldr	r3, [pc, #72]	@ (8008c50 <HAL_InitTick+0x54>)
 8008c06:	681a      	ldr	r2, [r3, #0]
 8008c08:	4b12      	ldr	r3, [pc, #72]	@ (8008c54 <HAL_InitTick+0x58>)
 8008c0a:	781b      	ldrb	r3, [r3, #0]
 8008c0c:	4619      	mov	r1, r3
 8008c0e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8008c12:	fbb3 f3f1 	udiv	r3, r3, r1
 8008c16:	fbb2 f3f3 	udiv	r3, r2, r3
 8008c1a:	4618      	mov	r0, r3
 8008c1c:	f000 f999 	bl	8008f52 <HAL_SYSTICK_Config>
 8008c20:	4603      	mov	r3, r0
 8008c22:	2b00      	cmp	r3, #0
 8008c24:	d001      	beq.n	8008c2a <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8008c26:	2301      	movs	r3, #1
 8008c28:	e00e      	b.n	8008c48 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8008c2a:	687b      	ldr	r3, [r7, #4]
 8008c2c:	2b0f      	cmp	r3, #15
 8008c2e:	d80a      	bhi.n	8008c46 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8008c30:	2200      	movs	r2, #0
 8008c32:	6879      	ldr	r1, [r7, #4]
 8008c34:	f04f 30ff 	mov.w	r0, #4294967295
 8008c38:	f000 f953 	bl	8008ee2 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8008c3c:	4a06      	ldr	r2, [pc, #24]	@ (8008c58 <HAL_InitTick+0x5c>)
 8008c3e:	687b      	ldr	r3, [r7, #4]
 8008c40:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8008c42:	2300      	movs	r3, #0
 8008c44:	e000      	b.n	8008c48 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8008c46:	2301      	movs	r3, #1
}
 8008c48:	4618      	mov	r0, r3
 8008c4a:	3708      	adds	r7, #8
 8008c4c:	46bd      	mov	sp, r7
 8008c4e:	bd80      	pop	{r7, pc}
 8008c50:	20000040 	.word	0x20000040
 8008c54:	200000a8 	.word	0x200000a8
 8008c58:	200000a4 	.word	0x200000a4

08008c5c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8008c5c:	b480      	push	{r7}
 8008c5e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8008c60:	4b06      	ldr	r3, [pc, #24]	@ (8008c7c <HAL_IncTick+0x20>)
 8008c62:	781b      	ldrb	r3, [r3, #0]
 8008c64:	461a      	mov	r2, r3
 8008c66:	4b06      	ldr	r3, [pc, #24]	@ (8008c80 <HAL_IncTick+0x24>)
 8008c68:	681b      	ldr	r3, [r3, #0]
 8008c6a:	4413      	add	r3, r2
 8008c6c:	4a04      	ldr	r2, [pc, #16]	@ (8008c80 <HAL_IncTick+0x24>)
 8008c6e:	6013      	str	r3, [r2, #0]
}
 8008c70:	bf00      	nop
 8008c72:	46bd      	mov	sp, r7
 8008c74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c78:	4770      	bx	lr
 8008c7a:	bf00      	nop
 8008c7c:	200000a8 	.word	0x200000a8
 8008c80:	2000a7bc 	.word	0x2000a7bc

08008c84 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8008c84:	b480      	push	{r7}
 8008c86:	af00      	add	r7, sp, #0
  return uwTick;
 8008c88:	4b03      	ldr	r3, [pc, #12]	@ (8008c98 <HAL_GetTick+0x14>)
 8008c8a:	681b      	ldr	r3, [r3, #0]
}
 8008c8c:	4618      	mov	r0, r3
 8008c8e:	46bd      	mov	sp, r7
 8008c90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c94:	4770      	bx	lr
 8008c96:	bf00      	nop
 8008c98:	2000a7bc 	.word	0x2000a7bc

08008c9c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8008c9c:	b580      	push	{r7, lr}
 8008c9e:	b084      	sub	sp, #16
 8008ca0:	af00      	add	r7, sp, #0
 8008ca2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8008ca4:	f7ff ffee 	bl	8008c84 <HAL_GetTick>
 8008ca8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8008caa:	687b      	ldr	r3, [r7, #4]
 8008cac:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8008cae:	68fb      	ldr	r3, [r7, #12]
 8008cb0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008cb4:	d005      	beq.n	8008cc2 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8008cb6:	4b0a      	ldr	r3, [pc, #40]	@ (8008ce0 <HAL_Delay+0x44>)
 8008cb8:	781b      	ldrb	r3, [r3, #0]
 8008cba:	461a      	mov	r2, r3
 8008cbc:	68fb      	ldr	r3, [r7, #12]
 8008cbe:	4413      	add	r3, r2
 8008cc0:	60fb      	str	r3, [r7, #12]
  }

  while((HAL_GetTick() - tickstart) < wait)
 8008cc2:	bf00      	nop
 8008cc4:	f7ff ffde 	bl	8008c84 <HAL_GetTick>
 8008cc8:	4602      	mov	r2, r0
 8008cca:	68bb      	ldr	r3, [r7, #8]
 8008ccc:	1ad3      	subs	r3, r2, r3
 8008cce:	68fa      	ldr	r2, [r7, #12]
 8008cd0:	429a      	cmp	r2, r3
 8008cd2:	d8f7      	bhi.n	8008cc4 <HAL_Delay+0x28>
  {
  }
}
 8008cd4:	bf00      	nop
 8008cd6:	bf00      	nop
 8008cd8:	3710      	adds	r7, #16
 8008cda:	46bd      	mov	sp, r7
 8008cdc:	bd80      	pop	{r7, pc}
 8008cde:	bf00      	nop
 8008ce0:	200000a8 	.word	0x200000a8

08008ce4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8008ce4:	b480      	push	{r7}
 8008ce6:	b085      	sub	sp, #20
 8008ce8:	af00      	add	r7, sp, #0
 8008cea:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8008cec:	687b      	ldr	r3, [r7, #4]
 8008cee:	f003 0307 	and.w	r3, r3, #7
 8008cf2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8008cf4:	4b0c      	ldr	r3, [pc, #48]	@ (8008d28 <__NVIC_SetPriorityGrouping+0x44>)
 8008cf6:	68db      	ldr	r3, [r3, #12]
 8008cf8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8008cfa:	68ba      	ldr	r2, [r7, #8]
 8008cfc:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8008d00:	4013      	ands	r3, r2
 8008d02:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8008d04:	68fb      	ldr	r3, [r7, #12]
 8008d06:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8008d08:	68bb      	ldr	r3, [r7, #8]
 8008d0a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8008d0c:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8008d10:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8008d14:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8008d16:	4a04      	ldr	r2, [pc, #16]	@ (8008d28 <__NVIC_SetPriorityGrouping+0x44>)
 8008d18:	68bb      	ldr	r3, [r7, #8]
 8008d1a:	60d3      	str	r3, [r2, #12]
}
 8008d1c:	bf00      	nop
 8008d1e:	3714      	adds	r7, #20
 8008d20:	46bd      	mov	sp, r7
 8008d22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d26:	4770      	bx	lr
 8008d28:	e000ed00 	.word	0xe000ed00

08008d2c <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8008d2c:	b480      	push	{r7}
 8008d2e:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8008d30:	4b04      	ldr	r3, [pc, #16]	@ (8008d44 <__NVIC_GetPriorityGrouping+0x18>)
 8008d32:	68db      	ldr	r3, [r3, #12]
 8008d34:	0a1b      	lsrs	r3, r3, #8
 8008d36:	f003 0307 	and.w	r3, r3, #7
}
 8008d3a:	4618      	mov	r0, r3
 8008d3c:	46bd      	mov	sp, r7
 8008d3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d42:	4770      	bx	lr
 8008d44:	e000ed00 	.word	0xe000ed00

08008d48 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8008d48:	b480      	push	{r7}
 8008d4a:	b083      	sub	sp, #12
 8008d4c:	af00      	add	r7, sp, #0
 8008d4e:	4603      	mov	r3, r0
 8008d50:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8008d52:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008d56:	2b00      	cmp	r3, #0
 8008d58:	db0b      	blt.n	8008d72 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8008d5a:	79fb      	ldrb	r3, [r7, #7]
 8008d5c:	f003 021f 	and.w	r2, r3, #31
 8008d60:	4907      	ldr	r1, [pc, #28]	@ (8008d80 <__NVIC_EnableIRQ+0x38>)
 8008d62:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008d66:	095b      	lsrs	r3, r3, #5
 8008d68:	2001      	movs	r0, #1
 8008d6a:	fa00 f202 	lsl.w	r2, r0, r2
 8008d6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8008d72:	bf00      	nop
 8008d74:	370c      	adds	r7, #12
 8008d76:	46bd      	mov	sp, r7
 8008d78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008d7c:	4770      	bx	lr
 8008d7e:	bf00      	nop
 8008d80:	e000e100 	.word	0xe000e100

08008d84 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8008d84:	b480      	push	{r7}
 8008d86:	b083      	sub	sp, #12
 8008d88:	af00      	add	r7, sp, #0
 8008d8a:	4603      	mov	r3, r0
 8008d8c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8008d8e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008d92:	2b00      	cmp	r3, #0
 8008d94:	db12      	blt.n	8008dbc <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8008d96:	79fb      	ldrb	r3, [r7, #7]
 8008d98:	f003 021f 	and.w	r2, r3, #31
 8008d9c:	490a      	ldr	r1, [pc, #40]	@ (8008dc8 <__NVIC_DisableIRQ+0x44>)
 8008d9e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008da2:	095b      	lsrs	r3, r3, #5
 8008da4:	2001      	movs	r0, #1
 8008da6:	fa00 f202 	lsl.w	r2, r0, r2
 8008daa:	3320      	adds	r3, #32
 8008dac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8008db0:	f3bf 8f4f 	dsb	sy
}
 8008db4:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8008db6:	f3bf 8f6f 	isb	sy
}
 8008dba:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 8008dbc:	bf00      	nop
 8008dbe:	370c      	adds	r7, #12
 8008dc0:	46bd      	mov	sp, r7
 8008dc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008dc6:	4770      	bx	lr
 8008dc8:	e000e100 	.word	0xe000e100

08008dcc <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8008dcc:	b480      	push	{r7}
 8008dce:	b083      	sub	sp, #12
 8008dd0:	af00      	add	r7, sp, #0
 8008dd2:	4603      	mov	r3, r0
 8008dd4:	6039      	str	r1, [r7, #0]
 8008dd6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8008dd8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008ddc:	2b00      	cmp	r3, #0
 8008dde:	db0a      	blt.n	8008df6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008de0:	683b      	ldr	r3, [r7, #0]
 8008de2:	b2da      	uxtb	r2, r3
 8008de4:	490c      	ldr	r1, [pc, #48]	@ (8008e18 <__NVIC_SetPriority+0x4c>)
 8008de6:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008dea:	0112      	lsls	r2, r2, #4
 8008dec:	b2d2      	uxtb	r2, r2
 8008dee:	440b      	add	r3, r1
 8008df0:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8008df4:	e00a      	b.n	8008e0c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8008df6:	683b      	ldr	r3, [r7, #0]
 8008df8:	b2da      	uxtb	r2, r3
 8008dfa:	4908      	ldr	r1, [pc, #32]	@ (8008e1c <__NVIC_SetPriority+0x50>)
 8008dfc:	79fb      	ldrb	r3, [r7, #7]
 8008dfe:	f003 030f 	and.w	r3, r3, #15
 8008e02:	3b04      	subs	r3, #4
 8008e04:	0112      	lsls	r2, r2, #4
 8008e06:	b2d2      	uxtb	r2, r2
 8008e08:	440b      	add	r3, r1
 8008e0a:	761a      	strb	r2, [r3, #24]
}
 8008e0c:	bf00      	nop
 8008e0e:	370c      	adds	r7, #12
 8008e10:	46bd      	mov	sp, r7
 8008e12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e16:	4770      	bx	lr
 8008e18:	e000e100 	.word	0xe000e100
 8008e1c:	e000ed00 	.word	0xe000ed00

08008e20 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8008e20:	b480      	push	{r7}
 8008e22:	b089      	sub	sp, #36	@ 0x24
 8008e24:	af00      	add	r7, sp, #0
 8008e26:	60f8      	str	r0, [r7, #12]
 8008e28:	60b9      	str	r1, [r7, #8]
 8008e2a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8008e2c:	68fb      	ldr	r3, [r7, #12]
 8008e2e:	f003 0307 	and.w	r3, r3, #7
 8008e32:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8008e34:	69fb      	ldr	r3, [r7, #28]
 8008e36:	f1c3 0307 	rsb	r3, r3, #7
 8008e3a:	2b04      	cmp	r3, #4
 8008e3c:	bf28      	it	cs
 8008e3e:	2304      	movcs	r3, #4
 8008e40:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8008e42:	69fb      	ldr	r3, [r7, #28]
 8008e44:	3304      	adds	r3, #4
 8008e46:	2b06      	cmp	r3, #6
 8008e48:	d902      	bls.n	8008e50 <NVIC_EncodePriority+0x30>
 8008e4a:	69fb      	ldr	r3, [r7, #28]
 8008e4c:	3b03      	subs	r3, #3
 8008e4e:	e000      	b.n	8008e52 <NVIC_EncodePriority+0x32>
 8008e50:	2300      	movs	r3, #0
 8008e52:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8008e54:	f04f 32ff 	mov.w	r2, #4294967295
 8008e58:	69bb      	ldr	r3, [r7, #24]
 8008e5a:	fa02 f303 	lsl.w	r3, r2, r3
 8008e5e:	43da      	mvns	r2, r3
 8008e60:	68bb      	ldr	r3, [r7, #8]
 8008e62:	401a      	ands	r2, r3
 8008e64:	697b      	ldr	r3, [r7, #20]
 8008e66:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8008e68:	f04f 31ff 	mov.w	r1, #4294967295
 8008e6c:	697b      	ldr	r3, [r7, #20]
 8008e6e:	fa01 f303 	lsl.w	r3, r1, r3
 8008e72:	43d9      	mvns	r1, r3
 8008e74:	687b      	ldr	r3, [r7, #4]
 8008e76:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8008e78:	4313      	orrs	r3, r2
         );
}
 8008e7a:	4618      	mov	r0, r3
 8008e7c:	3724      	adds	r7, #36	@ 0x24
 8008e7e:	46bd      	mov	sp, r7
 8008e80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008e84:	4770      	bx	lr
	...

08008e88 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8008e88:	b580      	push	{r7, lr}
 8008e8a:	b082      	sub	sp, #8
 8008e8c:	af00      	add	r7, sp, #0
 8008e8e:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8008e90:	687b      	ldr	r3, [r7, #4]
 8008e92:	3b01      	subs	r3, #1
 8008e94:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8008e98:	d301      	bcc.n	8008e9e <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8008e9a:	2301      	movs	r3, #1
 8008e9c:	e00f      	b.n	8008ebe <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8008e9e:	4a0a      	ldr	r2, [pc, #40]	@ (8008ec8 <SysTick_Config+0x40>)
 8008ea0:	687b      	ldr	r3, [r7, #4]
 8008ea2:	3b01      	subs	r3, #1
 8008ea4:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8008ea6:	210f      	movs	r1, #15
 8008ea8:	f04f 30ff 	mov.w	r0, #4294967295
 8008eac:	f7ff ff8e 	bl	8008dcc <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8008eb0:	4b05      	ldr	r3, [pc, #20]	@ (8008ec8 <SysTick_Config+0x40>)
 8008eb2:	2200      	movs	r2, #0
 8008eb4:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8008eb6:	4b04      	ldr	r3, [pc, #16]	@ (8008ec8 <SysTick_Config+0x40>)
 8008eb8:	2207      	movs	r2, #7
 8008eba:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8008ebc:	2300      	movs	r3, #0
}
 8008ebe:	4618      	mov	r0, r3
 8008ec0:	3708      	adds	r7, #8
 8008ec2:	46bd      	mov	sp, r7
 8008ec4:	bd80      	pop	{r7, pc}
 8008ec6:	bf00      	nop
 8008ec8:	e000e010 	.word	0xe000e010

08008ecc <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8008ecc:	b580      	push	{r7, lr}
 8008ece:	b082      	sub	sp, #8
 8008ed0:	af00      	add	r7, sp, #0
 8008ed2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8008ed4:	6878      	ldr	r0, [r7, #4]
 8008ed6:	f7ff ff05 	bl	8008ce4 <__NVIC_SetPriorityGrouping>
}
 8008eda:	bf00      	nop
 8008edc:	3708      	adds	r7, #8
 8008ede:	46bd      	mov	sp, r7
 8008ee0:	bd80      	pop	{r7, pc}

08008ee2 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8008ee2:	b580      	push	{r7, lr}
 8008ee4:	b086      	sub	sp, #24
 8008ee6:	af00      	add	r7, sp, #0
 8008ee8:	4603      	mov	r3, r0
 8008eea:	60b9      	str	r1, [r7, #8]
 8008eec:	607a      	str	r2, [r7, #4]
 8008eee:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8008ef0:	2300      	movs	r3, #0
 8008ef2:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8008ef4:	f7ff ff1a 	bl	8008d2c <__NVIC_GetPriorityGrouping>
 8008ef8:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8008efa:	687a      	ldr	r2, [r7, #4]
 8008efc:	68b9      	ldr	r1, [r7, #8]
 8008efe:	6978      	ldr	r0, [r7, #20]
 8008f00:	f7ff ff8e 	bl	8008e20 <NVIC_EncodePriority>
 8008f04:	4602      	mov	r2, r0
 8008f06:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8008f0a:	4611      	mov	r1, r2
 8008f0c:	4618      	mov	r0, r3
 8008f0e:	f7ff ff5d 	bl	8008dcc <__NVIC_SetPriority>
}
 8008f12:	bf00      	nop
 8008f14:	3718      	adds	r7, #24
 8008f16:	46bd      	mov	sp, r7
 8008f18:	bd80      	pop	{r7, pc}

08008f1a <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8008f1a:	b580      	push	{r7, lr}
 8008f1c:	b082      	sub	sp, #8
 8008f1e:	af00      	add	r7, sp, #0
 8008f20:	4603      	mov	r3, r0
 8008f22:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8008f24:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008f28:	4618      	mov	r0, r3
 8008f2a:	f7ff ff0d 	bl	8008d48 <__NVIC_EnableIRQ>
}
 8008f2e:	bf00      	nop
 8008f30:	3708      	adds	r7, #8
 8008f32:	46bd      	mov	sp, r7
 8008f34:	bd80      	pop	{r7, pc}

08008f36 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f4xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8008f36:	b580      	push	{r7, lr}
 8008f38:	b082      	sub	sp, #8
 8008f3a:	af00      	add	r7, sp, #0
 8008f3c:	4603      	mov	r3, r0
 8008f3e:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 8008f40:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8008f44:	4618      	mov	r0, r3
 8008f46:	f7ff ff1d 	bl	8008d84 <__NVIC_DisableIRQ>
}
 8008f4a:	bf00      	nop
 8008f4c:	3708      	adds	r7, #8
 8008f4e:	46bd      	mov	sp, r7
 8008f50:	bd80      	pop	{r7, pc}

08008f52 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8008f52:	b580      	push	{r7, lr}
 8008f54:	b082      	sub	sp, #8
 8008f56:	af00      	add	r7, sp, #0
 8008f58:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8008f5a:	6878      	ldr	r0, [r7, #4]
 8008f5c:	f7ff ff94 	bl	8008e88 <SysTick_Config>
 8008f60:	4603      	mov	r3, r0
}
 8008f62:	4618      	mov	r0, r3
 8008f64:	3708      	adds	r7, #8
 8008f66:	46bd      	mov	sp, r7
 8008f68:	bd80      	pop	{r7, pc}
	...

08008f6c <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8008f6c:	b580      	push	{r7, lr}
 8008f6e:	b086      	sub	sp, #24
 8008f70:	af00      	add	r7, sp, #0
 8008f72:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 8008f74:	2300      	movs	r3, #0
 8008f76:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 8008f78:	f7ff fe84 	bl	8008c84 <HAL_GetTick>
 8008f7c:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8008f7e:	687b      	ldr	r3, [r7, #4]
 8008f80:	2b00      	cmp	r3, #0
 8008f82:	d101      	bne.n	8008f88 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 8008f84:	2301      	movs	r3, #1
 8008f86:	e099      	b.n	80090bc <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8008f88:	687b      	ldr	r3, [r7, #4]
 8008f8a:	2202      	movs	r2, #2
 8008f8c:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 8008f90:	687b      	ldr	r3, [r7, #4]
 8008f92:	2200      	movs	r2, #0
 8008f94:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8008f98:	687b      	ldr	r3, [r7, #4]
 8008f9a:	681b      	ldr	r3, [r3, #0]
 8008f9c:	681a      	ldr	r2, [r3, #0]
 8008f9e:	687b      	ldr	r3, [r7, #4]
 8008fa0:	681b      	ldr	r3, [r3, #0]
 8008fa2:	f022 0201 	bic.w	r2, r2, #1
 8008fa6:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8008fa8:	e00f      	b.n	8008fca <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8008faa:	f7ff fe6b 	bl	8008c84 <HAL_GetTick>
 8008fae:	4602      	mov	r2, r0
 8008fb0:	693b      	ldr	r3, [r7, #16]
 8008fb2:	1ad3      	subs	r3, r2, r3
 8008fb4:	2b05      	cmp	r3, #5
 8008fb6:	d908      	bls.n	8008fca <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8008fb8:	687b      	ldr	r3, [r7, #4]
 8008fba:	2220      	movs	r2, #32
 8008fbc:	655a      	str	r2, [r3, #84]	@ 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8008fbe:	687b      	ldr	r3, [r7, #4]
 8008fc0:	2203      	movs	r2, #3
 8008fc2:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
      
      return HAL_TIMEOUT;
 8008fc6:	2303      	movs	r3, #3
 8008fc8:	e078      	b.n	80090bc <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8008fca:	687b      	ldr	r3, [r7, #4]
 8008fcc:	681b      	ldr	r3, [r3, #0]
 8008fce:	681b      	ldr	r3, [r3, #0]
 8008fd0:	f003 0301 	and.w	r3, r3, #1
 8008fd4:	2b00      	cmp	r3, #0
 8008fd6:	d1e8      	bne.n	8008faa <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8008fd8:	687b      	ldr	r3, [r7, #4]
 8008fda:	681b      	ldr	r3, [r3, #0]
 8008fdc:	681b      	ldr	r3, [r3, #0]
 8008fde:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8008fe0:	697a      	ldr	r2, [r7, #20]
 8008fe2:	4b38      	ldr	r3, [pc, #224]	@ (80090c4 <HAL_DMA_Init+0x158>)
 8008fe4:	4013      	ands	r3, r2
 8008fe6:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008fe8:	687b      	ldr	r3, [r7, #4]
 8008fea:	685a      	ldr	r2, [r3, #4]
 8008fec:	687b      	ldr	r3, [r7, #4]
 8008fee:	689b      	ldr	r3, [r3, #8]
 8008ff0:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008ff2:	687b      	ldr	r3, [r7, #4]
 8008ff4:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8008ff6:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8008ff8:	687b      	ldr	r3, [r7, #4]
 8008ffa:	691b      	ldr	r3, [r3, #16]
 8008ffc:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8008ffe:	687b      	ldr	r3, [r7, #4]
 8009000:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8009002:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8009004:	687b      	ldr	r3, [r7, #4]
 8009006:	699b      	ldr	r3, [r3, #24]
 8009008:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 800900a:	687b      	ldr	r3, [r7, #4]
 800900c:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800900e:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8009010:	687b      	ldr	r3, [r7, #4]
 8009012:	6a1b      	ldr	r3, [r3, #32]
 8009014:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8009016:	697a      	ldr	r2, [r7, #20]
 8009018:	4313      	orrs	r3, r2
 800901a:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800901c:	687b      	ldr	r3, [r7, #4]
 800901e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8009020:	2b04      	cmp	r3, #4
 8009022:	d107      	bne.n	8009034 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8009024:	687b      	ldr	r3, [r7, #4]
 8009026:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8009028:	687b      	ldr	r3, [r7, #4]
 800902a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800902c:	4313      	orrs	r3, r2
 800902e:	697a      	ldr	r2, [r7, #20]
 8009030:	4313      	orrs	r3, r2
 8009032:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8009034:	687b      	ldr	r3, [r7, #4]
 8009036:	681b      	ldr	r3, [r3, #0]
 8009038:	697a      	ldr	r2, [r7, #20]
 800903a:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 800903c:	687b      	ldr	r3, [r7, #4]
 800903e:	681b      	ldr	r3, [r3, #0]
 8009040:	695b      	ldr	r3, [r3, #20]
 8009042:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8009044:	697b      	ldr	r3, [r7, #20]
 8009046:	f023 0307 	bic.w	r3, r3, #7
 800904a:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 800904c:	687b      	ldr	r3, [r7, #4]
 800904e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8009050:	697a      	ldr	r2, [r7, #20]
 8009052:	4313      	orrs	r3, r2
 8009054:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8009056:	687b      	ldr	r3, [r7, #4]
 8009058:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800905a:	2b04      	cmp	r3, #4
 800905c:	d117      	bne.n	800908e <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 800905e:	687b      	ldr	r3, [r7, #4]
 8009060:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8009062:	697a      	ldr	r2, [r7, #20]
 8009064:	4313      	orrs	r3, r2
 8009066:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8009068:	687b      	ldr	r3, [r7, #4]
 800906a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800906c:	2b00      	cmp	r3, #0
 800906e:	d00e      	beq.n	800908e <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 8009070:	6878      	ldr	r0, [r7, #4]
 8009072:	f000 fb79 	bl	8009768 <DMA_CheckFifoParam>
 8009076:	4603      	mov	r3, r0
 8009078:	2b00      	cmp	r3, #0
 800907a:	d008      	beq.n	800908e <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 800907c:	687b      	ldr	r3, [r7, #4]
 800907e:	2240      	movs	r2, #64	@ 0x40
 8009080:	655a      	str	r2, [r3, #84]	@ 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 8009082:	687b      	ldr	r3, [r7, #4]
 8009084:	2201      	movs	r2, #1
 8009086:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        
        return HAL_ERROR; 
 800908a:	2301      	movs	r3, #1
 800908c:	e016      	b.n	80090bc <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 800908e:	687b      	ldr	r3, [r7, #4]
 8009090:	681b      	ldr	r3, [r3, #0]
 8009092:	697a      	ldr	r2, [r7, #20]
 8009094:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8009096:	6878      	ldr	r0, [r7, #4]
 8009098:	f000 fb30 	bl	80096fc <DMA_CalcBaseAndBitshift>
 800909c:	4603      	mov	r3, r0
 800909e:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 80090a0:	687b      	ldr	r3, [r7, #4]
 80090a2:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80090a4:	223f      	movs	r2, #63	@ 0x3f
 80090a6:	409a      	lsls	r2, r3
 80090a8:	68fb      	ldr	r3, [r7, #12]
 80090aa:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80090ac:	687b      	ldr	r3, [r7, #4]
 80090ae:	2200      	movs	r2, #0
 80090b0:	655a      	str	r2, [r3, #84]	@ 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80090b2:	687b      	ldr	r3, [r7, #4]
 80090b4:	2201      	movs	r2, #1
 80090b6:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  return HAL_OK;
 80090ba:	2300      	movs	r3, #0
}
 80090bc:	4618      	mov	r0, r3
 80090be:	3718      	adds	r7, #24
 80090c0:	46bd      	mov	sp, r7
 80090c2:	bd80      	pop	{r7, pc}
 80090c4:	f010803f 	.word	0xf010803f

080090c8 <HAL_DMA_DeInit>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 80090c8:	b580      	push	{r7, lr}
 80090ca:	b084      	sub	sp, #16
 80090cc:	af00      	add	r7, sp, #0
 80090ce:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 80090d0:	687b      	ldr	r3, [r7, #4]
 80090d2:	2b00      	cmp	r3, #0
 80090d4:	d101      	bne.n	80090da <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
 80090d6:	2301      	movs	r3, #1
 80090d8:	e050      	b.n	800917c <HAL_DMA_DeInit+0xb4>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 80090da:	687b      	ldr	r3, [r7, #4]
 80090dc:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80090e0:	b2db      	uxtb	r3, r3
 80090e2:	2b02      	cmp	r3, #2
 80090e4:	d101      	bne.n	80090ea <HAL_DMA_DeInit+0x22>
  {
    /* Return error status */
    return HAL_BUSY;
 80090e6:	2302      	movs	r3, #2
 80090e8:	e048      	b.n	800917c <HAL_DMA_DeInit+0xb4>

  /* Check the parameters */
  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 80090ea:	687b      	ldr	r3, [r7, #4]
 80090ec:	681b      	ldr	r3, [r3, #0]
 80090ee:	681a      	ldr	r2, [r3, #0]
 80090f0:	687b      	ldr	r3, [r7, #4]
 80090f2:	681b      	ldr	r3, [r3, #0]
 80090f4:	f022 0201 	bic.w	r2, r2, #1
 80090f8:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0U;
 80090fa:	687b      	ldr	r3, [r7, #4]
 80090fc:	681b      	ldr	r3, [r3, #0]
 80090fe:	2200      	movs	r2, #0
 8009100:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0U;
 8009102:	687b      	ldr	r3, [r7, #4]
 8009104:	681b      	ldr	r3, [r3, #0]
 8009106:	2200      	movs	r2, #0
 8009108:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0U;
 800910a:	687b      	ldr	r3, [r7, #4]
 800910c:	681b      	ldr	r3, [r3, #0]
 800910e:	2200      	movs	r2, #0
 8009110:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0U;
 8009112:	687b      	ldr	r3, [r7, #4]
 8009114:	681b      	ldr	r3, [r3, #0]
 8009116:	2200      	movs	r2, #0
 8009118:	60da      	str	r2, [r3, #12]
  
  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0U;
 800911a:	687b      	ldr	r3, [r7, #4]
 800911c:	681b      	ldr	r3, [r3, #0]
 800911e:	2200      	movs	r2, #0
 8009120:	611a      	str	r2, [r3, #16]
  
  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = 0x00000021U;
 8009122:	687b      	ldr	r3, [r7, #4]
 8009124:	681b      	ldr	r3, [r3, #0]
 8009126:	2221      	movs	r2, #33	@ 0x21
 8009128:	615a      	str	r2, [r3, #20]
  
  /* Get DMA steam Base Address */  
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800912a:	6878      	ldr	r0, [r7, #4]
 800912c:	f000 fae6 	bl	80096fc <DMA_CalcBaseAndBitshift>
 8009130:	4603      	mov	r3, r0
 8009132:	60fb      	str	r3, [r7, #12]
  
  /* Clean all callbacks */
  hdma->XferCpltCallback = NULL;
 8009134:	687b      	ldr	r3, [r7, #4]
 8009136:	2200      	movs	r2, #0
 8009138:	63da      	str	r2, [r3, #60]	@ 0x3c
  hdma->XferHalfCpltCallback = NULL;
 800913a:	687b      	ldr	r3, [r7, #4]
 800913c:	2200      	movs	r2, #0
 800913e:	641a      	str	r2, [r3, #64]	@ 0x40
  hdma->XferM1CpltCallback = NULL;
 8009140:	687b      	ldr	r3, [r7, #4]
 8009142:	2200      	movs	r2, #0
 8009144:	645a      	str	r2, [r3, #68]	@ 0x44
  hdma->XferM1HalfCpltCallback = NULL;
 8009146:	687b      	ldr	r3, [r7, #4]
 8009148:	2200      	movs	r2, #0
 800914a:	649a      	str	r2, [r3, #72]	@ 0x48
  hdma->XferErrorCallback = NULL;
 800914c:	687b      	ldr	r3, [r7, #4]
 800914e:	2200      	movs	r2, #0
 8009150:	64da      	str	r2, [r3, #76]	@ 0x4c
  hdma->XferAbortCallback = NULL;
 8009152:	687b      	ldr	r3, [r7, #4]
 8009154:	2200      	movs	r2, #0
 8009156:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Clear all interrupt flags at correct offset within the register */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8009158:	687b      	ldr	r3, [r7, #4]
 800915a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800915c:	223f      	movs	r2, #63	@ 0x3f
 800915e:	409a      	lsls	r2, r3
 8009160:	68fb      	ldr	r3, [r7, #12]
 8009162:	609a      	str	r2, [r3, #8]

  /* Reset the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8009164:	687b      	ldr	r3, [r7, #4]
 8009166:	2200      	movs	r2, #0
 8009168:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Reset the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 800916a:	687b      	ldr	r3, [r7, #4]
 800916c:	2200      	movs	r2, #0
 800916e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8009172:	687b      	ldr	r3, [r7, #4]
 8009174:	2200      	movs	r2, #0
 8009176:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  return HAL_OK;
 800917a:	2300      	movs	r3, #0
}
 800917c:	4618      	mov	r0, r3
 800917e:	3710      	adds	r7, #16
 8009180:	46bd      	mov	sp, r7
 8009182:	bd80      	pop	{r7, pc}

08009184 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8009184:	b580      	push	{r7, lr}
 8009186:	b086      	sub	sp, #24
 8009188:	af00      	add	r7, sp, #0
 800918a:	60f8      	str	r0, [r7, #12]
 800918c:	60b9      	str	r1, [r7, #8]
 800918e:	607a      	str	r2, [r7, #4]
 8009190:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8009192:	2300      	movs	r3, #0
 8009194:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8009196:	68fb      	ldr	r3, [r7, #12]
 8009198:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800919a:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 800919c:	68fb      	ldr	r3, [r7, #12]
 800919e:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 80091a2:	2b01      	cmp	r3, #1
 80091a4:	d101      	bne.n	80091aa <HAL_DMA_Start_IT+0x26>
 80091a6:	2302      	movs	r3, #2
 80091a8:	e040      	b.n	800922c <HAL_DMA_Start_IT+0xa8>
 80091aa:	68fb      	ldr	r3, [r7, #12]
 80091ac:	2201      	movs	r2, #1
 80091ae:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 80091b2:	68fb      	ldr	r3, [r7, #12]
 80091b4:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80091b8:	b2db      	uxtb	r3, r3
 80091ba:	2b01      	cmp	r3, #1
 80091bc:	d12f      	bne.n	800921e <HAL_DMA_Start_IT+0x9a>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 80091be:	68fb      	ldr	r3, [r7, #12]
 80091c0:	2202      	movs	r2, #2
 80091c2:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80091c6:	68fb      	ldr	r3, [r7, #12]
 80091c8:	2200      	movs	r2, #0
 80091ca:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 80091cc:	683b      	ldr	r3, [r7, #0]
 80091ce:	687a      	ldr	r2, [r7, #4]
 80091d0:	68b9      	ldr	r1, [r7, #8]
 80091d2:	68f8      	ldr	r0, [r7, #12]
 80091d4:	f000 fa64 	bl	80096a0 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80091d8:	68fb      	ldr	r3, [r7, #12]
 80091da:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80091dc:	223f      	movs	r2, #63	@ 0x3f
 80091de:	409a      	lsls	r2, r3
 80091e0:	693b      	ldr	r3, [r7, #16]
 80091e2:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 80091e4:	68fb      	ldr	r3, [r7, #12]
 80091e6:	681b      	ldr	r3, [r3, #0]
 80091e8:	681a      	ldr	r2, [r3, #0]
 80091ea:	68fb      	ldr	r3, [r7, #12]
 80091ec:	681b      	ldr	r3, [r3, #0]
 80091ee:	f042 0216 	orr.w	r2, r2, #22
 80091f2:	601a      	str	r2, [r3, #0]
    
    if(hdma->XferHalfCpltCallback != NULL)
 80091f4:	68fb      	ldr	r3, [r7, #12]
 80091f6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80091f8:	2b00      	cmp	r3, #0
 80091fa:	d007      	beq.n	800920c <HAL_DMA_Start_IT+0x88>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
 80091fc:	68fb      	ldr	r3, [r7, #12]
 80091fe:	681b      	ldr	r3, [r3, #0]
 8009200:	681a      	ldr	r2, [r3, #0]
 8009202:	68fb      	ldr	r3, [r7, #12]
 8009204:	681b      	ldr	r3, [r3, #0]
 8009206:	f042 0208 	orr.w	r2, r2, #8
 800920a:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 800920c:	68fb      	ldr	r3, [r7, #12]
 800920e:	681b      	ldr	r3, [r3, #0]
 8009210:	681a      	ldr	r2, [r3, #0]
 8009212:	68fb      	ldr	r3, [r7, #12]
 8009214:	681b      	ldr	r3, [r3, #0]
 8009216:	f042 0201 	orr.w	r2, r2, #1
 800921a:	601a      	str	r2, [r3, #0]
 800921c:	e005      	b.n	800922a <HAL_DMA_Start_IT+0xa6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 800921e:	68fb      	ldr	r3, [r7, #12]
 8009220:	2200      	movs	r2, #0
 8009222:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 8009226:	2302      	movs	r3, #2
 8009228:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 800922a:	7dfb      	ldrb	r3, [r7, #23]
}
 800922c:	4618      	mov	r0, r3
 800922e:	3718      	adds	r7, #24
 8009230:	46bd      	mov	sp, r7
 8009232:	bd80      	pop	{r7, pc}

08009234 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 8009234:	b580      	push	{r7, lr}
 8009236:	b084      	sub	sp, #16
 8009238:	af00      	add	r7, sp, #0
 800923a:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800923c:	687b      	ldr	r3, [r7, #4]
 800923e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8009240:	60fb      	str	r3, [r7, #12]
  
  uint32_t tickstart = HAL_GetTick();
 8009242:	f7ff fd1f 	bl	8008c84 <HAL_GetTick>
 8009246:	60b8      	str	r0, [r7, #8]
  
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8009248:	687b      	ldr	r3, [r7, #4]
 800924a:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800924e:	b2db      	uxtb	r3, r3
 8009250:	2b02      	cmp	r3, #2
 8009252:	d008      	beq.n	8009266 <HAL_DMA_Abort+0x32>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8009254:	687b      	ldr	r3, [r7, #4]
 8009256:	2280      	movs	r2, #128	@ 0x80
 8009258:	655a      	str	r2, [r3, #84]	@ 0x54
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 800925a:	687b      	ldr	r3, [r7, #4]
 800925c:	2200      	movs	r2, #0
 800925e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    
    return HAL_ERROR;
 8009262:	2301      	movs	r3, #1
 8009264:	e052      	b.n	800930c <HAL_DMA_Abort+0xd8>
  }
  else
  {
    /* Disable all the transfer interrupts */
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8009266:	687b      	ldr	r3, [r7, #4]
 8009268:	681b      	ldr	r3, [r3, #0]
 800926a:	681a      	ldr	r2, [r3, #0]
 800926c:	687b      	ldr	r3, [r7, #4]
 800926e:	681b      	ldr	r3, [r3, #0]
 8009270:	f022 0216 	bic.w	r2, r2, #22
 8009274:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
 8009276:	687b      	ldr	r3, [r7, #4]
 8009278:	681b      	ldr	r3, [r3, #0]
 800927a:	695a      	ldr	r2, [r3, #20]
 800927c:	687b      	ldr	r3, [r7, #4]
 800927e:	681b      	ldr	r3, [r3, #0]
 8009280:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8009284:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8009286:	687b      	ldr	r3, [r7, #4]
 8009288:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800928a:	2b00      	cmp	r3, #0
 800928c:	d103      	bne.n	8009296 <HAL_DMA_Abort+0x62>
 800928e:	687b      	ldr	r3, [r7, #4]
 8009290:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8009292:	2b00      	cmp	r3, #0
 8009294:	d007      	beq.n	80092a6 <HAL_DMA_Abort+0x72>
    {
      hdma->Instance->CR  &= ~(DMA_IT_HT);
 8009296:	687b      	ldr	r3, [r7, #4]
 8009298:	681b      	ldr	r3, [r3, #0]
 800929a:	681a      	ldr	r2, [r3, #0]
 800929c:	687b      	ldr	r3, [r7, #4]
 800929e:	681b      	ldr	r3, [r3, #0]
 80092a0:	f022 0208 	bic.w	r2, r2, #8
 80092a4:	601a      	str	r2, [r3, #0]
    }
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 80092a6:	687b      	ldr	r3, [r7, #4]
 80092a8:	681b      	ldr	r3, [r3, #0]
 80092aa:	681a      	ldr	r2, [r3, #0]
 80092ac:	687b      	ldr	r3, [r7, #4]
 80092ae:	681b      	ldr	r3, [r3, #0]
 80092b0:	f022 0201 	bic.w	r2, r2, #1
 80092b4:	601a      	str	r2, [r3, #0]
    
    /* Check if the DMA Stream is effectively disabled */
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80092b6:	e013      	b.n	80092e0 <HAL_DMA_Abort+0xac>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 80092b8:	f7ff fce4 	bl	8008c84 <HAL_GetTick>
 80092bc:	4602      	mov	r2, r0
 80092be:	68bb      	ldr	r3, [r7, #8]
 80092c0:	1ad3      	subs	r3, r2, r3
 80092c2:	2b05      	cmp	r3, #5
 80092c4:	d90c      	bls.n	80092e0 <HAL_DMA_Abort+0xac>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80092c6:	687b      	ldr	r3, [r7, #4]
 80092c8:	2220      	movs	r2, #32
 80092ca:	655a      	str	r2, [r3, #84]	@ 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
 80092cc:	687b      	ldr	r3, [r7, #4]
 80092ce:	2203      	movs	r2, #3
 80092d0:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        
        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80092d4:	687b      	ldr	r3, [r7, #4]
 80092d6:	2200      	movs	r2, #0
 80092d8:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        
        return HAL_TIMEOUT;
 80092dc:	2303      	movs	r3, #3
 80092de:	e015      	b.n	800930c <HAL_DMA_Abort+0xd8>
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 80092e0:	687b      	ldr	r3, [r7, #4]
 80092e2:	681b      	ldr	r3, [r3, #0]
 80092e4:	681b      	ldr	r3, [r3, #0]
 80092e6:	f003 0301 	and.w	r3, r3, #1
 80092ea:	2b00      	cmp	r3, #0
 80092ec:	d1e4      	bne.n	80092b8 <HAL_DMA_Abort+0x84>
      }
    }
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 80092ee:	687b      	ldr	r3, [r7, #4]
 80092f0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80092f2:	223f      	movs	r2, #63	@ 0x3f
 80092f4:	409a      	lsls	r2, r3
 80092f6:	68fb      	ldr	r3, [r7, #12]
 80092f8:	609a      	str	r2, [r3, #8]
    
    /* Change the DMA state*/
    hdma->State = HAL_DMA_STATE_READY;
 80092fa:	687b      	ldr	r3, [r7, #4]
 80092fc:	2201      	movs	r2, #1
 80092fe:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8009302:	687b      	ldr	r3, [r7, #4]
 8009304:	2200      	movs	r2, #0
 8009306:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  }
  return HAL_OK;
 800930a:	2300      	movs	r3, #0
}
 800930c:	4618      	mov	r0, r3
 800930e:	3710      	adds	r7, #16
 8009310:	46bd      	mov	sp, r7
 8009312:	bd80      	pop	{r7, pc}

08009314 <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8009314:	b480      	push	{r7}
 8009316:	b083      	sub	sp, #12
 8009318:	af00      	add	r7, sp, #0
 800931a:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800931c:	687b      	ldr	r3, [r7, #4]
 800931e:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8009322:	b2db      	uxtb	r3, r3
 8009324:	2b02      	cmp	r3, #2
 8009326:	d004      	beq.n	8009332 <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8009328:	687b      	ldr	r3, [r7, #4]
 800932a:	2280      	movs	r2, #128	@ 0x80
 800932c:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_ERROR;
 800932e:	2301      	movs	r3, #1
 8009330:	e00c      	b.n	800934c <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8009332:	687b      	ldr	r3, [r7, #4]
 8009334:	2205      	movs	r2, #5
 8009336:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 800933a:	687b      	ldr	r3, [r7, #4]
 800933c:	681b      	ldr	r3, [r3, #0]
 800933e:	681a      	ldr	r2, [r3, #0]
 8009340:	687b      	ldr	r3, [r7, #4]
 8009342:	681b      	ldr	r3, [r3, #0]
 8009344:	f022 0201 	bic.w	r2, r2, #1
 8009348:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
 800934a:	2300      	movs	r3, #0
}
 800934c:	4618      	mov	r0, r3
 800934e:	370c      	adds	r7, #12
 8009350:	46bd      	mov	sp, r7
 8009352:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009356:	4770      	bx	lr

08009358 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8009358:	b580      	push	{r7, lr}
 800935a:	b086      	sub	sp, #24
 800935c:	af00      	add	r7, sp, #0
 800935e:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0U;
 8009360:	2300      	movs	r3, #0
 8009362:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
 8009364:	4b8e      	ldr	r3, [pc, #568]	@ (80095a0 <HAL_DMA_IRQHandler+0x248>)
 8009366:	681b      	ldr	r3, [r3, #0]
 8009368:	4a8e      	ldr	r2, [pc, #568]	@ (80095a4 <HAL_DMA_IRQHandler+0x24c>)
 800936a:	fba2 2303 	umull	r2, r3, r2, r3
 800936e:	0a9b      	lsrs	r3, r3, #10
 8009370:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8009372:	687b      	ldr	r3, [r7, #4]
 8009374:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8009376:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 8009378:	693b      	ldr	r3, [r7, #16]
 800937a:	681b      	ldr	r3, [r3, #0]
 800937c:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800937e:	687b      	ldr	r3, [r7, #4]
 8009380:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8009382:	2208      	movs	r2, #8
 8009384:	409a      	lsls	r2, r3
 8009386:	68fb      	ldr	r3, [r7, #12]
 8009388:	4013      	ands	r3, r2
 800938a:	2b00      	cmp	r3, #0
 800938c:	d01a      	beq.n	80093c4 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800938e:	687b      	ldr	r3, [r7, #4]
 8009390:	681b      	ldr	r3, [r3, #0]
 8009392:	681b      	ldr	r3, [r3, #0]
 8009394:	f003 0304 	and.w	r3, r3, #4
 8009398:	2b00      	cmp	r3, #0
 800939a:	d013      	beq.n	80093c4 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 800939c:	687b      	ldr	r3, [r7, #4]
 800939e:	681b      	ldr	r3, [r3, #0]
 80093a0:	681a      	ldr	r2, [r3, #0]
 80093a2:	687b      	ldr	r3, [r7, #4]
 80093a4:	681b      	ldr	r3, [r3, #0]
 80093a6:	f022 0204 	bic.w	r2, r2, #4
 80093aa:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 80093ac:	687b      	ldr	r3, [r7, #4]
 80093ae:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80093b0:	2208      	movs	r2, #8
 80093b2:	409a      	lsls	r2, r3
 80093b4:	693b      	ldr	r3, [r7, #16]
 80093b6:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 80093b8:	687b      	ldr	r3, [r7, #4]
 80093ba:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80093bc:	f043 0201 	orr.w	r2, r3, #1
 80093c0:	687b      	ldr	r3, [r7, #4]
 80093c2:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 80093c4:	687b      	ldr	r3, [r7, #4]
 80093c6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80093c8:	2201      	movs	r2, #1
 80093ca:	409a      	lsls	r2, r3
 80093cc:	68fb      	ldr	r3, [r7, #12]
 80093ce:	4013      	ands	r3, r2
 80093d0:	2b00      	cmp	r3, #0
 80093d2:	d012      	beq.n	80093fa <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 80093d4:	687b      	ldr	r3, [r7, #4]
 80093d6:	681b      	ldr	r3, [r3, #0]
 80093d8:	695b      	ldr	r3, [r3, #20]
 80093da:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80093de:	2b00      	cmp	r3, #0
 80093e0:	d00b      	beq.n	80093fa <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 80093e2:	687b      	ldr	r3, [r7, #4]
 80093e4:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80093e6:	2201      	movs	r2, #1
 80093e8:	409a      	lsls	r2, r3
 80093ea:	693b      	ldr	r3, [r7, #16]
 80093ec:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 80093ee:	687b      	ldr	r3, [r7, #4]
 80093f0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80093f2:	f043 0202 	orr.w	r2, r3, #2
 80093f6:	687b      	ldr	r3, [r7, #4]
 80093f8:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 80093fa:	687b      	ldr	r3, [r7, #4]
 80093fc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80093fe:	2204      	movs	r2, #4
 8009400:	409a      	lsls	r2, r3
 8009402:	68fb      	ldr	r3, [r7, #12]
 8009404:	4013      	ands	r3, r2
 8009406:	2b00      	cmp	r3, #0
 8009408:	d012      	beq.n	8009430 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 800940a:	687b      	ldr	r3, [r7, #4]
 800940c:	681b      	ldr	r3, [r3, #0]
 800940e:	681b      	ldr	r3, [r3, #0]
 8009410:	f003 0302 	and.w	r3, r3, #2
 8009414:	2b00      	cmp	r3, #0
 8009416:	d00b      	beq.n	8009430 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 8009418:	687b      	ldr	r3, [r7, #4]
 800941a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800941c:	2204      	movs	r2, #4
 800941e:	409a      	lsls	r2, r3
 8009420:	693b      	ldr	r3, [r7, #16]
 8009422:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8009424:	687b      	ldr	r3, [r7, #4]
 8009426:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009428:	f043 0204 	orr.w	r2, r3, #4
 800942c:	687b      	ldr	r3, [r7, #4]
 800942e:	655a      	str	r2, [r3, #84]	@ 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 8009430:	687b      	ldr	r3, [r7, #4]
 8009432:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8009434:	2210      	movs	r2, #16
 8009436:	409a      	lsls	r2, r3
 8009438:	68fb      	ldr	r3, [r7, #12]
 800943a:	4013      	ands	r3, r2
 800943c:	2b00      	cmp	r3, #0
 800943e:	d043      	beq.n	80094c8 <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 8009440:	687b      	ldr	r3, [r7, #4]
 8009442:	681b      	ldr	r3, [r3, #0]
 8009444:	681b      	ldr	r3, [r3, #0]
 8009446:	f003 0308 	and.w	r3, r3, #8
 800944a:	2b00      	cmp	r3, #0
 800944c:	d03c      	beq.n	80094c8 <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 800944e:	687b      	ldr	r3, [r7, #4]
 8009450:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8009452:	2210      	movs	r2, #16
 8009454:	409a      	lsls	r2, r3
 8009456:	693b      	ldr	r3, [r7, #16]
 8009458:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 800945a:	687b      	ldr	r3, [r7, #4]
 800945c:	681b      	ldr	r3, [r3, #0]
 800945e:	681b      	ldr	r3, [r3, #0]
 8009460:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8009464:	2b00      	cmp	r3, #0
 8009466:	d018      	beq.n	800949a <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 8009468:	687b      	ldr	r3, [r7, #4]
 800946a:	681b      	ldr	r3, [r3, #0]
 800946c:	681b      	ldr	r3, [r3, #0]
 800946e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8009472:	2b00      	cmp	r3, #0
 8009474:	d108      	bne.n	8009488 <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 8009476:	687b      	ldr	r3, [r7, #4]
 8009478:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800947a:	2b00      	cmp	r3, #0
 800947c:	d024      	beq.n	80094c8 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 800947e:	687b      	ldr	r3, [r7, #4]
 8009480:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8009482:	6878      	ldr	r0, [r7, #4]
 8009484:	4798      	blx	r3
 8009486:	e01f      	b.n	80094c8 <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 8009488:	687b      	ldr	r3, [r7, #4]
 800948a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800948c:	2b00      	cmp	r3, #0
 800948e:	d01b      	beq.n	80094c8 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 8009490:	687b      	ldr	r3, [r7, #4]
 8009492:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8009494:	6878      	ldr	r0, [r7, #4]
 8009496:	4798      	blx	r3
 8009498:	e016      	b.n	80094c8 <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 800949a:	687b      	ldr	r3, [r7, #4]
 800949c:	681b      	ldr	r3, [r3, #0]
 800949e:	681b      	ldr	r3, [r3, #0]
 80094a0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80094a4:	2b00      	cmp	r3, #0
 80094a6:	d107      	bne.n	80094b8 <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80094a8:	687b      	ldr	r3, [r7, #4]
 80094aa:	681b      	ldr	r3, [r3, #0]
 80094ac:	681a      	ldr	r2, [r3, #0]
 80094ae:	687b      	ldr	r3, [r7, #4]
 80094b0:	681b      	ldr	r3, [r3, #0]
 80094b2:	f022 0208 	bic.w	r2, r2, #8
 80094b6:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 80094b8:	687b      	ldr	r3, [r7, #4]
 80094ba:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80094bc:	2b00      	cmp	r3, #0
 80094be:	d003      	beq.n	80094c8 <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 80094c0:	687b      	ldr	r3, [r7, #4]
 80094c2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80094c4:	6878      	ldr	r0, [r7, #4]
 80094c6:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 80094c8:	687b      	ldr	r3, [r7, #4]
 80094ca:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80094cc:	2220      	movs	r2, #32
 80094ce:	409a      	lsls	r2, r3
 80094d0:	68fb      	ldr	r3, [r7, #12]
 80094d2:	4013      	ands	r3, r2
 80094d4:	2b00      	cmp	r3, #0
 80094d6:	f000 808f 	beq.w	80095f8 <HAL_DMA_IRQHandler+0x2a0>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 80094da:	687b      	ldr	r3, [r7, #4]
 80094dc:	681b      	ldr	r3, [r3, #0]
 80094de:	681b      	ldr	r3, [r3, #0]
 80094e0:	f003 0310 	and.w	r3, r3, #16
 80094e4:	2b00      	cmp	r3, #0
 80094e6:	f000 8087 	beq.w	80095f8 <HAL_DMA_IRQHandler+0x2a0>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 80094ea:	687b      	ldr	r3, [r7, #4]
 80094ec:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80094ee:	2220      	movs	r2, #32
 80094f0:	409a      	lsls	r2, r3
 80094f2:	693b      	ldr	r3, [r7, #16]
 80094f4:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 80094f6:	687b      	ldr	r3, [r7, #4]
 80094f8:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80094fc:	b2db      	uxtb	r3, r3
 80094fe:	2b05      	cmp	r3, #5
 8009500:	d136      	bne.n	8009570 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8009502:	687b      	ldr	r3, [r7, #4]
 8009504:	681b      	ldr	r3, [r3, #0]
 8009506:	681a      	ldr	r2, [r3, #0]
 8009508:	687b      	ldr	r3, [r7, #4]
 800950a:	681b      	ldr	r3, [r3, #0]
 800950c:	f022 0216 	bic.w	r2, r2, #22
 8009510:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 8009512:	687b      	ldr	r3, [r7, #4]
 8009514:	681b      	ldr	r3, [r3, #0]
 8009516:	695a      	ldr	r2, [r3, #20]
 8009518:	687b      	ldr	r3, [r7, #4]
 800951a:	681b      	ldr	r3, [r3, #0]
 800951c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8009520:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8009522:	687b      	ldr	r3, [r7, #4]
 8009524:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8009526:	2b00      	cmp	r3, #0
 8009528:	d103      	bne.n	8009532 <HAL_DMA_IRQHandler+0x1da>
 800952a:	687b      	ldr	r3, [r7, #4]
 800952c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800952e:	2b00      	cmp	r3, #0
 8009530:	d007      	beq.n	8009542 <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8009532:	687b      	ldr	r3, [r7, #4]
 8009534:	681b      	ldr	r3, [r3, #0]
 8009536:	681a      	ldr	r2, [r3, #0]
 8009538:	687b      	ldr	r3, [r7, #4]
 800953a:	681b      	ldr	r3, [r3, #0]
 800953c:	f022 0208 	bic.w	r2, r2, #8
 8009540:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 8009542:	687b      	ldr	r3, [r7, #4]
 8009544:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8009546:	223f      	movs	r2, #63	@ 0x3f
 8009548:	409a      	lsls	r2, r3
 800954a:	693b      	ldr	r3, [r7, #16]
 800954c:	609a      	str	r2, [r3, #8]

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 800954e:	687b      	ldr	r3, [r7, #4]
 8009550:	2201      	movs	r2, #1
 8009552:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8009556:	687b      	ldr	r3, [r7, #4]
 8009558:	2200      	movs	r2, #0
 800955a:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

        if(hdma->XferAbortCallback != NULL)
 800955e:	687b      	ldr	r3, [r7, #4]
 8009560:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8009562:	2b00      	cmp	r3, #0
 8009564:	d07e      	beq.n	8009664 <HAL_DMA_IRQHandler+0x30c>
        {
          hdma->XferAbortCallback(hdma);
 8009566:	687b      	ldr	r3, [r7, #4]
 8009568:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800956a:	6878      	ldr	r0, [r7, #4]
 800956c:	4798      	blx	r3
        }
        return;
 800956e:	e079      	b.n	8009664 <HAL_DMA_IRQHandler+0x30c>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 8009570:	687b      	ldr	r3, [r7, #4]
 8009572:	681b      	ldr	r3, [r3, #0]
 8009574:	681b      	ldr	r3, [r3, #0]
 8009576:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800957a:	2b00      	cmp	r3, #0
 800957c:	d01d      	beq.n	80095ba <HAL_DMA_IRQHandler+0x262>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 800957e:	687b      	ldr	r3, [r7, #4]
 8009580:	681b      	ldr	r3, [r3, #0]
 8009582:	681b      	ldr	r3, [r3, #0]
 8009584:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8009588:	2b00      	cmp	r3, #0
 800958a:	d10d      	bne.n	80095a8 <HAL_DMA_IRQHandler+0x250>
        {
          if(hdma->XferM1CpltCallback != NULL)
 800958c:	687b      	ldr	r3, [r7, #4]
 800958e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8009590:	2b00      	cmp	r3, #0
 8009592:	d031      	beq.n	80095f8 <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8009594:	687b      	ldr	r3, [r7, #4]
 8009596:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8009598:	6878      	ldr	r0, [r7, #4]
 800959a:	4798      	blx	r3
 800959c:	e02c      	b.n	80095f8 <HAL_DMA_IRQHandler+0x2a0>
 800959e:	bf00      	nop
 80095a0:	20000040 	.word	0x20000040
 80095a4:	1b4e81b5 	.word	0x1b4e81b5
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 80095a8:	687b      	ldr	r3, [r7, #4]
 80095aa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80095ac:	2b00      	cmp	r3, #0
 80095ae:	d023      	beq.n	80095f8 <HAL_DMA_IRQHandler+0x2a0>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 80095b0:	687b      	ldr	r3, [r7, #4]
 80095b2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80095b4:	6878      	ldr	r0, [r7, #4]
 80095b6:	4798      	blx	r3
 80095b8:	e01e      	b.n	80095f8 <HAL_DMA_IRQHandler+0x2a0>
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 80095ba:	687b      	ldr	r3, [r7, #4]
 80095bc:	681b      	ldr	r3, [r3, #0]
 80095be:	681b      	ldr	r3, [r3, #0]
 80095c0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80095c4:	2b00      	cmp	r3, #0
 80095c6:	d10f      	bne.n	80095e8 <HAL_DMA_IRQHandler+0x290>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 80095c8:	687b      	ldr	r3, [r7, #4]
 80095ca:	681b      	ldr	r3, [r3, #0]
 80095cc:	681a      	ldr	r2, [r3, #0]
 80095ce:	687b      	ldr	r3, [r7, #4]
 80095d0:	681b      	ldr	r3, [r3, #0]
 80095d2:	f022 0210 	bic.w	r2, r2, #16
 80095d6:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 80095d8:	687b      	ldr	r3, [r7, #4]
 80095da:	2201      	movs	r2, #1
 80095dc:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 80095e0:	687b      	ldr	r3, [r7, #4]
 80095e2:	2200      	movs	r2, #0
 80095e4:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        }

        if(hdma->XferCpltCallback != NULL)
 80095e8:	687b      	ldr	r3, [r7, #4]
 80095ea:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80095ec:	2b00      	cmp	r3, #0
 80095ee:	d003      	beq.n	80095f8 <HAL_DMA_IRQHandler+0x2a0>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 80095f0:	687b      	ldr	r3, [r7, #4]
 80095f2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80095f4:	6878      	ldr	r0, [r7, #4]
 80095f6:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 80095f8:	687b      	ldr	r3, [r7, #4]
 80095fa:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80095fc:	2b00      	cmp	r3, #0
 80095fe:	d032      	beq.n	8009666 <HAL_DMA_IRQHandler+0x30e>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 8009600:	687b      	ldr	r3, [r7, #4]
 8009602:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009604:	f003 0301 	and.w	r3, r3, #1
 8009608:	2b00      	cmp	r3, #0
 800960a:	d022      	beq.n	8009652 <HAL_DMA_IRQHandler+0x2fa>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 800960c:	687b      	ldr	r3, [r7, #4]
 800960e:	2205      	movs	r2, #5
 8009610:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 8009614:	687b      	ldr	r3, [r7, #4]
 8009616:	681b      	ldr	r3, [r3, #0]
 8009618:	681a      	ldr	r2, [r3, #0]
 800961a:	687b      	ldr	r3, [r7, #4]
 800961c:	681b      	ldr	r3, [r3, #0]
 800961e:	f022 0201 	bic.w	r2, r2, #1
 8009622:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 8009624:	68bb      	ldr	r3, [r7, #8]
 8009626:	3301      	adds	r3, #1
 8009628:	60bb      	str	r3, [r7, #8]
 800962a:	697a      	ldr	r2, [r7, #20]
 800962c:	429a      	cmp	r2, r3
 800962e:	d307      	bcc.n	8009640 <HAL_DMA_IRQHandler+0x2e8>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 8009630:	687b      	ldr	r3, [r7, #4]
 8009632:	681b      	ldr	r3, [r3, #0]
 8009634:	681b      	ldr	r3, [r3, #0]
 8009636:	f003 0301 	and.w	r3, r3, #1
 800963a:	2b00      	cmp	r3, #0
 800963c:	d1f2      	bne.n	8009624 <HAL_DMA_IRQHandler+0x2cc>
 800963e:	e000      	b.n	8009642 <HAL_DMA_IRQHandler+0x2ea>
          break;
 8009640:	bf00      	nop

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8009642:	687b      	ldr	r3, [r7, #4]
 8009644:	2201      	movs	r2, #1
 8009646:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800964a:	687b      	ldr	r3, [r7, #4]
 800964c:	2200      	movs	r2, #0
 800964e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    }

    if(hdma->XferErrorCallback != NULL)
 8009652:	687b      	ldr	r3, [r7, #4]
 8009654:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009656:	2b00      	cmp	r3, #0
 8009658:	d005      	beq.n	8009666 <HAL_DMA_IRQHandler+0x30e>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 800965a:	687b      	ldr	r3, [r7, #4]
 800965c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800965e:	6878      	ldr	r0, [r7, #4]
 8009660:	4798      	blx	r3
 8009662:	e000      	b.n	8009666 <HAL_DMA_IRQHandler+0x30e>
        return;
 8009664:	bf00      	nop
    }
  }
}
 8009666:	3718      	adds	r7, #24
 8009668:	46bd      	mov	sp, r7
 800966a:	bd80      	pop	{r7, pc}

0800966c <HAL_DMA_GetState>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL state
  */
HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
{
 800966c:	b480      	push	{r7}
 800966e:	b083      	sub	sp, #12
 8009670:	af00      	add	r7, sp, #0
 8009672:	6078      	str	r0, [r7, #4]
  return hdma->State;
 8009674:	687b      	ldr	r3, [r7, #4]
 8009676:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800967a:	b2db      	uxtb	r3, r3
}
 800967c:	4618      	mov	r0, r3
 800967e:	370c      	adds	r7, #12
 8009680:	46bd      	mov	sp, r7
 8009682:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009686:	4770      	bx	lr

08009688 <HAL_DMA_GetError>:
  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
 8009688:	b480      	push	{r7}
 800968a:	b083      	sub	sp, #12
 800968c:	af00      	add	r7, sp, #0
 800968e:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
 8009690:	687b      	ldr	r3, [r7, #4]
 8009692:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
}
 8009694:	4618      	mov	r0, r3
 8009696:	370c      	adds	r7, #12
 8009698:	46bd      	mov	sp, r7
 800969a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800969e:	4770      	bx	lr

080096a0 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80096a0:	b480      	push	{r7}
 80096a2:	b085      	sub	sp, #20
 80096a4:	af00      	add	r7, sp, #0
 80096a6:	60f8      	str	r0, [r7, #12]
 80096a8:	60b9      	str	r1, [r7, #8]
 80096aa:	607a      	str	r2, [r7, #4]
 80096ac:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80096ae:	68fb      	ldr	r3, [r7, #12]
 80096b0:	681b      	ldr	r3, [r3, #0]
 80096b2:	681a      	ldr	r2, [r3, #0]
 80096b4:	68fb      	ldr	r3, [r7, #12]
 80096b6:	681b      	ldr	r3, [r3, #0]
 80096b8:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 80096bc:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 80096be:	68fb      	ldr	r3, [r7, #12]
 80096c0:	681b      	ldr	r3, [r3, #0]
 80096c2:	683a      	ldr	r2, [r7, #0]
 80096c4:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80096c6:	68fb      	ldr	r3, [r7, #12]
 80096c8:	689b      	ldr	r3, [r3, #8]
 80096ca:	2b40      	cmp	r3, #64	@ 0x40
 80096cc:	d108      	bne.n	80096e0 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 80096ce:	68fb      	ldr	r3, [r7, #12]
 80096d0:	681b      	ldr	r3, [r3, #0]
 80096d2:	687a      	ldr	r2, [r7, #4]
 80096d4:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 80096d6:	68fb      	ldr	r3, [r7, #12]
 80096d8:	681b      	ldr	r3, [r3, #0]
 80096da:	68ba      	ldr	r2, [r7, #8]
 80096dc:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 80096de:	e007      	b.n	80096f0 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 80096e0:	68fb      	ldr	r3, [r7, #12]
 80096e2:	681b      	ldr	r3, [r3, #0]
 80096e4:	68ba      	ldr	r2, [r7, #8]
 80096e6:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 80096e8:	68fb      	ldr	r3, [r7, #12]
 80096ea:	681b      	ldr	r3, [r3, #0]
 80096ec:	687a      	ldr	r2, [r7, #4]
 80096ee:	60da      	str	r2, [r3, #12]
}
 80096f0:	bf00      	nop
 80096f2:	3714      	adds	r7, #20
 80096f4:	46bd      	mov	sp, r7
 80096f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80096fa:	4770      	bx	lr

080096fc <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80096fc:	b480      	push	{r7}
 80096fe:	b085      	sub	sp, #20
 8009700:	af00      	add	r7, sp, #0
 8009702:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8009704:	687b      	ldr	r3, [r7, #4]
 8009706:	681b      	ldr	r3, [r3, #0]
 8009708:	b2db      	uxtb	r3, r3
 800970a:	3b10      	subs	r3, #16
 800970c:	4a14      	ldr	r2, [pc, #80]	@ (8009760 <DMA_CalcBaseAndBitshift+0x64>)
 800970e:	fba2 2303 	umull	r2, r3, r2, r3
 8009712:	091b      	lsrs	r3, r3, #4
 8009714:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8009716:	4a13      	ldr	r2, [pc, #76]	@ (8009764 <DMA_CalcBaseAndBitshift+0x68>)
 8009718:	68fb      	ldr	r3, [r7, #12]
 800971a:	4413      	add	r3, r2
 800971c:	781b      	ldrb	r3, [r3, #0]
 800971e:	461a      	mov	r2, r3
 8009720:	687b      	ldr	r3, [r7, #4]
 8009722:	65da      	str	r2, [r3, #92]	@ 0x5c
  
  if (stream_number > 3U)
 8009724:	68fb      	ldr	r3, [r7, #12]
 8009726:	2b03      	cmp	r3, #3
 8009728:	d909      	bls.n	800973e <DMA_CalcBaseAndBitshift+0x42>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800972a:	687b      	ldr	r3, [r7, #4]
 800972c:	681b      	ldr	r3, [r3, #0]
 800972e:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
 8009732:	f023 0303 	bic.w	r3, r3, #3
 8009736:	1d1a      	adds	r2, r3, #4
 8009738:	687b      	ldr	r3, [r7, #4]
 800973a:	659a      	str	r2, [r3, #88]	@ 0x58
 800973c:	e007      	b.n	800974e <DMA_CalcBaseAndBitshift+0x52>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 800973e:	687b      	ldr	r3, [r7, #4]
 8009740:	681b      	ldr	r3, [r3, #0]
 8009742:	f423 737f 	bic.w	r3, r3, #1020	@ 0x3fc
 8009746:	f023 0303 	bic.w	r3, r3, #3
 800974a:	687a      	ldr	r2, [r7, #4]
 800974c:	6593      	str	r3, [r2, #88]	@ 0x58
  }
  
  return hdma->StreamBaseAddress;
 800974e:	687b      	ldr	r3, [r7, #4]
 8009750:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
}
 8009752:	4618      	mov	r0, r3
 8009754:	3714      	adds	r7, #20
 8009756:	46bd      	mov	sp, r7
 8009758:	f85d 7b04 	ldr.w	r7, [sp], #4
 800975c:	4770      	bx	lr
 800975e:	bf00      	nop
 8009760:	aaaaaaab 	.word	0xaaaaaaab
 8009764:	080350d4 	.word	0x080350d4

08009768 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 8009768:	b480      	push	{r7}
 800976a:	b085      	sub	sp, #20
 800976c:	af00      	add	r7, sp, #0
 800976e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8009770:	2300      	movs	r3, #0
 8009772:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 8009774:	687b      	ldr	r3, [r7, #4]
 8009776:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8009778:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800977a:	687b      	ldr	r3, [r7, #4]
 800977c:	699b      	ldr	r3, [r3, #24]
 800977e:	2b00      	cmp	r3, #0
 8009780:	d11f      	bne.n	80097c2 <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 8009782:	68bb      	ldr	r3, [r7, #8]
 8009784:	2b03      	cmp	r3, #3
 8009786:	d856      	bhi.n	8009836 <DMA_CheckFifoParam+0xce>
 8009788:	a201      	add	r2, pc, #4	@ (adr r2, 8009790 <DMA_CheckFifoParam+0x28>)
 800978a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800978e:	bf00      	nop
 8009790:	080097a1 	.word	0x080097a1
 8009794:	080097b3 	.word	0x080097b3
 8009798:	080097a1 	.word	0x080097a1
 800979c:	08009837 	.word	0x08009837
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80097a0:	687b      	ldr	r3, [r7, #4]
 80097a2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80097a4:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80097a8:	2b00      	cmp	r3, #0
 80097aa:	d046      	beq.n	800983a <DMA_CheckFifoParam+0xd2>
      {
        status = HAL_ERROR;
 80097ac:	2301      	movs	r3, #1
 80097ae:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80097b0:	e043      	b.n	800983a <DMA_CheckFifoParam+0xd2>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80097b2:	687b      	ldr	r3, [r7, #4]
 80097b4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80097b6:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 80097ba:	d140      	bne.n	800983e <DMA_CheckFifoParam+0xd6>
      {
        status = HAL_ERROR;
 80097bc:	2301      	movs	r3, #1
 80097be:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80097c0:	e03d      	b.n	800983e <DMA_CheckFifoParam+0xd6>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80097c2:	687b      	ldr	r3, [r7, #4]
 80097c4:	699b      	ldr	r3, [r3, #24]
 80097c6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80097ca:	d121      	bne.n	8009810 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 80097cc:	68bb      	ldr	r3, [r7, #8]
 80097ce:	2b03      	cmp	r3, #3
 80097d0:	d837      	bhi.n	8009842 <DMA_CheckFifoParam+0xda>
 80097d2:	a201      	add	r2, pc, #4	@ (adr r2, 80097d8 <DMA_CheckFifoParam+0x70>)
 80097d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80097d8:	080097e9 	.word	0x080097e9
 80097dc:	080097ef 	.word	0x080097ef
 80097e0:	080097e9 	.word	0x080097e9
 80097e4:	08009801 	.word	0x08009801
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 80097e8:	2301      	movs	r3, #1
 80097ea:	73fb      	strb	r3, [r7, #15]
      break;
 80097ec:	e030      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80097ee:	687b      	ldr	r3, [r7, #4]
 80097f0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80097f2:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 80097f6:	2b00      	cmp	r3, #0
 80097f8:	d025      	beq.n	8009846 <DMA_CheckFifoParam+0xde>
      {
        status = HAL_ERROR;
 80097fa:	2301      	movs	r3, #1
 80097fc:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80097fe:	e022      	b.n	8009846 <DMA_CheckFifoParam+0xde>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8009800:	687b      	ldr	r3, [r7, #4]
 8009802:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009804:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 8009808:	d11f      	bne.n	800984a <DMA_CheckFifoParam+0xe2>
      {
        status = HAL_ERROR;
 800980a:	2301      	movs	r3, #1
 800980c:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 800980e:	e01c      	b.n	800984a <DMA_CheckFifoParam+0xe2>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8009810:	68bb      	ldr	r3, [r7, #8]
 8009812:	2b02      	cmp	r3, #2
 8009814:	d903      	bls.n	800981e <DMA_CheckFifoParam+0xb6>
 8009816:	68bb      	ldr	r3, [r7, #8]
 8009818:	2b03      	cmp	r3, #3
 800981a:	d003      	beq.n	8009824 <DMA_CheckFifoParam+0xbc>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 800981c:	e018      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      status = HAL_ERROR;
 800981e:	2301      	movs	r3, #1
 8009820:	73fb      	strb	r3, [r7, #15]
      break;
 8009822:	e015      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8009824:	687b      	ldr	r3, [r7, #4]
 8009826:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009828:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 800982c:	2b00      	cmp	r3, #0
 800982e:	d00e      	beq.n	800984e <DMA_CheckFifoParam+0xe6>
        status = HAL_ERROR;
 8009830:	2301      	movs	r3, #1
 8009832:	73fb      	strb	r3, [r7, #15]
      break;
 8009834:	e00b      	b.n	800984e <DMA_CheckFifoParam+0xe6>
      break;
 8009836:	bf00      	nop
 8009838:	e00a      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      break;
 800983a:	bf00      	nop
 800983c:	e008      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      break;
 800983e:	bf00      	nop
 8009840:	e006      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      break;
 8009842:	bf00      	nop
 8009844:	e004      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      break;
 8009846:	bf00      	nop
 8009848:	e002      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      break;   
 800984a:	bf00      	nop
 800984c:	e000      	b.n	8009850 <DMA_CheckFifoParam+0xe8>
      break;
 800984e:	bf00      	nop
    }
  } 
  
  return status; 
 8009850:	7bfb      	ldrb	r3, [r7, #15]
}
 8009852:	4618      	mov	r0, r3
 8009854:	3714      	adds	r7, #20
 8009856:	46bd      	mov	sp, r7
 8009858:	f85d 7b04 	ldr.w	r7, [sp], #4
 800985c:	4770      	bx	lr
 800985e:	bf00      	nop

08009860 <HAL_FLASH_Program>:
  * @param  Data specifies the data to be programmed
  * 
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
{
 8009860:	b580      	push	{r7, lr}
 8009862:	b086      	sub	sp, #24
 8009864:	af00      	add	r7, sp, #0
 8009866:	60f8      	str	r0, [r7, #12]
 8009868:	60b9      	str	r1, [r7, #8]
 800986a:	e9c7 2300 	strd	r2, r3, [r7]
  HAL_StatusTypeDef status = HAL_ERROR;
 800986e:	2301      	movs	r3, #1
 8009870:	75fb      	strb	r3, [r7, #23]
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8009872:	4b23      	ldr	r3, [pc, #140]	@ (8009900 <HAL_FLASH_Program+0xa0>)
 8009874:	7e1b      	ldrb	r3, [r3, #24]
 8009876:	2b01      	cmp	r3, #1
 8009878:	d101      	bne.n	800987e <HAL_FLASH_Program+0x1e>
 800987a:	2302      	movs	r3, #2
 800987c:	e03b      	b.n	80098f6 <HAL_FLASH_Program+0x96>
 800987e:	4b20      	ldr	r3, [pc, #128]	@ (8009900 <HAL_FLASH_Program+0xa0>)
 8009880:	2201      	movs	r2, #1
 8009882:	761a      	strb	r2, [r3, #24]
  
  /* Check the parameters */
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009884:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8009888:	f000 f870 	bl	800996c <FLASH_WaitForLastOperation>
 800988c:	4603      	mov	r3, r0
 800988e:	75fb      	strb	r3, [r7, #23]
  
  if(status == HAL_OK)
 8009890:	7dfb      	ldrb	r3, [r7, #23]
 8009892:	2b00      	cmp	r3, #0
 8009894:	d12b      	bne.n	80098ee <HAL_FLASH_Program+0x8e>
  {
    if(TypeProgram == FLASH_TYPEPROGRAM_BYTE)
 8009896:	68fb      	ldr	r3, [r7, #12]
 8009898:	2b00      	cmp	r3, #0
 800989a:	d105      	bne.n	80098a8 <HAL_FLASH_Program+0x48>
    {
      /*Program byte (8-bit) at a specified address.*/
      FLASH_Program_Byte(Address, (uint8_t) Data);
 800989c:	783b      	ldrb	r3, [r7, #0]
 800989e:	4619      	mov	r1, r3
 80098a0:	68b8      	ldr	r0, [r7, #8]
 80098a2:	f000 f91b 	bl	8009adc <FLASH_Program_Byte>
 80098a6:	e016      	b.n	80098d6 <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 80098a8:	68fb      	ldr	r3, [r7, #12]
 80098aa:	2b01      	cmp	r3, #1
 80098ac:	d105      	bne.n	80098ba <HAL_FLASH_Program+0x5a>
    {
      /*Program halfword (16-bit) at a specified address.*/
      FLASH_Program_HalfWord(Address, (uint16_t) Data);
 80098ae:	883b      	ldrh	r3, [r7, #0]
 80098b0:	4619      	mov	r1, r3
 80098b2:	68b8      	ldr	r0, [r7, #8]
 80098b4:	f000 f8ee 	bl	8009a94 <FLASH_Program_HalfWord>
 80098b8:	e00d      	b.n	80098d6 <HAL_FLASH_Program+0x76>
    }
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 80098ba:	68fb      	ldr	r3, [r7, #12]
 80098bc:	2b02      	cmp	r3, #2
 80098be:	d105      	bne.n	80098cc <HAL_FLASH_Program+0x6c>
    {
      /*Program word (32-bit) at a specified address.*/
      FLASH_Program_Word(Address, (uint32_t) Data);
 80098c0:	683b      	ldr	r3, [r7, #0]
 80098c2:	4619      	mov	r1, r3
 80098c4:	68b8      	ldr	r0, [r7, #8]
 80098c6:	f000 f8c3 	bl	8009a50 <FLASH_Program_Word>
 80098ca:	e004      	b.n	80098d6 <HAL_FLASH_Program+0x76>
    }
    else
    {
      /*Program double word (64-bit) at a specified address.*/
      FLASH_Program_DoubleWord(Address, Data);
 80098cc:	e9d7 2300 	ldrd	r2, r3, [r7]
 80098d0:	68b8      	ldr	r0, [r7, #8]
 80098d2:	f000 f88b 	bl	80099ec <FLASH_Program_DoubleWord>
    }
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80098d6:	f24c 3050 	movw	r0, #50000	@ 0xc350
 80098da:	f000 f847 	bl	800996c <FLASH_WaitForLastOperation>
 80098de:	4603      	mov	r3, r0
 80098e0:	75fb      	strb	r3, [r7, #23]
    
    /* If the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);  
 80098e2:	4b08      	ldr	r3, [pc, #32]	@ (8009904 <HAL_FLASH_Program+0xa4>)
 80098e4:	691b      	ldr	r3, [r3, #16]
 80098e6:	4a07      	ldr	r2, [pc, #28]	@ (8009904 <HAL_FLASH_Program+0xa4>)
 80098e8:	f023 0301 	bic.w	r3, r3, #1
 80098ec:	6113      	str	r3, [r2, #16]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 80098ee:	4b04      	ldr	r3, [pc, #16]	@ (8009900 <HAL_FLASH_Program+0xa0>)
 80098f0:	2200      	movs	r2, #0
 80098f2:	761a      	strb	r2, [r3, #24]
  
  return status;
 80098f4:	7dfb      	ldrb	r3, [r7, #23]
}
 80098f6:	4618      	mov	r0, r3
 80098f8:	3718      	adds	r7, #24
 80098fa:	46bd      	mov	sp, r7
 80098fc:	bd80      	pop	{r7, pc}
 80098fe:	bf00      	nop
 8009900:	2000a7c0 	.word	0x2000a7c0
 8009904:	40023c00 	.word	0x40023c00

08009908 <HAL_FLASH_Unlock>:
/**
  * @brief  Unlock the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
 8009908:	b480      	push	{r7}
 800990a:	b083      	sub	sp, #12
 800990c:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef status = HAL_OK;
 800990e:	2300      	movs	r3, #0
 8009910:	71fb      	strb	r3, [r7, #7]

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8009912:	4b0b      	ldr	r3, [pc, #44]	@ (8009940 <HAL_FLASH_Unlock+0x38>)
 8009914:	691b      	ldr	r3, [r3, #16]
 8009916:	2b00      	cmp	r3, #0
 8009918:	da0b      	bge.n	8009932 <HAL_FLASH_Unlock+0x2a>
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 800991a:	4b09      	ldr	r3, [pc, #36]	@ (8009940 <HAL_FLASH_Unlock+0x38>)
 800991c:	4a09      	ldr	r2, [pc, #36]	@ (8009944 <HAL_FLASH_Unlock+0x3c>)
 800991e:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8009920:	4b07      	ldr	r3, [pc, #28]	@ (8009940 <HAL_FLASH_Unlock+0x38>)
 8009922:	4a09      	ldr	r2, [pc, #36]	@ (8009948 <HAL_FLASH_Unlock+0x40>)
 8009924:	605a      	str	r2, [r3, #4]

    /* Verify Flash is unlocked */
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8009926:	4b06      	ldr	r3, [pc, #24]	@ (8009940 <HAL_FLASH_Unlock+0x38>)
 8009928:	691b      	ldr	r3, [r3, #16]
 800992a:	2b00      	cmp	r3, #0
 800992c:	da01      	bge.n	8009932 <HAL_FLASH_Unlock+0x2a>
    {
      status = HAL_ERROR;
 800992e:	2301      	movs	r3, #1
 8009930:	71fb      	strb	r3, [r7, #7]
    }
  }

  return status;
 8009932:	79fb      	ldrb	r3, [r7, #7]
}
 8009934:	4618      	mov	r0, r3
 8009936:	370c      	adds	r7, #12
 8009938:	46bd      	mov	sp, r7
 800993a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800993e:	4770      	bx	lr
 8009940:	40023c00 	.word	0x40023c00
 8009944:	45670123 	.word	0x45670123
 8009948:	cdef89ab 	.word	0xcdef89ab

0800994c <HAL_FLASH_Lock>:
/**
  * @brief  Locks the FLASH control register access
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
 800994c:	b480      	push	{r7}
 800994e:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8009950:	4b05      	ldr	r3, [pc, #20]	@ (8009968 <HAL_FLASH_Lock+0x1c>)
 8009952:	691b      	ldr	r3, [r3, #16]
 8009954:	4a04      	ldr	r2, [pc, #16]	@ (8009968 <HAL_FLASH_Lock+0x1c>)
 8009956:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 800995a:	6113      	str	r3, [r2, #16]
  
  return HAL_OK;  
 800995c:	2300      	movs	r3, #0
}
 800995e:	4618      	mov	r0, r3
 8009960:	46bd      	mov	sp, r7
 8009962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009966:	4770      	bx	lr
 8009968:	40023c00 	.word	0x40023c00

0800996c <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operationtimeout
  * @retval HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{ 
 800996c:	b580      	push	{r7, lr}
 800996e:	b084      	sub	sp, #16
 8009970:	af00      	add	r7, sp, #0
 8009972:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 8009974:	2300      	movs	r3, #0
 8009976:	60fb      	str	r3, [r7, #12]
  
  /* Clear Error Code */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8009978:	4b1a      	ldr	r3, [pc, #104]	@ (80099e4 <FLASH_WaitForLastOperation+0x78>)
 800997a:	2200      	movs	r2, #0
 800997c:	61da      	str	r2, [r3, #28]
  
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  /* Get tick */
  tickstart = HAL_GetTick();
 800997e:	f7ff f981 	bl	8008c84 <HAL_GetTick>
 8009982:	60f8      	str	r0, [r7, #12]

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 8009984:	e010      	b.n	80099a8 <FLASH_WaitForLastOperation+0x3c>
  { 
    if(Timeout != HAL_MAX_DELAY)
 8009986:	687b      	ldr	r3, [r7, #4]
 8009988:	f1b3 3fff 	cmp.w	r3, #4294967295
 800998c:	d00c      	beq.n	80099a8 <FLASH_WaitForLastOperation+0x3c>
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 800998e:	687b      	ldr	r3, [r7, #4]
 8009990:	2b00      	cmp	r3, #0
 8009992:	d007      	beq.n	80099a4 <FLASH_WaitForLastOperation+0x38>
 8009994:	f7ff f976 	bl	8008c84 <HAL_GetTick>
 8009998:	4602      	mov	r2, r0
 800999a:	68fb      	ldr	r3, [r7, #12]
 800999c:	1ad3      	subs	r3, r2, r3
 800999e:	687a      	ldr	r2, [r7, #4]
 80099a0:	429a      	cmp	r2, r3
 80099a2:	d201      	bcs.n	80099a8 <FLASH_WaitForLastOperation+0x3c>
      {
        return HAL_TIMEOUT;
 80099a4:	2303      	movs	r3, #3
 80099a6:	e019      	b.n	80099dc <FLASH_WaitForLastOperation+0x70>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET) 
 80099a8:	4b0f      	ldr	r3, [pc, #60]	@ (80099e8 <FLASH_WaitForLastOperation+0x7c>)
 80099aa:	68db      	ldr	r3, [r3, #12]
 80099ac:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80099b0:	2b00      	cmp	r3, #0
 80099b2:	d1e8      	bne.n	8009986 <FLASH_WaitForLastOperation+0x1a>
      }
    } 
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != RESET)
 80099b4:	4b0c      	ldr	r3, [pc, #48]	@ (80099e8 <FLASH_WaitForLastOperation+0x7c>)
 80099b6:	68db      	ldr	r3, [r3, #12]
 80099b8:	f003 0301 	and.w	r3, r3, #1
 80099bc:	2b00      	cmp	r3, #0
 80099be:	d002      	beq.n	80099c6 <FLASH_WaitForLastOperation+0x5a>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 80099c0:	4b09      	ldr	r3, [pc, #36]	@ (80099e8 <FLASH_WaitForLastOperation+0x7c>)
 80099c2:	2201      	movs	r2, #1
 80099c4:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR)  
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
 80099c6:	4b08      	ldr	r3, [pc, #32]	@ (80099e8 <FLASH_WaitForLastOperation+0x7c>)
 80099c8:	68db      	ldr	r3, [r3, #12]
 80099ca:	f403 73f9 	and.w	r3, r3, #498	@ 0x1f2
 80099ce:	2b00      	cmp	r3, #0
 80099d0:	d003      	beq.n	80099da <FLASH_WaitForLastOperation+0x6e>
  if(__HAL_FLASH_GET_FLAG((FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | \
                           FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR)) != RESET)
#endif /* FLASH_SR_RDERR */
  {
    /*Save the error code*/
    FLASH_SetErrorCode();
 80099d2:	f000 f8a5 	bl	8009b20 <FLASH_SetErrorCode>
    return HAL_ERROR;
 80099d6:	2301      	movs	r3, #1
 80099d8:	e000      	b.n	80099dc <FLASH_WaitForLastOperation+0x70>
  }

  /* If there is no error flag set */
  return HAL_OK;
 80099da:	2300      	movs	r3, #0
  
}  
 80099dc:	4618      	mov	r0, r3
 80099de:	3710      	adds	r7, #16
 80099e0:	46bd      	mov	sp, r7
 80099e2:	bd80      	pop	{r7, pc}
 80099e4:	2000a7c0 	.word	0x2000a7c0
 80099e8:	40023c00 	.word	0x40023c00

080099ec <FLASH_Program_DoubleWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
{
 80099ec:	b480      	push	{r7}
 80099ee:	b085      	sub	sp, #20
 80099f0:	af00      	add	r7, sp, #0
 80099f2:	60f8      	str	r0, [r7, #12]
 80099f4:	e9c7 2300 	strd	r2, r3, [r7]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 80099f8:	4b14      	ldr	r3, [pc, #80]	@ (8009a4c <FLASH_Program_DoubleWord+0x60>)
 80099fa:	691b      	ldr	r3, [r3, #16]
 80099fc:	4a13      	ldr	r2, [pc, #76]	@ (8009a4c <FLASH_Program_DoubleWord+0x60>)
 80099fe:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8009a02:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8009a04:	4b11      	ldr	r3, [pc, #68]	@ (8009a4c <FLASH_Program_DoubleWord+0x60>)
 8009a06:	691b      	ldr	r3, [r3, #16]
 8009a08:	4a10      	ldr	r2, [pc, #64]	@ (8009a4c <FLASH_Program_DoubleWord+0x60>)
 8009a0a:	f443 7340 	orr.w	r3, r3, #768	@ 0x300
 8009a0e:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8009a10:	4b0e      	ldr	r3, [pc, #56]	@ (8009a4c <FLASH_Program_DoubleWord+0x60>)
 8009a12:	691b      	ldr	r3, [r3, #16]
 8009a14:	4a0d      	ldr	r2, [pc, #52]	@ (8009a4c <FLASH_Program_DoubleWord+0x60>)
 8009a16:	f043 0301 	orr.w	r3, r3, #1
 8009a1a:	6113      	str	r3, [r2, #16]

  /* Program first word */
  *(__IO uint32_t*)Address = (uint32_t)Data;
 8009a1c:	68fb      	ldr	r3, [r7, #12]
 8009a1e:	683a      	ldr	r2, [r7, #0]
 8009a20:	601a      	str	r2, [r3, #0]
  __ASM volatile ("isb 0xF":::"memory");
 8009a22:	f3bf 8f6f 	isb	sy
}
 8009a26:	bf00      	nop
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(__IO uint32_t*)(Address+4) = (uint32_t)(Data >> 32);
 8009a28:	e9d7 0100 	ldrd	r0, r1, [r7]
 8009a2c:	f04f 0200 	mov.w	r2, #0
 8009a30:	f04f 0300 	mov.w	r3, #0
 8009a34:	000a      	movs	r2, r1
 8009a36:	2300      	movs	r3, #0
 8009a38:	68f9      	ldr	r1, [r7, #12]
 8009a3a:	3104      	adds	r1, #4
 8009a3c:	4613      	mov	r3, r2
 8009a3e:	600b      	str	r3, [r1, #0]
}
 8009a40:	bf00      	nop
 8009a42:	3714      	adds	r7, #20
 8009a44:	46bd      	mov	sp, r7
 8009a46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a4a:	4770      	bx	lr
 8009a4c:	40023c00 	.word	0x40023c00

08009a50 <FLASH_Program_Word>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Word(uint32_t Address, uint32_t Data)
{
 8009a50:	b480      	push	{r7}
 8009a52:	b083      	sub	sp, #12
 8009a54:	af00      	add	r7, sp, #0
 8009a56:	6078      	str	r0, [r7, #4]
 8009a58:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8009a5a:	4b0d      	ldr	r3, [pc, #52]	@ (8009a90 <FLASH_Program_Word+0x40>)
 8009a5c:	691b      	ldr	r3, [r3, #16]
 8009a5e:	4a0c      	ldr	r2, [pc, #48]	@ (8009a90 <FLASH_Program_Word+0x40>)
 8009a60:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8009a64:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_WORD;
 8009a66:	4b0a      	ldr	r3, [pc, #40]	@ (8009a90 <FLASH_Program_Word+0x40>)
 8009a68:	691b      	ldr	r3, [r3, #16]
 8009a6a:	4a09      	ldr	r2, [pc, #36]	@ (8009a90 <FLASH_Program_Word+0x40>)
 8009a6c:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8009a70:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8009a72:	4b07      	ldr	r3, [pc, #28]	@ (8009a90 <FLASH_Program_Word+0x40>)
 8009a74:	691b      	ldr	r3, [r3, #16]
 8009a76:	4a06      	ldr	r2, [pc, #24]	@ (8009a90 <FLASH_Program_Word+0x40>)
 8009a78:	f043 0301 	orr.w	r3, r3, #1
 8009a7c:	6113      	str	r3, [r2, #16]

  *(__IO uint32_t*)Address = Data;
 8009a7e:	687b      	ldr	r3, [r7, #4]
 8009a80:	683a      	ldr	r2, [r7, #0]
 8009a82:	601a      	str	r2, [r3, #0]
}
 8009a84:	bf00      	nop
 8009a86:	370c      	adds	r7, #12
 8009a88:	46bd      	mov	sp, r7
 8009a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a8e:	4770      	bx	lr
 8009a90:	40023c00 	.word	0x40023c00

08009a94 <FLASH_Program_HalfWord>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
{
 8009a94:	b480      	push	{r7}
 8009a96:	b083      	sub	sp, #12
 8009a98:	af00      	add	r7, sp, #0
 8009a9a:	6078      	str	r0, [r7, #4]
 8009a9c:	460b      	mov	r3, r1
 8009a9e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8009aa0:	4b0d      	ldr	r3, [pc, #52]	@ (8009ad8 <FLASH_Program_HalfWord+0x44>)
 8009aa2:	691b      	ldr	r3, [r3, #16]
 8009aa4:	4a0c      	ldr	r2, [pc, #48]	@ (8009ad8 <FLASH_Program_HalfWord+0x44>)
 8009aa6:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8009aaa:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8009aac:	4b0a      	ldr	r3, [pc, #40]	@ (8009ad8 <FLASH_Program_HalfWord+0x44>)
 8009aae:	691b      	ldr	r3, [r3, #16]
 8009ab0:	4a09      	ldr	r2, [pc, #36]	@ (8009ad8 <FLASH_Program_HalfWord+0x44>)
 8009ab2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8009ab6:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8009ab8:	4b07      	ldr	r3, [pc, #28]	@ (8009ad8 <FLASH_Program_HalfWord+0x44>)
 8009aba:	691b      	ldr	r3, [r3, #16]
 8009abc:	4a06      	ldr	r2, [pc, #24]	@ (8009ad8 <FLASH_Program_HalfWord+0x44>)
 8009abe:	f043 0301 	orr.w	r3, r3, #1
 8009ac2:	6113      	str	r3, [r2, #16]

  *(__IO uint16_t*)Address = Data;
 8009ac4:	687b      	ldr	r3, [r7, #4]
 8009ac6:	887a      	ldrh	r2, [r7, #2]
 8009ac8:	801a      	strh	r2, [r3, #0]
}
 8009aca:	bf00      	nop
 8009acc:	370c      	adds	r7, #12
 8009ace:	46bd      	mov	sp, r7
 8009ad0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009ad4:	4770      	bx	lr
 8009ad6:	bf00      	nop
 8009ad8:	40023c00 	.word	0x40023c00

08009adc <FLASH_Program_Byte>:
  * @param  Address specifies the address to be programmed.
  * @param  Data specifies the data to be programmed.
  * @retval None
  */
static void FLASH_Program_Byte(uint32_t Address, uint8_t Data)
{
 8009adc:	b480      	push	{r7}
 8009ade:	b083      	sub	sp, #12
 8009ae0:	af00      	add	r7, sp, #0
 8009ae2:	6078      	str	r0, [r7, #4]
 8009ae4:	460b      	mov	r3, r1
 8009ae6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));
  
  /* If the previous operation is completed, proceed to program the new data */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8009ae8:	4b0c      	ldr	r3, [pc, #48]	@ (8009b1c <FLASH_Program_Byte+0x40>)
 8009aea:	691b      	ldr	r3, [r3, #16]
 8009aec:	4a0b      	ldr	r2, [pc, #44]	@ (8009b1c <FLASH_Program_Byte+0x40>)
 8009aee:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8009af2:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_PSIZE_BYTE;
 8009af4:	4b09      	ldr	r3, [pc, #36]	@ (8009b1c <FLASH_Program_Byte+0x40>)
 8009af6:	4a09      	ldr	r2, [pc, #36]	@ (8009b1c <FLASH_Program_Byte+0x40>)
 8009af8:	691b      	ldr	r3, [r3, #16]
 8009afa:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_PG;
 8009afc:	4b07      	ldr	r3, [pc, #28]	@ (8009b1c <FLASH_Program_Byte+0x40>)
 8009afe:	691b      	ldr	r3, [r3, #16]
 8009b00:	4a06      	ldr	r2, [pc, #24]	@ (8009b1c <FLASH_Program_Byte+0x40>)
 8009b02:	f043 0301 	orr.w	r3, r3, #1
 8009b06:	6113      	str	r3, [r2, #16]

  *(__IO uint8_t*)Address = Data;
 8009b08:	687b      	ldr	r3, [r7, #4]
 8009b0a:	78fa      	ldrb	r2, [r7, #3]
 8009b0c:	701a      	strb	r2, [r3, #0]
}
 8009b0e:	bf00      	nop
 8009b10:	370c      	adds	r7, #12
 8009b12:	46bd      	mov	sp, r7
 8009b14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b18:	4770      	bx	lr
 8009b1a:	bf00      	nop
 8009b1c:	40023c00 	.word	0x40023c00

08009b20 <FLASH_SetErrorCode>:
/**
  * @brief  Set the specific FLASH error flag.
  * @retval None
  */
static void FLASH_SetErrorCode(void)
{ 
 8009b20:	b480      	push	{r7}
 8009b22:	af00      	add	r7, sp, #0
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) != RESET)
 8009b24:	4b2f      	ldr	r3, [pc, #188]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b26:	68db      	ldr	r3, [r3, #12]
 8009b28:	f003 0310 	and.w	r3, r3, #16
 8009b2c:	2b00      	cmp	r3, #0
 8009b2e:	d008      	beq.n	8009b42 <FLASH_SetErrorCode+0x22>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8009b30:	4b2d      	ldr	r3, [pc, #180]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b32:	69db      	ldr	r3, [r3, #28]
 8009b34:	f043 0310 	orr.w	r3, r3, #16
 8009b38:	4a2b      	ldr	r2, [pc, #172]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b3a:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH write protection error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_WRPERR);
 8009b3c:	4b29      	ldr	r3, [pc, #164]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b3e:	2210      	movs	r2, #16
 8009b40:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGAERR) != RESET)
 8009b42:	4b28      	ldr	r3, [pc, #160]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b44:	68db      	ldr	r3, [r3, #12]
 8009b46:	f003 0320 	and.w	r3, r3, #32
 8009b4a:	2b00      	cmp	r3, #0
 8009b4c:	d008      	beq.n	8009b60 <FLASH_SetErrorCode+0x40>
  {
   pFlash.ErrorCode |= HAL_FLASH_ERROR_PGA;
 8009b4e:	4b26      	ldr	r3, [pc, #152]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b50:	69db      	ldr	r3, [r3, #28]
 8009b52:	f043 0308 	orr.w	r3, r3, #8
 8009b56:	4a24      	ldr	r2, [pc, #144]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b58:	61d3      	str	r3, [r2, #28]
   
   /* Clear FLASH Programming alignment error pending bit */
   __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGAERR);
 8009b5a:	4b22      	ldr	r3, [pc, #136]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b5c:	2220      	movs	r2, #32
 8009b5e:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGPERR) != RESET)
 8009b60:	4b20      	ldr	r3, [pc, #128]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b62:	68db      	ldr	r3, [r3, #12]
 8009b64:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8009b68:	2b00      	cmp	r3, #0
 8009b6a:	d008      	beq.n	8009b7e <FLASH_SetErrorCode+0x5e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGP;
 8009b6c:	4b1e      	ldr	r3, [pc, #120]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b6e:	69db      	ldr	r3, [r3, #28]
 8009b70:	f043 0304 	orr.w	r3, r3, #4
 8009b74:	4a1c      	ldr	r2, [pc, #112]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b76:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming parallelism error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGPERR);
 8009b78:	4b1a      	ldr	r3, [pc, #104]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b7a:	2240      	movs	r2, #64	@ 0x40
 8009b7c:	60da      	str	r2, [r3, #12]
  }
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGSERR) != RESET)
 8009b7e:	4b19      	ldr	r3, [pc, #100]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b80:	68db      	ldr	r3, [r3, #12]
 8009b82:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8009b86:	2b00      	cmp	r3, #0
 8009b88:	d008      	beq.n	8009b9c <FLASH_SetErrorCode+0x7c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PGS;
 8009b8a:	4b17      	ldr	r3, [pc, #92]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b8c:	69db      	ldr	r3, [r3, #28]
 8009b8e:	f043 0302 	orr.w	r3, r3, #2
 8009b92:	4a15      	ldr	r2, [pc, #84]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009b94:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Programming sequence error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_PGSERR);
 8009b96:	4b13      	ldr	r3, [pc, #76]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b98:	2280      	movs	r2, #128	@ 0x80
 8009b9a:	60da      	str	r2, [r3, #12]
  }
#if defined(FLASH_SR_RDERR) 
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) != RESET)
 8009b9c:	4b11      	ldr	r3, [pc, #68]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009b9e:	68db      	ldr	r3, [r3, #12]
 8009ba0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009ba4:	2b00      	cmp	r3, #0
 8009ba6:	d009      	beq.n	8009bbc <FLASH_SetErrorCode+0x9c>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_RD;
 8009ba8:	4b0f      	ldr	r3, [pc, #60]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009baa:	69db      	ldr	r3, [r3, #28]
 8009bac:	f043 0301 	orr.w	r3, r3, #1
 8009bb0:	4a0d      	ldr	r2, [pc, #52]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009bb2:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Proprietary readout protection error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
 8009bb4:	4b0b      	ldr	r3, [pc, #44]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009bb6:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8009bba:	60da      	str	r2, [r3, #12]
  }
#endif /* FLASH_SR_RDERR */  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPERR) != RESET)
 8009bbc:	4b09      	ldr	r3, [pc, #36]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009bbe:	68db      	ldr	r3, [r3, #12]
 8009bc0:	f003 0302 	and.w	r3, r3, #2
 8009bc4:	2b00      	cmp	r3, #0
 8009bc6:	d008      	beq.n	8009bda <FLASH_SetErrorCode+0xba>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_OPERATION;
 8009bc8:	4b07      	ldr	r3, [pc, #28]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009bca:	69db      	ldr	r3, [r3, #28]
 8009bcc:	f043 0320 	orr.w	r3, r3, #32
 8009bd0:	4a05      	ldr	r2, [pc, #20]	@ (8009be8 <FLASH_SetErrorCode+0xc8>)
 8009bd2:	61d3      	str	r3, [r2, #28]
    
    /* Clear FLASH Operation error pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPERR);
 8009bd4:	4b03      	ldr	r3, [pc, #12]	@ (8009be4 <FLASH_SetErrorCode+0xc4>)
 8009bd6:	2202      	movs	r2, #2
 8009bd8:	60da      	str	r2, [r3, #12]
  }
}
 8009bda:	bf00      	nop
 8009bdc:	46bd      	mov	sp, r7
 8009bde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009be2:	4770      	bx	lr
 8009be4:	40023c00 	.word	0x40023c00
 8009be8:	2000a7c0 	.word	0x2000a7c0

08009bec <HAL_FLASHEx_Erase>:
  *         (0xFFFFFFFFU means that all the sectors have been correctly erased)
  *
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *SectorError)
{
 8009bec:	b580      	push	{r7, lr}
 8009bee:	b084      	sub	sp, #16
 8009bf0:	af00      	add	r7, sp, #0
 8009bf2:	6078      	str	r0, [r7, #4]
 8009bf4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_ERROR;
 8009bf6:	2301      	movs	r3, #1
 8009bf8:	73fb      	strb	r3, [r7, #15]
  uint32_t index = 0U;
 8009bfa:	2300      	movs	r3, #0
 8009bfc:	60bb      	str	r3, [r7, #8]

  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8009bfe:	4b31      	ldr	r3, [pc, #196]	@ (8009cc4 <HAL_FLASHEx_Erase+0xd8>)
 8009c00:	7e1b      	ldrb	r3, [r3, #24]
 8009c02:	2b01      	cmp	r3, #1
 8009c04:	d101      	bne.n	8009c0a <HAL_FLASHEx_Erase+0x1e>
 8009c06:	2302      	movs	r3, #2
 8009c08:	e058      	b.n	8009cbc <HAL_FLASHEx_Erase+0xd0>
 8009c0a:	4b2e      	ldr	r3, [pc, #184]	@ (8009cc4 <HAL_FLASHEx_Erase+0xd8>)
 8009c0c:	2201      	movs	r2, #1
 8009c0e:	761a      	strb	r2, [r3, #24]

  /* Check the parameters */
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009c10:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8009c14:	f7ff feaa 	bl	800996c <FLASH_WaitForLastOperation>
 8009c18:	4603      	mov	r3, r0
 8009c1a:	73fb      	strb	r3, [r7, #15]

  if (status == HAL_OK)
 8009c1c:	7bfb      	ldrb	r3, [r7, #15]
 8009c1e:	2b00      	cmp	r3, #0
 8009c20:	d148      	bne.n	8009cb4 <HAL_FLASHEx_Erase+0xc8>
  {
    /*Initialization of SectorError variable*/
    *SectorError = 0xFFFFFFFFU;
 8009c22:	683b      	ldr	r3, [r7, #0]
 8009c24:	f04f 32ff 	mov.w	r2, #4294967295
 8009c28:	601a      	str	r2, [r3, #0]

    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8009c2a:	687b      	ldr	r3, [r7, #4]
 8009c2c:	681b      	ldr	r3, [r3, #0]
 8009c2e:	2b01      	cmp	r3, #1
 8009c30:	d115      	bne.n	8009c5e <HAL_FLASHEx_Erase+0x72>
    {
      /*Mass erase to be done*/
      FLASH_MassErase((uint8_t) pEraseInit->VoltageRange, pEraseInit->Banks);
 8009c32:	687b      	ldr	r3, [r7, #4]
 8009c34:	691b      	ldr	r3, [r3, #16]
 8009c36:	b2da      	uxtb	r2, r3
 8009c38:	687b      	ldr	r3, [r7, #4]
 8009c3a:	685b      	ldr	r3, [r3, #4]
 8009c3c:	4619      	mov	r1, r3
 8009c3e:	4610      	mov	r0, r2
 8009c40:	f000 f844 	bl	8009ccc <FLASH_MassErase>

      /* Wait for last operation to be completed */
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009c44:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8009c48:	f7ff fe90 	bl	800996c <FLASH_WaitForLastOperation>
 8009c4c:	4603      	mov	r3, r0
 8009c4e:	73fb      	strb	r3, [r7, #15]

      /* if the erase operation is completed, disable the MER Bit */
      FLASH->CR &= (~FLASH_MER_BIT);
 8009c50:	4b1d      	ldr	r3, [pc, #116]	@ (8009cc8 <HAL_FLASHEx_Erase+0xdc>)
 8009c52:	691b      	ldr	r3, [r3, #16]
 8009c54:	4a1c      	ldr	r2, [pc, #112]	@ (8009cc8 <HAL_FLASHEx_Erase+0xdc>)
 8009c56:	f023 0304 	bic.w	r3, r3, #4
 8009c5a:	6113      	str	r3, [r2, #16]
 8009c5c:	e028      	b.n	8009cb0 <HAL_FLASHEx_Erase+0xc4>
    {
      /* Check the parameters */
      assert_param(IS_FLASH_NBSECTORS(pEraseInit->NbSectors + pEraseInit->Sector));

      /* Erase by sector by sector to be done*/
      for (index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8009c5e:	687b      	ldr	r3, [r7, #4]
 8009c60:	689b      	ldr	r3, [r3, #8]
 8009c62:	60bb      	str	r3, [r7, #8]
 8009c64:	e01c      	b.n	8009ca0 <HAL_FLASHEx_Erase+0xb4>
      {
        FLASH_Erase_Sector(index, (uint8_t) pEraseInit->VoltageRange);
 8009c66:	687b      	ldr	r3, [r7, #4]
 8009c68:	691b      	ldr	r3, [r3, #16]
 8009c6a:	b2db      	uxtb	r3, r3
 8009c6c:	4619      	mov	r1, r3
 8009c6e:	68b8      	ldr	r0, [r7, #8]
 8009c70:	f000 f850 	bl	8009d14 <FLASH_Erase_Sector>

        /* Wait for last operation to be completed */
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8009c74:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8009c78:	f7ff fe78 	bl	800996c <FLASH_WaitForLastOperation>
 8009c7c:	4603      	mov	r3, r0
 8009c7e:	73fb      	strb	r3, [r7, #15]

        /* If the erase operation is completed, disable the SER and SNB Bits */
        CLEAR_BIT(FLASH->CR, (FLASH_CR_SER | FLASH_CR_SNB));
 8009c80:	4b11      	ldr	r3, [pc, #68]	@ (8009cc8 <HAL_FLASHEx_Erase+0xdc>)
 8009c82:	691b      	ldr	r3, [r3, #16]
 8009c84:	4a10      	ldr	r2, [pc, #64]	@ (8009cc8 <HAL_FLASHEx_Erase+0xdc>)
 8009c86:	f023 03fa 	bic.w	r3, r3, #250	@ 0xfa
 8009c8a:	6113      	str	r3, [r2, #16]

        if (status != HAL_OK)
 8009c8c:	7bfb      	ldrb	r3, [r7, #15]
 8009c8e:	2b00      	cmp	r3, #0
 8009c90:	d003      	beq.n	8009c9a <HAL_FLASHEx_Erase+0xae>
        {
          /* In case of error, stop erase procedure and return the faulty sector*/
          *SectorError = index;
 8009c92:	683b      	ldr	r3, [r7, #0]
 8009c94:	68ba      	ldr	r2, [r7, #8]
 8009c96:	601a      	str	r2, [r3, #0]
          break;
 8009c98:	e00a      	b.n	8009cb0 <HAL_FLASHEx_Erase+0xc4>
      for (index = pEraseInit->Sector; index < (pEraseInit->NbSectors + pEraseInit->Sector); index++)
 8009c9a:	68bb      	ldr	r3, [r7, #8]
 8009c9c:	3301      	adds	r3, #1
 8009c9e:	60bb      	str	r3, [r7, #8]
 8009ca0:	687b      	ldr	r3, [r7, #4]
 8009ca2:	68da      	ldr	r2, [r3, #12]
 8009ca4:	687b      	ldr	r3, [r7, #4]
 8009ca6:	689b      	ldr	r3, [r3, #8]
 8009ca8:	4413      	add	r3, r2
 8009caa:	68ba      	ldr	r2, [r7, #8]
 8009cac:	429a      	cmp	r2, r3
 8009cae:	d3da      	bcc.n	8009c66 <HAL_FLASHEx_Erase+0x7a>
        }
      }
    }
    /* Flush the caches to be sure of the data consistency */
    FLASH_FlushCaches();
 8009cb0:	f000 f878 	bl	8009da4 <FLASH_FlushCaches>
  }

  /* Process Unlocked */
  __HAL_UNLOCK(&pFlash);
 8009cb4:	4b03      	ldr	r3, [pc, #12]	@ (8009cc4 <HAL_FLASHEx_Erase+0xd8>)
 8009cb6:	2200      	movs	r2, #0
 8009cb8:	761a      	strb	r2, [r3, #24]

  return status;
 8009cba:	7bfb      	ldrb	r3, [r7, #15]
}
 8009cbc:	4618      	mov	r0, r3
 8009cbe:	3710      	adds	r7, #16
 8009cc0:	46bd      	mov	sp, r7
 8009cc2:	bd80      	pop	{r7, pc}
 8009cc4:	2000a7c0 	.word	0x2000a7c0
 8009cc8:	40023c00 	.word	0x40023c00

08009ccc <FLASH_MassErase>:
  *            @arg FLASH_BANK_1: Bank1 to be erased
  *
  * @retval None
  */
static void FLASH_MassErase(uint8_t VoltageRange, uint32_t Banks)
{
 8009ccc:	b480      	push	{r7}
 8009cce:	b083      	sub	sp, #12
 8009cd0:	af00      	add	r7, sp, #0
 8009cd2:	4603      	mov	r3, r0
 8009cd4:	6039      	str	r1, [r7, #0]
 8009cd6:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  assert_param(IS_FLASH_BANK(Banks));

  /* If the previous operation is completed, proceed to erase all sectors */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8009cd8:	4b0d      	ldr	r3, [pc, #52]	@ (8009d10 <FLASH_MassErase+0x44>)
 8009cda:	691b      	ldr	r3, [r3, #16]
 8009cdc:	4a0c      	ldr	r2, [pc, #48]	@ (8009d10 <FLASH_MassErase+0x44>)
 8009cde:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8009ce2:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_MER;
 8009ce4:	4b0a      	ldr	r3, [pc, #40]	@ (8009d10 <FLASH_MassErase+0x44>)
 8009ce6:	691b      	ldr	r3, [r3, #16]
 8009ce8:	4a09      	ldr	r2, [pc, #36]	@ (8009d10 <FLASH_MassErase+0x44>)
 8009cea:	f043 0304 	orr.w	r3, r3, #4
 8009cee:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT | ((uint32_t)VoltageRange << 8U);
 8009cf0:	4b07      	ldr	r3, [pc, #28]	@ (8009d10 <FLASH_MassErase+0x44>)
 8009cf2:	691a      	ldr	r2, [r3, #16]
 8009cf4:	79fb      	ldrb	r3, [r7, #7]
 8009cf6:	021b      	lsls	r3, r3, #8
 8009cf8:	4313      	orrs	r3, r2
 8009cfa:	4a05      	ldr	r2, [pc, #20]	@ (8009d10 <FLASH_MassErase+0x44>)
 8009cfc:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8009d00:	6113      	str	r3, [r2, #16]
}
 8009d02:	bf00      	nop
 8009d04:	370c      	adds	r7, #12
 8009d06:	46bd      	mov	sp, r7
 8009d08:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d0c:	4770      	bx	lr
 8009d0e:	bf00      	nop
 8009d10:	40023c00 	.word	0x40023c00

08009d14 <FLASH_Erase_Sector>:
  *                                  the operation will be done by double word (64-bit)
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint8_t VoltageRange)
{
 8009d14:	b480      	push	{r7}
 8009d16:	b085      	sub	sp, #20
 8009d18:	af00      	add	r7, sp, #0
 8009d1a:	6078      	str	r0, [r7, #4]
 8009d1c:	460b      	mov	r3, r1
 8009d1e:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0U;
 8009d20:	2300      	movs	r3, #0
 8009d22:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));

  if (VoltageRange == FLASH_VOLTAGE_RANGE_1)
 8009d24:	78fb      	ldrb	r3, [r7, #3]
 8009d26:	2b00      	cmp	r3, #0
 8009d28:	d102      	bne.n	8009d30 <FLASH_Erase_Sector+0x1c>
  {
    tmp_psize = FLASH_PSIZE_BYTE;
 8009d2a:	2300      	movs	r3, #0
 8009d2c:	60fb      	str	r3, [r7, #12]
 8009d2e:	e010      	b.n	8009d52 <FLASH_Erase_Sector+0x3e>
  }
  else if (VoltageRange == FLASH_VOLTAGE_RANGE_2)
 8009d30:	78fb      	ldrb	r3, [r7, #3]
 8009d32:	2b01      	cmp	r3, #1
 8009d34:	d103      	bne.n	8009d3e <FLASH_Erase_Sector+0x2a>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8009d36:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8009d3a:	60fb      	str	r3, [r7, #12]
 8009d3c:	e009      	b.n	8009d52 <FLASH_Erase_Sector+0x3e>
  }
  else if (VoltageRange == FLASH_VOLTAGE_RANGE_3)
 8009d3e:	78fb      	ldrb	r3, [r7, #3]
 8009d40:	2b02      	cmp	r3, #2
 8009d42:	d103      	bne.n	8009d4c <FLASH_Erase_Sector+0x38>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 8009d44:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8009d48:	60fb      	str	r3, [r7, #12]
 8009d4a:	e002      	b.n	8009d52 <FLASH_Erase_Sector+0x3e>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8009d4c:	f44f 7340 	mov.w	r3, #768	@ 0x300
 8009d50:	60fb      	str	r3, [r7, #12]
  }

  /* If the previous operation is completed, proceed to erase the sector */
  CLEAR_BIT(FLASH->CR, FLASH_CR_PSIZE);
 8009d52:	4b13      	ldr	r3, [pc, #76]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d54:	691b      	ldr	r3, [r3, #16]
 8009d56:	4a12      	ldr	r2, [pc, #72]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d58:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8009d5c:	6113      	str	r3, [r2, #16]
  FLASH->CR |= tmp_psize;
 8009d5e:	4b10      	ldr	r3, [pc, #64]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d60:	691a      	ldr	r2, [r3, #16]
 8009d62:	490f      	ldr	r1, [pc, #60]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d64:	68fb      	ldr	r3, [r7, #12]
 8009d66:	4313      	orrs	r3, r2
 8009d68:	610b      	str	r3, [r1, #16]
  CLEAR_BIT(FLASH->CR, FLASH_CR_SNB);
 8009d6a:	4b0d      	ldr	r3, [pc, #52]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d6c:	691b      	ldr	r3, [r3, #16]
 8009d6e:	4a0c      	ldr	r2, [pc, #48]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d70:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8009d74:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos);
 8009d76:	4b0a      	ldr	r3, [pc, #40]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d78:	691a      	ldr	r2, [r3, #16]
 8009d7a:	687b      	ldr	r3, [r7, #4]
 8009d7c:	00db      	lsls	r3, r3, #3
 8009d7e:	4313      	orrs	r3, r2
 8009d80:	4a07      	ldr	r2, [pc, #28]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d82:	f043 0302 	orr.w	r3, r3, #2
 8009d86:	6113      	str	r3, [r2, #16]
  FLASH->CR |= FLASH_CR_STRT;
 8009d88:	4b05      	ldr	r3, [pc, #20]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d8a:	691b      	ldr	r3, [r3, #16]
 8009d8c:	4a04      	ldr	r2, [pc, #16]	@ (8009da0 <FLASH_Erase_Sector+0x8c>)
 8009d8e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8009d92:	6113      	str	r3, [r2, #16]
}
 8009d94:	bf00      	nop
 8009d96:	3714      	adds	r7, #20
 8009d98:	46bd      	mov	sp, r7
 8009d9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d9e:	4770      	bx	lr
 8009da0:	40023c00 	.word	0x40023c00

08009da4 <FLASH_FlushCaches>:
/**
  * @brief  Flush the instruction and data caches
  * @retval None
  */
void FLASH_FlushCaches(void)
{
 8009da4:	b480      	push	{r7}
 8009da6:	af00      	add	r7, sp, #0
  /* Flush instruction cache  */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != RESET)
 8009da8:	4b20      	ldr	r3, [pc, #128]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009daa:	681b      	ldr	r3, [r3, #0]
 8009dac:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8009db0:	2b00      	cmp	r3, #0
 8009db2:	d017      	beq.n	8009de4 <FLASH_FlushCaches+0x40>
  {
    /* Disable instruction cache  */
    __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8009db4:	4b1d      	ldr	r3, [pc, #116]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009db6:	681b      	ldr	r3, [r3, #0]
 8009db8:	4a1c      	ldr	r2, [pc, #112]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dba:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8009dbe:	6013      	str	r3, [r2, #0]
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 8009dc0:	4b1a      	ldr	r3, [pc, #104]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dc2:	681b      	ldr	r3, [r3, #0]
 8009dc4:	4a19      	ldr	r2, [pc, #100]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dc6:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8009dca:	6013      	str	r3, [r2, #0]
 8009dcc:	4b17      	ldr	r3, [pc, #92]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dce:	681b      	ldr	r3, [r3, #0]
 8009dd0:	4a16      	ldr	r2, [pc, #88]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dd2:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8009dd6:	6013      	str	r3, [r2, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8009dd8:	4b14      	ldr	r3, [pc, #80]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dda:	681b      	ldr	r3, [r3, #0]
 8009ddc:	4a13      	ldr	r2, [pc, #76]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dde:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8009de2:	6013      	str	r3, [r2, #0]
  }

  /* Flush data cache */
  if (READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != RESET)
 8009de4:	4b11      	ldr	r3, [pc, #68]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009de6:	681b      	ldr	r3, [r3, #0]
 8009de8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8009dec:	2b00      	cmp	r3, #0
 8009dee:	d017      	beq.n	8009e20 <FLASH_FlushCaches+0x7c>
  {
    /* Disable data cache  */
    __HAL_FLASH_DATA_CACHE_DISABLE();
 8009df0:	4b0e      	ldr	r3, [pc, #56]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009df2:	681b      	ldr	r3, [r3, #0]
 8009df4:	4a0d      	ldr	r2, [pc, #52]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009df6:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8009dfa:	6013      	str	r3, [r2, #0]
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 8009dfc:	4b0b      	ldr	r3, [pc, #44]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009dfe:	681b      	ldr	r3, [r3, #0]
 8009e00:	4a0a      	ldr	r2, [pc, #40]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009e02:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8009e06:	6013      	str	r3, [r2, #0]
 8009e08:	4b08      	ldr	r3, [pc, #32]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009e0a:	681b      	ldr	r3, [r3, #0]
 8009e0c:	4a07      	ldr	r2, [pc, #28]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009e0e:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8009e12:	6013      	str	r3, [r2, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 8009e14:	4b05      	ldr	r3, [pc, #20]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009e16:	681b      	ldr	r3, [r3, #0]
 8009e18:	4a04      	ldr	r2, [pc, #16]	@ (8009e2c <FLASH_FlushCaches+0x88>)
 8009e1a:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8009e1e:	6013      	str	r3, [r2, #0]
  }
}
 8009e20:	bf00      	nop
 8009e22:	46bd      	mov	sp, r7
 8009e24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009e28:	4770      	bx	lr
 8009e2a:	bf00      	nop
 8009e2c:	40023c00 	.word	0x40023c00

08009e30 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8009e30:	b480      	push	{r7}
 8009e32:	b089      	sub	sp, #36	@ 0x24
 8009e34:	af00      	add	r7, sp, #0
 8009e36:	6078      	str	r0, [r7, #4]
 8009e38:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 8009e3a:	2300      	movs	r3, #0
 8009e3c:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00U;
 8009e3e:	2300      	movs	r3, #0
 8009e40:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00U;
 8009e42:	2300      	movs	r3, #0
 8009e44:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8009e46:	2300      	movs	r3, #0
 8009e48:	61fb      	str	r3, [r7, #28]
 8009e4a:	e159      	b.n	800a100 <HAL_GPIO_Init+0x2d0>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 8009e4c:	2201      	movs	r2, #1
 8009e4e:	69fb      	ldr	r3, [r7, #28]
 8009e50:	fa02 f303 	lsl.w	r3, r2, r3
 8009e54:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8009e56:	683b      	ldr	r3, [r7, #0]
 8009e58:	681b      	ldr	r3, [r3, #0]
 8009e5a:	697a      	ldr	r2, [r7, #20]
 8009e5c:	4013      	ands	r3, r2
 8009e5e:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8009e60:	693a      	ldr	r2, [r7, #16]
 8009e62:	697b      	ldr	r3, [r7, #20]
 8009e64:	429a      	cmp	r2, r3
 8009e66:	f040 8148 	bne.w	800a0fa <HAL_GPIO_Init+0x2ca>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8009e6a:	683b      	ldr	r3, [r7, #0]
 8009e6c:	685b      	ldr	r3, [r3, #4]
 8009e6e:	f003 0303 	and.w	r3, r3, #3
 8009e72:	2b01      	cmp	r3, #1
 8009e74:	d005      	beq.n	8009e82 <HAL_GPIO_Init+0x52>
          (GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8009e76:	683b      	ldr	r3, [r7, #0]
 8009e78:	685b      	ldr	r3, [r3, #4]
 8009e7a:	f003 0303 	and.w	r3, r3, #3
      if(((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || \
 8009e7e:	2b02      	cmp	r3, #2
 8009e80:	d130      	bne.n	8009ee4 <HAL_GPIO_Init+0xb4>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8009e82:	687b      	ldr	r3, [r7, #4]
 8009e84:	689b      	ldr	r3, [r3, #8]
 8009e86:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8009e88:	69fb      	ldr	r3, [r7, #28]
 8009e8a:	005b      	lsls	r3, r3, #1
 8009e8c:	2203      	movs	r2, #3
 8009e8e:	fa02 f303 	lsl.w	r3, r2, r3
 8009e92:	43db      	mvns	r3, r3
 8009e94:	69ba      	ldr	r2, [r7, #24]
 8009e96:	4013      	ands	r3, r2
 8009e98:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8009e9a:	683b      	ldr	r3, [r7, #0]
 8009e9c:	68da      	ldr	r2, [r3, #12]
 8009e9e:	69fb      	ldr	r3, [r7, #28]
 8009ea0:	005b      	lsls	r3, r3, #1
 8009ea2:	fa02 f303 	lsl.w	r3, r2, r3
 8009ea6:	69ba      	ldr	r2, [r7, #24]
 8009ea8:	4313      	orrs	r3, r2
 8009eaa:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8009eac:	687b      	ldr	r3, [r7, #4]
 8009eae:	69ba      	ldr	r2, [r7, #24]
 8009eb0:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8009eb2:	687b      	ldr	r3, [r7, #4]
 8009eb4:	685b      	ldr	r3, [r3, #4]
 8009eb6:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8009eb8:	2201      	movs	r2, #1
 8009eba:	69fb      	ldr	r3, [r7, #28]
 8009ebc:	fa02 f303 	lsl.w	r3, r2, r3
 8009ec0:	43db      	mvns	r3, r3
 8009ec2:	69ba      	ldr	r2, [r7, #24]
 8009ec4:	4013      	ands	r3, r2
 8009ec6:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8009ec8:	683b      	ldr	r3, [r7, #0]
 8009eca:	685b      	ldr	r3, [r3, #4]
 8009ecc:	091b      	lsrs	r3, r3, #4
 8009ece:	f003 0201 	and.w	r2, r3, #1
 8009ed2:	69fb      	ldr	r3, [r7, #28]
 8009ed4:	fa02 f303 	lsl.w	r3, r2, r3
 8009ed8:	69ba      	ldr	r2, [r7, #24]
 8009eda:	4313      	orrs	r3, r2
 8009edc:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8009ede:	687b      	ldr	r3, [r7, #4]
 8009ee0:	69ba      	ldr	r2, [r7, #24]
 8009ee2:	605a      	str	r2, [r3, #4]
       }

      if((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8009ee4:	683b      	ldr	r3, [r7, #0]
 8009ee6:	685b      	ldr	r3, [r3, #4]
 8009ee8:	f003 0303 	and.w	r3, r3, #3
 8009eec:	2b03      	cmp	r3, #3
 8009eee:	d017      	beq.n	8009f20 <HAL_GPIO_Init+0xf0>
      {
        /* Check the parameters */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
        
        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
 8009ef0:	687b      	ldr	r3, [r7, #4]
 8009ef2:	68db      	ldr	r3, [r3, #12]
 8009ef4:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8009ef6:	69fb      	ldr	r3, [r7, #28]
 8009ef8:	005b      	lsls	r3, r3, #1
 8009efa:	2203      	movs	r2, #3
 8009efc:	fa02 f303 	lsl.w	r3, r2, r3
 8009f00:	43db      	mvns	r3, r3
 8009f02:	69ba      	ldr	r2, [r7, #24]
 8009f04:	4013      	ands	r3, r2
 8009f06:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Pull) << (position * 2U));
 8009f08:	683b      	ldr	r3, [r7, #0]
 8009f0a:	689a      	ldr	r2, [r3, #8]
 8009f0c:	69fb      	ldr	r3, [r7, #28]
 8009f0e:	005b      	lsls	r3, r3, #1
 8009f10:	fa02 f303 	lsl.w	r3, r2, r3
 8009f14:	69ba      	ldr	r2, [r7, #24]
 8009f16:	4313      	orrs	r3, r2
 8009f18:	61bb      	str	r3, [r7, #24]
        GPIOx->PUPDR = temp;
 8009f1a:	687b      	ldr	r3, [r7, #4]
 8009f1c:	69ba      	ldr	r2, [r7, #24]
 8009f1e:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8009f20:	683b      	ldr	r3, [r7, #0]
 8009f22:	685b      	ldr	r3, [r3, #4]
 8009f24:	f003 0303 	and.w	r3, r3, #3
 8009f28:	2b02      	cmp	r3, #2
 8009f2a:	d123      	bne.n	8009f74 <HAL_GPIO_Init+0x144>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8009f2c:	69fb      	ldr	r3, [r7, #28]
 8009f2e:	08da      	lsrs	r2, r3, #3
 8009f30:	687b      	ldr	r3, [r7, #4]
 8009f32:	3208      	adds	r2, #8
 8009f34:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8009f38:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8009f3a:	69fb      	ldr	r3, [r7, #28]
 8009f3c:	f003 0307 	and.w	r3, r3, #7
 8009f40:	009b      	lsls	r3, r3, #2
 8009f42:	220f      	movs	r2, #15
 8009f44:	fa02 f303 	lsl.w	r3, r2, r3
 8009f48:	43db      	mvns	r3, r3
 8009f4a:	69ba      	ldr	r2, [r7, #24]
 8009f4c:	4013      	ands	r3, r2
 8009f4e:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8009f50:	683b      	ldr	r3, [r7, #0]
 8009f52:	691a      	ldr	r2, [r3, #16]
 8009f54:	69fb      	ldr	r3, [r7, #28]
 8009f56:	f003 0307 	and.w	r3, r3, #7
 8009f5a:	009b      	lsls	r3, r3, #2
 8009f5c:	fa02 f303 	lsl.w	r3, r2, r3
 8009f60:	69ba      	ldr	r2, [r7, #24]
 8009f62:	4313      	orrs	r3, r2
 8009f64:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8009f66:	69fb      	ldr	r3, [r7, #28]
 8009f68:	08da      	lsrs	r2, r3, #3
 8009f6a:	687b      	ldr	r3, [r7, #4]
 8009f6c:	3208      	adds	r2, #8
 8009f6e:	69b9      	ldr	r1, [r7, #24]
 8009f70:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8009f74:	687b      	ldr	r3, [r7, #4]
 8009f76:	681b      	ldr	r3, [r3, #0]
 8009f78:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8009f7a:	69fb      	ldr	r3, [r7, #28]
 8009f7c:	005b      	lsls	r3, r3, #1
 8009f7e:	2203      	movs	r2, #3
 8009f80:	fa02 f303 	lsl.w	r3, r2, r3
 8009f84:	43db      	mvns	r3, r3
 8009f86:	69ba      	ldr	r2, [r7, #24]
 8009f88:	4013      	ands	r3, r2
 8009f8a:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8009f8c:	683b      	ldr	r3, [r7, #0]
 8009f8e:	685b      	ldr	r3, [r3, #4]
 8009f90:	f003 0203 	and.w	r2, r3, #3
 8009f94:	69fb      	ldr	r3, [r7, #28]
 8009f96:	005b      	lsls	r3, r3, #1
 8009f98:	fa02 f303 	lsl.w	r3, r2, r3
 8009f9c:	69ba      	ldr	r2, [r7, #24]
 8009f9e:	4313      	orrs	r3, r2
 8009fa0:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8009fa2:	687b      	ldr	r3, [r7, #4]
 8009fa4:	69ba      	ldr	r2, [r7, #24]
 8009fa6:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8009fa8:	683b      	ldr	r3, [r7, #0]
 8009faa:	685b      	ldr	r3, [r3, #4]
 8009fac:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8009fb0:	2b00      	cmp	r3, #0
 8009fb2:	f000 80a2 	beq.w	800a0fa <HAL_GPIO_Init+0x2ca>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8009fb6:	2300      	movs	r3, #0
 8009fb8:	60fb      	str	r3, [r7, #12]
 8009fba:	4b57      	ldr	r3, [pc, #348]	@ (800a118 <HAL_GPIO_Init+0x2e8>)
 8009fbc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8009fbe:	4a56      	ldr	r2, [pc, #344]	@ (800a118 <HAL_GPIO_Init+0x2e8>)
 8009fc0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8009fc4:	6453      	str	r3, [r2, #68]	@ 0x44
 8009fc6:	4b54      	ldr	r3, [pc, #336]	@ (800a118 <HAL_GPIO_Init+0x2e8>)
 8009fc8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8009fca:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8009fce:	60fb      	str	r3, [r7, #12]
 8009fd0:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8009fd2:	4a52      	ldr	r2, [pc, #328]	@ (800a11c <HAL_GPIO_Init+0x2ec>)
 8009fd4:	69fb      	ldr	r3, [r7, #28]
 8009fd6:	089b      	lsrs	r3, r3, #2
 8009fd8:	3302      	adds	r3, #2
 8009fda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009fde:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FU << (4U * (position & 0x03U)));
 8009fe0:	69fb      	ldr	r3, [r7, #28]
 8009fe2:	f003 0303 	and.w	r3, r3, #3
 8009fe6:	009b      	lsls	r3, r3, #2
 8009fe8:	220f      	movs	r2, #15
 8009fea:	fa02 f303 	lsl.w	r3, r2, r3
 8009fee:	43db      	mvns	r3, r3
 8009ff0:	69ba      	ldr	r2, [r7, #24]
 8009ff2:	4013      	ands	r3, r2
 8009ff4:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8009ff6:	687b      	ldr	r3, [r7, #4]
 8009ff8:	4a49      	ldr	r2, [pc, #292]	@ (800a120 <HAL_GPIO_Init+0x2f0>)
 8009ffa:	4293      	cmp	r3, r2
 8009ffc:	d019      	beq.n	800a032 <HAL_GPIO_Init+0x202>
 8009ffe:	687b      	ldr	r3, [r7, #4]
 800a000:	4a48      	ldr	r2, [pc, #288]	@ (800a124 <HAL_GPIO_Init+0x2f4>)
 800a002:	4293      	cmp	r3, r2
 800a004:	d013      	beq.n	800a02e <HAL_GPIO_Init+0x1fe>
 800a006:	687b      	ldr	r3, [r7, #4]
 800a008:	4a47      	ldr	r2, [pc, #284]	@ (800a128 <HAL_GPIO_Init+0x2f8>)
 800a00a:	4293      	cmp	r3, r2
 800a00c:	d00d      	beq.n	800a02a <HAL_GPIO_Init+0x1fa>
 800a00e:	687b      	ldr	r3, [r7, #4]
 800a010:	4a46      	ldr	r2, [pc, #280]	@ (800a12c <HAL_GPIO_Init+0x2fc>)
 800a012:	4293      	cmp	r3, r2
 800a014:	d007      	beq.n	800a026 <HAL_GPIO_Init+0x1f6>
 800a016:	687b      	ldr	r3, [r7, #4]
 800a018:	4a45      	ldr	r2, [pc, #276]	@ (800a130 <HAL_GPIO_Init+0x300>)
 800a01a:	4293      	cmp	r3, r2
 800a01c:	d101      	bne.n	800a022 <HAL_GPIO_Init+0x1f2>
 800a01e:	2304      	movs	r3, #4
 800a020:	e008      	b.n	800a034 <HAL_GPIO_Init+0x204>
 800a022:	2307      	movs	r3, #7
 800a024:	e006      	b.n	800a034 <HAL_GPIO_Init+0x204>
 800a026:	2303      	movs	r3, #3
 800a028:	e004      	b.n	800a034 <HAL_GPIO_Init+0x204>
 800a02a:	2302      	movs	r3, #2
 800a02c:	e002      	b.n	800a034 <HAL_GPIO_Init+0x204>
 800a02e:	2301      	movs	r3, #1
 800a030:	e000      	b.n	800a034 <HAL_GPIO_Init+0x204>
 800a032:	2300      	movs	r3, #0
 800a034:	69fa      	ldr	r2, [r7, #28]
 800a036:	f002 0203 	and.w	r2, r2, #3
 800a03a:	0092      	lsls	r2, r2, #2
 800a03c:	4093      	lsls	r3, r2
 800a03e:	69ba      	ldr	r2, [r7, #24]
 800a040:	4313      	orrs	r3, r2
 800a042:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800a044:	4935      	ldr	r1, [pc, #212]	@ (800a11c <HAL_GPIO_Init+0x2ec>)
 800a046:	69fb      	ldr	r3, [r7, #28]
 800a048:	089b      	lsrs	r3, r3, #2
 800a04a:	3302      	adds	r3, #2
 800a04c:	69ba      	ldr	r2, [r7, #24]
 800a04e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 800a052:	4b38      	ldr	r3, [pc, #224]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a054:	689b      	ldr	r3, [r3, #8]
 800a056:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800a058:	693b      	ldr	r3, [r7, #16]
 800a05a:	43db      	mvns	r3, r3
 800a05c:	69ba      	ldr	r2, [r7, #24]
 800a05e:	4013      	ands	r3, r2
 800a060:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800a062:	683b      	ldr	r3, [r7, #0]
 800a064:	685b      	ldr	r3, [r3, #4]
 800a066:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800a06a:	2b00      	cmp	r3, #0
 800a06c:	d003      	beq.n	800a076 <HAL_GPIO_Init+0x246>
        {
          temp |= iocurrent;
 800a06e:	69ba      	ldr	r2, [r7, #24]
 800a070:	693b      	ldr	r3, [r7, #16]
 800a072:	4313      	orrs	r3, r2
 800a074:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 800a076:	4a2f      	ldr	r2, [pc, #188]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a078:	69bb      	ldr	r3, [r7, #24]
 800a07a:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 800a07c:	4b2d      	ldr	r3, [pc, #180]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a07e:	68db      	ldr	r3, [r3, #12]
 800a080:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800a082:	693b      	ldr	r3, [r7, #16]
 800a084:	43db      	mvns	r3, r3
 800a086:	69ba      	ldr	r2, [r7, #24]
 800a088:	4013      	ands	r3, r2
 800a08a:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 800a08c:	683b      	ldr	r3, [r7, #0]
 800a08e:	685b      	ldr	r3, [r3, #4]
 800a090:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800a094:	2b00      	cmp	r3, #0
 800a096:	d003      	beq.n	800a0a0 <HAL_GPIO_Init+0x270>
        {
          temp |= iocurrent;
 800a098:	69ba      	ldr	r2, [r7, #24]
 800a09a:	693b      	ldr	r3, [r7, #16]
 800a09c:	4313      	orrs	r3, r2
 800a09e:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 800a0a0:	4a24      	ldr	r2, [pc, #144]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a0a2:	69bb      	ldr	r3, [r7, #24]
 800a0a4:	60d3      	str	r3, [r2, #12]

        temp = EXTI->EMR;
 800a0a6:	4b23      	ldr	r3, [pc, #140]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a0a8:	685b      	ldr	r3, [r3, #4]
 800a0aa:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800a0ac:	693b      	ldr	r3, [r7, #16]
 800a0ae:	43db      	mvns	r3, r3
 800a0b0:	69ba      	ldr	r2, [r7, #24]
 800a0b2:	4013      	ands	r3, r2
 800a0b4:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 800a0b6:	683b      	ldr	r3, [r7, #0]
 800a0b8:	685b      	ldr	r3, [r3, #4]
 800a0ba:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800a0be:	2b00      	cmp	r3, #0
 800a0c0:	d003      	beq.n	800a0ca <HAL_GPIO_Init+0x29a>
        {
          temp |= iocurrent;
 800a0c2:	69ba      	ldr	r2, [r7, #24]
 800a0c4:	693b      	ldr	r3, [r7, #16]
 800a0c6:	4313      	orrs	r3, r2
 800a0c8:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 800a0ca:	4a1a      	ldr	r2, [pc, #104]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a0cc:	69bb      	ldr	r3, [r7, #24]
 800a0ce:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800a0d0:	4b18      	ldr	r3, [pc, #96]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a0d2:	681b      	ldr	r3, [r3, #0]
 800a0d4:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 800a0d6:	693b      	ldr	r3, [r7, #16]
 800a0d8:	43db      	mvns	r3, r3
 800a0da:	69ba      	ldr	r2, [r7, #24]
 800a0dc:	4013      	ands	r3, r2
 800a0de:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800a0e0:	683b      	ldr	r3, [r7, #0]
 800a0e2:	685b      	ldr	r3, [r3, #4]
 800a0e4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800a0e8:	2b00      	cmp	r3, #0
 800a0ea:	d003      	beq.n	800a0f4 <HAL_GPIO_Init+0x2c4>
        {
          temp |= iocurrent;
 800a0ec:	69ba      	ldr	r2, [r7, #24]
 800a0ee:	693b      	ldr	r3, [r7, #16]
 800a0f0:	4313      	orrs	r3, r2
 800a0f2:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 800a0f4:	4a0f      	ldr	r2, [pc, #60]	@ (800a134 <HAL_GPIO_Init+0x304>)
 800a0f6:	69bb      	ldr	r3, [r7, #24]
 800a0f8:	6013      	str	r3, [r2, #0]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800a0fa:	69fb      	ldr	r3, [r7, #28]
 800a0fc:	3301      	adds	r3, #1
 800a0fe:	61fb      	str	r3, [r7, #28]
 800a100:	69fb      	ldr	r3, [r7, #28]
 800a102:	2b0f      	cmp	r3, #15
 800a104:	f67f aea2 	bls.w	8009e4c <HAL_GPIO_Init+0x1c>
      }
    }
  }
}
 800a108:	bf00      	nop
 800a10a:	bf00      	nop
 800a10c:	3724      	adds	r7, #36	@ 0x24
 800a10e:	46bd      	mov	sp, r7
 800a110:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a114:	4770      	bx	lr
 800a116:	bf00      	nop
 800a118:	40023800 	.word	0x40023800
 800a11c:	40013800 	.word	0x40013800
 800a120:	40020000 	.word	0x40020000
 800a124:	40020400 	.word	0x40020400
 800a128:	40020800 	.word	0x40020800
 800a12c:	40020c00 	.word	0x40020c00
 800a130:	40021000 	.word	0x40021000
 800a134:	40013c00 	.word	0x40013c00

0800a138 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 800a138:	b480      	push	{r7}
 800a13a:	b087      	sub	sp, #28
 800a13c:	af00      	add	r7, sp, #0
 800a13e:	6078      	str	r0, [r7, #4]
 800a140:	6039      	str	r1, [r7, #0]
  uint32_t position;
  uint32_t ioposition = 0x00U;
 800a142:	2300      	movs	r3, #0
 800a144:	613b      	str	r3, [r7, #16]
  uint32_t iocurrent = 0x00U;
 800a146:	2300      	movs	r3, #0
 800a148:	60fb      	str	r3, [r7, #12]
  uint32_t tmp = 0x00U;
 800a14a:	2300      	movs	r3, #0
 800a14c:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 800a14e:	2300      	movs	r3, #0
 800a150:	617b      	str	r3, [r7, #20]
 800a152:	e0bb      	b.n	800a2cc <HAL_GPIO_DeInit+0x194>
  {
    /* Get the IO position */
    ioposition = 0x01U << position;
 800a154:	2201      	movs	r2, #1
 800a156:	697b      	ldr	r3, [r7, #20]
 800a158:	fa02 f303 	lsl.w	r3, r2, r3
 800a15c:	613b      	str	r3, [r7, #16]
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;
 800a15e:	683a      	ldr	r2, [r7, #0]
 800a160:	693b      	ldr	r3, [r7, #16]
 800a162:	4013      	ands	r3, r2
 800a164:	60fb      	str	r3, [r7, #12]

    if(iocurrent == ioposition)
 800a166:	68fa      	ldr	r2, [r7, #12]
 800a168:	693b      	ldr	r3, [r7, #16]
 800a16a:	429a      	cmp	r2, r3
 800a16c:	f040 80ab 	bne.w	800a2c6 <HAL_GPIO_DeInit+0x18e>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2U];
 800a170:	4a5c      	ldr	r2, [pc, #368]	@ (800a2e4 <HAL_GPIO_DeInit+0x1ac>)
 800a172:	697b      	ldr	r3, [r7, #20]
 800a174:	089b      	lsrs	r3, r3, #2
 800a176:	3302      	adds	r3, #2
 800a178:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800a17c:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FU << (4U * (position & 0x03U)));
 800a17e:	697b      	ldr	r3, [r7, #20]
 800a180:	f003 0303 	and.w	r3, r3, #3
 800a184:	009b      	lsls	r3, r3, #2
 800a186:	220f      	movs	r2, #15
 800a188:	fa02 f303 	lsl.w	r3, r2, r3
 800a18c:	68ba      	ldr	r2, [r7, #8]
 800a18e:	4013      	ands	r3, r2
 800a190:	60bb      	str	r3, [r7, #8]
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 800a192:	687b      	ldr	r3, [r7, #4]
 800a194:	4a54      	ldr	r2, [pc, #336]	@ (800a2e8 <HAL_GPIO_DeInit+0x1b0>)
 800a196:	4293      	cmp	r3, r2
 800a198:	d019      	beq.n	800a1ce <HAL_GPIO_DeInit+0x96>
 800a19a:	687b      	ldr	r3, [r7, #4]
 800a19c:	4a53      	ldr	r2, [pc, #332]	@ (800a2ec <HAL_GPIO_DeInit+0x1b4>)
 800a19e:	4293      	cmp	r3, r2
 800a1a0:	d013      	beq.n	800a1ca <HAL_GPIO_DeInit+0x92>
 800a1a2:	687b      	ldr	r3, [r7, #4]
 800a1a4:	4a52      	ldr	r2, [pc, #328]	@ (800a2f0 <HAL_GPIO_DeInit+0x1b8>)
 800a1a6:	4293      	cmp	r3, r2
 800a1a8:	d00d      	beq.n	800a1c6 <HAL_GPIO_DeInit+0x8e>
 800a1aa:	687b      	ldr	r3, [r7, #4]
 800a1ac:	4a51      	ldr	r2, [pc, #324]	@ (800a2f4 <HAL_GPIO_DeInit+0x1bc>)
 800a1ae:	4293      	cmp	r3, r2
 800a1b0:	d007      	beq.n	800a1c2 <HAL_GPIO_DeInit+0x8a>
 800a1b2:	687b      	ldr	r3, [r7, #4]
 800a1b4:	4a50      	ldr	r2, [pc, #320]	@ (800a2f8 <HAL_GPIO_DeInit+0x1c0>)
 800a1b6:	4293      	cmp	r3, r2
 800a1b8:	d101      	bne.n	800a1be <HAL_GPIO_DeInit+0x86>
 800a1ba:	2304      	movs	r3, #4
 800a1bc:	e008      	b.n	800a1d0 <HAL_GPIO_DeInit+0x98>
 800a1be:	2307      	movs	r3, #7
 800a1c0:	e006      	b.n	800a1d0 <HAL_GPIO_DeInit+0x98>
 800a1c2:	2303      	movs	r3, #3
 800a1c4:	e004      	b.n	800a1d0 <HAL_GPIO_DeInit+0x98>
 800a1c6:	2302      	movs	r3, #2
 800a1c8:	e002      	b.n	800a1d0 <HAL_GPIO_DeInit+0x98>
 800a1ca:	2301      	movs	r3, #1
 800a1cc:	e000      	b.n	800a1d0 <HAL_GPIO_DeInit+0x98>
 800a1ce:	2300      	movs	r3, #0
 800a1d0:	697a      	ldr	r2, [r7, #20]
 800a1d2:	f002 0203 	and.w	r2, r2, #3
 800a1d6:	0092      	lsls	r2, r2, #2
 800a1d8:	4093      	lsls	r3, r2
 800a1da:	68ba      	ldr	r2, [r7, #8]
 800a1dc:	429a      	cmp	r2, r3
 800a1de:	d132      	bne.n	800a246 <HAL_GPIO_DeInit+0x10e>
      {
        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 800a1e0:	4b46      	ldr	r3, [pc, #280]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a1e2:	681a      	ldr	r2, [r3, #0]
 800a1e4:	68fb      	ldr	r3, [r7, #12]
 800a1e6:	43db      	mvns	r3, r3
 800a1e8:	4944      	ldr	r1, [pc, #272]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a1ea:	4013      	ands	r3, r2
 800a1ec:	600b      	str	r3, [r1, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 800a1ee:	4b43      	ldr	r3, [pc, #268]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a1f0:	685a      	ldr	r2, [r3, #4]
 800a1f2:	68fb      	ldr	r3, [r7, #12]
 800a1f4:	43db      	mvns	r3, r3
 800a1f6:	4941      	ldr	r1, [pc, #260]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a1f8:	4013      	ands	r3, r2
 800a1fa:	604b      	str	r3, [r1, #4]
        
        /* Clear Rising Falling edge configuration */
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 800a1fc:	4b3f      	ldr	r3, [pc, #252]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a1fe:	68da      	ldr	r2, [r3, #12]
 800a200:	68fb      	ldr	r3, [r7, #12]
 800a202:	43db      	mvns	r3, r3
 800a204:	493d      	ldr	r1, [pc, #244]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a206:	4013      	ands	r3, r2
 800a208:	60cb      	str	r3, [r1, #12]
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 800a20a:	4b3c      	ldr	r3, [pc, #240]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a20c:	689a      	ldr	r2, [r3, #8]
 800a20e:	68fb      	ldr	r3, [r7, #12]
 800a210:	43db      	mvns	r3, r3
 800a212:	493a      	ldr	r1, [pc, #232]	@ (800a2fc <HAL_GPIO_DeInit+0x1c4>)
 800a214:	4013      	ands	r3, r2
 800a216:	608b      	str	r3, [r1, #8]

        /* Configure the External Interrupt or event for the current IO */
        tmp = 0x0FU << (4U * (position & 0x03U));
 800a218:	697b      	ldr	r3, [r7, #20]
 800a21a:	f003 0303 	and.w	r3, r3, #3
 800a21e:	009b      	lsls	r3, r3, #2
 800a220:	220f      	movs	r2, #15
 800a222:	fa02 f303 	lsl.w	r3, r2, r3
 800a226:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 800a228:	4a2e      	ldr	r2, [pc, #184]	@ (800a2e4 <HAL_GPIO_DeInit+0x1ac>)
 800a22a:	697b      	ldr	r3, [r7, #20]
 800a22c:	089b      	lsrs	r3, r3, #2
 800a22e:	3302      	adds	r3, #2
 800a230:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 800a234:	68bb      	ldr	r3, [r7, #8]
 800a236:	43da      	mvns	r2, r3
 800a238:	482a      	ldr	r0, [pc, #168]	@ (800a2e4 <HAL_GPIO_DeInit+0x1ac>)
 800a23a:	697b      	ldr	r3, [r7, #20]
 800a23c:	089b      	lsrs	r3, r3, #2
 800a23e:	400a      	ands	r2, r1
 800a240:	3302      	adds	r3, #2
 800a242:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800a246:	687b      	ldr	r3, [r7, #4]
 800a248:	681a      	ldr	r2, [r3, #0]
 800a24a:	697b      	ldr	r3, [r7, #20]
 800a24c:	005b      	lsls	r3, r3, #1
 800a24e:	2103      	movs	r1, #3
 800a250:	fa01 f303 	lsl.w	r3, r1, r3
 800a254:	43db      	mvns	r3, r3
 800a256:	401a      	ands	r2, r3
 800a258:	687b      	ldr	r3, [r7, #4]
 800a25a:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800a25c:	697b      	ldr	r3, [r7, #20]
 800a25e:	08da      	lsrs	r2, r3, #3
 800a260:	687b      	ldr	r3, [r7, #4]
 800a262:	3208      	adds	r2, #8
 800a264:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800a268:	697b      	ldr	r3, [r7, #20]
 800a26a:	f003 0307 	and.w	r3, r3, #7
 800a26e:	009b      	lsls	r3, r3, #2
 800a270:	220f      	movs	r2, #15
 800a272:	fa02 f303 	lsl.w	r3, r2, r3
 800a276:	43db      	mvns	r3, r3
 800a278:	697a      	ldr	r2, [r7, #20]
 800a27a:	08d2      	lsrs	r2, r2, #3
 800a27c:	4019      	ands	r1, r3
 800a27e:	687b      	ldr	r3, [r7, #4]
 800a280:	3208      	adds	r2, #8
 800a282:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800a286:	687b      	ldr	r3, [r7, #4]
 800a288:	68da      	ldr	r2, [r3, #12]
 800a28a:	697b      	ldr	r3, [r7, #20]
 800a28c:	005b      	lsls	r3, r3, #1
 800a28e:	2103      	movs	r1, #3
 800a290:	fa01 f303 	lsl.w	r3, r1, r3
 800a294:	43db      	mvns	r3, r3
 800a296:	401a      	ands	r2, r3
 800a298:	687b      	ldr	r3, [r7, #4]
 800a29a:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 800a29c:	687b      	ldr	r3, [r7, #4]
 800a29e:	685a      	ldr	r2, [r3, #4]
 800a2a0:	2101      	movs	r1, #1
 800a2a2:	697b      	ldr	r3, [r7, #20]
 800a2a4:	fa01 f303 	lsl.w	r3, r1, r3
 800a2a8:	43db      	mvns	r3, r3
 800a2aa:	401a      	ands	r2, r3
 800a2ac:	687b      	ldr	r3, [r7, #4]
 800a2ae:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 800a2b0:	687b      	ldr	r3, [r7, #4]
 800a2b2:	689a      	ldr	r2, [r3, #8]
 800a2b4:	697b      	ldr	r3, [r7, #20]
 800a2b6:	005b      	lsls	r3, r3, #1
 800a2b8:	2103      	movs	r1, #3
 800a2ba:	fa01 f303 	lsl.w	r3, r1, r3
 800a2be:	43db      	mvns	r3, r3
 800a2c0:	401a      	ands	r2, r3
 800a2c2:	687b      	ldr	r3, [r7, #4]
 800a2c4:	609a      	str	r2, [r3, #8]
  for(position = 0U; position < GPIO_NUMBER; position++)
 800a2c6:	697b      	ldr	r3, [r7, #20]
 800a2c8:	3301      	adds	r3, #1
 800a2ca:	617b      	str	r3, [r7, #20]
 800a2cc:	697b      	ldr	r3, [r7, #20]
 800a2ce:	2b0f      	cmp	r3, #15
 800a2d0:	f67f af40 	bls.w	800a154 <HAL_GPIO_DeInit+0x1c>
    }
  }
}
 800a2d4:	bf00      	nop
 800a2d6:	bf00      	nop
 800a2d8:	371c      	adds	r7, #28
 800a2da:	46bd      	mov	sp, r7
 800a2dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a2e0:	4770      	bx	lr
 800a2e2:	bf00      	nop
 800a2e4:	40013800 	.word	0x40013800
 800a2e8:	40020000 	.word	0x40020000
 800a2ec:	40020400 	.word	0x40020400
 800a2f0:	40020800 	.word	0x40020800
 800a2f4:	40020c00 	.word	0x40020c00
 800a2f8:	40021000 	.word	0x40021000
 800a2fc:	40013c00 	.word	0x40013c00

0800a300 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800a300:	b480      	push	{r7}
 800a302:	b085      	sub	sp, #20
 800a304:	af00      	add	r7, sp, #0
 800a306:	6078      	str	r0, [r7, #4]
 800a308:	460b      	mov	r3, r1
 800a30a:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 800a30c:	687b      	ldr	r3, [r7, #4]
 800a30e:	691a      	ldr	r2, [r3, #16]
 800a310:	887b      	ldrh	r3, [r7, #2]
 800a312:	4013      	ands	r3, r2
 800a314:	2b00      	cmp	r3, #0
 800a316:	d002      	beq.n	800a31e <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 800a318:	2301      	movs	r3, #1
 800a31a:	73fb      	strb	r3, [r7, #15]
 800a31c:	e001      	b.n	800a322 <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 800a31e:	2300      	movs	r3, #0
 800a320:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 800a322:	7bfb      	ldrb	r3, [r7, #15]
}
 800a324:	4618      	mov	r0, r3
 800a326:	3714      	adds	r7, #20
 800a328:	46bd      	mov	sp, r7
 800a32a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a32e:	4770      	bx	lr

0800a330 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 800a330:	b480      	push	{r7}
 800a332:	b083      	sub	sp, #12
 800a334:	af00      	add	r7, sp, #0
 800a336:	6078      	str	r0, [r7, #4]
 800a338:	460b      	mov	r3, r1
 800a33a:	807b      	strh	r3, [r7, #2]
 800a33c:	4613      	mov	r3, r2
 800a33e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 800a340:	787b      	ldrb	r3, [r7, #1]
 800a342:	2b00      	cmp	r3, #0
 800a344:	d003      	beq.n	800a34e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 800a346:	887a      	ldrh	r2, [r7, #2]
 800a348:	687b      	ldr	r3, [r7, #4]
 800a34a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
  }
}
 800a34c:	e003      	b.n	800a356 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 800a34e:	887b      	ldrh	r3, [r7, #2]
 800a350:	041a      	lsls	r2, r3, #16
 800a352:	687b      	ldr	r3, [r7, #4]
 800a354:	619a      	str	r2, [r3, #24]
}
 800a356:	bf00      	nop
 800a358:	370c      	adds	r7, #12
 800a35a:	46bd      	mov	sp, r7
 800a35c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a360:	4770      	bx	lr

0800a362 <HAL_GPIO_TogglePin>:
  *                      x can be (A..I) to select the GPIO peripheral for STM32F40XX and STM32F427X devices.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 800a362:	b480      	push	{r7}
 800a364:	b085      	sub	sp, #20
 800a366:	af00      	add	r7, sp, #0
 800a368:	6078      	str	r0, [r7, #4]
 800a36a:	460b      	mov	r3, r1
 800a36c:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
 800a36e:	687b      	ldr	r3, [r7, #4]
 800a370:	695b      	ldr	r3, [r3, #20]
 800a372:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 800a374:	887a      	ldrh	r2, [r7, #2]
 800a376:	68fb      	ldr	r3, [r7, #12]
 800a378:	4013      	ands	r3, r2
 800a37a:	041a      	lsls	r2, r3, #16
 800a37c:	68fb      	ldr	r3, [r7, #12]
 800a37e:	43d9      	mvns	r1, r3
 800a380:	887b      	ldrh	r3, [r7, #2]
 800a382:	400b      	ands	r3, r1
 800a384:	431a      	orrs	r2, r3
 800a386:	687b      	ldr	r3, [r7, #4]
 800a388:	619a      	str	r2, [r3, #24]
}
 800a38a:	bf00      	nop
 800a38c:	3714      	adds	r7, #20
 800a38e:	46bd      	mov	sp, r7
 800a390:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a394:	4770      	bx	lr
	...

0800a398 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800a398:	b580      	push	{r7, lr}
 800a39a:	b084      	sub	sp, #16
 800a39c:	af00      	add	r7, sp, #0
 800a39e:	6078      	str	r0, [r7, #4]
  uint32_t freqrange;
  uint32_t pclk1;

  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800a3a0:	687b      	ldr	r3, [r7, #4]
 800a3a2:	2b00      	cmp	r3, #0
 800a3a4:	d101      	bne.n	800a3aa <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800a3a6:	2301      	movs	r3, #1
 800a3a8:	e12b      	b.n	800a602 <HAL_I2C_Init+0x26a>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 800a3aa:	687b      	ldr	r3, [r7, #4]
 800a3ac:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800a3b0:	b2db      	uxtb	r3, r3
 800a3b2:	2b00      	cmp	r3, #0
 800a3b4:	d106      	bne.n	800a3c4 <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800a3b6:	687b      	ldr	r3, [r7, #4]
 800a3b8:	2200      	movs	r2, #0
 800a3ba:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 800a3be:	6878      	ldr	r0, [r7, #4]
 800a3c0:	f7fa f838 	bl	8004434 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800a3c4:	687b      	ldr	r3, [r7, #4]
 800a3c6:	2224      	movs	r2, #36	@ 0x24
 800a3c8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 800a3cc:	687b      	ldr	r3, [r7, #4]
 800a3ce:	681b      	ldr	r3, [r3, #0]
 800a3d0:	681a      	ldr	r2, [r3, #0]
 800a3d2:	687b      	ldr	r3, [r7, #4]
 800a3d4:	681b      	ldr	r3, [r3, #0]
 800a3d6:	f022 0201 	bic.w	r2, r2, #1
 800a3da:	601a      	str	r2, [r3, #0]

  /*Reset I2C*/
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 800a3dc:	687b      	ldr	r3, [r7, #4]
 800a3de:	681b      	ldr	r3, [r3, #0]
 800a3e0:	681a      	ldr	r2, [r3, #0]
 800a3e2:	687b      	ldr	r3, [r7, #4]
 800a3e4:	681b      	ldr	r3, [r3, #0]
 800a3e6:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 800a3ea:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 800a3ec:	687b      	ldr	r3, [r7, #4]
 800a3ee:	681b      	ldr	r3, [r3, #0]
 800a3f0:	681a      	ldr	r2, [r3, #0]
 800a3f2:	687b      	ldr	r3, [r7, #4]
 800a3f4:	681b      	ldr	r3, [r3, #0]
 800a3f6:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 800a3fa:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 800a3fc:	f005 fac4 	bl	800f988 <HAL_RCC_GetPCLK1Freq>
 800a400:	60f8      	str	r0, [r7, #12]

  /* Check the minimum allowed PCLK1 frequency */
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 800a402:	687b      	ldr	r3, [r7, #4]
 800a404:	685b      	ldr	r3, [r3, #4]
 800a406:	4a81      	ldr	r2, [pc, #516]	@ (800a60c <HAL_I2C_Init+0x274>)
 800a408:	4293      	cmp	r3, r2
 800a40a:	d807      	bhi.n	800a41c <HAL_I2C_Init+0x84>
 800a40c:	68fb      	ldr	r3, [r7, #12]
 800a40e:	4a80      	ldr	r2, [pc, #512]	@ (800a610 <HAL_I2C_Init+0x278>)
 800a410:	4293      	cmp	r3, r2
 800a412:	bf94      	ite	ls
 800a414:	2301      	movls	r3, #1
 800a416:	2300      	movhi	r3, #0
 800a418:	b2db      	uxtb	r3, r3
 800a41a:	e006      	b.n	800a42a <HAL_I2C_Init+0x92>
 800a41c:	68fb      	ldr	r3, [r7, #12]
 800a41e:	4a7d      	ldr	r2, [pc, #500]	@ (800a614 <HAL_I2C_Init+0x27c>)
 800a420:	4293      	cmp	r3, r2
 800a422:	bf94      	ite	ls
 800a424:	2301      	movls	r3, #1
 800a426:	2300      	movhi	r3, #0
 800a428:	b2db      	uxtb	r3, r3
 800a42a:	2b00      	cmp	r3, #0
 800a42c:	d001      	beq.n	800a432 <HAL_I2C_Init+0x9a>
  {
    return HAL_ERROR;
 800a42e:	2301      	movs	r3, #1
 800a430:	e0e7      	b.n	800a602 <HAL_I2C_Init+0x26a>
  }

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 800a432:	68fb      	ldr	r3, [r7, #12]
 800a434:	4a78      	ldr	r2, [pc, #480]	@ (800a618 <HAL_I2C_Init+0x280>)
 800a436:	fba2 2303 	umull	r2, r3, r2, r3
 800a43a:	0c9b      	lsrs	r3, r3, #18
 800a43c:	60bb      	str	r3, [r7, #8]

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 800a43e:	687b      	ldr	r3, [r7, #4]
 800a440:	681b      	ldr	r3, [r3, #0]
 800a442:	685b      	ldr	r3, [r3, #4]
 800a444:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 800a448:	687b      	ldr	r3, [r7, #4]
 800a44a:	681b      	ldr	r3, [r3, #0]
 800a44c:	68ba      	ldr	r2, [r7, #8]
 800a44e:	430a      	orrs	r2, r1
 800a450:	605a      	str	r2, [r3, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 800a452:	687b      	ldr	r3, [r7, #4]
 800a454:	681b      	ldr	r3, [r3, #0]
 800a456:	6a1b      	ldr	r3, [r3, #32]
 800a458:	f023 013f 	bic.w	r1, r3, #63	@ 0x3f
 800a45c:	687b      	ldr	r3, [r7, #4]
 800a45e:	685b      	ldr	r3, [r3, #4]
 800a460:	4a6a      	ldr	r2, [pc, #424]	@ (800a60c <HAL_I2C_Init+0x274>)
 800a462:	4293      	cmp	r3, r2
 800a464:	d802      	bhi.n	800a46c <HAL_I2C_Init+0xd4>
 800a466:	68bb      	ldr	r3, [r7, #8]
 800a468:	3301      	adds	r3, #1
 800a46a:	e009      	b.n	800a480 <HAL_I2C_Init+0xe8>
 800a46c:	68bb      	ldr	r3, [r7, #8]
 800a46e:	f44f 7296 	mov.w	r2, #300	@ 0x12c
 800a472:	fb02 f303 	mul.w	r3, r2, r3
 800a476:	4a69      	ldr	r2, [pc, #420]	@ (800a61c <HAL_I2C_Init+0x284>)
 800a478:	fba2 2303 	umull	r2, r3, r2, r3
 800a47c:	099b      	lsrs	r3, r3, #6
 800a47e:	3301      	adds	r3, #1
 800a480:	687a      	ldr	r2, [r7, #4]
 800a482:	6812      	ldr	r2, [r2, #0]
 800a484:	430b      	orrs	r3, r1
 800a486:	6213      	str	r3, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 800a488:	687b      	ldr	r3, [r7, #4]
 800a48a:	681b      	ldr	r3, [r3, #0]
 800a48c:	69db      	ldr	r3, [r3, #28]
 800a48e:	f423 424f 	bic.w	r2, r3, #52992	@ 0xcf00
 800a492:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 800a496:	687b      	ldr	r3, [r7, #4]
 800a498:	685b      	ldr	r3, [r3, #4]
 800a49a:	495c      	ldr	r1, [pc, #368]	@ (800a60c <HAL_I2C_Init+0x274>)
 800a49c:	428b      	cmp	r3, r1
 800a49e:	d819      	bhi.n	800a4d4 <HAL_I2C_Init+0x13c>
 800a4a0:	68fb      	ldr	r3, [r7, #12]
 800a4a2:	1e59      	subs	r1, r3, #1
 800a4a4:	687b      	ldr	r3, [r7, #4]
 800a4a6:	685b      	ldr	r3, [r3, #4]
 800a4a8:	005b      	lsls	r3, r3, #1
 800a4aa:	fbb1 f3f3 	udiv	r3, r1, r3
 800a4ae:	1c59      	adds	r1, r3, #1
 800a4b0:	f640 73fc 	movw	r3, #4092	@ 0xffc
 800a4b4:	400b      	ands	r3, r1
 800a4b6:	2b00      	cmp	r3, #0
 800a4b8:	d00a      	beq.n	800a4d0 <HAL_I2C_Init+0x138>
 800a4ba:	68fb      	ldr	r3, [r7, #12]
 800a4bc:	1e59      	subs	r1, r3, #1
 800a4be:	687b      	ldr	r3, [r7, #4]
 800a4c0:	685b      	ldr	r3, [r3, #4]
 800a4c2:	005b      	lsls	r3, r3, #1
 800a4c4:	fbb1 f3f3 	udiv	r3, r1, r3
 800a4c8:	3301      	adds	r3, #1
 800a4ca:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800a4ce:	e051      	b.n	800a574 <HAL_I2C_Init+0x1dc>
 800a4d0:	2304      	movs	r3, #4
 800a4d2:	e04f      	b.n	800a574 <HAL_I2C_Init+0x1dc>
 800a4d4:	687b      	ldr	r3, [r7, #4]
 800a4d6:	689b      	ldr	r3, [r3, #8]
 800a4d8:	2b00      	cmp	r3, #0
 800a4da:	d111      	bne.n	800a500 <HAL_I2C_Init+0x168>
 800a4dc:	68fb      	ldr	r3, [r7, #12]
 800a4de:	1e58      	subs	r0, r3, #1
 800a4e0:	687b      	ldr	r3, [r7, #4]
 800a4e2:	6859      	ldr	r1, [r3, #4]
 800a4e4:	460b      	mov	r3, r1
 800a4e6:	005b      	lsls	r3, r3, #1
 800a4e8:	440b      	add	r3, r1
 800a4ea:	fbb0 f3f3 	udiv	r3, r0, r3
 800a4ee:	3301      	adds	r3, #1
 800a4f0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800a4f4:	2b00      	cmp	r3, #0
 800a4f6:	bf0c      	ite	eq
 800a4f8:	2301      	moveq	r3, #1
 800a4fa:	2300      	movne	r3, #0
 800a4fc:	b2db      	uxtb	r3, r3
 800a4fe:	e012      	b.n	800a526 <HAL_I2C_Init+0x18e>
 800a500:	68fb      	ldr	r3, [r7, #12]
 800a502:	1e58      	subs	r0, r3, #1
 800a504:	687b      	ldr	r3, [r7, #4]
 800a506:	6859      	ldr	r1, [r3, #4]
 800a508:	460b      	mov	r3, r1
 800a50a:	009b      	lsls	r3, r3, #2
 800a50c:	440b      	add	r3, r1
 800a50e:	0099      	lsls	r1, r3, #2
 800a510:	440b      	add	r3, r1
 800a512:	fbb0 f3f3 	udiv	r3, r0, r3
 800a516:	3301      	adds	r3, #1
 800a518:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800a51c:	2b00      	cmp	r3, #0
 800a51e:	bf0c      	ite	eq
 800a520:	2301      	moveq	r3, #1
 800a522:	2300      	movne	r3, #0
 800a524:	b2db      	uxtb	r3, r3
 800a526:	2b00      	cmp	r3, #0
 800a528:	d001      	beq.n	800a52e <HAL_I2C_Init+0x196>
 800a52a:	2301      	movs	r3, #1
 800a52c:	e022      	b.n	800a574 <HAL_I2C_Init+0x1dc>
 800a52e:	687b      	ldr	r3, [r7, #4]
 800a530:	689b      	ldr	r3, [r3, #8]
 800a532:	2b00      	cmp	r3, #0
 800a534:	d10e      	bne.n	800a554 <HAL_I2C_Init+0x1bc>
 800a536:	68fb      	ldr	r3, [r7, #12]
 800a538:	1e58      	subs	r0, r3, #1
 800a53a:	687b      	ldr	r3, [r7, #4]
 800a53c:	6859      	ldr	r1, [r3, #4]
 800a53e:	460b      	mov	r3, r1
 800a540:	005b      	lsls	r3, r3, #1
 800a542:	440b      	add	r3, r1
 800a544:	fbb0 f3f3 	udiv	r3, r0, r3
 800a548:	3301      	adds	r3, #1
 800a54a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800a54e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 800a552:	e00f      	b.n	800a574 <HAL_I2C_Init+0x1dc>
 800a554:	68fb      	ldr	r3, [r7, #12]
 800a556:	1e58      	subs	r0, r3, #1
 800a558:	687b      	ldr	r3, [r7, #4]
 800a55a:	6859      	ldr	r1, [r3, #4]
 800a55c:	460b      	mov	r3, r1
 800a55e:	009b      	lsls	r3, r3, #2
 800a560:	440b      	add	r3, r1
 800a562:	0099      	lsls	r1, r3, #2
 800a564:	440b      	add	r3, r1
 800a566:	fbb0 f3f3 	udiv	r3, r0, r3
 800a56a:	3301      	adds	r3, #1
 800a56c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800a570:	f443 4340 	orr.w	r3, r3, #49152	@ 0xc000
 800a574:	6879      	ldr	r1, [r7, #4]
 800a576:	6809      	ldr	r1, [r1, #0]
 800a578:	4313      	orrs	r3, r2
 800a57a:	61cb      	str	r3, [r1, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 800a57c:	687b      	ldr	r3, [r7, #4]
 800a57e:	681b      	ldr	r3, [r3, #0]
 800a580:	681b      	ldr	r3, [r3, #0]
 800a582:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 800a586:	687b      	ldr	r3, [r7, #4]
 800a588:	69da      	ldr	r2, [r3, #28]
 800a58a:	687b      	ldr	r3, [r7, #4]
 800a58c:	6a1b      	ldr	r3, [r3, #32]
 800a58e:	431a      	orrs	r2, r3
 800a590:	687b      	ldr	r3, [r7, #4]
 800a592:	681b      	ldr	r3, [r3, #0]
 800a594:	430a      	orrs	r2, r1
 800a596:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 800a598:	687b      	ldr	r3, [r7, #4]
 800a59a:	681b      	ldr	r3, [r3, #0]
 800a59c:	689b      	ldr	r3, [r3, #8]
 800a59e:	f423 4303 	bic.w	r3, r3, #33536	@ 0x8300
 800a5a2:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 800a5a6:	687a      	ldr	r2, [r7, #4]
 800a5a8:	6911      	ldr	r1, [r2, #16]
 800a5aa:	687a      	ldr	r2, [r7, #4]
 800a5ac:	68d2      	ldr	r2, [r2, #12]
 800a5ae:	4311      	orrs	r1, r2
 800a5b0:	687a      	ldr	r2, [r7, #4]
 800a5b2:	6812      	ldr	r2, [r2, #0]
 800a5b4:	430b      	orrs	r3, r1
 800a5b6:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 800a5b8:	687b      	ldr	r3, [r7, #4]
 800a5ba:	681b      	ldr	r3, [r3, #0]
 800a5bc:	68db      	ldr	r3, [r3, #12]
 800a5be:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
 800a5c2:	687b      	ldr	r3, [r7, #4]
 800a5c4:	695a      	ldr	r2, [r3, #20]
 800a5c6:	687b      	ldr	r3, [r7, #4]
 800a5c8:	699b      	ldr	r3, [r3, #24]
 800a5ca:	431a      	orrs	r2, r3
 800a5cc:	687b      	ldr	r3, [r7, #4]
 800a5ce:	681b      	ldr	r3, [r3, #0]
 800a5d0:	430a      	orrs	r2, r1
 800a5d2:	60da      	str	r2, [r3, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 800a5d4:	687b      	ldr	r3, [r7, #4]
 800a5d6:	681b      	ldr	r3, [r3, #0]
 800a5d8:	681a      	ldr	r2, [r3, #0]
 800a5da:	687b      	ldr	r3, [r7, #4]
 800a5dc:	681b      	ldr	r3, [r3, #0]
 800a5de:	f042 0201 	orr.w	r2, r2, #1
 800a5e2:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a5e4:	687b      	ldr	r3, [r7, #4]
 800a5e6:	2200      	movs	r2, #0
 800a5e8:	641a      	str	r2, [r3, #64]	@ 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 800a5ea:	687b      	ldr	r3, [r7, #4]
 800a5ec:	2220      	movs	r2, #32
 800a5ee:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 800a5f2:	687b      	ldr	r3, [r7, #4]
 800a5f4:	2200      	movs	r2, #0
 800a5f6:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800a5f8:	687b      	ldr	r3, [r7, #4]
 800a5fa:	2200      	movs	r2, #0
 800a5fc:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

  return HAL_OK;
 800a600:	2300      	movs	r3, #0
}
 800a602:	4618      	mov	r0, r3
 800a604:	3710      	adds	r7, #16
 800a606:	46bd      	mov	sp, r7
 800a608:	bd80      	pop	{r7, pc}
 800a60a:	bf00      	nop
 800a60c:	000186a0 	.word	0x000186a0
 800a610:	001e847f 	.word	0x001e847f
 800a614:	003d08ff 	.word	0x003d08ff
 800a618:	431bde83 	.word	0x431bde83
 800a61c:	10624dd3 	.word	0x10624dd3

0800a620 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 800a620:	b580      	push	{r7, lr}
 800a622:	b082      	sub	sp, #8
 800a624:	af00      	add	r7, sp, #0
 800a626:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 800a628:	687b      	ldr	r3, [r7, #4]
 800a62a:	2b00      	cmp	r3, #0
 800a62c:	d101      	bne.n	800a632 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
 800a62e:	2301      	movs	r3, #1
 800a630:	e021      	b.n	800a676 <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
 800a632:	687b      	ldr	r3, [r7, #4]
 800a634:	2224      	movs	r2, #36	@ 0x24
 800a636:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 800a63a:	687b      	ldr	r3, [r7, #4]
 800a63c:	681b      	ldr	r3, [r3, #0]
 800a63e:	681a      	ldr	r2, [r3, #0]
 800a640:	687b      	ldr	r3, [r7, #4]
 800a642:	681b      	ldr	r3, [r3, #0]
 800a644:	f022 0201 	bic.w	r2, r2, #1
 800a648:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 800a64a:	6878      	ldr	r0, [r7, #4]
 800a64c:	f7f9 ff5a 	bl	8004504 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 800a650:	687b      	ldr	r3, [r7, #4]
 800a652:	2200      	movs	r2, #0
 800a654:	641a      	str	r2, [r3, #64]	@ 0x40
  hi2c->State         = HAL_I2C_STATE_RESET;
 800a656:	687b      	ldr	r3, [r7, #4]
 800a658:	2200      	movs	r2, #0
 800a65a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 800a65e:	687b      	ldr	r3, [r7, #4]
 800a660:	2200      	movs	r2, #0
 800a662:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 800a664:	687b      	ldr	r3, [r7, #4]
 800a666:	2200      	movs	r2, #0
 800a668:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 800a66c:	687b      	ldr	r3, [r7, #4]
 800a66e:	2200      	movs	r2, #0
 800a670:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 800a674:	2300      	movs	r3, #0
}
 800a676:	4618      	mov	r0, r3
 800a678:	3708      	adds	r7, #8
 800a67a:	46bd      	mov	sp, r7
 800a67c:	bd80      	pop	{r7, pc}

0800a67e <I2C_Flush_DR>:
  * @brief  I2C data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_DR(I2C_HandleTypeDef *hi2c)
{
 800a67e:	b480      	push	{r7}
 800a680:	b083      	sub	sp, #12
 800a682:	af00      	add	r7, sp, #0
 800a684:	6078      	str	r0, [r7, #4]
  /* Write a dummy data in DR to clear TXE flag */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) != RESET)
 800a686:	687b      	ldr	r3, [r7, #4]
 800a688:	681b      	ldr	r3, [r3, #0]
 800a68a:	695b      	ldr	r3, [r3, #20]
 800a68c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800a690:	2b80      	cmp	r3, #128	@ 0x80
 800a692:	d103      	bne.n	800a69c <I2C_Flush_DR+0x1e>
  {
    hi2c->Instance->DR = 0x00U;
 800a694:	687b      	ldr	r3, [r7, #4]
 800a696:	681b      	ldr	r3, [r3, #0]
 800a698:	2200      	movs	r2, #0
 800a69a:	611a      	str	r2, [r3, #16]
  }
}
 800a69c:	bf00      	nop
 800a69e:	370c      	adds	r7, #12
 800a6a0:	46bd      	mov	sp, r7
 800a6a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6a6:	4770      	bx	lr

0800a6a8 <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800a6a8:	b580      	push	{r7, lr}
 800a6aa:	b088      	sub	sp, #32
 800a6ac:	af02      	add	r7, sp, #8
 800a6ae:	60f8      	str	r0, [r7, #12]
 800a6b0:	4608      	mov	r0, r1
 800a6b2:	4611      	mov	r1, r2
 800a6b4:	461a      	mov	r2, r3
 800a6b6:	4603      	mov	r3, r0
 800a6b8:	817b      	strh	r3, [r7, #10]
 800a6ba:	460b      	mov	r3, r1
 800a6bc:	813b      	strh	r3, [r7, #8]
 800a6be:	4613      	mov	r3, r2
 800a6c0:	80fb      	strh	r3, [r7, #6]
  /* Init tickstart for timeout management*/
  uint32_t tickstart = HAL_GetTick();
 800a6c2:	f7fe fadf 	bl	8008c84 <HAL_GetTick>
 800a6c6:	6178      	str	r0, [r7, #20]

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800a6c8:	68fb      	ldr	r3, [r7, #12]
 800a6ca:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800a6ce:	b2db      	uxtb	r3, r3
 800a6d0:	2b20      	cmp	r3, #32
 800a6d2:	f040 80d9 	bne.w	800a888 <HAL_I2C_Mem_Write+0x1e0>
  {
    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 800a6d6:	697b      	ldr	r3, [r7, #20]
 800a6d8:	9300      	str	r3, [sp, #0]
 800a6da:	2319      	movs	r3, #25
 800a6dc:	2201      	movs	r2, #1
 800a6de:	496d      	ldr	r1, [pc, #436]	@ (800a894 <HAL_I2C_Mem_Write+0x1ec>)
 800a6e0:	68f8      	ldr	r0, [r7, #12]
 800a6e2:	f002 fa35 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800a6e6:	4603      	mov	r3, r0
 800a6e8:	2b00      	cmp	r3, #0
 800a6ea:	d001      	beq.n	800a6f0 <HAL_I2C_Mem_Write+0x48>
    {
      return HAL_BUSY;
 800a6ec:	2302      	movs	r3, #2
 800a6ee:	e0cc      	b.n	800a88a <HAL_I2C_Mem_Write+0x1e2>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800a6f0:	68fb      	ldr	r3, [r7, #12]
 800a6f2:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800a6f6:	2b01      	cmp	r3, #1
 800a6f8:	d101      	bne.n	800a6fe <HAL_I2C_Mem_Write+0x56>
 800a6fa:	2302      	movs	r3, #2
 800a6fc:	e0c5      	b.n	800a88a <HAL_I2C_Mem_Write+0x1e2>
 800a6fe:	68fb      	ldr	r3, [r7, #12]
 800a700:	2201      	movs	r2, #1
 800a702:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Check if the I2C is already enabled */
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 800a706:	68fb      	ldr	r3, [r7, #12]
 800a708:	681b      	ldr	r3, [r3, #0]
 800a70a:	681b      	ldr	r3, [r3, #0]
 800a70c:	f003 0301 	and.w	r3, r3, #1
 800a710:	2b01      	cmp	r3, #1
 800a712:	d007      	beq.n	800a724 <HAL_I2C_Mem_Write+0x7c>
    {
      /* Enable I2C peripheral */
      __HAL_I2C_ENABLE(hi2c);
 800a714:	68fb      	ldr	r3, [r7, #12]
 800a716:	681b      	ldr	r3, [r3, #0]
 800a718:	681a      	ldr	r2, [r3, #0]
 800a71a:	68fb      	ldr	r3, [r7, #12]
 800a71c:	681b      	ldr	r3, [r3, #0]
 800a71e:	f042 0201 	orr.w	r2, r2, #1
 800a722:	601a      	str	r2, [r3, #0]
    }

    /* Disable Pos */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 800a724:	68fb      	ldr	r3, [r7, #12]
 800a726:	681b      	ldr	r3, [r3, #0]
 800a728:	681a      	ldr	r2, [r3, #0]
 800a72a:	68fb      	ldr	r3, [r7, #12]
 800a72c:	681b      	ldr	r3, [r3, #0]
 800a72e:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800a732:	601a      	str	r2, [r3, #0]

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 800a734:	68fb      	ldr	r3, [r7, #12]
 800a736:	2221      	movs	r2, #33	@ 0x21
 800a738:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800a73c:	68fb      	ldr	r3, [r7, #12]
 800a73e:	2240      	movs	r2, #64	@ 0x40
 800a740:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a744:	68fb      	ldr	r3, [r7, #12]
 800a746:	2200      	movs	r2, #0
 800a748:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
 800a74a:	68fb      	ldr	r3, [r7, #12]
 800a74c:	6a3a      	ldr	r2, [r7, #32]
 800a74e:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
 800a750:	68fb      	ldr	r3, [r7, #12]
 800a752:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 800a754:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
 800a756:	68fb      	ldr	r3, [r7, #12]
 800a758:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a75a:	b29a      	uxth	r2, r3
 800a75c:	68fb      	ldr	r3, [r7, #12]
 800a75e:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800a760:	68fb      	ldr	r3, [r7, #12]
 800a762:	4a4d      	ldr	r2, [pc, #308]	@ (800a898 <HAL_I2C_Mem_Write+0x1f0>)
 800a764:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 800a766:	88f8      	ldrh	r0, [r7, #6]
 800a768:	893a      	ldrh	r2, [r7, #8]
 800a76a:	8979      	ldrh	r1, [r7, #10]
 800a76c:	697b      	ldr	r3, [r7, #20]
 800a76e:	9301      	str	r3, [sp, #4]
 800a770:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a772:	9300      	str	r3, [sp, #0]
 800a774:	4603      	mov	r3, r0
 800a776:	68f8      	ldr	r0, [r7, #12]
 800a778:	f001 ffc4 	bl	800c704 <I2C_RequestMemoryWrite>
 800a77c:	4603      	mov	r3, r0
 800a77e:	2b00      	cmp	r3, #0
 800a780:	d052      	beq.n	800a828 <HAL_I2C_Mem_Write+0x180>
    {
      return HAL_ERROR;
 800a782:	2301      	movs	r3, #1
 800a784:	e081      	b.n	800a88a <HAL_I2C_Mem_Write+0x1e2>
    }

    while (hi2c->XferSize > 0U)
    {
      /* Wait until TXE flag is set */
      if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800a786:	697a      	ldr	r2, [r7, #20]
 800a788:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800a78a:	68f8      	ldr	r0, [r7, #12]
 800a78c:	f002 fafa 	bl	800cd84 <I2C_WaitOnTXEFlagUntilTimeout>
 800a790:	4603      	mov	r3, r0
 800a792:	2b00      	cmp	r3, #0
 800a794:	d00d      	beq.n	800a7b2 <HAL_I2C_Mem_Write+0x10a>
      {
        if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800a796:	68fb      	ldr	r3, [r7, #12]
 800a798:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a79a:	2b04      	cmp	r3, #4
 800a79c:	d107      	bne.n	800a7ae <HAL_I2C_Mem_Write+0x106>
        {
          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800a79e:	68fb      	ldr	r3, [r7, #12]
 800a7a0:	681b      	ldr	r3, [r3, #0]
 800a7a2:	681a      	ldr	r2, [r3, #0]
 800a7a4:	68fb      	ldr	r3, [r7, #12]
 800a7a6:	681b      	ldr	r3, [r3, #0]
 800a7a8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800a7ac:	601a      	str	r2, [r3, #0]
        }
        return HAL_ERROR;
 800a7ae:	2301      	movs	r3, #1
 800a7b0:	e06b      	b.n	800a88a <HAL_I2C_Mem_Write+0x1e2>
      }

      /* Write data to DR */
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 800a7b2:	68fb      	ldr	r3, [r7, #12]
 800a7b4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800a7b6:	781a      	ldrb	r2, [r3, #0]
 800a7b8:	68fb      	ldr	r3, [r7, #12]
 800a7ba:	681b      	ldr	r3, [r3, #0]
 800a7bc:	611a      	str	r2, [r3, #16]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800a7be:	68fb      	ldr	r3, [r7, #12]
 800a7c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800a7c2:	1c5a      	adds	r2, r3, #1
 800a7c4:	68fb      	ldr	r3, [r7, #12]
 800a7c6:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferSize--;
 800a7c8:	68fb      	ldr	r3, [r7, #12]
 800a7ca:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800a7cc:	3b01      	subs	r3, #1
 800a7ce:	b29a      	uxth	r2, r3
 800a7d0:	68fb      	ldr	r3, [r7, #12]
 800a7d2:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 800a7d4:	68fb      	ldr	r3, [r7, #12]
 800a7d6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a7d8:	b29b      	uxth	r3, r3
 800a7da:	3b01      	subs	r3, #1
 800a7dc:	b29a      	uxth	r2, r3
 800a7de:	68fb      	ldr	r3, [r7, #12]
 800a7e0:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (hi2c->XferSize != 0U))
 800a7e2:	68fb      	ldr	r3, [r7, #12]
 800a7e4:	681b      	ldr	r3, [r3, #0]
 800a7e6:	695b      	ldr	r3, [r3, #20]
 800a7e8:	f003 0304 	and.w	r3, r3, #4
 800a7ec:	2b04      	cmp	r3, #4
 800a7ee:	d11b      	bne.n	800a828 <HAL_I2C_Mem_Write+0x180>
 800a7f0:	68fb      	ldr	r3, [r7, #12]
 800a7f2:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800a7f4:	2b00      	cmp	r3, #0
 800a7f6:	d017      	beq.n	800a828 <HAL_I2C_Mem_Write+0x180>
      {
        /* Write data to DR */
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 800a7f8:	68fb      	ldr	r3, [r7, #12]
 800a7fa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800a7fc:	781a      	ldrb	r2, [r3, #0]
 800a7fe:	68fb      	ldr	r3, [r7, #12]
 800a800:	681b      	ldr	r3, [r3, #0]
 800a802:	611a      	str	r2, [r3, #16]

        /* Increment Buffer pointer */
        hi2c->pBuffPtr++;
 800a804:	68fb      	ldr	r3, [r7, #12]
 800a806:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800a808:	1c5a      	adds	r2, r3, #1
 800a80a:	68fb      	ldr	r3, [r7, #12]
 800a80c:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Update counter */
        hi2c->XferSize--;
 800a80e:	68fb      	ldr	r3, [r7, #12]
 800a810:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800a812:	3b01      	subs	r3, #1
 800a814:	b29a      	uxth	r2, r3
 800a816:	68fb      	ldr	r3, [r7, #12]
 800a818:	851a      	strh	r2, [r3, #40]	@ 0x28
        hi2c->XferCount--;
 800a81a:	68fb      	ldr	r3, [r7, #12]
 800a81c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a81e:	b29b      	uxth	r3, r3
 800a820:	3b01      	subs	r3, #1
 800a822:	b29a      	uxth	r2, r3
 800a824:	68fb      	ldr	r3, [r7, #12]
 800a826:	855a      	strh	r2, [r3, #42]	@ 0x2a
    while (hi2c->XferSize > 0U)
 800a828:	68fb      	ldr	r3, [r7, #12]
 800a82a:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800a82c:	2b00      	cmp	r3, #0
 800a82e:	d1aa      	bne.n	800a786 <HAL_I2C_Mem_Write+0xde>
      }
    }

    /* Wait until BTF flag is set */
    if (I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800a830:	697a      	ldr	r2, [r7, #20]
 800a832:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800a834:	68f8      	ldr	r0, [r7, #12]
 800a836:	f002 faed 	bl	800ce14 <I2C_WaitOnBTFFlagUntilTimeout>
 800a83a:	4603      	mov	r3, r0
 800a83c:	2b00      	cmp	r3, #0
 800a83e:	d00d      	beq.n	800a85c <HAL_I2C_Mem_Write+0x1b4>
    {
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800a840:	68fb      	ldr	r3, [r7, #12]
 800a842:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a844:	2b04      	cmp	r3, #4
 800a846:	d107      	bne.n	800a858 <HAL_I2C_Mem_Write+0x1b0>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800a848:	68fb      	ldr	r3, [r7, #12]
 800a84a:	681b      	ldr	r3, [r3, #0]
 800a84c:	681a      	ldr	r2, [r3, #0]
 800a84e:	68fb      	ldr	r3, [r7, #12]
 800a850:	681b      	ldr	r3, [r3, #0]
 800a852:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800a856:	601a      	str	r2, [r3, #0]
      }
      return HAL_ERROR;
 800a858:	2301      	movs	r3, #1
 800a85a:	e016      	b.n	800a88a <HAL_I2C_Mem_Write+0x1e2>
    }

    /* Generate Stop */
    SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800a85c:	68fb      	ldr	r3, [r7, #12]
 800a85e:	681b      	ldr	r3, [r3, #0]
 800a860:	681a      	ldr	r2, [r3, #0]
 800a862:	68fb      	ldr	r3, [r7, #12]
 800a864:	681b      	ldr	r3, [r3, #0]
 800a866:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800a86a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800a86c:	68fb      	ldr	r3, [r7, #12]
 800a86e:	2220      	movs	r2, #32
 800a870:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800a874:	68fb      	ldr	r3, [r7, #12]
 800a876:	2200      	movs	r2, #0
 800a878:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800a87c:	68fb      	ldr	r3, [r7, #12]
 800a87e:	2200      	movs	r2, #0
 800a880:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 800a884:	2300      	movs	r3, #0
 800a886:	e000      	b.n	800a88a <HAL_I2C_Mem_Write+0x1e2>
  }
  else
  {
    return HAL_BUSY;
 800a888:	2302      	movs	r3, #2
  }
}
 800a88a:	4618      	mov	r0, r3
 800a88c:	3718      	adds	r7, #24
 800a88e:	46bd      	mov	sp, r7
 800a890:	bd80      	pop	{r7, pc}
 800a892:	bf00      	nop
 800a894:	00100002 	.word	0x00100002
 800a898:	ffff0000 	.word	0xffff0000

0800a89c <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800a89c:	b580      	push	{r7, lr}
 800a89e:	b08c      	sub	sp, #48	@ 0x30
 800a8a0:	af02      	add	r7, sp, #8
 800a8a2:	60f8      	str	r0, [r7, #12]
 800a8a4:	4608      	mov	r0, r1
 800a8a6:	4611      	mov	r1, r2
 800a8a8:	461a      	mov	r2, r3
 800a8aa:	4603      	mov	r3, r0
 800a8ac:	817b      	strh	r3, [r7, #10]
 800a8ae:	460b      	mov	r3, r1
 800a8b0:	813b      	strh	r3, [r7, #8]
 800a8b2:	4613      	mov	r3, r2
 800a8b4:	80fb      	strh	r3, [r7, #6]
  /* Init tickstart for timeout management*/
  uint32_t tickstart = HAL_GetTick();
 800a8b6:	f7fe f9e5 	bl	8008c84 <HAL_GetTick>
 800a8ba:	6278      	str	r0, [r7, #36]	@ 0x24

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800a8bc:	68fb      	ldr	r3, [r7, #12]
 800a8be:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800a8c2:	b2db      	uxtb	r3, r3
 800a8c4:	2b20      	cmp	r3, #32
 800a8c6:	f040 8214 	bne.w	800acf2 <HAL_I2C_Mem_Read+0x456>
  {
    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 800a8ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a8cc:	9300      	str	r3, [sp, #0]
 800a8ce:	2319      	movs	r3, #25
 800a8d0:	2201      	movs	r2, #1
 800a8d2:	497b      	ldr	r1, [pc, #492]	@ (800aac0 <HAL_I2C_Mem_Read+0x224>)
 800a8d4:	68f8      	ldr	r0, [r7, #12]
 800a8d6:	f002 f93b 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800a8da:	4603      	mov	r3, r0
 800a8dc:	2b00      	cmp	r3, #0
 800a8de:	d001      	beq.n	800a8e4 <HAL_I2C_Mem_Read+0x48>
    {
      return HAL_BUSY;
 800a8e0:	2302      	movs	r3, #2
 800a8e2:	e207      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800a8e4:	68fb      	ldr	r3, [r7, #12]
 800a8e6:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800a8ea:	2b01      	cmp	r3, #1
 800a8ec:	d101      	bne.n	800a8f2 <HAL_I2C_Mem_Read+0x56>
 800a8ee:	2302      	movs	r3, #2
 800a8f0:	e200      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
 800a8f2:	68fb      	ldr	r3, [r7, #12]
 800a8f4:	2201      	movs	r2, #1
 800a8f6:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Check if the I2C is already enabled */
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 800a8fa:	68fb      	ldr	r3, [r7, #12]
 800a8fc:	681b      	ldr	r3, [r3, #0]
 800a8fe:	681b      	ldr	r3, [r3, #0]
 800a900:	f003 0301 	and.w	r3, r3, #1
 800a904:	2b01      	cmp	r3, #1
 800a906:	d007      	beq.n	800a918 <HAL_I2C_Mem_Read+0x7c>
    {
      /* Enable I2C peripheral */
      __HAL_I2C_ENABLE(hi2c);
 800a908:	68fb      	ldr	r3, [r7, #12]
 800a90a:	681b      	ldr	r3, [r3, #0]
 800a90c:	681a      	ldr	r2, [r3, #0]
 800a90e:	68fb      	ldr	r3, [r7, #12]
 800a910:	681b      	ldr	r3, [r3, #0]
 800a912:	f042 0201 	orr.w	r2, r2, #1
 800a916:	601a      	str	r2, [r3, #0]
    }

    /* Disable Pos */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 800a918:	68fb      	ldr	r3, [r7, #12]
 800a91a:	681b      	ldr	r3, [r3, #0]
 800a91c:	681a      	ldr	r2, [r3, #0]
 800a91e:	68fb      	ldr	r3, [r7, #12]
 800a920:	681b      	ldr	r3, [r3, #0]
 800a922:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800a926:	601a      	str	r2, [r3, #0]

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800a928:	68fb      	ldr	r3, [r7, #12]
 800a92a:	2222      	movs	r2, #34	@ 0x22
 800a92c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 800a930:	68fb      	ldr	r3, [r7, #12]
 800a932:	2240      	movs	r2, #64	@ 0x40
 800a934:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800a938:	68fb      	ldr	r3, [r7, #12]
 800a93a:	2200      	movs	r2, #0
 800a93c:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Prepare transfer parameters */
    hi2c->pBuffPtr    = pData;
 800a93e:	68fb      	ldr	r3, [r7, #12]
 800a940:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800a942:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount   = Size;
 800a944:	68fb      	ldr	r3, [r7, #12]
 800a946:	8eba      	ldrh	r2, [r7, #52]	@ 0x34
 800a948:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferSize    = hi2c->XferCount;
 800a94a:	68fb      	ldr	r3, [r7, #12]
 800a94c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800a94e:	b29a      	uxth	r2, r3
 800a950:	68fb      	ldr	r3, [r7, #12]
 800a952:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800a954:	68fb      	ldr	r3, [r7, #12]
 800a956:	4a5b      	ldr	r2, [pc, #364]	@ (800aac4 <HAL_I2C_Mem_Read+0x228>)
 800a958:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 800a95a:	88f8      	ldrh	r0, [r7, #6]
 800a95c:	893a      	ldrh	r2, [r7, #8]
 800a95e:	8979      	ldrh	r1, [r7, #10]
 800a960:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800a962:	9301      	str	r3, [sp, #4]
 800a964:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a966:	9300      	str	r3, [sp, #0]
 800a968:	4603      	mov	r3, r0
 800a96a:	68f8      	ldr	r0, [r7, #12]
 800a96c:	f001 ff60 	bl	800c830 <I2C_RequestMemoryRead>
 800a970:	4603      	mov	r3, r0
 800a972:	2b00      	cmp	r3, #0
 800a974:	d001      	beq.n	800a97a <HAL_I2C_Mem_Read+0xde>
    {
      return HAL_ERROR;
 800a976:	2301      	movs	r3, #1
 800a978:	e1bc      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
    }

    if (hi2c->XferSize == 0U)
 800a97a:	68fb      	ldr	r3, [r7, #12]
 800a97c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800a97e:	2b00      	cmp	r3, #0
 800a980:	d113      	bne.n	800a9aa <HAL_I2C_Mem_Read+0x10e>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800a982:	2300      	movs	r3, #0
 800a984:	623b      	str	r3, [r7, #32]
 800a986:	68fb      	ldr	r3, [r7, #12]
 800a988:	681b      	ldr	r3, [r3, #0]
 800a98a:	695b      	ldr	r3, [r3, #20]
 800a98c:	623b      	str	r3, [r7, #32]
 800a98e:	68fb      	ldr	r3, [r7, #12]
 800a990:	681b      	ldr	r3, [r3, #0]
 800a992:	699b      	ldr	r3, [r3, #24]
 800a994:	623b      	str	r3, [r7, #32]
 800a996:	6a3b      	ldr	r3, [r7, #32]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800a998:	68fb      	ldr	r3, [r7, #12]
 800a99a:	681b      	ldr	r3, [r3, #0]
 800a99c:	681a      	ldr	r2, [r3, #0]
 800a99e:	68fb      	ldr	r3, [r7, #12]
 800a9a0:	681b      	ldr	r3, [r3, #0]
 800a9a2:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800a9a6:	601a      	str	r2, [r3, #0]
 800a9a8:	e190      	b.n	800accc <HAL_I2C_Mem_Read+0x430>
    }
    else if (hi2c->XferSize == 1U)
 800a9aa:	68fb      	ldr	r3, [r7, #12]
 800a9ac:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800a9ae:	2b01      	cmp	r3, #1
 800a9b0:	d11b      	bne.n	800a9ea <HAL_I2C_Mem_Read+0x14e>
    {
      /* Disable Acknowledge */
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800a9b2:	68fb      	ldr	r3, [r7, #12]
 800a9b4:	681b      	ldr	r3, [r3, #0]
 800a9b6:	681a      	ldr	r2, [r3, #0]
 800a9b8:	68fb      	ldr	r3, [r7, #12]
 800a9ba:	681b      	ldr	r3, [r3, #0]
 800a9bc:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800a9c0:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800a9c2:	2300      	movs	r3, #0
 800a9c4:	61fb      	str	r3, [r7, #28]
 800a9c6:	68fb      	ldr	r3, [r7, #12]
 800a9c8:	681b      	ldr	r3, [r3, #0]
 800a9ca:	695b      	ldr	r3, [r3, #20]
 800a9cc:	61fb      	str	r3, [r7, #28]
 800a9ce:	68fb      	ldr	r3, [r7, #12]
 800a9d0:	681b      	ldr	r3, [r3, #0]
 800a9d2:	699b      	ldr	r3, [r3, #24]
 800a9d4:	61fb      	str	r3, [r7, #28]
 800a9d6:	69fb      	ldr	r3, [r7, #28]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800a9d8:	68fb      	ldr	r3, [r7, #12]
 800a9da:	681b      	ldr	r3, [r3, #0]
 800a9dc:	681a      	ldr	r2, [r3, #0]
 800a9de:	68fb      	ldr	r3, [r7, #12]
 800a9e0:	681b      	ldr	r3, [r3, #0]
 800a9e2:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800a9e6:	601a      	str	r2, [r3, #0]
 800a9e8:	e170      	b.n	800accc <HAL_I2C_Mem_Read+0x430>
    }
    else if (hi2c->XferSize == 2U)
 800a9ea:	68fb      	ldr	r3, [r7, #12]
 800a9ec:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800a9ee:	2b02      	cmp	r3, #2
 800a9f0:	d11b      	bne.n	800aa2a <HAL_I2C_Mem_Read+0x18e>
    {
      /* Disable Acknowledge */
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800a9f2:	68fb      	ldr	r3, [r7, #12]
 800a9f4:	681b      	ldr	r3, [r3, #0]
 800a9f6:	681a      	ldr	r2, [r3, #0]
 800a9f8:	68fb      	ldr	r3, [r7, #12]
 800a9fa:	681b      	ldr	r3, [r3, #0]
 800a9fc:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800aa00:	601a      	str	r2, [r3, #0]

      /* Enable Pos */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 800aa02:	68fb      	ldr	r3, [r7, #12]
 800aa04:	681b      	ldr	r3, [r3, #0]
 800aa06:	681a      	ldr	r2, [r3, #0]
 800aa08:	68fb      	ldr	r3, [r7, #12]
 800aa0a:	681b      	ldr	r3, [r3, #0]
 800aa0c:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800aa10:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800aa12:	2300      	movs	r3, #0
 800aa14:	61bb      	str	r3, [r7, #24]
 800aa16:	68fb      	ldr	r3, [r7, #12]
 800aa18:	681b      	ldr	r3, [r3, #0]
 800aa1a:	695b      	ldr	r3, [r3, #20]
 800aa1c:	61bb      	str	r3, [r7, #24]
 800aa1e:	68fb      	ldr	r3, [r7, #12]
 800aa20:	681b      	ldr	r3, [r3, #0]
 800aa22:	699b      	ldr	r3, [r3, #24]
 800aa24:	61bb      	str	r3, [r7, #24]
 800aa26:	69bb      	ldr	r3, [r7, #24]
 800aa28:	e150      	b.n	800accc <HAL_I2C_Mem_Read+0x430>
    }
    else
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800aa2a:	2300      	movs	r3, #0
 800aa2c:	617b      	str	r3, [r7, #20]
 800aa2e:	68fb      	ldr	r3, [r7, #12]
 800aa30:	681b      	ldr	r3, [r3, #0]
 800aa32:	695b      	ldr	r3, [r3, #20]
 800aa34:	617b      	str	r3, [r7, #20]
 800aa36:	68fb      	ldr	r3, [r7, #12]
 800aa38:	681b      	ldr	r3, [r3, #0]
 800aa3a:	699b      	ldr	r3, [r3, #24]
 800aa3c:	617b      	str	r3, [r7, #20]
 800aa3e:	697b      	ldr	r3, [r7, #20]
    }

    while (hi2c->XferSize > 0U)
 800aa40:	e144      	b.n	800accc <HAL_I2C_Mem_Read+0x430>
    {
      if (hi2c->XferSize <= 3U)
 800aa42:	68fb      	ldr	r3, [r7, #12]
 800aa44:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800aa46:	2b03      	cmp	r3, #3
 800aa48:	f200 80f1 	bhi.w	800ac2e <HAL_I2C_Mem_Read+0x392>
      {
        /* One byte */
        if (hi2c->XferSize == 1U)
 800aa4c:	68fb      	ldr	r3, [r7, #12]
 800aa4e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800aa50:	2b01      	cmp	r3, #1
 800aa52:	d123      	bne.n	800aa9c <HAL_I2C_Mem_Read+0x200>
        {
          /* Wait until RXNE flag is set */
          if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800aa54:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800aa56:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 800aa58:	68f8      	ldr	r0, [r7, #12]
 800aa5a:	f002 fa55 	bl	800cf08 <I2C_WaitOnRXNEFlagUntilTimeout>
 800aa5e:	4603      	mov	r3, r0
 800aa60:	2b00      	cmp	r3, #0
 800aa62:	d001      	beq.n	800aa68 <HAL_I2C_Mem_Read+0x1cc>
          {
            return HAL_ERROR;
 800aa64:	2301      	movs	r3, #1
 800aa66:	e145      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
          }

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800aa68:	68fb      	ldr	r3, [r7, #12]
 800aa6a:	681b      	ldr	r3, [r3, #0]
 800aa6c:	691a      	ldr	r2, [r3, #16]
 800aa6e:	68fb      	ldr	r3, [r7, #12]
 800aa70:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800aa72:	b2d2      	uxtb	r2, r2
 800aa74:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800aa76:	68fb      	ldr	r3, [r7, #12]
 800aa78:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800aa7a:	1c5a      	adds	r2, r3, #1
 800aa7c:	68fb      	ldr	r3, [r7, #12]
 800aa7e:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 800aa80:	68fb      	ldr	r3, [r7, #12]
 800aa82:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800aa84:	3b01      	subs	r3, #1
 800aa86:	b29a      	uxth	r2, r3
 800aa88:	68fb      	ldr	r3, [r7, #12]
 800aa8a:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 800aa8c:	68fb      	ldr	r3, [r7, #12]
 800aa8e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800aa90:	b29b      	uxth	r3, r3
 800aa92:	3b01      	subs	r3, #1
 800aa94:	b29a      	uxth	r2, r3
 800aa96:	68fb      	ldr	r3, [r7, #12]
 800aa98:	855a      	strh	r2, [r3, #42]	@ 0x2a
 800aa9a:	e117      	b.n	800accc <HAL_I2C_Mem_Read+0x430>
        }
        /* Two bytes */
        else if (hi2c->XferSize == 2U)
 800aa9c:	68fb      	ldr	r3, [r7, #12]
 800aa9e:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800aaa0:	2b02      	cmp	r3, #2
 800aaa2:	d14e      	bne.n	800ab42 <HAL_I2C_Mem_Read+0x2a6>
        {
          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 800aaa4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800aaa6:	9300      	str	r3, [sp, #0]
 800aaa8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800aaaa:	2200      	movs	r2, #0
 800aaac:	4906      	ldr	r1, [pc, #24]	@ (800aac8 <HAL_I2C_Mem_Read+0x22c>)
 800aaae:	68f8      	ldr	r0, [r7, #12]
 800aab0:	f002 f84e 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800aab4:	4603      	mov	r3, r0
 800aab6:	2b00      	cmp	r3, #0
 800aab8:	d008      	beq.n	800aacc <HAL_I2C_Mem_Read+0x230>
          {
            return HAL_ERROR;
 800aaba:	2301      	movs	r3, #1
 800aabc:	e11a      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
 800aabe:	bf00      	nop
 800aac0:	00100002 	.word	0x00100002
 800aac4:	ffff0000 	.word	0xffff0000
 800aac8:	00010004 	.word	0x00010004
          }

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800aacc:	68fb      	ldr	r3, [r7, #12]
 800aace:	681b      	ldr	r3, [r3, #0]
 800aad0:	681a      	ldr	r2, [r3, #0]
 800aad2:	68fb      	ldr	r3, [r7, #12]
 800aad4:	681b      	ldr	r3, [r3, #0]
 800aad6:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800aada:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800aadc:	68fb      	ldr	r3, [r7, #12]
 800aade:	681b      	ldr	r3, [r3, #0]
 800aae0:	691a      	ldr	r2, [r3, #16]
 800aae2:	68fb      	ldr	r3, [r7, #12]
 800aae4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800aae6:	b2d2      	uxtb	r2, r2
 800aae8:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800aaea:	68fb      	ldr	r3, [r7, #12]
 800aaec:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800aaee:	1c5a      	adds	r2, r3, #1
 800aaf0:	68fb      	ldr	r3, [r7, #12]
 800aaf2:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 800aaf4:	68fb      	ldr	r3, [r7, #12]
 800aaf6:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800aaf8:	3b01      	subs	r3, #1
 800aafa:	b29a      	uxth	r2, r3
 800aafc:	68fb      	ldr	r3, [r7, #12]
 800aafe:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 800ab00:	68fb      	ldr	r3, [r7, #12]
 800ab02:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800ab04:	b29b      	uxth	r3, r3
 800ab06:	3b01      	subs	r3, #1
 800ab08:	b29a      	uxth	r2, r3
 800ab0a:	68fb      	ldr	r3, [r7, #12]
 800ab0c:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800ab0e:	68fb      	ldr	r3, [r7, #12]
 800ab10:	681b      	ldr	r3, [r3, #0]
 800ab12:	691a      	ldr	r2, [r3, #16]
 800ab14:	68fb      	ldr	r3, [r7, #12]
 800ab16:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ab18:	b2d2      	uxtb	r2, r2
 800ab1a:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800ab1c:	68fb      	ldr	r3, [r7, #12]
 800ab1e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ab20:	1c5a      	adds	r2, r3, #1
 800ab22:	68fb      	ldr	r3, [r7, #12]
 800ab24:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 800ab26:	68fb      	ldr	r3, [r7, #12]
 800ab28:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ab2a:	3b01      	subs	r3, #1
 800ab2c:	b29a      	uxth	r2, r3
 800ab2e:	68fb      	ldr	r3, [r7, #12]
 800ab30:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 800ab32:	68fb      	ldr	r3, [r7, #12]
 800ab34:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800ab36:	b29b      	uxth	r3, r3
 800ab38:	3b01      	subs	r3, #1
 800ab3a:	b29a      	uxth	r2, r3
 800ab3c:	68fb      	ldr	r3, [r7, #12]
 800ab3e:	855a      	strh	r2, [r3, #42]	@ 0x2a
 800ab40:	e0c4      	b.n	800accc <HAL_I2C_Mem_Read+0x430>
        }
        /* 3 Last bytes */
        else
        {
          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 800ab42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800ab44:	9300      	str	r3, [sp, #0]
 800ab46:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800ab48:	2200      	movs	r2, #0
 800ab4a:	496c      	ldr	r1, [pc, #432]	@ (800acfc <HAL_I2C_Mem_Read+0x460>)
 800ab4c:	68f8      	ldr	r0, [r7, #12]
 800ab4e:	f001 ffff 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800ab52:	4603      	mov	r3, r0
 800ab54:	2b00      	cmp	r3, #0
 800ab56:	d001      	beq.n	800ab5c <HAL_I2C_Mem_Read+0x2c0>
          {
            return HAL_ERROR;
 800ab58:	2301      	movs	r3, #1
 800ab5a:	e0cb      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
          }

          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800ab5c:	68fb      	ldr	r3, [r7, #12]
 800ab5e:	681b      	ldr	r3, [r3, #0]
 800ab60:	681a      	ldr	r2, [r3, #0]
 800ab62:	68fb      	ldr	r3, [r7, #12]
 800ab64:	681b      	ldr	r3, [r3, #0]
 800ab66:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800ab6a:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800ab6c:	68fb      	ldr	r3, [r7, #12]
 800ab6e:	681b      	ldr	r3, [r3, #0]
 800ab70:	691a      	ldr	r2, [r3, #16]
 800ab72:	68fb      	ldr	r3, [r7, #12]
 800ab74:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ab76:	b2d2      	uxtb	r2, r2
 800ab78:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800ab7a:	68fb      	ldr	r3, [r7, #12]
 800ab7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ab7e:	1c5a      	adds	r2, r3, #1
 800ab80:	68fb      	ldr	r3, [r7, #12]
 800ab82:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 800ab84:	68fb      	ldr	r3, [r7, #12]
 800ab86:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ab88:	3b01      	subs	r3, #1
 800ab8a:	b29a      	uxth	r2, r3
 800ab8c:	68fb      	ldr	r3, [r7, #12]
 800ab8e:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 800ab90:	68fb      	ldr	r3, [r7, #12]
 800ab92:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800ab94:	b29b      	uxth	r3, r3
 800ab96:	3b01      	subs	r3, #1
 800ab98:	b29a      	uxth	r2, r3
 800ab9a:	68fb      	ldr	r3, [r7, #12]
 800ab9c:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Wait until BTF flag is set */
          if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 800ab9e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800aba0:	9300      	str	r3, [sp, #0]
 800aba2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800aba4:	2200      	movs	r2, #0
 800aba6:	4955      	ldr	r1, [pc, #340]	@ (800acfc <HAL_I2C_Mem_Read+0x460>)
 800aba8:	68f8      	ldr	r0, [r7, #12]
 800abaa:	f001 ffd1 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800abae:	4603      	mov	r3, r0
 800abb0:	2b00      	cmp	r3, #0
 800abb2:	d001      	beq.n	800abb8 <HAL_I2C_Mem_Read+0x31c>
          {
            return HAL_ERROR;
 800abb4:	2301      	movs	r3, #1
 800abb6:	e09d      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
          }

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800abb8:	68fb      	ldr	r3, [r7, #12]
 800abba:	681b      	ldr	r3, [r3, #0]
 800abbc:	681a      	ldr	r2, [r3, #0]
 800abbe:	68fb      	ldr	r3, [r7, #12]
 800abc0:	681b      	ldr	r3, [r3, #0]
 800abc2:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800abc6:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800abc8:	68fb      	ldr	r3, [r7, #12]
 800abca:	681b      	ldr	r3, [r3, #0]
 800abcc:	691a      	ldr	r2, [r3, #16]
 800abce:	68fb      	ldr	r3, [r7, #12]
 800abd0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800abd2:	b2d2      	uxtb	r2, r2
 800abd4:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800abd6:	68fb      	ldr	r3, [r7, #12]
 800abd8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800abda:	1c5a      	adds	r2, r3, #1
 800abdc:	68fb      	ldr	r3, [r7, #12]
 800abde:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 800abe0:	68fb      	ldr	r3, [r7, #12]
 800abe2:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800abe4:	3b01      	subs	r3, #1
 800abe6:	b29a      	uxth	r2, r3
 800abe8:	68fb      	ldr	r3, [r7, #12]
 800abea:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 800abec:	68fb      	ldr	r3, [r7, #12]
 800abee:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800abf0:	b29b      	uxth	r3, r3
 800abf2:	3b01      	subs	r3, #1
 800abf4:	b29a      	uxth	r2, r3
 800abf6:	68fb      	ldr	r3, [r7, #12]
 800abf8:	855a      	strh	r2, [r3, #42]	@ 0x2a

          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800abfa:	68fb      	ldr	r3, [r7, #12]
 800abfc:	681b      	ldr	r3, [r3, #0]
 800abfe:	691a      	ldr	r2, [r3, #16]
 800ac00:	68fb      	ldr	r3, [r7, #12]
 800ac02:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ac04:	b2d2      	uxtb	r2, r2
 800ac06:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800ac08:	68fb      	ldr	r3, [r7, #12]
 800ac0a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ac0c:	1c5a      	adds	r2, r3, #1
 800ac0e:	68fb      	ldr	r3, [r7, #12]
 800ac10:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 800ac12:	68fb      	ldr	r3, [r7, #12]
 800ac14:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ac16:	3b01      	subs	r3, #1
 800ac18:	b29a      	uxth	r2, r3
 800ac1a:	68fb      	ldr	r3, [r7, #12]
 800ac1c:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 800ac1e:	68fb      	ldr	r3, [r7, #12]
 800ac20:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800ac22:	b29b      	uxth	r3, r3
 800ac24:	3b01      	subs	r3, #1
 800ac26:	b29a      	uxth	r2, r3
 800ac28:	68fb      	ldr	r3, [r7, #12]
 800ac2a:	855a      	strh	r2, [r3, #42]	@ 0x2a
 800ac2c:	e04e      	b.n	800accc <HAL_I2C_Mem_Read+0x430>
        }
      }
      else
      {
        /* Wait until RXNE flag is set */
        if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800ac2e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800ac30:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 800ac32:	68f8      	ldr	r0, [r7, #12]
 800ac34:	f002 f968 	bl	800cf08 <I2C_WaitOnRXNEFlagUntilTimeout>
 800ac38:	4603      	mov	r3, r0
 800ac3a:	2b00      	cmp	r3, #0
 800ac3c:	d001      	beq.n	800ac42 <HAL_I2C_Mem_Read+0x3a6>
        {
          return HAL_ERROR;
 800ac3e:	2301      	movs	r3, #1
 800ac40:	e058      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
        }

        /* Read data from DR */
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800ac42:	68fb      	ldr	r3, [r7, #12]
 800ac44:	681b      	ldr	r3, [r3, #0]
 800ac46:	691a      	ldr	r2, [r3, #16]
 800ac48:	68fb      	ldr	r3, [r7, #12]
 800ac4a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ac4c:	b2d2      	uxtb	r2, r2
 800ac4e:	701a      	strb	r2, [r3, #0]

        /* Increment Buffer pointer */
        hi2c->pBuffPtr++;
 800ac50:	68fb      	ldr	r3, [r7, #12]
 800ac52:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ac54:	1c5a      	adds	r2, r3, #1
 800ac56:	68fb      	ldr	r3, [r7, #12]
 800ac58:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Update counter */
        hi2c->XferSize--;
 800ac5a:	68fb      	ldr	r3, [r7, #12]
 800ac5c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ac5e:	3b01      	subs	r3, #1
 800ac60:	b29a      	uxth	r2, r3
 800ac62:	68fb      	ldr	r3, [r7, #12]
 800ac64:	851a      	strh	r2, [r3, #40]	@ 0x28
        hi2c->XferCount--;
 800ac66:	68fb      	ldr	r3, [r7, #12]
 800ac68:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800ac6a:	b29b      	uxth	r3, r3
 800ac6c:	3b01      	subs	r3, #1
 800ac6e:	b29a      	uxth	r2, r3
 800ac70:	68fb      	ldr	r3, [r7, #12]
 800ac72:	855a      	strh	r2, [r3, #42]	@ 0x2a

        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 800ac74:	68fb      	ldr	r3, [r7, #12]
 800ac76:	681b      	ldr	r3, [r3, #0]
 800ac78:	695b      	ldr	r3, [r3, #20]
 800ac7a:	f003 0304 	and.w	r3, r3, #4
 800ac7e:	2b04      	cmp	r3, #4
 800ac80:	d124      	bne.n	800accc <HAL_I2C_Mem_Read+0x430>
        {
          if (hi2c->XferSize == 3U)
 800ac82:	68fb      	ldr	r3, [r7, #12]
 800ac84:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800ac86:	2b03      	cmp	r3, #3
 800ac88:	d107      	bne.n	800ac9a <HAL_I2C_Mem_Read+0x3fe>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800ac8a:	68fb      	ldr	r3, [r7, #12]
 800ac8c:	681b      	ldr	r3, [r3, #0]
 800ac8e:	681a      	ldr	r2, [r3, #0]
 800ac90:	68fb      	ldr	r3, [r7, #12]
 800ac92:	681b      	ldr	r3, [r3, #0]
 800ac94:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800ac98:	601a      	str	r2, [r3, #0]
          }
          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800ac9a:	68fb      	ldr	r3, [r7, #12]
 800ac9c:	681b      	ldr	r3, [r3, #0]
 800ac9e:	691a      	ldr	r2, [r3, #16]
 800aca0:	68fb      	ldr	r3, [r7, #12]
 800aca2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800aca4:	b2d2      	uxtb	r2, r2
 800aca6:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800aca8:	68fb      	ldr	r3, [r7, #12]
 800acaa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800acac:	1c5a      	adds	r2, r3, #1
 800acae:	68fb      	ldr	r3, [r7, #12]
 800acb0:	625a      	str	r2, [r3, #36]	@ 0x24

          /* Update counter */
          hi2c->XferSize--;
 800acb2:	68fb      	ldr	r3, [r7, #12]
 800acb4:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800acb6:	3b01      	subs	r3, #1
 800acb8:	b29a      	uxth	r2, r3
 800acba:	68fb      	ldr	r3, [r7, #12]
 800acbc:	851a      	strh	r2, [r3, #40]	@ 0x28
          hi2c->XferCount--;
 800acbe:	68fb      	ldr	r3, [r7, #12]
 800acc0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800acc2:	b29b      	uxth	r3, r3
 800acc4:	3b01      	subs	r3, #1
 800acc6:	b29a      	uxth	r2, r3
 800acc8:	68fb      	ldr	r3, [r7, #12]
 800acca:	855a      	strh	r2, [r3, #42]	@ 0x2a
    while (hi2c->XferSize > 0U)
 800accc:	68fb      	ldr	r3, [r7, #12]
 800acce:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800acd0:	2b00      	cmp	r3, #0
 800acd2:	f47f aeb6 	bne.w	800aa42 <HAL_I2C_Mem_Read+0x1a6>
        }
      }
    }

    hi2c->State = HAL_I2C_STATE_READY;
 800acd6:	68fb      	ldr	r3, [r7, #12]
 800acd8:	2220      	movs	r2, #32
 800acda:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800acde:	68fb      	ldr	r3, [r7, #12]
 800ace0:	2200      	movs	r2, #0
 800ace2:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800ace6:	68fb      	ldr	r3, [r7, #12]
 800ace8:	2200      	movs	r2, #0
 800acea:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_OK;
 800acee:	2300      	movs	r3, #0
 800acf0:	e000      	b.n	800acf4 <HAL_I2C_Mem_Read+0x458>
  }
  else
  {
    return HAL_BUSY;
 800acf2:	2302      	movs	r3, #2
  }
}
 800acf4:	4618      	mov	r0, r3
 800acf6:	3728      	adds	r7, #40	@ 0x28
 800acf8:	46bd      	mov	sp, r7
 800acfa:	bd80      	pop	{r7, pc}
 800acfc:	00010004 	.word	0x00010004

0800ad00 <HAL_I2C_IsDeviceReady>:
  * @param  Trials Number of trials
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_IsDeviceReady(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint32_t Trials, uint32_t Timeout)
{
 800ad00:	b580      	push	{r7, lr}
 800ad02:	b08a      	sub	sp, #40	@ 0x28
 800ad04:	af02      	add	r7, sp, #8
 800ad06:	60f8      	str	r0, [r7, #12]
 800ad08:	607a      	str	r2, [r7, #4]
 800ad0a:	603b      	str	r3, [r7, #0]
 800ad0c:	460b      	mov	r3, r1
 800ad0e:	817b      	strh	r3, [r7, #10]
  /* Get tick */
  uint32_t tickstart = HAL_GetTick();
 800ad10:	f7fd ffb8 	bl	8008c84 <HAL_GetTick>
 800ad14:	61f8      	str	r0, [r7, #28]
  uint32_t I2C_Trials = 0U;
 800ad16:	2300      	movs	r3, #0
 800ad18:	61bb      	str	r3, [r7, #24]
  FlagStatus tmp1;
  FlagStatus tmp2;

  if (hi2c->State == HAL_I2C_STATE_READY)
 800ad1a:	68fb      	ldr	r3, [r7, #12]
 800ad1c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800ad20:	b2db      	uxtb	r3, r3
 800ad22:	2b20      	cmp	r3, #32
 800ad24:	f040 8111 	bne.w	800af4a <HAL_I2C_IsDeviceReady+0x24a>
  {
    /* Wait until BUSY flag is reset */
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 800ad28:	69fb      	ldr	r3, [r7, #28]
 800ad2a:	9300      	str	r3, [sp, #0]
 800ad2c:	2319      	movs	r3, #25
 800ad2e:	2201      	movs	r2, #1
 800ad30:	4988      	ldr	r1, [pc, #544]	@ (800af54 <HAL_I2C_IsDeviceReady+0x254>)
 800ad32:	68f8      	ldr	r0, [r7, #12]
 800ad34:	f001 ff0c 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800ad38:	4603      	mov	r3, r0
 800ad3a:	2b00      	cmp	r3, #0
 800ad3c:	d001      	beq.n	800ad42 <HAL_I2C_IsDeviceReady+0x42>
    {
      return HAL_BUSY;
 800ad3e:	2302      	movs	r3, #2
 800ad40:	e104      	b.n	800af4c <HAL_I2C_IsDeviceReady+0x24c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 800ad42:	68fb      	ldr	r3, [r7, #12]
 800ad44:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800ad48:	2b01      	cmp	r3, #1
 800ad4a:	d101      	bne.n	800ad50 <HAL_I2C_IsDeviceReady+0x50>
 800ad4c:	2302      	movs	r3, #2
 800ad4e:	e0fd      	b.n	800af4c <HAL_I2C_IsDeviceReady+0x24c>
 800ad50:	68fb      	ldr	r3, [r7, #12]
 800ad52:	2201      	movs	r2, #1
 800ad54:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Check if the I2C is already enabled */
    if ((hi2c->Instance->CR1 & I2C_CR1_PE) != I2C_CR1_PE)
 800ad58:	68fb      	ldr	r3, [r7, #12]
 800ad5a:	681b      	ldr	r3, [r3, #0]
 800ad5c:	681b      	ldr	r3, [r3, #0]
 800ad5e:	f003 0301 	and.w	r3, r3, #1
 800ad62:	2b01      	cmp	r3, #1
 800ad64:	d007      	beq.n	800ad76 <HAL_I2C_IsDeviceReady+0x76>
    {
      /* Enable I2C peripheral */
      __HAL_I2C_ENABLE(hi2c);
 800ad66:	68fb      	ldr	r3, [r7, #12]
 800ad68:	681b      	ldr	r3, [r3, #0]
 800ad6a:	681a      	ldr	r2, [r3, #0]
 800ad6c:	68fb      	ldr	r3, [r7, #12]
 800ad6e:	681b      	ldr	r3, [r3, #0]
 800ad70:	f042 0201 	orr.w	r2, r2, #1
 800ad74:	601a      	str	r2, [r3, #0]
    }

    /* Disable Pos */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 800ad76:	68fb      	ldr	r3, [r7, #12]
 800ad78:	681b      	ldr	r3, [r3, #0]
 800ad7a:	681a      	ldr	r2, [r3, #0]
 800ad7c:	68fb      	ldr	r3, [r7, #12]
 800ad7e:	681b      	ldr	r3, [r3, #0]
 800ad80:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800ad84:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_BUSY;
 800ad86:	68fb      	ldr	r3, [r7, #12]
 800ad88:	2224      	movs	r2, #36	@ 0x24
 800ad8a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800ad8e:	68fb      	ldr	r3, [r7, #12]
 800ad90:	2200      	movs	r2, #0
 800ad92:	641a      	str	r2, [r3, #64]	@ 0x40
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800ad94:	68fb      	ldr	r3, [r7, #12]
 800ad96:	4a70      	ldr	r2, [pc, #448]	@ (800af58 <HAL_I2C_IsDeviceReady+0x258>)
 800ad98:	62da      	str	r2, [r3, #44]	@ 0x2c

    do
    {
      /* Generate Start */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 800ad9a:	68fb      	ldr	r3, [r7, #12]
 800ad9c:	681b      	ldr	r3, [r3, #0]
 800ad9e:	681a      	ldr	r2, [r3, #0]
 800ada0:	68fb      	ldr	r3, [r7, #12]
 800ada2:	681b      	ldr	r3, [r3, #0]
 800ada4:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800ada8:	601a      	str	r2, [r3, #0]

      /* Wait until SB flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, tickstart) != HAL_OK)
 800adaa:	69fb      	ldr	r3, [r7, #28]
 800adac:	9300      	str	r3, [sp, #0]
 800adae:	683b      	ldr	r3, [r7, #0]
 800adb0:	2200      	movs	r2, #0
 800adb2:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 800adb6:	68f8      	ldr	r0, [r7, #12]
 800adb8:	f001 feca 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800adbc:	4603      	mov	r3, r0
 800adbe:	2b00      	cmp	r3, #0
 800adc0:	d00d      	beq.n	800adde <HAL_I2C_IsDeviceReady+0xde>
      {
        if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 800adc2:	68fb      	ldr	r3, [r7, #12]
 800adc4:	681b      	ldr	r3, [r3, #0]
 800adc6:	681b      	ldr	r3, [r3, #0]
 800adc8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800adcc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800add0:	d103      	bne.n	800adda <HAL_I2C_IsDeviceReady+0xda>
        {
          hi2c->ErrorCode = HAL_I2C_WRONG_START;
 800add2:	68fb      	ldr	r3, [r7, #12]
 800add4:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800add8:	641a      	str	r2, [r3, #64]	@ 0x40
        }
        return HAL_TIMEOUT;
 800adda:	2303      	movs	r3, #3
 800addc:	e0b6      	b.n	800af4c <HAL_I2C_IsDeviceReady+0x24c>
      }

      /* Send slave address */
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 800adde:	897b      	ldrh	r3, [r7, #10]
 800ade0:	b2db      	uxtb	r3, r3
 800ade2:	461a      	mov	r2, r3
 800ade4:	68fb      	ldr	r3, [r7, #12]
 800ade6:	681b      	ldr	r3, [r3, #0]
 800ade8:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 800adec:	611a      	str	r2, [r3, #16]

      /* Wait until ADDR or AF flag are set */
      /* Get tick */
      tickstart = HAL_GetTick();
 800adee:	f7fd ff49 	bl	8008c84 <HAL_GetTick>
 800adf2:	61f8      	str	r0, [r7, #28]

      tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
 800adf4:	68fb      	ldr	r3, [r7, #12]
 800adf6:	681b      	ldr	r3, [r3, #0]
 800adf8:	695b      	ldr	r3, [r3, #20]
 800adfa:	f003 0302 	and.w	r3, r3, #2
 800adfe:	2b02      	cmp	r3, #2
 800ae00:	bf0c      	ite	eq
 800ae02:	2301      	moveq	r3, #1
 800ae04:	2300      	movne	r3, #0
 800ae06:	b2db      	uxtb	r3, r3
 800ae08:	75fb      	strb	r3, [r7, #23]
      tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
 800ae0a:	68fb      	ldr	r3, [r7, #12]
 800ae0c:	681b      	ldr	r3, [r3, #0]
 800ae0e:	695b      	ldr	r3, [r3, #20]
 800ae10:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800ae14:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800ae18:	bf0c      	ite	eq
 800ae1a:	2301      	moveq	r3, #1
 800ae1c:	2300      	movne	r3, #0
 800ae1e:	b2db      	uxtb	r3, r3
 800ae20:	75bb      	strb	r3, [r7, #22]
      while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
 800ae22:	e025      	b.n	800ae70 <HAL_I2C_IsDeviceReady+0x170>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800ae24:	f7fd ff2e 	bl	8008c84 <HAL_GetTick>
 800ae28:	4602      	mov	r2, r0
 800ae2a:	69fb      	ldr	r3, [r7, #28]
 800ae2c:	1ad3      	subs	r3, r2, r3
 800ae2e:	683a      	ldr	r2, [r7, #0]
 800ae30:	429a      	cmp	r2, r3
 800ae32:	d302      	bcc.n	800ae3a <HAL_I2C_IsDeviceReady+0x13a>
 800ae34:	683b      	ldr	r3, [r7, #0]
 800ae36:	2b00      	cmp	r3, #0
 800ae38:	d103      	bne.n	800ae42 <HAL_I2C_IsDeviceReady+0x142>
        {
          hi2c->State = HAL_I2C_STATE_TIMEOUT;
 800ae3a:	68fb      	ldr	r3, [r7, #12]
 800ae3c:	22a0      	movs	r2, #160	@ 0xa0
 800ae3e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        }
        tmp1 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR);
 800ae42:	68fb      	ldr	r3, [r7, #12]
 800ae44:	681b      	ldr	r3, [r3, #0]
 800ae46:	695b      	ldr	r3, [r3, #20]
 800ae48:	f003 0302 	and.w	r3, r3, #2
 800ae4c:	2b02      	cmp	r3, #2
 800ae4e:	bf0c      	ite	eq
 800ae50:	2301      	moveq	r3, #1
 800ae52:	2300      	movne	r3, #0
 800ae54:	b2db      	uxtb	r3, r3
 800ae56:	75fb      	strb	r3, [r7, #23]
        tmp2 = __HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF);
 800ae58:	68fb      	ldr	r3, [r7, #12]
 800ae5a:	681b      	ldr	r3, [r3, #0]
 800ae5c:	695b      	ldr	r3, [r3, #20]
 800ae5e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800ae62:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800ae66:	bf0c      	ite	eq
 800ae68:	2301      	moveq	r3, #1
 800ae6a:	2300      	movne	r3, #0
 800ae6c:	b2db      	uxtb	r3, r3
 800ae6e:	75bb      	strb	r3, [r7, #22]
      while ((hi2c->State != HAL_I2C_STATE_TIMEOUT) && (tmp1 == RESET) && (tmp2 == RESET))
 800ae70:	68fb      	ldr	r3, [r7, #12]
 800ae72:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800ae76:	b2db      	uxtb	r3, r3
 800ae78:	2ba0      	cmp	r3, #160	@ 0xa0
 800ae7a:	d005      	beq.n	800ae88 <HAL_I2C_IsDeviceReady+0x188>
 800ae7c:	7dfb      	ldrb	r3, [r7, #23]
 800ae7e:	2b00      	cmp	r3, #0
 800ae80:	d102      	bne.n	800ae88 <HAL_I2C_IsDeviceReady+0x188>
 800ae82:	7dbb      	ldrb	r3, [r7, #22]
 800ae84:	2b00      	cmp	r3, #0
 800ae86:	d0cd      	beq.n	800ae24 <HAL_I2C_IsDeviceReady+0x124>
      }

      hi2c->State = HAL_I2C_STATE_READY;
 800ae88:	68fb      	ldr	r3, [r7, #12]
 800ae8a:	2220      	movs	r2, #32
 800ae8c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

      /* Check if the ADDR flag has been set */
      if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_ADDR) == SET)
 800ae90:	68fb      	ldr	r3, [r7, #12]
 800ae92:	681b      	ldr	r3, [r3, #0]
 800ae94:	695b      	ldr	r3, [r3, #20]
 800ae96:	f003 0302 	and.w	r3, r3, #2
 800ae9a:	2b02      	cmp	r3, #2
 800ae9c:	d129      	bne.n	800aef2 <HAL_I2C_IsDeviceReady+0x1f2>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800ae9e:	68fb      	ldr	r3, [r7, #12]
 800aea0:	681b      	ldr	r3, [r3, #0]
 800aea2:	681a      	ldr	r2, [r3, #0]
 800aea4:	68fb      	ldr	r3, [r7, #12]
 800aea6:	681b      	ldr	r3, [r3, #0]
 800aea8:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800aeac:	601a      	str	r2, [r3, #0]

        /* Clear ADDR Flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800aeae:	2300      	movs	r3, #0
 800aeb0:	613b      	str	r3, [r7, #16]
 800aeb2:	68fb      	ldr	r3, [r7, #12]
 800aeb4:	681b      	ldr	r3, [r3, #0]
 800aeb6:	695b      	ldr	r3, [r3, #20]
 800aeb8:	613b      	str	r3, [r7, #16]
 800aeba:	68fb      	ldr	r3, [r7, #12]
 800aebc:	681b      	ldr	r3, [r3, #0]
 800aebe:	699b      	ldr	r3, [r3, #24]
 800aec0:	613b      	str	r3, [r7, #16]
 800aec2:	693b      	ldr	r3, [r7, #16]

        /* Wait until BUSY flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 800aec4:	69fb      	ldr	r3, [r7, #28]
 800aec6:	9300      	str	r3, [sp, #0]
 800aec8:	2319      	movs	r3, #25
 800aeca:	2201      	movs	r2, #1
 800aecc:	4921      	ldr	r1, [pc, #132]	@ (800af54 <HAL_I2C_IsDeviceReady+0x254>)
 800aece:	68f8      	ldr	r0, [r7, #12]
 800aed0:	f001 fe3e 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800aed4:	4603      	mov	r3, r0
 800aed6:	2b00      	cmp	r3, #0
 800aed8:	d001      	beq.n	800aede <HAL_I2C_IsDeviceReady+0x1de>
        {
          return HAL_ERROR;
 800aeda:	2301      	movs	r3, #1
 800aedc:	e036      	b.n	800af4c <HAL_I2C_IsDeviceReady+0x24c>
        }

        hi2c->State = HAL_I2C_STATE_READY;
 800aede:	68fb      	ldr	r3, [r7, #12]
 800aee0:	2220      	movs	r2, #32
 800aee2:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800aee6:	68fb      	ldr	r3, [r7, #12]
 800aee8:	2200      	movs	r2, #0
 800aeea:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

        return HAL_OK;
 800aeee:	2300      	movs	r3, #0
 800aef0:	e02c      	b.n	800af4c <HAL_I2C_IsDeviceReady+0x24c>
      }
      else
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800aef2:	68fb      	ldr	r3, [r7, #12]
 800aef4:	681b      	ldr	r3, [r3, #0]
 800aef6:	681a      	ldr	r2, [r3, #0]
 800aef8:	68fb      	ldr	r3, [r7, #12]
 800aefa:	681b      	ldr	r3, [r3, #0]
 800aefc:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800af00:	601a      	str	r2, [r3, #0]

        /* Clear AF Flag */
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800af02:	68fb      	ldr	r3, [r7, #12]
 800af04:	681b      	ldr	r3, [r3, #0]
 800af06:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 800af0a:	615a      	str	r2, [r3, #20]

        /* Wait until BUSY flag is reset */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 800af0c:	69fb      	ldr	r3, [r7, #28]
 800af0e:	9300      	str	r3, [sp, #0]
 800af10:	2319      	movs	r3, #25
 800af12:	2201      	movs	r2, #1
 800af14:	490f      	ldr	r1, [pc, #60]	@ (800af54 <HAL_I2C_IsDeviceReady+0x254>)
 800af16:	68f8      	ldr	r0, [r7, #12]
 800af18:	f001 fe1a 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800af1c:	4603      	mov	r3, r0
 800af1e:	2b00      	cmp	r3, #0
 800af20:	d001      	beq.n	800af26 <HAL_I2C_IsDeviceReady+0x226>
        {
          return HAL_ERROR;
 800af22:	2301      	movs	r3, #1
 800af24:	e012      	b.n	800af4c <HAL_I2C_IsDeviceReady+0x24c>
        }
      }

      /* Increment Trials */
      I2C_Trials++;
 800af26:	69bb      	ldr	r3, [r7, #24]
 800af28:	3301      	adds	r3, #1
 800af2a:	61bb      	str	r3, [r7, #24]
    }
    while (I2C_Trials < Trials);
 800af2c:	69ba      	ldr	r2, [r7, #24]
 800af2e:	687b      	ldr	r3, [r7, #4]
 800af30:	429a      	cmp	r2, r3
 800af32:	f4ff af32 	bcc.w	800ad9a <HAL_I2C_IsDeviceReady+0x9a>

    hi2c->State = HAL_I2C_STATE_READY;
 800af36:	68fb      	ldr	r3, [r7, #12]
 800af38:	2220      	movs	r2, #32
 800af3a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800af3e:	68fb      	ldr	r3, [r7, #12]
 800af40:	2200      	movs	r2, #0
 800af42:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_ERROR;
 800af46:	2301      	movs	r3, #1
 800af48:	e000      	b.n	800af4c <HAL_I2C_IsDeviceReady+0x24c>
  }
  else
  {
    return HAL_BUSY;
 800af4a:	2302      	movs	r3, #2
  }
}
 800af4c:	4618      	mov	r0, r3
 800af4e:	3720      	adds	r7, #32
 800af50:	46bd      	mov	sp, r7
 800af52:	bd80      	pop	{r7, pc}
 800af54:	00100002 	.word	0x00100002
 800af58:	ffff0000 	.word	0xffff0000

0800af5c <HAL_I2C_EV_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 800af5c:	b580      	push	{r7, lr}
 800af5e:	b088      	sub	sp, #32
 800af60:	af00      	add	r7, sp, #0
 800af62:	6078      	str	r0, [r7, #4]
  uint32_t sr1itflags;
  uint32_t sr2itflags               = 0U;
 800af64:	2300      	movs	r3, #0
 800af66:	61bb      	str	r3, [r7, #24]
  uint32_t itsources                = READ_REG(hi2c->Instance->CR2);
 800af68:	687b      	ldr	r3, [r7, #4]
 800af6a:	681b      	ldr	r3, [r3, #0]
 800af6c:	685b      	ldr	r3, [r3, #4]
 800af6e:	617b      	str	r3, [r7, #20]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 800af70:	687b      	ldr	r3, [r7, #4]
 800af72:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800af74:	613b      	str	r3, [r7, #16]
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 800af76:	687b      	ldr	r3, [r7, #4]
 800af78:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800af7c:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800af7e:	687b      	ldr	r3, [r7, #4]
 800af80:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800af84:	73bb      	strb	r3, [r7, #14]

  /* Master or Memory mode selected */
  if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 800af86:	7bfb      	ldrb	r3, [r7, #15]
 800af88:	2b10      	cmp	r3, #16
 800af8a:	d003      	beq.n	800af94 <HAL_I2C_EV_IRQHandler+0x38>
 800af8c:	7bfb      	ldrb	r3, [r7, #15]
 800af8e:	2b40      	cmp	r3, #64	@ 0x40
 800af90:	f040 80b1 	bne.w	800b0f6 <HAL_I2C_EV_IRQHandler+0x19a>
  {
    sr2itflags   = READ_REG(hi2c->Instance->SR2);
 800af94:	687b      	ldr	r3, [r7, #4]
 800af96:	681b      	ldr	r3, [r3, #0]
 800af98:	699b      	ldr	r3, [r3, #24]
 800af9a:	61bb      	str	r3, [r7, #24]
    sr1itflags   = READ_REG(hi2c->Instance->SR1);
 800af9c:	687b      	ldr	r3, [r7, #4]
 800af9e:	681b      	ldr	r3, [r3, #0]
 800afa0:	695b      	ldr	r3, [r3, #20]
 800afa2:	61fb      	str	r3, [r7, #28]

    /* Exit IRQ event until Start Bit detected in case of Other frame requested */
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) == RESET) && (IS_I2C_TRANSFER_OTHER_OPTIONS_REQUEST(CurrentXferOptions) == 1U))
 800afa4:	69fb      	ldr	r3, [r7, #28]
 800afa6:	f003 0301 	and.w	r3, r3, #1
 800afaa:	2b00      	cmp	r3, #0
 800afac:	d10d      	bne.n	800afca <HAL_I2C_EV_IRQHandler+0x6e>
 800afae:	693b      	ldr	r3, [r7, #16]
 800afb0:	f5b3 0f2a 	cmp.w	r3, #11141120	@ 0xaa0000
 800afb4:	d003      	beq.n	800afbe <HAL_I2C_EV_IRQHandler+0x62>
 800afb6:	693b      	ldr	r3, [r7, #16]
 800afb8:	f1b3 4f2a 	cmp.w	r3, #2852126720	@ 0xaa000000
 800afbc:	d101      	bne.n	800afc2 <HAL_I2C_EV_IRQHandler+0x66>
 800afbe:	2301      	movs	r3, #1
 800afc0:	e000      	b.n	800afc4 <HAL_I2C_EV_IRQHandler+0x68>
 800afc2:	2300      	movs	r3, #0
 800afc4:	2b01      	cmp	r3, #1
 800afc6:	f000 8114 	beq.w	800b1f2 <HAL_I2C_EV_IRQHandler+0x296>
    {
      return;
    }

    /* SB Set ----------------------------------------------------------------*/
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800afca:	69fb      	ldr	r3, [r7, #28]
 800afcc:	f003 0301 	and.w	r3, r3, #1
 800afd0:	2b00      	cmp	r3, #0
 800afd2:	d00b      	beq.n	800afec <HAL_I2C_EV_IRQHandler+0x90>
 800afd4:	697b      	ldr	r3, [r7, #20]
 800afd6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800afda:	2b00      	cmp	r3, #0
 800afdc:	d006      	beq.n	800afec <HAL_I2C_EV_IRQHandler+0x90>
    {
      /* Convert OTHER_xxx XferOptions if any */
      I2C_ConvertOtherXferOptions(hi2c);
 800afde:	6878      	ldr	r0, [r7, #4]
 800afe0:	f002 f81e 	bl	800d020 <I2C_ConvertOtherXferOptions>

      I2C_Master_SB(hi2c);
 800afe4:	6878      	ldr	r0, [r7, #4]
 800afe6:	f000 fd70 	bl	800baca <I2C_Master_SB>
 800afea:	e083      	b.n	800b0f4 <HAL_I2C_EV_IRQHandler+0x198>
    }
    /* ADD10 Set -------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADD10) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800afec:	69fb      	ldr	r3, [r7, #28]
 800afee:	f003 0308 	and.w	r3, r3, #8
 800aff2:	2b00      	cmp	r3, #0
 800aff4:	d008      	beq.n	800b008 <HAL_I2C_EV_IRQHandler+0xac>
 800aff6:	697b      	ldr	r3, [r7, #20]
 800aff8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800affc:	2b00      	cmp	r3, #0
 800affe:	d003      	beq.n	800b008 <HAL_I2C_EV_IRQHandler+0xac>
    {
      I2C_Master_ADD10(hi2c);
 800b000:	6878      	ldr	r0, [r7, #4]
 800b002:	f000 fde8 	bl	800bbd6 <I2C_Master_ADD10>
 800b006:	e075      	b.n	800b0f4 <HAL_I2C_EV_IRQHandler+0x198>
    }
    /* ADDR Set --------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b008:	69fb      	ldr	r3, [r7, #28]
 800b00a:	f003 0302 	and.w	r3, r3, #2
 800b00e:	2b00      	cmp	r3, #0
 800b010:	d008      	beq.n	800b024 <HAL_I2C_EV_IRQHandler+0xc8>
 800b012:	697b      	ldr	r3, [r7, #20]
 800b014:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b018:	2b00      	cmp	r3, #0
 800b01a:	d003      	beq.n	800b024 <HAL_I2C_EV_IRQHandler+0xc8>
    {
      I2C_Master_ADDR(hi2c);
 800b01c:	6878      	ldr	r0, [r7, #4]
 800b01e:	f000 fe04 	bl	800bc2a <I2C_Master_ADDR>
 800b022:	e067      	b.n	800b0f4 <HAL_I2C_EV_IRQHandler+0x198>
    }
    /* I2C in mode Transmitter -----------------------------------------------*/
    else if (I2C_CHECK_FLAG(sr2itflags, I2C_FLAG_TRA) != RESET)
 800b024:	69bb      	ldr	r3, [r7, #24]
 800b026:	f003 0304 	and.w	r3, r3, #4
 800b02a:	2b00      	cmp	r3, #0
 800b02c:	d036      	beq.n	800b09c <HAL_I2C_EV_IRQHandler+0x140>
    {
      /* Do not check buffer and BTF flag if a Xfer DMA is on going */
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 800b02e:	687b      	ldr	r3, [r7, #4]
 800b030:	681b      	ldr	r3, [r3, #0]
 800b032:	685b      	ldr	r3, [r3, #4]
 800b034:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800b038:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800b03c:	f000 80db 	beq.w	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
      {
        /* TXE set and BTF reset -----------------------------------------------*/
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800b040:	69fb      	ldr	r3, [r7, #28]
 800b042:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800b046:	2b00      	cmp	r3, #0
 800b048:	d00d      	beq.n	800b066 <HAL_I2C_EV_IRQHandler+0x10a>
 800b04a:	697b      	ldr	r3, [r7, #20]
 800b04c:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800b050:	2b00      	cmp	r3, #0
 800b052:	d008      	beq.n	800b066 <HAL_I2C_EV_IRQHandler+0x10a>
 800b054:	69fb      	ldr	r3, [r7, #28]
 800b056:	f003 0304 	and.w	r3, r3, #4
 800b05a:	2b00      	cmp	r3, #0
 800b05c:	d103      	bne.n	800b066 <HAL_I2C_EV_IRQHandler+0x10a>
        {
          I2C_MasterTransmit_TXE(hi2c);
 800b05e:	6878      	ldr	r0, [r7, #4]
 800b060:	f000 f9cc 	bl	800b3fc <I2C_MasterTransmit_TXE>
 800b064:	e046      	b.n	800b0f4 <HAL_I2C_EV_IRQHandler+0x198>
        }
        /* BTF set -------------------------------------------------------------*/
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b066:	69fb      	ldr	r3, [r7, #28]
 800b068:	f003 0304 	and.w	r3, r3, #4
 800b06c:	2b00      	cmp	r3, #0
 800b06e:	f000 80c2 	beq.w	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
 800b072:	697b      	ldr	r3, [r7, #20]
 800b074:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b078:	2b00      	cmp	r3, #0
 800b07a:	f000 80bc 	beq.w	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
        {
          if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 800b07e:	7bbb      	ldrb	r3, [r7, #14]
 800b080:	2b21      	cmp	r3, #33	@ 0x21
 800b082:	d103      	bne.n	800b08c <HAL_I2C_EV_IRQHandler+0x130>
          {
            I2C_MasterTransmit_BTF(hi2c);
 800b084:	6878      	ldr	r0, [r7, #4]
 800b086:	f000 fa55 	bl	800b534 <I2C_MasterTransmit_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b08a:	e0b4      	b.n	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
          }
          else /* HAL_I2C_MODE_MEM */
          {
            if (CurrentMode == HAL_I2C_MODE_MEM)
 800b08c:	7bfb      	ldrb	r3, [r7, #15]
 800b08e:	2b40      	cmp	r3, #64	@ 0x40
 800b090:	f040 80b1 	bne.w	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
            {
              I2C_MemoryTransmit_TXE_BTF(hi2c);
 800b094:	6878      	ldr	r0, [r7, #4]
 800b096:	f000 fac3 	bl	800b620 <I2C_MemoryTransmit_TXE_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b09a:	e0ac      	b.n	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
    }
    /* I2C in mode Receiver --------------------------------------------------*/
    else
    {
      /* Do not check buffer and BTF flag if a Xfer DMA is on going */
      if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN)
 800b09c:	687b      	ldr	r3, [r7, #4]
 800b09e:	681b      	ldr	r3, [r3, #0]
 800b0a0:	685b      	ldr	r3, [r3, #4]
 800b0a2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800b0a6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800b0aa:	f000 80a4 	beq.w	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
      {
        /* RXNE set and BTF reset -----------------------------------------------*/
        if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800b0ae:	69fb      	ldr	r3, [r7, #28]
 800b0b0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800b0b4:	2b00      	cmp	r3, #0
 800b0b6:	d00d      	beq.n	800b0d4 <HAL_I2C_EV_IRQHandler+0x178>
 800b0b8:	697b      	ldr	r3, [r7, #20]
 800b0ba:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800b0be:	2b00      	cmp	r3, #0
 800b0c0:	d008      	beq.n	800b0d4 <HAL_I2C_EV_IRQHandler+0x178>
 800b0c2:	69fb      	ldr	r3, [r7, #28]
 800b0c4:	f003 0304 	and.w	r3, r3, #4
 800b0c8:	2b00      	cmp	r3, #0
 800b0ca:	d103      	bne.n	800b0d4 <HAL_I2C_EV_IRQHandler+0x178>
        {
          I2C_MasterReceive_RXNE(hi2c);
 800b0cc:	6878      	ldr	r0, [r7, #4]
 800b0ce:	f000 fb3f 	bl	800b750 <I2C_MasterReceive_RXNE>
 800b0d2:	e00f      	b.n	800b0f4 <HAL_I2C_EV_IRQHandler+0x198>
        }
        /* BTF set -------------------------------------------------------------*/
        else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b0d4:	69fb      	ldr	r3, [r7, #28]
 800b0d6:	f003 0304 	and.w	r3, r3, #4
 800b0da:	2b00      	cmp	r3, #0
 800b0dc:	f000 808b 	beq.w	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
 800b0e0:	697b      	ldr	r3, [r7, #20]
 800b0e2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b0e6:	2b00      	cmp	r3, #0
 800b0e8:	f000 8085 	beq.w	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
        {
          I2C_MasterReceive_BTF(hi2c);
 800b0ec:	6878      	ldr	r0, [r7, #4]
 800b0ee:	f000 fbf7 	bl	800b8e0 <I2C_MasterReceive_BTF>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b0f2:	e080      	b.n	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
 800b0f4:	e07f      	b.n	800b1f6 <HAL_I2C_EV_IRQHandler+0x29a>
  /* Slave mode selected */
  else
  {
    /* If an error is detected, read only SR1 register to prevent */
    /* a clear of ADDR flags by reading SR2 after reading SR1 in Error treatment */
    if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800b0f6:	687b      	ldr	r3, [r7, #4]
 800b0f8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b0fa:	2b00      	cmp	r3, #0
 800b0fc:	d004      	beq.n	800b108 <HAL_I2C_EV_IRQHandler+0x1ac>
    {
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 800b0fe:	687b      	ldr	r3, [r7, #4]
 800b100:	681b      	ldr	r3, [r3, #0]
 800b102:	695b      	ldr	r3, [r3, #20]
 800b104:	61fb      	str	r3, [r7, #28]
 800b106:	e007      	b.n	800b118 <HAL_I2C_EV_IRQHandler+0x1bc>
    }
    else
    {
      sr2itflags   = READ_REG(hi2c->Instance->SR2);
 800b108:	687b      	ldr	r3, [r7, #4]
 800b10a:	681b      	ldr	r3, [r3, #0]
 800b10c:	699b      	ldr	r3, [r3, #24]
 800b10e:	61bb      	str	r3, [r7, #24]
      sr1itflags   = READ_REG(hi2c->Instance->SR1);
 800b110:	687b      	ldr	r3, [r7, #4]
 800b112:	681b      	ldr	r3, [r3, #0]
 800b114:	695b      	ldr	r3, [r3, #20]
 800b116:	61fb      	str	r3, [r7, #28]
    }

    /* ADDR set --------------------------------------------------------------*/
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b118:	69fb      	ldr	r3, [r7, #28]
 800b11a:	f003 0302 	and.w	r3, r3, #2
 800b11e:	2b00      	cmp	r3, #0
 800b120:	d011      	beq.n	800b146 <HAL_I2C_EV_IRQHandler+0x1ea>
 800b122:	697b      	ldr	r3, [r7, #20]
 800b124:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b128:	2b00      	cmp	r3, #0
 800b12a:	d00c      	beq.n	800b146 <HAL_I2C_EV_IRQHandler+0x1ea>
    {
      /* Now time to read SR2, this will clear ADDR flag automatically */
      if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800b12c:	687b      	ldr	r3, [r7, #4]
 800b12e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800b130:	2b00      	cmp	r3, #0
 800b132:	d003      	beq.n	800b13c <HAL_I2C_EV_IRQHandler+0x1e0>
      {
        sr2itflags   = READ_REG(hi2c->Instance->SR2);
 800b134:	687b      	ldr	r3, [r7, #4]
 800b136:	681b      	ldr	r3, [r3, #0]
 800b138:	699b      	ldr	r3, [r3, #24]
 800b13a:	61bb      	str	r3, [r7, #24]
      }
      I2C_Slave_ADDR(hi2c, sr2itflags);
 800b13c:	69b9      	ldr	r1, [r7, #24]
 800b13e:	6878      	ldr	r0, [r7, #4]
 800b140:	f000 ffc2 	bl	800c0c8 <I2C_Slave_ADDR>
 800b144:	e05a      	b.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
    }
    /* STOPF set --------------------------------------------------------------*/
    else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b146:	69fb      	ldr	r3, [r7, #28]
 800b148:	f003 0310 	and.w	r3, r3, #16
 800b14c:	2b00      	cmp	r3, #0
 800b14e:	d008      	beq.n	800b162 <HAL_I2C_EV_IRQHandler+0x206>
 800b150:	697b      	ldr	r3, [r7, #20]
 800b152:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b156:	2b00      	cmp	r3, #0
 800b158:	d003      	beq.n	800b162 <HAL_I2C_EV_IRQHandler+0x206>
    {
      I2C_Slave_STOPF(hi2c);
 800b15a:	6878      	ldr	r0, [r7, #4]
 800b15c:	f000 fffc 	bl	800c158 <I2C_Slave_STOPF>
 800b160:	e04c      	b.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
    }
    /* I2C in mode Transmitter -----------------------------------------------*/
    else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 800b162:	7bbb      	ldrb	r3, [r7, #14]
 800b164:	2b21      	cmp	r3, #33	@ 0x21
 800b166:	d002      	beq.n	800b16e <HAL_I2C_EV_IRQHandler+0x212>
 800b168:	7bbb      	ldrb	r3, [r7, #14]
 800b16a:	2b29      	cmp	r3, #41	@ 0x29
 800b16c:	d120      	bne.n	800b1b0 <HAL_I2C_EV_IRQHandler+0x254>
    {
      /* TXE set and BTF reset -----------------------------------------------*/
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800b16e:	69fb      	ldr	r3, [r7, #28]
 800b170:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800b174:	2b00      	cmp	r3, #0
 800b176:	d00d      	beq.n	800b194 <HAL_I2C_EV_IRQHandler+0x238>
 800b178:	697b      	ldr	r3, [r7, #20]
 800b17a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800b17e:	2b00      	cmp	r3, #0
 800b180:	d008      	beq.n	800b194 <HAL_I2C_EV_IRQHandler+0x238>
 800b182:	69fb      	ldr	r3, [r7, #28]
 800b184:	f003 0304 	and.w	r3, r3, #4
 800b188:	2b00      	cmp	r3, #0
 800b18a:	d103      	bne.n	800b194 <HAL_I2C_EV_IRQHandler+0x238>
      {
        I2C_SlaveTransmit_TXE(hi2c);
 800b18c:	6878      	ldr	r0, [r7, #4]
 800b18e:	f000 fedd 	bl	800bf4c <I2C_SlaveTransmit_TXE>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800b192:	e032      	b.n	800b1fa <HAL_I2C_EV_IRQHandler+0x29e>
      }
      /* BTF set -------------------------------------------------------------*/
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b194:	69fb      	ldr	r3, [r7, #28]
 800b196:	f003 0304 	and.w	r3, r3, #4
 800b19a:	2b00      	cmp	r3, #0
 800b19c:	d02d      	beq.n	800b1fa <HAL_I2C_EV_IRQHandler+0x29e>
 800b19e:	697b      	ldr	r3, [r7, #20]
 800b1a0:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b1a4:	2b00      	cmp	r3, #0
 800b1a6:	d028      	beq.n	800b1fa <HAL_I2C_EV_IRQHandler+0x29e>
      {
        I2C_SlaveTransmit_BTF(hi2c);
 800b1a8:	6878      	ldr	r0, [r7, #4]
 800b1aa:	f000 ff0c 	bl	800bfc6 <I2C_SlaveTransmit_BTF>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800b1ae:	e024      	b.n	800b1fa <HAL_I2C_EV_IRQHandler+0x29e>
    }
    /* I2C in mode Receiver --------------------------------------------------*/
    else
    {
      /* RXNE set and BTF reset ----------------------------------------------*/
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800b1b0:	69fb      	ldr	r3, [r7, #28]
 800b1b2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800b1b6:	2b00      	cmp	r3, #0
 800b1b8:	d00d      	beq.n	800b1d6 <HAL_I2C_EV_IRQHandler+0x27a>
 800b1ba:	697b      	ldr	r3, [r7, #20]
 800b1bc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800b1c0:	2b00      	cmp	r3, #0
 800b1c2:	d008      	beq.n	800b1d6 <HAL_I2C_EV_IRQHandler+0x27a>
 800b1c4:	69fb      	ldr	r3, [r7, #28]
 800b1c6:	f003 0304 	and.w	r3, r3, #4
 800b1ca:	2b00      	cmp	r3, #0
 800b1cc:	d103      	bne.n	800b1d6 <HAL_I2C_EV_IRQHandler+0x27a>
      {
        I2C_SlaveReceive_RXNE(hi2c);
 800b1ce:	6878      	ldr	r0, [r7, #4]
 800b1d0:	f000 ff1a 	bl	800c008 <I2C_SlaveReceive_RXNE>
 800b1d4:	e012      	b.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
      }
      /* BTF set -------------------------------------------------------------*/
      else if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b1d6:	69fb      	ldr	r3, [r7, #28]
 800b1d8:	f003 0304 	and.w	r3, r3, #4
 800b1dc:	2b00      	cmp	r3, #0
 800b1de:	d00d      	beq.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
 800b1e0:	697b      	ldr	r3, [r7, #20]
 800b1e2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b1e6:	2b00      	cmp	r3, #0
 800b1e8:	d008      	beq.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
      {
        I2C_SlaveReceive_BTF(hi2c);
 800b1ea:	6878      	ldr	r0, [r7, #4]
 800b1ec:	f000 ff4a 	bl	800c084 <I2C_SlaveReceive_BTF>
 800b1f0:	e004      	b.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
      return;
 800b1f2:	bf00      	nop
 800b1f4:	e002      	b.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
    if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_SB) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_EVT) != RESET))
 800b1f6:	bf00      	nop
 800b1f8:	e000      	b.n	800b1fc <HAL_I2C_EV_IRQHandler+0x2a0>
      if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_TXE) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_BUF) != RESET) && (I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BTF) == RESET))
 800b1fa:	bf00      	nop
      {
        /* Do nothing */
      }
    }
  }
}
 800b1fc:	3720      	adds	r7, #32
 800b1fe:	46bd      	mov	sp, r7
 800b200:	bd80      	pop	{r7, pc}

0800b202 <HAL_I2C_ER_IRQHandler>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
void HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)
{
 800b202:	b580      	push	{r7, lr}
 800b204:	b08a      	sub	sp, #40	@ 0x28
 800b206:	af00      	add	r7, sp, #0
 800b208:	6078      	str	r0, [r7, #4]
  HAL_I2C_ModeTypeDef tmp1;
  uint32_t tmp2;
  HAL_I2C_StateTypeDef tmp3;
  uint32_t tmp4;
  uint32_t sr1itflags = READ_REG(hi2c->Instance->SR1);
 800b20a:	687b      	ldr	r3, [r7, #4]
 800b20c:	681b      	ldr	r3, [r3, #0]
 800b20e:	695b      	ldr	r3, [r3, #20]
 800b210:	623b      	str	r3, [r7, #32]
  uint32_t itsources  = READ_REG(hi2c->Instance->CR2);
 800b212:	687b      	ldr	r3, [r7, #4]
 800b214:	681b      	ldr	r3, [r3, #0]
 800b216:	685b      	ldr	r3, [r3, #4]
 800b218:	61fb      	str	r3, [r7, #28]
  uint32_t error      = HAL_I2C_ERROR_NONE;
 800b21a:	2300      	movs	r3, #0
 800b21c:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 800b21e:	687b      	ldr	r3, [r7, #4]
 800b220:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800b224:	76fb      	strb	r3, [r7, #27]

  /* I2C Bus error interrupt occurred ----------------------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 800b226:	6a3b      	ldr	r3, [r7, #32]
 800b228:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800b22c:	2b00      	cmp	r3, #0
 800b22e:	d00d      	beq.n	800b24c <HAL_I2C_ER_IRQHandler+0x4a>
 800b230:	69fb      	ldr	r3, [r7, #28]
 800b232:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800b236:	2b00      	cmp	r3, #0
 800b238:	d008      	beq.n	800b24c <HAL_I2C_ER_IRQHandler+0x4a>
  {
    error |= HAL_I2C_ERROR_BERR;
 800b23a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b23c:	f043 0301 	orr.w	r3, r3, #1
 800b240:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 800b242:	687b      	ldr	r3, [r7, #4]
 800b244:	681b      	ldr	r3, [r3, #0]
 800b246:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 800b24a:	615a      	str	r2, [r3, #20]
  }

  /* I2C Arbitration Lost error interrupt occurred ---------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 800b24c:	6a3b      	ldr	r3, [r7, #32]
 800b24e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800b252:	2b00      	cmp	r3, #0
 800b254:	d00d      	beq.n	800b272 <HAL_I2C_ER_IRQHandler+0x70>
 800b256:	69fb      	ldr	r3, [r7, #28]
 800b258:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800b25c:	2b00      	cmp	r3, #0
 800b25e:	d008      	beq.n	800b272 <HAL_I2C_ER_IRQHandler+0x70>
  {
    error |= HAL_I2C_ERROR_ARLO;
 800b260:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b262:	f043 0302 	orr.w	r3, r3, #2
 800b266:	627b      	str	r3, [r7, #36]	@ 0x24

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 800b268:	687b      	ldr	r3, [r7, #4]
 800b26a:	681b      	ldr	r3, [r3, #0]
 800b26c:	f46f 7200 	mvn.w	r2, #512	@ 0x200
 800b270:	615a      	str	r2, [r3, #20]
  }

  /* I2C Acknowledge failure error interrupt occurred ------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 800b272:	6a3b      	ldr	r3, [r7, #32]
 800b274:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800b278:	2b00      	cmp	r3, #0
 800b27a:	d03e      	beq.n	800b2fa <HAL_I2C_ER_IRQHandler+0xf8>
 800b27c:	69fb      	ldr	r3, [r7, #28]
 800b27e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800b282:	2b00      	cmp	r3, #0
 800b284:	d039      	beq.n	800b2fa <HAL_I2C_ER_IRQHandler+0xf8>
  {
    tmp1 = CurrentMode;
 800b286:	7efb      	ldrb	r3, [r7, #27]
 800b288:	76bb      	strb	r3, [r7, #26]
    tmp2 = hi2c->XferCount;
 800b28a:	687b      	ldr	r3, [r7, #4]
 800b28c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b28e:	b29b      	uxth	r3, r3
 800b290:	617b      	str	r3, [r7, #20]
    tmp3 = hi2c->State;
 800b292:	687b      	ldr	r3, [r7, #4]
 800b294:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800b298:	74fb      	strb	r3, [r7, #19]
    tmp4 = hi2c->PreviousState;
 800b29a:	687b      	ldr	r3, [r7, #4]
 800b29c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800b29e:	60fb      	str	r3, [r7, #12]
    if ((tmp1 == HAL_I2C_MODE_SLAVE) && (tmp2 == 0U) && \
 800b2a0:	7ebb      	ldrb	r3, [r7, #26]
 800b2a2:	2b20      	cmp	r3, #32
 800b2a4:	d112      	bne.n	800b2cc <HAL_I2C_ER_IRQHandler+0xca>
 800b2a6:	697b      	ldr	r3, [r7, #20]
 800b2a8:	2b00      	cmp	r3, #0
 800b2aa:	d10f      	bne.n	800b2cc <HAL_I2C_ER_IRQHandler+0xca>
 800b2ac:	7cfb      	ldrb	r3, [r7, #19]
 800b2ae:	2b21      	cmp	r3, #33	@ 0x21
 800b2b0:	d008      	beq.n	800b2c4 <HAL_I2C_ER_IRQHandler+0xc2>
        ((tmp3 == HAL_I2C_STATE_BUSY_TX) || (tmp3 == HAL_I2C_STATE_BUSY_TX_LISTEN) || \
 800b2b2:	7cfb      	ldrb	r3, [r7, #19]
 800b2b4:	2b29      	cmp	r3, #41	@ 0x29
 800b2b6:	d005      	beq.n	800b2c4 <HAL_I2C_ER_IRQHandler+0xc2>
 800b2b8:	7cfb      	ldrb	r3, [r7, #19]
 800b2ba:	2b28      	cmp	r3, #40	@ 0x28
 800b2bc:	d106      	bne.n	800b2cc <HAL_I2C_ER_IRQHandler+0xca>
         ((tmp3 == HAL_I2C_STATE_LISTEN) && (tmp4 == I2C_STATE_SLAVE_BUSY_TX))))
 800b2be:	68fb      	ldr	r3, [r7, #12]
 800b2c0:	2b21      	cmp	r3, #33	@ 0x21
 800b2c2:	d103      	bne.n	800b2cc <HAL_I2C_ER_IRQHandler+0xca>
    {
      I2C_Slave_AF(hi2c);
 800b2c4:	6878      	ldr	r0, [r7, #4]
 800b2c6:	f001 f877 	bl	800c3b8 <I2C_Slave_AF>
 800b2ca:	e016      	b.n	800b2fa <HAL_I2C_ER_IRQHandler+0xf8>
    }
    else
    {
      /* Clear AF flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800b2cc:	687b      	ldr	r3, [r7, #4]
 800b2ce:	681b      	ldr	r3, [r3, #0]
 800b2d0:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 800b2d4:	615a      	str	r2, [r3, #20]

      error |= HAL_I2C_ERROR_AF;
 800b2d6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b2d8:	f043 0304 	orr.w	r3, r3, #4
 800b2dc:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Do not generate a STOP in case of Slave receive non acknowledge during transfer (mean not at the end of transfer) */
      if ((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM))
 800b2de:	7efb      	ldrb	r3, [r7, #27]
 800b2e0:	2b10      	cmp	r3, #16
 800b2e2:	d002      	beq.n	800b2ea <HAL_I2C_ER_IRQHandler+0xe8>
 800b2e4:	7efb      	ldrb	r3, [r7, #27]
 800b2e6:	2b40      	cmp	r3, #64	@ 0x40
 800b2e8:	d107      	bne.n	800b2fa <HAL_I2C_ER_IRQHandler+0xf8>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800b2ea:	687b      	ldr	r3, [r7, #4]
 800b2ec:	681b      	ldr	r3, [r3, #0]
 800b2ee:	681a      	ldr	r2, [r3, #0]
 800b2f0:	687b      	ldr	r3, [r7, #4]
 800b2f2:	681b      	ldr	r3, [r3, #0]
 800b2f4:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800b2f8:	601a      	str	r2, [r3, #0]
      }
    }
  }

  /* I2C Over-Run/Under-Run interrupt occurred -------------------------------*/
  if ((I2C_CHECK_FLAG(sr1itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERR) != RESET))
 800b2fa:	6a3b      	ldr	r3, [r7, #32]
 800b2fc:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800b300:	2b00      	cmp	r3, #0
 800b302:	d00d      	beq.n	800b320 <HAL_I2C_ER_IRQHandler+0x11e>
 800b304:	69fb      	ldr	r3, [r7, #28]
 800b306:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800b30a:	2b00      	cmp	r3, #0
 800b30c:	d008      	beq.n	800b320 <HAL_I2C_ER_IRQHandler+0x11e>
  {
    error |= HAL_I2C_ERROR_OVR;
 800b30e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b310:	f043 0308 	orr.w	r3, r3, #8
 800b314:	627b      	str	r3, [r7, #36]	@ 0x24
    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 800b316:	687b      	ldr	r3, [r7, #4]
 800b318:	681b      	ldr	r3, [r3, #0]
 800b31a:	f46f 6200 	mvn.w	r2, #2048	@ 0x800
 800b31e:	615a      	str	r2, [r3, #20]
  }

  /* Call the Error Callback in case of Error detected -----------------------*/
  if (error != HAL_I2C_ERROR_NONE)
 800b320:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b322:	2b00      	cmp	r3, #0
 800b324:	d008      	beq.n	800b338 <HAL_I2C_ER_IRQHandler+0x136>
  {
    hi2c->ErrorCode |= error;
 800b326:	687b      	ldr	r3, [r7, #4]
 800b328:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800b32a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800b32c:	431a      	orrs	r2, r3
 800b32e:	687b      	ldr	r3, [r7, #4]
 800b330:	641a      	str	r2, [r3, #64]	@ 0x40
    I2C_ITError(hi2c);
 800b332:	6878      	ldr	r0, [r7, #4]
 800b334:	f001 f8b4 	bl	800c4a0 <I2C_ITError>
  }
}
 800b338:	bf00      	nop
 800b33a:	3728      	adds	r7, #40	@ 0x28
 800b33c:	46bd      	mov	sp, r7
 800b33e:	bd80      	pop	{r7, pc}

0800b340 <HAL_I2C_MasterTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b340:	b480      	push	{r7}
 800b342:	b083      	sub	sp, #12
 800b344:	af00      	add	r7, sp, #0
 800b346:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterTxCpltCallback could be implemented in the user file
   */
}
 800b348:	bf00      	nop
 800b34a:	370c      	adds	r7, #12
 800b34c:	46bd      	mov	sp, r7
 800b34e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b352:	4770      	bx	lr

0800b354 <HAL_I2C_MasterRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b354:	b480      	push	{r7}
 800b356:	b083      	sub	sp, #12
 800b358:	af00      	add	r7, sp, #0
 800b35a:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MasterRxCpltCallback could be implemented in the user file
   */
}
 800b35c:	bf00      	nop
 800b35e:	370c      	adds	r7, #12
 800b360:	46bd      	mov	sp, r7
 800b362:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b366:	4770      	bx	lr

0800b368 <HAL_I2C_SlaveTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b368:	b480      	push	{r7}
 800b36a:	b083      	sub	sp, #12
 800b36c:	af00      	add	r7, sp, #0
 800b36e:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveTxCpltCallback could be implemented in the user file
   */
}
 800b370:	bf00      	nop
 800b372:	370c      	adds	r7, #12
 800b374:	46bd      	mov	sp, r7
 800b376:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b37a:	4770      	bx	lr

0800b37c <HAL_I2C_SlaveRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b37c:	b480      	push	{r7}
 800b37e:	b083      	sub	sp, #12
 800b380:	af00      	add	r7, sp, #0
 800b382:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_SlaveRxCpltCallback could be implemented in the user file
   */
}
 800b384:	bf00      	nop
 800b386:	370c      	adds	r7, #12
 800b388:	46bd      	mov	sp, r7
 800b38a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b38e:	4770      	bx	lr

0800b390 <HAL_I2C_AddrCallback>:
  * @param  TransferDirection Master request Transfer Direction (Write/Read), value of @ref I2C_XferDirection_definition
  * @param  AddrMatchCode Address Match Code
  * @retval None
  */
__weak void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t TransferDirection, uint16_t AddrMatchCode)
{
 800b390:	b480      	push	{r7}
 800b392:	b083      	sub	sp, #12
 800b394:	af00      	add	r7, sp, #0
 800b396:	6078      	str	r0, [r7, #4]
 800b398:	460b      	mov	r3, r1
 800b39a:	70fb      	strb	r3, [r7, #3]
 800b39c:	4613      	mov	r3, r2
 800b39e:	803b      	strh	r3, [r7, #0]
  UNUSED(AddrMatchCode);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AddrCallback() could be implemented in the user file
   */
}
 800b3a0:	bf00      	nop
 800b3a2:	370c      	adds	r7, #12
 800b3a4:	46bd      	mov	sp, r7
 800b3a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3aa:	4770      	bx	lr

0800b3ac <HAL_I2C_ListenCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b3ac:	b480      	push	{r7}
 800b3ae:	b083      	sub	sp, #12
 800b3b0:	af00      	add	r7, sp, #0
 800b3b2:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_ListenCpltCallback() could be implemented in the user file
  */
}
 800b3b4:	bf00      	nop
 800b3b6:	370c      	adds	r7, #12
 800b3b8:	46bd      	mov	sp, r7
 800b3ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3be:	4770      	bx	lr

0800b3c0 <HAL_I2C_MemTxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b3c0:	b480      	push	{r7}
 800b3c2:	b083      	sub	sp, #12
 800b3c4:	af00      	add	r7, sp, #0
 800b3c6:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemTxCpltCallback could be implemented in the user file
   */
}
 800b3c8:	bf00      	nop
 800b3ca:	370c      	adds	r7, #12
 800b3cc:	46bd      	mov	sp, r7
 800b3ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3d2:	4770      	bx	lr

0800b3d4 <HAL_I2C_MemRxCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b3d4:	b480      	push	{r7}
 800b3d6:	b083      	sub	sp, #12
 800b3d8:	af00      	add	r7, sp, #0
 800b3da:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MemRxCpltCallback could be implemented in the user file
   */
}
 800b3dc:	bf00      	nop
 800b3de:	370c      	adds	r7, #12
 800b3e0:	46bd      	mov	sp, r7
 800b3e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3e6:	4770      	bx	lr

0800b3e8 <HAL_I2C_AbortCpltCallback>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)
{
 800b3e8:	b480      	push	{r7}
 800b3ea:	b083      	sub	sp, #12
 800b3ec:	af00      	add	r7, sp, #0
 800b3ee:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_AbortCpltCallback could be implemented in the user file
   */
}
 800b3f0:	bf00      	nop
 800b3f2:	370c      	adds	r7, #12
 800b3f4:	46bd      	mov	sp, r7
 800b3f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3fa:	4770      	bx	lr

0800b3fc <I2C_MasterTransmit_TXE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)
{
 800b3fc:	b580      	push	{r7, lr}
 800b3fe:	b084      	sub	sp, #16
 800b400:	af00      	add	r7, sp, #0
 800b402:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800b404:	687b      	ldr	r3, [r7, #4]
 800b406:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800b40a:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_ModeTypeDef CurrentMode   = hi2c->Mode;
 800b40c:	687b      	ldr	r3, [r7, #4]
 800b40e:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800b412:	73bb      	strb	r3, [r7, #14]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 800b414:	687b      	ldr	r3, [r7, #4]
 800b416:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b418:	60bb      	str	r3, [r7, #8]

  if ((hi2c->XferSize == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 800b41a:	687b      	ldr	r3, [r7, #4]
 800b41c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800b41e:	2b00      	cmp	r3, #0
 800b420:	d150      	bne.n	800b4c4 <I2C_MasterTransmit_TXE+0xc8>
 800b422:	7bfb      	ldrb	r3, [r7, #15]
 800b424:	2b21      	cmp	r3, #33	@ 0x21
 800b426:	d14d      	bne.n	800b4c4 <I2C_MasterTransmit_TXE+0xc8>
  {
    /* Call TxCpltCallback() directly if no stop mode is set */
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 800b428:	68bb      	ldr	r3, [r7, #8]
 800b42a:	2b08      	cmp	r3, #8
 800b42c:	d01d      	beq.n	800b46a <I2C_MasterTransmit_TXE+0x6e>
 800b42e:	68bb      	ldr	r3, [r7, #8]
 800b430:	2b20      	cmp	r3, #32
 800b432:	d01a      	beq.n	800b46a <I2C_MasterTransmit_TXE+0x6e>
 800b434:	68bb      	ldr	r3, [r7, #8]
 800b436:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 800b43a:	d016      	beq.n	800b46a <I2C_MasterTransmit_TXE+0x6e>
    {
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800b43c:	687b      	ldr	r3, [r7, #4]
 800b43e:	681b      	ldr	r3, [r3, #0]
 800b440:	685a      	ldr	r2, [r3, #4]
 800b442:	687b      	ldr	r3, [r7, #4]
 800b444:	681b      	ldr	r3, [r3, #0]
 800b446:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b44a:	605a      	str	r2, [r3, #4]

      hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 800b44c:	687b      	ldr	r3, [r7, #4]
 800b44e:	2211      	movs	r2, #17
 800b450:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800b452:	687b      	ldr	r3, [r7, #4]
 800b454:	2200      	movs	r2, #0
 800b456:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->State = HAL_I2C_STATE_READY;
 800b45a:	687b      	ldr	r3, [r7, #4]
 800b45c:	2220      	movs	r2, #32
 800b45e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->MasterTxCpltCallback(hi2c);
#else
      HAL_I2C_MasterTxCpltCallback(hi2c);
 800b462:	6878      	ldr	r0, [r7, #4]
 800b464:	f7ff ff6c 	bl	800b340 <HAL_I2C_MasterTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 800b468:	e060      	b.n	800b52c <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
    else /* Generate Stop condition then Call TxCpltCallback() */
    {
      /* Disable EVT, BUF and ERR interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800b46a:	687b      	ldr	r3, [r7, #4]
 800b46c:	681b      	ldr	r3, [r3, #0]
 800b46e:	685a      	ldr	r2, [r3, #4]
 800b470:	687b      	ldr	r3, [r7, #4]
 800b472:	681b      	ldr	r3, [r3, #0]
 800b474:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b478:	605a      	str	r2, [r3, #4]

      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800b47a:	687b      	ldr	r3, [r7, #4]
 800b47c:	681b      	ldr	r3, [r3, #0]
 800b47e:	681a      	ldr	r2, [r3, #0]
 800b480:	687b      	ldr	r3, [r7, #4]
 800b482:	681b      	ldr	r3, [r3, #0]
 800b484:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800b488:	601a      	str	r2, [r3, #0]

      hi2c->PreviousState = I2C_STATE_NONE;
 800b48a:	687b      	ldr	r3, [r7, #4]
 800b48c:	2200      	movs	r2, #0
 800b48e:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 800b490:	687b      	ldr	r3, [r7, #4]
 800b492:	2220      	movs	r2, #32
 800b494:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800b498:	687b      	ldr	r3, [r7, #4]
 800b49a:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800b49e:	b2db      	uxtb	r3, r3
 800b4a0:	2b40      	cmp	r3, #64	@ 0x40
 800b4a2:	d107      	bne.n	800b4b4 <I2C_MasterTransmit_TXE+0xb8>
      {
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800b4a4:	687b      	ldr	r3, [r7, #4]
 800b4a6:	2200      	movs	r2, #0
 800b4a8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
        hi2c->MemTxCpltCallback(hi2c);
#else
        HAL_I2C_MemTxCpltCallback(hi2c);
 800b4ac:	6878      	ldr	r0, [r7, #4]
 800b4ae:	f7ff ff87 	bl	800b3c0 <HAL_I2C_MemTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 800b4b2:	e03b      	b.n	800b52c <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
      else
      {
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800b4b4:	687b      	ldr	r3, [r7, #4]
 800b4b6:	2200      	movs	r2, #0
 800b4b8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
        hi2c->MasterTxCpltCallback(hi2c);
#else
        HAL_I2C_MasterTxCpltCallback(hi2c);
 800b4bc:	6878      	ldr	r0, [r7, #4]
 800b4be:	f7ff ff3f 	bl	800b340 <HAL_I2C_MasterTxCpltCallback>
    if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 800b4c2:	e033      	b.n	800b52c <I2C_MasterTransmit_TXE+0x130>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
    }
  }
  else if ((CurrentState == HAL_I2C_STATE_BUSY_TX) || \
 800b4c4:	7bfb      	ldrb	r3, [r7, #15]
 800b4c6:	2b21      	cmp	r3, #33	@ 0x21
 800b4c8:	d005      	beq.n	800b4d6 <I2C_MasterTransmit_TXE+0xda>
 800b4ca:	7bbb      	ldrb	r3, [r7, #14]
 800b4cc:	2b40      	cmp	r3, #64	@ 0x40
 800b4ce:	d12d      	bne.n	800b52c <I2C_MasterTransmit_TXE+0x130>
           ((CurrentMode == HAL_I2C_MODE_MEM) && (CurrentState == HAL_I2C_STATE_BUSY_RX)))
 800b4d0:	7bfb      	ldrb	r3, [r7, #15]
 800b4d2:	2b22      	cmp	r3, #34	@ 0x22
 800b4d4:	d12a      	bne.n	800b52c <I2C_MasterTransmit_TXE+0x130>
  {
    if (hi2c->XferCount == 0U)
 800b4d6:	687b      	ldr	r3, [r7, #4]
 800b4d8:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b4da:	b29b      	uxth	r3, r3
 800b4dc:	2b00      	cmp	r3, #0
 800b4de:	d108      	bne.n	800b4f2 <I2C_MasterTransmit_TXE+0xf6>
    {
      /* Disable BUF interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800b4e0:	687b      	ldr	r3, [r7, #4]
 800b4e2:	681b      	ldr	r3, [r3, #0]
 800b4e4:	685a      	ldr	r2, [r3, #4]
 800b4e6:	687b      	ldr	r3, [r7, #4]
 800b4e8:	681b      	ldr	r3, [r3, #0]
 800b4ea:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b4ee:	605a      	str	r2, [r3, #4]
  }
  else
  {
    /* Do nothing */
  }
}
 800b4f0:	e01c      	b.n	800b52c <I2C_MasterTransmit_TXE+0x130>
      if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800b4f2:	687b      	ldr	r3, [r7, #4]
 800b4f4:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800b4f8:	b2db      	uxtb	r3, r3
 800b4fa:	2b40      	cmp	r3, #64	@ 0x40
 800b4fc:	d103      	bne.n	800b506 <I2C_MasterTransmit_TXE+0x10a>
        I2C_MemoryTransmit_TXE_BTF(hi2c);
 800b4fe:	6878      	ldr	r0, [r7, #4]
 800b500:	f000 f88e 	bl	800b620 <I2C_MemoryTransmit_TXE_BTF>
}
 800b504:	e012      	b.n	800b52c <I2C_MasterTransmit_TXE+0x130>
        hi2c->Instance->DR = *hi2c->pBuffPtr;
 800b506:	687b      	ldr	r3, [r7, #4]
 800b508:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b50a:	781a      	ldrb	r2, [r3, #0]
 800b50c:	687b      	ldr	r3, [r7, #4]
 800b50e:	681b      	ldr	r3, [r3, #0]
 800b510:	611a      	str	r2, [r3, #16]
        hi2c->pBuffPtr++;
 800b512:	687b      	ldr	r3, [r7, #4]
 800b514:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b516:	1c5a      	adds	r2, r3, #1
 800b518:	687b      	ldr	r3, [r7, #4]
 800b51a:	625a      	str	r2, [r3, #36]	@ 0x24
        hi2c->XferCount--;
 800b51c:	687b      	ldr	r3, [r7, #4]
 800b51e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b520:	b29b      	uxth	r3, r3
 800b522:	3b01      	subs	r3, #1
 800b524:	b29a      	uxth	r2, r3
 800b526:	687b      	ldr	r3, [r7, #4]
 800b528:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 800b52a:	e7ff      	b.n	800b52c <I2C_MasterTransmit_TXE+0x130>
 800b52c:	bf00      	nop
 800b52e:	3710      	adds	r7, #16
 800b530:	46bd      	mov	sp, r7
 800b532:	bd80      	pop	{r7, pc}

0800b534 <I2C_MasterTransmit_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
 800b534:	b580      	push	{r7, lr}
 800b536:	b084      	sub	sp, #16
 800b538:	af00      	add	r7, sp, #0
 800b53a:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 800b53c:	687b      	ldr	r3, [r7, #4]
 800b53e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b540:	60fb      	str	r3, [r7, #12]

  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 800b542:	687b      	ldr	r3, [r7, #4]
 800b544:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800b548:	b2db      	uxtb	r3, r3
 800b54a:	2b21      	cmp	r3, #33	@ 0x21
 800b54c:	d164      	bne.n	800b618 <I2C_MasterTransmit_BTF+0xe4>
  {
    if (hi2c->XferCount != 0U)
 800b54e:	687b      	ldr	r3, [r7, #4]
 800b550:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b552:	b29b      	uxth	r3, r3
 800b554:	2b00      	cmp	r3, #0
 800b556:	d012      	beq.n	800b57e <I2C_MasterTransmit_BTF+0x4a>
    {
      /* Write data to DR */
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 800b558:	687b      	ldr	r3, [r7, #4]
 800b55a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b55c:	781a      	ldrb	r2, [r3, #0]
 800b55e:	687b      	ldr	r3, [r7, #4]
 800b560:	681b      	ldr	r3, [r3, #0]
 800b562:	611a      	str	r2, [r3, #16]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b564:	687b      	ldr	r3, [r7, #4]
 800b566:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b568:	1c5a      	adds	r2, r3, #1
 800b56a:	687b      	ldr	r3, [r7, #4]
 800b56c:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 800b56e:	687b      	ldr	r3, [r7, #4]
 800b570:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b572:	b29b      	uxth	r3, r3
 800b574:	3b01      	subs	r3, #1
 800b576:	b29a      	uxth	r2, r3
 800b578:	687b      	ldr	r3, [r7, #4]
 800b57a:	855a      	strh	r2, [r3, #42]	@ 0x2a
  }
  else
  {
    /* Do nothing */
  }
}
 800b57c:	e04c      	b.n	800b618 <I2C_MasterTransmit_BTF+0xe4>
      if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) && (CurrentXferOptions != I2C_NO_OPTION_FRAME))
 800b57e:	68fb      	ldr	r3, [r7, #12]
 800b580:	2b08      	cmp	r3, #8
 800b582:	d01d      	beq.n	800b5c0 <I2C_MasterTransmit_BTF+0x8c>
 800b584:	68fb      	ldr	r3, [r7, #12]
 800b586:	2b20      	cmp	r3, #32
 800b588:	d01a      	beq.n	800b5c0 <I2C_MasterTransmit_BTF+0x8c>
 800b58a:	68fb      	ldr	r3, [r7, #12]
 800b58c:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 800b590:	d016      	beq.n	800b5c0 <I2C_MasterTransmit_BTF+0x8c>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800b592:	687b      	ldr	r3, [r7, #4]
 800b594:	681b      	ldr	r3, [r3, #0]
 800b596:	685a      	ldr	r2, [r3, #4]
 800b598:	687b      	ldr	r3, [r7, #4]
 800b59a:	681b      	ldr	r3, [r3, #0]
 800b59c:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b5a0:	605a      	str	r2, [r3, #4]
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 800b5a2:	687b      	ldr	r3, [r7, #4]
 800b5a4:	2211      	movs	r2, #17
 800b5a6:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800b5a8:	687b      	ldr	r3, [r7, #4]
 800b5aa:	2200      	movs	r2, #0
 800b5ac:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        hi2c->State = HAL_I2C_STATE_READY;
 800b5b0:	687b      	ldr	r3, [r7, #4]
 800b5b2:	2220      	movs	r2, #32
 800b5b4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        HAL_I2C_MasterTxCpltCallback(hi2c);
 800b5b8:	6878      	ldr	r0, [r7, #4]
 800b5ba:	f7ff fec1 	bl	800b340 <HAL_I2C_MasterTxCpltCallback>
}
 800b5be:	e02b      	b.n	800b618 <I2C_MasterTransmit_BTF+0xe4>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800b5c0:	687b      	ldr	r3, [r7, #4]
 800b5c2:	681b      	ldr	r3, [r3, #0]
 800b5c4:	685a      	ldr	r2, [r3, #4]
 800b5c6:	687b      	ldr	r3, [r7, #4]
 800b5c8:	681b      	ldr	r3, [r3, #0]
 800b5ca:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b5ce:	605a      	str	r2, [r3, #4]
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800b5d0:	687b      	ldr	r3, [r7, #4]
 800b5d2:	681b      	ldr	r3, [r3, #0]
 800b5d4:	681a      	ldr	r2, [r3, #0]
 800b5d6:	687b      	ldr	r3, [r7, #4]
 800b5d8:	681b      	ldr	r3, [r3, #0]
 800b5da:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800b5de:	601a      	str	r2, [r3, #0]
        hi2c->PreviousState = I2C_STATE_NONE;
 800b5e0:	687b      	ldr	r3, [r7, #4]
 800b5e2:	2200      	movs	r2, #0
 800b5e4:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 800b5e6:	687b      	ldr	r3, [r7, #4]
 800b5e8:	2220      	movs	r2, #32
 800b5ea:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800b5ee:	687b      	ldr	r3, [r7, #4]
 800b5f0:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800b5f4:	b2db      	uxtb	r3, r3
 800b5f6:	2b40      	cmp	r3, #64	@ 0x40
 800b5f8:	d107      	bne.n	800b60a <I2C_MasterTransmit_BTF+0xd6>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 800b5fa:	687b      	ldr	r3, [r7, #4]
 800b5fc:	2200      	movs	r2, #0
 800b5fe:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          HAL_I2C_MemTxCpltCallback(hi2c);
 800b602:	6878      	ldr	r0, [r7, #4]
 800b604:	f7ff fedc 	bl	800b3c0 <HAL_I2C_MemTxCpltCallback>
}
 800b608:	e006      	b.n	800b618 <I2C_MasterTransmit_BTF+0xe4>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 800b60a:	687b      	ldr	r3, [r7, #4]
 800b60c:	2200      	movs	r2, #0
 800b60e:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          HAL_I2C_MasterTxCpltCallback(hi2c);
 800b612:	6878      	ldr	r0, [r7, #4]
 800b614:	f7ff fe94 	bl	800b340 <HAL_I2C_MasterTxCpltCallback>
}
 800b618:	bf00      	nop
 800b61a:	3710      	adds	r7, #16
 800b61c:	46bd      	mov	sp, r7
 800b61e:	bd80      	pop	{r7, pc}

0800b620 <I2C_MemoryTransmit_TXE_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MemoryTransmit_TXE_BTF(I2C_HandleTypeDef *hi2c)
{
 800b620:	b580      	push	{r7, lr}
 800b622:	b084      	sub	sp, #16
 800b624:	af00      	add	r7, sp, #0
 800b626:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800b628:	687b      	ldr	r3, [r7, #4]
 800b62a:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800b62e:	73fb      	strb	r3, [r7, #15]

  if (hi2c->EventCount == 0U)
 800b630:	687b      	ldr	r3, [r7, #4]
 800b632:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b634:	2b00      	cmp	r3, #0
 800b636:	d11d      	bne.n	800b674 <I2C_MemoryTransmit_TXE_BTF+0x54>
  {
    /* If Memory address size is 8Bit */
    if (hi2c->MemaddSize == I2C_MEMADD_SIZE_8BIT)
 800b638:	687b      	ldr	r3, [r7, #4]
 800b63a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800b63c:	2b01      	cmp	r3, #1
 800b63e:	d10b      	bne.n	800b658 <I2C_MemoryTransmit_TXE_BTF+0x38>
    {
      /* Send Memory Address */
      hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 800b640:	687b      	ldr	r3, [r7, #4]
 800b642:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b644:	b2da      	uxtb	r2, r3
 800b646:	687b      	ldr	r3, [r7, #4]
 800b648:	681b      	ldr	r3, [r3, #0]
 800b64a:	611a      	str	r2, [r3, #16]

      hi2c->EventCount += 2U;
 800b64c:	687b      	ldr	r3, [r7, #4]
 800b64e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b650:	1c9a      	adds	r2, r3, #2
 800b652:	687b      	ldr	r3, [r7, #4]
 800b654:	651a      	str	r2, [r3, #80]	@ 0x50
  else
  {
    /* Clear TXE and BTF flags */
    I2C_Flush_DR(hi2c);
  }
}
 800b656:	e077      	b.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
      hi2c->Instance->DR = I2C_MEM_ADD_MSB(hi2c->Memaddress);
 800b658:	687b      	ldr	r3, [r7, #4]
 800b65a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b65c:	b29b      	uxth	r3, r3
 800b65e:	121b      	asrs	r3, r3, #8
 800b660:	b2da      	uxtb	r2, r3
 800b662:	687b      	ldr	r3, [r7, #4]
 800b664:	681b      	ldr	r3, [r3, #0]
 800b666:	611a      	str	r2, [r3, #16]
      hi2c->EventCount++;
 800b668:	687b      	ldr	r3, [r7, #4]
 800b66a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b66c:	1c5a      	adds	r2, r3, #1
 800b66e:	687b      	ldr	r3, [r7, #4]
 800b670:	651a      	str	r2, [r3, #80]	@ 0x50
}
 800b672:	e069      	b.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
  else if (hi2c->EventCount == 1U)
 800b674:	687b      	ldr	r3, [r7, #4]
 800b676:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b678:	2b01      	cmp	r3, #1
 800b67a:	d10b      	bne.n	800b694 <I2C_MemoryTransmit_TXE_BTF+0x74>
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(hi2c->Memaddress);
 800b67c:	687b      	ldr	r3, [r7, #4]
 800b67e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800b680:	b2da      	uxtb	r2, r3
 800b682:	687b      	ldr	r3, [r7, #4]
 800b684:	681b      	ldr	r3, [r3, #0]
 800b686:	611a      	str	r2, [r3, #16]
    hi2c->EventCount++;
 800b688:	687b      	ldr	r3, [r7, #4]
 800b68a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b68c:	1c5a      	adds	r2, r3, #1
 800b68e:	687b      	ldr	r3, [r7, #4]
 800b690:	651a      	str	r2, [r3, #80]	@ 0x50
}
 800b692:	e059      	b.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
  else if (hi2c->EventCount == 2U)
 800b694:	687b      	ldr	r3, [r7, #4]
 800b696:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b698:	2b02      	cmp	r3, #2
 800b69a:	d152      	bne.n	800b742 <I2C_MemoryTransmit_TXE_BTF+0x122>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX)
 800b69c:	7bfb      	ldrb	r3, [r7, #15]
 800b69e:	2b22      	cmp	r3, #34	@ 0x22
 800b6a0:	d10d      	bne.n	800b6be <I2C_MemoryTransmit_TXE_BTF+0x9e>
      hi2c->Instance->CR1 |= I2C_CR1_START;
 800b6a2:	687b      	ldr	r3, [r7, #4]
 800b6a4:	681b      	ldr	r3, [r3, #0]
 800b6a6:	681a      	ldr	r2, [r3, #0]
 800b6a8:	687b      	ldr	r3, [r7, #4]
 800b6aa:	681b      	ldr	r3, [r3, #0]
 800b6ac:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800b6b0:	601a      	str	r2, [r3, #0]
      hi2c->EventCount++;
 800b6b2:	687b      	ldr	r3, [r7, #4]
 800b6b4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800b6b6:	1c5a      	adds	r2, r3, #1
 800b6b8:	687b      	ldr	r3, [r7, #4]
 800b6ba:	651a      	str	r2, [r3, #80]	@ 0x50
}
 800b6bc:	e044      	b.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
    else if ((hi2c->XferCount > 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 800b6be:	687b      	ldr	r3, [r7, #4]
 800b6c0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b6c2:	b29b      	uxth	r3, r3
 800b6c4:	2b00      	cmp	r3, #0
 800b6c6:	d015      	beq.n	800b6f4 <I2C_MemoryTransmit_TXE_BTF+0xd4>
 800b6c8:	7bfb      	ldrb	r3, [r7, #15]
 800b6ca:	2b21      	cmp	r3, #33	@ 0x21
 800b6cc:	d112      	bne.n	800b6f4 <I2C_MemoryTransmit_TXE_BTF+0xd4>
      hi2c->Instance->DR = *hi2c->pBuffPtr;
 800b6ce:	687b      	ldr	r3, [r7, #4]
 800b6d0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b6d2:	781a      	ldrb	r2, [r3, #0]
 800b6d4:	687b      	ldr	r3, [r7, #4]
 800b6d6:	681b      	ldr	r3, [r3, #0]
 800b6d8:	611a      	str	r2, [r3, #16]
      hi2c->pBuffPtr++;
 800b6da:	687b      	ldr	r3, [r7, #4]
 800b6dc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b6de:	1c5a      	adds	r2, r3, #1
 800b6e0:	687b      	ldr	r3, [r7, #4]
 800b6e2:	625a      	str	r2, [r3, #36]	@ 0x24
      hi2c->XferCount--;
 800b6e4:	687b      	ldr	r3, [r7, #4]
 800b6e6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b6e8:	b29b      	uxth	r3, r3
 800b6ea:	3b01      	subs	r3, #1
 800b6ec:	b29a      	uxth	r2, r3
 800b6ee:	687b      	ldr	r3, [r7, #4]
 800b6f0:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 800b6f2:	e029      	b.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
    else if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX))
 800b6f4:	687b      	ldr	r3, [r7, #4]
 800b6f6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b6f8:	b29b      	uxth	r3, r3
 800b6fa:	2b00      	cmp	r3, #0
 800b6fc:	d124      	bne.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
 800b6fe:	7bfb      	ldrb	r3, [r7, #15]
 800b700:	2b21      	cmp	r3, #33	@ 0x21
 800b702:	d121      	bne.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800b704:	687b      	ldr	r3, [r7, #4]
 800b706:	681b      	ldr	r3, [r3, #0]
 800b708:	685a      	ldr	r2, [r3, #4]
 800b70a:	687b      	ldr	r3, [r7, #4]
 800b70c:	681b      	ldr	r3, [r3, #0]
 800b70e:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b712:	605a      	str	r2, [r3, #4]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800b714:	687b      	ldr	r3, [r7, #4]
 800b716:	681b      	ldr	r3, [r3, #0]
 800b718:	681a      	ldr	r2, [r3, #0]
 800b71a:	687b      	ldr	r3, [r7, #4]
 800b71c:	681b      	ldr	r3, [r3, #0]
 800b71e:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800b722:	601a      	str	r2, [r3, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 800b724:	687b      	ldr	r3, [r7, #4]
 800b726:	2200      	movs	r2, #0
 800b728:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 800b72a:	687b      	ldr	r3, [r7, #4]
 800b72c:	2220      	movs	r2, #32
 800b72e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800b732:	687b      	ldr	r3, [r7, #4]
 800b734:	2200      	movs	r2, #0
 800b736:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      HAL_I2C_MemTxCpltCallback(hi2c);
 800b73a:	6878      	ldr	r0, [r7, #4]
 800b73c:	f7ff fe40 	bl	800b3c0 <HAL_I2C_MemTxCpltCallback>
}
 800b740:	e002      	b.n	800b748 <I2C_MemoryTransmit_TXE_BTF+0x128>
    I2C_Flush_DR(hi2c);
 800b742:	6878      	ldr	r0, [r7, #4]
 800b744:	f7fe ff9b 	bl	800a67e <I2C_Flush_DR>
}
 800b748:	bf00      	nop
 800b74a:	3710      	adds	r7, #16
 800b74c:	46bd      	mov	sp, r7
 800b74e:	bd80      	pop	{r7, pc}

0800b750 <I2C_MasterReceive_RXNE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)
{
 800b750:	b580      	push	{r7, lr}
 800b752:	b084      	sub	sp, #16
 800b754:	af00      	add	r7, sp, #0
 800b756:	6078      	str	r0, [r7, #4]
  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800b758:	687b      	ldr	r3, [r7, #4]
 800b75a:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800b75e:	b2db      	uxtb	r3, r3
 800b760:	2b22      	cmp	r3, #34	@ 0x22
 800b762:	f040 80b9 	bne.w	800b8d8 <I2C_MasterReceive_RXNE+0x188>
  {
    uint32_t tmp;
    uint32_t CurrentXferOptions;

    CurrentXferOptions = hi2c->XferOptions;
 800b766:	687b      	ldr	r3, [r7, #4]
 800b768:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b76a:	60fb      	str	r3, [r7, #12]
    tmp = hi2c->XferCount;
 800b76c:	687b      	ldr	r3, [r7, #4]
 800b76e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b770:	b29b      	uxth	r3, r3
 800b772:	60bb      	str	r3, [r7, #8]
    if (tmp > 3U)
 800b774:	68bb      	ldr	r3, [r7, #8]
 800b776:	2b03      	cmp	r3, #3
 800b778:	d921      	bls.n	800b7be <I2C_MasterReceive_RXNE+0x6e>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800b77a:	687b      	ldr	r3, [r7, #4]
 800b77c:	681b      	ldr	r3, [r3, #0]
 800b77e:	691a      	ldr	r2, [r3, #16]
 800b780:	687b      	ldr	r3, [r7, #4]
 800b782:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b784:	b2d2      	uxtb	r2, r2
 800b786:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800b788:	687b      	ldr	r3, [r7, #4]
 800b78a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b78c:	1c5a      	adds	r2, r3, #1
 800b78e:	687b      	ldr	r3, [r7, #4]
 800b790:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 800b792:	687b      	ldr	r3, [r7, #4]
 800b794:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b796:	b29b      	uxth	r3, r3
 800b798:	3b01      	subs	r3, #1
 800b79a:	b29a      	uxth	r2, r3
 800b79c:	687b      	ldr	r3, [r7, #4]
 800b79e:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if (hi2c->XferCount == (uint16_t)3)
 800b7a0:	687b      	ldr	r3, [r7, #4]
 800b7a2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b7a4:	b29b      	uxth	r3, r3
 800b7a6:	2b03      	cmp	r3, #3
 800b7a8:	f040 8096 	bne.w	800b8d8 <I2C_MasterReceive_RXNE+0x188>
      {
        /* Disable BUF interrupt, this help to treat correctly the last 4 bytes
        on BTF subroutine */
        /* Disable BUF interrupt */
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800b7ac:	687b      	ldr	r3, [r7, #4]
 800b7ae:	681b      	ldr	r3, [r3, #0]
 800b7b0:	685a      	ldr	r2, [r3, #4]
 800b7b2:	687b      	ldr	r3, [r7, #4]
 800b7b4:	681b      	ldr	r3, [r3, #0]
 800b7b6:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b7ba:	605a      	str	r2, [r3, #4]
      /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
         on BTF subroutine if there is a reception delay between N-1 and N byte */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
    }
  }
}
 800b7bc:	e08c      	b.n	800b8d8 <I2C_MasterReceive_RXNE+0x188>
    else if ((hi2c->XferOptions != I2C_FIRST_AND_NEXT_FRAME) && ((tmp == 1U) || (tmp == 0U)))
 800b7be:	687b      	ldr	r3, [r7, #4]
 800b7c0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b7c2:	2b02      	cmp	r3, #2
 800b7c4:	d07f      	beq.n	800b8c6 <I2C_MasterReceive_RXNE+0x176>
 800b7c6:	68bb      	ldr	r3, [r7, #8]
 800b7c8:	2b01      	cmp	r3, #1
 800b7ca:	d002      	beq.n	800b7d2 <I2C_MasterReceive_RXNE+0x82>
 800b7cc:	68bb      	ldr	r3, [r7, #8]
 800b7ce:	2b00      	cmp	r3, #0
 800b7d0:	d179      	bne.n	800b8c6 <I2C_MasterReceive_RXNE+0x176>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 800b7d2:	6878      	ldr	r0, [r7, #4]
 800b7d4:	f001 fb66 	bl	800cea4 <I2C_WaitOnSTOPRequestThroughIT>
 800b7d8:	4603      	mov	r3, r0
 800b7da:	2b00      	cmp	r3, #0
 800b7dc:	d14c      	bne.n	800b878 <I2C_MasterReceive_RXNE+0x128>
        CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800b7de:	687b      	ldr	r3, [r7, #4]
 800b7e0:	681b      	ldr	r3, [r3, #0]
 800b7e2:	681a      	ldr	r2, [r3, #0]
 800b7e4:	687b      	ldr	r3, [r7, #4]
 800b7e6:	681b      	ldr	r3, [r3, #0]
 800b7e8:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b7ec:	601a      	str	r2, [r3, #0]
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800b7ee:	687b      	ldr	r3, [r7, #4]
 800b7f0:	681b      	ldr	r3, [r3, #0]
 800b7f2:	685a      	ldr	r2, [r3, #4]
 800b7f4:	687b      	ldr	r3, [r7, #4]
 800b7f6:	681b      	ldr	r3, [r3, #0]
 800b7f8:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b7fc:	605a      	str	r2, [r3, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800b7fe:	687b      	ldr	r3, [r7, #4]
 800b800:	681b      	ldr	r3, [r3, #0]
 800b802:	691a      	ldr	r2, [r3, #16]
 800b804:	687b      	ldr	r3, [r7, #4]
 800b806:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b808:	b2d2      	uxtb	r2, r2
 800b80a:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 800b80c:	687b      	ldr	r3, [r7, #4]
 800b80e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b810:	1c5a      	adds	r2, r3, #1
 800b812:	687b      	ldr	r3, [r7, #4]
 800b814:	625a      	str	r2, [r3, #36]	@ 0x24
        hi2c->XferCount--;
 800b816:	687b      	ldr	r3, [r7, #4]
 800b818:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b81a:	b29b      	uxth	r3, r3
 800b81c:	3b01      	subs	r3, #1
 800b81e:	b29a      	uxth	r2, r3
 800b820:	687b      	ldr	r3, [r7, #4]
 800b822:	855a      	strh	r2, [r3, #42]	@ 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 800b824:	687b      	ldr	r3, [r7, #4]
 800b826:	2220      	movs	r2, #32
 800b828:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800b82c:	687b      	ldr	r3, [r7, #4]
 800b82e:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800b832:	b2db      	uxtb	r3, r3
 800b834:	2b40      	cmp	r3, #64	@ 0x40
 800b836:	d10a      	bne.n	800b84e <I2C_MasterReceive_RXNE+0xfe>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 800b838:	687b      	ldr	r3, [r7, #4]
 800b83a:	2200      	movs	r2, #0
 800b83c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->PreviousState = I2C_STATE_NONE;
 800b840:	687b      	ldr	r3, [r7, #4]
 800b842:	2200      	movs	r2, #0
 800b844:	631a      	str	r2, [r3, #48]	@ 0x30
          HAL_I2C_MemRxCpltCallback(hi2c);
 800b846:	6878      	ldr	r0, [r7, #4]
 800b848:	f7ff fdc4 	bl	800b3d4 <HAL_I2C_MemRxCpltCallback>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 800b84c:	e044      	b.n	800b8d8 <I2C_MasterReceive_RXNE+0x188>
          hi2c->Mode = HAL_I2C_MODE_NONE;
 800b84e:	687b      	ldr	r3, [r7, #4]
 800b850:	2200      	movs	r2, #0
 800b852:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
 800b856:	68fb      	ldr	r3, [r7, #12]
 800b858:	2b08      	cmp	r3, #8
 800b85a:	d002      	beq.n	800b862 <I2C_MasterReceive_RXNE+0x112>
 800b85c:	68fb      	ldr	r3, [r7, #12]
 800b85e:	2b20      	cmp	r3, #32
 800b860:	d103      	bne.n	800b86a <I2C_MasterReceive_RXNE+0x11a>
            hi2c->PreviousState = I2C_STATE_NONE;
 800b862:	687b      	ldr	r3, [r7, #4]
 800b864:	2200      	movs	r2, #0
 800b866:	631a      	str	r2, [r3, #48]	@ 0x30
 800b868:	e002      	b.n	800b870 <I2C_MasterReceive_RXNE+0x120>
            hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 800b86a:	687b      	ldr	r3, [r7, #4]
 800b86c:	2212      	movs	r2, #18
 800b86e:	631a      	str	r2, [r3, #48]	@ 0x30
          HAL_I2C_MasterRxCpltCallback(hi2c);
 800b870:	6878      	ldr	r0, [r7, #4]
 800b872:	f7ff fd6f 	bl	800b354 <HAL_I2C_MasterRxCpltCallback>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 800b876:	e02f      	b.n	800b8d8 <I2C_MasterReceive_RXNE+0x188>
        __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800b878:	687b      	ldr	r3, [r7, #4]
 800b87a:	681b      	ldr	r3, [r3, #0]
 800b87c:	685a      	ldr	r2, [r3, #4]
 800b87e:	687b      	ldr	r3, [r7, #4]
 800b880:	681b      	ldr	r3, [r3, #0]
 800b882:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800b886:	605a      	str	r2, [r3, #4]
        *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800b888:	687b      	ldr	r3, [r7, #4]
 800b88a:	681b      	ldr	r3, [r3, #0]
 800b88c:	691a      	ldr	r2, [r3, #16]
 800b88e:	687b      	ldr	r3, [r7, #4]
 800b890:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b892:	b2d2      	uxtb	r2, r2
 800b894:	701a      	strb	r2, [r3, #0]
        hi2c->pBuffPtr++;
 800b896:	687b      	ldr	r3, [r7, #4]
 800b898:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b89a:	1c5a      	adds	r2, r3, #1
 800b89c:	687b      	ldr	r3, [r7, #4]
 800b89e:	625a      	str	r2, [r3, #36]	@ 0x24
        hi2c->XferCount--;
 800b8a0:	687b      	ldr	r3, [r7, #4]
 800b8a2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b8a4:	b29b      	uxth	r3, r3
 800b8a6:	3b01      	subs	r3, #1
 800b8a8:	b29a      	uxth	r2, r3
 800b8aa:	687b      	ldr	r3, [r7, #4]
 800b8ac:	855a      	strh	r2, [r3, #42]	@ 0x2a
        hi2c->State = HAL_I2C_STATE_READY;
 800b8ae:	687b      	ldr	r3, [r7, #4]
 800b8b0:	2220      	movs	r2, #32
 800b8b2:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800b8b6:	687b      	ldr	r3, [r7, #4]
 800b8b8:	2200      	movs	r2, #0
 800b8ba:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        HAL_I2C_ErrorCallback(hi2c);
 800b8be:	6878      	ldr	r0, [r7, #4]
 800b8c0:	f7f8 fdad 	bl	800441e <HAL_I2C_ErrorCallback>
      if (I2C_WaitOnSTOPRequestThroughIT(hi2c) == HAL_OK)
 800b8c4:	e008      	b.n	800b8d8 <I2C_MasterReceive_RXNE+0x188>
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800b8c6:	687b      	ldr	r3, [r7, #4]
 800b8c8:	681b      	ldr	r3, [r3, #0]
 800b8ca:	685a      	ldr	r2, [r3, #4]
 800b8cc:	687b      	ldr	r3, [r7, #4]
 800b8ce:	681b      	ldr	r3, [r3, #0]
 800b8d0:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b8d4:	605a      	str	r2, [r3, #4]
}
 800b8d6:	e7ff      	b.n	800b8d8 <I2C_MasterReceive_RXNE+0x188>
 800b8d8:	bf00      	nop
 800b8da:	3710      	adds	r7, #16
 800b8dc:	46bd      	mov	sp, r7
 800b8de:	bd80      	pop	{r7, pc}

0800b8e0 <I2C_MasterReceive_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)
{
 800b8e0:	b580      	push	{r7, lr}
 800b8e2:	b084      	sub	sp, #16
 800b8e4:	af00      	add	r7, sp, #0
 800b8e6:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  uint32_t CurrentXferOptions = hi2c->XferOptions;
 800b8e8:	687b      	ldr	r3, [r7, #4]
 800b8ea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b8ec:	60fb      	str	r3, [r7, #12]

  if (hi2c->XferCount == 4U)
 800b8ee:	687b      	ldr	r3, [r7, #4]
 800b8f0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b8f2:	b29b      	uxth	r3, r3
 800b8f4:	2b04      	cmp	r3, #4
 800b8f6:	d11b      	bne.n	800b930 <I2C_MasterReceive_BTF+0x50>
  {
    /* Disable BUF interrupt, this help to treat correctly the last 2 bytes
       on BTF subroutine if there is a reception delay between N-1 and N byte */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800b8f8:	687b      	ldr	r3, [r7, #4]
 800b8fa:	681b      	ldr	r3, [r3, #0]
 800b8fc:	685a      	ldr	r2, [r3, #4]
 800b8fe:	687b      	ldr	r3, [r7, #4]
 800b900:	681b      	ldr	r3, [r3, #0]
 800b902:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b906:	605a      	str	r2, [r3, #4]

    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800b908:	687b      	ldr	r3, [r7, #4]
 800b90a:	681b      	ldr	r3, [r3, #0]
 800b90c:	691a      	ldr	r2, [r3, #16]
 800b90e:	687b      	ldr	r3, [r7, #4]
 800b910:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b912:	b2d2      	uxtb	r2, r2
 800b914:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 800b916:	687b      	ldr	r3, [r7, #4]
 800b918:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b91a:	1c5a      	adds	r2, r3, #1
 800b91c:	687b      	ldr	r3, [r7, #4]
 800b91e:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 800b920:	687b      	ldr	r3, [r7, #4]
 800b922:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b924:	b29b      	uxth	r3, r3
 800b926:	3b01      	subs	r3, #1
 800b928:	b29a      	uxth	r2, r3
 800b92a:	687b      	ldr	r3, [r7, #4]
 800b92c:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->pBuffPtr++;

    /* Update counter */
    hi2c->XferCount--;
  }
}
 800b92e:	e0c8      	b.n	800bac2 <I2C_MasterReceive_BTF+0x1e2>
  else if (hi2c->XferCount == 3U)
 800b930:	687b      	ldr	r3, [r7, #4]
 800b932:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b934:	b29b      	uxth	r3, r3
 800b936:	2b03      	cmp	r3, #3
 800b938:	d129      	bne.n	800b98e <I2C_MasterReceive_BTF+0xae>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800b93a:	687b      	ldr	r3, [r7, #4]
 800b93c:	681b      	ldr	r3, [r3, #0]
 800b93e:	685a      	ldr	r2, [r3, #4]
 800b940:	687b      	ldr	r3, [r7, #4]
 800b942:	681b      	ldr	r3, [r3, #0]
 800b944:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b948:	605a      	str	r2, [r3, #4]
    if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME))
 800b94a:	68fb      	ldr	r3, [r7, #12]
 800b94c:	2b04      	cmp	r3, #4
 800b94e:	d00a      	beq.n	800b966 <I2C_MasterReceive_BTF+0x86>
 800b950:	68fb      	ldr	r3, [r7, #12]
 800b952:	2b02      	cmp	r3, #2
 800b954:	d007      	beq.n	800b966 <I2C_MasterReceive_BTF+0x86>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800b956:	687b      	ldr	r3, [r7, #4]
 800b958:	681b      	ldr	r3, [r3, #0]
 800b95a:	681a      	ldr	r2, [r3, #0]
 800b95c:	687b      	ldr	r3, [r7, #4]
 800b95e:	681b      	ldr	r3, [r3, #0]
 800b960:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b964:	601a      	str	r2, [r3, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800b966:	687b      	ldr	r3, [r7, #4]
 800b968:	681b      	ldr	r3, [r3, #0]
 800b96a:	691a      	ldr	r2, [r3, #16]
 800b96c:	687b      	ldr	r3, [r7, #4]
 800b96e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b970:	b2d2      	uxtb	r2, r2
 800b972:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 800b974:	687b      	ldr	r3, [r7, #4]
 800b976:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b978:	1c5a      	adds	r2, r3, #1
 800b97a:	687b      	ldr	r3, [r7, #4]
 800b97c:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 800b97e:	687b      	ldr	r3, [r7, #4]
 800b980:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b982:	b29b      	uxth	r3, r3
 800b984:	3b01      	subs	r3, #1
 800b986:	b29a      	uxth	r2, r3
 800b988:	687b      	ldr	r3, [r7, #4]
 800b98a:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 800b98c:	e099      	b.n	800bac2 <I2C_MasterReceive_BTF+0x1e2>
  else if (hi2c->XferCount == 2U)
 800b98e:	687b      	ldr	r3, [r7, #4]
 800b990:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800b992:	b29b      	uxth	r3, r3
 800b994:	2b02      	cmp	r3, #2
 800b996:	f040 8081 	bne.w	800ba9c <I2C_MasterReceive_BTF+0x1bc>
    if ((CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP))
 800b99a:	68fb      	ldr	r3, [r7, #12]
 800b99c:	2b01      	cmp	r3, #1
 800b99e:	d002      	beq.n	800b9a6 <I2C_MasterReceive_BTF+0xc6>
 800b9a0:	68fb      	ldr	r3, [r7, #12]
 800b9a2:	2b10      	cmp	r3, #16
 800b9a4:	d108      	bne.n	800b9b8 <I2C_MasterReceive_BTF+0xd8>
      CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800b9a6:	687b      	ldr	r3, [r7, #4]
 800b9a8:	681b      	ldr	r3, [r3, #0]
 800b9aa:	681a      	ldr	r2, [r3, #0]
 800b9ac:	687b      	ldr	r3, [r7, #4]
 800b9ae:	681b      	ldr	r3, [r3, #0]
 800b9b0:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800b9b4:	601a      	str	r2, [r3, #0]
 800b9b6:	e019      	b.n	800b9ec <I2C_MasterReceive_BTF+0x10c>
    else if ((CurrentXferOptions == I2C_NEXT_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_NEXT_FRAME))
 800b9b8:	68fb      	ldr	r3, [r7, #12]
 800b9ba:	2b04      	cmp	r3, #4
 800b9bc:	d002      	beq.n	800b9c4 <I2C_MasterReceive_BTF+0xe4>
 800b9be:	68fb      	ldr	r3, [r7, #12]
 800b9c0:	2b02      	cmp	r3, #2
 800b9c2:	d108      	bne.n	800b9d6 <I2C_MasterReceive_BTF+0xf6>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800b9c4:	687b      	ldr	r3, [r7, #4]
 800b9c6:	681b      	ldr	r3, [r3, #0]
 800b9c8:	681a      	ldr	r2, [r3, #0]
 800b9ca:	687b      	ldr	r3, [r7, #4]
 800b9cc:	681b      	ldr	r3, [r3, #0]
 800b9ce:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800b9d2:	601a      	str	r2, [r3, #0]
 800b9d4:	e00a      	b.n	800b9ec <I2C_MasterReceive_BTF+0x10c>
    else if (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP)
 800b9d6:	68fb      	ldr	r3, [r7, #12]
 800b9d8:	2b10      	cmp	r3, #16
 800b9da:	d007      	beq.n	800b9ec <I2C_MasterReceive_BTF+0x10c>
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800b9dc:	687b      	ldr	r3, [r7, #4]
 800b9de:	681b      	ldr	r3, [r3, #0]
 800b9e0:	681a      	ldr	r2, [r3, #0]
 800b9e2:	687b      	ldr	r3, [r7, #4]
 800b9e4:	681b      	ldr	r3, [r3, #0]
 800b9e6:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800b9ea:	601a      	str	r2, [r3, #0]
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800b9ec:	687b      	ldr	r3, [r7, #4]
 800b9ee:	681b      	ldr	r3, [r3, #0]
 800b9f0:	691a      	ldr	r2, [r3, #16]
 800b9f2:	687b      	ldr	r3, [r7, #4]
 800b9f4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b9f6:	b2d2      	uxtb	r2, r2
 800b9f8:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 800b9fa:	687b      	ldr	r3, [r7, #4]
 800b9fc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800b9fe:	1c5a      	adds	r2, r3, #1
 800ba00:	687b      	ldr	r3, [r7, #4]
 800ba02:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 800ba04:	687b      	ldr	r3, [r7, #4]
 800ba06:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800ba08:	b29b      	uxth	r3, r3
 800ba0a:	3b01      	subs	r3, #1
 800ba0c:	b29a      	uxth	r2, r3
 800ba0e:	687b      	ldr	r3, [r7, #4]
 800ba10:	855a      	strh	r2, [r3, #42]	@ 0x2a
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800ba12:	687b      	ldr	r3, [r7, #4]
 800ba14:	681b      	ldr	r3, [r3, #0]
 800ba16:	691a      	ldr	r2, [r3, #16]
 800ba18:	687b      	ldr	r3, [r7, #4]
 800ba1a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ba1c:	b2d2      	uxtb	r2, r2
 800ba1e:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 800ba20:	687b      	ldr	r3, [r7, #4]
 800ba22:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800ba24:	1c5a      	adds	r2, r3, #1
 800ba26:	687b      	ldr	r3, [r7, #4]
 800ba28:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 800ba2a:	687b      	ldr	r3, [r7, #4]
 800ba2c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800ba2e:	b29b      	uxth	r3, r3
 800ba30:	3b01      	subs	r3, #1
 800ba32:	b29a      	uxth	r2, r3
 800ba34:	687b      	ldr	r3, [r7, #4]
 800ba36:	855a      	strh	r2, [r3, #42]	@ 0x2a
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_ERR);
 800ba38:	687b      	ldr	r3, [r7, #4]
 800ba3a:	681b      	ldr	r3, [r3, #0]
 800ba3c:	685a      	ldr	r2, [r3, #4]
 800ba3e:	687b      	ldr	r3, [r7, #4]
 800ba40:	681b      	ldr	r3, [r3, #0]
 800ba42:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 800ba46:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 800ba48:	687b      	ldr	r3, [r7, #4]
 800ba4a:	2220      	movs	r2, #32
 800ba4c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800ba50:	687b      	ldr	r3, [r7, #4]
 800ba52:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800ba56:	b2db      	uxtb	r3, r3
 800ba58:	2b40      	cmp	r3, #64	@ 0x40
 800ba5a:	d10a      	bne.n	800ba72 <I2C_MasterReceive_BTF+0x192>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800ba5c:	687b      	ldr	r3, [r7, #4]
 800ba5e:	2200      	movs	r2, #0
 800ba60:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->PreviousState = I2C_STATE_NONE;
 800ba64:	687b      	ldr	r3, [r7, #4]
 800ba66:	2200      	movs	r2, #0
 800ba68:	631a      	str	r2, [r3, #48]	@ 0x30
      HAL_I2C_MemRxCpltCallback(hi2c);
 800ba6a:	6878      	ldr	r0, [r7, #4]
 800ba6c:	f7ff fcb2 	bl	800b3d4 <HAL_I2C_MemRxCpltCallback>
}
 800ba70:	e027      	b.n	800bac2 <I2C_MasterReceive_BTF+0x1e2>
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800ba72:	687b      	ldr	r3, [r7, #4]
 800ba74:	2200      	movs	r2, #0
 800ba76:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      if ((CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME))
 800ba7a:	68fb      	ldr	r3, [r7, #12]
 800ba7c:	2b08      	cmp	r3, #8
 800ba7e:	d002      	beq.n	800ba86 <I2C_MasterReceive_BTF+0x1a6>
 800ba80:	68fb      	ldr	r3, [r7, #12]
 800ba82:	2b20      	cmp	r3, #32
 800ba84:	d103      	bne.n	800ba8e <I2C_MasterReceive_BTF+0x1ae>
        hi2c->PreviousState = I2C_STATE_NONE;
 800ba86:	687b      	ldr	r3, [r7, #4]
 800ba88:	2200      	movs	r2, #0
 800ba8a:	631a      	str	r2, [r3, #48]	@ 0x30
 800ba8c:	e002      	b.n	800ba94 <I2C_MasterReceive_BTF+0x1b4>
        hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 800ba8e:	687b      	ldr	r3, [r7, #4]
 800ba90:	2212      	movs	r2, #18
 800ba92:	631a      	str	r2, [r3, #48]	@ 0x30
      HAL_I2C_MasterRxCpltCallback(hi2c);
 800ba94:	6878      	ldr	r0, [r7, #4]
 800ba96:	f7ff fc5d 	bl	800b354 <HAL_I2C_MasterRxCpltCallback>
}
 800ba9a:	e012      	b.n	800bac2 <I2C_MasterReceive_BTF+0x1e2>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800ba9c:	687b      	ldr	r3, [r7, #4]
 800ba9e:	681b      	ldr	r3, [r3, #0]
 800baa0:	691a      	ldr	r2, [r3, #16]
 800baa2:	687b      	ldr	r3, [r7, #4]
 800baa4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800baa6:	b2d2      	uxtb	r2, r2
 800baa8:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 800baaa:	687b      	ldr	r3, [r7, #4]
 800baac:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800baae:	1c5a      	adds	r2, r3, #1
 800bab0:	687b      	ldr	r3, [r7, #4]
 800bab2:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount--;
 800bab4:	687b      	ldr	r3, [r7, #4]
 800bab6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bab8:	b29b      	uxth	r3, r3
 800baba:	3b01      	subs	r3, #1
 800babc:	b29a      	uxth	r2, r3
 800babe:	687b      	ldr	r3, [r7, #4]
 800bac0:	855a      	strh	r2, [r3, #42]	@ 0x2a
}
 800bac2:	bf00      	nop
 800bac4:	3710      	adds	r7, #16
 800bac6:	46bd      	mov	sp, r7
 800bac8:	bd80      	pop	{r7, pc}

0800baca <I2C_Master_SB>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_SB(I2C_HandleTypeDef *hi2c)
{
 800baca:	b480      	push	{r7}
 800bacc:	b083      	sub	sp, #12
 800bace:	af00      	add	r7, sp, #0
 800bad0:	6078      	str	r0, [r7, #4]
  if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800bad2:	687b      	ldr	r3, [r7, #4]
 800bad4:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800bad8:	b2db      	uxtb	r3, r3
 800bada:	2b40      	cmp	r3, #64	@ 0x40
 800badc:	d117      	bne.n	800bb0e <I2C_Master_SB+0x44>
  {
    if (hi2c->EventCount == 0U)
 800bade:	687b      	ldr	r3, [r7, #4]
 800bae0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bae2:	2b00      	cmp	r3, #0
 800bae4:	d109      	bne.n	800bafa <I2C_Master_SB+0x30>
    {
      /* Send slave address */
      hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 800bae6:	687b      	ldr	r3, [r7, #4]
 800bae8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800baea:	b2db      	uxtb	r3, r3
 800baec:	461a      	mov	r2, r3
 800baee:	687b      	ldr	r3, [r7, #4]
 800baf0:	681b      	ldr	r3, [r3, #0]
 800baf2:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 800baf6:	611a      	str	r2, [r3, #16]
      {
        /* Do nothing */
      }
    }
  }
}
 800baf8:	e067      	b.n	800bbca <I2C_Master_SB+0x100>
      hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 800bafa:	687b      	ldr	r3, [r7, #4]
 800bafc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bafe:	b2db      	uxtb	r3, r3
 800bb00:	f043 0301 	orr.w	r3, r3, #1
 800bb04:	b2da      	uxtb	r2, r3
 800bb06:	687b      	ldr	r3, [r7, #4]
 800bb08:	681b      	ldr	r3, [r3, #0]
 800bb0a:	611a      	str	r2, [r3, #16]
}
 800bb0c:	e05d      	b.n	800bbca <I2C_Master_SB+0x100>
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800bb0e:	687b      	ldr	r3, [r7, #4]
 800bb10:	691b      	ldr	r3, [r3, #16]
 800bb12:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 800bb16:	d133      	bne.n	800bb80 <I2C_Master_SB+0xb6>
      if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 800bb18:	687b      	ldr	r3, [r7, #4]
 800bb1a:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800bb1e:	b2db      	uxtb	r3, r3
 800bb20:	2b21      	cmp	r3, #33	@ 0x21
 800bb22:	d109      	bne.n	800bb38 <I2C_Master_SB+0x6e>
        hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(hi2c->Devaddress);
 800bb24:	687b      	ldr	r3, [r7, #4]
 800bb26:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bb28:	b2db      	uxtb	r3, r3
 800bb2a:	461a      	mov	r2, r3
 800bb2c:	687b      	ldr	r3, [r7, #4]
 800bb2e:	681b      	ldr	r3, [r3, #0]
 800bb30:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 800bb34:	611a      	str	r2, [r3, #16]
 800bb36:	e008      	b.n	800bb4a <I2C_Master_SB+0x80>
        hi2c->Instance->DR = I2C_7BIT_ADD_READ(hi2c->Devaddress);
 800bb38:	687b      	ldr	r3, [r7, #4]
 800bb3a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bb3c:	b2db      	uxtb	r3, r3
 800bb3e:	f043 0301 	orr.w	r3, r3, #1
 800bb42:	b2da      	uxtb	r2, r3
 800bb44:	687b      	ldr	r3, [r7, #4]
 800bb46:	681b      	ldr	r3, [r3, #0]
 800bb48:	611a      	str	r2, [r3, #16]
      if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
 800bb4a:	687b      	ldr	r3, [r7, #4]
 800bb4c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800bb4e:	2b00      	cmp	r3, #0
 800bb50:	d004      	beq.n	800bb5c <I2C_Master_SB+0x92>
 800bb52:	687b      	ldr	r3, [r7, #4]
 800bb54:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800bb56:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800bb58:	2b00      	cmp	r3, #0
 800bb5a:	d108      	bne.n	800bb6e <I2C_Master_SB+0xa4>
          || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
 800bb5c:	687b      	ldr	r3, [r7, #4]
 800bb5e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800bb60:	2b00      	cmp	r3, #0
 800bb62:	d032      	beq.n	800bbca <I2C_Master_SB+0x100>
 800bb64:	687b      	ldr	r3, [r7, #4]
 800bb66:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800bb68:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800bb6a:	2b00      	cmp	r3, #0
 800bb6c:	d02d      	beq.n	800bbca <I2C_Master_SB+0x100>
        SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 800bb6e:	687b      	ldr	r3, [r7, #4]
 800bb70:	681b      	ldr	r3, [r3, #0]
 800bb72:	685a      	ldr	r2, [r3, #4]
 800bb74:	687b      	ldr	r3, [r7, #4]
 800bb76:	681b      	ldr	r3, [r3, #0]
 800bb78:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800bb7c:	605a      	str	r2, [r3, #4]
}
 800bb7e:	e024      	b.n	800bbca <I2C_Master_SB+0x100>
      if (hi2c->EventCount == 0U)
 800bb80:	687b      	ldr	r3, [r7, #4]
 800bb82:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bb84:	2b00      	cmp	r3, #0
 800bb86:	d10e      	bne.n	800bba6 <I2C_Master_SB+0xdc>
        hi2c->Instance->DR = I2C_10BIT_HEADER_WRITE(hi2c->Devaddress);
 800bb88:	687b      	ldr	r3, [r7, #4]
 800bb8a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bb8c:	b29b      	uxth	r3, r3
 800bb8e:	11db      	asrs	r3, r3, #7
 800bb90:	b2db      	uxtb	r3, r3
 800bb92:	f003 0306 	and.w	r3, r3, #6
 800bb96:	b2db      	uxtb	r3, r3
 800bb98:	f063 030f 	orn	r3, r3, #15
 800bb9c:	b2da      	uxtb	r2, r3
 800bb9e:	687b      	ldr	r3, [r7, #4]
 800bba0:	681b      	ldr	r3, [r3, #0]
 800bba2:	611a      	str	r2, [r3, #16]
}
 800bba4:	e011      	b.n	800bbca <I2C_Master_SB+0x100>
      else if (hi2c->EventCount == 1U)
 800bba6:	687b      	ldr	r3, [r7, #4]
 800bba8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bbaa:	2b01      	cmp	r3, #1
 800bbac:	d10d      	bne.n	800bbca <I2C_Master_SB+0x100>
        hi2c->Instance->DR = I2C_10BIT_HEADER_READ(hi2c->Devaddress);
 800bbae:	687b      	ldr	r3, [r7, #4]
 800bbb0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bbb2:	b29b      	uxth	r3, r3
 800bbb4:	11db      	asrs	r3, r3, #7
 800bbb6:	b2db      	uxtb	r3, r3
 800bbb8:	f003 0306 	and.w	r3, r3, #6
 800bbbc:	b2db      	uxtb	r3, r3
 800bbbe:	f063 030e 	orn	r3, r3, #14
 800bbc2:	b2da      	uxtb	r2, r3
 800bbc4:	687b      	ldr	r3, [r7, #4]
 800bbc6:	681b      	ldr	r3, [r3, #0]
 800bbc8:	611a      	str	r2, [r3, #16]
}
 800bbca:	bf00      	nop
 800bbcc:	370c      	adds	r7, #12
 800bbce:	46bd      	mov	sp, r7
 800bbd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bbd4:	4770      	bx	lr

0800bbd6 <I2C_Master_ADD10>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)
{
 800bbd6:	b480      	push	{r7}
 800bbd8:	b083      	sub	sp, #12
 800bbda:	af00      	add	r7, sp, #0
 800bbdc:	6078      	str	r0, [r7, #4]
  /* Send slave address */
  hi2c->Instance->DR = I2C_10BIT_ADDRESS(hi2c->Devaddress);
 800bbde:	687b      	ldr	r3, [r7, #4]
 800bbe0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800bbe2:	b2da      	uxtb	r2, r3
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	681b      	ldr	r3, [r3, #0]
 800bbe8:	611a      	str	r2, [r3, #16]

  if (((hi2c->hdmatx != NULL) && (hi2c->hdmatx->XferCpltCallback != NULL))
 800bbea:	687b      	ldr	r3, [r7, #4]
 800bbec:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800bbee:	2b00      	cmp	r3, #0
 800bbf0:	d004      	beq.n	800bbfc <I2C_Master_ADD10+0x26>
 800bbf2:	687b      	ldr	r3, [r7, #4]
 800bbf4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800bbf6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800bbf8:	2b00      	cmp	r3, #0
 800bbfa:	d108      	bne.n	800bc0e <I2C_Master_ADD10+0x38>
      || ((hi2c->hdmarx != NULL) && (hi2c->hdmarx->XferCpltCallback != NULL)))
 800bbfc:	687b      	ldr	r3, [r7, #4]
 800bbfe:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800bc00:	2b00      	cmp	r3, #0
 800bc02:	d00c      	beq.n	800bc1e <I2C_Master_ADD10+0x48>
 800bc04:	687b      	ldr	r3, [r7, #4]
 800bc06:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800bc08:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800bc0a:	2b00      	cmp	r3, #0
 800bc0c:	d007      	beq.n	800bc1e <I2C_Master_ADD10+0x48>
  {
    /* Enable DMA Request */
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 800bc0e:	687b      	ldr	r3, [r7, #4]
 800bc10:	681b      	ldr	r3, [r3, #0]
 800bc12:	685a      	ldr	r2, [r3, #4]
 800bc14:	687b      	ldr	r3, [r7, #4]
 800bc16:	681b      	ldr	r3, [r3, #0]
 800bc18:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800bc1c:	605a      	str	r2, [r3, #4]
  }
}
 800bc1e:	bf00      	nop
 800bc20:	370c      	adds	r7, #12
 800bc22:	46bd      	mov	sp, r7
 800bc24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bc28:	4770      	bx	lr

0800bc2a <I2C_Master_ADDR>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)
{
 800bc2a:	b480      	push	{r7}
 800bc2c:	b091      	sub	sp, #68	@ 0x44
 800bc2e:	af00      	add	r7, sp, #0
 800bc30:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_ModeTypeDef CurrentMode       = hi2c->Mode;
 800bc32:	687b      	ldr	r3, [r7, #4]
 800bc34:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800bc38:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
  uint32_t CurrentXferOptions           = hi2c->XferOptions;
 800bc3c:	687b      	ldr	r3, [r7, #4]
 800bc3e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800bc40:	63bb      	str	r3, [r7, #56]	@ 0x38
  uint32_t Prev_State                   = hi2c->PreviousState;
 800bc42:	687b      	ldr	r3, [r7, #4]
 800bc44:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800bc46:	637b      	str	r3, [r7, #52]	@ 0x34

  if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800bc48:	687b      	ldr	r3, [r7, #4]
 800bc4a:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800bc4e:	b2db      	uxtb	r3, r3
 800bc50:	2b22      	cmp	r3, #34	@ 0x22
 800bc52:	f040 8169 	bne.w	800bf28 <I2C_Master_ADDR+0x2fe>
  {
    if ((hi2c->EventCount == 0U) && (CurrentMode == HAL_I2C_MODE_MEM))
 800bc56:	687b      	ldr	r3, [r7, #4]
 800bc58:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bc5a:	2b00      	cmp	r3, #0
 800bc5c:	d10f      	bne.n	800bc7e <I2C_Master_ADDR+0x54>
 800bc5e:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 800bc62:	2b40      	cmp	r3, #64	@ 0x40
 800bc64:	d10b      	bne.n	800bc7e <I2C_Master_ADDR+0x54>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bc66:	2300      	movs	r3, #0
 800bc68:	633b      	str	r3, [r7, #48]	@ 0x30
 800bc6a:	687b      	ldr	r3, [r7, #4]
 800bc6c:	681b      	ldr	r3, [r3, #0]
 800bc6e:	695b      	ldr	r3, [r3, #20]
 800bc70:	633b      	str	r3, [r7, #48]	@ 0x30
 800bc72:	687b      	ldr	r3, [r7, #4]
 800bc74:	681b      	ldr	r3, [r3, #0]
 800bc76:	699b      	ldr	r3, [r3, #24]
 800bc78:	633b      	str	r3, [r7, #48]	@ 0x30
 800bc7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800bc7c:	e160      	b.n	800bf40 <I2C_Master_ADDR+0x316>
    }
    else if ((hi2c->EventCount == 0U) && (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT))
 800bc7e:	687b      	ldr	r3, [r7, #4]
 800bc80:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bc82:	2b00      	cmp	r3, #0
 800bc84:	d11d      	bne.n	800bcc2 <I2C_Master_ADDR+0x98>
 800bc86:	687b      	ldr	r3, [r7, #4]
 800bc88:	691b      	ldr	r3, [r3, #16]
 800bc8a:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
 800bc8e:	d118      	bne.n	800bcc2 <I2C_Master_ADDR+0x98>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bc90:	2300      	movs	r3, #0
 800bc92:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800bc94:	687b      	ldr	r3, [r7, #4]
 800bc96:	681b      	ldr	r3, [r3, #0]
 800bc98:	695b      	ldr	r3, [r3, #20]
 800bc9a:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800bc9c:	687b      	ldr	r3, [r7, #4]
 800bc9e:	681b      	ldr	r3, [r3, #0]
 800bca0:	699b      	ldr	r3, [r3, #24]
 800bca2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800bca4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c

      /* Generate Restart */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 800bca6:	687b      	ldr	r3, [r7, #4]
 800bca8:	681b      	ldr	r3, [r3, #0]
 800bcaa:	681a      	ldr	r2, [r3, #0]
 800bcac:	687b      	ldr	r3, [r7, #4]
 800bcae:	681b      	ldr	r3, [r3, #0]
 800bcb0:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800bcb4:	601a      	str	r2, [r3, #0]

      hi2c->EventCount++;
 800bcb6:	687b      	ldr	r3, [r7, #4]
 800bcb8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800bcba:	1c5a      	adds	r2, r3, #1
 800bcbc:	687b      	ldr	r3, [r7, #4]
 800bcbe:	651a      	str	r2, [r3, #80]	@ 0x50
 800bcc0:	e13e      	b.n	800bf40 <I2C_Master_ADDR+0x316>
    }
    else
    {
      if (hi2c->XferCount == 0U)
 800bcc2:	687b      	ldr	r3, [r7, #4]
 800bcc4:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bcc6:	b29b      	uxth	r3, r3
 800bcc8:	2b00      	cmp	r3, #0
 800bcca:	d113      	bne.n	800bcf4 <I2C_Master_ADDR+0xca>
      {
        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bccc:	2300      	movs	r3, #0
 800bcce:	62bb      	str	r3, [r7, #40]	@ 0x28
 800bcd0:	687b      	ldr	r3, [r7, #4]
 800bcd2:	681b      	ldr	r3, [r3, #0]
 800bcd4:	695b      	ldr	r3, [r3, #20]
 800bcd6:	62bb      	str	r3, [r7, #40]	@ 0x28
 800bcd8:	687b      	ldr	r3, [r7, #4]
 800bcda:	681b      	ldr	r3, [r3, #0]
 800bcdc:	699b      	ldr	r3, [r3, #24]
 800bcde:	62bb      	str	r3, [r7, #40]	@ 0x28
 800bce0:	6abb      	ldr	r3, [r7, #40]	@ 0x28

        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800bce2:	687b      	ldr	r3, [r7, #4]
 800bce4:	681b      	ldr	r3, [r3, #0]
 800bce6:	681a      	ldr	r2, [r3, #0]
 800bce8:	687b      	ldr	r3, [r7, #4]
 800bcea:	681b      	ldr	r3, [r3, #0]
 800bcec:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800bcf0:	601a      	str	r2, [r3, #0]
 800bcf2:	e115      	b.n	800bf20 <I2C_Master_ADDR+0x2f6>
      }
      else if (hi2c->XferCount == 1U)
 800bcf4:	687b      	ldr	r3, [r7, #4]
 800bcf6:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bcf8:	b29b      	uxth	r3, r3
 800bcfa:	2b01      	cmp	r3, #1
 800bcfc:	f040 808a 	bne.w	800be14 <I2C_Master_ADDR+0x1ea>
      {
        if (CurrentXferOptions == I2C_NO_OPTION_FRAME)
 800bd00:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bd02:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 800bd06:	d137      	bne.n	800bd78 <I2C_Master_ADDR+0x14e>
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800bd08:	687b      	ldr	r3, [r7, #4]
 800bd0a:	681b      	ldr	r3, [r3, #0]
 800bd0c:	681a      	ldr	r2, [r3, #0]
 800bd0e:	687b      	ldr	r3, [r7, #4]
 800bd10:	681b      	ldr	r3, [r3, #0]
 800bd12:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800bd16:	601a      	str	r2, [r3, #0]

          if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 800bd18:	687b      	ldr	r3, [r7, #4]
 800bd1a:	681b      	ldr	r3, [r3, #0]
 800bd1c:	685b      	ldr	r3, [r3, #4]
 800bd1e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800bd22:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800bd26:	d113      	bne.n	800bd50 <I2C_Master_ADDR+0x126>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800bd28:	687b      	ldr	r3, [r7, #4]
 800bd2a:	681b      	ldr	r3, [r3, #0]
 800bd2c:	681a      	ldr	r2, [r3, #0]
 800bd2e:	687b      	ldr	r3, [r7, #4]
 800bd30:	681b      	ldr	r3, [r3, #0]
 800bd32:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800bd36:	601a      	str	r2, [r3, #0]

            /* Clear ADDR flag */
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bd38:	2300      	movs	r3, #0
 800bd3a:	627b      	str	r3, [r7, #36]	@ 0x24
 800bd3c:	687b      	ldr	r3, [r7, #4]
 800bd3e:	681b      	ldr	r3, [r3, #0]
 800bd40:	695b      	ldr	r3, [r3, #20]
 800bd42:	627b      	str	r3, [r7, #36]	@ 0x24
 800bd44:	687b      	ldr	r3, [r7, #4]
 800bd46:	681b      	ldr	r3, [r3, #0]
 800bd48:	699b      	ldr	r3, [r3, #24]
 800bd4a:	627b      	str	r3, [r7, #36]	@ 0x24
 800bd4c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800bd4e:	e0e7      	b.n	800bf20 <I2C_Master_ADDR+0x2f6>
          }
          else
          {
            /* Clear ADDR flag */
            __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bd50:	2300      	movs	r3, #0
 800bd52:	623b      	str	r3, [r7, #32]
 800bd54:	687b      	ldr	r3, [r7, #4]
 800bd56:	681b      	ldr	r3, [r3, #0]
 800bd58:	695b      	ldr	r3, [r3, #20]
 800bd5a:	623b      	str	r3, [r7, #32]
 800bd5c:	687b      	ldr	r3, [r7, #4]
 800bd5e:	681b      	ldr	r3, [r3, #0]
 800bd60:	699b      	ldr	r3, [r3, #24]
 800bd62:	623b      	str	r3, [r7, #32]
 800bd64:	6a3b      	ldr	r3, [r7, #32]

            /* Generate Stop */
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800bd66:	687b      	ldr	r3, [r7, #4]
 800bd68:	681b      	ldr	r3, [r3, #0]
 800bd6a:	681a      	ldr	r2, [r3, #0]
 800bd6c:	687b      	ldr	r3, [r7, #4]
 800bd6e:	681b      	ldr	r3, [r3, #0]
 800bd70:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800bd74:	601a      	str	r2, [r3, #0]
 800bd76:	e0d3      	b.n	800bf20 <I2C_Master_ADDR+0x2f6>
          }
        }
        /* Prepare next transfer or stop current transfer */
        else if ((CurrentXferOptions != I2C_FIRST_AND_LAST_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME) \
 800bd78:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bd7a:	2b08      	cmp	r3, #8
 800bd7c:	d02e      	beq.n	800bddc <I2C_Master_ADDR+0x1b2>
 800bd7e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bd80:	2b20      	cmp	r3, #32
 800bd82:	d02b      	beq.n	800bddc <I2C_Master_ADDR+0x1b2>
                 && ((Prev_State != I2C_STATE_MASTER_BUSY_RX) || (CurrentXferOptions == I2C_FIRST_FRAME)))
 800bd84:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800bd86:	2b12      	cmp	r3, #18
 800bd88:	d102      	bne.n	800bd90 <I2C_Master_ADDR+0x166>
 800bd8a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bd8c:	2b01      	cmp	r3, #1
 800bd8e:	d125      	bne.n	800bddc <I2C_Master_ADDR+0x1b2>
        {
          if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 800bd90:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bd92:	2b04      	cmp	r3, #4
 800bd94:	d00e      	beq.n	800bdb4 <I2C_Master_ADDR+0x18a>
 800bd96:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bd98:	2b02      	cmp	r3, #2
 800bd9a:	d00b      	beq.n	800bdb4 <I2C_Master_ADDR+0x18a>
 800bd9c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bd9e:	2b10      	cmp	r3, #16
 800bda0:	d008      	beq.n	800bdb4 <I2C_Master_ADDR+0x18a>
          {
            /* Disable Acknowledge */
            CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800bda2:	687b      	ldr	r3, [r7, #4]
 800bda4:	681b      	ldr	r3, [r3, #0]
 800bda6:	681a      	ldr	r2, [r3, #0]
 800bda8:	687b      	ldr	r3, [r7, #4]
 800bdaa:	681b      	ldr	r3, [r3, #0]
 800bdac:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800bdb0:	601a      	str	r2, [r3, #0]
 800bdb2:	e007      	b.n	800bdc4 <I2C_Master_ADDR+0x19a>
          }
          else
          {
            /* Enable Acknowledge */
            SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800bdb4:	687b      	ldr	r3, [r7, #4]
 800bdb6:	681b      	ldr	r3, [r3, #0]
 800bdb8:	681a      	ldr	r2, [r3, #0]
 800bdba:	687b      	ldr	r3, [r7, #4]
 800bdbc:	681b      	ldr	r3, [r3, #0]
 800bdbe:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800bdc2:	601a      	str	r2, [r3, #0]
          }

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bdc4:	2300      	movs	r3, #0
 800bdc6:	61fb      	str	r3, [r7, #28]
 800bdc8:	687b      	ldr	r3, [r7, #4]
 800bdca:	681b      	ldr	r3, [r3, #0]
 800bdcc:	695b      	ldr	r3, [r3, #20]
 800bdce:	61fb      	str	r3, [r7, #28]
 800bdd0:	687b      	ldr	r3, [r7, #4]
 800bdd2:	681b      	ldr	r3, [r3, #0]
 800bdd4:	699b      	ldr	r3, [r3, #24]
 800bdd6:	61fb      	str	r3, [r7, #28]
 800bdd8:	69fb      	ldr	r3, [r7, #28]
 800bdda:	e0a1      	b.n	800bf20 <I2C_Master_ADDR+0x2f6>
        }
        else
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800bddc:	687b      	ldr	r3, [r7, #4]
 800bdde:	681b      	ldr	r3, [r3, #0]
 800bde0:	681a      	ldr	r2, [r3, #0]
 800bde2:	687b      	ldr	r3, [r7, #4]
 800bde4:	681b      	ldr	r3, [r3, #0]
 800bde6:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800bdea:	601a      	str	r2, [r3, #0]

          /* Clear ADDR flag */
          __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bdec:	2300      	movs	r3, #0
 800bdee:	61bb      	str	r3, [r7, #24]
 800bdf0:	687b      	ldr	r3, [r7, #4]
 800bdf2:	681b      	ldr	r3, [r3, #0]
 800bdf4:	695b      	ldr	r3, [r3, #20]
 800bdf6:	61bb      	str	r3, [r7, #24]
 800bdf8:	687b      	ldr	r3, [r7, #4]
 800bdfa:	681b      	ldr	r3, [r3, #0]
 800bdfc:	699b      	ldr	r3, [r3, #24]
 800bdfe:	61bb      	str	r3, [r7, #24]
 800be00:	69bb      	ldr	r3, [r7, #24]

          /* Generate Stop */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800be02:	687b      	ldr	r3, [r7, #4]
 800be04:	681b      	ldr	r3, [r3, #0]
 800be06:	681a      	ldr	r2, [r3, #0]
 800be08:	687b      	ldr	r3, [r7, #4]
 800be0a:	681b      	ldr	r3, [r3, #0]
 800be0c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800be10:	601a      	str	r2, [r3, #0]
 800be12:	e085      	b.n	800bf20 <I2C_Master_ADDR+0x2f6>
        }
      }
      else if (hi2c->XferCount == 2U)
 800be14:	687b      	ldr	r3, [r7, #4]
 800be16:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800be18:	b29b      	uxth	r3, r3
 800be1a:	2b02      	cmp	r3, #2
 800be1c:	d14d      	bne.n	800beba <I2C_Master_ADDR+0x290>
      {
        if ((CurrentXferOptions != I2C_NEXT_FRAME) && (CurrentXferOptions != I2C_FIRST_AND_NEXT_FRAME) && (CurrentXferOptions != I2C_LAST_FRAME_NO_STOP))
 800be1e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be20:	2b04      	cmp	r3, #4
 800be22:	d016      	beq.n	800be52 <I2C_Master_ADDR+0x228>
 800be24:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be26:	2b02      	cmp	r3, #2
 800be28:	d013      	beq.n	800be52 <I2C_Master_ADDR+0x228>
 800be2a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be2c:	2b10      	cmp	r3, #16
 800be2e:	d010      	beq.n	800be52 <I2C_Master_ADDR+0x228>
        {
          /* Disable Acknowledge */
          CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800be30:	687b      	ldr	r3, [r7, #4]
 800be32:	681b      	ldr	r3, [r3, #0]
 800be34:	681a      	ldr	r2, [r3, #0]
 800be36:	687b      	ldr	r3, [r7, #4]
 800be38:	681b      	ldr	r3, [r3, #0]
 800be3a:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800be3e:	601a      	str	r2, [r3, #0]

          /* Enable Pos */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_POS);
 800be40:	687b      	ldr	r3, [r7, #4]
 800be42:	681b      	ldr	r3, [r3, #0]
 800be44:	681a      	ldr	r2, [r3, #0]
 800be46:	687b      	ldr	r3, [r7, #4]
 800be48:	681b      	ldr	r3, [r3, #0]
 800be4a:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800be4e:	601a      	str	r2, [r3, #0]
 800be50:	e007      	b.n	800be62 <I2C_Master_ADDR+0x238>
        }
        else
        {
          /* Enable Acknowledge */
          SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800be52:	687b      	ldr	r3, [r7, #4]
 800be54:	681b      	ldr	r3, [r3, #0]
 800be56:	681a      	ldr	r2, [r3, #0]
 800be58:	687b      	ldr	r3, [r7, #4]
 800be5a:	681b      	ldr	r3, [r3, #0]
 800be5c:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800be60:	601a      	str	r2, [r3, #0]
        }

        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 800be62:	687b      	ldr	r3, [r7, #4]
 800be64:	681b      	ldr	r3, [r3, #0]
 800be66:	685b      	ldr	r3, [r3, #4]
 800be68:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800be6c:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800be70:	d117      	bne.n	800bea2 <I2C_Master_ADDR+0x278>
 800be72:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be74:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 800be78:	d00b      	beq.n	800be92 <I2C_Master_ADDR+0x268>
 800be7a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be7c:	2b01      	cmp	r3, #1
 800be7e:	d008      	beq.n	800be92 <I2C_Master_ADDR+0x268>
 800be80:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be82:	2b08      	cmp	r3, #8
 800be84:	d005      	beq.n	800be92 <I2C_Master_ADDR+0x268>
 800be86:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be88:	2b10      	cmp	r3, #16
 800be8a:	d002      	beq.n	800be92 <I2C_Master_ADDR+0x268>
 800be8c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800be8e:	2b20      	cmp	r3, #32
 800be90:	d107      	bne.n	800bea2 <I2C_Master_ADDR+0x278>
        {
          /* Enable Last DMA bit */
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 800be92:	687b      	ldr	r3, [r7, #4]
 800be94:	681b      	ldr	r3, [r3, #0]
 800be96:	685a      	ldr	r2, [r3, #4]
 800be98:	687b      	ldr	r3, [r7, #4]
 800be9a:	681b      	ldr	r3, [r3, #0]
 800be9c:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 800bea0:	605a      	str	r2, [r3, #4]
        }

        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bea2:	2300      	movs	r3, #0
 800bea4:	617b      	str	r3, [r7, #20]
 800bea6:	687b      	ldr	r3, [r7, #4]
 800bea8:	681b      	ldr	r3, [r3, #0]
 800beaa:	695b      	ldr	r3, [r3, #20]
 800beac:	617b      	str	r3, [r7, #20]
 800beae:	687b      	ldr	r3, [r7, #4]
 800beb0:	681b      	ldr	r3, [r3, #0]
 800beb2:	699b      	ldr	r3, [r3, #24]
 800beb4:	617b      	str	r3, [r7, #20]
 800beb6:	697b      	ldr	r3, [r7, #20]
 800beb8:	e032      	b.n	800bf20 <I2C_Master_ADDR+0x2f6>
      }
      else
      {
        /* Enable Acknowledge */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800beba:	687b      	ldr	r3, [r7, #4]
 800bebc:	681b      	ldr	r3, [r3, #0]
 800bebe:	681a      	ldr	r2, [r3, #0]
 800bec0:	687b      	ldr	r3, [r7, #4]
 800bec2:	681b      	ldr	r3, [r3, #0]
 800bec4:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800bec8:	601a      	str	r2, [r3, #0]

        if (((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN) && ((CurrentXferOptions == I2C_NO_OPTION_FRAME) || (CurrentXferOptions == I2C_FIRST_FRAME) || (CurrentXferOptions == I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME_NO_STOP) || (CurrentXferOptions == I2C_LAST_FRAME)))
 800beca:	687b      	ldr	r3, [r7, #4]
 800becc:	681b      	ldr	r3, [r3, #0]
 800bece:	685b      	ldr	r3, [r3, #4]
 800bed0:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800bed4:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800bed8:	d117      	bne.n	800bf0a <I2C_Master_ADDR+0x2e0>
 800beda:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bedc:	f513 3f80 	cmn.w	r3, #65536	@ 0x10000
 800bee0:	d00b      	beq.n	800befa <I2C_Master_ADDR+0x2d0>
 800bee2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bee4:	2b01      	cmp	r3, #1
 800bee6:	d008      	beq.n	800befa <I2C_Master_ADDR+0x2d0>
 800bee8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800beea:	2b08      	cmp	r3, #8
 800beec:	d005      	beq.n	800befa <I2C_Master_ADDR+0x2d0>
 800beee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bef0:	2b10      	cmp	r3, #16
 800bef2:	d002      	beq.n	800befa <I2C_Master_ADDR+0x2d0>
 800bef4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800bef6:	2b20      	cmp	r3, #32
 800bef8:	d107      	bne.n	800bf0a <I2C_Master_ADDR+0x2e0>
        {
          /* Enable Last DMA bit */
          SET_BIT(hi2c->Instance->CR2, I2C_CR2_LAST);
 800befa:	687b      	ldr	r3, [r7, #4]
 800befc:	681b      	ldr	r3, [r3, #0]
 800befe:	685a      	ldr	r2, [r3, #4]
 800bf00:	687b      	ldr	r3, [r7, #4]
 800bf02:	681b      	ldr	r3, [r3, #0]
 800bf04:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 800bf08:	605a      	str	r2, [r3, #4]
        }

        /* Clear ADDR flag */
        __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bf0a:	2300      	movs	r3, #0
 800bf0c:	613b      	str	r3, [r7, #16]
 800bf0e:	687b      	ldr	r3, [r7, #4]
 800bf10:	681b      	ldr	r3, [r3, #0]
 800bf12:	695b      	ldr	r3, [r3, #20]
 800bf14:	613b      	str	r3, [r7, #16]
 800bf16:	687b      	ldr	r3, [r7, #4]
 800bf18:	681b      	ldr	r3, [r3, #0]
 800bf1a:	699b      	ldr	r3, [r3, #24]
 800bf1c:	613b      	str	r3, [r7, #16]
 800bf1e:	693b      	ldr	r3, [r7, #16]
      }

      /* Reset Event counter  */
      hi2c->EventCount = 0U;
 800bf20:	687b      	ldr	r3, [r7, #4]
 800bf22:	2200      	movs	r2, #0
 800bf24:	651a      	str	r2, [r3, #80]	@ 0x50
  else
  {
    /* Clear ADDR flag */
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
  }
}
 800bf26:	e00b      	b.n	800bf40 <I2C_Master_ADDR+0x316>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800bf28:	2300      	movs	r3, #0
 800bf2a:	60fb      	str	r3, [r7, #12]
 800bf2c:	687b      	ldr	r3, [r7, #4]
 800bf2e:	681b      	ldr	r3, [r3, #0]
 800bf30:	695b      	ldr	r3, [r3, #20]
 800bf32:	60fb      	str	r3, [r7, #12]
 800bf34:	687b      	ldr	r3, [r7, #4]
 800bf36:	681b      	ldr	r3, [r3, #0]
 800bf38:	699b      	ldr	r3, [r3, #24]
 800bf3a:	60fb      	str	r3, [r7, #12]
 800bf3c:	68fb      	ldr	r3, [r7, #12]
}
 800bf3e:	e7ff      	b.n	800bf40 <I2C_Master_ADDR+0x316>
 800bf40:	bf00      	nop
 800bf42:	3744      	adds	r7, #68	@ 0x44
 800bf44:	46bd      	mov	sp, r7
 800bf46:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf4a:	4770      	bx	lr

0800bf4c <I2C_SlaveTransmit_TXE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)
{
 800bf4c:	b580      	push	{r7, lr}
 800bf4e:	b084      	sub	sp, #16
 800bf50:	af00      	add	r7, sp, #0
 800bf52:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800bf54:	687b      	ldr	r3, [r7, #4]
 800bf56:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800bf5a:	73fb      	strb	r3, [r7, #15]

  if (hi2c->XferCount != 0U)
 800bf5c:	687b      	ldr	r3, [r7, #4]
 800bf5e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bf60:	b29b      	uxth	r3, r3
 800bf62:	2b00      	cmp	r3, #0
 800bf64:	d02b      	beq.n	800bfbe <I2C_SlaveTransmit_TXE+0x72>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 800bf66:	687b      	ldr	r3, [r7, #4]
 800bf68:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bf6a:	781a      	ldrb	r2, [r3, #0]
 800bf6c:	687b      	ldr	r3, [r7, #4]
 800bf6e:	681b      	ldr	r3, [r3, #0]
 800bf70:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 800bf72:	687b      	ldr	r3, [r7, #4]
 800bf74:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bf76:	1c5a      	adds	r2, r3, #1
 800bf78:	687b      	ldr	r3, [r7, #4]
 800bf7a:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 800bf7c:	687b      	ldr	r3, [r7, #4]
 800bf7e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bf80:	b29b      	uxth	r3, r3
 800bf82:	3b01      	subs	r3, #1
 800bf84:	b29a      	uxth	r2, r3
 800bf86:	687b      	ldr	r3, [r7, #4]
 800bf88:	855a      	strh	r2, [r3, #42]	@ 0x2a

    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_TX_LISTEN))
 800bf8a:	687b      	ldr	r3, [r7, #4]
 800bf8c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bf8e:	b29b      	uxth	r3, r3
 800bf90:	2b00      	cmp	r3, #0
 800bf92:	d114      	bne.n	800bfbe <I2C_SlaveTransmit_TXE+0x72>
 800bf94:	7bfb      	ldrb	r3, [r7, #15]
 800bf96:	2b29      	cmp	r3, #41	@ 0x29
 800bf98:	d111      	bne.n	800bfbe <I2C_SlaveTransmit_TXE+0x72>
    {
      /* Last Byte is received, disable Interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800bf9a:	687b      	ldr	r3, [r7, #4]
 800bf9c:	681b      	ldr	r3, [r3, #0]
 800bf9e:	685a      	ldr	r2, [r3, #4]
 800bfa0:	687b      	ldr	r3, [r7, #4]
 800bfa2:	681b      	ldr	r3, [r3, #0]
 800bfa4:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800bfa8:	605a      	str	r2, [r3, #4]

      /* Set state at HAL_I2C_STATE_LISTEN */
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 800bfaa:	687b      	ldr	r3, [r7, #4]
 800bfac:	2221      	movs	r2, #33	@ 0x21
 800bfae:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 800bfb0:	687b      	ldr	r3, [r7, #4]
 800bfb2:	2228      	movs	r2, #40	@ 0x28
 800bfb4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

      /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->SlaveTxCpltCallback(hi2c);
#else
      HAL_I2C_SlaveTxCpltCallback(hi2c);
 800bfb8:	6878      	ldr	r0, [r7, #4]
 800bfba:	f7ff f9d5 	bl	800b368 <HAL_I2C_SlaveTxCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
  }
}
 800bfbe:	bf00      	nop
 800bfc0:	3710      	adds	r7, #16
 800bfc2:	46bd      	mov	sp, r7
 800bfc4:	bd80      	pop	{r7, pc}

0800bfc6 <I2C_SlaveTransmit_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)
{
 800bfc6:	b480      	push	{r7}
 800bfc8:	b083      	sub	sp, #12
 800bfca:	af00      	add	r7, sp, #0
 800bfcc:	6078      	str	r0, [r7, #4]
  if (hi2c->XferCount != 0U)
 800bfce:	687b      	ldr	r3, [r7, #4]
 800bfd0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bfd2:	b29b      	uxth	r3, r3
 800bfd4:	2b00      	cmp	r3, #0
 800bfd6:	d011      	beq.n	800bffc <I2C_SlaveTransmit_BTF+0x36>
  {
    /* Write data to DR */
    hi2c->Instance->DR = *hi2c->pBuffPtr;
 800bfd8:	687b      	ldr	r3, [r7, #4]
 800bfda:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bfdc:	781a      	ldrb	r2, [r3, #0]
 800bfde:	687b      	ldr	r3, [r7, #4]
 800bfe0:	681b      	ldr	r3, [r3, #0]
 800bfe2:	611a      	str	r2, [r3, #16]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 800bfe4:	687b      	ldr	r3, [r7, #4]
 800bfe6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bfe8:	1c5a      	adds	r2, r3, #1
 800bfea:	687b      	ldr	r3, [r7, #4]
 800bfec:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 800bfee:	687b      	ldr	r3, [r7, #4]
 800bff0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800bff2:	b29b      	uxth	r3, r3
 800bff4:	3b01      	subs	r3, #1
 800bff6:	b29a      	uxth	r2, r3
 800bff8:	687b      	ldr	r3, [r7, #4]
 800bffa:	855a      	strh	r2, [r3, #42]	@ 0x2a
  }
}
 800bffc:	bf00      	nop
 800bffe:	370c      	adds	r7, #12
 800c000:	46bd      	mov	sp, r7
 800c002:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c006:	4770      	bx	lr

0800c008 <I2C_SlaveReceive_RXNE>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)
{
 800c008:	b580      	push	{r7, lr}
 800c00a:	b084      	sub	sp, #16
 800c00c:	af00      	add	r7, sp, #0
 800c00e:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c016:	73fb      	strb	r3, [r7, #15]

  if (hi2c->XferCount != 0U)
 800c018:	687b      	ldr	r3, [r7, #4]
 800c01a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c01c:	b29b      	uxth	r3, r3
 800c01e:	2b00      	cmp	r3, #0
 800c020:	d02c      	beq.n	800c07c <I2C_SlaveReceive_RXNE+0x74>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800c022:	687b      	ldr	r3, [r7, #4]
 800c024:	681b      	ldr	r3, [r3, #0]
 800c026:	691a      	ldr	r2, [r3, #16]
 800c028:	687b      	ldr	r3, [r7, #4]
 800c02a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c02c:	b2d2      	uxtb	r2, r2
 800c02e:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 800c030:	687b      	ldr	r3, [r7, #4]
 800c032:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c034:	1c5a      	adds	r2, r3, #1
 800c036:	687b      	ldr	r3, [r7, #4]
 800c038:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 800c03a:	687b      	ldr	r3, [r7, #4]
 800c03c:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c03e:	b29b      	uxth	r3, r3
 800c040:	3b01      	subs	r3, #1
 800c042:	b29a      	uxth	r2, r3
 800c044:	687b      	ldr	r3, [r7, #4]
 800c046:	855a      	strh	r2, [r3, #42]	@ 0x2a

    if ((hi2c->XferCount == 0U) && (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 800c048:	687b      	ldr	r3, [r7, #4]
 800c04a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c04c:	b29b      	uxth	r3, r3
 800c04e:	2b00      	cmp	r3, #0
 800c050:	d114      	bne.n	800c07c <I2C_SlaveReceive_RXNE+0x74>
 800c052:	7bfb      	ldrb	r3, [r7, #15]
 800c054:	2b2a      	cmp	r3, #42	@ 0x2a
 800c056:	d111      	bne.n	800c07c <I2C_SlaveReceive_RXNE+0x74>
    {
      /* Last Byte is received, disable Interrupt */
      __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_BUF);
 800c058:	687b      	ldr	r3, [r7, #4]
 800c05a:	681b      	ldr	r3, [r3, #0]
 800c05c:	685a      	ldr	r2, [r3, #4]
 800c05e:	687b      	ldr	r3, [r7, #4]
 800c060:	681b      	ldr	r3, [r3, #0]
 800c062:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800c066:	605a      	str	r2, [r3, #4]

      /* Set state at HAL_I2C_STATE_LISTEN */
      hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 800c068:	687b      	ldr	r3, [r7, #4]
 800c06a:	2222      	movs	r2, #34	@ 0x22
 800c06c:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 800c06e:	687b      	ldr	r3, [r7, #4]
 800c070:	2228      	movs	r2, #40	@ 0x28
 800c072:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

      /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
      hi2c->SlaveRxCpltCallback(hi2c);
#else
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 800c076:	6878      	ldr	r0, [r7, #4]
 800c078:	f7ff f980 	bl	800b37c <HAL_I2C_SlaveRxCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
    }
  }
}
 800c07c:	bf00      	nop
 800c07e:	3710      	adds	r7, #16
 800c080:	46bd      	mov	sp, r7
 800c082:	bd80      	pop	{r7, pc}

0800c084 <I2C_SlaveReceive_BTF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)
{
 800c084:	b480      	push	{r7}
 800c086:	b083      	sub	sp, #12
 800c088:	af00      	add	r7, sp, #0
 800c08a:	6078      	str	r0, [r7, #4]
  if (hi2c->XferCount != 0U)
 800c08c:	687b      	ldr	r3, [r7, #4]
 800c08e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c090:	b29b      	uxth	r3, r3
 800c092:	2b00      	cmp	r3, #0
 800c094:	d012      	beq.n	800c0bc <I2C_SlaveReceive_BTF+0x38>
  {
    /* Read data from DR */
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800c096:	687b      	ldr	r3, [r7, #4]
 800c098:	681b      	ldr	r3, [r3, #0]
 800c09a:	691a      	ldr	r2, [r3, #16]
 800c09c:	687b      	ldr	r3, [r7, #4]
 800c09e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c0a0:	b2d2      	uxtb	r2, r2
 800c0a2:	701a      	strb	r2, [r3, #0]

    /* Increment Buffer pointer */
    hi2c->pBuffPtr++;
 800c0a4:	687b      	ldr	r3, [r7, #4]
 800c0a6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c0a8:	1c5a      	adds	r2, r3, #1
 800c0aa:	687b      	ldr	r3, [r7, #4]
 800c0ac:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Update counter */
    hi2c->XferCount--;
 800c0ae:	687b      	ldr	r3, [r7, #4]
 800c0b0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c0b2:	b29b      	uxth	r3, r3
 800c0b4:	3b01      	subs	r3, #1
 800c0b6:	b29a      	uxth	r2, r3
 800c0b8:	687b      	ldr	r3, [r7, #4]
 800c0ba:	855a      	strh	r2, [r3, #42]	@ 0x2a
  }
}
 800c0bc:	bf00      	nop
 800c0be:	370c      	adds	r7, #12
 800c0c0:	46bd      	mov	sp, r7
 800c0c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0c6:	4770      	bx	lr

0800c0c8 <I2C_Slave_ADDR>:
  *         the configuration information for I2C module
  * @param  IT2Flags Interrupt2 flags to handle.
  * @retval None
  */
static void I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c, uint32_t IT2Flags)
{
 800c0c8:	b580      	push	{r7, lr}
 800c0ca:	b084      	sub	sp, #16
 800c0cc:	af00      	add	r7, sp, #0
 800c0ce:	6078      	str	r0, [r7, #4]
 800c0d0:	6039      	str	r1, [r7, #0]
  uint8_t TransferDirection = I2C_DIRECTION_RECEIVE;
 800c0d2:	2300      	movs	r3, #0
 800c0d4:	73fb      	strb	r3, [r7, #15]
  uint16_t SlaveAddrCode;

  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 800c0d6:	687b      	ldr	r3, [r7, #4]
 800c0d8:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c0dc:	b2db      	uxtb	r3, r3
 800c0de:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 800c0e2:	2b28      	cmp	r3, #40	@ 0x28
 800c0e4:	d125      	bne.n	800c132 <I2C_Slave_ADDR+0x6a>
  {
    /* Disable BUF interrupt, BUF enabling is manage through slave specific interface */
    __HAL_I2C_DISABLE_IT(hi2c, (I2C_IT_BUF));
 800c0e6:	687b      	ldr	r3, [r7, #4]
 800c0e8:	681b      	ldr	r3, [r3, #0]
 800c0ea:	685a      	ldr	r2, [r3, #4]
 800c0ec:	687b      	ldr	r3, [r7, #4]
 800c0ee:	681b      	ldr	r3, [r3, #0]
 800c0f0:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800c0f4:	605a      	str	r2, [r3, #4]

    /* Transfer Direction requested by Master */
    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_TRA) == RESET)
 800c0f6:	683b      	ldr	r3, [r7, #0]
 800c0f8:	f003 0304 	and.w	r3, r3, #4
 800c0fc:	2b00      	cmp	r3, #0
 800c0fe:	d101      	bne.n	800c104 <I2C_Slave_ADDR+0x3c>
    {
      TransferDirection = I2C_DIRECTION_TRANSMIT;
 800c100:	2301      	movs	r3, #1
 800c102:	73fb      	strb	r3, [r7, #15]
    }

    if (I2C_CHECK_FLAG(IT2Flags, I2C_FLAG_DUALF) == RESET)
 800c104:	683b      	ldr	r3, [r7, #0]
 800c106:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800c10a:	2b00      	cmp	r3, #0
 800c10c:	d103      	bne.n	800c116 <I2C_Slave_ADDR+0x4e>
    {
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress1;
 800c10e:	687b      	ldr	r3, [r7, #4]
 800c110:	68db      	ldr	r3, [r3, #12]
 800c112:	81bb      	strh	r3, [r7, #12]
 800c114:	e002      	b.n	800c11c <I2C_Slave_ADDR+0x54>
    }
    else
    {
      SlaveAddrCode = (uint16_t)hi2c->Init.OwnAddress2;
 800c116:	687b      	ldr	r3, [r7, #4]
 800c118:	699b      	ldr	r3, [r3, #24]
 800c11a:	81bb      	strh	r3, [r7, #12]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800c11c:	687b      	ldr	r3, [r7, #4]
 800c11e:	2200      	movs	r2, #0
 800c120:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    /* Call Slave Addr callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
#else
    HAL_I2C_AddrCallback(hi2c, TransferDirection, SlaveAddrCode);
 800c124:	89ba      	ldrh	r2, [r7, #12]
 800c126:	7bfb      	ldrb	r3, [r7, #15]
 800c128:	4619      	mov	r1, r3
 800c12a:	6878      	ldr	r0, [r7, #4]
 800c12c:	f7ff f930 	bl	800b390 <HAL_I2C_AddrCallback>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
  }
}
 800c130:	e00e      	b.n	800c150 <I2C_Slave_ADDR+0x88>
    __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800c132:	2300      	movs	r3, #0
 800c134:	60bb      	str	r3, [r7, #8]
 800c136:	687b      	ldr	r3, [r7, #4]
 800c138:	681b      	ldr	r3, [r3, #0]
 800c13a:	695b      	ldr	r3, [r3, #20]
 800c13c:	60bb      	str	r3, [r7, #8]
 800c13e:	687b      	ldr	r3, [r7, #4]
 800c140:	681b      	ldr	r3, [r3, #0]
 800c142:	699b      	ldr	r3, [r3, #24]
 800c144:	60bb      	str	r3, [r7, #8]
 800c146:	68bb      	ldr	r3, [r7, #8]
    __HAL_UNLOCK(hi2c);
 800c148:	687b      	ldr	r3, [r7, #4]
 800c14a:	2200      	movs	r2, #0
 800c14c:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
}
 800c150:	bf00      	nop
 800c152:	3710      	adds	r7, #16
 800c154:	46bd      	mov	sp, r7
 800c156:	bd80      	pop	{r7, pc}

0800c158 <I2C_Slave_STOPF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)
{
 800c158:	b580      	push	{r7, lr}
 800c15a:	b084      	sub	sp, #16
 800c15c:	af00      	add	r7, sp, #0
 800c15e:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800c160:	687b      	ldr	r3, [r7, #4]
 800c162:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c166:	73fb      	strb	r3, [r7, #15]

  /* Disable EVT, BUF and ERR interrupt */
  __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800c168:	687b      	ldr	r3, [r7, #4]
 800c16a:	681b      	ldr	r3, [r3, #0]
 800c16c:	685a      	ldr	r2, [r3, #4]
 800c16e:	687b      	ldr	r3, [r7, #4]
 800c170:	681b      	ldr	r3, [r3, #0]
 800c172:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c176:	605a      	str	r2, [r3, #4]

  /* Clear STOPF flag */
  __HAL_I2C_CLEAR_STOPFLAG(hi2c);
 800c178:	2300      	movs	r3, #0
 800c17a:	60bb      	str	r3, [r7, #8]
 800c17c:	687b      	ldr	r3, [r7, #4]
 800c17e:	681b      	ldr	r3, [r3, #0]
 800c180:	695b      	ldr	r3, [r3, #20]
 800c182:	60bb      	str	r3, [r7, #8]
 800c184:	687b      	ldr	r3, [r7, #4]
 800c186:	681b      	ldr	r3, [r3, #0]
 800c188:	681a      	ldr	r2, [r3, #0]
 800c18a:	687b      	ldr	r3, [r7, #4]
 800c18c:	681b      	ldr	r3, [r3, #0]
 800c18e:	f042 0201 	orr.w	r2, r2, #1
 800c192:	601a      	str	r2, [r3, #0]
 800c194:	68bb      	ldr	r3, [r7, #8]

  /* Disable Acknowledge */
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800c196:	687b      	ldr	r3, [r7, #4]
 800c198:	681b      	ldr	r3, [r3, #0]
 800c19a:	681a      	ldr	r2, [r3, #0]
 800c19c:	687b      	ldr	r3, [r7, #4]
 800c19e:	681b      	ldr	r3, [r3, #0]
 800c1a0:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800c1a4:	601a      	str	r2, [r3, #0]

  /* If a DMA is ongoing, Update handle size context */
  if ((hi2c->Instance->CR2 & I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 800c1a6:	687b      	ldr	r3, [r7, #4]
 800c1a8:	681b      	ldr	r3, [r3, #0]
 800c1aa:	685b      	ldr	r3, [r3, #4]
 800c1ac:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800c1b0:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800c1b4:	d172      	bne.n	800c29c <I2C_Slave_STOPF+0x144>
  {
    if ((CurrentState == HAL_I2C_STATE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN))
 800c1b6:	7bfb      	ldrb	r3, [r7, #15]
 800c1b8:	2b22      	cmp	r3, #34	@ 0x22
 800c1ba:	d002      	beq.n	800c1c2 <I2C_Slave_STOPF+0x6a>
 800c1bc:	7bfb      	ldrb	r3, [r7, #15]
 800c1be:	2b2a      	cmp	r3, #42	@ 0x2a
 800c1c0:	d135      	bne.n	800c22e <I2C_Slave_STOPF+0xd6>
    {
      hi2c->XferCount = (uint16_t)(I2C_GET_DMA_REMAIN_DATA(hi2c->hdmarx));
 800c1c2:	687b      	ldr	r3, [r7, #4]
 800c1c4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c1c6:	681b      	ldr	r3, [r3, #0]
 800c1c8:	685b      	ldr	r3, [r3, #4]
 800c1ca:	b29a      	uxth	r2, r3
 800c1cc:	687b      	ldr	r3, [r7, #4]
 800c1ce:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if (hi2c->XferCount != 0U)
 800c1d0:	687b      	ldr	r3, [r7, #4]
 800c1d2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c1d4:	b29b      	uxth	r3, r3
 800c1d6:	2b00      	cmp	r3, #0
 800c1d8:	d005      	beq.n	800c1e6 <I2C_Slave_STOPF+0x8e>
      {
        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800c1da:	687b      	ldr	r3, [r7, #4]
 800c1dc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c1de:	f043 0204 	orr.w	r2, r3, #4
 800c1e2:	687b      	ldr	r3, [r7, #4]
 800c1e4:	641a      	str	r2, [r3, #64]	@ 0x40
      }

      /* Disable, stop the current DMA */
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 800c1e6:	687b      	ldr	r3, [r7, #4]
 800c1e8:	681b      	ldr	r3, [r3, #0]
 800c1ea:	685a      	ldr	r2, [r3, #4]
 800c1ec:	687b      	ldr	r3, [r7, #4]
 800c1ee:	681b      	ldr	r3, [r3, #0]
 800c1f0:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800c1f4:	605a      	str	r2, [r3, #4]

      /* Abort DMA Xfer if any */
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 800c1f6:	687b      	ldr	r3, [r7, #4]
 800c1f8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c1fa:	4618      	mov	r0, r3
 800c1fc:	f7fd fa36 	bl	800966c <HAL_DMA_GetState>
 800c200:	4603      	mov	r3, r0
 800c202:	2b01      	cmp	r3, #1
 800c204:	d049      	beq.n	800c29a <I2C_Slave_STOPF+0x142>
      {
        /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
        hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 800c206:	687b      	ldr	r3, [r7, #4]
 800c208:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c20a:	4a69      	ldr	r2, [pc, #420]	@ (800c3b0 <I2C_Slave_STOPF+0x258>)
 800c20c:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Abort DMA RX */
        if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 800c20e:	687b      	ldr	r3, [r7, #4]
 800c210:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c212:	4618      	mov	r0, r3
 800c214:	f7fd f87e 	bl	8009314 <HAL_DMA_Abort_IT>
 800c218:	4603      	mov	r3, r0
 800c21a:	2b00      	cmp	r3, #0
 800c21c:	d03d      	beq.n	800c29a <I2C_Slave_STOPF+0x142>
        {
          /* Call Directly XferAbortCallback function in case of error */
          hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800c21e:	687b      	ldr	r3, [r7, #4]
 800c220:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c222:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c224:	687a      	ldr	r2, [r7, #4]
 800c226:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 800c228:	4610      	mov	r0, r2
 800c22a:	4798      	blx	r3
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 800c22c:	e035      	b.n	800c29a <I2C_Slave_STOPF+0x142>
        }
      }
    }
    else
    {
      hi2c->XferCount = (uint16_t)(I2C_GET_DMA_REMAIN_DATA(hi2c->hdmatx));
 800c22e:	687b      	ldr	r3, [r7, #4]
 800c230:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c232:	681b      	ldr	r3, [r3, #0]
 800c234:	685b      	ldr	r3, [r3, #4]
 800c236:	b29a      	uxth	r2, r3
 800c238:	687b      	ldr	r3, [r7, #4]
 800c23a:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if (hi2c->XferCount != 0U)
 800c23c:	687b      	ldr	r3, [r7, #4]
 800c23e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c240:	b29b      	uxth	r3, r3
 800c242:	2b00      	cmp	r3, #0
 800c244:	d005      	beq.n	800c252 <I2C_Slave_STOPF+0xfa>
      {
        /* Set ErrorCode corresponding to a Non-Acknowledge */
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800c246:	687b      	ldr	r3, [r7, #4]
 800c248:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c24a:	f043 0204 	orr.w	r2, r3, #4
 800c24e:	687b      	ldr	r3, [r7, #4]
 800c250:	641a      	str	r2, [r3, #64]	@ 0x40
      }

      /* Disable, stop the current DMA */
      CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN);
 800c252:	687b      	ldr	r3, [r7, #4]
 800c254:	681b      	ldr	r3, [r3, #0]
 800c256:	685a      	ldr	r2, [r3, #4]
 800c258:	687b      	ldr	r3, [r7, #4]
 800c25a:	681b      	ldr	r3, [r3, #0]
 800c25c:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800c260:	605a      	str	r2, [r3, #4]

      /* Abort DMA Xfer if any */
      if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 800c262:	687b      	ldr	r3, [r7, #4]
 800c264:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c266:	4618      	mov	r0, r3
 800c268:	f7fd fa00 	bl	800966c <HAL_DMA_GetState>
 800c26c:	4603      	mov	r3, r0
 800c26e:	2b01      	cmp	r3, #1
 800c270:	d014      	beq.n	800c29c <I2C_Slave_STOPF+0x144>
      {
        /* Set the I2C DMA Abort callback :
        will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
        hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 800c272:	687b      	ldr	r3, [r7, #4]
 800c274:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c276:	4a4e      	ldr	r2, [pc, #312]	@ (800c3b0 <I2C_Slave_STOPF+0x258>)
 800c278:	651a      	str	r2, [r3, #80]	@ 0x50

        /* Abort DMA TX */
        if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 800c27a:	687b      	ldr	r3, [r7, #4]
 800c27c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c27e:	4618      	mov	r0, r3
 800c280:	f7fd f848 	bl	8009314 <HAL_DMA_Abort_IT>
 800c284:	4603      	mov	r3, r0
 800c286:	2b00      	cmp	r3, #0
 800c288:	d008      	beq.n	800c29c <I2C_Slave_STOPF+0x144>
        {
          /* Call Directly XferAbortCallback function in case of error */
          hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 800c28a:	687b      	ldr	r3, [r7, #4]
 800c28c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c28e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c290:	687a      	ldr	r2, [r7, #4]
 800c292:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 800c294:	4610      	mov	r0, r2
 800c296:	4798      	blx	r3
 800c298:	e000      	b.n	800c29c <I2C_Slave_STOPF+0x144>
      if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 800c29a:	bf00      	nop
      }
    }
  }

  /* All data are not transferred, so set error code accordingly */
  if (hi2c->XferCount != 0U)
 800c29c:	687b      	ldr	r3, [r7, #4]
 800c29e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c2a0:	b29b      	uxth	r3, r3
 800c2a2:	2b00      	cmp	r3, #0
 800c2a4:	d03e      	beq.n	800c324 <I2C_Slave_STOPF+0x1cc>
  {
    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 800c2a6:	687b      	ldr	r3, [r7, #4]
 800c2a8:	681b      	ldr	r3, [r3, #0]
 800c2aa:	695b      	ldr	r3, [r3, #20]
 800c2ac:	f003 0304 	and.w	r3, r3, #4
 800c2b0:	2b04      	cmp	r3, #4
 800c2b2:	d112      	bne.n	800c2da <I2C_Slave_STOPF+0x182>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800c2b4:	687b      	ldr	r3, [r7, #4]
 800c2b6:	681b      	ldr	r3, [r3, #0]
 800c2b8:	691a      	ldr	r2, [r3, #16]
 800c2ba:	687b      	ldr	r3, [r7, #4]
 800c2bc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c2be:	b2d2      	uxtb	r2, r2
 800c2c0:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800c2c2:	687b      	ldr	r3, [r7, #4]
 800c2c4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c2c6:	1c5a      	adds	r2, r3, #1
 800c2c8:	687b      	ldr	r3, [r7, #4]
 800c2ca:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 800c2cc:	687b      	ldr	r3, [r7, #4]
 800c2ce:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c2d0:	b29b      	uxth	r3, r3
 800c2d2:	3b01      	subs	r3, #1
 800c2d4:	b29a      	uxth	r2, r3
 800c2d6:	687b      	ldr	r3, [r7, #4]
 800c2d8:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }

    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800c2da:	687b      	ldr	r3, [r7, #4]
 800c2dc:	681b      	ldr	r3, [r3, #0]
 800c2de:	695b      	ldr	r3, [r3, #20]
 800c2e0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800c2e4:	2b40      	cmp	r3, #64	@ 0x40
 800c2e6:	d112      	bne.n	800c30e <I2C_Slave_STOPF+0x1b6>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800c2e8:	687b      	ldr	r3, [r7, #4]
 800c2ea:	681b      	ldr	r3, [r3, #0]
 800c2ec:	691a      	ldr	r2, [r3, #16]
 800c2ee:	687b      	ldr	r3, [r7, #4]
 800c2f0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c2f2:	b2d2      	uxtb	r2, r2
 800c2f4:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800c2f6:	687b      	ldr	r3, [r7, #4]
 800c2f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c2fa:	1c5a      	adds	r2, r3, #1
 800c2fc:	687b      	ldr	r3, [r7, #4]
 800c2fe:	625a      	str	r2, [r3, #36]	@ 0x24

      /* Update counter */
      hi2c->XferCount--;
 800c300:	687b      	ldr	r3, [r7, #4]
 800c302:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c304:	b29b      	uxth	r3, r3
 800c306:	3b01      	subs	r3, #1
 800c308:	b29a      	uxth	r2, r3
 800c30a:	687b      	ldr	r3, [r7, #4]
 800c30c:	855a      	strh	r2, [r3, #42]	@ 0x2a
    }

    if (hi2c->XferCount != 0U)
 800c30e:	687b      	ldr	r3, [r7, #4]
 800c310:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800c312:	b29b      	uxth	r3, r3
 800c314:	2b00      	cmp	r3, #0
 800c316:	d005      	beq.n	800c324 <I2C_Slave_STOPF+0x1cc>
    {
      /* Set ErrorCode corresponding to a Non-Acknowledge */
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800c318:	687b      	ldr	r3, [r7, #4]
 800c31a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c31c:	f043 0204 	orr.w	r2, r3, #4
 800c320:	687b      	ldr	r3, [r7, #4]
 800c322:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 800c324:	687b      	ldr	r3, [r7, #4]
 800c326:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c328:	2b00      	cmp	r3, #0
 800c32a:	d003      	beq.n	800c334 <I2C_Slave_STOPF+0x1dc>
  {
    /* Call the corresponding callback to inform upper layer of End of Transfer */
    I2C_ITError(hi2c);
 800c32c:	6878      	ldr	r0, [r7, #4]
 800c32e:	f000 f8b7 	bl	800c4a0 <I2C_ITError>
        HAL_I2C_SlaveRxCpltCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
      }
    }
  }
}
 800c332:	e039      	b.n	800c3a8 <I2C_Slave_STOPF+0x250>
    if (CurrentState == HAL_I2C_STATE_BUSY_RX_LISTEN)
 800c334:	7bfb      	ldrb	r3, [r7, #15]
 800c336:	2b2a      	cmp	r3, #42	@ 0x2a
 800c338:	d109      	bne.n	800c34e <I2C_Slave_STOPF+0x1f6>
      hi2c->PreviousState = I2C_STATE_NONE;
 800c33a:	687b      	ldr	r3, [r7, #4]
 800c33c:	2200      	movs	r2, #0
 800c33e:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 800c340:	687b      	ldr	r3, [r7, #4]
 800c342:	2228      	movs	r2, #40	@ 0x28
 800c344:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      HAL_I2C_SlaveRxCpltCallback(hi2c);
 800c348:	6878      	ldr	r0, [r7, #4]
 800c34a:	f7ff f817 	bl	800b37c <HAL_I2C_SlaveRxCpltCallback>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 800c34e:	687b      	ldr	r3, [r7, #4]
 800c350:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c354:	b2db      	uxtb	r3, r3
 800c356:	2b28      	cmp	r3, #40	@ 0x28
 800c358:	d111      	bne.n	800c37e <I2C_Slave_STOPF+0x226>
      hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800c35a:	687b      	ldr	r3, [r7, #4]
 800c35c:	4a15      	ldr	r2, [pc, #84]	@ (800c3b4 <I2C_Slave_STOPF+0x25c>)
 800c35e:	62da      	str	r2, [r3, #44]	@ 0x2c
      hi2c->PreviousState = I2C_STATE_NONE;
 800c360:	687b      	ldr	r3, [r7, #4]
 800c362:	2200      	movs	r2, #0
 800c364:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_READY;
 800c366:	687b      	ldr	r3, [r7, #4]
 800c368:	2220      	movs	r2, #32
 800c36a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800c36e:	687b      	ldr	r3, [r7, #4]
 800c370:	2200      	movs	r2, #0
 800c372:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      HAL_I2C_ListenCpltCallback(hi2c);
 800c376:	6878      	ldr	r0, [r7, #4]
 800c378:	f7ff f818 	bl	800b3ac <HAL_I2C_ListenCpltCallback>
}
 800c37c:	e014      	b.n	800c3a8 <I2C_Slave_STOPF+0x250>
      if ((hi2c->PreviousState  == I2C_STATE_SLAVE_BUSY_RX) || (CurrentState == HAL_I2C_STATE_BUSY_RX))
 800c37e:	687b      	ldr	r3, [r7, #4]
 800c380:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800c382:	2b22      	cmp	r3, #34	@ 0x22
 800c384:	d002      	beq.n	800c38c <I2C_Slave_STOPF+0x234>
 800c386:	7bfb      	ldrb	r3, [r7, #15]
 800c388:	2b22      	cmp	r3, #34	@ 0x22
 800c38a:	d10d      	bne.n	800c3a8 <I2C_Slave_STOPF+0x250>
        hi2c->PreviousState = I2C_STATE_NONE;
 800c38c:	687b      	ldr	r3, [r7, #4]
 800c38e:	2200      	movs	r2, #0
 800c390:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->State = HAL_I2C_STATE_READY;
 800c392:	687b      	ldr	r3, [r7, #4]
 800c394:	2220      	movs	r2, #32
 800c396:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        hi2c->Mode = HAL_I2C_MODE_NONE;
 800c39a:	687b      	ldr	r3, [r7, #4]
 800c39c:	2200      	movs	r2, #0
 800c39e:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        HAL_I2C_SlaveRxCpltCallback(hi2c);
 800c3a2:	6878      	ldr	r0, [r7, #4]
 800c3a4:	f7fe ffea 	bl	800b37c <HAL_I2C_SlaveRxCpltCallback>
}
 800c3a8:	bf00      	nop
 800c3aa:	3710      	adds	r7, #16
 800c3ac:	46bd      	mov	sp, r7
 800c3ae:	bd80      	pop	{r7, pc}
 800c3b0:	0800ca01 	.word	0x0800ca01
 800c3b4:	ffff0000 	.word	0xffff0000

0800c3b8 <I2C_Slave_AF>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval None
  */
static void I2C_Slave_AF(I2C_HandleTypeDef *hi2c)
{
 800c3b8:	b580      	push	{r7, lr}
 800c3ba:	b084      	sub	sp, #16
 800c3bc:	af00      	add	r7, sp, #0
 800c3be:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variables to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800c3c0:	687b      	ldr	r3, [r7, #4]
 800c3c2:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c3c6:	73fb      	strb	r3, [r7, #15]
  uint32_t CurrentXferOptions       = hi2c->XferOptions;
 800c3c8:	687b      	ldr	r3, [r7, #4]
 800c3ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800c3cc:	60bb      	str	r3, [r7, #8]

  if (((CurrentXferOptions ==  I2C_FIRST_AND_LAST_FRAME) || (CurrentXferOptions == I2C_LAST_FRAME)) && \
 800c3ce:	68bb      	ldr	r3, [r7, #8]
 800c3d0:	2b08      	cmp	r3, #8
 800c3d2:	d002      	beq.n	800c3da <I2C_Slave_AF+0x22>
 800c3d4:	68bb      	ldr	r3, [r7, #8]
 800c3d6:	2b20      	cmp	r3, #32
 800c3d8:	d129      	bne.n	800c42e <I2C_Slave_AF+0x76>
 800c3da:	7bfb      	ldrb	r3, [r7, #15]
 800c3dc:	2b28      	cmp	r3, #40	@ 0x28
 800c3de:	d126      	bne.n	800c42e <I2C_Slave_AF+0x76>
      (CurrentState == HAL_I2C_STATE_LISTEN))
  {
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800c3e0:	687b      	ldr	r3, [r7, #4]
 800c3e2:	4a2e      	ldr	r2, [pc, #184]	@ (800c49c <I2C_Slave_AF+0xe4>)
 800c3e4:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Disable EVT, BUF and ERR interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800c3e6:	687b      	ldr	r3, [r7, #4]
 800c3e8:	681b      	ldr	r3, [r3, #0]
 800c3ea:	685a      	ldr	r2, [r3, #4]
 800c3ec:	687b      	ldr	r3, [r7, #4]
 800c3ee:	681b      	ldr	r3, [r3, #0]
 800c3f0:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c3f4:	605a      	str	r2, [r3, #4]

    /* Clear AF flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800c3f6:	687b      	ldr	r3, [r7, #4]
 800c3f8:	681b      	ldr	r3, [r3, #0]
 800c3fa:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 800c3fe:	615a      	str	r2, [r3, #20]

    /* Disable Acknowledge */
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800c400:	687b      	ldr	r3, [r7, #4]
 800c402:	681b      	ldr	r3, [r3, #0]
 800c404:	681a      	ldr	r2, [r3, #0]
 800c406:	687b      	ldr	r3, [r7, #4]
 800c408:	681b      	ldr	r3, [r3, #0]
 800c40a:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800c40e:	601a      	str	r2, [r3, #0]

    hi2c->PreviousState = I2C_STATE_NONE;
 800c410:	687b      	ldr	r3, [r7, #4]
 800c412:	2200      	movs	r2, #0
 800c414:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 800c416:	687b      	ldr	r3, [r7, #4]
 800c418:	2220      	movs	r2, #32
 800c41a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 800c41e:	687b      	ldr	r3, [r7, #4]
 800c420:	2200      	movs	r2, #0
 800c422:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ListenCpltCallback(hi2c);
#else
    HAL_I2C_ListenCpltCallback(hi2c);
 800c426:	6878      	ldr	r0, [r7, #4]
 800c428:	f7fe ffc0 	bl	800b3ac <HAL_I2C_ListenCpltCallback>
  {
    /* Clear AF flag only */
    /* State Listen, but XferOptions == FIRST or NEXT */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
  }
}
 800c42c:	e031      	b.n	800c492 <I2C_Slave_AF+0xda>
  else if (CurrentState == HAL_I2C_STATE_BUSY_TX)
 800c42e:	7bfb      	ldrb	r3, [r7, #15]
 800c430:	2b21      	cmp	r3, #33	@ 0x21
 800c432:	d129      	bne.n	800c488 <I2C_Slave_AF+0xd0>
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 800c434:	687b      	ldr	r3, [r7, #4]
 800c436:	4a19      	ldr	r2, [pc, #100]	@ (800c49c <I2C_Slave_AF+0xe4>)
 800c438:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 800c43a:	687b      	ldr	r3, [r7, #4]
 800c43c:	2221      	movs	r2, #33	@ 0x21
 800c43e:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 800c440:	687b      	ldr	r3, [r7, #4]
 800c442:	2220      	movs	r2, #32
 800c444:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 800c448:	687b      	ldr	r3, [r7, #4]
 800c44a:	2200      	movs	r2, #0
 800c44c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800c450:	687b      	ldr	r3, [r7, #4]
 800c452:	681b      	ldr	r3, [r3, #0]
 800c454:	685a      	ldr	r2, [r3, #4]
 800c456:	687b      	ldr	r3, [r7, #4]
 800c458:	681b      	ldr	r3, [r3, #0]
 800c45a:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c45e:	605a      	str	r2, [r3, #4]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800c460:	687b      	ldr	r3, [r7, #4]
 800c462:	681b      	ldr	r3, [r3, #0]
 800c464:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 800c468:	615a      	str	r2, [r3, #20]
    CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800c46a:	687b      	ldr	r3, [r7, #4]
 800c46c:	681b      	ldr	r3, [r3, #0]
 800c46e:	681a      	ldr	r2, [r3, #0]
 800c470:	687b      	ldr	r3, [r7, #4]
 800c472:	681b      	ldr	r3, [r3, #0]
 800c474:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800c478:	601a      	str	r2, [r3, #0]
    I2C_Flush_DR(hi2c);
 800c47a:	6878      	ldr	r0, [r7, #4]
 800c47c:	f7fe f8ff 	bl	800a67e <I2C_Flush_DR>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 800c480:	6878      	ldr	r0, [r7, #4]
 800c482:	f7fe ff71 	bl	800b368 <HAL_I2C_SlaveTxCpltCallback>
}
 800c486:	e004      	b.n	800c492 <I2C_Slave_AF+0xda>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800c488:	687b      	ldr	r3, [r7, #4]
 800c48a:	681b      	ldr	r3, [r3, #0]
 800c48c:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 800c490:	615a      	str	r2, [r3, #20]
}
 800c492:	bf00      	nop
 800c494:	3710      	adds	r7, #16
 800c496:	46bd      	mov	sp, r7
 800c498:	bd80      	pop	{r7, pc}
 800c49a:	bf00      	nop
 800c49c:	ffff0000 	.word	0xffff0000

0800c4a0 <I2C_ITError>:
  * @brief  I2C interrupts error process
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ITError(I2C_HandleTypeDef *hi2c)
{
 800c4a0:	b580      	push	{r7, lr}
 800c4a2:	b084      	sub	sp, #16
 800c4a4:	af00      	add	r7, sp, #0
 800c4a6:	6078      	str	r0, [r7, #4]
  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800c4a8:	687b      	ldr	r3, [r7, #4]
 800c4aa:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c4ae:	73fb      	strb	r3, [r7, #15]
  HAL_I2C_ModeTypeDef CurrentMode = hi2c->Mode;
 800c4b0:	687b      	ldr	r3, [r7, #4]
 800c4b2:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
 800c4b6:	73bb      	strb	r3, [r7, #14]
  uint32_t CurrentError;

  if (((CurrentMode == HAL_I2C_MODE_MASTER) || (CurrentMode == HAL_I2C_MODE_MEM)) && (CurrentState == HAL_I2C_STATE_BUSY_RX))
 800c4b8:	7bbb      	ldrb	r3, [r7, #14]
 800c4ba:	2b10      	cmp	r3, #16
 800c4bc:	d002      	beq.n	800c4c4 <I2C_ITError+0x24>
 800c4be:	7bbb      	ldrb	r3, [r7, #14]
 800c4c0:	2b40      	cmp	r3, #64	@ 0x40
 800c4c2:	d10a      	bne.n	800c4da <I2C_ITError+0x3a>
 800c4c4:	7bfb      	ldrb	r3, [r7, #15]
 800c4c6:	2b22      	cmp	r3, #34	@ 0x22
 800c4c8:	d107      	bne.n	800c4da <I2C_ITError+0x3a>
  {
    /* Disable Pos bit in I2C CR1 when error occurred in Master/Mem Receive IT Process */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 800c4ca:	687b      	ldr	r3, [r7, #4]
 800c4cc:	681b      	ldr	r3, [r3, #0]
 800c4ce:	681a      	ldr	r2, [r3, #0]
 800c4d0:	687b      	ldr	r3, [r7, #4]
 800c4d2:	681b      	ldr	r3, [r3, #0]
 800c4d4:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800c4d8:	601a      	str	r2, [r3, #0]
  }

  if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 800c4da:	7bfb      	ldrb	r3, [r7, #15]
 800c4dc:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 800c4e0:	2b28      	cmp	r3, #40	@ 0x28
 800c4e2:	d107      	bne.n	800c4f4 <I2C_ITError+0x54>
  {
    /* keep HAL_I2C_STATE_LISTEN */
    hi2c->PreviousState = I2C_STATE_NONE;
 800c4e4:	687b      	ldr	r3, [r7, #4]
 800c4e6:	2200      	movs	r2, #0
 800c4e8:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State = HAL_I2C_STATE_LISTEN;
 800c4ea:	687b      	ldr	r3, [r7, #4]
 800c4ec:	2228      	movs	r2, #40	@ 0x28
 800c4ee:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
 800c4f2:	e015      	b.n	800c520 <I2C_ITError+0x80>
  }
  else
  {
    /* If state is an abort treatment on going, don't change state */
    /* This change will be do later */
    if ((READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) != I2C_CR2_DMAEN) && (CurrentState != HAL_I2C_STATE_ABORT))
 800c4f4:	687b      	ldr	r3, [r7, #4]
 800c4f6:	681b      	ldr	r3, [r3, #0]
 800c4f8:	685b      	ldr	r3, [r3, #4]
 800c4fa:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800c4fe:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800c502:	d00a      	beq.n	800c51a <I2C_ITError+0x7a>
 800c504:	7bfb      	ldrb	r3, [r7, #15]
 800c506:	2b60      	cmp	r3, #96	@ 0x60
 800c508:	d007      	beq.n	800c51a <I2C_ITError+0x7a>
    {
      hi2c->State = HAL_I2C_STATE_READY;
 800c50a:	687b      	ldr	r3, [r7, #4]
 800c50c:	2220      	movs	r2, #32
 800c50e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800c512:	687b      	ldr	r3, [r7, #4]
 800c514:	2200      	movs	r2, #0
 800c516:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    }
    hi2c->PreviousState = I2C_STATE_NONE;
 800c51a:	687b      	ldr	r3, [r7, #4]
 800c51c:	2200      	movs	r2, #0
 800c51e:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Abort DMA transfer */
  if (READ_BIT(hi2c->Instance->CR2, I2C_CR2_DMAEN) == I2C_CR2_DMAEN)
 800c520:	687b      	ldr	r3, [r7, #4]
 800c522:	681b      	ldr	r3, [r3, #0]
 800c524:	685b      	ldr	r3, [r3, #4]
 800c526:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800c52a:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800c52e:	d162      	bne.n	800c5f6 <I2C_ITError+0x156>
  {
    hi2c->Instance->CR2 &= ~I2C_CR2_DMAEN;
 800c530:	687b      	ldr	r3, [r7, #4]
 800c532:	681b      	ldr	r3, [r3, #0]
 800c534:	685a      	ldr	r2, [r3, #4]
 800c536:	687b      	ldr	r3, [r7, #4]
 800c538:	681b      	ldr	r3, [r3, #0]
 800c53a:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 800c53e:	605a      	str	r2, [r3, #4]

    if (hi2c->hdmatx->State != HAL_DMA_STATE_READY)
 800c540:	687b      	ldr	r3, [r7, #4]
 800c542:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c544:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 800c548:	b2db      	uxtb	r3, r3
 800c54a:	2b01      	cmp	r3, #1
 800c54c:	d020      	beq.n	800c590 <I2C_ITError+0xf0>
    {
      /* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 800c54e:	687b      	ldr	r3, [r7, #4]
 800c550:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c552:	4a6a      	ldr	r2, [pc, #424]	@ (800c6fc <I2C_ITError+0x25c>)
 800c554:	651a      	str	r2, [r3, #80]	@ 0x50

      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 800c556:	687b      	ldr	r3, [r7, #4]
 800c558:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c55a:	4618      	mov	r0, r3
 800c55c:	f7fc feda 	bl	8009314 <HAL_DMA_Abort_IT>
 800c560:	4603      	mov	r3, r0
 800c562:	2b00      	cmp	r3, #0
 800c564:	f000 8089 	beq.w	800c67a <I2C_ITError+0x1da>
      {
        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);
 800c568:	687b      	ldr	r3, [r7, #4]
 800c56a:	681b      	ldr	r3, [r3, #0]
 800c56c:	681a      	ldr	r2, [r3, #0]
 800c56e:	687b      	ldr	r3, [r7, #4]
 800c570:	681b      	ldr	r3, [r3, #0]
 800c572:	f022 0201 	bic.w	r2, r2, #1
 800c576:	601a      	str	r2, [r3, #0]

        hi2c->State = HAL_I2C_STATE_READY;
 800c578:	687b      	ldr	r3, [r7, #4]
 800c57a:	2220      	movs	r2, #32
 800c57c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

        /* Call Directly XferAbortCallback function in case of error */
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 800c580:	687b      	ldr	r3, [r7, #4]
 800c582:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800c584:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c586:	687a      	ldr	r2, [r7, #4]
 800c588:	6b52      	ldr	r2, [r2, #52]	@ 0x34
 800c58a:	4610      	mov	r0, r2
 800c58c:	4798      	blx	r3
 800c58e:	e074      	b.n	800c67a <I2C_ITError+0x1da>
    }
    else
    {
      /* Set the DMA Abort callback :
      will lead to call HAL_I2C_ErrorCallback() at end of DMA abort procedure */
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 800c590:	687b      	ldr	r3, [r7, #4]
 800c592:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c594:	4a59      	ldr	r2, [pc, #356]	@ (800c6fc <I2C_ITError+0x25c>)
 800c596:	651a      	str	r2, [r3, #80]	@ 0x50

      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 800c598:	687b      	ldr	r3, [r7, #4]
 800c59a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c59c:	4618      	mov	r0, r3
 800c59e:	f7fc feb9 	bl	8009314 <HAL_DMA_Abort_IT>
 800c5a2:	4603      	mov	r3, r0
 800c5a4:	2b00      	cmp	r3, #0
 800c5a6:	d068      	beq.n	800c67a <I2C_ITError+0x1da>
      {
        /* Store Last receive data if any */
        if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800c5a8:	687b      	ldr	r3, [r7, #4]
 800c5aa:	681b      	ldr	r3, [r3, #0]
 800c5ac:	695b      	ldr	r3, [r3, #20]
 800c5ae:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800c5b2:	2b40      	cmp	r3, #64	@ 0x40
 800c5b4:	d10b      	bne.n	800c5ce <I2C_ITError+0x12e>
        {
          /* Read data from DR */
          *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800c5b6:	687b      	ldr	r3, [r7, #4]
 800c5b8:	681b      	ldr	r3, [r3, #0]
 800c5ba:	691a      	ldr	r2, [r3, #16]
 800c5bc:	687b      	ldr	r3, [r7, #4]
 800c5be:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c5c0:	b2d2      	uxtb	r2, r2
 800c5c2:	701a      	strb	r2, [r3, #0]

          /* Increment Buffer pointer */
          hi2c->pBuffPtr++;
 800c5c4:	687b      	ldr	r3, [r7, #4]
 800c5c6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c5c8:	1c5a      	adds	r2, r3, #1
 800c5ca:	687b      	ldr	r3, [r7, #4]
 800c5cc:	625a      	str	r2, [r3, #36]	@ 0x24
        }

        /* Disable I2C peripheral to prevent dummy data in buffer */
        __HAL_I2C_DISABLE(hi2c);
 800c5ce:	687b      	ldr	r3, [r7, #4]
 800c5d0:	681b      	ldr	r3, [r3, #0]
 800c5d2:	681a      	ldr	r2, [r3, #0]
 800c5d4:	687b      	ldr	r3, [r7, #4]
 800c5d6:	681b      	ldr	r3, [r3, #0]
 800c5d8:	f022 0201 	bic.w	r2, r2, #1
 800c5dc:	601a      	str	r2, [r3, #0]

        hi2c->State = HAL_I2C_STATE_READY;
 800c5de:	687b      	ldr	r3, [r7, #4]
 800c5e0:	2220      	movs	r2, #32
 800c5e2:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

        /* Call Directly hi2c->hdmarx->XferAbortCallback function in case of error */
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 800c5e6:	687b      	ldr	r3, [r7, #4]
 800c5e8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800c5ea:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800c5ec:	687a      	ldr	r2, [r7, #4]
 800c5ee:	6b92      	ldr	r2, [r2, #56]	@ 0x38
 800c5f0:	4610      	mov	r0, r2
 800c5f2:	4798      	blx	r3
 800c5f4:	e041      	b.n	800c67a <I2C_ITError+0x1da>
      }
    }
  }
  else if (hi2c->State == HAL_I2C_STATE_ABORT)
 800c5f6:	687b      	ldr	r3, [r7, #4]
 800c5f8:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c5fc:	b2db      	uxtb	r3, r3
 800c5fe:	2b60      	cmp	r3, #96	@ 0x60
 800c600:	d125      	bne.n	800c64e <I2C_ITError+0x1ae>
  {
    hi2c->State = HAL_I2C_STATE_READY;
 800c602:	687b      	ldr	r3, [r7, #4]
 800c604:	2220      	movs	r2, #32
 800c606:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800c60a:	687b      	ldr	r3, [r7, #4]
 800c60c:	2200      	movs	r2, #0
 800c60e:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800c610:	687b      	ldr	r3, [r7, #4]
 800c612:	681b      	ldr	r3, [r3, #0]
 800c614:	695b      	ldr	r3, [r3, #20]
 800c616:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800c61a:	2b40      	cmp	r3, #64	@ 0x40
 800c61c:	d10b      	bne.n	800c636 <I2C_ITError+0x196>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800c61e:	687b      	ldr	r3, [r7, #4]
 800c620:	681b      	ldr	r3, [r3, #0]
 800c622:	691a      	ldr	r2, [r3, #16]
 800c624:	687b      	ldr	r3, [r7, #4]
 800c626:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c628:	b2d2      	uxtb	r2, r2
 800c62a:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800c62c:	687b      	ldr	r3, [r7, #4]
 800c62e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c630:	1c5a      	adds	r2, r3, #1
 800c632:	687b      	ldr	r3, [r7, #4]
 800c634:	625a      	str	r2, [r3, #36]	@ 0x24
    }

    /* Disable I2C peripheral to prevent dummy data in buffer */
    __HAL_I2C_DISABLE(hi2c);
 800c636:	687b      	ldr	r3, [r7, #4]
 800c638:	681b      	ldr	r3, [r3, #0]
 800c63a:	681a      	ldr	r2, [r3, #0]
 800c63c:	687b      	ldr	r3, [r7, #4]
 800c63e:	681b      	ldr	r3, [r3, #0]
 800c640:	f022 0201 	bic.w	r2, r2, #1
 800c644:	601a      	str	r2, [r3, #0]

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
 800c646:	6878      	ldr	r0, [r7, #4]
 800c648:	f7fe fece 	bl	800b3e8 <HAL_I2C_AbortCpltCallback>
 800c64c:	e015      	b.n	800c67a <I2C_ITError+0x1da>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
  else
  {
    /* Store Last receive data if any */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET)
 800c64e:	687b      	ldr	r3, [r7, #4]
 800c650:	681b      	ldr	r3, [r3, #0]
 800c652:	695b      	ldr	r3, [r3, #20]
 800c654:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800c658:	2b40      	cmp	r3, #64	@ 0x40
 800c65a:	d10b      	bne.n	800c674 <I2C_ITError+0x1d4>
    {
      /* Read data from DR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->DR;
 800c65c:	687b      	ldr	r3, [r7, #4]
 800c65e:	681b      	ldr	r3, [r3, #0]
 800c660:	691a      	ldr	r2, [r3, #16]
 800c662:	687b      	ldr	r3, [r7, #4]
 800c664:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c666:	b2d2      	uxtb	r2, r2
 800c668:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 800c66a:	687b      	ldr	r3, [r7, #4]
 800c66c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c66e:	1c5a      	adds	r2, r3, #1
 800c670:	687b      	ldr	r3, [r7, #4]
 800c672:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Call user error callback */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
 800c674:	6878      	ldr	r0, [r7, #4]
 800c676:	f7f7 fed2 	bl	800441e <HAL_I2C_ErrorCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  /* STOP Flag is not set after a NACK reception, BusError, ArbitrationLost, OverRun */
  CurrentError = hi2c->ErrorCode;
 800c67a:	687b      	ldr	r3, [r7, #4]
 800c67c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c67e:	60bb      	str	r3, [r7, #8]

  if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
 800c680:	68bb      	ldr	r3, [r7, #8]
 800c682:	f003 0301 	and.w	r3, r3, #1
 800c686:	2b00      	cmp	r3, #0
 800c688:	d10e      	bne.n	800c6a8 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
 800c68a:	68bb      	ldr	r3, [r7, #8]
 800c68c:	f003 0302 	and.w	r3, r3, #2
  if (((CurrentError & HAL_I2C_ERROR_BERR) == HAL_I2C_ERROR_BERR) || \
 800c690:	2b00      	cmp	r3, #0
 800c692:	d109      	bne.n	800c6a8 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
 800c694:	68bb      	ldr	r3, [r7, #8]
 800c696:	f003 0304 	and.w	r3, r3, #4
      ((CurrentError & HAL_I2C_ERROR_ARLO) == HAL_I2C_ERROR_ARLO) || \
 800c69a:	2b00      	cmp	r3, #0
 800c69c:	d104      	bne.n	800c6a8 <I2C_ITError+0x208>
      ((CurrentError & HAL_I2C_ERROR_OVR) == HAL_I2C_ERROR_OVR))
 800c69e:	68bb      	ldr	r3, [r7, #8]
 800c6a0:	f003 0308 	and.w	r3, r3, #8
      ((CurrentError & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF)     || \
 800c6a4:	2b00      	cmp	r3, #0
 800c6a6:	d007      	beq.n	800c6b8 <I2C_ITError+0x218>
  {
    /* Disable EVT, BUF and ERR interrupt */
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 800c6a8:	687b      	ldr	r3, [r7, #4]
 800c6aa:	681b      	ldr	r3, [r3, #0]
 800c6ac:	685a      	ldr	r2, [r3, #4]
 800c6ae:	687b      	ldr	r3, [r7, #4]
 800c6b0:	681b      	ldr	r3, [r3, #0]
 800c6b2:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 800c6b6:	605a      	str	r2, [r3, #4]
  }

  /* So may inform upper layer that listen phase is stopped */
  /* during NACK error treatment */
  CurrentState = hi2c->State;
 800c6b8:	687b      	ldr	r3, [r7, #4]
 800c6ba:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800c6be:	73fb      	strb	r3, [r7, #15]
  if (((hi2c->ErrorCode & HAL_I2C_ERROR_AF) == HAL_I2C_ERROR_AF) && (CurrentState == HAL_I2C_STATE_LISTEN))
 800c6c0:	687b      	ldr	r3, [r7, #4]
 800c6c2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c6c4:	f003 0304 	and.w	r3, r3, #4
 800c6c8:	2b04      	cmp	r3, #4
 800c6ca:	d113      	bne.n	800c6f4 <I2C_ITError+0x254>
 800c6cc:	7bfb      	ldrb	r3, [r7, #15]
 800c6ce:	2b28      	cmp	r3, #40	@ 0x28
 800c6d0:	d110      	bne.n	800c6f4 <I2C_ITError+0x254>
  {
    hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 800c6d2:	687b      	ldr	r3, [r7, #4]
 800c6d4:	4a0a      	ldr	r2, [pc, #40]	@ (800c700 <I2C_ITError+0x260>)
 800c6d6:	62da      	str	r2, [r3, #44]	@ 0x2c
    hi2c->PreviousState = I2C_STATE_NONE;
 800c6d8:	687b      	ldr	r3, [r7, #4]
 800c6da:	2200      	movs	r2, #0
 800c6dc:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State         = HAL_I2C_STATE_READY;
 800c6de:	687b      	ldr	r3, [r7, #4]
 800c6e0:	2220      	movs	r2, #32
 800c6e2:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 800c6e6:	687b      	ldr	r3, [r7, #4]
 800c6e8:	2200      	movs	r2, #0
 800c6ea:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e

    /* Call the Listen Complete callback, to inform upper layer of the end of Listen usecase */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->ListenCpltCallback(hi2c);
#else
    HAL_I2C_ListenCpltCallback(hi2c);
 800c6ee:	6878      	ldr	r0, [r7, #4]
 800c6f0:	f7fe fe5c 	bl	800b3ac <HAL_I2C_ListenCpltCallback>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 800c6f4:	bf00      	nop
 800c6f6:	3710      	adds	r7, #16
 800c6f8:	46bd      	mov	sp, r7
 800c6fa:	bd80      	pop	{r7, pc}
 800c6fc:	0800ca01 	.word	0x0800ca01
 800c700:	ffff0000 	.word	0xffff0000

0800c704 <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 800c704:	b580      	push	{r7, lr}
 800c706:	b088      	sub	sp, #32
 800c708:	af02      	add	r7, sp, #8
 800c70a:	60f8      	str	r0, [r7, #12]
 800c70c:	4608      	mov	r0, r1
 800c70e:	4611      	mov	r1, r2
 800c710:	461a      	mov	r2, r3
 800c712:	4603      	mov	r3, r0
 800c714:	817b      	strh	r3, [r7, #10]
 800c716:	460b      	mov	r3, r1
 800c718:	813b      	strh	r3, [r7, #8]
 800c71a:	4613      	mov	r3, r2
 800c71c:	80fb      	strh	r3, [r7, #6]
  /* Generate Start */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 800c71e:	68fb      	ldr	r3, [r7, #12]
 800c720:	681b      	ldr	r3, [r3, #0]
 800c722:	681a      	ldr	r2, [r3, #0]
 800c724:	68fb      	ldr	r3, [r7, #12]
 800c726:	681b      	ldr	r3, [r3, #0]
 800c728:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800c72c:	601a      	str	r2, [r3, #0]

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 800c72e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c730:	9300      	str	r3, [sp, #0]
 800c732:	6a3b      	ldr	r3, [r7, #32]
 800c734:	2200      	movs	r2, #0
 800c736:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 800c73a:	68f8      	ldr	r0, [r7, #12]
 800c73c:	f000 fa08 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800c740:	4603      	mov	r3, r0
 800c742:	2b00      	cmp	r3, #0
 800c744:	d00d      	beq.n	800c762 <I2C_RequestMemoryWrite+0x5e>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 800c746:	68fb      	ldr	r3, [r7, #12]
 800c748:	681b      	ldr	r3, [r3, #0]
 800c74a:	681b      	ldr	r3, [r3, #0]
 800c74c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c750:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c754:	d103      	bne.n	800c75e <I2C_RequestMemoryWrite+0x5a>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 800c756:	68fb      	ldr	r3, [r7, #12]
 800c758:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800c75c:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 800c75e:	2303      	movs	r3, #3
 800c760:	e05f      	b.n	800c822 <I2C_RequestMemoryWrite+0x11e>
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 800c762:	897b      	ldrh	r3, [r7, #10]
 800c764:	b2db      	uxtb	r3, r3
 800c766:	461a      	mov	r2, r3
 800c768:	68fb      	ldr	r3, [r7, #12]
 800c76a:	681b      	ldr	r3, [r3, #0]
 800c76c:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 800c770:	611a      	str	r2, [r3, #16]

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 800c772:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c774:	6a3a      	ldr	r2, [r7, #32]
 800c776:	492d      	ldr	r1, [pc, #180]	@ (800c82c <I2C_RequestMemoryWrite+0x128>)
 800c778:	68f8      	ldr	r0, [r7, #12]
 800c77a:	f000 fa63 	bl	800cc44 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 800c77e:	4603      	mov	r3, r0
 800c780:	2b00      	cmp	r3, #0
 800c782:	d001      	beq.n	800c788 <I2C_RequestMemoryWrite+0x84>
  {
    return HAL_ERROR;
 800c784:	2301      	movs	r3, #1
 800c786:	e04c      	b.n	800c822 <I2C_RequestMemoryWrite+0x11e>
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800c788:	2300      	movs	r3, #0
 800c78a:	617b      	str	r3, [r7, #20]
 800c78c:	68fb      	ldr	r3, [r7, #12]
 800c78e:	681b      	ldr	r3, [r3, #0]
 800c790:	695b      	ldr	r3, [r3, #20]
 800c792:	617b      	str	r3, [r7, #20]
 800c794:	68fb      	ldr	r3, [r7, #12]
 800c796:	681b      	ldr	r3, [r3, #0]
 800c798:	699b      	ldr	r3, [r3, #24]
 800c79a:	617b      	str	r3, [r7, #20]
 800c79c:	697b      	ldr	r3, [r7, #20]

  /* Wait until TXE flag is set */
  if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800c79e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800c7a0:	6a39      	ldr	r1, [r7, #32]
 800c7a2:	68f8      	ldr	r0, [r7, #12]
 800c7a4:	f000 faee 	bl	800cd84 <I2C_WaitOnTXEFlagUntilTimeout>
 800c7a8:	4603      	mov	r3, r0
 800c7aa:	2b00      	cmp	r3, #0
 800c7ac:	d00d      	beq.n	800c7ca <I2C_RequestMemoryWrite+0xc6>
  {
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800c7ae:	68fb      	ldr	r3, [r7, #12]
 800c7b0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c7b2:	2b04      	cmp	r3, #4
 800c7b4:	d107      	bne.n	800c7c6 <I2C_RequestMemoryWrite+0xc2>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800c7b6:	68fb      	ldr	r3, [r7, #12]
 800c7b8:	681b      	ldr	r3, [r3, #0]
 800c7ba:	681a      	ldr	r2, [r3, #0]
 800c7bc:	68fb      	ldr	r3, [r7, #12]
 800c7be:	681b      	ldr	r3, [r3, #0]
 800c7c0:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800c7c4:	601a      	str	r2, [r3, #0]
    }
    return HAL_ERROR;
 800c7c6:	2301      	movs	r3, #1
 800c7c8:	e02b      	b.n	800c822 <I2C_RequestMemoryWrite+0x11e>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800c7ca:	88fb      	ldrh	r3, [r7, #6]
 800c7cc:	2b01      	cmp	r3, #1
 800c7ce:	d105      	bne.n	800c7dc <I2C_RequestMemoryWrite+0xd8>
  {
    /* Send Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 800c7d0:	893b      	ldrh	r3, [r7, #8]
 800c7d2:	b2da      	uxtb	r2, r3
 800c7d4:	68fb      	ldr	r3, [r7, #12]
 800c7d6:	681b      	ldr	r3, [r3, #0]
 800c7d8:	611a      	str	r2, [r3, #16]
 800c7da:	e021      	b.n	800c820 <I2C_RequestMemoryWrite+0x11c>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 800c7dc:	893b      	ldrh	r3, [r7, #8]
 800c7de:	0a1b      	lsrs	r3, r3, #8
 800c7e0:	b29b      	uxth	r3, r3
 800c7e2:	b2da      	uxtb	r2, r3
 800c7e4:	68fb      	ldr	r3, [r7, #12]
 800c7e6:	681b      	ldr	r3, [r3, #0]
 800c7e8:	611a      	str	r2, [r3, #16]

    /* Wait until TXE flag is set */
    if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800c7ea:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800c7ec:	6a39      	ldr	r1, [r7, #32]
 800c7ee:	68f8      	ldr	r0, [r7, #12]
 800c7f0:	f000 fac8 	bl	800cd84 <I2C_WaitOnTXEFlagUntilTimeout>
 800c7f4:	4603      	mov	r3, r0
 800c7f6:	2b00      	cmp	r3, #0
 800c7f8:	d00d      	beq.n	800c816 <I2C_RequestMemoryWrite+0x112>
    {
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800c7fa:	68fb      	ldr	r3, [r7, #12]
 800c7fc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c7fe:	2b04      	cmp	r3, #4
 800c800:	d107      	bne.n	800c812 <I2C_RequestMemoryWrite+0x10e>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800c802:	68fb      	ldr	r3, [r7, #12]
 800c804:	681b      	ldr	r3, [r3, #0]
 800c806:	681a      	ldr	r2, [r3, #0]
 800c808:	68fb      	ldr	r3, [r7, #12]
 800c80a:	681b      	ldr	r3, [r3, #0]
 800c80c:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800c810:	601a      	str	r2, [r3, #0]
      }
      return HAL_ERROR;
 800c812:	2301      	movs	r3, #1
 800c814:	e005      	b.n	800c822 <I2C_RequestMemoryWrite+0x11e>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 800c816:	893b      	ldrh	r3, [r7, #8]
 800c818:	b2da      	uxtb	r2, r3
 800c81a:	68fb      	ldr	r3, [r7, #12]
 800c81c:	681b      	ldr	r3, [r3, #0]
 800c81e:	611a      	str	r2, [r3, #16]
  }

  return HAL_OK;
 800c820:	2300      	movs	r3, #0
}
 800c822:	4618      	mov	r0, r3
 800c824:	3718      	adds	r7, #24
 800c826:	46bd      	mov	sp, r7
 800c828:	bd80      	pop	{r7, pc}
 800c82a:	bf00      	nop
 800c82c:	00010002 	.word	0x00010002

0800c830 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 800c830:	b580      	push	{r7, lr}
 800c832:	b088      	sub	sp, #32
 800c834:	af02      	add	r7, sp, #8
 800c836:	60f8      	str	r0, [r7, #12]
 800c838:	4608      	mov	r0, r1
 800c83a:	4611      	mov	r1, r2
 800c83c:	461a      	mov	r2, r3
 800c83e:	4603      	mov	r3, r0
 800c840:	817b      	strh	r3, [r7, #10]
 800c842:	460b      	mov	r3, r1
 800c844:	813b      	strh	r3, [r7, #8]
 800c846:	4613      	mov	r3, r2
 800c848:	80fb      	strh	r3, [r7, #6]
  /* Enable Acknowledge */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800c84a:	68fb      	ldr	r3, [r7, #12]
 800c84c:	681b      	ldr	r3, [r3, #0]
 800c84e:	681a      	ldr	r2, [r3, #0]
 800c850:	68fb      	ldr	r3, [r7, #12]
 800c852:	681b      	ldr	r3, [r3, #0]
 800c854:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800c858:	601a      	str	r2, [r3, #0]

  /* Generate Start */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 800c85a:	68fb      	ldr	r3, [r7, #12]
 800c85c:	681b      	ldr	r3, [r3, #0]
 800c85e:	681a      	ldr	r2, [r3, #0]
 800c860:	68fb      	ldr	r3, [r7, #12]
 800c862:	681b      	ldr	r3, [r3, #0]
 800c864:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800c868:	601a      	str	r2, [r3, #0]

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 800c86a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c86c:	9300      	str	r3, [sp, #0]
 800c86e:	6a3b      	ldr	r3, [r7, #32]
 800c870:	2200      	movs	r2, #0
 800c872:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 800c876:	68f8      	ldr	r0, [r7, #12]
 800c878:	f000 f96a 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800c87c:	4603      	mov	r3, r0
 800c87e:	2b00      	cmp	r3, #0
 800c880:	d00d      	beq.n	800c89e <I2C_RequestMemoryRead+0x6e>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 800c882:	68fb      	ldr	r3, [r7, #12]
 800c884:	681b      	ldr	r3, [r3, #0]
 800c886:	681b      	ldr	r3, [r3, #0]
 800c888:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c88c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c890:	d103      	bne.n	800c89a <I2C_RequestMemoryRead+0x6a>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 800c892:	68fb      	ldr	r3, [r7, #12]
 800c894:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800c898:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 800c89a:	2303      	movs	r3, #3
 800c89c:	e0aa      	b.n	800c9f4 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 800c89e:	897b      	ldrh	r3, [r7, #10]
 800c8a0:	b2db      	uxtb	r3, r3
 800c8a2:	461a      	mov	r2, r3
 800c8a4:	68fb      	ldr	r3, [r7, #12]
 800c8a6:	681b      	ldr	r3, [r3, #0]
 800c8a8:	f002 02fe 	and.w	r2, r2, #254	@ 0xfe
 800c8ac:	611a      	str	r2, [r3, #16]

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 800c8ae:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c8b0:	6a3a      	ldr	r2, [r7, #32]
 800c8b2:	4952      	ldr	r1, [pc, #328]	@ (800c9fc <I2C_RequestMemoryRead+0x1cc>)
 800c8b4:	68f8      	ldr	r0, [r7, #12]
 800c8b6:	f000 f9c5 	bl	800cc44 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 800c8ba:	4603      	mov	r3, r0
 800c8bc:	2b00      	cmp	r3, #0
 800c8be:	d001      	beq.n	800c8c4 <I2C_RequestMemoryRead+0x94>
  {
    return HAL_ERROR;
 800c8c0:	2301      	movs	r3, #1
 800c8c2:	e097      	b.n	800c9f4 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800c8c4:	2300      	movs	r3, #0
 800c8c6:	617b      	str	r3, [r7, #20]
 800c8c8:	68fb      	ldr	r3, [r7, #12]
 800c8ca:	681b      	ldr	r3, [r3, #0]
 800c8cc:	695b      	ldr	r3, [r3, #20]
 800c8ce:	617b      	str	r3, [r7, #20]
 800c8d0:	68fb      	ldr	r3, [r7, #12]
 800c8d2:	681b      	ldr	r3, [r3, #0]
 800c8d4:	699b      	ldr	r3, [r3, #24]
 800c8d6:	617b      	str	r3, [r7, #20]
 800c8d8:	697b      	ldr	r3, [r7, #20]

  /* Wait until TXE flag is set */
  if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800c8da:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800c8dc:	6a39      	ldr	r1, [r7, #32]
 800c8de:	68f8      	ldr	r0, [r7, #12]
 800c8e0:	f000 fa50 	bl	800cd84 <I2C_WaitOnTXEFlagUntilTimeout>
 800c8e4:	4603      	mov	r3, r0
 800c8e6:	2b00      	cmp	r3, #0
 800c8e8:	d00d      	beq.n	800c906 <I2C_RequestMemoryRead+0xd6>
  {
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800c8ea:	68fb      	ldr	r3, [r7, #12]
 800c8ec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c8ee:	2b04      	cmp	r3, #4
 800c8f0:	d107      	bne.n	800c902 <I2C_RequestMemoryRead+0xd2>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800c8f2:	68fb      	ldr	r3, [r7, #12]
 800c8f4:	681b      	ldr	r3, [r3, #0]
 800c8f6:	681a      	ldr	r2, [r3, #0]
 800c8f8:	68fb      	ldr	r3, [r7, #12]
 800c8fa:	681b      	ldr	r3, [r3, #0]
 800c8fc:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800c900:	601a      	str	r2, [r3, #0]
    }
    return HAL_ERROR;
 800c902:	2301      	movs	r3, #1
 800c904:	e076      	b.n	800c9f4 <I2C_RequestMemoryRead+0x1c4>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800c906:	88fb      	ldrh	r3, [r7, #6]
 800c908:	2b01      	cmp	r3, #1
 800c90a:	d105      	bne.n	800c918 <I2C_RequestMemoryRead+0xe8>
  {
    /* Send Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 800c90c:	893b      	ldrh	r3, [r7, #8]
 800c90e:	b2da      	uxtb	r2, r3
 800c910:	68fb      	ldr	r3, [r7, #12]
 800c912:	681b      	ldr	r3, [r3, #0]
 800c914:	611a      	str	r2, [r3, #16]
 800c916:	e021      	b.n	800c95c <I2C_RequestMemoryRead+0x12c>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 800c918:	893b      	ldrh	r3, [r7, #8]
 800c91a:	0a1b      	lsrs	r3, r3, #8
 800c91c:	b29b      	uxth	r3, r3
 800c91e:	b2da      	uxtb	r2, r3
 800c920:	68fb      	ldr	r3, [r7, #12]
 800c922:	681b      	ldr	r3, [r3, #0]
 800c924:	611a      	str	r2, [r3, #16]

    /* Wait until TXE flag is set */
    if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800c926:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800c928:	6a39      	ldr	r1, [r7, #32]
 800c92a:	68f8      	ldr	r0, [r7, #12]
 800c92c:	f000 fa2a 	bl	800cd84 <I2C_WaitOnTXEFlagUntilTimeout>
 800c930:	4603      	mov	r3, r0
 800c932:	2b00      	cmp	r3, #0
 800c934:	d00d      	beq.n	800c952 <I2C_RequestMemoryRead+0x122>
    {
      if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800c936:	68fb      	ldr	r3, [r7, #12]
 800c938:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c93a:	2b04      	cmp	r3, #4
 800c93c:	d107      	bne.n	800c94e <I2C_RequestMemoryRead+0x11e>
      {
        /* Generate Stop */
        SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800c93e:	68fb      	ldr	r3, [r7, #12]
 800c940:	681b      	ldr	r3, [r3, #0]
 800c942:	681a      	ldr	r2, [r3, #0]
 800c944:	68fb      	ldr	r3, [r7, #12]
 800c946:	681b      	ldr	r3, [r3, #0]
 800c948:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800c94c:	601a      	str	r2, [r3, #0]
      }
      return HAL_ERROR;
 800c94e:	2301      	movs	r3, #1
 800c950:	e050      	b.n	800c9f4 <I2C_RequestMemoryRead+0x1c4>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 800c952:	893b      	ldrh	r3, [r7, #8]
 800c954:	b2da      	uxtb	r2, r3
 800c956:	68fb      	ldr	r3, [r7, #12]
 800c958:	681b      	ldr	r3, [r3, #0]
 800c95a:	611a      	str	r2, [r3, #16]
  }

  /* Wait until TXE flag is set */
  if (I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800c95c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800c95e:	6a39      	ldr	r1, [r7, #32]
 800c960:	68f8      	ldr	r0, [r7, #12]
 800c962:	f000 fa0f 	bl	800cd84 <I2C_WaitOnTXEFlagUntilTimeout>
 800c966:	4603      	mov	r3, r0
 800c968:	2b00      	cmp	r3, #0
 800c96a:	d00d      	beq.n	800c988 <I2C_RequestMemoryRead+0x158>
  {
    if (hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800c96c:	68fb      	ldr	r3, [r7, #12]
 800c96e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800c970:	2b04      	cmp	r3, #4
 800c972:	d107      	bne.n	800c984 <I2C_RequestMemoryRead+0x154>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800c974:	68fb      	ldr	r3, [r7, #12]
 800c976:	681b      	ldr	r3, [r3, #0]
 800c978:	681a      	ldr	r2, [r3, #0]
 800c97a:	68fb      	ldr	r3, [r7, #12]
 800c97c:	681b      	ldr	r3, [r3, #0]
 800c97e:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800c982:	601a      	str	r2, [r3, #0]
    }
    return HAL_ERROR;
 800c984:	2301      	movs	r3, #1
 800c986:	e035      	b.n	800c9f4 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Generate Restart */
  SET_BIT(hi2c->Instance->CR1, I2C_CR1_START);
 800c988:	68fb      	ldr	r3, [r7, #12]
 800c98a:	681b      	ldr	r3, [r3, #0]
 800c98c:	681a      	ldr	r2, [r3, #0]
 800c98e:	68fb      	ldr	r3, [r7, #12]
 800c990:	681b      	ldr	r3, [r3, #0]
 800c992:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800c996:	601a      	str	r2, [r3, #0]

  /* Wait until SB flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 800c998:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c99a:	9300      	str	r3, [sp, #0]
 800c99c:	6a3b      	ldr	r3, [r7, #32]
 800c99e:	2200      	movs	r2, #0
 800c9a0:	f04f 1101 	mov.w	r1, #65537	@ 0x10001
 800c9a4:	68f8      	ldr	r0, [r7, #12]
 800c9a6:	f000 f8d3 	bl	800cb50 <I2C_WaitOnFlagUntilTimeout>
 800c9aa:	4603      	mov	r3, r0
 800c9ac:	2b00      	cmp	r3, #0
 800c9ae:	d00d      	beq.n	800c9cc <I2C_RequestMemoryRead+0x19c>
  {
    if (READ_BIT(hi2c->Instance->CR1, I2C_CR1_START) == I2C_CR1_START)
 800c9b0:	68fb      	ldr	r3, [r7, #12]
 800c9b2:	681b      	ldr	r3, [r3, #0]
 800c9b4:	681b      	ldr	r3, [r3, #0]
 800c9b6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800c9ba:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800c9be:	d103      	bne.n	800c9c8 <I2C_RequestMemoryRead+0x198>
    {
      hi2c->ErrorCode = HAL_I2C_WRONG_START;
 800c9c0:	68fb      	ldr	r3, [r7, #12]
 800c9c2:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800c9c6:	641a      	str	r2, [r3, #64]	@ 0x40
    }
    return HAL_TIMEOUT;
 800c9c8:	2303      	movs	r3, #3
 800c9ca:	e013      	b.n	800c9f4 <I2C_RequestMemoryRead+0x1c4>
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
 800c9cc:	897b      	ldrh	r3, [r7, #10]
 800c9ce:	b2db      	uxtb	r3, r3
 800c9d0:	f043 0301 	orr.w	r3, r3, #1
 800c9d4:	b2da      	uxtb	r2, r3
 800c9d6:	68fb      	ldr	r3, [r7, #12]
 800c9d8:	681b      	ldr	r3, [r3, #0]
 800c9da:	611a      	str	r2, [r3, #16]

  /* Wait until ADDR flag is set */
  if (I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 800c9dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c9de:	6a3a      	ldr	r2, [r7, #32]
 800c9e0:	4906      	ldr	r1, [pc, #24]	@ (800c9fc <I2C_RequestMemoryRead+0x1cc>)
 800c9e2:	68f8      	ldr	r0, [r7, #12]
 800c9e4:	f000 f92e 	bl	800cc44 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 800c9e8:	4603      	mov	r3, r0
 800c9ea:	2b00      	cmp	r3, #0
 800c9ec:	d001      	beq.n	800c9f2 <I2C_RequestMemoryRead+0x1c2>
  {
    return HAL_ERROR;
 800c9ee:	2301      	movs	r3, #1
 800c9f0:	e000      	b.n	800c9f4 <I2C_RequestMemoryRead+0x1c4>
  }

  return HAL_OK;
 800c9f2:	2300      	movs	r3, #0
}
 800c9f4:	4618      	mov	r0, r3
 800c9f6:	3718      	adds	r7, #24
 800c9f8:	46bd      	mov	sp, r7
 800c9fa:	bd80      	pop	{r7, pc}
 800c9fc:	00010002 	.word	0x00010002

0800ca00 <I2C_DMAAbort>:
  *        (To be called at end of DMA Abort procedure).
  * @param hdma DMA handle.
  * @retval None
  */
static void I2C_DMAAbort(DMA_HandleTypeDef *hdma)
{
 800ca00:	b580      	push	{r7, lr}
 800ca02:	b086      	sub	sp, #24
 800ca04:	af00      	add	r7, sp, #0
 800ca06:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 800ca08:	2300      	movs	r3, #0
 800ca0a:	60fb      	str	r3, [r7, #12]
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 800ca0c:	687b      	ldr	r3, [r7, #4]
 800ca0e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800ca10:	617b      	str	r3, [r7, #20]

  /* Declaration of temporary variable to prevent undefined behavior of volatile usage */
  HAL_I2C_StateTypeDef CurrentState = hi2c->State;
 800ca12:	697b      	ldr	r3, [r7, #20]
 800ca14:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800ca18:	74fb      	strb	r3, [r7, #19]

  /* During abort treatment, check that there is no pending STOP request */
  /* Wait until STOP flag is reset */
  count = I2C_TIMEOUT_FLAG * (SystemCoreClock / 25U / 1000U);
 800ca1a:	4b4b      	ldr	r3, [pc, #300]	@ (800cb48 <I2C_DMAAbort+0x148>)
 800ca1c:	681b      	ldr	r3, [r3, #0]
 800ca1e:	08db      	lsrs	r3, r3, #3
 800ca20:	4a4a      	ldr	r2, [pc, #296]	@ (800cb4c <I2C_DMAAbort+0x14c>)
 800ca22:	fba2 2303 	umull	r2, r3, r2, r3
 800ca26:	0a1a      	lsrs	r2, r3, #8
 800ca28:	4613      	mov	r3, r2
 800ca2a:	009b      	lsls	r3, r3, #2
 800ca2c:	4413      	add	r3, r2
 800ca2e:	00da      	lsls	r2, r3, #3
 800ca30:	1ad3      	subs	r3, r2, r3
 800ca32:	60fb      	str	r3, [r7, #12]
  do
  {
    if (count == 0U)
 800ca34:	68fb      	ldr	r3, [r7, #12]
 800ca36:	2b00      	cmp	r3, #0
 800ca38:	d106      	bne.n	800ca48 <I2C_DMAAbort+0x48>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800ca3a:	697b      	ldr	r3, [r7, #20]
 800ca3c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ca3e:	f043 0220 	orr.w	r2, r3, #32
 800ca42:	697b      	ldr	r3, [r7, #20]
 800ca44:	641a      	str	r2, [r3, #64]	@ 0x40
      break;
 800ca46:	e00a      	b.n	800ca5e <I2C_DMAAbort+0x5e>
    }
    count--;
 800ca48:	68fb      	ldr	r3, [r7, #12]
 800ca4a:	3b01      	subs	r3, #1
 800ca4c:	60fb      	str	r3, [r7, #12]
  }
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 800ca4e:	697b      	ldr	r3, [r7, #20]
 800ca50:	681b      	ldr	r3, [r3, #0]
 800ca52:	681b      	ldr	r3, [r3, #0]
 800ca54:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800ca58:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800ca5c:	d0ea      	beq.n	800ca34 <I2C_DMAAbort+0x34>

  /* Clear Complete callback */
  if (hi2c->hdmatx != NULL)
 800ca5e:	697b      	ldr	r3, [r7, #20]
 800ca60:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800ca62:	2b00      	cmp	r3, #0
 800ca64:	d003      	beq.n	800ca6e <I2C_DMAAbort+0x6e>
  {
    hi2c->hdmatx->XferCpltCallback = NULL;
 800ca66:	697b      	ldr	r3, [r7, #20]
 800ca68:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800ca6a:	2200      	movs	r2, #0
 800ca6c:	63da      	str	r2, [r3, #60]	@ 0x3c
  }
  if (hi2c->hdmarx != NULL)
 800ca6e:	697b      	ldr	r3, [r7, #20]
 800ca70:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800ca72:	2b00      	cmp	r3, #0
 800ca74:	d003      	beq.n	800ca7e <I2C_DMAAbort+0x7e>
  {
    hi2c->hdmarx->XferCpltCallback = NULL;
 800ca76:	697b      	ldr	r3, [r7, #20]
 800ca78:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800ca7a:	2200      	movs	r2, #0
 800ca7c:	63da      	str	r2, [r3, #60]	@ 0x3c
  }

  /* Disable Acknowledge */
  CLEAR_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800ca7e:	697b      	ldr	r3, [r7, #20]
 800ca80:	681b      	ldr	r3, [r3, #0]
 800ca82:	681a      	ldr	r2, [r3, #0]
 800ca84:	697b      	ldr	r3, [r7, #20]
 800ca86:	681b      	ldr	r3, [r3, #0]
 800ca88:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 800ca8c:	601a      	str	r2, [r3, #0]

  hi2c->XferCount = 0U;
 800ca8e:	697b      	ldr	r3, [r7, #20]
 800ca90:	2200      	movs	r2, #0
 800ca92:	855a      	strh	r2, [r3, #42]	@ 0x2a

  /* Reset XferAbortCallback */
  if (hi2c->hdmatx != NULL)
 800ca94:	697b      	ldr	r3, [r7, #20]
 800ca96:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800ca98:	2b00      	cmp	r3, #0
 800ca9a:	d003      	beq.n	800caa4 <I2C_DMAAbort+0xa4>
  {
    hi2c->hdmatx->XferAbortCallback = NULL;
 800ca9c:	697b      	ldr	r3, [r7, #20]
 800ca9e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800caa0:	2200      	movs	r2, #0
 800caa2:	651a      	str	r2, [r3, #80]	@ 0x50
  }
  if (hi2c->hdmarx != NULL)
 800caa4:	697b      	ldr	r3, [r7, #20]
 800caa6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800caa8:	2b00      	cmp	r3, #0
 800caaa:	d003      	beq.n	800cab4 <I2C_DMAAbort+0xb4>
  {
    hi2c->hdmarx->XferAbortCallback = NULL;
 800caac:	697b      	ldr	r3, [r7, #20]
 800caae:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800cab0:	2200      	movs	r2, #0
 800cab2:	651a      	str	r2, [r3, #80]	@ 0x50
  }

  /* Disable I2C peripheral to prevent dummy data in buffer */
  __HAL_I2C_DISABLE(hi2c);
 800cab4:	697b      	ldr	r3, [r7, #20]
 800cab6:	681b      	ldr	r3, [r3, #0]
 800cab8:	681a      	ldr	r2, [r3, #0]
 800caba:	697b      	ldr	r3, [r7, #20]
 800cabc:	681b      	ldr	r3, [r3, #0]
 800cabe:	f022 0201 	bic.w	r2, r2, #1
 800cac2:	601a      	str	r2, [r3, #0]

  /* Check if come from abort from user */
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 800cac4:	697b      	ldr	r3, [r7, #20]
 800cac6:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800caca:	b2db      	uxtb	r3, r3
 800cacc:	2b60      	cmp	r3, #96	@ 0x60
 800cace:	d10e      	bne.n	800caee <I2C_DMAAbort+0xee>
  {
    hi2c->State         = HAL_I2C_STATE_READY;
 800cad0:	697b      	ldr	r3, [r7, #20]
 800cad2:	2220      	movs	r2, #32
 800cad4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode          = HAL_I2C_MODE_NONE;
 800cad8:	697b      	ldr	r3, [r7, #20]
 800cada:	2200      	movs	r2, #0
 800cadc:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode     = HAL_I2C_ERROR_NONE;
 800cae0:	697b      	ldr	r3, [r7, #20]
 800cae2:	2200      	movs	r2, #0
 800cae4:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Call the corresponding callback to inform upper layer of End of Transfer */
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 1)
    hi2c->AbortCpltCallback(hi2c);
#else
    HAL_I2C_AbortCpltCallback(hi2c);
 800cae6:	6978      	ldr	r0, [r7, #20]
 800cae8:	f7fe fc7e 	bl	800b3e8 <HAL_I2C_AbortCpltCallback>
    hi2c->ErrorCallback(hi2c);
#else
    HAL_I2C_ErrorCallback(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }
}
 800caec:	e027      	b.n	800cb3e <I2C_DMAAbort+0x13e>
    if (((uint32_t)CurrentState & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 800caee:	7cfb      	ldrb	r3, [r7, #19]
 800caf0:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 800caf4:	2b28      	cmp	r3, #40	@ 0x28
 800caf6:	d117      	bne.n	800cb28 <I2C_DMAAbort+0x128>
      __HAL_I2C_ENABLE(hi2c);
 800caf8:	697b      	ldr	r3, [r7, #20]
 800cafa:	681b      	ldr	r3, [r3, #0]
 800cafc:	681a      	ldr	r2, [r3, #0]
 800cafe:	697b      	ldr	r3, [r7, #20]
 800cb00:	681b      	ldr	r3, [r3, #0]
 800cb02:	f042 0201 	orr.w	r2, r2, #1
 800cb06:	601a      	str	r2, [r3, #0]
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_ACK);
 800cb08:	697b      	ldr	r3, [r7, #20]
 800cb0a:	681b      	ldr	r3, [r3, #0]
 800cb0c:	681a      	ldr	r2, [r3, #0]
 800cb0e:	697b      	ldr	r3, [r7, #20]
 800cb10:	681b      	ldr	r3, [r3, #0]
 800cb12:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800cb16:	601a      	str	r2, [r3, #0]
      hi2c->PreviousState = I2C_STATE_NONE;
 800cb18:	697b      	ldr	r3, [r7, #20]
 800cb1a:	2200      	movs	r2, #0
 800cb1c:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State = HAL_I2C_STATE_LISTEN;
 800cb1e:	697b      	ldr	r3, [r7, #20]
 800cb20:	2228      	movs	r2, #40	@ 0x28
 800cb22:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
 800cb26:	e007      	b.n	800cb38 <I2C_DMAAbort+0x138>
      hi2c->State = HAL_I2C_STATE_READY;
 800cb28:	697b      	ldr	r3, [r7, #20]
 800cb2a:	2220      	movs	r2, #32
 800cb2c:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800cb30:	697b      	ldr	r3, [r7, #20]
 800cb32:	2200      	movs	r2, #0
 800cb34:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    HAL_I2C_ErrorCallback(hi2c);
 800cb38:	6978      	ldr	r0, [r7, #20]
 800cb3a:	f7f7 fc70 	bl	800441e <HAL_I2C_ErrorCallback>
}
 800cb3e:	bf00      	nop
 800cb40:	3718      	adds	r7, #24
 800cb42:	46bd      	mov	sp, r7
 800cb44:	bd80      	pop	{r7, pc}
 800cb46:	bf00      	nop
 800cb48:	20000040 	.word	0x20000040
 800cb4c:	14f8b589 	.word	0x14f8b589

0800cb50 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
 800cb50:	b580      	push	{r7, lr}
 800cb52:	b084      	sub	sp, #16
 800cb54:	af00      	add	r7, sp, #0
 800cb56:	60f8      	str	r0, [r7, #12]
 800cb58:	60b9      	str	r1, [r7, #8]
 800cb5a:	603b      	str	r3, [r7, #0]
 800cb5c:	4613      	mov	r3, r2
 800cb5e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800cb60:	e048      	b.n	800cbf4 <I2C_WaitOnFlagUntilTimeout+0xa4>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800cb62:	683b      	ldr	r3, [r7, #0]
 800cb64:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cb68:	d044      	beq.n	800cbf4 <I2C_WaitOnFlagUntilTimeout+0xa4>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800cb6a:	f7fc f88b 	bl	8008c84 <HAL_GetTick>
 800cb6e:	4602      	mov	r2, r0
 800cb70:	69bb      	ldr	r3, [r7, #24]
 800cb72:	1ad3      	subs	r3, r2, r3
 800cb74:	683a      	ldr	r2, [r7, #0]
 800cb76:	429a      	cmp	r2, r3
 800cb78:	d302      	bcc.n	800cb80 <I2C_WaitOnFlagUntilTimeout+0x30>
 800cb7a:	683b      	ldr	r3, [r7, #0]
 800cb7c:	2b00      	cmp	r3, #0
 800cb7e:	d139      	bne.n	800cbf4 <I2C_WaitOnFlagUntilTimeout+0xa4>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 800cb80:	68bb      	ldr	r3, [r7, #8]
 800cb82:	0c1b      	lsrs	r3, r3, #16
 800cb84:	b2db      	uxtb	r3, r3
 800cb86:	2b01      	cmp	r3, #1
 800cb88:	d10d      	bne.n	800cba6 <I2C_WaitOnFlagUntilTimeout+0x56>
 800cb8a:	68fb      	ldr	r3, [r7, #12]
 800cb8c:	681b      	ldr	r3, [r3, #0]
 800cb8e:	695b      	ldr	r3, [r3, #20]
 800cb90:	43da      	mvns	r2, r3
 800cb92:	68bb      	ldr	r3, [r7, #8]
 800cb94:	4013      	ands	r3, r2
 800cb96:	b29b      	uxth	r3, r3
 800cb98:	2b00      	cmp	r3, #0
 800cb9a:	bf0c      	ite	eq
 800cb9c:	2301      	moveq	r3, #1
 800cb9e:	2300      	movne	r3, #0
 800cba0:	b2db      	uxtb	r3, r3
 800cba2:	461a      	mov	r2, r3
 800cba4:	e00c      	b.n	800cbc0 <I2C_WaitOnFlagUntilTimeout+0x70>
 800cba6:	68fb      	ldr	r3, [r7, #12]
 800cba8:	681b      	ldr	r3, [r3, #0]
 800cbaa:	699b      	ldr	r3, [r3, #24]
 800cbac:	43da      	mvns	r2, r3
 800cbae:	68bb      	ldr	r3, [r7, #8]
 800cbb0:	4013      	ands	r3, r2
 800cbb2:	b29b      	uxth	r3, r3
 800cbb4:	2b00      	cmp	r3, #0
 800cbb6:	bf0c      	ite	eq
 800cbb8:	2301      	moveq	r3, #1
 800cbba:	2300      	movne	r3, #0
 800cbbc:	b2db      	uxtb	r3, r3
 800cbbe:	461a      	mov	r2, r3
 800cbc0:	79fb      	ldrb	r3, [r7, #7]
 800cbc2:	429a      	cmp	r2, r3
 800cbc4:	d116      	bne.n	800cbf4 <I2C_WaitOnFlagUntilTimeout+0xa4>
        {
          hi2c->PreviousState     = I2C_STATE_NONE;
 800cbc6:	68fb      	ldr	r3, [r7, #12]
 800cbc8:	2200      	movs	r2, #0
 800cbca:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State             = HAL_I2C_STATE_READY;
 800cbcc:	68fb      	ldr	r3, [r7, #12]
 800cbce:	2220      	movs	r2, #32
 800cbd0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode              = HAL_I2C_MODE_NONE;
 800cbd4:	68fb      	ldr	r3, [r7, #12]
 800cbd6:	2200      	movs	r2, #0
 800cbd8:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode         |= HAL_I2C_ERROR_TIMEOUT;
 800cbdc:	68fb      	ldr	r3, [r7, #12]
 800cbde:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800cbe0:	f043 0220 	orr.w	r2, r3, #32
 800cbe4:	68fb      	ldr	r3, [r7, #12]
 800cbe6:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 800cbe8:	68fb      	ldr	r3, [r7, #12]
 800cbea:	2200      	movs	r2, #0
 800cbec:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 800cbf0:	2301      	movs	r3, #1
 800cbf2:	e023      	b.n	800cc3c <I2C_WaitOnFlagUntilTimeout+0xec>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 800cbf4:	68bb      	ldr	r3, [r7, #8]
 800cbf6:	0c1b      	lsrs	r3, r3, #16
 800cbf8:	b2db      	uxtb	r3, r3
 800cbfa:	2b01      	cmp	r3, #1
 800cbfc:	d10d      	bne.n	800cc1a <I2C_WaitOnFlagUntilTimeout+0xca>
 800cbfe:	68fb      	ldr	r3, [r7, #12]
 800cc00:	681b      	ldr	r3, [r3, #0]
 800cc02:	695b      	ldr	r3, [r3, #20]
 800cc04:	43da      	mvns	r2, r3
 800cc06:	68bb      	ldr	r3, [r7, #8]
 800cc08:	4013      	ands	r3, r2
 800cc0a:	b29b      	uxth	r3, r3
 800cc0c:	2b00      	cmp	r3, #0
 800cc0e:	bf0c      	ite	eq
 800cc10:	2301      	moveq	r3, #1
 800cc12:	2300      	movne	r3, #0
 800cc14:	b2db      	uxtb	r3, r3
 800cc16:	461a      	mov	r2, r3
 800cc18:	e00c      	b.n	800cc34 <I2C_WaitOnFlagUntilTimeout+0xe4>
 800cc1a:	68fb      	ldr	r3, [r7, #12]
 800cc1c:	681b      	ldr	r3, [r3, #0]
 800cc1e:	699b      	ldr	r3, [r3, #24]
 800cc20:	43da      	mvns	r2, r3
 800cc22:	68bb      	ldr	r3, [r7, #8]
 800cc24:	4013      	ands	r3, r2
 800cc26:	b29b      	uxth	r3, r3
 800cc28:	2b00      	cmp	r3, #0
 800cc2a:	bf0c      	ite	eq
 800cc2c:	2301      	moveq	r3, #1
 800cc2e:	2300      	movne	r3, #0
 800cc30:	b2db      	uxtb	r3, r3
 800cc32:	461a      	mov	r2, r3
 800cc34:	79fb      	ldrb	r3, [r7, #7]
 800cc36:	429a      	cmp	r2, r3
 800cc38:	d093      	beq.n	800cb62 <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 800cc3a:	2300      	movs	r3, #0
}
 800cc3c:	4618      	mov	r0, r3
 800cc3e:	3710      	adds	r7, #16
 800cc40:	46bd      	mov	sp, r7
 800cc42:	bd80      	pop	{r7, pc}

0800cc44 <I2C_WaitOnMasterAddressFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
{
 800cc44:	b580      	push	{r7, lr}
 800cc46:	b084      	sub	sp, #16
 800cc48:	af00      	add	r7, sp, #0
 800cc4a:	60f8      	str	r0, [r7, #12]
 800cc4c:	60b9      	str	r1, [r7, #8]
 800cc4e:	607a      	str	r2, [r7, #4]
 800cc50:	603b      	str	r3, [r7, #0]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 800cc52:	e071      	b.n	800cd38 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
  {
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800cc54:	68fb      	ldr	r3, [r7, #12]
 800cc56:	681b      	ldr	r3, [r3, #0]
 800cc58:	695b      	ldr	r3, [r3, #20]
 800cc5a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800cc5e:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800cc62:	d123      	bne.n	800ccac <I2C_WaitOnMasterAddressFlagUntilTimeout+0x68>
    {
      /* Generate Stop */
      SET_BIT(hi2c->Instance->CR1, I2C_CR1_STOP);
 800cc64:	68fb      	ldr	r3, [r7, #12]
 800cc66:	681b      	ldr	r3, [r3, #0]
 800cc68:	681a      	ldr	r2, [r3, #0]
 800cc6a:	68fb      	ldr	r3, [r7, #12]
 800cc6c:	681b      	ldr	r3, [r3, #0]
 800cc6e:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 800cc72:	601a      	str	r2, [r3, #0]

      /* Clear AF Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800cc74:	68fb      	ldr	r3, [r7, #12]
 800cc76:	681b      	ldr	r3, [r3, #0]
 800cc78:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 800cc7c:	615a      	str	r2, [r3, #20]

      hi2c->PreviousState       = I2C_STATE_NONE;
 800cc7e:	68fb      	ldr	r3, [r7, #12]
 800cc80:	2200      	movs	r2, #0
 800cc82:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State               = HAL_I2C_STATE_READY;
 800cc84:	68fb      	ldr	r3, [r7, #12]
 800cc86:	2220      	movs	r2, #32
 800cc88:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode                = HAL_I2C_MODE_NONE;
 800cc8c:	68fb      	ldr	r3, [r7, #12]
 800cc8e:	2200      	movs	r2, #0
 800cc90:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
 800cc94:	68fb      	ldr	r3, [r7, #12]
 800cc96:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800cc98:	f043 0204 	orr.w	r2, r3, #4
 800cc9c:	68fb      	ldr	r3, [r7, #12]
 800cc9e:	641a      	str	r2, [r3, #64]	@ 0x40

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800cca0:	68fb      	ldr	r3, [r7, #12]
 800cca2:	2200      	movs	r2, #0
 800cca4:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

      return HAL_ERROR;
 800cca8:	2301      	movs	r3, #1
 800ccaa:	e067      	b.n	800cd7c <I2C_WaitOnMasterAddressFlagUntilTimeout+0x138>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ccac:	687b      	ldr	r3, [r7, #4]
 800ccae:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ccb2:	d041      	beq.n	800cd38 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ccb4:	f7fb ffe6 	bl	8008c84 <HAL_GetTick>
 800ccb8:	4602      	mov	r2, r0
 800ccba:	683b      	ldr	r3, [r7, #0]
 800ccbc:	1ad3      	subs	r3, r2, r3
 800ccbe:	687a      	ldr	r2, [r7, #4]
 800ccc0:	429a      	cmp	r2, r3
 800ccc2:	d302      	bcc.n	800ccca <I2C_WaitOnMasterAddressFlagUntilTimeout+0x86>
 800ccc4:	687b      	ldr	r3, [r7, #4]
 800ccc6:	2b00      	cmp	r3, #0
 800ccc8:	d136      	bne.n	800cd38 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET))
 800ccca:	68bb      	ldr	r3, [r7, #8]
 800cccc:	0c1b      	lsrs	r3, r3, #16
 800ccce:	b2db      	uxtb	r3, r3
 800ccd0:	2b01      	cmp	r3, #1
 800ccd2:	d10c      	bne.n	800ccee <I2C_WaitOnMasterAddressFlagUntilTimeout+0xaa>
 800ccd4:	68fb      	ldr	r3, [r7, #12]
 800ccd6:	681b      	ldr	r3, [r3, #0]
 800ccd8:	695b      	ldr	r3, [r3, #20]
 800ccda:	43da      	mvns	r2, r3
 800ccdc:	68bb      	ldr	r3, [r7, #8]
 800ccde:	4013      	ands	r3, r2
 800cce0:	b29b      	uxth	r3, r3
 800cce2:	2b00      	cmp	r3, #0
 800cce4:	bf14      	ite	ne
 800cce6:	2301      	movne	r3, #1
 800cce8:	2300      	moveq	r3, #0
 800ccea:	b2db      	uxtb	r3, r3
 800ccec:	e00b      	b.n	800cd06 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xc2>
 800ccee:	68fb      	ldr	r3, [r7, #12]
 800ccf0:	681b      	ldr	r3, [r3, #0]
 800ccf2:	699b      	ldr	r3, [r3, #24]
 800ccf4:	43da      	mvns	r2, r3
 800ccf6:	68bb      	ldr	r3, [r7, #8]
 800ccf8:	4013      	ands	r3, r2
 800ccfa:	b29b      	uxth	r3, r3
 800ccfc:	2b00      	cmp	r3, #0
 800ccfe:	bf14      	ite	ne
 800cd00:	2301      	movne	r3, #1
 800cd02:	2300      	moveq	r3, #0
 800cd04:	b2db      	uxtb	r3, r3
 800cd06:	2b00      	cmp	r3, #0
 800cd08:	d016      	beq.n	800cd38 <I2C_WaitOnMasterAddressFlagUntilTimeout+0xf4>
        {
          hi2c->PreviousState       = I2C_STATE_NONE;
 800cd0a:	68fb      	ldr	r3, [r7, #12]
 800cd0c:	2200      	movs	r2, #0
 800cd0e:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State               = HAL_I2C_STATE_READY;
 800cd10:	68fb      	ldr	r3, [r7, #12]
 800cd12:	2220      	movs	r2, #32
 800cd14:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode                = HAL_I2C_MODE_NONE;
 800cd18:	68fb      	ldr	r3, [r7, #12]
 800cd1a:	2200      	movs	r2, #0
 800cd1c:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 800cd20:	68fb      	ldr	r3, [r7, #12]
 800cd22:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800cd24:	f043 0220 	orr.w	r2, r3, #32
 800cd28:	68fb      	ldr	r3, [r7, #12]
 800cd2a:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 800cd2c:	68fb      	ldr	r3, [r7, #12]
 800cd2e:	2200      	movs	r2, #0
 800cd30:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 800cd34:	2301      	movs	r3, #1
 800cd36:	e021      	b.n	800cd7c <I2C_WaitOnMasterAddressFlagUntilTimeout+0x138>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 800cd38:	68bb      	ldr	r3, [r7, #8]
 800cd3a:	0c1b      	lsrs	r3, r3, #16
 800cd3c:	b2db      	uxtb	r3, r3
 800cd3e:	2b01      	cmp	r3, #1
 800cd40:	d10c      	bne.n	800cd5c <I2C_WaitOnMasterAddressFlagUntilTimeout+0x118>
 800cd42:	68fb      	ldr	r3, [r7, #12]
 800cd44:	681b      	ldr	r3, [r3, #0]
 800cd46:	695b      	ldr	r3, [r3, #20]
 800cd48:	43da      	mvns	r2, r3
 800cd4a:	68bb      	ldr	r3, [r7, #8]
 800cd4c:	4013      	ands	r3, r2
 800cd4e:	b29b      	uxth	r3, r3
 800cd50:	2b00      	cmp	r3, #0
 800cd52:	bf14      	ite	ne
 800cd54:	2301      	movne	r3, #1
 800cd56:	2300      	moveq	r3, #0
 800cd58:	b2db      	uxtb	r3, r3
 800cd5a:	e00b      	b.n	800cd74 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x130>
 800cd5c:	68fb      	ldr	r3, [r7, #12]
 800cd5e:	681b      	ldr	r3, [r3, #0]
 800cd60:	699b      	ldr	r3, [r3, #24]
 800cd62:	43da      	mvns	r2, r3
 800cd64:	68bb      	ldr	r3, [r7, #8]
 800cd66:	4013      	ands	r3, r2
 800cd68:	b29b      	uxth	r3, r3
 800cd6a:	2b00      	cmp	r3, #0
 800cd6c:	bf14      	ite	ne
 800cd6e:	2301      	movne	r3, #1
 800cd70:	2300      	moveq	r3, #0
 800cd72:	b2db      	uxtb	r3, r3
 800cd74:	2b00      	cmp	r3, #0
 800cd76:	f47f af6d 	bne.w	800cc54 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x10>
        }
      }
    }
  }
  return HAL_OK;
 800cd7a:	2300      	movs	r3, #0
}
 800cd7c:	4618      	mov	r0, r3
 800cd7e:	3710      	adds	r7, #16
 800cd80:	46bd      	mov	sp, r7
 800cd82:	bd80      	pop	{r7, pc}

0800cd84 <I2C_WaitOnTXEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800cd84:	b580      	push	{r7, lr}
 800cd86:	b084      	sub	sp, #16
 800cd88:	af00      	add	r7, sp, #0
 800cd8a:	60f8      	str	r0, [r7, #12]
 800cd8c:	60b9      	str	r1, [r7, #8]
 800cd8e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800cd90:	e034      	b.n	800cdfc <I2C_WaitOnTXEFlagUntilTimeout+0x78>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 800cd92:	68f8      	ldr	r0, [r7, #12]
 800cd94:	f000 f915 	bl	800cfc2 <I2C_IsAcknowledgeFailed>
 800cd98:	4603      	mov	r3, r0
 800cd9a:	2b00      	cmp	r3, #0
 800cd9c:	d001      	beq.n	800cda2 <I2C_WaitOnTXEFlagUntilTimeout+0x1e>
    {
      return HAL_ERROR;
 800cd9e:	2301      	movs	r3, #1
 800cda0:	e034      	b.n	800ce0c <I2C_WaitOnTXEFlagUntilTimeout+0x88>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800cda2:	68bb      	ldr	r3, [r7, #8]
 800cda4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cda8:	d028      	beq.n	800cdfc <I2C_WaitOnTXEFlagUntilTimeout+0x78>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800cdaa:	f7fb ff6b 	bl	8008c84 <HAL_GetTick>
 800cdae:	4602      	mov	r2, r0
 800cdb0:	687b      	ldr	r3, [r7, #4]
 800cdb2:	1ad3      	subs	r3, r2, r3
 800cdb4:	68ba      	ldr	r2, [r7, #8]
 800cdb6:	429a      	cmp	r2, r3
 800cdb8:	d302      	bcc.n	800cdc0 <I2C_WaitOnTXEFlagUntilTimeout+0x3c>
 800cdba:	68bb      	ldr	r3, [r7, #8]
 800cdbc:	2b00      	cmp	r3, #0
 800cdbe:	d11d      	bne.n	800cdfc <I2C_WaitOnTXEFlagUntilTimeout+0x78>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET))
 800cdc0:	68fb      	ldr	r3, [r7, #12]
 800cdc2:	681b      	ldr	r3, [r3, #0]
 800cdc4:	695b      	ldr	r3, [r3, #20]
 800cdc6:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800cdca:	2b80      	cmp	r3, #128	@ 0x80
 800cdcc:	d016      	beq.n	800cdfc <I2C_WaitOnTXEFlagUntilTimeout+0x78>
        {
          hi2c->PreviousState       = I2C_STATE_NONE;
 800cdce:	68fb      	ldr	r3, [r7, #12]
 800cdd0:	2200      	movs	r2, #0
 800cdd2:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State               = HAL_I2C_STATE_READY;
 800cdd4:	68fb      	ldr	r3, [r7, #12]
 800cdd6:	2220      	movs	r2, #32
 800cdd8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode                = HAL_I2C_MODE_NONE;
 800cddc:	68fb      	ldr	r3, [r7, #12]
 800cdde:	2200      	movs	r2, #0
 800cde0:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 800cde4:	68fb      	ldr	r3, [r7, #12]
 800cde6:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800cde8:	f043 0220 	orr.w	r2, r3, #32
 800cdec:	68fb      	ldr	r3, [r7, #12]
 800cdee:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 800cdf0:	68fb      	ldr	r3, [r7, #12]
 800cdf2:	2200      	movs	r2, #0
 800cdf4:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 800cdf8:	2301      	movs	r3, #1
 800cdfa:	e007      	b.n	800ce0c <I2C_WaitOnTXEFlagUntilTimeout+0x88>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800cdfc:	68fb      	ldr	r3, [r7, #12]
 800cdfe:	681b      	ldr	r3, [r3, #0]
 800ce00:	695b      	ldr	r3, [r3, #20]
 800ce02:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800ce06:	2b80      	cmp	r3, #128	@ 0x80
 800ce08:	d1c3      	bne.n	800cd92 <I2C_WaitOnTXEFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
 800ce0a:	2300      	movs	r3, #0
}
 800ce0c:	4618      	mov	r0, r3
 800ce0e:	3710      	adds	r7, #16
 800ce10:	46bd      	mov	sp, r7
 800ce12:	bd80      	pop	{r7, pc}

0800ce14 <I2C_WaitOnBTFFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800ce14:	b580      	push	{r7, lr}
 800ce16:	b084      	sub	sp, #16
 800ce18:	af00      	add	r7, sp, #0
 800ce1a:	60f8      	str	r0, [r7, #12]
 800ce1c:	60b9      	str	r1, [r7, #8]
 800ce1e:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 800ce20:	e034      	b.n	800ce8c <I2C_WaitOnBTFFlagUntilTimeout+0x78>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 800ce22:	68f8      	ldr	r0, [r7, #12]
 800ce24:	f000 f8cd 	bl	800cfc2 <I2C_IsAcknowledgeFailed>
 800ce28:	4603      	mov	r3, r0
 800ce2a:	2b00      	cmp	r3, #0
 800ce2c:	d001      	beq.n	800ce32 <I2C_WaitOnBTFFlagUntilTimeout+0x1e>
    {
      return HAL_ERROR;
 800ce2e:	2301      	movs	r3, #1
 800ce30:	e034      	b.n	800ce9c <I2C_WaitOnBTFFlagUntilTimeout+0x88>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800ce32:	68bb      	ldr	r3, [r7, #8]
 800ce34:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ce38:	d028      	beq.n	800ce8c <I2C_WaitOnBTFFlagUntilTimeout+0x78>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800ce3a:	f7fb ff23 	bl	8008c84 <HAL_GetTick>
 800ce3e:	4602      	mov	r2, r0
 800ce40:	687b      	ldr	r3, [r7, #4]
 800ce42:	1ad3      	subs	r3, r2, r3
 800ce44:	68ba      	ldr	r2, [r7, #8]
 800ce46:	429a      	cmp	r2, r3
 800ce48:	d302      	bcc.n	800ce50 <I2C_WaitOnBTFFlagUntilTimeout+0x3c>
 800ce4a:	68bb      	ldr	r3, [r7, #8]
 800ce4c:	2b00      	cmp	r3, #0
 800ce4e:	d11d      	bne.n	800ce8c <I2C_WaitOnBTFFlagUntilTimeout+0x78>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET))
 800ce50:	68fb      	ldr	r3, [r7, #12]
 800ce52:	681b      	ldr	r3, [r3, #0]
 800ce54:	695b      	ldr	r3, [r3, #20]
 800ce56:	f003 0304 	and.w	r3, r3, #4
 800ce5a:	2b04      	cmp	r3, #4
 800ce5c:	d016      	beq.n	800ce8c <I2C_WaitOnBTFFlagUntilTimeout+0x78>
        {
          hi2c->PreviousState       = I2C_STATE_NONE;
 800ce5e:	68fb      	ldr	r3, [r7, #12]
 800ce60:	2200      	movs	r2, #0
 800ce62:	631a      	str	r2, [r3, #48]	@ 0x30
          hi2c->State               = HAL_I2C_STATE_READY;
 800ce64:	68fb      	ldr	r3, [r7, #12]
 800ce66:	2220      	movs	r2, #32
 800ce68:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
          hi2c->Mode                = HAL_I2C_MODE_NONE;
 800ce6c:	68fb      	ldr	r3, [r7, #12]
 800ce6e:	2200      	movs	r2, #0
 800ce70:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
          hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 800ce74:	68fb      	ldr	r3, [r7, #12]
 800ce76:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ce78:	f043 0220 	orr.w	r2, r3, #32
 800ce7c:	68fb      	ldr	r3, [r7, #12]
 800ce7e:	641a      	str	r2, [r3, #64]	@ 0x40

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 800ce80:	68fb      	ldr	r3, [r7, #12]
 800ce82:	2200      	movs	r2, #0
 800ce84:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

          return HAL_ERROR;
 800ce88:	2301      	movs	r3, #1
 800ce8a:	e007      	b.n	800ce9c <I2C_WaitOnBTFFlagUntilTimeout+0x88>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 800ce8c:	68fb      	ldr	r3, [r7, #12]
 800ce8e:	681b      	ldr	r3, [r3, #0]
 800ce90:	695b      	ldr	r3, [r3, #20]
 800ce92:	f003 0304 	and.w	r3, r3, #4
 800ce96:	2b04      	cmp	r3, #4
 800ce98:	d1c3      	bne.n	800ce22 <I2C_WaitOnBTFFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
 800ce9a:	2300      	movs	r3, #0
}
 800ce9c:	4618      	mov	r0, r3
 800ce9e:	3710      	adds	r7, #16
 800cea0:	46bd      	mov	sp, r7
 800cea2:	bd80      	pop	{r7, pc}

0800cea4 <I2C_WaitOnSTOPRequestThroughIT>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPRequestThroughIT(I2C_HandleTypeDef *hi2c)
{
 800cea4:	b480      	push	{r7}
 800cea6:	b085      	sub	sp, #20
 800cea8:	af00      	add	r7, sp, #0
 800ceaa:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 800ceac:	2300      	movs	r3, #0
 800ceae:	60fb      	str	r3, [r7, #12]

  /* Wait until STOP flag is reset */
  count = I2C_TIMEOUT_STOP_FLAG * (SystemCoreClock / 25U / 1000U);
 800ceb0:	4b13      	ldr	r3, [pc, #76]	@ (800cf00 <I2C_WaitOnSTOPRequestThroughIT+0x5c>)
 800ceb2:	681b      	ldr	r3, [r3, #0]
 800ceb4:	08db      	lsrs	r3, r3, #3
 800ceb6:	4a13      	ldr	r2, [pc, #76]	@ (800cf04 <I2C_WaitOnSTOPRequestThroughIT+0x60>)
 800ceb8:	fba2 2303 	umull	r2, r3, r2, r3
 800cebc:	0a1a      	lsrs	r2, r3, #8
 800cebe:	4613      	mov	r3, r2
 800cec0:	009b      	lsls	r3, r3, #2
 800cec2:	4413      	add	r3, r2
 800cec4:	60fb      	str	r3, [r7, #12]
  do
  {
    count--;
 800cec6:	68fb      	ldr	r3, [r7, #12]
 800cec8:	3b01      	subs	r3, #1
 800ceca:	60fb      	str	r3, [r7, #12]
    if (count == 0U)
 800cecc:	68fb      	ldr	r3, [r7, #12]
 800cece:	2b00      	cmp	r3, #0
 800ced0:	d107      	bne.n	800cee2 <I2C_WaitOnSTOPRequestThroughIT+0x3e>
    {
      hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 800ced2:	687b      	ldr	r3, [r7, #4]
 800ced4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ced6:	f043 0220 	orr.w	r2, r3, #32
 800ceda:	687b      	ldr	r3, [r7, #4]
 800cedc:	641a      	str	r2, [r3, #64]	@ 0x40

      return HAL_ERROR;
 800cede:	2301      	movs	r3, #1
 800cee0:	e008      	b.n	800cef4 <I2C_WaitOnSTOPRequestThroughIT+0x50>
    }
  }
  while (READ_BIT(hi2c->Instance->CR1, I2C_CR1_STOP) == I2C_CR1_STOP);
 800cee2:	687b      	ldr	r3, [r7, #4]
 800cee4:	681b      	ldr	r3, [r3, #0]
 800cee6:	681b      	ldr	r3, [r3, #0]
 800cee8:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 800ceec:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800cef0:	d0e9      	beq.n	800cec6 <I2C_WaitOnSTOPRequestThroughIT+0x22>

  return HAL_OK;
 800cef2:	2300      	movs	r3, #0
}
 800cef4:	4618      	mov	r0, r3
 800cef6:	3714      	adds	r7, #20
 800cef8:	46bd      	mov	sp, r7
 800cefa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cefe:	4770      	bx	lr
 800cf00:	20000040 	.word	0x20000040
 800cf04:	14f8b589 	.word	0x14f8b589

0800cf08 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800cf08:	b580      	push	{r7, lr}
 800cf0a:	b084      	sub	sp, #16
 800cf0c:	af00      	add	r7, sp, #0
 800cf0e:	60f8      	str	r0, [r7, #12]
 800cf10:	60b9      	str	r1, [r7, #8]
 800cf12:	607a      	str	r2, [r7, #4]

  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800cf14:	e049      	b.n	800cfaa <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
  {
    /* Check if a STOPF is detected */
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 800cf16:	68fb      	ldr	r3, [r7, #12]
 800cf18:	681b      	ldr	r3, [r3, #0]
 800cf1a:	695b      	ldr	r3, [r3, #20]
 800cf1c:	f003 0310 	and.w	r3, r3, #16
 800cf20:	2b10      	cmp	r3, #16
 800cf22:	d119      	bne.n	800cf58 <I2C_WaitOnRXNEFlagUntilTimeout+0x50>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800cf24:	68fb      	ldr	r3, [r7, #12]
 800cf26:	681b      	ldr	r3, [r3, #0]
 800cf28:	f06f 0210 	mvn.w	r2, #16
 800cf2c:	615a      	str	r2, [r3, #20]

      hi2c->PreviousState       = I2C_STATE_NONE;
 800cf2e:	68fb      	ldr	r3, [r7, #12]
 800cf30:	2200      	movs	r2, #0
 800cf32:	631a      	str	r2, [r3, #48]	@ 0x30
      hi2c->State               = HAL_I2C_STATE_READY;
 800cf34:	68fb      	ldr	r3, [r7, #12]
 800cf36:	2220      	movs	r2, #32
 800cf38:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
      hi2c->Mode                = HAL_I2C_MODE_NONE;
 800cf3c:	68fb      	ldr	r3, [r7, #12]
 800cf3e:	2200      	movs	r2, #0
 800cf40:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
      hi2c->ErrorCode           |= HAL_I2C_ERROR_NONE;
 800cf44:	68fb      	ldr	r3, [r7, #12]
 800cf46:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800cf48:	68fb      	ldr	r3, [r7, #12]
 800cf4a:	641a      	str	r2, [r3, #64]	@ 0x40

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800cf4c:	68fb      	ldr	r3, [r7, #12]
 800cf4e:	2200      	movs	r2, #0
 800cf50:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

      return HAL_ERROR;
 800cf54:	2301      	movs	r3, #1
 800cf56:	e030      	b.n	800cfba <I2C_WaitOnRXNEFlagUntilTimeout+0xb2>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800cf58:	f7fb fe94 	bl	8008c84 <HAL_GetTick>
 800cf5c:	4602      	mov	r2, r0
 800cf5e:	687b      	ldr	r3, [r7, #4]
 800cf60:	1ad3      	subs	r3, r2, r3
 800cf62:	68ba      	ldr	r2, [r7, #8]
 800cf64:	429a      	cmp	r2, r3
 800cf66:	d302      	bcc.n	800cf6e <I2C_WaitOnRXNEFlagUntilTimeout+0x66>
 800cf68:	68bb      	ldr	r3, [r7, #8]
 800cf6a:	2b00      	cmp	r3, #0
 800cf6c:	d11d      	bne.n	800cfaa <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET))
 800cf6e:	68fb      	ldr	r3, [r7, #12]
 800cf70:	681b      	ldr	r3, [r3, #0]
 800cf72:	695b      	ldr	r3, [r3, #20]
 800cf74:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800cf78:	2b40      	cmp	r3, #64	@ 0x40
 800cf7a:	d016      	beq.n	800cfaa <I2C_WaitOnRXNEFlagUntilTimeout+0xa2>
      {
        hi2c->PreviousState       = I2C_STATE_NONE;
 800cf7c:	68fb      	ldr	r3, [r7, #12]
 800cf7e:	2200      	movs	r2, #0
 800cf80:	631a      	str	r2, [r3, #48]	@ 0x30
        hi2c->State               = HAL_I2C_STATE_READY;
 800cf82:	68fb      	ldr	r3, [r7, #12]
 800cf84:	2220      	movs	r2, #32
 800cf86:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
        hi2c->Mode                = HAL_I2C_MODE_NONE;
 800cf8a:	68fb      	ldr	r3, [r7, #12]
 800cf8c:	2200      	movs	r2, #0
 800cf8e:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
        hi2c->ErrorCode           |= HAL_I2C_ERROR_TIMEOUT;
 800cf92:	68fb      	ldr	r3, [r7, #12]
 800cf94:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800cf96:	f043 0220 	orr.w	r2, r3, #32
 800cf9a:	68fb      	ldr	r3, [r7, #12]
 800cf9c:	641a      	str	r2, [r3, #64]	@ 0x40

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800cf9e:	68fb      	ldr	r3, [r7, #12]
 800cfa0:	2200      	movs	r2, #0
 800cfa2:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

        return HAL_ERROR;
 800cfa6:	2301      	movs	r3, #1
 800cfa8:	e007      	b.n	800cfba <I2C_WaitOnRXNEFlagUntilTimeout+0xb2>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800cfaa:	68fb      	ldr	r3, [r7, #12]
 800cfac:	681b      	ldr	r3, [r3, #0]
 800cfae:	695b      	ldr	r3, [r3, #20]
 800cfb0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800cfb4:	2b40      	cmp	r3, #64	@ 0x40
 800cfb6:	d1ae      	bne.n	800cf16 <I2C_WaitOnRXNEFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 800cfb8:	2300      	movs	r3, #0
}
 800cfba:	4618      	mov	r0, r3
 800cfbc:	3710      	adds	r7, #16
 800cfbe:	46bd      	mov	sp, r7
 800cfc0:	bd80      	pop	{r7, pc}

0800cfc2 <I2C_IsAcknowledgeFailed>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
{
 800cfc2:	b480      	push	{r7}
 800cfc4:	b083      	sub	sp, #12
 800cfc6:	af00      	add	r7, sp, #0
 800cfc8:	6078      	str	r0, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800cfca:	687b      	ldr	r3, [r7, #4]
 800cfcc:	681b      	ldr	r3, [r3, #0]
 800cfce:	695b      	ldr	r3, [r3, #20]
 800cfd0:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800cfd4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 800cfd8:	d11b      	bne.n	800d012 <I2C_IsAcknowledgeFailed+0x50>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800cfda:	687b      	ldr	r3, [r7, #4]
 800cfdc:	681b      	ldr	r3, [r3, #0]
 800cfde:	f46f 6280 	mvn.w	r2, #1024	@ 0x400
 800cfe2:	615a      	str	r2, [r3, #20]

    hi2c->PreviousState       = I2C_STATE_NONE;
 800cfe4:	687b      	ldr	r3, [r7, #4]
 800cfe6:	2200      	movs	r2, #0
 800cfe8:	631a      	str	r2, [r3, #48]	@ 0x30
    hi2c->State               = HAL_I2C_STATE_READY;
 800cfea:	687b      	ldr	r3, [r7, #4]
 800cfec:	2220      	movs	r2, #32
 800cfee:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d
    hi2c->Mode                = HAL_I2C_MODE_NONE;
 800cff2:	687b      	ldr	r3, [r7, #4]
 800cff4:	2200      	movs	r2, #0
 800cff6:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
    hi2c->ErrorCode           |= HAL_I2C_ERROR_AF;
 800cffa:	687b      	ldr	r3, [r7, #4]
 800cffc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800cffe:	f043 0204 	orr.w	r2, r3, #4
 800d002:	687b      	ldr	r3, [r7, #4]
 800d004:	641a      	str	r2, [r3, #64]	@ 0x40

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800d006:	687b      	ldr	r3, [r7, #4]
 800d008:	2200      	movs	r2, #0
 800d00a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

    return HAL_ERROR;
 800d00e:	2301      	movs	r3, #1
 800d010:	e000      	b.n	800d014 <I2C_IsAcknowledgeFailed+0x52>
  }
  return HAL_OK;
 800d012:	2300      	movs	r3, #0
}
 800d014:	4618      	mov	r0, r3
 800d016:	370c      	adds	r7, #12
 800d018:	46bd      	mov	sp, r7
 800d01a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d01e:	4770      	bx	lr

0800d020 <I2C_ConvertOtherXferOptions>:
  * @brief  Convert I2Cx OTHER_xxx XferOptions to functional XferOptions.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_ConvertOtherXferOptions(I2C_HandleTypeDef *hi2c)
{
 800d020:	b480      	push	{r7}
 800d022:	b083      	sub	sp, #12
 800d024:	af00      	add	r7, sp, #0
 800d026:	6078      	str	r0, [r7, #4]
  /* if user set XferOptions to I2C_OTHER_FRAME            */
  /* it request implicitly to generate a restart condition */
  /* set XferOptions to I2C_FIRST_FRAME                    */
  if (hi2c->XferOptions == I2C_OTHER_FRAME)
 800d028:	687b      	ldr	r3, [r7, #4]
 800d02a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800d02c:	f5b3 0f2a 	cmp.w	r3, #11141120	@ 0xaa0000
 800d030:	d103      	bne.n	800d03a <I2C_ConvertOtherXferOptions+0x1a>
  {
    hi2c->XferOptions = I2C_FIRST_FRAME;
 800d032:	687b      	ldr	r3, [r7, #4]
 800d034:	2201      	movs	r2, #1
 800d036:	62da      	str	r2, [r3, #44]	@ 0x2c
  }
  else
  {
    /* Nothing to do */
  }
}
 800d038:	e007      	b.n	800d04a <I2C_ConvertOtherXferOptions+0x2a>
  else if (hi2c->XferOptions == I2C_OTHER_AND_LAST_FRAME)
 800d03a:	687b      	ldr	r3, [r7, #4]
 800d03c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800d03e:	f1b3 4f2a 	cmp.w	r3, #2852126720	@ 0xaa000000
 800d042:	d102      	bne.n	800d04a <I2C_ConvertOtherXferOptions+0x2a>
    hi2c->XferOptions = I2C_FIRST_AND_LAST_FRAME;
 800d044:	687b      	ldr	r3, [r7, #4]
 800d046:	2208      	movs	r2, #8
 800d048:	62da      	str	r2, [r3, #44]	@ 0x2c
}
 800d04a:	bf00      	nop
 800d04c:	370c      	adds	r7, #12
 800d04e:	46bd      	mov	sp, r7
 800d050:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d054:	4770      	bx	lr

0800d056 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter new state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 800d056:	b480      	push	{r7}
 800d058:	b083      	sub	sp, #12
 800d05a:	af00      	add	r7, sp, #0
 800d05c:	6078      	str	r0, [r7, #4]
 800d05e:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800d060:	687b      	ldr	r3, [r7, #4]
 800d062:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800d066:	b2db      	uxtb	r3, r3
 800d068:	2b20      	cmp	r3, #32
 800d06a:	d129      	bne.n	800d0c0 <HAL_I2CEx_ConfigAnalogFilter+0x6a>
  {
    hi2c->State = HAL_I2C_STATE_BUSY;
 800d06c:	687b      	ldr	r3, [r7, #4]
 800d06e:	2224      	movs	r2, #36	@ 0x24
 800d070:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800d074:	687b      	ldr	r3, [r7, #4]
 800d076:	681b      	ldr	r3, [r3, #0]
 800d078:	681a      	ldr	r2, [r3, #0]
 800d07a:	687b      	ldr	r3, [r7, #4]
 800d07c:	681b      	ldr	r3, [r3, #0]
 800d07e:	f022 0201 	bic.w	r2, r2, #1
 800d082:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->FLTR &= ~(I2C_FLTR_ANOFF);
 800d084:	687b      	ldr	r3, [r7, #4]
 800d086:	681b      	ldr	r3, [r3, #0]
 800d088:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800d08a:	687b      	ldr	r3, [r7, #4]
 800d08c:	681b      	ldr	r3, [r3, #0]
 800d08e:	f022 0210 	bic.w	r2, r2, #16
 800d092:	625a      	str	r2, [r3, #36]	@ 0x24

    /* Disable the analog filter */
    hi2c->Instance->FLTR |= AnalogFilter;
 800d094:	687b      	ldr	r3, [r7, #4]
 800d096:	681b      	ldr	r3, [r3, #0]
 800d098:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 800d09a:	687b      	ldr	r3, [r7, #4]
 800d09c:	681b      	ldr	r3, [r3, #0]
 800d09e:	683a      	ldr	r2, [r7, #0]
 800d0a0:	430a      	orrs	r2, r1
 800d0a2:	625a      	str	r2, [r3, #36]	@ 0x24

    __HAL_I2C_ENABLE(hi2c);
 800d0a4:	687b      	ldr	r3, [r7, #4]
 800d0a6:	681b      	ldr	r3, [r3, #0]
 800d0a8:	681a      	ldr	r2, [r3, #0]
 800d0aa:	687b      	ldr	r3, [r7, #4]
 800d0ac:	681b      	ldr	r3, [r3, #0]
 800d0ae:	f042 0201 	orr.w	r2, r2, #1
 800d0b2:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800d0b4:	687b      	ldr	r3, [r7, #4]
 800d0b6:	2220      	movs	r2, #32
 800d0b8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

    return HAL_OK;
 800d0bc:	2300      	movs	r3, #0
 800d0be:	e000      	b.n	800d0c2 <HAL_I2CEx_ConfigAnalogFilter+0x6c>
  }
  else
  {
    return HAL_BUSY;
 800d0c0:	2302      	movs	r3, #2
  }
}
 800d0c2:	4618      	mov	r0, r3
 800d0c4:	370c      	adds	r7, #12
 800d0c6:	46bd      	mov	sp, r7
 800d0c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0cc:	4770      	bx	lr

0800d0ce <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between 0x00 and 0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800d0ce:	b480      	push	{r7}
 800d0d0:	b085      	sub	sp, #20
 800d0d2:	af00      	add	r7, sp, #0
 800d0d4:	6078      	str	r0, [r7, #4]
 800d0d6:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0;
 800d0d8:	2300      	movs	r3, #0
 800d0da:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800d0dc:	687b      	ldr	r3, [r7, #4]
 800d0de:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800d0e2:	b2db      	uxtb	r3, r3
 800d0e4:	2b20      	cmp	r3, #32
 800d0e6:	d12a      	bne.n	800d13e <HAL_I2CEx_ConfigDigitalFilter+0x70>
  {
    hi2c->State = HAL_I2C_STATE_BUSY;
 800d0e8:	687b      	ldr	r3, [r7, #4]
 800d0ea:	2224      	movs	r2, #36	@ 0x24
 800d0ec:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800d0f0:	687b      	ldr	r3, [r7, #4]
 800d0f2:	681b      	ldr	r3, [r3, #0]
 800d0f4:	681a      	ldr	r2, [r3, #0]
 800d0f6:	687b      	ldr	r3, [r7, #4]
 800d0f8:	681b      	ldr	r3, [r3, #0]
 800d0fa:	f022 0201 	bic.w	r2, r2, #1
 800d0fe:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->FLTR;
 800d100:	687b      	ldr	r3, [r7, #4]
 800d102:	681b      	ldr	r3, [r3, #0]
 800d104:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d106:	81fb      	strh	r3, [r7, #14]

    /* Reset I2Cx DNF bit [3:0] */
    tmpreg &= ~(I2C_FLTR_DNF);
 800d108:	89fb      	ldrh	r3, [r7, #14]
 800d10a:	f023 030f 	bic.w	r3, r3, #15
 800d10e:	81fb      	strh	r3, [r7, #14]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter;
 800d110:	683b      	ldr	r3, [r7, #0]
 800d112:	b29a      	uxth	r2, r3
 800d114:	89fb      	ldrh	r3, [r7, #14]
 800d116:	4313      	orrs	r3, r2
 800d118:	81fb      	strh	r3, [r7, #14]

    /* Store the new register value */
    hi2c->Instance->FLTR = tmpreg;
 800d11a:	687b      	ldr	r3, [r7, #4]
 800d11c:	681b      	ldr	r3, [r3, #0]
 800d11e:	89fa      	ldrh	r2, [r7, #14]
 800d120:	625a      	str	r2, [r3, #36]	@ 0x24

    __HAL_I2C_ENABLE(hi2c);
 800d122:	687b      	ldr	r3, [r7, #4]
 800d124:	681b      	ldr	r3, [r3, #0]
 800d126:	681a      	ldr	r2, [r3, #0]
 800d128:	687b      	ldr	r3, [r7, #4]
 800d12a:	681b      	ldr	r3, [r3, #0]
 800d12c:	f042 0201 	orr.w	r2, r2, #1
 800d130:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800d132:	687b      	ldr	r3, [r7, #4]
 800d134:	2220      	movs	r2, #32
 800d136:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

    return HAL_OK;
 800d13a:	2300      	movs	r3, #0
 800d13c:	e000      	b.n	800d140 <HAL_I2CEx_ConfigDigitalFilter+0x72>
  }
  else
  {
    return HAL_BUSY;
 800d13e:	2302      	movs	r3, #2
  }
}
 800d140:	4618      	mov	r0, r3
 800d142:	3714      	adds	r7, #20
 800d144:	46bd      	mov	sp, r7
 800d146:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d14a:	4770      	bx	lr

0800d14c <HAL_I2S_Init>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Init(I2S_HandleTypeDef *hi2s)
{
 800d14c:	b580      	push	{r7, lr}
 800d14e:	b088      	sub	sp, #32
 800d150:	af00      	add	r7, sp, #0
 800d152:	6078      	str	r0, [r7, #4]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)
  uint16_t tmpreg;
#endif

  /* Check the I2S handle allocation */
  if (hi2s == NULL)
 800d154:	687b      	ldr	r3, [r7, #4]
 800d156:	2b00      	cmp	r3, #0
 800d158:	d101      	bne.n	800d15e <HAL_I2S_Init+0x12>
  {
    return HAL_ERROR;
 800d15a:	2301      	movs	r3, #1
 800d15c:	e128      	b.n	800d3b0 <HAL_I2S_Init+0x264>
  assert_param(IS_I2S_MCLK_OUTPUT(hi2s->Init.MCLKOutput));
  assert_param(IS_I2S_AUDIO_FREQ(hi2s->Init.AudioFreq));
  assert_param(IS_I2S_CPOL(hi2s->Init.CPOL));
  assert_param(IS_I2S_CLOCKSOURCE(hi2s->Init.ClockSource));

  if (hi2s->State == HAL_I2S_STATE_RESET)
 800d15e:	687b      	ldr	r3, [r7, #4]
 800d160:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800d164:	b2db      	uxtb	r3, r3
 800d166:	2b00      	cmp	r3, #0
 800d168:	d109      	bne.n	800d17e <HAL_I2S_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hi2s->Lock = HAL_UNLOCKED;
 800d16a:	687b      	ldr	r3, [r7, #4]
 800d16c:	2200      	movs	r2, #0
 800d16e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Initialize Default I2S IrqHandler ISR */
    hi2s->IrqHandlerISR = I2S_IRQHandler;
 800d172:	687b      	ldr	r3, [r7, #4]
 800d174:	4a90      	ldr	r2, [pc, #576]	@ (800d3b8 <HAL_I2S_Init+0x26c>)
 800d176:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hi2s->MspInitCallback(hi2s);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2S_MspInit(hi2s);
 800d178:	6878      	ldr	r0, [r7, #4]
 800d17a:	f7f7 fcb3 	bl	8004ae4 <HAL_I2S_MspInit>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }

  hi2s->State = HAL_I2S_STATE_BUSY;
 800d17e:	687b      	ldr	r3, [r7, #4]
 800d180:	2202      	movs	r2, #2
 800d182:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  CLEAR_BIT(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800d186:	687b      	ldr	r3, [r7, #4]
 800d188:	681b      	ldr	r3, [r3, #0]
 800d18a:	69db      	ldr	r3, [r3, #28]
 800d18c:	687a      	ldr	r2, [r7, #4]
 800d18e:	6812      	ldr	r2, [r2, #0]
 800d190:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 800d194:	f023 030f 	bic.w	r3, r3, #15
 800d198:	61d3      	str	r3, [r2, #28]
                                      SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                      SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
  hi2s->Instance->I2SPR = 0x0002U;
 800d19a:	687b      	ldr	r3, [r7, #4]
 800d19c:	681b      	ldr	r3, [r3, #0]
 800d19e:	2202      	movs	r2, #2
 800d1a0:	621a      	str	r2, [r3, #32]

  /*----------------------- I2SPR: I2SDIV and ODD Calculation -----------------*/
  /* If the requested audio frequency is not the default, compute the prescaler */
  if (hi2s->Init.AudioFreq != I2S_AUDIOFREQ_DEFAULT)
 800d1a2:	687b      	ldr	r3, [r7, #4]
 800d1a4:	695b      	ldr	r3, [r3, #20]
 800d1a6:	2b02      	cmp	r3, #2
 800d1a8:	d060      	beq.n	800d26c <HAL_I2S_Init+0x120>
  {
    /* Check the frame length (For the Prescaler computing) ********************/
    if (hi2s->Init.DataFormat == I2S_DATAFORMAT_16B)
 800d1aa:	687b      	ldr	r3, [r7, #4]
 800d1ac:	68db      	ldr	r3, [r3, #12]
 800d1ae:	2b00      	cmp	r3, #0
 800d1b0:	d102      	bne.n	800d1b8 <HAL_I2S_Init+0x6c>
    {
      /* Packet length is 16 bits */
      packetlength = 16U;
 800d1b2:	2310      	movs	r3, #16
 800d1b4:	617b      	str	r3, [r7, #20]
 800d1b6:	e001      	b.n	800d1bc <HAL_I2S_Init+0x70>
    }
    else
    {
      /* Packet length is 32 bits */
      packetlength = 32U;
 800d1b8:	2320      	movs	r3, #32
 800d1ba:	617b      	str	r3, [r7, #20]
    }

    /* I2S standard */
    if (hi2s->Init.Standard <= I2S_STANDARD_LSB)
 800d1bc:	687b      	ldr	r3, [r7, #4]
 800d1be:	689b      	ldr	r3, [r3, #8]
 800d1c0:	2b20      	cmp	r3, #32
 800d1c2:	d802      	bhi.n	800d1ca <HAL_I2S_Init+0x7e>
    {
      /* In I2S standard packet length is multiplied by 2 */
      packetlength = packetlength * 2U;
 800d1c4:	697b      	ldr	r3, [r7, #20]
 800d1c6:	005b      	lsls	r3, r3, #1
 800d1c8:	617b      	str	r3, [r7, #20]
    else
    {
      i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S_APB2);
    }
#else
    i2sclk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_I2S);
 800d1ca:	2001      	movs	r0, #1
 800d1cc:	f002 fce0 	bl	800fb90 <HAL_RCCEx_GetPeriphCLKFreq>
 800d1d0:	60f8      	str	r0, [r7, #12]
#endif /* I2S_APB1_APB2_FEATURE */

    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if (hi2s->Init.MCLKOutput == I2S_MCLKOUTPUT_ENABLE)
 800d1d2:	687b      	ldr	r3, [r7, #4]
 800d1d4:	691b      	ldr	r3, [r3, #16]
 800d1d6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d1da:	d125      	bne.n	800d228 <HAL_I2S_Init+0xdc>
    {
      /* MCLK output is enabled */
      if (hi2s->Init.DataFormat != I2S_DATAFORMAT_16B)
 800d1dc:	687b      	ldr	r3, [r7, #4]
 800d1de:	68db      	ldr	r3, [r3, #12]
 800d1e0:	2b00      	cmp	r3, #0
 800d1e2:	d010      	beq.n	800d206 <HAL_I2S_Init+0xba>
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 4U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800d1e4:	697b      	ldr	r3, [r7, #20]
 800d1e6:	009b      	lsls	r3, r3, #2
 800d1e8:	68fa      	ldr	r2, [r7, #12]
 800d1ea:	fbb2 f2f3 	udiv	r2, r2, r3
 800d1ee:	4613      	mov	r3, r2
 800d1f0:	009b      	lsls	r3, r3, #2
 800d1f2:	4413      	add	r3, r2
 800d1f4:	005b      	lsls	r3, r3, #1
 800d1f6:	461a      	mov	r2, r3
 800d1f8:	687b      	ldr	r3, [r7, #4]
 800d1fa:	695b      	ldr	r3, [r3, #20]
 800d1fc:	fbb2 f3f3 	udiv	r3, r2, r3
 800d200:	3305      	adds	r3, #5
 800d202:	613b      	str	r3, [r7, #16]
 800d204:	e01f      	b.n	800d246 <HAL_I2S_Init+0xfa>
      }
      else
      {
        tmp = (uint32_t)(((((i2sclk / (packetlength * 8U)) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800d206:	697b      	ldr	r3, [r7, #20]
 800d208:	00db      	lsls	r3, r3, #3
 800d20a:	68fa      	ldr	r2, [r7, #12]
 800d20c:	fbb2 f2f3 	udiv	r2, r2, r3
 800d210:	4613      	mov	r3, r2
 800d212:	009b      	lsls	r3, r3, #2
 800d214:	4413      	add	r3, r2
 800d216:	005b      	lsls	r3, r3, #1
 800d218:	461a      	mov	r2, r3
 800d21a:	687b      	ldr	r3, [r7, #4]
 800d21c:	695b      	ldr	r3, [r3, #20]
 800d21e:	fbb2 f3f3 	udiv	r3, r2, r3
 800d222:	3305      	adds	r3, #5
 800d224:	613b      	str	r3, [r7, #16]
 800d226:	e00e      	b.n	800d246 <HAL_I2S_Init+0xfa>
      }
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint32_t)(((((i2sclk / packetlength) * 10U) / hi2s->Init.AudioFreq)) + 5U);
 800d228:	68fa      	ldr	r2, [r7, #12]
 800d22a:	697b      	ldr	r3, [r7, #20]
 800d22c:	fbb2 f2f3 	udiv	r2, r2, r3
 800d230:	4613      	mov	r3, r2
 800d232:	009b      	lsls	r3, r3, #2
 800d234:	4413      	add	r3, r2
 800d236:	005b      	lsls	r3, r3, #1
 800d238:	461a      	mov	r2, r3
 800d23a:	687b      	ldr	r3, [r7, #4]
 800d23c:	695b      	ldr	r3, [r3, #20]
 800d23e:	fbb2 f3f3 	udiv	r3, r2, r3
 800d242:	3305      	adds	r3, #5
 800d244:	613b      	str	r3, [r7, #16]
    }

    /* Remove the flatting point */
    tmp = tmp / 10U;
 800d246:	693b      	ldr	r3, [r7, #16]
 800d248:	4a5c      	ldr	r2, [pc, #368]	@ (800d3bc <HAL_I2S_Init+0x270>)
 800d24a:	fba2 2303 	umull	r2, r3, r2, r3
 800d24e:	08db      	lsrs	r3, r3, #3
 800d250:	613b      	str	r3, [r7, #16]

    /* Check the parity of the divider */
    i2sodd = (uint32_t)(tmp & (uint32_t)1U);
 800d252:	693b      	ldr	r3, [r7, #16]
 800d254:	f003 0301 	and.w	r3, r3, #1
 800d258:	61bb      	str	r3, [r7, #24]

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint32_t)((tmp - i2sodd) / 2U);
 800d25a:	693a      	ldr	r2, [r7, #16]
 800d25c:	69bb      	ldr	r3, [r7, #24]
 800d25e:	1ad3      	subs	r3, r2, r3
 800d260:	085b      	lsrs	r3, r3, #1
 800d262:	61fb      	str	r3, [r7, #28]

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint32_t)(i2sodd << 8U);
 800d264:	69bb      	ldr	r3, [r7, #24]
 800d266:	021b      	lsls	r3, r3, #8
 800d268:	61bb      	str	r3, [r7, #24]
 800d26a:	e003      	b.n	800d274 <HAL_I2S_Init+0x128>
  }
  else
  {
    /* Set the default values */
    i2sdiv = 2U;
 800d26c:	2302      	movs	r3, #2
 800d26e:	61fb      	str	r3, [r7, #28]
    i2sodd = 0U;
 800d270:	2300      	movs	r3, #0
 800d272:	61bb      	str	r3, [r7, #24]
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
 800d274:	69fb      	ldr	r3, [r7, #28]
 800d276:	2b01      	cmp	r3, #1
 800d278:	d902      	bls.n	800d280 <HAL_I2S_Init+0x134>
 800d27a:	69fb      	ldr	r3, [r7, #28]
 800d27c:	2bff      	cmp	r3, #255	@ 0xff
 800d27e:	d907      	bls.n	800d290 <HAL_I2S_Init+0x144>
  {
    /* Set the error code and execute error callback*/
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_PRESCALER);
 800d280:	687b      	ldr	r3, [r7, #4]
 800d282:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d284:	f043 0210 	orr.w	r2, r3, #16
 800d288:	687b      	ldr	r3, [r7, #4]
 800d28a:	645a      	str	r2, [r3, #68]	@ 0x44
    return  HAL_ERROR;
 800d28c:	2301      	movs	r3, #1
 800d28e:	e08f      	b.n	800d3b0 <HAL_I2S_Init+0x264>
  }

  /*----------------------- SPIx I2SCFGR & I2SPR Configuration ----------------*/

  /* Write to SPIx I2SPR register the computed value */
  hi2s->Instance->I2SPR = (uint32_t)((uint32_t)i2sdiv | (uint32_t)(i2sodd | (uint32_t)hi2s->Init.MCLKOutput));
 800d290:	687b      	ldr	r3, [r7, #4]
 800d292:	691a      	ldr	r2, [r3, #16]
 800d294:	69bb      	ldr	r3, [r7, #24]
 800d296:	ea42 0103 	orr.w	r1, r2, r3
 800d29a:	687b      	ldr	r3, [r7, #4]
 800d29c:	681b      	ldr	r3, [r3, #0]
 800d29e:	69fa      	ldr	r2, [r7, #28]
 800d2a0:	430a      	orrs	r2, r1
 800d2a2:	621a      	str	r2, [r3, #32]

  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  /* And configure the I2S with the I2S_InitStruct values                      */
  MODIFY_REG(hi2s->Instance->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | \
 800d2a4:	687b      	ldr	r3, [r7, #4]
 800d2a6:	681b      	ldr	r3, [r3, #0]
 800d2a8:	69db      	ldr	r3, [r3, #28]
 800d2aa:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 800d2ae:	f023 030f 	bic.w	r3, r3, #15
 800d2b2:	687a      	ldr	r2, [r7, #4]
 800d2b4:	6851      	ldr	r1, [r2, #4]
 800d2b6:	687a      	ldr	r2, [r7, #4]
 800d2b8:	6892      	ldr	r2, [r2, #8]
 800d2ba:	4311      	orrs	r1, r2
 800d2bc:	687a      	ldr	r2, [r7, #4]
 800d2be:	68d2      	ldr	r2, [r2, #12]
 800d2c0:	4311      	orrs	r1, r2
 800d2c2:	687a      	ldr	r2, [r7, #4]
 800d2c4:	6992      	ldr	r2, [r2, #24]
 800d2c6:	430a      	orrs	r2, r1
 800d2c8:	431a      	orrs	r2, r3
 800d2ca:	687b      	ldr	r3, [r7, #4]
 800d2cc:	681b      	ldr	r3, [r3, #0]
 800d2ce:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800d2d2:	61da      	str	r2, [r3, #28]
#if defined (SPI_I2S_FULLDUPLEX_SUPPORT)

  /* Configure the I2S extended if the full duplex mode is enabled */
  assert_param(IS_I2S_FULLDUPLEX_MODE(hi2s->Init.FullDuplexMode));

  if (hi2s->Init.FullDuplexMode == I2S_FULLDUPLEXMODE_ENABLE)
 800d2d4:	687b      	ldr	r3, [r7, #4]
 800d2d6:	6a1b      	ldr	r3, [r3, #32]
 800d2d8:	2b01      	cmp	r3, #1
 800d2da:	d161      	bne.n	800d3a0 <HAL_I2S_Init+0x254>
  {
    /* Set FullDuplex I2S IrqHandler ISR if FULLDUPLEXMODE is enabled */
    hi2s->IrqHandlerISR = HAL_I2SEx_FullDuplex_IRQHandler;
 800d2dc:	687b      	ldr	r3, [r7, #4]
 800d2de:	4a38      	ldr	r2, [pc, #224]	@ (800d3c0 <HAL_I2S_Init+0x274>)
 800d2e0:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    CLEAR_BIT(I2SxEXT(hi2s->Instance)->I2SCFGR, (SPI_I2SCFGR_CHLEN | SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CKPOL | \
 800d2e2:	687b      	ldr	r3, [r7, #4]
 800d2e4:	681b      	ldr	r3, [r3, #0]
 800d2e6:	4a37      	ldr	r2, [pc, #220]	@ (800d3c4 <HAL_I2S_Init+0x278>)
 800d2e8:	4293      	cmp	r3, r2
 800d2ea:	d101      	bne.n	800d2f0 <HAL_I2S_Init+0x1a4>
 800d2ec:	4b36      	ldr	r3, [pc, #216]	@ (800d3c8 <HAL_I2S_Init+0x27c>)
 800d2ee:	e001      	b.n	800d2f4 <HAL_I2S_Init+0x1a8>
 800d2f0:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d2f4:	69db      	ldr	r3, [r3, #28]
 800d2f6:	687a      	ldr	r2, [r7, #4]
 800d2f8:	6812      	ldr	r2, [r2, #0]
 800d2fa:	4932      	ldr	r1, [pc, #200]	@ (800d3c4 <HAL_I2S_Init+0x278>)
 800d2fc:	428a      	cmp	r2, r1
 800d2fe:	d101      	bne.n	800d304 <HAL_I2S_Init+0x1b8>
 800d300:	4a31      	ldr	r2, [pc, #196]	@ (800d3c8 <HAL_I2S_Init+0x27c>)
 800d302:	e001      	b.n	800d308 <HAL_I2S_Init+0x1bc>
 800d304:	f04f 2240 	mov.w	r2, #1073758208	@ 0x40004000
 800d308:	f423 637b 	bic.w	r3, r3, #4016	@ 0xfb0
 800d30c:	f023 030f 	bic.w	r3, r3, #15
 800d310:	61d3      	str	r3, [r2, #28]
                                                 SPI_I2SCFGR_I2SSTD | SPI_I2SCFGR_PCMSYNC | SPI_I2SCFGR_I2SCFG | \
                                                 SPI_I2SCFGR_I2SE | SPI_I2SCFGR_I2SMOD));
    I2SxEXT(hi2s->Instance)->I2SPR = 2U;
 800d312:	687b      	ldr	r3, [r7, #4]
 800d314:	681b      	ldr	r3, [r3, #0]
 800d316:	4a2b      	ldr	r2, [pc, #172]	@ (800d3c4 <HAL_I2S_Init+0x278>)
 800d318:	4293      	cmp	r3, r2
 800d31a:	d101      	bne.n	800d320 <HAL_I2S_Init+0x1d4>
 800d31c:	4b2a      	ldr	r3, [pc, #168]	@ (800d3c8 <HAL_I2S_Init+0x27c>)
 800d31e:	e001      	b.n	800d324 <HAL_I2S_Init+0x1d8>
 800d320:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d324:	2202      	movs	r2, #2
 800d326:	621a      	str	r2, [r3, #32]

    /* Get the I2SCFGR register value */
    tmpreg = I2SxEXT(hi2s->Instance)->I2SCFGR;
 800d328:	687b      	ldr	r3, [r7, #4]
 800d32a:	681b      	ldr	r3, [r3, #0]
 800d32c:	4a25      	ldr	r2, [pc, #148]	@ (800d3c4 <HAL_I2S_Init+0x278>)
 800d32e:	4293      	cmp	r3, r2
 800d330:	d101      	bne.n	800d336 <HAL_I2S_Init+0x1ea>
 800d332:	4b25      	ldr	r3, [pc, #148]	@ (800d3c8 <HAL_I2S_Init+0x27c>)
 800d334:	e001      	b.n	800d33a <HAL_I2S_Init+0x1ee>
 800d336:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d33a:	69db      	ldr	r3, [r3, #28]
 800d33c:	817b      	strh	r3, [r7, #10]

    /* Get the mode to be configured for the extended I2S */
    if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 800d33e:	687b      	ldr	r3, [r7, #4]
 800d340:	685b      	ldr	r3, [r3, #4]
 800d342:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d346:	d003      	beq.n	800d350 <HAL_I2S_Init+0x204>
 800d348:	687b      	ldr	r3, [r7, #4]
 800d34a:	685b      	ldr	r3, [r3, #4]
 800d34c:	2b00      	cmp	r3, #0
 800d34e:	d103      	bne.n	800d358 <HAL_I2S_Init+0x20c>
    {
      tmp = I2S_MODE_SLAVE_RX;
 800d350:	f44f 7380 	mov.w	r3, #256	@ 0x100
 800d354:	613b      	str	r3, [r7, #16]
 800d356:	e001      	b.n	800d35c <HAL_I2S_Init+0x210>
    }
    else /* I2S_MODE_MASTER_RX ||  I2S_MODE_SLAVE_RX */
    {
      tmp = I2S_MODE_SLAVE_TX;
 800d358:	2300      	movs	r3, #0
 800d35a:	613b      	str	r3, [r7, #16]
    }

    /* Configure the I2S Slave with the I2S Master parameter values */
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
                         (uint16_t)tmp                   | \
 800d35c:	693b      	ldr	r3, [r7, #16]
 800d35e:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.Standard   | \
 800d360:	687b      	ldr	r3, [r7, #4]
 800d362:	689b      	ldr	r3, [r3, #8]
 800d364:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 800d366:	4313      	orrs	r3, r2
 800d368:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.DataFormat | \
 800d36a:	687b      	ldr	r3, [r7, #4]
 800d36c:	68db      	ldr	r3, [r3, #12]
 800d36e:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 800d370:	4313      	orrs	r3, r2
 800d372:	b29a      	uxth	r2, r3
                         (uint16_t)hi2s->Init.CPOL);
 800d374:	687b      	ldr	r3, [r7, #4]
 800d376:	699b      	ldr	r3, [r3, #24]
 800d378:	b29b      	uxth	r3, r3
    tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD    | \
 800d37a:	4313      	orrs	r3, r2
 800d37c:	b29a      	uxth	r2, r3
 800d37e:	897b      	ldrh	r3, [r7, #10]
 800d380:	4313      	orrs	r3, r2
 800d382:	b29b      	uxth	r3, r3
 800d384:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 800d388:	817b      	strh	r3, [r7, #10]

    /* Write to SPIx I2SCFGR */
    WRITE_REG(I2SxEXT(hi2s->Instance)->I2SCFGR, tmpreg);
 800d38a:	687b      	ldr	r3, [r7, #4]
 800d38c:	681b      	ldr	r3, [r3, #0]
 800d38e:	4a0d      	ldr	r2, [pc, #52]	@ (800d3c4 <HAL_I2S_Init+0x278>)
 800d390:	4293      	cmp	r3, r2
 800d392:	d101      	bne.n	800d398 <HAL_I2S_Init+0x24c>
 800d394:	4b0c      	ldr	r3, [pc, #48]	@ (800d3c8 <HAL_I2S_Init+0x27c>)
 800d396:	e001      	b.n	800d39c <HAL_I2S_Init+0x250>
 800d398:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d39c:	897a      	ldrh	r2, [r7, #10]
 800d39e:	61da      	str	r2, [r3, #28]
  }
#endif /* SPI_I2S_FULLDUPLEX_SUPPORT */

  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 800d3a0:	687b      	ldr	r3, [r7, #4]
 800d3a2:	2200      	movs	r2, #0
 800d3a4:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2s->State     = HAL_I2S_STATE_READY;
 800d3a6:	687b      	ldr	r3, [r7, #4]
 800d3a8:	2201      	movs	r2, #1
 800d3aa:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  return HAL_OK;
 800d3ae:	2300      	movs	r3, #0
}
 800d3b0:	4618      	mov	r0, r3
 800d3b2:	3720      	adds	r7, #32
 800d3b4:	46bd      	mov	sp, r7
 800d3b6:	bd80      	pop	{r7, pc}
 800d3b8:	0800d6c1 	.word	0x0800d6c1
 800d3bc:	cccccccd 	.word	0xcccccccd
 800d3c0:	0800d7d5 	.word	0x0800d7d5
 800d3c4:	40003800 	.word	0x40003800
 800d3c8:	40003400 	.word	0x40003400

0800d3cc <HAL_I2S_Transmit_DMA>:
  * @note   The I2S is kept enabled at the end of transaction to avoid the clock de-synchronization
  *         between Master and Slave(example: audio streaming).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2S_Transmit_DMA(I2S_HandleTypeDef *hi2s, uint16_t *pData, uint16_t Size)
{
 800d3cc:	b580      	push	{r7, lr}
 800d3ce:	b086      	sub	sp, #24
 800d3d0:	af00      	add	r7, sp, #0
 800d3d2:	60f8      	str	r0, [r7, #12]
 800d3d4:	60b9      	str	r1, [r7, #8]
 800d3d6:	4613      	mov	r3, r2
 800d3d8:	80fb      	strh	r3, [r7, #6]
  uint32_t tmpreg_cfgr;

  if ((pData == NULL) || (Size == 0U))
 800d3da:	68bb      	ldr	r3, [r7, #8]
 800d3dc:	2b00      	cmp	r3, #0
 800d3de:	d002      	beq.n	800d3e6 <HAL_I2S_Transmit_DMA+0x1a>
 800d3e0:	88fb      	ldrh	r3, [r7, #6]
 800d3e2:	2b00      	cmp	r3, #0
 800d3e4:	d101      	bne.n	800d3ea <HAL_I2S_Transmit_DMA+0x1e>
  {
    return  HAL_ERROR;
 800d3e6:	2301      	movs	r3, #1
 800d3e8:	e08e      	b.n	800d508 <HAL_I2S_Transmit_DMA+0x13c>
  }

  /* Process Locked */
  __HAL_LOCK(hi2s);
 800d3ea:	68fb      	ldr	r3, [r7, #12]
 800d3ec:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 800d3f0:	b2db      	uxtb	r3, r3
 800d3f2:	2b01      	cmp	r3, #1
 800d3f4:	d101      	bne.n	800d3fa <HAL_I2S_Transmit_DMA+0x2e>
 800d3f6:	2302      	movs	r3, #2
 800d3f8:	e086      	b.n	800d508 <HAL_I2S_Transmit_DMA+0x13c>
 800d3fa:	68fb      	ldr	r3, [r7, #12]
 800d3fc:	2201      	movs	r2, #1
 800d3fe:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

  if (hi2s->State != HAL_I2S_STATE_READY)
 800d402:	68fb      	ldr	r3, [r7, #12]
 800d404:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800d408:	b2db      	uxtb	r3, r3
 800d40a:	2b01      	cmp	r3, #1
 800d40c:	d005      	beq.n	800d41a <HAL_I2S_Transmit_DMA+0x4e>
  {
    __HAL_UNLOCK(hi2s);
 800d40e:	68fb      	ldr	r3, [r7, #12]
 800d410:	2200      	movs	r2, #0
 800d412:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    return HAL_BUSY;
 800d416:	2302      	movs	r3, #2
 800d418:	e076      	b.n	800d508 <HAL_I2S_Transmit_DMA+0x13c>
  }

  /* Set state and reset error code */
  hi2s->State = HAL_I2S_STATE_BUSY_TX;
 800d41a:	68fb      	ldr	r3, [r7, #12]
 800d41c:	2203      	movs	r2, #3
 800d41e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2s->ErrorCode = HAL_I2S_ERROR_NONE;
 800d422:	68fb      	ldr	r3, [r7, #12]
 800d424:	2200      	movs	r2, #0
 800d426:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2s->pTxBuffPtr = pData;
 800d428:	68fb      	ldr	r3, [r7, #12]
 800d42a:	68ba      	ldr	r2, [r7, #8]
 800d42c:	625a      	str	r2, [r3, #36]	@ 0x24

  tmpreg_cfgr = hi2s->Instance->I2SCFGR & (SPI_I2SCFGR_DATLEN | SPI_I2SCFGR_CHLEN);
 800d42e:	68fb      	ldr	r3, [r7, #12]
 800d430:	681b      	ldr	r3, [r3, #0]
 800d432:	69db      	ldr	r3, [r3, #28]
 800d434:	f003 0307 	and.w	r3, r3, #7
 800d438:	617b      	str	r3, [r7, #20]

  if ((tmpreg_cfgr == I2S_DATAFORMAT_24B) || (tmpreg_cfgr == I2S_DATAFORMAT_32B))
 800d43a:	697b      	ldr	r3, [r7, #20]
 800d43c:	2b03      	cmp	r3, #3
 800d43e:	d002      	beq.n	800d446 <HAL_I2S_Transmit_DMA+0x7a>
 800d440:	697b      	ldr	r3, [r7, #20]
 800d442:	2b05      	cmp	r3, #5
 800d444:	d10a      	bne.n	800d45c <HAL_I2S_Transmit_DMA+0x90>
  {
    hi2s->TxXferSize = (Size << 1U);
 800d446:	88fb      	ldrh	r3, [r7, #6]
 800d448:	005b      	lsls	r3, r3, #1
 800d44a:	b29a      	uxth	r2, r3
 800d44c:	68fb      	ldr	r3, [r7, #12]
 800d44e:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2s->TxXferCount = (Size << 1U);
 800d450:	88fb      	ldrh	r3, [r7, #6]
 800d452:	005b      	lsls	r3, r3, #1
 800d454:	b29a      	uxth	r2, r3
 800d456:	68fb      	ldr	r3, [r7, #12]
 800d458:	855a      	strh	r2, [r3, #42]	@ 0x2a
 800d45a:	e005      	b.n	800d468 <HAL_I2S_Transmit_DMA+0x9c>
  }
  else
  {
    hi2s->TxXferSize = Size;
 800d45c:	68fb      	ldr	r3, [r7, #12]
 800d45e:	88fa      	ldrh	r2, [r7, #6]
 800d460:	851a      	strh	r2, [r3, #40]	@ 0x28
    hi2s->TxXferCount = Size;
 800d462:	68fb      	ldr	r3, [r7, #12]
 800d464:	88fa      	ldrh	r2, [r7, #6]
 800d466:	855a      	strh	r2, [r3, #42]	@ 0x2a
  }

  /* Set the I2S Tx DMA Half transfer complete callback */
  hi2s->hdmatx->XferHalfCpltCallback = I2S_DMATxHalfCplt;
 800d468:	68fb      	ldr	r3, [r7, #12]
 800d46a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d46c:	4a28      	ldr	r2, [pc, #160]	@ (800d510 <HAL_I2S_Transmit_DMA+0x144>)
 800d46e:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Set the I2S Tx DMA transfer complete callback */
  hi2s->hdmatx->XferCpltCallback = I2S_DMATxCplt;
 800d470:	68fb      	ldr	r3, [r7, #12]
 800d472:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d474:	4a27      	ldr	r2, [pc, #156]	@ (800d514 <HAL_I2S_Transmit_DMA+0x148>)
 800d476:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Set the DMA error callback */
  hi2s->hdmatx->XferErrorCallback = I2S_DMAError;
 800d478:	68fb      	ldr	r3, [r7, #12]
 800d47a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d47c:	4a26      	ldr	r2, [pc, #152]	@ (800d518 <HAL_I2S_Transmit_DMA+0x14c>)
 800d47e:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Enable the Tx DMA Stream/Channel */
  if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmatx,
 800d480:	68fb      	ldr	r3, [r7, #12]
 800d482:	6b98      	ldr	r0, [r3, #56]	@ 0x38
                                 (uint32_t)hi2s->pTxBuffPtr,
 800d484:	68fb      	ldr	r3, [r7, #12]
 800d486:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
  if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmatx,
 800d488:	4619      	mov	r1, r3
                                 (uint32_t)&hi2s->Instance->DR,
 800d48a:	68fb      	ldr	r3, [r7, #12]
 800d48c:	681b      	ldr	r3, [r3, #0]
 800d48e:	330c      	adds	r3, #12
  if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmatx,
 800d490:	461a      	mov	r2, r3
                                 hi2s->TxXferSize))
 800d492:	68fb      	ldr	r3, [r7, #12]
 800d494:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800d496:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hi2s->hdmatx,
 800d498:	f7fb fe74 	bl	8009184 <HAL_DMA_Start_IT>
 800d49c:	4603      	mov	r3, r0
 800d49e:	2b00      	cmp	r3, #0
 800d4a0:	d00f      	beq.n	800d4c2 <HAL_I2S_Transmit_DMA+0xf6>
  {
    /* Update SPI error code */
    SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
 800d4a2:	68fb      	ldr	r3, [r7, #12]
 800d4a4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d4a6:	f043 0208 	orr.w	r2, r3, #8
 800d4aa:	68fb      	ldr	r3, [r7, #12]
 800d4ac:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2s->State = HAL_I2S_STATE_READY;
 800d4ae:	68fb      	ldr	r3, [r7, #12]
 800d4b0:	2201      	movs	r2, #1
 800d4b2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    __HAL_UNLOCK(hi2s);
 800d4b6:	68fb      	ldr	r3, [r7, #12]
 800d4b8:	2200      	movs	r2, #0
 800d4ba:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    return HAL_ERROR;
 800d4be:	2301      	movs	r3, #1
 800d4c0:	e022      	b.n	800d508 <HAL_I2S_Transmit_DMA+0x13c>
  }

  /* Check if the I2S is already enabled */
  if (HAL_IS_BIT_CLR(hi2s->Instance->I2SCFGR, SPI_I2SCFGR_I2SE))
 800d4c2:	68fb      	ldr	r3, [r7, #12]
 800d4c4:	681b      	ldr	r3, [r3, #0]
 800d4c6:	69db      	ldr	r3, [r3, #28]
 800d4c8:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 800d4cc:	2b00      	cmp	r3, #0
 800d4ce:	d107      	bne.n	800d4e0 <HAL_I2S_Transmit_DMA+0x114>
  {
    /* Enable I2S peripheral */
    __HAL_I2S_ENABLE(hi2s);
 800d4d0:	68fb      	ldr	r3, [r7, #12]
 800d4d2:	681b      	ldr	r3, [r3, #0]
 800d4d4:	69da      	ldr	r2, [r3, #28]
 800d4d6:	68fb      	ldr	r3, [r7, #12]
 800d4d8:	681b      	ldr	r3, [r3, #0]
 800d4da:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 800d4de:	61da      	str	r2, [r3, #28]
  }

  /* Check if the I2S Tx request is already enabled */
  if (HAL_IS_BIT_CLR(hi2s->Instance->CR2, SPI_CR2_TXDMAEN))
 800d4e0:	68fb      	ldr	r3, [r7, #12]
 800d4e2:	681b      	ldr	r3, [r3, #0]
 800d4e4:	685b      	ldr	r3, [r3, #4]
 800d4e6:	f003 0302 	and.w	r3, r3, #2
 800d4ea:	2b00      	cmp	r3, #0
 800d4ec:	d107      	bne.n	800d4fe <HAL_I2S_Transmit_DMA+0x132>
  {
    /* Enable Tx DMA Request */
    SET_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
 800d4ee:	68fb      	ldr	r3, [r7, #12]
 800d4f0:	681b      	ldr	r3, [r3, #0]
 800d4f2:	685a      	ldr	r2, [r3, #4]
 800d4f4:	68fb      	ldr	r3, [r7, #12]
 800d4f6:	681b      	ldr	r3, [r3, #0]
 800d4f8:	f042 0202 	orr.w	r2, r2, #2
 800d4fc:	605a      	str	r2, [r3, #4]
  }

  __HAL_UNLOCK(hi2s);
 800d4fe:	68fb      	ldr	r3, [r7, #12]
 800d500:	2200      	movs	r2, #0
 800d502:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  return HAL_OK;
 800d506:	2300      	movs	r3, #0
}
 800d508:	4618      	mov	r0, r3
 800d50a:	3718      	adds	r7, #24
 800d50c:	46bd      	mov	sp, r7
 800d50e:	bd80      	pop	{r7, pc}
 800d510:	0800d59f 	.word	0x0800d59f
 800d514:	0800d55d 	.word	0x0800d55d
 800d518:	0800d5bb 	.word	0x0800d5bb

0800d51c <HAL_I2S_IRQHandler>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
void HAL_I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 800d51c:	b580      	push	{r7, lr}
 800d51e:	b082      	sub	sp, #8
 800d520:	af00      	add	r7, sp, #0
 800d522:	6078      	str	r0, [r7, #4]
  /* Call the IrqHandler ISR set during HAL_I2S_INIT */
  hi2s->IrqHandlerISR(hi2s);
 800d524:	687b      	ldr	r3, [r7, #4]
 800d526:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800d528:	6878      	ldr	r0, [r7, #4]
 800d52a:	4798      	blx	r3
}
 800d52c:	bf00      	nop
 800d52e:	3708      	adds	r7, #8
 800d530:	46bd      	mov	sp, r7
 800d532:	bd80      	pop	{r7, pc}

0800d534 <HAL_I2S_TxHalfCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_TxHalfCpltCallback(I2S_HandleTypeDef *hi2s)
{
 800d534:	b480      	push	{r7}
 800d536:	b083      	sub	sp, #12
 800d538:	af00      	add	r7, sp, #0
 800d53a:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_TxHalfCpltCallback could be implemented in the user file
   */
}
 800d53c:	bf00      	nop
 800d53e:	370c      	adds	r7, #12
 800d540:	46bd      	mov	sp, r7
 800d542:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d546:	4770      	bx	lr

0800d548 <HAL_I2S_RxCpltCallback>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
__weak void HAL_I2S_RxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 800d548:	b480      	push	{r7}
 800d54a:	b083      	sub	sp, #12
 800d54c:	af00      	add	r7, sp, #0
 800d54e:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_I2S_RxCpltCallback could be implemented in the user file
   */
}
 800d550:	bf00      	nop
 800d552:	370c      	adds	r7, #12
 800d554:	46bd      	mov	sp, r7
 800d556:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d55a:	4770      	bx	lr

0800d55c <I2S_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void I2S_DMATxCplt(DMA_HandleTypeDef *hdma)
{
 800d55c:	b580      	push	{r7, lr}
 800d55e:	b084      	sub	sp, #16
 800d560:	af00      	add	r7, sp, #0
 800d562:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 800d564:	687b      	ldr	r3, [r7, #4]
 800d566:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d568:	60fb      	str	r3, [r7, #12]

  /* if DMA is configured in DMA_NORMAL Mode */
  if (hdma->Init.Mode == DMA_NORMAL)
 800d56a:	687b      	ldr	r3, [r7, #4]
 800d56c:	69db      	ldr	r3, [r3, #28]
 800d56e:	2b00      	cmp	r3, #0
 800d570:	d10e      	bne.n	800d590 <I2S_DMATxCplt+0x34>
  {
    /* Disable Tx DMA Request */
    CLEAR_BIT(hi2s->Instance->CR2, SPI_CR2_TXDMAEN);
 800d572:	68fb      	ldr	r3, [r7, #12]
 800d574:	681b      	ldr	r3, [r3, #0]
 800d576:	685a      	ldr	r2, [r3, #4]
 800d578:	68fb      	ldr	r3, [r7, #12]
 800d57a:	681b      	ldr	r3, [r3, #0]
 800d57c:	f022 0202 	bic.w	r2, r2, #2
 800d580:	605a      	str	r2, [r3, #4]

    hi2s->TxXferCount = 0U;
 800d582:	68fb      	ldr	r3, [r7, #12]
 800d584:	2200      	movs	r2, #0
 800d586:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2s->State = HAL_I2S_STATE_READY;
 800d588:	68fb      	ldr	r3, [r7, #12]
 800d58a:	2201      	movs	r2, #1
 800d58c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  }
  /* Call user Tx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
  hi2s->TxCpltCallback(hi2s);
#else
  HAL_I2S_TxCpltCallback(hi2s);
 800d590:	68f8      	ldr	r0, [r7, #12]
 800d592:	f7f7 fa3d 	bl	8004a10 <HAL_I2S_TxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
}
 800d596:	bf00      	nop
 800d598:	3710      	adds	r7, #16
 800d59a:	46bd      	mov	sp, r7
 800d59c:	bd80      	pop	{r7, pc}

0800d59e <I2S_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void I2S_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800d59e:	b580      	push	{r7, lr}
 800d5a0:	b084      	sub	sp, #16
 800d5a2:	af00      	add	r7, sp, #0
 800d5a4:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 800d5a6:	687b      	ldr	r3, [r7, #4]
 800d5a8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d5aa:	60fb      	str	r3, [r7, #12]

  /* Call user Tx half complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
  hi2s->TxHalfCpltCallback(hi2s);
#else
  HAL_I2S_TxHalfCpltCallback(hi2s);
 800d5ac:	68f8      	ldr	r0, [r7, #12]
 800d5ae:	f7ff ffc1 	bl	800d534 <HAL_I2S_TxHalfCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
}
 800d5b2:	bf00      	nop
 800d5b4:	3710      	adds	r7, #16
 800d5b6:	46bd      	mov	sp, r7
 800d5b8:	bd80      	pop	{r7, pc}

0800d5ba <I2S_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
static void I2S_DMAError(DMA_HandleTypeDef *hdma)
{
 800d5ba:	b580      	push	{r7, lr}
 800d5bc:	b084      	sub	sp, #16
 800d5be:	af00      	add	r7, sp, #0
 800d5c0:	6078      	str	r0, [r7, #4]
  I2S_HandleTypeDef *hi2s = (I2S_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent; /* Derogation MISRAC2012-Rule-11.5 */
 800d5c2:	687b      	ldr	r3, [r7, #4]
 800d5c4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800d5c6:	60fb      	str	r3, [r7, #12]

  /* Disable Rx and Tx DMA Request */
  CLEAR_BIT(hi2s->Instance->CR2, (SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN));
 800d5c8:	68fb      	ldr	r3, [r7, #12]
 800d5ca:	681b      	ldr	r3, [r3, #0]
 800d5cc:	685a      	ldr	r2, [r3, #4]
 800d5ce:	68fb      	ldr	r3, [r7, #12]
 800d5d0:	681b      	ldr	r3, [r3, #0]
 800d5d2:	f022 0203 	bic.w	r2, r2, #3
 800d5d6:	605a      	str	r2, [r3, #4]
  hi2s->TxXferCount = 0U;
 800d5d8:	68fb      	ldr	r3, [r7, #12]
 800d5da:	2200      	movs	r2, #0
 800d5dc:	855a      	strh	r2, [r3, #42]	@ 0x2a
  hi2s->RxXferCount = 0U;
 800d5de:	68fb      	ldr	r3, [r7, #12]
 800d5e0:	2200      	movs	r2, #0
 800d5e2:	865a      	strh	r2, [r3, #50]	@ 0x32

  hi2s->State = HAL_I2S_STATE_READY;
 800d5e4:	68fb      	ldr	r3, [r7, #12]
 800d5e6:	2201      	movs	r2, #1
 800d5e8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Set the error code and execute error callback*/
  SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_DMA);
 800d5ec:	68fb      	ldr	r3, [r7, #12]
 800d5ee:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d5f0:	f043 0208 	orr.w	r2, r3, #8
 800d5f4:	68fb      	ldr	r3, [r7, #12]
 800d5f6:	645a      	str	r2, [r3, #68]	@ 0x44
  /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
  hi2s->ErrorCallback(hi2s);
#else
  HAL_I2S_ErrorCallback(hi2s);
 800d5f8:	68f8      	ldr	r0, [r7, #12]
 800d5fa:	f7f7 fa69 	bl	8004ad0 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
}
 800d5fe:	bf00      	nop
 800d600:	3710      	adds	r7, #16
 800d602:	46bd      	mov	sp, r7
 800d604:	bd80      	pop	{r7, pc}

0800d606 <I2S_Transmit_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Transmit_IT(I2S_HandleTypeDef *hi2s)
{
 800d606:	b580      	push	{r7, lr}
 800d608:	b082      	sub	sp, #8
 800d60a:	af00      	add	r7, sp, #0
 800d60c:	6078      	str	r0, [r7, #4]
  /* Transmit data */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr);
 800d60e:	687b      	ldr	r3, [r7, #4]
 800d610:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d612:	881a      	ldrh	r2, [r3, #0]
 800d614:	687b      	ldr	r3, [r7, #4]
 800d616:	681b      	ldr	r3, [r3, #0]
 800d618:	60da      	str	r2, [r3, #12]
  hi2s->pTxBuffPtr++;
 800d61a:	687b      	ldr	r3, [r7, #4]
 800d61c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d61e:	1c9a      	adds	r2, r3, #2
 800d620:	687b      	ldr	r3, [r7, #4]
 800d622:	625a      	str	r2, [r3, #36]	@ 0x24
  hi2s->TxXferCount--;
 800d624:	687b      	ldr	r3, [r7, #4]
 800d626:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800d628:	b29b      	uxth	r3, r3
 800d62a:	3b01      	subs	r3, #1
 800d62c:	b29a      	uxth	r2, r3
 800d62e:	687b      	ldr	r3, [r7, #4]
 800d630:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 800d632:	687b      	ldr	r3, [r7, #4]
 800d634:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800d636:	b29b      	uxth	r3, r3
 800d638:	2b00      	cmp	r3, #0
 800d63a:	d10e      	bne.n	800d65a <I2S_Transmit_IT+0x54>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800d63c:	687b      	ldr	r3, [r7, #4]
 800d63e:	681b      	ldr	r3, [r3, #0]
 800d640:	685a      	ldr	r2, [r3, #4]
 800d642:	687b      	ldr	r3, [r7, #4]
 800d644:	681b      	ldr	r3, [r3, #0]
 800d646:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800d64a:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 800d64c:	687b      	ldr	r3, [r7, #4]
 800d64e:	2201      	movs	r2, #1
 800d650:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Tx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->TxCpltCallback(hi2s);
#else
    HAL_I2S_TxCpltCallback(hi2s);
 800d654:	6878      	ldr	r0, [r7, #4]
 800d656:	f7f7 f9db 	bl	8004a10 <HAL_I2S_TxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 800d65a:	bf00      	nop
 800d65c:	3708      	adds	r7, #8
 800d65e:	46bd      	mov	sp, r7
 800d660:	bd80      	pop	{r7, pc}

0800d662 <I2S_Receive_IT>:
  * @param  hi2s pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_Receive_IT(I2S_HandleTypeDef *hi2s)
{
 800d662:	b580      	push	{r7, lr}
 800d664:	b082      	sub	sp, #8
 800d666:	af00      	add	r7, sp, #0
 800d668:	6078      	str	r0, [r7, #4]
  /* Receive data */
  (*hi2s->pRxBuffPtr) = (uint16_t)hi2s->Instance->DR;
 800d66a:	687b      	ldr	r3, [r7, #4]
 800d66c:	681b      	ldr	r3, [r3, #0]
 800d66e:	68da      	ldr	r2, [r3, #12]
 800d670:	687b      	ldr	r3, [r7, #4]
 800d672:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800d674:	b292      	uxth	r2, r2
 800d676:	801a      	strh	r2, [r3, #0]
  hi2s->pRxBuffPtr++;
 800d678:	687b      	ldr	r3, [r7, #4]
 800d67a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800d67c:	1c9a      	adds	r2, r3, #2
 800d67e:	687b      	ldr	r3, [r7, #4]
 800d680:	62da      	str	r2, [r3, #44]	@ 0x2c
  hi2s->RxXferCount--;
 800d682:	687b      	ldr	r3, [r7, #4]
 800d684:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800d686:	b29b      	uxth	r3, r3
 800d688:	3b01      	subs	r3, #1
 800d68a:	b29a      	uxth	r2, r3
 800d68c:	687b      	ldr	r3, [r7, #4]
 800d68e:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 800d690:	687b      	ldr	r3, [r7, #4]
 800d692:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800d694:	b29b      	uxth	r3, r3
 800d696:	2b00      	cmp	r3, #0
 800d698:	d10e      	bne.n	800d6b8 <I2S_Receive_IT+0x56>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800d69a:	687b      	ldr	r3, [r7, #4]
 800d69c:	681b      	ldr	r3, [r3, #0]
 800d69e:	685a      	ldr	r2, [r3, #4]
 800d6a0:	687b      	ldr	r3, [r7, #4]
 800d6a2:	681b      	ldr	r3, [r3, #0]
 800d6a4:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800d6a8:	605a      	str	r2, [r3, #4]

    hi2s->State = HAL_I2S_STATE_READY;
 800d6aa:	687b      	ldr	r3, [r7, #4]
 800d6ac:	2201      	movs	r2, #1
 800d6ae:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    /* Call user Rx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
    hi2s->RxCpltCallback(hi2s);
#else
    HAL_I2S_RxCpltCallback(hi2s);
 800d6b2:	6878      	ldr	r0, [r7, #4]
 800d6b4:	f7ff ff48 	bl	800d548 <HAL_I2S_RxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
  }
}
 800d6b8:	bf00      	nop
 800d6ba:	3708      	adds	r7, #8
 800d6bc:	46bd      	mov	sp, r7
 800d6be:	bd80      	pop	{r7, pc}

0800d6c0 <I2S_IRQHandler>:
  * @param  hi2s: pointer to a I2S_HandleTypeDef structure that contains
  *         the configuration information for I2S module
  * @retval None
  */
static void I2S_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 800d6c0:	b580      	push	{r7, lr}
 800d6c2:	b086      	sub	sp, #24
 800d6c4:	af00      	add	r7, sp, #0
 800d6c6:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr = hi2s->Instance->SR;
 800d6c8:	687b      	ldr	r3, [r7, #4]
 800d6ca:	681b      	ldr	r3, [r3, #0]
 800d6cc:	689b      	ldr	r3, [r3, #8]
 800d6ce:	617b      	str	r3, [r7, #20]

  if (hi2s->State == HAL_I2S_STATE_BUSY_RX)
 800d6d0:	687b      	ldr	r3, [r7, #4]
 800d6d2:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800d6d6:	b2db      	uxtb	r3, r3
 800d6d8:	2b04      	cmp	r3, #4
 800d6da:	d13a      	bne.n	800d752 <I2S_IRQHandler+0x92>
  {
    /* I2S in mode Receiver ------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_RXNE) != RESET))
 800d6dc:	697b      	ldr	r3, [r7, #20]
 800d6de:	f003 0301 	and.w	r3, r3, #1
 800d6e2:	2b01      	cmp	r3, #1
 800d6e4:	d109      	bne.n	800d6fa <I2S_IRQHandler+0x3a>
 800d6e6:	687b      	ldr	r3, [r7, #4]
 800d6e8:	681b      	ldr	r3, [r3, #0]
 800d6ea:	685b      	ldr	r3, [r3, #4]
 800d6ec:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800d6f0:	2b40      	cmp	r3, #64	@ 0x40
 800d6f2:	d102      	bne.n	800d6fa <I2S_IRQHandler+0x3a>
    {
      I2S_Receive_IT(hi2s);
 800d6f4:	6878      	ldr	r0, [r7, #4]
 800d6f6:	f7ff ffb4 	bl	800d662 <I2S_Receive_IT>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 800d6fa:	697b      	ldr	r3, [r7, #20]
 800d6fc:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800d700:	2b40      	cmp	r3, #64	@ 0x40
 800d702:	d126      	bne.n	800d752 <I2S_IRQHandler+0x92>
 800d704:	687b      	ldr	r3, [r7, #4]
 800d706:	681b      	ldr	r3, [r3, #0]
 800d708:	685b      	ldr	r3, [r3, #4]
 800d70a:	f003 0320 	and.w	r3, r3, #32
 800d70e:	2b20      	cmp	r3, #32
 800d710:	d11f      	bne.n	800d752 <I2S_IRQHandler+0x92>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800d712:	687b      	ldr	r3, [r7, #4]
 800d714:	681b      	ldr	r3, [r3, #0]
 800d716:	685a      	ldr	r2, [r3, #4]
 800d718:	687b      	ldr	r3, [r7, #4]
 800d71a:	681b      	ldr	r3, [r3, #0]
 800d71c:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800d720:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 800d722:	2300      	movs	r3, #0
 800d724:	613b      	str	r3, [r7, #16]
 800d726:	687b      	ldr	r3, [r7, #4]
 800d728:	681b      	ldr	r3, [r3, #0]
 800d72a:	68db      	ldr	r3, [r3, #12]
 800d72c:	613b      	str	r3, [r7, #16]
 800d72e:	687b      	ldr	r3, [r7, #4]
 800d730:	681b      	ldr	r3, [r3, #0]
 800d732:	689b      	ldr	r3, [r3, #8]
 800d734:	613b      	str	r3, [r7, #16]
 800d736:	693b      	ldr	r3, [r7, #16]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800d738:	687b      	ldr	r3, [r7, #4]
 800d73a:	2201      	movs	r2, #1
 800d73c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41


      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800d740:	687b      	ldr	r3, [r7, #4]
 800d742:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d744:	f043 0202 	orr.w	r2, r3, #2
 800d748:	687b      	ldr	r3, [r7, #4]
 800d74a:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800d74c:	6878      	ldr	r0, [r7, #4]
 800d74e:	f7f7 f9bf 	bl	8004ad0 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }

  if (hi2s->State == HAL_I2S_STATE_BUSY_TX)
 800d752:	687b      	ldr	r3, [r7, #4]
 800d754:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 800d758:	b2db      	uxtb	r3, r3
 800d75a:	2b03      	cmp	r3, #3
 800d75c:	d136      	bne.n	800d7cc <I2S_IRQHandler+0x10c>
  {
    /* I2S in mode Transmitter -----------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_TXE) != RESET))
 800d75e:	697b      	ldr	r3, [r7, #20]
 800d760:	f003 0302 	and.w	r3, r3, #2
 800d764:	2b02      	cmp	r3, #2
 800d766:	d109      	bne.n	800d77c <I2S_IRQHandler+0xbc>
 800d768:	687b      	ldr	r3, [r7, #4]
 800d76a:	681b      	ldr	r3, [r3, #0]
 800d76c:	685b      	ldr	r3, [r3, #4]
 800d76e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800d772:	2b80      	cmp	r3, #128	@ 0x80
 800d774:	d102      	bne.n	800d77c <I2S_IRQHandler+0xbc>
    {
      I2S_Transmit_IT(hi2s);
 800d776:	6878      	ldr	r0, [r7, #4]
 800d778:	f7ff ff45 	bl	800d606 <I2S_Transmit_IT>
    }

    /* I2S Underrun error interrupt occurred --------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && (__HAL_I2S_GET_IT_SOURCE(hi2s, I2S_IT_ERR) != RESET))
 800d77c:	697b      	ldr	r3, [r7, #20]
 800d77e:	f003 0308 	and.w	r3, r3, #8
 800d782:	2b08      	cmp	r3, #8
 800d784:	d122      	bne.n	800d7cc <I2S_IRQHandler+0x10c>
 800d786:	687b      	ldr	r3, [r7, #4]
 800d788:	681b      	ldr	r3, [r3, #0]
 800d78a:	685b      	ldr	r3, [r3, #4]
 800d78c:	f003 0320 	and.w	r3, r3, #32
 800d790:	2b20      	cmp	r3, #32
 800d792:	d11b      	bne.n	800d7cc <I2S_IRQHandler+0x10c>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800d794:	687b      	ldr	r3, [r7, #4]
 800d796:	681b      	ldr	r3, [r3, #0]
 800d798:	685a      	ldr	r2, [r3, #4]
 800d79a:	687b      	ldr	r3, [r7, #4]
 800d79c:	681b      	ldr	r3, [r3, #0]
 800d79e:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800d7a2:	605a      	str	r2, [r3, #4]

      /* Clear Underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 800d7a4:	2300      	movs	r3, #0
 800d7a6:	60fb      	str	r3, [r7, #12]
 800d7a8:	687b      	ldr	r3, [r7, #4]
 800d7aa:	681b      	ldr	r3, [r3, #0]
 800d7ac:	689b      	ldr	r3, [r3, #8]
 800d7ae:	60fb      	str	r3, [r7, #12]
 800d7b0:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800d7b2:	687b      	ldr	r3, [r7, #4]
 800d7b4:	2201      	movs	r2, #1
 800d7b6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 800d7ba:	687b      	ldr	r3, [r7, #4]
 800d7bc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d7be:	f043 0204 	orr.w	r2, r3, #4
 800d7c2:	687b      	ldr	r3, [r7, #4]
 800d7c4:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800d7c6:	6878      	ldr	r0, [r7, #4]
 800d7c8:	f7f7 f982 	bl	8004ad0 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800d7cc:	bf00      	nop
 800d7ce:	3718      	adds	r7, #24
 800d7d0:	46bd      	mov	sp, r7
 800d7d2:	bd80      	pop	{r7, pc}

0800d7d4 <HAL_I2SEx_FullDuplex_IRQHandler>:
  * @brief  This function handles I2S/I2Sext interrupt requests in full-duplex mode.
  * @param  hi2s I2S handle
  * @retval HAL status
  */
void HAL_I2SEx_FullDuplex_IRQHandler(I2S_HandleTypeDef *hi2s)
{
 800d7d4:	b580      	push	{r7, lr}
 800d7d6:	b088      	sub	sp, #32
 800d7d8:	af00      	add	r7, sp, #0
 800d7da:	6078      	str	r0, [r7, #4]
  __IO uint32_t i2ssr     = hi2s->Instance->SR;
 800d7dc:	687b      	ldr	r3, [r7, #4]
 800d7de:	681b      	ldr	r3, [r3, #0]
 800d7e0:	689b      	ldr	r3, [r3, #8]
 800d7e2:	61fb      	str	r3, [r7, #28]
  __IO uint32_t i2sextsr  = I2SxEXT(hi2s->Instance)->SR;
 800d7e4:	687b      	ldr	r3, [r7, #4]
 800d7e6:	681b      	ldr	r3, [r3, #0]
 800d7e8:	4a92      	ldr	r2, [pc, #584]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d7ea:	4293      	cmp	r3, r2
 800d7ec:	d101      	bne.n	800d7f2 <HAL_I2SEx_FullDuplex_IRQHandler+0x1e>
 800d7ee:	4b92      	ldr	r3, [pc, #584]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d7f0:	e001      	b.n	800d7f6 <HAL_I2SEx_FullDuplex_IRQHandler+0x22>
 800d7f2:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d7f6:	689b      	ldr	r3, [r3, #8]
 800d7f8:	61bb      	str	r3, [r7, #24]
  __IO uint32_t i2scr2    = hi2s->Instance->CR2;
 800d7fa:	687b      	ldr	r3, [r7, #4]
 800d7fc:	681b      	ldr	r3, [r3, #0]
 800d7fe:	685b      	ldr	r3, [r3, #4]
 800d800:	617b      	str	r3, [r7, #20]
  __IO uint32_t i2sextcr2 = I2SxEXT(hi2s->Instance)->CR2;
 800d802:	687b      	ldr	r3, [r7, #4]
 800d804:	681b      	ldr	r3, [r3, #0]
 800d806:	4a8b      	ldr	r2, [pc, #556]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d808:	4293      	cmp	r3, r2
 800d80a:	d101      	bne.n	800d810 <HAL_I2SEx_FullDuplex_IRQHandler+0x3c>
 800d80c:	4b8a      	ldr	r3, [pc, #552]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d80e:	e001      	b.n	800d814 <HAL_I2SEx_FullDuplex_IRQHandler+0x40>
 800d810:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d814:	685b      	ldr	r3, [r3, #4]
 800d816:	613b      	str	r3, [r7, #16]

  /* Check if the I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX Mode is selected */
  if ((hi2s->Init.Mode == I2S_MODE_MASTER_TX) || (hi2s->Init.Mode == I2S_MODE_SLAVE_TX))
 800d818:	687b      	ldr	r3, [r7, #4]
 800d81a:	685b      	ldr	r3, [r3, #4]
 800d81c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800d820:	d004      	beq.n	800d82c <HAL_I2SEx_FullDuplex_IRQHandler+0x58>
 800d822:	687b      	ldr	r3, [r7, #4]
 800d824:	685b      	ldr	r3, [r3, #4]
 800d826:	2b00      	cmp	r3, #0
 800d828:	f040 8099 	bne.w	800d95e <HAL_I2SEx_FullDuplex_IRQHandler+0x18a>
  {
    /* I2S in mode Transmitter -------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2scr2 & I2S_IT_TXE) != RESET))
 800d82c:	69fb      	ldr	r3, [r7, #28]
 800d82e:	f003 0302 	and.w	r3, r3, #2
 800d832:	2b02      	cmp	r3, #2
 800d834:	d107      	bne.n	800d846 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
 800d836:	697b      	ldr	r3, [r7, #20]
 800d838:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800d83c:	2b00      	cmp	r3, #0
 800d83e:	d002      	beq.n	800d846 <HAL_I2SEx_FullDuplex_IRQHandler+0x72>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2S TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2S(hi2s);
 800d840:	6878      	ldr	r0, [r7, #4]
 800d842:	f000 f925 	bl	800da90 <I2SEx_TxISR_I2S>
    }

    /* I2Sext in mode Receiver -----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2sextcr2 & I2S_IT_RXNE) != RESET))
 800d846:	69bb      	ldr	r3, [r7, #24]
 800d848:	f003 0301 	and.w	r3, r3, #1
 800d84c:	2b01      	cmp	r3, #1
 800d84e:	d107      	bne.n	800d860 <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
 800d850:	693b      	ldr	r3, [r7, #16]
 800d852:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800d856:	2b00      	cmp	r3, #0
 800d858:	d002      	beq.n	800d860 <HAL_I2SEx_FullDuplex_IRQHandler+0x8c>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_TX or I2S_MODE_SLAVE_TX,
      the I2Sext RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2SExt(hi2s);
 800d85a:	6878      	ldr	r0, [r7, #4]
 800d85c:	f000 f9c8 	bl	800dbf0 <I2SEx_RxISR_I2SExt>
    }

    /* I2Sext Overrun error interrupt occurred --------------------------------*/
    if (((i2sextsr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 800d860:	69bb      	ldr	r3, [r7, #24]
 800d862:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800d866:	2b40      	cmp	r3, #64	@ 0x40
 800d868:	d13a      	bne.n	800d8e0 <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
 800d86a:	693b      	ldr	r3, [r7, #16]
 800d86c:	f003 0320 	and.w	r3, r3, #32
 800d870:	2b00      	cmp	r3, #0
 800d872:	d035      	beq.n	800d8e0 <HAL_I2SEx_FullDuplex_IRQHandler+0x10c>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800d874:	687b      	ldr	r3, [r7, #4]
 800d876:	681b      	ldr	r3, [r3, #0]
 800d878:	4a6e      	ldr	r2, [pc, #440]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d87a:	4293      	cmp	r3, r2
 800d87c:	d101      	bne.n	800d882 <HAL_I2SEx_FullDuplex_IRQHandler+0xae>
 800d87e:	4b6e      	ldr	r3, [pc, #440]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d880:	e001      	b.n	800d886 <HAL_I2SEx_FullDuplex_IRQHandler+0xb2>
 800d882:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d886:	685a      	ldr	r2, [r3, #4]
 800d888:	687b      	ldr	r3, [r7, #4]
 800d88a:	681b      	ldr	r3, [r3, #0]
 800d88c:	4969      	ldr	r1, [pc, #420]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d88e:	428b      	cmp	r3, r1
 800d890:	d101      	bne.n	800d896 <HAL_I2SEx_FullDuplex_IRQHandler+0xc2>
 800d892:	4b69      	ldr	r3, [pc, #420]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d894:	e001      	b.n	800d89a <HAL_I2SEx_FullDuplex_IRQHandler+0xc6>
 800d896:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d89a:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800d89e:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800d8a0:	687b      	ldr	r3, [r7, #4]
 800d8a2:	681b      	ldr	r3, [r3, #0]
 800d8a4:	685a      	ldr	r2, [r3, #4]
 800d8a6:	687b      	ldr	r3, [r7, #4]
 800d8a8:	681b      	ldr	r3, [r3, #0]
 800d8aa:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800d8ae:	605a      	str	r2, [r3, #4]

      /* Clear Overrun flag */
      __HAL_I2S_CLEAR_OVRFLAG(hi2s);
 800d8b0:	2300      	movs	r3, #0
 800d8b2:	60fb      	str	r3, [r7, #12]
 800d8b4:	687b      	ldr	r3, [r7, #4]
 800d8b6:	681b      	ldr	r3, [r3, #0]
 800d8b8:	68db      	ldr	r3, [r3, #12]
 800d8ba:	60fb      	str	r3, [r7, #12]
 800d8bc:	687b      	ldr	r3, [r7, #4]
 800d8be:	681b      	ldr	r3, [r3, #0]
 800d8c0:	689b      	ldr	r3, [r3, #8]
 800d8c2:	60fb      	str	r3, [r7, #12]
 800d8c4:	68fb      	ldr	r3, [r7, #12]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800d8c6:	687b      	ldr	r3, [r7, #4]
 800d8c8:	2201      	movs	r2, #1
 800d8ca:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800d8ce:	687b      	ldr	r3, [r7, #4]
 800d8d0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d8d2:	f043 0202 	orr.w	r2, r3, #2
 800d8d6:	687b      	ldr	r3, [r7, #4]
 800d8d8:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800d8da:	6878      	ldr	r0, [r7, #4]
 800d8dc:	f7f7 f8f8 	bl	8004ad0 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2S Underrun error interrupt occurred ----------------------------------*/
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800d8e0:	69fb      	ldr	r3, [r7, #28]
 800d8e2:	f003 0308 	and.w	r3, r3, #8
 800d8e6:	2b08      	cmp	r3, #8
 800d8e8:	f040 80c3 	bne.w	800da72 <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
 800d8ec:	697b      	ldr	r3, [r7, #20]
 800d8ee:	f003 0320 	and.w	r3, r3, #32
 800d8f2:	2b00      	cmp	r3, #0
 800d8f4:	f000 80bd 	beq.w	800da72 <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800d8f8:	687b      	ldr	r3, [r7, #4]
 800d8fa:	681b      	ldr	r3, [r3, #0]
 800d8fc:	685a      	ldr	r2, [r3, #4]
 800d8fe:	687b      	ldr	r3, [r7, #4]
 800d900:	681b      	ldr	r3, [r3, #0]
 800d902:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800d906:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800d908:	687b      	ldr	r3, [r7, #4]
 800d90a:	681b      	ldr	r3, [r3, #0]
 800d90c:	4a49      	ldr	r2, [pc, #292]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d90e:	4293      	cmp	r3, r2
 800d910:	d101      	bne.n	800d916 <HAL_I2SEx_FullDuplex_IRQHandler+0x142>
 800d912:	4b49      	ldr	r3, [pc, #292]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d914:	e001      	b.n	800d91a <HAL_I2SEx_FullDuplex_IRQHandler+0x146>
 800d916:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d91a:	685a      	ldr	r2, [r3, #4]
 800d91c:	687b      	ldr	r3, [r7, #4]
 800d91e:	681b      	ldr	r3, [r3, #0]
 800d920:	4944      	ldr	r1, [pc, #272]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d922:	428b      	cmp	r3, r1
 800d924:	d101      	bne.n	800d92a <HAL_I2SEx_FullDuplex_IRQHandler+0x156>
 800d926:	4b44      	ldr	r3, [pc, #272]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d928:	e001      	b.n	800d92e <HAL_I2SEx_FullDuplex_IRQHandler+0x15a>
 800d92a:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d92e:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800d932:	605a      	str	r2, [r3, #4]

      /* Clear underrun flag */
      __HAL_I2S_CLEAR_UDRFLAG(hi2s);
 800d934:	2300      	movs	r3, #0
 800d936:	60bb      	str	r3, [r7, #8]
 800d938:	687b      	ldr	r3, [r7, #4]
 800d93a:	681b      	ldr	r3, [r3, #0]
 800d93c:	689b      	ldr	r3, [r3, #8]
 800d93e:	60bb      	str	r3, [r7, #8]
 800d940:	68bb      	ldr	r3, [r7, #8]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800d942:	687b      	ldr	r3, [r7, #4]
 800d944:	2201      	movs	r2, #1
 800d946:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 800d94a:	687b      	ldr	r3, [r7, #4]
 800d94c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d94e:	f043 0204 	orr.w	r2, r3, #4
 800d952:	687b      	ldr	r3, [r7, #4]
 800d954:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800d956:	6878      	ldr	r0, [r7, #4]
 800d958:	f7f7 f8ba 	bl	8004ad0 <HAL_I2S_ErrorCallback>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800d95c:	e089      	b.n	800da72 <HAL_I2SEx_FullDuplex_IRQHandler+0x29e>
  }
  /* The I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX Mode is selected */
  else
  {
    /* I2Sext in mode Transmitter ----------------------------------------------*/
    if (((i2sextsr & I2S_FLAG_TXE) == I2S_FLAG_TXE) && ((i2sextcr2 & I2S_IT_TXE) != RESET))
 800d95e:	69bb      	ldr	r3, [r7, #24]
 800d960:	f003 0302 	and.w	r3, r3, #2
 800d964:	2b02      	cmp	r3, #2
 800d966:	d107      	bne.n	800d978 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
 800d968:	693b      	ldr	r3, [r7, #16]
 800d96a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800d96e:	2b00      	cmp	r3, #0
 800d970:	d002      	beq.n	800d978 <HAL_I2SEx_FullDuplex_IRQHandler+0x1a4>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2Sext TXE interrupt will be generated to manage the full-duplex transmit phase. */
      I2SEx_TxISR_I2SExt(hi2s);
 800d972:	6878      	ldr	r0, [r7, #4]
 800d974:	f000 f8be 	bl	800daf4 <I2SEx_TxISR_I2SExt>
    }

    /* I2S in mode Receiver --------------------------------------------------*/
    if (((i2ssr & I2S_FLAG_RXNE) == I2S_FLAG_RXNE) && ((i2scr2 & I2S_IT_RXNE) != RESET))
 800d978:	69fb      	ldr	r3, [r7, #28]
 800d97a:	f003 0301 	and.w	r3, r3, #1
 800d97e:	2b01      	cmp	r3, #1
 800d980:	d107      	bne.n	800d992 <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
 800d982:	697b      	ldr	r3, [r7, #20]
 800d984:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800d988:	2b00      	cmp	r3, #0
 800d98a:	d002      	beq.n	800d992 <HAL_I2SEx_FullDuplex_IRQHandler+0x1be>
    {
      /* When the I2S mode is configured as I2S_MODE_MASTER_RX or I2S_MODE_SLAVE_RX,
      the I2S RXNE interrupt will be generated to manage the full-duplex receive phase. */
      I2SEx_RxISR_I2S(hi2s);
 800d98c:	6878      	ldr	r0, [r7, #4]
 800d98e:	f000 f8fd 	bl	800db8c <I2SEx_RxISR_I2S>
    }

    /* I2S Overrun error interrupt occurred -------------------------------------*/
    if (((i2ssr & I2S_FLAG_OVR) == I2S_FLAG_OVR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800d992:	69fb      	ldr	r3, [r7, #28]
 800d994:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800d998:	2b40      	cmp	r3, #64	@ 0x40
 800d99a:	d12f      	bne.n	800d9fc <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
 800d99c:	697b      	ldr	r3, [r7, #20]
 800d99e:	f003 0320 	and.w	r3, r3, #32
 800d9a2:	2b00      	cmp	r3, #0
 800d9a4:	d02a      	beq.n	800d9fc <HAL_I2SEx_FullDuplex_IRQHandler+0x228>
    {
      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800d9a6:	687b      	ldr	r3, [r7, #4]
 800d9a8:	681b      	ldr	r3, [r3, #0]
 800d9aa:	685a      	ldr	r2, [r3, #4]
 800d9ac:	687b      	ldr	r3, [r7, #4]
 800d9ae:	681b      	ldr	r3, [r3, #0]
 800d9b0:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800d9b4:	605a      	str	r2, [r3, #4]

      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800d9b6:	687b      	ldr	r3, [r7, #4]
 800d9b8:	681b      	ldr	r3, [r3, #0]
 800d9ba:	4a1e      	ldr	r2, [pc, #120]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d9bc:	4293      	cmp	r3, r2
 800d9be:	d101      	bne.n	800d9c4 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f0>
 800d9c0:	4b1d      	ldr	r3, [pc, #116]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d9c2:	e001      	b.n	800d9c8 <HAL_I2SEx_FullDuplex_IRQHandler+0x1f4>
 800d9c4:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d9c8:	685a      	ldr	r2, [r3, #4]
 800d9ca:	687b      	ldr	r3, [r7, #4]
 800d9cc:	681b      	ldr	r3, [r3, #0]
 800d9ce:	4919      	ldr	r1, [pc, #100]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800d9d0:	428b      	cmp	r3, r1
 800d9d2:	d101      	bne.n	800d9d8 <HAL_I2SEx_FullDuplex_IRQHandler+0x204>
 800d9d4:	4b18      	ldr	r3, [pc, #96]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800d9d6:	e001      	b.n	800d9dc <HAL_I2SEx_FullDuplex_IRQHandler+0x208>
 800d9d8:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800d9dc:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800d9e0:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800d9e2:	687b      	ldr	r3, [r7, #4]
 800d9e4:	2201      	movs	r2, #1
 800d9e6:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_OVR);
 800d9ea:	687b      	ldr	r3, [r7, #4]
 800d9ec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800d9ee:	f043 0202 	orr.w	r2, r3, #2
 800d9f2:	687b      	ldr	r3, [r7, #4]
 800d9f4:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800d9f6:	6878      	ldr	r0, [r7, #4]
 800d9f8:	f7f7 f86a 	bl	8004ad0 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }

    /* I2Sext Underrun error interrupt occurred -------------------------------*/
    if (((i2sextsr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2sextcr2 & I2S_IT_ERR) != RESET))
 800d9fc:	69bb      	ldr	r3, [r7, #24]
 800d9fe:	f003 0308 	and.w	r3, r3, #8
 800da02:	2b08      	cmp	r3, #8
 800da04:	d136      	bne.n	800da74 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
 800da06:	693b      	ldr	r3, [r7, #16]
 800da08:	f003 0320 	and.w	r3, r3, #32
 800da0c:	2b00      	cmp	r3, #0
 800da0e:	d031      	beq.n	800da74 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    {
      /* Disable TXE and ERR interrupt */
      __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800da10:	687b      	ldr	r3, [r7, #4]
 800da12:	681b      	ldr	r3, [r3, #0]
 800da14:	4a07      	ldr	r2, [pc, #28]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800da16:	4293      	cmp	r3, r2
 800da18:	d101      	bne.n	800da1e <HAL_I2SEx_FullDuplex_IRQHandler+0x24a>
 800da1a:	4b07      	ldr	r3, [pc, #28]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800da1c:	e001      	b.n	800da22 <HAL_I2SEx_FullDuplex_IRQHandler+0x24e>
 800da1e:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800da22:	685a      	ldr	r2, [r3, #4]
 800da24:	687b      	ldr	r3, [r7, #4]
 800da26:	681b      	ldr	r3, [r3, #0]
 800da28:	4902      	ldr	r1, [pc, #8]	@ (800da34 <HAL_I2SEx_FullDuplex_IRQHandler+0x260>)
 800da2a:	428b      	cmp	r3, r1
 800da2c:	d106      	bne.n	800da3c <HAL_I2SEx_FullDuplex_IRQHandler+0x268>
 800da2e:	4b02      	ldr	r3, [pc, #8]	@ (800da38 <HAL_I2SEx_FullDuplex_IRQHandler+0x264>)
 800da30:	e006      	b.n	800da40 <HAL_I2SEx_FullDuplex_IRQHandler+0x26c>
 800da32:	bf00      	nop
 800da34:	40003800 	.word	0x40003800
 800da38:	40003400 	.word	0x40003400
 800da3c:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800da40:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800da44:	605a      	str	r2, [r3, #4]

      /* Disable RXNE and ERR interrupt */
      __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800da46:	687b      	ldr	r3, [r7, #4]
 800da48:	681b      	ldr	r3, [r3, #0]
 800da4a:	685a      	ldr	r2, [r3, #4]
 800da4c:	687b      	ldr	r3, [r7, #4]
 800da4e:	681b      	ldr	r3, [r3, #0]
 800da50:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800da54:	605a      	str	r2, [r3, #4]

      /* Set the I2S State ready */
      hi2s->State = HAL_I2S_STATE_READY;
 800da56:	687b      	ldr	r3, [r7, #4]
 800da58:	2201      	movs	r2, #1
 800da5a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      /* Set the error code and execute error callback*/
      SET_BIT(hi2s->ErrorCode, HAL_I2S_ERROR_UDR);
 800da5e:	687b      	ldr	r3, [r7, #4]
 800da60:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800da62:	f043 0204 	orr.w	r2, r3, #4
 800da66:	687b      	ldr	r3, [r7, #4]
 800da68:	645a      	str	r2, [r3, #68]	@ 0x44
      /* Call user error callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->ErrorCallback(hi2s);
#else
      HAL_I2S_ErrorCallback(hi2s);
 800da6a:	6878      	ldr	r0, [r7, #4]
 800da6c:	f7f7 f830 	bl	8004ad0 <HAL_I2S_ErrorCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800da70:	e000      	b.n	800da74 <HAL_I2SEx_FullDuplex_IRQHandler+0x2a0>
    if (((i2ssr & I2S_FLAG_UDR) == I2S_FLAG_UDR) && ((i2scr2 & I2S_IT_ERR) != RESET))
 800da72:	bf00      	nop
}
 800da74:	bf00      	nop
 800da76:	3720      	adds	r7, #32
 800da78:	46bd      	mov	sp, r7
 800da7a:	bd80      	pop	{r7, pc}

0800da7c <HAL_I2SEx_TxRxCpltCallback>:
  * @brief  Tx and Rx Transfer completed callback
  * @param  hi2s I2S handle
  * @retval None
  */
__weak void HAL_I2SEx_TxRxCpltCallback(I2S_HandleTypeDef *hi2s)
{
 800da7c:	b480      	push	{r7}
 800da7e:	b083      	sub	sp, #12
 800da80:	af00      	add	r7, sp, #0
 800da82:	6078      	str	r0, [r7, #4]
  UNUSED(hi2s);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2SEx_TxRxCpltCallback could be implemented in the user file
   */
}
 800da84:	bf00      	nop
 800da86:	370c      	adds	r7, #12
 800da88:	46bd      	mov	sp, r7
 800da8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800da8e:	4770      	bx	lr

0800da90 <I2SEx_TxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 800da90:	b580      	push	{r7, lr}
 800da92:	b082      	sub	sp, #8
 800da94:	af00      	add	r7, sp, #0
 800da96:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  hi2s->Instance->DR = (*hi2s->pTxBuffPtr++);
 800da98:	687b      	ldr	r3, [r7, #4]
 800da9a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800da9c:	1c99      	adds	r1, r3, #2
 800da9e:	687a      	ldr	r2, [r7, #4]
 800daa0:	6251      	str	r1, [r2, #36]	@ 0x24
 800daa2:	881a      	ldrh	r2, [r3, #0]
 800daa4:	687b      	ldr	r3, [r7, #4]
 800daa6:	681b      	ldr	r3, [r3, #0]
 800daa8:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 800daaa:	687b      	ldr	r3, [r7, #4]
 800daac:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800daae:	b29b      	uxth	r3, r3
 800dab0:	3b01      	subs	r3, #1
 800dab2:	b29a      	uxth	r2, r3
 800dab4:	687b      	ldr	r3, [r7, #4]
 800dab6:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 800dab8:	687b      	ldr	r3, [r7, #4]
 800daba:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800dabc:	b29b      	uxth	r3, r3
 800dabe:	2b00      	cmp	r3, #0
 800dac0:	d113      	bne.n	800daea <I2SEx_TxISR_I2S+0x5a>
  {
    /* Disable TXE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800dac2:	687b      	ldr	r3, [r7, #4]
 800dac4:	681b      	ldr	r3, [r3, #0]
 800dac6:	685a      	ldr	r2, [r3, #4]
 800dac8:	687b      	ldr	r3, [r7, #4]
 800daca:	681b      	ldr	r3, [r3, #0]
 800dacc:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800dad0:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 800dad2:	687b      	ldr	r3, [r7, #4]
 800dad4:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800dad6:	b29b      	uxth	r3, r3
 800dad8:	2b00      	cmp	r3, #0
 800dada:	d106      	bne.n	800daea <I2SEx_TxISR_I2S+0x5a>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800dadc:	687b      	ldr	r3, [r7, #4]
 800dade:	2201      	movs	r2, #1
 800dae0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800dae4:	6878      	ldr	r0, [r7, #4]
 800dae6:	f7ff ffc9 	bl	800da7c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800daea:	bf00      	nop
 800daec:	3708      	adds	r7, #8
 800daee:	46bd      	mov	sp, r7
 800daf0:	bd80      	pop	{r7, pc}
	...

0800daf4 <I2SEx_TxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler transmit function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_TxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 800daf4:	b580      	push	{r7, lr}
 800daf6:	b082      	sub	sp, #8
 800daf8:	af00      	add	r7, sp, #0
 800dafa:	6078      	str	r0, [r7, #4]
  /* Write Data on DR register */
  I2SxEXT(hi2s->Instance)->DR = (*hi2s->pTxBuffPtr++);
 800dafc:	687b      	ldr	r3, [r7, #4]
 800dafe:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800db00:	1c99      	adds	r1, r3, #2
 800db02:	687a      	ldr	r2, [r7, #4]
 800db04:	6251      	str	r1, [r2, #36]	@ 0x24
 800db06:	8819      	ldrh	r1, [r3, #0]
 800db08:	687b      	ldr	r3, [r7, #4]
 800db0a:	681b      	ldr	r3, [r3, #0]
 800db0c:	4a1d      	ldr	r2, [pc, #116]	@ (800db84 <I2SEx_TxISR_I2SExt+0x90>)
 800db0e:	4293      	cmp	r3, r2
 800db10:	d101      	bne.n	800db16 <I2SEx_TxISR_I2SExt+0x22>
 800db12:	4b1d      	ldr	r3, [pc, #116]	@ (800db88 <I2SEx_TxISR_I2SExt+0x94>)
 800db14:	e001      	b.n	800db1a <I2SEx_TxISR_I2SExt+0x26>
 800db16:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800db1a:	460a      	mov	r2, r1
 800db1c:	60da      	str	r2, [r3, #12]
  hi2s->TxXferCount--;
 800db1e:	687b      	ldr	r3, [r7, #4]
 800db20:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800db22:	b29b      	uxth	r3, r3
 800db24:	3b01      	subs	r3, #1
 800db26:	b29a      	uxth	r2, r3
 800db28:	687b      	ldr	r3, [r7, #4]
 800db2a:	855a      	strh	r2, [r3, #42]	@ 0x2a

  if (hi2s->TxXferCount == 0U)
 800db2c:	687b      	ldr	r3, [r7, #4]
 800db2e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800db30:	b29b      	uxth	r3, r3
 800db32:	2b00      	cmp	r3, #0
 800db34:	d121      	bne.n	800db7a <I2SEx_TxISR_I2SExt+0x86>
  {
    /* Disable I2Sext TXE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_TXE | I2S_IT_ERR));
 800db36:	687b      	ldr	r3, [r7, #4]
 800db38:	681b      	ldr	r3, [r3, #0]
 800db3a:	4a12      	ldr	r2, [pc, #72]	@ (800db84 <I2SEx_TxISR_I2SExt+0x90>)
 800db3c:	4293      	cmp	r3, r2
 800db3e:	d101      	bne.n	800db44 <I2SEx_TxISR_I2SExt+0x50>
 800db40:	4b11      	ldr	r3, [pc, #68]	@ (800db88 <I2SEx_TxISR_I2SExt+0x94>)
 800db42:	e001      	b.n	800db48 <I2SEx_TxISR_I2SExt+0x54>
 800db44:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800db48:	685a      	ldr	r2, [r3, #4]
 800db4a:	687b      	ldr	r3, [r7, #4]
 800db4c:	681b      	ldr	r3, [r3, #0]
 800db4e:	490d      	ldr	r1, [pc, #52]	@ (800db84 <I2SEx_TxISR_I2SExt+0x90>)
 800db50:	428b      	cmp	r3, r1
 800db52:	d101      	bne.n	800db58 <I2SEx_TxISR_I2SExt+0x64>
 800db54:	4b0c      	ldr	r3, [pc, #48]	@ (800db88 <I2SEx_TxISR_I2SExt+0x94>)
 800db56:	e001      	b.n	800db5c <I2SEx_TxISR_I2SExt+0x68>
 800db58:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800db5c:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 800db60:	605a      	str	r2, [r3, #4]

    if (hi2s->RxXferCount == 0U)
 800db62:	687b      	ldr	r3, [r7, #4]
 800db64:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800db66:	b29b      	uxth	r3, r3
 800db68:	2b00      	cmp	r3, #0
 800db6a:	d106      	bne.n	800db7a <I2SEx_TxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800db6c:	687b      	ldr	r3, [r7, #4]
 800db6e:	2201      	movs	r2, #1
 800db70:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800db74:	6878      	ldr	r0, [r7, #4]
 800db76:	f7ff ff81 	bl	800da7c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800db7a:	bf00      	nop
 800db7c:	3708      	adds	r7, #8
 800db7e:	46bd      	mov	sp, r7
 800db80:	bd80      	pop	{r7, pc}
 800db82:	bf00      	nop
 800db84:	40003800 	.word	0x40003800
 800db88:	40003400 	.word	0x40003400

0800db8c <I2SEx_RxISR_I2S>:
  * @brief  I2S Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2S(I2S_HandleTypeDef *hi2s)
{
 800db8c:	b580      	push	{r7, lr}
 800db8e:	b082      	sub	sp, #8
 800db90:	af00      	add	r7, sp, #0
 800db92:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = hi2s->Instance->DR;
 800db94:	687b      	ldr	r3, [r7, #4]
 800db96:	681b      	ldr	r3, [r3, #0]
 800db98:	68d8      	ldr	r0, [r3, #12]
 800db9a:	687b      	ldr	r3, [r7, #4]
 800db9c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800db9e:	1c99      	adds	r1, r3, #2
 800dba0:	687a      	ldr	r2, [r7, #4]
 800dba2:	62d1      	str	r1, [r2, #44]	@ 0x2c
 800dba4:	b282      	uxth	r2, r0
 800dba6:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 800dba8:	687b      	ldr	r3, [r7, #4]
 800dbaa:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800dbac:	b29b      	uxth	r3, r3
 800dbae:	3b01      	subs	r3, #1
 800dbb0:	b29a      	uxth	r2, r3
 800dbb2:	687b      	ldr	r3, [r7, #4]
 800dbb4:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 800dbb6:	687b      	ldr	r3, [r7, #4]
 800dbb8:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800dbba:	b29b      	uxth	r3, r3
 800dbbc:	2b00      	cmp	r3, #0
 800dbbe:	d113      	bne.n	800dbe8 <I2SEx_RxISR_I2S+0x5c>
  {
    /* Disable RXNE and ERR interrupt */
    __HAL_I2S_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800dbc0:	687b      	ldr	r3, [r7, #4]
 800dbc2:	681b      	ldr	r3, [r3, #0]
 800dbc4:	685a      	ldr	r2, [r3, #4]
 800dbc6:	687b      	ldr	r3, [r7, #4]
 800dbc8:	681b      	ldr	r3, [r3, #0]
 800dbca:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800dbce:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 800dbd0:	687b      	ldr	r3, [r7, #4]
 800dbd2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800dbd4:	b29b      	uxth	r3, r3
 800dbd6:	2b00      	cmp	r3, #0
 800dbd8:	d106      	bne.n	800dbe8 <I2SEx_RxISR_I2S+0x5c>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800dbda:	687b      	ldr	r3, [r7, #4]
 800dbdc:	2201      	movs	r2, #1
 800dbde:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800dbe2:	6878      	ldr	r0, [r7, #4]
 800dbe4:	f7ff ff4a 	bl	800da7c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800dbe8:	bf00      	nop
 800dbea:	3708      	adds	r7, #8
 800dbec:	46bd      	mov	sp, r7
 800dbee:	bd80      	pop	{r7, pc}

0800dbf0 <I2SEx_RxISR_I2SExt>:
  * @brief  I2SExt Full-Duplex IT handler receive function
  * @param  hi2s I2S handle
  * @retval None
  */
static void I2SEx_RxISR_I2SExt(I2S_HandleTypeDef *hi2s)
{
 800dbf0:	b580      	push	{r7, lr}
 800dbf2:	b082      	sub	sp, #8
 800dbf4:	af00      	add	r7, sp, #0
 800dbf6:	6078      	str	r0, [r7, #4]
  /* Read Data from DR register */
  (*hi2s->pRxBuffPtr++) = I2SxEXT(hi2s->Instance)->DR;
 800dbf8:	687b      	ldr	r3, [r7, #4]
 800dbfa:	681b      	ldr	r3, [r3, #0]
 800dbfc:	4a20      	ldr	r2, [pc, #128]	@ (800dc80 <I2SEx_RxISR_I2SExt+0x90>)
 800dbfe:	4293      	cmp	r3, r2
 800dc00:	d101      	bne.n	800dc06 <I2SEx_RxISR_I2SExt+0x16>
 800dc02:	4b20      	ldr	r3, [pc, #128]	@ (800dc84 <I2SEx_RxISR_I2SExt+0x94>)
 800dc04:	e001      	b.n	800dc0a <I2SEx_RxISR_I2SExt+0x1a>
 800dc06:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800dc0a:	68d8      	ldr	r0, [r3, #12]
 800dc0c:	687b      	ldr	r3, [r7, #4]
 800dc0e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800dc10:	1c99      	adds	r1, r3, #2
 800dc12:	687a      	ldr	r2, [r7, #4]
 800dc14:	62d1      	str	r1, [r2, #44]	@ 0x2c
 800dc16:	b282      	uxth	r2, r0
 800dc18:	801a      	strh	r2, [r3, #0]
  hi2s->RxXferCount--;
 800dc1a:	687b      	ldr	r3, [r7, #4]
 800dc1c:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800dc1e:	b29b      	uxth	r3, r3
 800dc20:	3b01      	subs	r3, #1
 800dc22:	b29a      	uxth	r2, r3
 800dc24:	687b      	ldr	r3, [r7, #4]
 800dc26:	865a      	strh	r2, [r3, #50]	@ 0x32

  if (hi2s->RxXferCount == 0U)
 800dc28:	687b      	ldr	r3, [r7, #4]
 800dc2a:	8e5b      	ldrh	r3, [r3, #50]	@ 0x32
 800dc2c:	b29b      	uxth	r3, r3
 800dc2e:	2b00      	cmp	r3, #0
 800dc30:	d121      	bne.n	800dc76 <I2SEx_RxISR_I2SExt+0x86>
  {
    /* Disable I2Sext RXNE and ERR interrupt */
    __HAL_I2SEXT_DISABLE_IT(hi2s, (I2S_IT_RXNE | I2S_IT_ERR));
 800dc32:	687b      	ldr	r3, [r7, #4]
 800dc34:	681b      	ldr	r3, [r3, #0]
 800dc36:	4a12      	ldr	r2, [pc, #72]	@ (800dc80 <I2SEx_RxISR_I2SExt+0x90>)
 800dc38:	4293      	cmp	r3, r2
 800dc3a:	d101      	bne.n	800dc40 <I2SEx_RxISR_I2SExt+0x50>
 800dc3c:	4b11      	ldr	r3, [pc, #68]	@ (800dc84 <I2SEx_RxISR_I2SExt+0x94>)
 800dc3e:	e001      	b.n	800dc44 <I2SEx_RxISR_I2SExt+0x54>
 800dc40:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800dc44:	685a      	ldr	r2, [r3, #4]
 800dc46:	687b      	ldr	r3, [r7, #4]
 800dc48:	681b      	ldr	r3, [r3, #0]
 800dc4a:	490d      	ldr	r1, [pc, #52]	@ (800dc80 <I2SEx_RxISR_I2SExt+0x90>)
 800dc4c:	428b      	cmp	r3, r1
 800dc4e:	d101      	bne.n	800dc54 <I2SEx_RxISR_I2SExt+0x64>
 800dc50:	4b0c      	ldr	r3, [pc, #48]	@ (800dc84 <I2SEx_RxISR_I2SExt+0x94>)
 800dc52:	e001      	b.n	800dc58 <I2SEx_RxISR_I2SExt+0x68>
 800dc54:	f04f 2340 	mov.w	r3, #1073758208	@ 0x40004000
 800dc58:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 800dc5c:	605a      	str	r2, [r3, #4]

    if (hi2s->TxXferCount == 0U)
 800dc5e:	687b      	ldr	r3, [r7, #4]
 800dc60:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800dc62:	b29b      	uxth	r3, r3
 800dc64:	2b00      	cmp	r3, #0
 800dc66:	d106      	bne.n	800dc76 <I2SEx_RxISR_I2SExt+0x86>
    {
      hi2s->State = HAL_I2S_STATE_READY;
 800dc68:	687b      	ldr	r3, [r7, #4]
 800dc6a:	2201      	movs	r2, #1
 800dc6c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
      /* Call user TxRx complete callback */
#if (USE_HAL_I2S_REGISTER_CALLBACKS == 1U)
      hi2s->TxRxCpltCallback(hi2s);
#else
      HAL_I2SEx_TxRxCpltCallback(hi2s);
 800dc70:	6878      	ldr	r0, [r7, #4]
 800dc72:	f7ff ff03 	bl	800da7c <HAL_I2SEx_TxRxCpltCallback>
#endif /* USE_HAL_I2S_REGISTER_CALLBACKS */
    }
  }
}
 800dc76:	bf00      	nop
 800dc78:	3708      	adds	r7, #8
 800dc7a:	46bd      	mov	sp, r7
 800dc7c:	bd80      	pop	{r7, pc}
 800dc7e:	bf00      	nop
 800dc80:	40003800 	.word	0x40003800
 800dc84:	40003400 	.word	0x40003400

0800dc88 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 800dc88:	b580      	push	{r7, lr}
 800dc8a:	b086      	sub	sp, #24
 800dc8c:	af02      	add	r7, sp, #8
 800dc8e:	6078      	str	r0, [r7, #4]
  const USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 800dc90:	687b      	ldr	r3, [r7, #4]
 800dc92:	2b00      	cmp	r3, #0
 800dc94:	d101      	bne.n	800dc9a <HAL_PCD_Init+0x12>
  {
    return HAL_ERROR;
 800dc96:	2301      	movs	r3, #1
 800dc98:	e101      	b.n	800de9e <HAL_PCD_Init+0x216>

  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
 800dc9a:	687b      	ldr	r3, [r7, #4]
 800dc9c:	681b      	ldr	r3, [r3, #0]
 800dc9e:	60bb      	str	r3, [r7, #8]
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 800dca0:	687b      	ldr	r3, [r7, #4]
 800dca2:	f893 3495 	ldrb.w	r3, [r3, #1173]	@ 0x495
 800dca6:	b2db      	uxtb	r3, r3
 800dca8:	2b00      	cmp	r3, #0
 800dcaa:	d106      	bne.n	800dcba <HAL_PCD_Init+0x32>
  {
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 800dcac:	687b      	ldr	r3, [r7, #4]
 800dcae:	2200      	movs	r2, #0
 800dcb0:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

    /* Init the low level hardware */
    hpcd->MspInitCallback(hpcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 800dcb4:	6878      	ldr	r0, [r7, #4]
 800dcb6:	f00d fe53 	bl	801b960 <HAL_PCD_MspInit>
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 800dcba:	687b      	ldr	r3, [r7, #4]
 800dcbc:	2203      	movs	r2, #3
 800dcbe:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495

#if defined (USB_OTG_FS)
  /* Disable DMA mode for FS instance */
  if (USBx == USB_OTG_FS)
 800dcc2:	68bb      	ldr	r3, [r7, #8]
 800dcc4:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800dcc8:	d102      	bne.n	800dcd0 <HAL_PCD_Init+0x48>
  {
    hpcd->Init.dma_enable = 0U;
 800dcca:	687b      	ldr	r3, [r7, #4]
 800dccc:	2200      	movs	r2, #0
 800dcce:	719a      	strb	r2, [r3, #6]
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 800dcd0:	687b      	ldr	r3, [r7, #4]
 800dcd2:	681b      	ldr	r3, [r3, #0]
 800dcd4:	4618      	mov	r0, r3
 800dcd6:	f005 ffbe 	bl	8013c56 <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800dcda:	687b      	ldr	r3, [r7, #4]
 800dcdc:	6818      	ldr	r0, [r3, #0]
 800dcde:	687b      	ldr	r3, [r7, #4]
 800dce0:	7c1a      	ldrb	r2, [r3, #16]
 800dce2:	f88d 2000 	strb.w	r2, [sp]
 800dce6:	3304      	adds	r3, #4
 800dce8:	cb0e      	ldmia	r3, {r1, r2, r3}
 800dcea:	f005 fe9d 	bl	8013a28 <USB_CoreInit>
 800dcee:	4603      	mov	r3, r0
 800dcf0:	2b00      	cmp	r3, #0
 800dcf2:	d005      	beq.n	800dd00 <HAL_PCD_Init+0x78>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 800dcf4:	687b      	ldr	r3, [r7, #4]
 800dcf6:	2202      	movs	r2, #2
 800dcf8:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 800dcfc:	2301      	movs	r3, #1
 800dcfe:	e0ce      	b.n	800de9e <HAL_PCD_Init+0x216>
  }

  /* Force Device Mode */
  if (USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE) != HAL_OK)
 800dd00:	687b      	ldr	r3, [r7, #4]
 800dd02:	681b      	ldr	r3, [r3, #0]
 800dd04:	2100      	movs	r1, #0
 800dd06:	4618      	mov	r0, r3
 800dd08:	f005 ffb6 	bl	8013c78 <USB_SetCurrentMode>
 800dd0c:	4603      	mov	r3, r0
 800dd0e:	2b00      	cmp	r3, #0
 800dd10:	d005      	beq.n	800dd1e <HAL_PCD_Init+0x96>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 800dd12:	687b      	ldr	r3, [r7, #4]
 800dd14:	2202      	movs	r2, #2
 800dd16:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 800dd1a:	2301      	movs	r3, #1
 800dd1c:	e0bf      	b.n	800de9e <HAL_PCD_Init+0x216>
  }

  /* Init endpoints structures */
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800dd1e:	2300      	movs	r3, #0
 800dd20:	73fb      	strb	r3, [r7, #15]
 800dd22:	e04a      	b.n	800ddba <HAL_PCD_Init+0x132>
  {
    /* Init ep structure */
    hpcd->IN_ep[i].is_in = 1U;
 800dd24:	7bfa      	ldrb	r2, [r7, #15]
 800dd26:	6879      	ldr	r1, [r7, #4]
 800dd28:	4613      	mov	r3, r2
 800dd2a:	00db      	lsls	r3, r3, #3
 800dd2c:	4413      	add	r3, r2
 800dd2e:	009b      	lsls	r3, r3, #2
 800dd30:	440b      	add	r3, r1
 800dd32:	3315      	adds	r3, #21
 800dd34:	2201      	movs	r2, #1
 800dd36:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].num = i;
 800dd38:	7bfa      	ldrb	r2, [r7, #15]
 800dd3a:	6879      	ldr	r1, [r7, #4]
 800dd3c:	4613      	mov	r3, r2
 800dd3e:	00db      	lsls	r3, r3, #3
 800dd40:	4413      	add	r3, r2
 800dd42:	009b      	lsls	r3, r3, #2
 800dd44:	440b      	add	r3, r1
 800dd46:	3314      	adds	r3, #20
 800dd48:	7bfa      	ldrb	r2, [r7, #15]
 800dd4a:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].tx_fifo_num = i;
 800dd4c:	7bfa      	ldrb	r2, [r7, #15]
 800dd4e:	7bfb      	ldrb	r3, [r7, #15]
 800dd50:	b298      	uxth	r0, r3
 800dd52:	6879      	ldr	r1, [r7, #4]
 800dd54:	4613      	mov	r3, r2
 800dd56:	00db      	lsls	r3, r3, #3
 800dd58:	4413      	add	r3, r2
 800dd5a:	009b      	lsls	r3, r3, #2
 800dd5c:	440b      	add	r3, r1
 800dd5e:	332e      	adds	r3, #46	@ 0x2e
 800dd60:	4602      	mov	r2, r0
 800dd62:	801a      	strh	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 800dd64:	7bfa      	ldrb	r2, [r7, #15]
 800dd66:	6879      	ldr	r1, [r7, #4]
 800dd68:	4613      	mov	r3, r2
 800dd6a:	00db      	lsls	r3, r3, #3
 800dd6c:	4413      	add	r3, r2
 800dd6e:	009b      	lsls	r3, r3, #2
 800dd70:	440b      	add	r3, r1
 800dd72:	3318      	adds	r3, #24
 800dd74:	2200      	movs	r2, #0
 800dd76:	701a      	strb	r2, [r3, #0]
    hpcd->IN_ep[i].maxpacket = 0U;
 800dd78:	7bfa      	ldrb	r2, [r7, #15]
 800dd7a:	6879      	ldr	r1, [r7, #4]
 800dd7c:	4613      	mov	r3, r2
 800dd7e:	00db      	lsls	r3, r3, #3
 800dd80:	4413      	add	r3, r2
 800dd82:	009b      	lsls	r3, r3, #2
 800dd84:	440b      	add	r3, r1
 800dd86:	331c      	adds	r3, #28
 800dd88:	2200      	movs	r2, #0
 800dd8a:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_buff = 0U;
 800dd8c:	7bfa      	ldrb	r2, [r7, #15]
 800dd8e:	6879      	ldr	r1, [r7, #4]
 800dd90:	4613      	mov	r3, r2
 800dd92:	00db      	lsls	r3, r3, #3
 800dd94:	4413      	add	r3, r2
 800dd96:	009b      	lsls	r3, r3, #2
 800dd98:	440b      	add	r3, r1
 800dd9a:	3320      	adds	r3, #32
 800dd9c:	2200      	movs	r2, #0
 800dd9e:	601a      	str	r2, [r3, #0]
    hpcd->IN_ep[i].xfer_len = 0U;
 800dda0:	7bfa      	ldrb	r2, [r7, #15]
 800dda2:	6879      	ldr	r1, [r7, #4]
 800dda4:	4613      	mov	r3, r2
 800dda6:	00db      	lsls	r3, r3, #3
 800dda8:	4413      	add	r3, r2
 800ddaa:	009b      	lsls	r3, r3, #2
 800ddac:	440b      	add	r3, r1
 800ddae:	3324      	adds	r3, #36	@ 0x24
 800ddb0:	2200      	movs	r2, #0
 800ddb2:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ddb4:	7bfb      	ldrb	r3, [r7, #15]
 800ddb6:	3301      	adds	r3, #1
 800ddb8:	73fb      	strb	r3, [r7, #15]
 800ddba:	687b      	ldr	r3, [r7, #4]
 800ddbc:	791b      	ldrb	r3, [r3, #4]
 800ddbe:	7bfa      	ldrb	r2, [r7, #15]
 800ddc0:	429a      	cmp	r2, r3
 800ddc2:	d3af      	bcc.n	800dd24 <HAL_PCD_Init+0x9c>
  }

  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800ddc4:	2300      	movs	r3, #0
 800ddc6:	73fb      	strb	r3, [r7, #15]
 800ddc8:	e044      	b.n	800de54 <HAL_PCD_Init+0x1cc>
  {
    hpcd->OUT_ep[i].is_in = 0U;
 800ddca:	7bfa      	ldrb	r2, [r7, #15]
 800ddcc:	6879      	ldr	r1, [r7, #4]
 800ddce:	4613      	mov	r3, r2
 800ddd0:	00db      	lsls	r3, r3, #3
 800ddd2:	4413      	add	r3, r2
 800ddd4:	009b      	lsls	r3, r3, #2
 800ddd6:	440b      	add	r3, r1
 800ddd8:	f203 2355 	addw	r3, r3, #597	@ 0x255
 800dddc:	2200      	movs	r2, #0
 800ddde:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].num = i;
 800dde0:	7bfa      	ldrb	r2, [r7, #15]
 800dde2:	6879      	ldr	r1, [r7, #4]
 800dde4:	4613      	mov	r3, r2
 800dde6:	00db      	lsls	r3, r3, #3
 800dde8:	4413      	add	r3, r2
 800ddea:	009b      	lsls	r3, r3, #2
 800ddec:	440b      	add	r3, r1
 800ddee:	f503 7315 	add.w	r3, r3, #596	@ 0x254
 800ddf2:	7bfa      	ldrb	r2, [r7, #15]
 800ddf4:	701a      	strb	r2, [r3, #0]
    /* Control until ep is activated */
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 800ddf6:	7bfa      	ldrb	r2, [r7, #15]
 800ddf8:	6879      	ldr	r1, [r7, #4]
 800ddfa:	4613      	mov	r3, r2
 800ddfc:	00db      	lsls	r3, r3, #3
 800ddfe:	4413      	add	r3, r2
 800de00:	009b      	lsls	r3, r3, #2
 800de02:	440b      	add	r3, r1
 800de04:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 800de08:	2200      	movs	r2, #0
 800de0a:	701a      	strb	r2, [r3, #0]
    hpcd->OUT_ep[i].maxpacket = 0U;
 800de0c:	7bfa      	ldrb	r2, [r7, #15]
 800de0e:	6879      	ldr	r1, [r7, #4]
 800de10:	4613      	mov	r3, r2
 800de12:	00db      	lsls	r3, r3, #3
 800de14:	4413      	add	r3, r2
 800de16:	009b      	lsls	r3, r3, #2
 800de18:	440b      	add	r3, r1
 800de1a:	f503 7317 	add.w	r3, r3, #604	@ 0x25c
 800de1e:	2200      	movs	r2, #0
 800de20:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_buff = 0U;
 800de22:	7bfa      	ldrb	r2, [r7, #15]
 800de24:	6879      	ldr	r1, [r7, #4]
 800de26:	4613      	mov	r3, r2
 800de28:	00db      	lsls	r3, r3, #3
 800de2a:	4413      	add	r3, r2
 800de2c:	009b      	lsls	r3, r3, #2
 800de2e:	440b      	add	r3, r1
 800de30:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 800de34:	2200      	movs	r2, #0
 800de36:	601a      	str	r2, [r3, #0]
    hpcd->OUT_ep[i].xfer_len = 0U;
 800de38:	7bfa      	ldrb	r2, [r7, #15]
 800de3a:	6879      	ldr	r1, [r7, #4]
 800de3c:	4613      	mov	r3, r2
 800de3e:	00db      	lsls	r3, r3, #3
 800de40:	4413      	add	r3, r2
 800de42:	009b      	lsls	r3, r3, #2
 800de44:	440b      	add	r3, r1
 800de46:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 800de4a:	2200      	movs	r2, #0
 800de4c:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800de4e:	7bfb      	ldrb	r3, [r7, #15]
 800de50:	3301      	adds	r3, #1
 800de52:	73fb      	strb	r3, [r7, #15]
 800de54:	687b      	ldr	r3, [r7, #4]
 800de56:	791b      	ldrb	r3, [r3, #4]
 800de58:	7bfa      	ldrb	r2, [r7, #15]
 800de5a:	429a      	cmp	r2, r3
 800de5c:	d3b5      	bcc.n	800ddca <HAL_PCD_Init+0x142>
  }

  /* Init Device */
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 800de5e:	687b      	ldr	r3, [r7, #4]
 800de60:	6818      	ldr	r0, [r3, #0]
 800de62:	687b      	ldr	r3, [r7, #4]
 800de64:	7c1a      	ldrb	r2, [r3, #16]
 800de66:	f88d 2000 	strb.w	r2, [sp]
 800de6a:	3304      	adds	r3, #4
 800de6c:	cb0e      	ldmia	r3, {r1, r2, r3}
 800de6e:	f005 ff4f 	bl	8013d10 <USB_DevInit>
 800de72:	4603      	mov	r3, r0
 800de74:	2b00      	cmp	r3, #0
 800de76:	d005      	beq.n	800de84 <HAL_PCD_Init+0x1fc>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 800de78:	687b      	ldr	r3, [r7, #4]
 800de7a:	2202      	movs	r2, #2
 800de7c:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    return HAL_ERROR;
 800de80:	2301      	movs	r3, #1
 800de82:	e00c      	b.n	800de9e <HAL_PCD_Init+0x216>
  }

  hpcd->USB_Address = 0U;
 800de84:	687b      	ldr	r3, [r7, #4]
 800de86:	2200      	movs	r2, #0
 800de88:	745a      	strb	r2, [r3, #17]
  hpcd->State = HAL_PCD_STATE_READY;
 800de8a:	687b      	ldr	r3, [r7, #4]
 800de8c:	2201      	movs	r2, #1
 800de8e:	f883 2495 	strb.w	r2, [r3, #1173]	@ 0x495
    (void)HAL_PCDEx_ActivateLPM(hpcd);
  }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
  (void)USB_DevDisconnect(hpcd->Instance);
 800de92:	687b      	ldr	r3, [r7, #4]
 800de94:	681b      	ldr	r3, [r3, #0]
 800de96:	4618      	mov	r0, r3
 800de98:	f006 ff93 	bl	8014dc2 <USB_DevDisconnect>

  return HAL_OK;
 800de9c:	2300      	movs	r3, #0
}
 800de9e:	4618      	mov	r0, r3
 800dea0:	3710      	adds	r7, #16
 800dea2:	46bd      	mov	sp, r7
 800dea4:	bd80      	pop	{r7, pc}

0800dea6 <HAL_PCD_Start>:
  * @brief  Start the USB device
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{
 800dea6:	b580      	push	{r7, lr}
 800dea8:	b084      	sub	sp, #16
 800deaa:	af00      	add	r7, sp, #0
 800deac:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800deae:	687b      	ldr	r3, [r7, #4]
 800deb0:	681b      	ldr	r3, [r3, #0]
 800deb2:	60fb      	str	r3, [r7, #12]

  __HAL_LOCK(hpcd);
 800deb4:	687b      	ldr	r3, [r7, #4]
 800deb6:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800deba:	2b01      	cmp	r3, #1
 800debc:	d101      	bne.n	800dec2 <HAL_PCD_Start+0x1c>
 800debe:	2302      	movs	r3, #2
 800dec0:	e022      	b.n	800df08 <HAL_PCD_Start+0x62>
 800dec2:	687b      	ldr	r3, [r7, #4]
 800dec4:	2201      	movs	r2, #1
 800dec6:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 800deca:	68fb      	ldr	r3, [r7, #12]
 800decc:	68db      	ldr	r3, [r3, #12]
 800dece:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800ded2:	2b00      	cmp	r3, #0
 800ded4:	d009      	beq.n	800deea <HAL_PCD_Start+0x44>
      (hpcd->Init.battery_charging_enable == 1U))
 800ded6:	687b      	ldr	r3, [r7, #4]
 800ded8:	7b5b      	ldrb	r3, [r3, #13]
  if (((USBx->GUSBCFG & USB_OTG_GUSBCFG_PHYSEL) != 0U) &&
 800deda:	2b01      	cmp	r3, #1
 800dedc:	d105      	bne.n	800deea <HAL_PCD_Start+0x44>
  {
    /* Enable USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 800dede:	68fb      	ldr	r3, [r7, #12]
 800dee0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800dee2:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 800dee6:	68fb      	ldr	r3, [r7, #12]
 800dee8:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  __HAL_PCD_ENABLE(hpcd);
 800deea:	687b      	ldr	r3, [r7, #4]
 800deec:	681b      	ldr	r3, [r3, #0]
 800deee:	4618      	mov	r0, r3
 800def0:	f005 fea0 	bl	8013c34 <USB_EnableGlobalInt>
  (void)USB_DevConnect(hpcd->Instance);
 800def4:	687b      	ldr	r3, [r7, #4]
 800def6:	681b      	ldr	r3, [r3, #0]
 800def8:	4618      	mov	r0, r3
 800defa:	f006 ff41 	bl	8014d80 <USB_DevConnect>
  __HAL_UNLOCK(hpcd);
 800defe:	687b      	ldr	r3, [r7, #4]
 800df00:	2200      	movs	r2, #0
 800df02:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 800df06:	2300      	movs	r3, #0
}
 800df08:	4618      	mov	r0, r3
 800df0a:	3710      	adds	r7, #16
 800df0c:	46bd      	mov	sp, r7
 800df0e:	bd80      	pop	{r7, pc}

0800df10 <HAL_PCD_IRQHandler>:
  * @brief  Handles PCD interrupt request.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd)
{
 800df10:	b590      	push	{r4, r7, lr}
 800df12:	b08d      	sub	sp, #52	@ 0x34
 800df14:	af00      	add	r7, sp, #0
 800df16:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800df18:	687b      	ldr	r3, [r7, #4]
 800df1a:	681b      	ldr	r3, [r3, #0]
 800df1c:	623b      	str	r3, [r7, #32]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800df1e:	6a3b      	ldr	r3, [r7, #32]
 800df20:	61fb      	str	r3, [r7, #28]
  uint32_t epnum;
  uint32_t fifoemptymsk;
  uint32_t RegVal;

  /* ensure that we are in device mode */
  if (USB_GetMode(hpcd->Instance) == USB_OTG_MODE_DEVICE)
 800df22:	687b      	ldr	r3, [r7, #4]
 800df24:	681b      	ldr	r3, [r3, #0]
 800df26:	4618      	mov	r0, r3
 800df28:	f006 ffff 	bl	8014f2a <USB_GetMode>
 800df2c:	4603      	mov	r3, r0
 800df2e:	2b00      	cmp	r3, #0
 800df30:	f040 848c 	bne.w	800e84c <HAL_PCD_IRQHandler+0x93c>
  {
    /* avoid spurious interrupt */
    if (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
 800df34:	687b      	ldr	r3, [r7, #4]
 800df36:	681b      	ldr	r3, [r3, #0]
 800df38:	4618      	mov	r0, r3
 800df3a:	f006 ff63 	bl	8014e04 <USB_ReadInterrupts>
 800df3e:	4603      	mov	r3, r0
 800df40:	2b00      	cmp	r3, #0
 800df42:	f000 8482 	beq.w	800e84a <HAL_PCD_IRQHandler+0x93a>
    {
      return;
    }

    /* store current frame number */
    hpcd->FrameNumber = (USBx_DEVICE->DSTS & USB_OTG_DSTS_FNSOF_Msk) >> USB_OTG_DSTS_FNSOF_Pos;
 800df46:	69fb      	ldr	r3, [r7, #28]
 800df48:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800df4c:	689b      	ldr	r3, [r3, #8]
 800df4e:	0a1b      	lsrs	r3, r3, #8
 800df50:	f3c3 020d 	ubfx	r2, r3, #0, #14
 800df54:	687b      	ldr	r3, [r7, #4]
 800df56:	f8c3 24d4 	str.w	r2, [r3, #1236]	@ 0x4d4

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_MMIS))
 800df5a:	687b      	ldr	r3, [r7, #4]
 800df5c:	681b      	ldr	r3, [r3, #0]
 800df5e:	4618      	mov	r0, r3
 800df60:	f006 ff50 	bl	8014e04 <USB_ReadInterrupts>
 800df64:	4603      	mov	r3, r0
 800df66:	f003 0302 	and.w	r3, r3, #2
 800df6a:	2b02      	cmp	r3, #2
 800df6c:	d107      	bne.n	800df7e <HAL_PCD_IRQHandler+0x6e>
    {
      /* incorrect mode, acknowledge the interrupt */
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_MMIS);
 800df6e:	687b      	ldr	r3, [r7, #4]
 800df70:	681b      	ldr	r3, [r3, #0]
 800df72:	695a      	ldr	r2, [r3, #20]
 800df74:	687b      	ldr	r3, [r7, #4]
 800df76:	681b      	ldr	r3, [r3, #0]
 800df78:	f002 0202 	and.w	r2, r2, #2
 800df7c:	615a      	str	r2, [r3, #20]
    }

    /* Handle RxQLevel Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_RXFLVL))
 800df7e:	687b      	ldr	r3, [r7, #4]
 800df80:	681b      	ldr	r3, [r3, #0]
 800df82:	4618      	mov	r0, r3
 800df84:	f006 ff3e 	bl	8014e04 <USB_ReadInterrupts>
 800df88:	4603      	mov	r3, r0
 800df8a:	f003 0310 	and.w	r3, r3, #16
 800df8e:	2b10      	cmp	r3, #16
 800df90:	d161      	bne.n	800e056 <HAL_PCD_IRQHandler+0x146>
    {
      USB_MASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800df92:	687b      	ldr	r3, [r7, #4]
 800df94:	681b      	ldr	r3, [r3, #0]
 800df96:	699a      	ldr	r2, [r3, #24]
 800df98:	687b      	ldr	r3, [r7, #4]
 800df9a:	681b      	ldr	r3, [r3, #0]
 800df9c:	f022 0210 	bic.w	r2, r2, #16
 800dfa0:	619a      	str	r2, [r3, #24]

      RegVal = USBx->GRXSTSP;
 800dfa2:	6a3b      	ldr	r3, [r7, #32]
 800dfa4:	6a1b      	ldr	r3, [r3, #32]
 800dfa6:	61bb      	str	r3, [r7, #24]

      ep = &hpcd->OUT_ep[RegVal & USB_OTG_GRXSTSP_EPNUM];
 800dfa8:	69bb      	ldr	r3, [r7, #24]
 800dfaa:	f003 020f 	and.w	r2, r3, #15
 800dfae:	4613      	mov	r3, r2
 800dfb0:	00db      	lsls	r3, r3, #3
 800dfb2:	4413      	add	r3, r2
 800dfb4:	009b      	lsls	r3, r3, #2
 800dfb6:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800dfba:	687a      	ldr	r2, [r7, #4]
 800dfbc:	4413      	add	r3, r2
 800dfbe:	3304      	adds	r3, #4
 800dfc0:	617b      	str	r3, [r7, #20]

      if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) ==  STS_DATA_UPDT)
 800dfc2:	69bb      	ldr	r3, [r7, #24]
 800dfc4:	0c5b      	lsrs	r3, r3, #17
 800dfc6:	f003 030f 	and.w	r3, r3, #15
 800dfca:	2b02      	cmp	r3, #2
 800dfcc:	d124      	bne.n	800e018 <HAL_PCD_IRQHandler+0x108>
      {
        if ((RegVal & USB_OTG_GRXSTSP_BCNT) != 0U)
 800dfce:	69ba      	ldr	r2, [r7, #24]
 800dfd0:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 800dfd4:	4013      	ands	r3, r2
 800dfd6:	2b00      	cmp	r3, #0
 800dfd8:	d035      	beq.n	800e046 <HAL_PCD_IRQHandler+0x136>
        {
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 800dfda:	697b      	ldr	r3, [r7, #20]
 800dfdc:	68d9      	ldr	r1, [r3, #12]
                               (uint16_t)((RegVal & USB_OTG_GRXSTSP_BCNT) >> 4));
 800dfde:	69bb      	ldr	r3, [r7, #24]
 800dfe0:	091b      	lsrs	r3, r3, #4
 800dfe2:	b29b      	uxth	r3, r3
          (void)USB_ReadPacket(USBx, ep->xfer_buff,
 800dfe4:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800dfe8:	b29b      	uxth	r3, r3
 800dfea:	461a      	mov	r2, r3
 800dfec:	6a38      	ldr	r0, [r7, #32]
 800dfee:	f006 fd75 	bl	8014adc <USB_ReadPacket>

          ep->xfer_buff += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800dff2:	697b      	ldr	r3, [r7, #20]
 800dff4:	68da      	ldr	r2, [r3, #12]
 800dff6:	69bb      	ldr	r3, [r7, #24]
 800dff8:	091b      	lsrs	r3, r3, #4
 800dffa:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800dffe:	441a      	add	r2, r3
 800e000:	697b      	ldr	r3, [r7, #20]
 800e002:	60da      	str	r2, [r3, #12]
          ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800e004:	697b      	ldr	r3, [r7, #20]
 800e006:	695a      	ldr	r2, [r3, #20]
 800e008:	69bb      	ldr	r3, [r7, #24]
 800e00a:	091b      	lsrs	r3, r3, #4
 800e00c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800e010:	441a      	add	r2, r3
 800e012:	697b      	ldr	r3, [r7, #20]
 800e014:	615a      	str	r2, [r3, #20]
 800e016:	e016      	b.n	800e046 <HAL_PCD_IRQHandler+0x136>
        }
      }
      else if (((RegVal & USB_OTG_GRXSTSP_PKTSTS) >> 17) == STS_SETUP_UPDT)
 800e018:	69bb      	ldr	r3, [r7, #24]
 800e01a:	0c5b      	lsrs	r3, r3, #17
 800e01c:	f003 030f 	and.w	r3, r3, #15
 800e020:	2b06      	cmp	r3, #6
 800e022:	d110      	bne.n	800e046 <HAL_PCD_IRQHandler+0x136>
      {
        (void)USB_ReadPacket(USBx, (uint8_t *)hpcd->Setup, 8U);
 800e024:	687b      	ldr	r3, [r7, #4]
 800e026:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800e02a:	2208      	movs	r2, #8
 800e02c:	4619      	mov	r1, r3
 800e02e:	6a38      	ldr	r0, [r7, #32]
 800e030:	f006 fd54 	bl	8014adc <USB_ReadPacket>
        ep->xfer_count += (RegVal & USB_OTG_GRXSTSP_BCNT) >> 4;
 800e034:	697b      	ldr	r3, [r7, #20]
 800e036:	695a      	ldr	r2, [r3, #20]
 800e038:	69bb      	ldr	r3, [r7, #24]
 800e03a:	091b      	lsrs	r3, r3, #4
 800e03c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800e040:	441a      	add	r2, r3
 800e042:	697b      	ldr	r3, [r7, #20]
 800e044:	615a      	str	r2, [r3, #20]
      else
      {
        /* ... */
      }

      USB_UNMASK_INTERRUPT(hpcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 800e046:	687b      	ldr	r3, [r7, #4]
 800e048:	681b      	ldr	r3, [r3, #0]
 800e04a:	699a      	ldr	r2, [r3, #24]
 800e04c:	687b      	ldr	r3, [r7, #4]
 800e04e:	681b      	ldr	r3, [r3, #0]
 800e050:	f042 0210 	orr.w	r2, r2, #16
 800e054:	619a      	str	r2, [r3, #24]
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OEPINT))
 800e056:	687b      	ldr	r3, [r7, #4]
 800e058:	681b      	ldr	r3, [r3, #0]
 800e05a:	4618      	mov	r0, r3
 800e05c:	f006 fed2 	bl	8014e04 <USB_ReadInterrupts>
 800e060:	4603      	mov	r3, r0
 800e062:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800e066:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 800e06a:	f040 80a7 	bne.w	800e1bc <HAL_PCD_IRQHandler+0x2ac>
    {
      epnum = 0U;
 800e06e:	2300      	movs	r3, #0
 800e070:	627b      	str	r3, [r7, #36]	@ 0x24

      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd->Instance);
 800e072:	687b      	ldr	r3, [r7, #4]
 800e074:	681b      	ldr	r3, [r3, #0]
 800e076:	4618      	mov	r0, r3
 800e078:	f006 fed7 	bl	8014e2a <USB_ReadDevAllOutEpInterrupt>
 800e07c:	62b8      	str	r0, [r7, #40]	@ 0x28

      while (ep_intr != 0U)
 800e07e:	e099      	b.n	800e1b4 <HAL_PCD_IRQHandler+0x2a4>
      {
        if ((ep_intr & 0x1U) != 0U)
 800e080:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e082:	f003 0301 	and.w	r3, r3, #1
 800e086:	2b00      	cmp	r3, #0
 800e088:	f000 808e 	beq.w	800e1a8 <HAL_PCD_IRQHandler+0x298>
        {
          epint = USB_ReadDevOutEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800e08c:	687b      	ldr	r3, [r7, #4]
 800e08e:	681b      	ldr	r3, [r3, #0]
 800e090:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e092:	b2d2      	uxtb	r2, r2
 800e094:	4611      	mov	r1, r2
 800e096:	4618      	mov	r0, r3
 800e098:	f006 fefb 	bl	8014e92 <USB_ReadDevOutEPInterrupt>
 800e09c:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
 800e09e:	693b      	ldr	r3, [r7, #16]
 800e0a0:	f003 0301 	and.w	r3, r3, #1
 800e0a4:	2b00      	cmp	r3, #0
 800e0a6:	d00c      	beq.n	800e0c2 <HAL_PCD_IRQHandler+0x1b2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
 800e0a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0aa:	015a      	lsls	r2, r3, #5
 800e0ac:	69fb      	ldr	r3, [r7, #28]
 800e0ae:	4413      	add	r3, r2
 800e0b0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e0b4:	461a      	mov	r2, r3
 800e0b6:	2301      	movs	r3, #1
 800e0b8:	6093      	str	r3, [r2, #8]
            (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
 800e0ba:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800e0bc:	6878      	ldr	r0, [r7, #4]
 800e0be:	f000 fea1 	bl	800ee04 <PCD_EP_OutXfrComplete_int>
          }

          if ((epint & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
 800e0c2:	693b      	ldr	r3, [r7, #16]
 800e0c4:	f003 0308 	and.w	r3, r3, #8
 800e0c8:	2b00      	cmp	r3, #0
 800e0ca:	d00c      	beq.n	800e0e6 <HAL_PCD_IRQHandler+0x1d6>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
 800e0cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0ce:	015a      	lsls	r2, r3, #5
 800e0d0:	69fb      	ldr	r3, [r7, #28]
 800e0d2:	4413      	add	r3, r2
 800e0d4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e0d8:	461a      	mov	r2, r3
 800e0da:	2308      	movs	r3, #8
 800e0dc:	6093      	str	r3, [r2, #8]
            /* Class B setup phase done for previous decoded setup */
            (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
 800e0de:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800e0e0:	6878      	ldr	r0, [r7, #4]
 800e0e2:	f000 ff77 	bl	800efd4 <PCD_EP_OutSetupPacket_int>
          }

          if ((epint & USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
 800e0e6:	693b      	ldr	r3, [r7, #16]
 800e0e8:	f003 0310 	and.w	r3, r3, #16
 800e0ec:	2b00      	cmp	r3, #0
 800e0ee:	d008      	beq.n	800e102 <HAL_PCD_IRQHandler+0x1f2>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
 800e0f0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0f2:	015a      	lsls	r2, r3, #5
 800e0f4:	69fb      	ldr	r3, [r7, #28]
 800e0f6:	4413      	add	r3, r2
 800e0f8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e0fc:	461a      	mov	r2, r3
 800e0fe:	2310      	movs	r3, #16
 800e100:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT Endpoint disable interrupt */
          if ((epint & USB_OTG_DOEPINT_EPDISD) == USB_OTG_DOEPINT_EPDISD)
 800e102:	693b      	ldr	r3, [r7, #16]
 800e104:	f003 0302 	and.w	r3, r3, #2
 800e108:	2b00      	cmp	r3, #0
 800e10a:	d030      	beq.n	800e16e <HAL_PCD_IRQHandler+0x25e>
          {
            if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == USB_OTG_GINTSTS_BOUTNAKEFF)
 800e10c:	6a3b      	ldr	r3, [r7, #32]
 800e10e:	695b      	ldr	r3, [r3, #20]
 800e110:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e114:	2b80      	cmp	r3, #128	@ 0x80
 800e116:	d109      	bne.n	800e12c <HAL_PCD_IRQHandler+0x21c>
            {
              USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGONAK;
 800e118:	69fb      	ldr	r3, [r7, #28]
 800e11a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e11e:	685b      	ldr	r3, [r3, #4]
 800e120:	69fa      	ldr	r2, [r7, #28]
 800e122:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e126:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 800e12a:	6053      	str	r3, [r2, #4]
            }

            ep = &hpcd->OUT_ep[epnum];
 800e12c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e12e:	4613      	mov	r3, r2
 800e130:	00db      	lsls	r3, r3, #3
 800e132:	4413      	add	r3, r2
 800e134:	009b      	lsls	r3, r3, #2
 800e136:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e13a:	687a      	ldr	r2, [r7, #4]
 800e13c:	4413      	add	r3, r2
 800e13e:	3304      	adds	r3, #4
 800e140:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 800e142:	697b      	ldr	r3, [r7, #20]
 800e144:	78db      	ldrb	r3, [r3, #3]
 800e146:	2b01      	cmp	r3, #1
 800e148:	d108      	bne.n	800e15c <HAL_PCD_IRQHandler+0x24c>
            {
              ep->is_iso_incomplete = 0U;
 800e14a:	697b      	ldr	r3, [r7, #20]
 800e14c:	2200      	movs	r2, #0
 800e14e:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
 800e150:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e152:	b2db      	uxtb	r3, r3
 800e154:	4619      	mov	r1, r3
 800e156:	6878      	ldr	r0, [r7, #4]
 800e158:	f00d fcfe 	bl	801bb58 <HAL_PCD_ISOOUTIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_EPDISD);
 800e15c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e15e:	015a      	lsls	r2, r3, #5
 800e160:	69fb      	ldr	r3, [r7, #28]
 800e162:	4413      	add	r3, r2
 800e164:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e168:	461a      	mov	r2, r3
 800e16a:	2302      	movs	r3, #2
 800e16c:	6093      	str	r3, [r2, #8]
          }

          /* Clear Status Phase Received interrupt */
          if ((epint & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800e16e:	693b      	ldr	r3, [r7, #16]
 800e170:	f003 0320 	and.w	r3, r3, #32
 800e174:	2b00      	cmp	r3, #0
 800e176:	d008      	beq.n	800e18a <HAL_PCD_IRQHandler+0x27a>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800e178:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e17a:	015a      	lsls	r2, r3, #5
 800e17c:	69fb      	ldr	r3, [r7, #28]
 800e17e:	4413      	add	r3, r2
 800e180:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e184:	461a      	mov	r2, r3
 800e186:	2320      	movs	r3, #32
 800e188:	6093      	str	r3, [r2, #8]
          }

          /* Clear OUT NAK interrupt */
          if ((epint & USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
 800e18a:	693b      	ldr	r3, [r7, #16]
 800e18c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800e190:	2b00      	cmp	r3, #0
 800e192:	d009      	beq.n	800e1a8 <HAL_PCD_IRQHandler+0x298>
          {
            CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
 800e194:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e196:	015a      	lsls	r2, r3, #5
 800e198:	69fb      	ldr	r3, [r7, #28]
 800e19a:	4413      	add	r3, r2
 800e19c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e1a0:	461a      	mov	r2, r3
 800e1a2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 800e1a6:	6093      	str	r3, [r2, #8]
          }
        }
        epnum++;
 800e1a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e1aa:	3301      	adds	r3, #1
 800e1ac:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 800e1ae:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e1b0:	085b      	lsrs	r3, r3, #1
 800e1b2:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 800e1b4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e1b6:	2b00      	cmp	r3, #0
 800e1b8:	f47f af62 	bne.w	800e080 <HAL_PCD_IRQHandler+0x170>
      }
    }

    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IEPINT))
 800e1bc:	687b      	ldr	r3, [r7, #4]
 800e1be:	681b      	ldr	r3, [r3, #0]
 800e1c0:	4618      	mov	r0, r3
 800e1c2:	f006 fe1f 	bl	8014e04 <USB_ReadInterrupts>
 800e1c6:	4603      	mov	r3, r0
 800e1c8:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 800e1cc:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800e1d0:	f040 80db 	bne.w	800e38a <HAL_PCD_IRQHandler+0x47a>
    {
      /* Read in the device interrupt bits */
      ep_intr = USB_ReadDevAllInEpInterrupt(hpcd->Instance);
 800e1d4:	687b      	ldr	r3, [r7, #4]
 800e1d6:	681b      	ldr	r3, [r3, #0]
 800e1d8:	4618      	mov	r0, r3
 800e1da:	f006 fe40 	bl	8014e5e <USB_ReadDevAllInEpInterrupt>
 800e1de:	62b8      	str	r0, [r7, #40]	@ 0x28

      epnum = 0U;
 800e1e0:	2300      	movs	r3, #0
 800e1e2:	627b      	str	r3, [r7, #36]	@ 0x24

      while (ep_intr != 0U)
 800e1e4:	e0cd      	b.n	800e382 <HAL_PCD_IRQHandler+0x472>
      {
        if ((ep_intr & 0x1U) != 0U) /* In ITR */
 800e1e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e1e8:	f003 0301 	and.w	r3, r3, #1
 800e1ec:	2b00      	cmp	r3, #0
 800e1ee:	f000 80c2 	beq.w	800e376 <HAL_PCD_IRQHandler+0x466>
        {
          epint = USB_ReadDevInEPInterrupt(hpcd->Instance, (uint8_t)epnum);
 800e1f2:	687b      	ldr	r3, [r7, #4]
 800e1f4:	681b      	ldr	r3, [r3, #0]
 800e1f6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e1f8:	b2d2      	uxtb	r2, r2
 800e1fa:	4611      	mov	r1, r2
 800e1fc:	4618      	mov	r0, r3
 800e1fe:	f006 fe66 	bl	8014ece <USB_ReadDevInEPInterrupt>
 800e202:	6138      	str	r0, [r7, #16]

          if ((epint & USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
 800e204:	693b      	ldr	r3, [r7, #16]
 800e206:	f003 0301 	and.w	r3, r3, #1
 800e20a:	2b00      	cmp	r3, #0
 800e20c:	d057      	beq.n	800e2be <HAL_PCD_IRQHandler+0x3ae>
          {
            fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800e20e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e210:	f003 030f 	and.w	r3, r3, #15
 800e214:	2201      	movs	r2, #1
 800e216:	fa02 f303 	lsl.w	r3, r2, r3
 800e21a:	60fb      	str	r3, [r7, #12]
            USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800e21c:	69fb      	ldr	r3, [r7, #28]
 800e21e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e222:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800e224:	68fb      	ldr	r3, [r7, #12]
 800e226:	43db      	mvns	r3, r3
 800e228:	69f9      	ldr	r1, [r7, #28]
 800e22a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800e22e:	4013      	ands	r3, r2
 800e230:	634b      	str	r3, [r1, #52]	@ 0x34

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
 800e232:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e234:	015a      	lsls	r2, r3, #5
 800e236:	69fb      	ldr	r3, [r7, #28]
 800e238:	4413      	add	r3, r2
 800e23a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e23e:	461a      	mov	r2, r3
 800e240:	2301      	movs	r3, #1
 800e242:	6093      	str	r3, [r2, #8]

            if (hpcd->Init.dma_enable == 1U)
 800e244:	687b      	ldr	r3, [r7, #4]
 800e246:	799b      	ldrb	r3, [r3, #6]
 800e248:	2b01      	cmp	r3, #1
 800e24a:	d132      	bne.n	800e2b2 <HAL_PCD_IRQHandler+0x3a2>
            {
              hpcd->IN_ep[epnum].xfer_buff += hpcd->IN_ep[epnum].maxpacket;
 800e24c:	6879      	ldr	r1, [r7, #4]
 800e24e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e250:	4613      	mov	r3, r2
 800e252:	00db      	lsls	r3, r3, #3
 800e254:	4413      	add	r3, r2
 800e256:	009b      	lsls	r3, r3, #2
 800e258:	440b      	add	r3, r1
 800e25a:	3320      	adds	r3, #32
 800e25c:	6819      	ldr	r1, [r3, #0]
 800e25e:	6878      	ldr	r0, [r7, #4]
 800e260:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e262:	4613      	mov	r3, r2
 800e264:	00db      	lsls	r3, r3, #3
 800e266:	4413      	add	r3, r2
 800e268:	009b      	lsls	r3, r3, #2
 800e26a:	4403      	add	r3, r0
 800e26c:	331c      	adds	r3, #28
 800e26e:	681b      	ldr	r3, [r3, #0]
 800e270:	4419      	add	r1, r3
 800e272:	6878      	ldr	r0, [r7, #4]
 800e274:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e276:	4613      	mov	r3, r2
 800e278:	00db      	lsls	r3, r3, #3
 800e27a:	4413      	add	r3, r2
 800e27c:	009b      	lsls	r3, r3, #2
 800e27e:	4403      	add	r3, r0
 800e280:	3320      	adds	r3, #32
 800e282:	6019      	str	r1, [r3, #0]

              /* this is ZLP, so prepare EP0 for next setup */
              if ((epnum == 0U) && (hpcd->IN_ep[epnum].xfer_len == 0U))
 800e284:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e286:	2b00      	cmp	r3, #0
 800e288:	d113      	bne.n	800e2b2 <HAL_PCD_IRQHandler+0x3a2>
 800e28a:	6879      	ldr	r1, [r7, #4]
 800e28c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e28e:	4613      	mov	r3, r2
 800e290:	00db      	lsls	r3, r3, #3
 800e292:	4413      	add	r3, r2
 800e294:	009b      	lsls	r3, r3, #2
 800e296:	440b      	add	r3, r1
 800e298:	3324      	adds	r3, #36	@ 0x24
 800e29a:	681b      	ldr	r3, [r3, #0]
 800e29c:	2b00      	cmp	r3, #0
 800e29e:	d108      	bne.n	800e2b2 <HAL_PCD_IRQHandler+0x3a2>
              {
                /* prepare to rx more setup packets */
                (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800e2a0:	687b      	ldr	r3, [r7, #4]
 800e2a2:	6818      	ldr	r0, [r3, #0]
 800e2a4:	687b      	ldr	r3, [r7, #4]
 800e2a6:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800e2aa:	461a      	mov	r2, r3
 800e2ac:	2101      	movs	r1, #1
 800e2ae:	f006 fe6d 	bl	8014f8c <USB_EP0_OutStart>
            }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
            hpcd->DataInStageCallback(hpcd, (uint8_t)epnum);
#else
            HAL_PCD_DataInStageCallback(hpcd, (uint8_t)epnum);
 800e2b2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e2b4:	b2db      	uxtb	r3, r3
 800e2b6:	4619      	mov	r1, r3
 800e2b8:	6878      	ldr	r0, [r7, #4]
 800e2ba:	f00d fbd2 	bl	801ba62 <HAL_PCD_DataInStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
          }
          if ((epint & USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
 800e2be:	693b      	ldr	r3, [r7, #16]
 800e2c0:	f003 0308 	and.w	r3, r3, #8
 800e2c4:	2b00      	cmp	r3, #0
 800e2c6:	d008      	beq.n	800e2da <HAL_PCD_IRQHandler+0x3ca>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
 800e2c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e2ca:	015a      	lsls	r2, r3, #5
 800e2cc:	69fb      	ldr	r3, [r7, #28]
 800e2ce:	4413      	add	r3, r2
 800e2d0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e2d4:	461a      	mov	r2, r3
 800e2d6:	2308      	movs	r3, #8
 800e2d8:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
 800e2da:	693b      	ldr	r3, [r7, #16]
 800e2dc:	f003 0310 	and.w	r3, r3, #16
 800e2e0:	2b00      	cmp	r3, #0
 800e2e2:	d008      	beq.n	800e2f6 <HAL_PCD_IRQHandler+0x3e6>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
 800e2e4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e2e6:	015a      	lsls	r2, r3, #5
 800e2e8:	69fb      	ldr	r3, [r7, #28]
 800e2ea:	4413      	add	r3, r2
 800e2ec:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e2f0:	461a      	mov	r2, r3
 800e2f2:	2310      	movs	r3, #16
 800e2f4:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
 800e2f6:	693b      	ldr	r3, [r7, #16]
 800e2f8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800e2fc:	2b00      	cmp	r3, #0
 800e2fe:	d008      	beq.n	800e312 <HAL_PCD_IRQHandler+0x402>
          {
            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
 800e300:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e302:	015a      	lsls	r2, r3, #5
 800e304:	69fb      	ldr	r3, [r7, #28]
 800e306:	4413      	add	r3, r2
 800e308:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e30c:	461a      	mov	r2, r3
 800e30e:	2340      	movs	r3, #64	@ 0x40
 800e310:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
 800e312:	693b      	ldr	r3, [r7, #16]
 800e314:	f003 0302 	and.w	r3, r3, #2
 800e318:	2b00      	cmp	r3, #0
 800e31a:	d023      	beq.n	800e364 <HAL_PCD_IRQHandler+0x454>
          {
            (void)USB_FlushTxFifo(USBx, epnum);
 800e31c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800e31e:	6a38      	ldr	r0, [r7, #32]
 800e320:	f005 fe5a 	bl	8013fd8 <USB_FlushTxFifo>

            ep = &hpcd->IN_ep[epnum];
 800e324:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e326:	4613      	mov	r3, r2
 800e328:	00db      	lsls	r3, r3, #3
 800e32a:	4413      	add	r3, r2
 800e32c:	009b      	lsls	r3, r3, #2
 800e32e:	3310      	adds	r3, #16
 800e330:	687a      	ldr	r2, [r7, #4]
 800e332:	4413      	add	r3, r2
 800e334:	3304      	adds	r3, #4
 800e336:	617b      	str	r3, [r7, #20]

            if (ep->is_iso_incomplete == 1U)
 800e338:	697b      	ldr	r3, [r7, #20]
 800e33a:	78db      	ldrb	r3, [r3, #3]
 800e33c:	2b01      	cmp	r3, #1
 800e33e:	d108      	bne.n	800e352 <HAL_PCD_IRQHandler+0x442>
            {
              ep->is_iso_incomplete = 0U;
 800e340:	697b      	ldr	r3, [r7, #20]
 800e342:	2200      	movs	r2, #0
 800e344:	70da      	strb	r2, [r3, #3]

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
              hpcd->ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
#else
              HAL_PCD_ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
 800e346:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e348:	b2db      	uxtb	r3, r3
 800e34a:	4619      	mov	r1, r3
 800e34c:	6878      	ldr	r0, [r7, #4]
 800e34e:	f00d fc15 	bl	801bb7c <HAL_PCD_ISOINIncompleteCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
            }

            CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
 800e352:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e354:	015a      	lsls	r2, r3, #5
 800e356:	69fb      	ldr	r3, [r7, #28]
 800e358:	4413      	add	r3, r2
 800e35a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e35e:	461a      	mov	r2, r3
 800e360:	2302      	movs	r3, #2
 800e362:	6093      	str	r3, [r2, #8]
          }
          if ((epint & USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
 800e364:	693b      	ldr	r3, [r7, #16]
 800e366:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e36a:	2b00      	cmp	r3, #0
 800e36c:	d003      	beq.n	800e376 <HAL_PCD_IRQHandler+0x466>
          {
            (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
 800e36e:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800e370:	6878      	ldr	r0, [r7, #4]
 800e372:	f000 fcbb 	bl	800ecec <PCD_WriteEmptyTxFifo>
          }
        }
        epnum++;
 800e376:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e378:	3301      	adds	r3, #1
 800e37a:	627b      	str	r3, [r7, #36]	@ 0x24
        ep_intr >>= 1U;
 800e37c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e37e:	085b      	lsrs	r3, r3, #1
 800e380:	62bb      	str	r3, [r7, #40]	@ 0x28
      while (ep_intr != 0U)
 800e382:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e384:	2b00      	cmp	r3, #0
 800e386:	f47f af2e 	bne.w	800e1e6 <HAL_PCD_IRQHandler+0x2d6>
      }
    }

    /* Handle Resume Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT))
 800e38a:	687b      	ldr	r3, [r7, #4]
 800e38c:	681b      	ldr	r3, [r3, #0]
 800e38e:	4618      	mov	r0, r3
 800e390:	f006 fd38 	bl	8014e04 <USB_ReadInterrupts>
 800e394:	4603      	mov	r3, r0
 800e396:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 800e39a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 800e39e:	d122      	bne.n	800e3e6 <HAL_PCD_IRQHandler+0x4d6>
    {
      /* Clear the Remote Wake-up Signaling */
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800e3a0:	69fb      	ldr	r3, [r7, #28]
 800e3a2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e3a6:	685b      	ldr	r3, [r3, #4]
 800e3a8:	69fa      	ldr	r2, [r7, #28]
 800e3aa:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e3ae:	f023 0301 	bic.w	r3, r3, #1
 800e3b2:	6053      	str	r3, [r2, #4]

      if (hpcd->LPM_State == LPM_L1)
 800e3b4:	687b      	ldr	r3, [r7, #4]
 800e3b6:	f893 34cc 	ldrb.w	r3, [r3, #1228]	@ 0x4cc
 800e3ba:	2b01      	cmp	r3, #1
 800e3bc:	d108      	bne.n	800e3d0 <HAL_PCD_IRQHandler+0x4c0>
      {
        hpcd->LPM_State = LPM_L0;
 800e3be:	687b      	ldr	r3, [r7, #4]
 800e3c0:	2200      	movs	r2, #0
 800e3c2:	f883 24cc 	strb.w	r2, [r3, #1228]	@ 0x4cc

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->LPMCallback(hpcd, PCD_LPM_L0_ACTIVE);
#else
        HAL_PCDEx_LPM_Callback(hpcd, PCD_LPM_L0_ACTIVE);
 800e3c6:	2100      	movs	r1, #0
 800e3c8:	6878      	ldr	r0, [r7, #4]
 800e3ca:	f000 fea1 	bl	800f110 <HAL_PCDEx_LPM_Callback>
 800e3ce:	e002      	b.n	800e3d6 <HAL_PCD_IRQHandler+0x4c6>
      else
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->ResumeCallback(hpcd);
#else
        HAL_PCD_ResumeCallback(hpcd);
 800e3d0:	6878      	ldr	r0, [r7, #4]
 800e3d2:	f00d fbb3 	bl	801bb3c <HAL_PCD_ResumeCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_WKUINT);
 800e3d6:	687b      	ldr	r3, [r7, #4]
 800e3d8:	681b      	ldr	r3, [r3, #0]
 800e3da:	695a      	ldr	r2, [r3, #20]
 800e3dc:	687b      	ldr	r3, [r7, #4]
 800e3de:	681b      	ldr	r3, [r3, #0]
 800e3e0:	f002 4200 	and.w	r2, r2, #2147483648	@ 0x80000000
 800e3e4:	615a      	str	r2, [r3, #20]
    }

    /* Handle Suspend Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP))
 800e3e6:	687b      	ldr	r3, [r7, #4]
 800e3e8:	681b      	ldr	r3, [r3, #0]
 800e3ea:	4618      	mov	r0, r3
 800e3ec:	f006 fd0a 	bl	8014e04 <USB_ReadInterrupts>
 800e3f0:	4603      	mov	r3, r0
 800e3f2:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800e3f6:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800e3fa:	d112      	bne.n	800e422 <HAL_PCD_IRQHandler+0x512>
    {
      if ((USBx_DEVICE->DSTS & USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
 800e3fc:	69fb      	ldr	r3, [r7, #28]
 800e3fe:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e402:	689b      	ldr	r3, [r3, #8]
 800e404:	f003 0301 	and.w	r3, r3, #1
 800e408:	2b01      	cmp	r3, #1
 800e40a:	d102      	bne.n	800e412 <HAL_PCD_IRQHandler+0x502>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->SuspendCallback(hpcd);
#else
        HAL_PCD_SuspendCallback(hpcd);
 800e40c:	6878      	ldr	r0, [r7, #4]
 800e40e:	f00d fb6f 	bl	801baf0 <HAL_PCD_SuspendCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBSUSP);
 800e412:	687b      	ldr	r3, [r7, #4]
 800e414:	681b      	ldr	r3, [r3, #0]
 800e416:	695a      	ldr	r2, [r3, #20]
 800e418:	687b      	ldr	r3, [r7, #4]
 800e41a:	681b      	ldr	r3, [r3, #0]
 800e41c:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 800e420:	615a      	str	r2, [r3, #20]
    }
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */
    /* Handle Reset Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_USBRST))
 800e422:	687b      	ldr	r3, [r7, #4]
 800e424:	681b      	ldr	r3, [r3, #0]
 800e426:	4618      	mov	r0, r3
 800e428:	f006 fcec 	bl	8014e04 <USB_ReadInterrupts>
 800e42c:	4603      	mov	r3, r0
 800e42e:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 800e432:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800e436:	f040 80b7 	bne.w	800e5a8 <HAL_PCD_IRQHandler+0x698>
    {
      USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_RWUSIG;
 800e43a:	69fb      	ldr	r3, [r7, #28]
 800e43c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e440:	685b      	ldr	r3, [r3, #4]
 800e442:	69fa      	ldr	r2, [r7, #28]
 800e444:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e448:	f023 0301 	bic.w	r3, r3, #1
 800e44c:	6053      	str	r3, [r2, #4]
      (void)USB_FlushTxFifo(hpcd->Instance, 0x10U);
 800e44e:	687b      	ldr	r3, [r7, #4]
 800e450:	681b      	ldr	r3, [r3, #0]
 800e452:	2110      	movs	r1, #16
 800e454:	4618      	mov	r0, r3
 800e456:	f005 fdbf 	bl	8013fd8 <USB_FlushTxFifo>

      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800e45a:	2300      	movs	r3, #0
 800e45c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800e45e:	e046      	b.n	800e4ee <HAL_PCD_IRQHandler+0x5de>
      {
        USBx_INEP(i)->DIEPINT = 0xFB7FU;
 800e460:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e462:	015a      	lsls	r2, r3, #5
 800e464:	69fb      	ldr	r3, [r7, #28]
 800e466:	4413      	add	r3, r2
 800e468:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e46c:	461a      	mov	r2, r3
 800e46e:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 800e472:	6093      	str	r3, [r2, #8]
        USBx_INEP(i)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 800e474:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e476:	015a      	lsls	r2, r3, #5
 800e478:	69fb      	ldr	r3, [r7, #28]
 800e47a:	4413      	add	r3, r2
 800e47c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e480:	681b      	ldr	r3, [r3, #0]
 800e482:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800e484:	0151      	lsls	r1, r2, #5
 800e486:	69fa      	ldr	r2, [r7, #28]
 800e488:	440a      	add	r2, r1
 800e48a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 800e48e:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 800e492:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPINT = 0xFB7FU;
 800e494:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e496:	015a      	lsls	r2, r3, #5
 800e498:	69fb      	ldr	r3, [r7, #28]
 800e49a:	4413      	add	r3, r2
 800e49c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e4a0:	461a      	mov	r2, r3
 800e4a2:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 800e4a6:	6093      	str	r3, [r2, #8]
        USBx_OUTEP(i)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 800e4a8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e4aa:	015a      	lsls	r2, r3, #5
 800e4ac:	69fb      	ldr	r3, [r7, #28]
 800e4ae:	4413      	add	r3, r2
 800e4b0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e4b4:	681b      	ldr	r3, [r3, #0]
 800e4b6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800e4b8:	0151      	lsls	r1, r2, #5
 800e4ba:	69fa      	ldr	r2, [r7, #28]
 800e4bc:	440a      	add	r2, r1
 800e4be:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800e4c2:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 800e4c6:	6013      	str	r3, [r2, #0]
        USBx_OUTEP(i)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 800e4c8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e4ca:	015a      	lsls	r2, r3, #5
 800e4cc:	69fb      	ldr	r3, [r7, #28]
 800e4ce:	4413      	add	r3, r2
 800e4d0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e4d4:	681b      	ldr	r3, [r3, #0]
 800e4d6:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800e4d8:	0151      	lsls	r1, r2, #5
 800e4da:	69fa      	ldr	r2, [r7, #28]
 800e4dc:	440a      	add	r2, r1
 800e4de:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 800e4e2:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 800e4e6:	6013      	str	r3, [r2, #0]
      for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800e4e8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e4ea:	3301      	adds	r3, #1
 800e4ec:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800e4ee:	687b      	ldr	r3, [r7, #4]
 800e4f0:	791b      	ldrb	r3, [r3, #4]
 800e4f2:	461a      	mov	r2, r3
 800e4f4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e4f6:	4293      	cmp	r3, r2
 800e4f8:	d3b2      	bcc.n	800e460 <HAL_PCD_IRQHandler+0x550>
      }
      USBx_DEVICE->DAINTMSK |= 0x10001U;
 800e4fa:	69fb      	ldr	r3, [r7, #28]
 800e4fc:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e500:	69db      	ldr	r3, [r3, #28]
 800e502:	69fa      	ldr	r2, [r7, #28]
 800e504:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e508:	f043 1301 	orr.w	r3, r3, #65537	@ 0x10001
 800e50c:	61d3      	str	r3, [r2, #28]

      if (hpcd->Init.use_dedicated_ep1 != 0U)
 800e50e:	687b      	ldr	r3, [r7, #4]
 800e510:	7bdb      	ldrb	r3, [r3, #15]
 800e512:	2b00      	cmp	r3, #0
 800e514:	d016      	beq.n	800e544 <HAL_PCD_IRQHandler+0x634>
      {
        USBx_DEVICE->DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
 800e516:	69fb      	ldr	r3, [r7, #28]
 800e518:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e51c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800e520:	69fa      	ldr	r2, [r7, #28]
 800e522:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e526:	f043 030b 	orr.w	r3, r3, #11
 800e52a:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84
                                   USB_OTG_DOEPMSK_XFRCM |
                                   USB_OTG_DOEPMSK_EPDM;

        USBx_DEVICE->DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
 800e52e:	69fb      	ldr	r3, [r7, #28]
 800e530:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e534:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800e536:	69fa      	ldr	r2, [r7, #28]
 800e538:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e53c:	f043 030b 	orr.w	r3, r3, #11
 800e540:	6453      	str	r3, [r2, #68]	@ 0x44
 800e542:	e015      	b.n	800e570 <HAL_PCD_IRQHandler+0x660>
                                  USB_OTG_DIEPMSK_XFRCM |
                                  USB_OTG_DIEPMSK_EPDM;
      }
      else
      {
        USBx_DEVICE->DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
 800e544:	69fb      	ldr	r3, [r7, #28]
 800e546:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e54a:	695b      	ldr	r3, [r3, #20]
 800e54c:	69fa      	ldr	r2, [r7, #28]
 800e54e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e552:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 800e556:	f043 032b 	orr.w	r3, r3, #43	@ 0x2b
 800e55a:	6153      	str	r3, [r2, #20]
                                USB_OTG_DOEPMSK_XFRCM |
                                USB_OTG_DOEPMSK_EPDM |
                                USB_OTG_DOEPMSK_OTEPSPRM |
                                USB_OTG_DOEPMSK_NAKM;

        USBx_DEVICE->DIEPMSK |= USB_OTG_DIEPMSK_TOM |
 800e55c:	69fb      	ldr	r3, [r7, #28]
 800e55e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e562:	691b      	ldr	r3, [r3, #16]
 800e564:	69fa      	ldr	r2, [r7, #28]
 800e566:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e56a:	f043 030b 	orr.w	r3, r3, #11
 800e56e:	6113      	str	r3, [r2, #16]
                                USB_OTG_DIEPMSK_XFRCM |
                                USB_OTG_DIEPMSK_EPDM;
      }

      /* Set Default Address to 0 */
      USBx_DEVICE->DCFG &= ~USB_OTG_DCFG_DAD;
 800e570:	69fb      	ldr	r3, [r7, #28]
 800e572:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e576:	681b      	ldr	r3, [r3, #0]
 800e578:	69fa      	ldr	r2, [r7, #28]
 800e57a:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e57e:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 800e582:	6013      	str	r3, [r2, #0]

      /* setup EP0 to receive SETUP packets */
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 800e584:	687b      	ldr	r3, [r7, #4]
 800e586:	6818      	ldr	r0, [r3, #0]
 800e588:	687b      	ldr	r3, [r7, #4]
 800e58a:	7999      	ldrb	r1, [r3, #6]
                             (uint8_t *)hpcd->Setup);
 800e58c:	687b      	ldr	r3, [r7, #4]
 800e58e:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
      (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable,
 800e592:	461a      	mov	r2, r3
 800e594:	f006 fcfa 	bl	8014f8c <USB_EP0_OutStart>

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_USBRST);
 800e598:	687b      	ldr	r3, [r7, #4]
 800e59a:	681b      	ldr	r3, [r3, #0]
 800e59c:	695a      	ldr	r2, [r3, #20]
 800e59e:	687b      	ldr	r3, [r7, #4]
 800e5a0:	681b      	ldr	r3, [r3, #0]
 800e5a2:	f402 5280 	and.w	r2, r2, #4096	@ 0x1000
 800e5a6:	615a      	str	r2, [r3, #20]
    }

    /* Handle Enumeration done Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE))
 800e5a8:	687b      	ldr	r3, [r7, #4]
 800e5aa:	681b      	ldr	r3, [r3, #0]
 800e5ac:	4618      	mov	r0, r3
 800e5ae:	f006 fc29 	bl	8014e04 <USB_ReadInterrupts>
 800e5b2:	4603      	mov	r3, r0
 800e5b4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 800e5b8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800e5bc:	d123      	bne.n	800e606 <HAL_PCD_IRQHandler+0x6f6>
    {
      (void)USB_ActivateSetup(hpcd->Instance);
 800e5be:	687b      	ldr	r3, [r7, #4]
 800e5c0:	681b      	ldr	r3, [r3, #0]
 800e5c2:	4618      	mov	r0, r3
 800e5c4:	f006 fcbf 	bl	8014f46 <USB_ActivateSetup>
      hpcd->Init.speed = USB_GetDevSpeed(hpcd->Instance);
 800e5c8:	687b      	ldr	r3, [r7, #4]
 800e5ca:	681b      	ldr	r3, [r3, #0]
 800e5cc:	4618      	mov	r0, r3
 800e5ce:	f005 fd7c 	bl	80140ca <USB_GetDevSpeed>
 800e5d2:	4603      	mov	r3, r0
 800e5d4:	461a      	mov	r2, r3
 800e5d6:	687b      	ldr	r3, [r7, #4]
 800e5d8:	71da      	strb	r2, [r3, #7]

      /* Set USB Turnaround time */
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 800e5da:	687b      	ldr	r3, [r7, #4]
 800e5dc:	681c      	ldr	r4, [r3, #0]
 800e5de:	f001 f9c7 	bl	800f970 <HAL_RCC_GetHCLKFreq>
 800e5e2:	4601      	mov	r1, r0
                                  HAL_RCC_GetHCLKFreq(),
                                  (uint8_t)hpcd->Init.speed);
 800e5e4:	687b      	ldr	r3, [r7, #4]
 800e5e6:	79db      	ldrb	r3, [r3, #7]
      (void)USB_SetTurnaroundTime(hpcd->Instance,
 800e5e8:	461a      	mov	r2, r3
 800e5ea:	4620      	mov	r0, r4
 800e5ec:	f005 fa80 	bl	8013af0 <USB_SetTurnaroundTime>

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ResetCallback(hpcd);
#else
      HAL_PCD_ResetCallback(hpcd);
 800e5f0:	6878      	ldr	r0, [r7, #4]
 800e5f2:	f00d fa5e 	bl	801bab2 <HAL_PCD_ResetCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_ENUMDNE);
 800e5f6:	687b      	ldr	r3, [r7, #4]
 800e5f8:	681b      	ldr	r3, [r3, #0]
 800e5fa:	695a      	ldr	r2, [r3, #20]
 800e5fc:	687b      	ldr	r3, [r7, #4]
 800e5fe:	681b      	ldr	r3, [r3, #0]
 800e600:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 800e604:	615a      	str	r2, [r3, #20]
    }

    /* Handle SOF Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SOF))
 800e606:	687b      	ldr	r3, [r7, #4]
 800e608:	681b      	ldr	r3, [r3, #0]
 800e60a:	4618      	mov	r0, r3
 800e60c:	f006 fbfa 	bl	8014e04 <USB_ReadInterrupts>
 800e610:	4603      	mov	r3, r0
 800e612:	f003 0308 	and.w	r3, r3, #8
 800e616:	2b08      	cmp	r3, #8
 800e618:	d10a      	bne.n	800e630 <HAL_PCD_IRQHandler+0x720>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->SOFCallback(hpcd);
#else
      HAL_PCD_SOFCallback(hpcd);
 800e61a:	6878      	ldr	r0, [r7, #4]
 800e61c:	f00d fa3b 	bl	801ba96 <HAL_PCD_SOFCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SOF);
 800e620:	687b      	ldr	r3, [r7, #4]
 800e622:	681b      	ldr	r3, [r3, #0]
 800e624:	695a      	ldr	r2, [r3, #20]
 800e626:	687b      	ldr	r3, [r7, #4]
 800e628:	681b      	ldr	r3, [r3, #0]
 800e62a:	f002 0208 	and.w	r2, r2, #8
 800e62e:	615a      	str	r2, [r3, #20]
    }

    /* Handle Global OUT NAK effective Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_BOUTNAKEFF))
 800e630:	687b      	ldr	r3, [r7, #4]
 800e632:	681b      	ldr	r3, [r3, #0]
 800e634:	4618      	mov	r0, r3
 800e636:	f006 fbe5 	bl	8014e04 <USB_ReadInterrupts>
 800e63a:	4603      	mov	r3, r0
 800e63c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e640:	2b80      	cmp	r3, #128	@ 0x80
 800e642:	d123      	bne.n	800e68c <HAL_PCD_IRQHandler+0x77c>
    {
      USBx->GINTMSK &= ~USB_OTG_GINTMSK_GONAKEFFM;
 800e644:	6a3b      	ldr	r3, [r7, #32]
 800e646:	699b      	ldr	r3, [r3, #24]
 800e648:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 800e64c:	6a3b      	ldr	r3, [r7, #32]
 800e64e:	619a      	str	r2, [r3, #24]

      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800e650:	2301      	movs	r3, #1
 800e652:	627b      	str	r3, [r7, #36]	@ 0x24
 800e654:	e014      	b.n	800e680 <HAL_PCD_IRQHandler+0x770>
      {
        if (hpcd->OUT_ep[epnum].is_iso_incomplete == 1U)
 800e656:	6879      	ldr	r1, [r7, #4]
 800e658:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e65a:	4613      	mov	r3, r2
 800e65c:	00db      	lsls	r3, r3, #3
 800e65e:	4413      	add	r3, r2
 800e660:	009b      	lsls	r3, r3, #2
 800e662:	440b      	add	r3, r1
 800e664:	f203 2357 	addw	r3, r3, #599	@ 0x257
 800e668:	781b      	ldrb	r3, [r3, #0]
 800e66a:	2b01      	cmp	r3, #1
 800e66c:	d105      	bne.n	800e67a <HAL_PCD_IRQHandler+0x76a>
        {
          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)epnum);
 800e66e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e670:	b2db      	uxtb	r3, r3
 800e672:	4619      	mov	r1, r3
 800e674:	6878      	ldr	r0, [r7, #4]
 800e676:	f000 fb08 	bl	800ec8a <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800e67a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e67c:	3301      	adds	r3, #1
 800e67e:	627b      	str	r3, [r7, #36]	@ 0x24
 800e680:	687b      	ldr	r3, [r7, #4]
 800e682:	791b      	ldrb	r3, [r3, #4]
 800e684:	461a      	mov	r2, r3
 800e686:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e688:	4293      	cmp	r3, r2
 800e68a:	d3e4      	bcc.n	800e656 <HAL_PCD_IRQHandler+0x746>
        }
      }
    }

    /* Handle Incomplete ISO IN Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR))
 800e68c:	687b      	ldr	r3, [r7, #4]
 800e68e:	681b      	ldr	r3, [r3, #0]
 800e690:	4618      	mov	r0, r3
 800e692:	f006 fbb7 	bl	8014e04 <USB_ReadInterrupts>
 800e696:	4603      	mov	r3, r0
 800e698:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800e69c:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800e6a0:	d13c      	bne.n	800e71c <HAL_PCD_IRQHandler+0x80c>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800e6a2:	2301      	movs	r3, #1
 800e6a4:	627b      	str	r3, [r7, #36]	@ 0x24
 800e6a6:	e02b      	b.n	800e700 <HAL_PCD_IRQHandler+0x7f0>
      {
        RegVal = USBx_INEP(epnum)->DIEPCTL;
 800e6a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e6aa:	015a      	lsls	r2, r3, #5
 800e6ac:	69fb      	ldr	r3, [r7, #28]
 800e6ae:	4413      	add	r3, r2
 800e6b0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800e6b4:	681b      	ldr	r3, [r3, #0]
 800e6b6:	61bb      	str	r3, [r7, #24]

        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800e6b8:	6879      	ldr	r1, [r7, #4]
 800e6ba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e6bc:	4613      	mov	r3, r2
 800e6be:	00db      	lsls	r3, r3, #3
 800e6c0:	4413      	add	r3, r2
 800e6c2:	009b      	lsls	r3, r3, #2
 800e6c4:	440b      	add	r3, r1
 800e6c6:	3318      	adds	r3, #24
 800e6c8:	781b      	ldrb	r3, [r3, #0]
 800e6ca:	2b01      	cmp	r3, #1
 800e6cc:	d115      	bne.n	800e6fa <HAL_PCD_IRQHandler+0x7ea>
            ((RegVal & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA))
 800e6ce:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->IN_ep[epnum].type == EP_TYPE_ISOC) &&
 800e6d0:	2b00      	cmp	r3, #0
 800e6d2:	da12      	bge.n	800e6fa <HAL_PCD_IRQHandler+0x7ea>
        {
          hpcd->IN_ep[epnum].is_iso_incomplete = 1U;
 800e6d4:	6879      	ldr	r1, [r7, #4]
 800e6d6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e6d8:	4613      	mov	r3, r2
 800e6da:	00db      	lsls	r3, r3, #3
 800e6dc:	4413      	add	r3, r2
 800e6de:	009b      	lsls	r3, r3, #2
 800e6e0:	440b      	add	r3, r1
 800e6e2:	3317      	adds	r3, #23
 800e6e4:	2201      	movs	r2, #1
 800e6e6:	701a      	strb	r2, [r3, #0]

          /* Abort current transaction and disable the EP */
          (void)HAL_PCD_EP_Abort(hpcd, (uint8_t)(epnum | 0x80U));
 800e6e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e6ea:	b2db      	uxtb	r3, r3
 800e6ec:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 800e6f0:	b2db      	uxtb	r3, r3
 800e6f2:	4619      	mov	r1, r3
 800e6f4:	6878      	ldr	r0, [r7, #4]
 800e6f6:	f000 fac8 	bl	800ec8a <HAL_PCD_EP_Abort>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800e6fa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e6fc:	3301      	adds	r3, #1
 800e6fe:	627b      	str	r3, [r7, #36]	@ 0x24
 800e700:	687b      	ldr	r3, [r7, #4]
 800e702:	791b      	ldrb	r3, [r3, #4]
 800e704:	461a      	mov	r2, r3
 800e706:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e708:	4293      	cmp	r3, r2
 800e70a:	d3cd      	bcc.n	800e6a8 <HAL_PCD_IRQHandler+0x798>
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_IISOIXFR);
 800e70c:	687b      	ldr	r3, [r7, #4]
 800e70e:	681b      	ldr	r3, [r3, #0]
 800e710:	695a      	ldr	r2, [r3, #20]
 800e712:	687b      	ldr	r3, [r7, #4]
 800e714:	681b      	ldr	r3, [r3, #0]
 800e716:	f402 1280 	and.w	r2, r2, #1048576	@ 0x100000
 800e71a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Incomplete ISO OUT Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 800e71c:	687b      	ldr	r3, [r7, #4]
 800e71e:	681b      	ldr	r3, [r3, #0]
 800e720:	4618      	mov	r0, r3
 800e722:	f006 fb6f 	bl	8014e04 <USB_ReadInterrupts>
 800e726:	4603      	mov	r3, r0
 800e728:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800e72c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800e730:	d156      	bne.n	800e7e0 <HAL_PCD_IRQHandler+0x8d0>
    {
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800e732:	2301      	movs	r3, #1
 800e734:	627b      	str	r3, [r7, #36]	@ 0x24
 800e736:	e045      	b.n	800e7c4 <HAL_PCD_IRQHandler+0x8b4>
      {
        RegVal = USBx_OUTEP(epnum)->DOEPCTL;
 800e738:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e73a:	015a      	lsls	r2, r3, #5
 800e73c:	69fb      	ldr	r3, [r7, #28]
 800e73e:	4413      	add	r3, r2
 800e740:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800e744:	681b      	ldr	r3, [r3, #0]
 800e746:	61bb      	str	r3, [r7, #24]

        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 800e748:	6879      	ldr	r1, [r7, #4]
 800e74a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e74c:	4613      	mov	r3, r2
 800e74e:	00db      	lsls	r3, r3, #3
 800e750:	4413      	add	r3, r2
 800e752:	009b      	lsls	r3, r3, #2
 800e754:	440b      	add	r3, r1
 800e756:	f503 7316 	add.w	r3, r3, #600	@ 0x258
 800e75a:	781b      	ldrb	r3, [r3, #0]
 800e75c:	2b01      	cmp	r3, #1
 800e75e:	d12e      	bne.n	800e7be <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 800e760:	69bb      	ldr	r3, [r7, #24]
        if ((hpcd->OUT_ep[epnum].type == EP_TYPE_ISOC) &&
 800e762:	2b00      	cmp	r3, #0
 800e764:	da2b      	bge.n	800e7be <HAL_PCD_IRQHandler+0x8ae>
            ((RegVal & (0x1U << 16)) == (hpcd->FrameNumber & 0x1U)))
 800e766:	69bb      	ldr	r3, [r7, #24]
 800e768:	f403 3280 	and.w	r2, r3, #65536	@ 0x10000
 800e76c:	687b      	ldr	r3, [r7, #4]
 800e76e:	f8d3 34d4 	ldr.w	r3, [r3, #1236]	@ 0x4d4
 800e772:	f003 0301 	and.w	r3, r3, #1
            ((RegVal & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA) &&
 800e776:	429a      	cmp	r2, r3
 800e778:	d121      	bne.n	800e7be <HAL_PCD_IRQHandler+0x8ae>
        {
          hpcd->OUT_ep[epnum].is_iso_incomplete = 1U;
 800e77a:	6879      	ldr	r1, [r7, #4]
 800e77c:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800e77e:	4613      	mov	r3, r2
 800e780:	00db      	lsls	r3, r3, #3
 800e782:	4413      	add	r3, r2
 800e784:	009b      	lsls	r3, r3, #2
 800e786:	440b      	add	r3, r1
 800e788:	f203 2357 	addw	r3, r3, #599	@ 0x257
 800e78c:	2201      	movs	r2, #1
 800e78e:	701a      	strb	r2, [r3, #0]

          USBx->GINTMSK |= USB_OTG_GINTMSK_GONAKEFFM;
 800e790:	6a3b      	ldr	r3, [r7, #32]
 800e792:	699b      	ldr	r3, [r3, #24]
 800e794:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 800e798:	6a3b      	ldr	r3, [r7, #32]
 800e79a:	619a      	str	r2, [r3, #24]

          if ((USBx->GINTSTS & USB_OTG_GINTSTS_BOUTNAKEFF) == 0U)
 800e79c:	6a3b      	ldr	r3, [r7, #32]
 800e79e:	695b      	ldr	r3, [r3, #20]
 800e7a0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800e7a4:	2b00      	cmp	r3, #0
 800e7a6:	d10a      	bne.n	800e7be <HAL_PCD_IRQHandler+0x8ae>
          {
            USBx_DEVICE->DCTL |= USB_OTG_DCTL_SGONAK;
 800e7a8:	69fb      	ldr	r3, [r7, #28]
 800e7aa:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800e7ae:	685b      	ldr	r3, [r3, #4]
 800e7b0:	69fa      	ldr	r2, [r7, #28]
 800e7b2:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 800e7b6:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 800e7ba:	6053      	str	r3, [r2, #4]
            break;
 800e7bc:	e008      	b.n	800e7d0 <HAL_PCD_IRQHandler+0x8c0>
      for (epnum = 1U; epnum < hpcd->Init.dev_endpoints; epnum++)
 800e7be:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e7c0:	3301      	adds	r3, #1
 800e7c2:	627b      	str	r3, [r7, #36]	@ 0x24
 800e7c4:	687b      	ldr	r3, [r7, #4]
 800e7c6:	791b      	ldrb	r3, [r3, #4]
 800e7c8:	461a      	mov	r2, r3
 800e7ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e7cc:	4293      	cmp	r3, r2
 800e7ce:	d3b3      	bcc.n	800e738 <HAL_PCD_IRQHandler+0x828>
          }
        }
      }

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 800e7d0:	687b      	ldr	r3, [r7, #4]
 800e7d2:	681b      	ldr	r3, [r3, #0]
 800e7d4:	695a      	ldr	r2, [r3, #20]
 800e7d6:	687b      	ldr	r3, [r7, #4]
 800e7d8:	681b      	ldr	r3, [r3, #0]
 800e7da:	f402 1200 	and.w	r2, r2, #2097152	@ 0x200000
 800e7de:	615a      	str	r2, [r3, #20]
    }

    /* Handle Connection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT))
 800e7e0:	687b      	ldr	r3, [r7, #4]
 800e7e2:	681b      	ldr	r3, [r3, #0]
 800e7e4:	4618      	mov	r0, r3
 800e7e6:	f006 fb0d 	bl	8014e04 <USB_ReadInterrupts>
 800e7ea:	4603      	mov	r3, r0
 800e7ec:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 800e7f0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800e7f4:	d10a      	bne.n	800e80c <HAL_PCD_IRQHandler+0x8fc>
    {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->ConnectCallback(hpcd);
#else
      HAL_PCD_ConnectCallback(hpcd);
 800e7f6:	6878      	ldr	r0, [r7, #4]
 800e7f8:	f00d f9d2 	bl	801bba0 <HAL_PCD_ConnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

      __HAL_PCD_CLEAR_FLAG(hpcd, USB_OTG_GINTSTS_SRQINT);
 800e7fc:	687b      	ldr	r3, [r7, #4]
 800e7fe:	681b      	ldr	r3, [r3, #0]
 800e800:	695a      	ldr	r2, [r3, #20]
 800e802:	687b      	ldr	r3, [r7, #4]
 800e804:	681b      	ldr	r3, [r3, #0]
 800e806:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 800e80a:	615a      	str	r2, [r3, #20]
    }

    /* Handle Disconnection event Interrupt */
    if (__HAL_PCD_GET_FLAG(hpcd, USB_OTG_GINTSTS_OTGINT))
 800e80c:	687b      	ldr	r3, [r7, #4]
 800e80e:	681b      	ldr	r3, [r3, #0]
 800e810:	4618      	mov	r0, r3
 800e812:	f006 faf7 	bl	8014e04 <USB_ReadInterrupts>
 800e816:	4603      	mov	r3, r0
 800e818:	f003 0304 	and.w	r3, r3, #4
 800e81c:	2b04      	cmp	r3, #4
 800e81e:	d115      	bne.n	800e84c <HAL_PCD_IRQHandler+0x93c>
    {
      RegVal = hpcd->Instance->GOTGINT;
 800e820:	687b      	ldr	r3, [r7, #4]
 800e822:	681b      	ldr	r3, [r3, #0]
 800e824:	685b      	ldr	r3, [r3, #4]
 800e826:	61bb      	str	r3, [r7, #24]

      if ((RegVal & USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
 800e828:	69bb      	ldr	r3, [r7, #24]
 800e82a:	f003 0304 	and.w	r3, r3, #4
 800e82e:	2b00      	cmp	r3, #0
 800e830:	d002      	beq.n	800e838 <HAL_PCD_IRQHandler+0x928>
      {
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DisconnectCallback(hpcd);
#else
        HAL_PCD_DisconnectCallback(hpcd);
 800e832:	6878      	ldr	r0, [r7, #4]
 800e834:	f00d f9c2 	bl	801bbbc <HAL_PCD_DisconnectCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
      hpcd->Instance->GOTGINT |= RegVal;
 800e838:	687b      	ldr	r3, [r7, #4]
 800e83a:	681b      	ldr	r3, [r3, #0]
 800e83c:	6859      	ldr	r1, [r3, #4]
 800e83e:	687b      	ldr	r3, [r7, #4]
 800e840:	681b      	ldr	r3, [r3, #0]
 800e842:	69ba      	ldr	r2, [r7, #24]
 800e844:	430a      	orrs	r2, r1
 800e846:	605a      	str	r2, [r3, #4]
 800e848:	e000      	b.n	800e84c <HAL_PCD_IRQHandler+0x93c>
      return;
 800e84a:	bf00      	nop
    }
  }
}
 800e84c:	3734      	adds	r7, #52	@ 0x34
 800e84e:	46bd      	mov	sp, r7
 800e850:	bd90      	pop	{r4, r7, pc}

0800e852 <HAL_PCD_SetAddress>:
  * @param  hpcd PCD handle
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
 800e852:	b580      	push	{r7, lr}
 800e854:	b082      	sub	sp, #8
 800e856:	af00      	add	r7, sp, #0
 800e858:	6078      	str	r0, [r7, #4]
 800e85a:	460b      	mov	r3, r1
 800e85c:	70fb      	strb	r3, [r7, #3]
  __HAL_LOCK(hpcd);
 800e85e:	687b      	ldr	r3, [r7, #4]
 800e860:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800e864:	2b01      	cmp	r3, #1
 800e866:	d101      	bne.n	800e86c <HAL_PCD_SetAddress+0x1a>
 800e868:	2302      	movs	r3, #2
 800e86a:	e012      	b.n	800e892 <HAL_PCD_SetAddress+0x40>
 800e86c:	687b      	ldr	r3, [r7, #4]
 800e86e:	2201      	movs	r2, #1
 800e870:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  hpcd->USB_Address = address;
 800e874:	687b      	ldr	r3, [r7, #4]
 800e876:	78fa      	ldrb	r2, [r7, #3]
 800e878:	745a      	strb	r2, [r3, #17]
  (void)USB_SetDevAddress(hpcd->Instance, address);
 800e87a:	687b      	ldr	r3, [r7, #4]
 800e87c:	681b      	ldr	r3, [r3, #0]
 800e87e:	78fa      	ldrb	r2, [r7, #3]
 800e880:	4611      	mov	r1, r2
 800e882:	4618      	mov	r0, r3
 800e884:	f006 fa56 	bl	8014d34 <USB_SetDevAddress>
  __HAL_UNLOCK(hpcd);
 800e888:	687b      	ldr	r3, [r7, #4]
 800e88a:	2200      	movs	r2, #0
 800e88c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 800e890:	2300      	movs	r3, #0
}
 800e892:	4618      	mov	r0, r3
 800e894:	3708      	adds	r7, #8
 800e896:	46bd      	mov	sp, r7
 800e898:	bd80      	pop	{r7, pc}

0800e89a <HAL_PCD_EP_Open>:
  * @param  ep_type endpoint type
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr,
                                  uint16_t ep_mps, uint8_t ep_type)
{
 800e89a:	b580      	push	{r7, lr}
 800e89c:	b084      	sub	sp, #16
 800e89e:	af00      	add	r7, sp, #0
 800e8a0:	6078      	str	r0, [r7, #4]
 800e8a2:	4608      	mov	r0, r1
 800e8a4:	4611      	mov	r1, r2
 800e8a6:	461a      	mov	r2, r3
 800e8a8:	4603      	mov	r3, r0
 800e8aa:	70fb      	strb	r3, [r7, #3]
 800e8ac:	460b      	mov	r3, r1
 800e8ae:	803b      	strh	r3, [r7, #0]
 800e8b0:	4613      	mov	r3, r2
 800e8b2:	70bb      	strb	r3, [r7, #2]
  HAL_StatusTypeDef  ret = HAL_OK;
 800e8b4:	2300      	movs	r3, #0
 800e8b6:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800e8b8:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e8bc:	2b00      	cmp	r3, #0
 800e8be:	da0f      	bge.n	800e8e0 <HAL_PCD_EP_Open+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800e8c0:	78fb      	ldrb	r3, [r7, #3]
 800e8c2:	f003 020f 	and.w	r2, r3, #15
 800e8c6:	4613      	mov	r3, r2
 800e8c8:	00db      	lsls	r3, r3, #3
 800e8ca:	4413      	add	r3, r2
 800e8cc:	009b      	lsls	r3, r3, #2
 800e8ce:	3310      	adds	r3, #16
 800e8d0:	687a      	ldr	r2, [r7, #4]
 800e8d2:	4413      	add	r3, r2
 800e8d4:	3304      	adds	r3, #4
 800e8d6:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800e8d8:	68fb      	ldr	r3, [r7, #12]
 800e8da:	2201      	movs	r2, #1
 800e8dc:	705a      	strb	r2, [r3, #1]
 800e8de:	e00f      	b.n	800e900 <HAL_PCD_EP_Open+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800e8e0:	78fb      	ldrb	r3, [r7, #3]
 800e8e2:	f003 020f 	and.w	r2, r3, #15
 800e8e6:	4613      	mov	r3, r2
 800e8e8:	00db      	lsls	r3, r3, #3
 800e8ea:	4413      	add	r3, r2
 800e8ec:	009b      	lsls	r3, r3, #2
 800e8ee:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e8f2:	687a      	ldr	r2, [r7, #4]
 800e8f4:	4413      	add	r3, r2
 800e8f6:	3304      	adds	r3, #4
 800e8f8:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800e8fa:	68fb      	ldr	r3, [r7, #12]
 800e8fc:	2200      	movs	r2, #0
 800e8fe:	705a      	strb	r2, [r3, #1]
  }

  ep->num = ep_addr & EP_ADDR_MSK;
 800e900:	78fb      	ldrb	r3, [r7, #3]
 800e902:	f003 030f 	and.w	r3, r3, #15
 800e906:	b2da      	uxtb	r2, r3
 800e908:	68fb      	ldr	r3, [r7, #12]
 800e90a:	701a      	strb	r2, [r3, #0]
  ep->maxpacket = ep_mps;
 800e90c:	883a      	ldrh	r2, [r7, #0]
 800e90e:	68fb      	ldr	r3, [r7, #12]
 800e910:	609a      	str	r2, [r3, #8]
  ep->type = ep_type;
 800e912:	68fb      	ldr	r3, [r7, #12]
 800e914:	78ba      	ldrb	r2, [r7, #2]
 800e916:	711a      	strb	r2, [r3, #4]

  if (ep->is_in != 0U)
 800e918:	68fb      	ldr	r3, [r7, #12]
 800e91a:	785b      	ldrb	r3, [r3, #1]
 800e91c:	2b00      	cmp	r3, #0
 800e91e:	d004      	beq.n	800e92a <HAL_PCD_EP_Open+0x90>
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 800e920:	68fb      	ldr	r3, [r7, #12]
 800e922:	781b      	ldrb	r3, [r3, #0]
 800e924:	461a      	mov	r2, r3
 800e926:	68fb      	ldr	r3, [r7, #12]
 800e928:	835a      	strh	r2, [r3, #26]
  }

  /* Set initial data PID. */
  if (ep_type == EP_TYPE_BULK)
 800e92a:	78bb      	ldrb	r3, [r7, #2]
 800e92c:	2b02      	cmp	r3, #2
 800e92e:	d102      	bne.n	800e936 <HAL_PCD_EP_Open+0x9c>
  {
    ep->data_pid_start = 0U;
 800e930:	68fb      	ldr	r3, [r7, #12]
 800e932:	2200      	movs	r2, #0
 800e934:	715a      	strb	r2, [r3, #5]
  }

  __HAL_LOCK(hpcd);
 800e936:	687b      	ldr	r3, [r7, #4]
 800e938:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800e93c:	2b01      	cmp	r3, #1
 800e93e:	d101      	bne.n	800e944 <HAL_PCD_EP_Open+0xaa>
 800e940:	2302      	movs	r3, #2
 800e942:	e00e      	b.n	800e962 <HAL_PCD_EP_Open+0xc8>
 800e944:	687b      	ldr	r3, [r7, #4]
 800e946:	2201      	movs	r2, #1
 800e948:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_ActivateEndpoint(hpcd->Instance, ep);
 800e94c:	687b      	ldr	r3, [r7, #4]
 800e94e:	681b      	ldr	r3, [r3, #0]
 800e950:	68f9      	ldr	r1, [r7, #12]
 800e952:	4618      	mov	r0, r3
 800e954:	f005 fbde 	bl	8014114 <USB_ActivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800e958:	687b      	ldr	r3, [r7, #4]
 800e95a:	2200      	movs	r2, #0
 800e95c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return ret;
 800e960:	7afb      	ldrb	r3, [r7, #11]
}
 800e962:	4618      	mov	r0, r3
 800e964:	3710      	adds	r7, #16
 800e966:	46bd      	mov	sp, r7
 800e968:	bd80      	pop	{r7, pc}

0800e96a <HAL_PCD_EP_Close>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800e96a:	b580      	push	{r7, lr}
 800e96c:	b084      	sub	sp, #16
 800e96e:	af00      	add	r7, sp, #0
 800e970:	6078      	str	r0, [r7, #4]
 800e972:	460b      	mov	r3, r1
 800e974:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if ((ep_addr & 0x80U) == 0x80U)
 800e976:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800e97a:	2b00      	cmp	r3, #0
 800e97c:	da0f      	bge.n	800e99e <HAL_PCD_EP_Close+0x34>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800e97e:	78fb      	ldrb	r3, [r7, #3]
 800e980:	f003 020f 	and.w	r2, r3, #15
 800e984:	4613      	mov	r3, r2
 800e986:	00db      	lsls	r3, r3, #3
 800e988:	4413      	add	r3, r2
 800e98a:	009b      	lsls	r3, r3, #2
 800e98c:	3310      	adds	r3, #16
 800e98e:	687a      	ldr	r2, [r7, #4]
 800e990:	4413      	add	r3, r2
 800e992:	3304      	adds	r3, #4
 800e994:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800e996:	68fb      	ldr	r3, [r7, #12]
 800e998:	2201      	movs	r2, #1
 800e99a:	705a      	strb	r2, [r3, #1]
 800e99c:	e00f      	b.n	800e9be <HAL_PCD_EP_Close+0x54>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800e99e:	78fb      	ldrb	r3, [r7, #3]
 800e9a0:	f003 020f 	and.w	r2, r3, #15
 800e9a4:	4613      	mov	r3, r2
 800e9a6:	00db      	lsls	r3, r3, #3
 800e9a8:	4413      	add	r3, r2
 800e9aa:	009b      	lsls	r3, r3, #2
 800e9ac:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800e9b0:	687a      	ldr	r2, [r7, #4]
 800e9b2:	4413      	add	r3, r2
 800e9b4:	3304      	adds	r3, #4
 800e9b6:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800e9b8:	68fb      	ldr	r3, [r7, #12]
 800e9ba:	2200      	movs	r2, #0
 800e9bc:	705a      	strb	r2, [r3, #1]
  }
  ep->num = ep_addr & EP_ADDR_MSK;
 800e9be:	78fb      	ldrb	r3, [r7, #3]
 800e9c0:	f003 030f 	and.w	r3, r3, #15
 800e9c4:	b2da      	uxtb	r2, r3
 800e9c6:	68fb      	ldr	r3, [r7, #12]
 800e9c8:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800e9ca:	687b      	ldr	r3, [r7, #4]
 800e9cc:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800e9d0:	2b01      	cmp	r3, #1
 800e9d2:	d101      	bne.n	800e9d8 <HAL_PCD_EP_Close+0x6e>
 800e9d4:	2302      	movs	r3, #2
 800e9d6:	e00e      	b.n	800e9f6 <HAL_PCD_EP_Close+0x8c>
 800e9d8:	687b      	ldr	r3, [r7, #4]
 800e9da:	2201      	movs	r2, #1
 800e9dc:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_DeactivateEndpoint(hpcd->Instance, ep);
 800e9e0:	687b      	ldr	r3, [r7, #4]
 800e9e2:	681b      	ldr	r3, [r3, #0]
 800e9e4:	68f9      	ldr	r1, [r7, #12]
 800e9e6:	4618      	mov	r0, r3
 800e9e8:	f005 fc1c 	bl	8014224 <USB_DeactivateEndpoint>
  __HAL_UNLOCK(hpcd);
 800e9ec:	687b      	ldr	r3, [r7, #4]
 800e9ee:	2200      	movs	r2, #0
 800e9f0:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  return HAL_OK;
 800e9f4:	2300      	movs	r3, #0
}
 800e9f6:	4618      	mov	r0, r3
 800e9f8:	3710      	adds	r7, #16
 800e9fa:	46bd      	mov	sp, r7
 800e9fc:	bd80      	pop	{r7, pc}

0800e9fe <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800e9fe:	b580      	push	{r7, lr}
 800ea00:	b086      	sub	sp, #24
 800ea02:	af00      	add	r7, sp, #0
 800ea04:	60f8      	str	r0, [r7, #12]
 800ea06:	607a      	str	r2, [r7, #4]
 800ea08:	603b      	str	r3, [r7, #0]
 800ea0a:	460b      	mov	r3, r1
 800ea0c:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800ea0e:	7afb      	ldrb	r3, [r7, #11]
 800ea10:	f003 020f 	and.w	r2, r3, #15
 800ea14:	4613      	mov	r3, r2
 800ea16:	00db      	lsls	r3, r3, #3
 800ea18:	4413      	add	r3, r2
 800ea1a:	009b      	lsls	r3, r3, #2
 800ea1c:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800ea20:	68fa      	ldr	r2, [r7, #12]
 800ea22:	4413      	add	r3, r2
 800ea24:	3304      	adds	r3, #4
 800ea26:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800ea28:	697b      	ldr	r3, [r7, #20]
 800ea2a:	687a      	ldr	r2, [r7, #4]
 800ea2c:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 800ea2e:	697b      	ldr	r3, [r7, #20]
 800ea30:	683a      	ldr	r2, [r7, #0]
 800ea32:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 800ea34:	697b      	ldr	r3, [r7, #20]
 800ea36:	2200      	movs	r2, #0
 800ea38:	615a      	str	r2, [r3, #20]
  ep->is_in = 0U;
 800ea3a:	697b      	ldr	r3, [r7, #20]
 800ea3c:	2200      	movs	r2, #0
 800ea3e:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800ea40:	7afb      	ldrb	r3, [r7, #11]
 800ea42:	f003 030f 	and.w	r3, r3, #15
 800ea46:	b2da      	uxtb	r2, r3
 800ea48:	697b      	ldr	r3, [r7, #20]
 800ea4a:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 800ea4c:	68fb      	ldr	r3, [r7, #12]
 800ea4e:	799b      	ldrb	r3, [r3, #6]
 800ea50:	2b01      	cmp	r3, #1
 800ea52:	d102      	bne.n	800ea5a <HAL_PCD_EP_Receive+0x5c>
  {
    ep->dma_addr = (uint32_t)pBuf;
 800ea54:	687a      	ldr	r2, [r7, #4]
 800ea56:	697b      	ldr	r3, [r7, #20]
 800ea58:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800ea5a:	68fb      	ldr	r3, [r7, #12]
 800ea5c:	6818      	ldr	r0, [r3, #0]
 800ea5e:	68fb      	ldr	r3, [r7, #12]
 800ea60:	799b      	ldrb	r3, [r3, #6]
 800ea62:	461a      	mov	r2, r3
 800ea64:	6979      	ldr	r1, [r7, #20]
 800ea66:	f005 fcb9 	bl	80143dc <USB_EPStartXfer>

  return HAL_OK;
 800ea6a:	2300      	movs	r3, #0
}
 800ea6c:	4618      	mov	r0, r3
 800ea6e:	3718      	adds	r7, #24
 800ea70:	46bd      	mov	sp, r7
 800ea72:	bd80      	pop	{r7, pc}

0800ea74 <HAL_PCD_EP_GetRxCount>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval Data Size
  */
uint32_t HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef const *hpcd, uint8_t ep_addr)
{
 800ea74:	b480      	push	{r7}
 800ea76:	b083      	sub	sp, #12
 800ea78:	af00      	add	r7, sp, #0
 800ea7a:	6078      	str	r0, [r7, #4]
 800ea7c:	460b      	mov	r3, r1
 800ea7e:	70fb      	strb	r3, [r7, #3]
  return hpcd->OUT_ep[ep_addr & EP_ADDR_MSK].xfer_count;
 800ea80:	78fb      	ldrb	r3, [r7, #3]
 800ea82:	f003 020f 	and.w	r2, r3, #15
 800ea86:	6879      	ldr	r1, [r7, #4]
 800ea88:	4613      	mov	r3, r2
 800ea8a:	00db      	lsls	r3, r3, #3
 800ea8c:	4413      	add	r3, r2
 800ea8e:	009b      	lsls	r3, r3, #2
 800ea90:	440b      	add	r3, r1
 800ea92:	f503 731a 	add.w	r3, r3, #616	@ 0x268
 800ea96:	681b      	ldr	r3, [r3, #0]
}
 800ea98:	4618      	mov	r0, r3
 800ea9a:	370c      	adds	r7, #12
 800ea9c:	46bd      	mov	sp, r7
 800ea9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eaa2:	4770      	bx	lr

0800eaa4 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 800eaa4:	b580      	push	{r7, lr}
 800eaa6:	b086      	sub	sp, #24
 800eaa8:	af00      	add	r7, sp, #0
 800eaaa:	60f8      	str	r0, [r7, #12]
 800eaac:	607a      	str	r2, [r7, #4]
 800eaae:	603b      	str	r3, [r7, #0]
 800eab0:	460b      	mov	r3, r1
 800eab2:	72fb      	strb	r3, [r7, #11]
  PCD_EPTypeDef *ep;

  ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800eab4:	7afb      	ldrb	r3, [r7, #11]
 800eab6:	f003 020f 	and.w	r2, r3, #15
 800eaba:	4613      	mov	r3, r2
 800eabc:	00db      	lsls	r3, r3, #3
 800eabe:	4413      	add	r3, r2
 800eac0:	009b      	lsls	r3, r3, #2
 800eac2:	3310      	adds	r3, #16
 800eac4:	68fa      	ldr	r2, [r7, #12]
 800eac6:	4413      	add	r3, r2
 800eac8:	3304      	adds	r3, #4
 800eaca:	617b      	str	r3, [r7, #20]

  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;
 800eacc:	697b      	ldr	r3, [r7, #20]
 800eace:	687a      	ldr	r2, [r7, #4]
 800ead0:	60da      	str	r2, [r3, #12]
  ep->xfer_len = len;
 800ead2:	697b      	ldr	r3, [r7, #20]
 800ead4:	683a      	ldr	r2, [r7, #0]
 800ead6:	611a      	str	r2, [r3, #16]
  ep->xfer_count = 0U;
 800ead8:	697b      	ldr	r3, [r7, #20]
 800eada:	2200      	movs	r2, #0
 800eadc:	615a      	str	r2, [r3, #20]
  ep->is_in = 1U;
 800eade:	697b      	ldr	r3, [r7, #20]
 800eae0:	2201      	movs	r2, #1
 800eae2:	705a      	strb	r2, [r3, #1]
  ep->num = ep_addr & EP_ADDR_MSK;
 800eae4:	7afb      	ldrb	r3, [r7, #11]
 800eae6:	f003 030f 	and.w	r3, r3, #15
 800eaea:	b2da      	uxtb	r2, r3
 800eaec:	697b      	ldr	r3, [r7, #20]
 800eaee:	701a      	strb	r2, [r3, #0]

  if (hpcd->Init.dma_enable == 1U)
 800eaf0:	68fb      	ldr	r3, [r7, #12]
 800eaf2:	799b      	ldrb	r3, [r3, #6]
 800eaf4:	2b01      	cmp	r3, #1
 800eaf6:	d102      	bne.n	800eafe <HAL_PCD_EP_Transmit+0x5a>
  {
    ep->dma_addr = (uint32_t)pBuf;
 800eaf8:	687a      	ldr	r2, [r7, #4]
 800eafa:	697b      	ldr	r3, [r7, #20]
 800eafc:	61da      	str	r2, [r3, #28]
  }

  (void)USB_EPStartXfer(hpcd->Instance, ep, (uint8_t)hpcd->Init.dma_enable);
 800eafe:	68fb      	ldr	r3, [r7, #12]
 800eb00:	6818      	ldr	r0, [r3, #0]
 800eb02:	68fb      	ldr	r3, [r7, #12]
 800eb04:	799b      	ldrb	r3, [r3, #6]
 800eb06:	461a      	mov	r2, r3
 800eb08:	6979      	ldr	r1, [r7, #20]
 800eb0a:	f005 fc67 	bl	80143dc <USB_EPStartXfer>

  return HAL_OK;
 800eb0e:	2300      	movs	r3, #0
}
 800eb10:	4618      	mov	r0, r3
 800eb12:	3718      	adds	r7, #24
 800eb14:	46bd      	mov	sp, r7
 800eb16:	bd80      	pop	{r7, pc}

0800eb18 <HAL_PCD_EP_SetStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800eb18:	b580      	push	{r7, lr}
 800eb1a:	b084      	sub	sp, #16
 800eb1c:	af00      	add	r7, sp, #0
 800eb1e:	6078      	str	r0, [r7, #4]
 800eb20:	460b      	mov	r3, r1
 800eb22:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & EP_ADDR_MSK) > hpcd->Init.dev_endpoints)
 800eb24:	78fb      	ldrb	r3, [r7, #3]
 800eb26:	f003 030f 	and.w	r3, r3, #15
 800eb2a:	687a      	ldr	r2, [r7, #4]
 800eb2c:	7912      	ldrb	r2, [r2, #4]
 800eb2e:	4293      	cmp	r3, r2
 800eb30:	d901      	bls.n	800eb36 <HAL_PCD_EP_SetStall+0x1e>
  {
    return HAL_ERROR;
 800eb32:	2301      	movs	r3, #1
 800eb34:	e04f      	b.n	800ebd6 <HAL_PCD_EP_SetStall+0xbe>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800eb36:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800eb3a:	2b00      	cmp	r3, #0
 800eb3c:	da0f      	bge.n	800eb5e <HAL_PCD_EP_SetStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800eb3e:	78fb      	ldrb	r3, [r7, #3]
 800eb40:	f003 020f 	and.w	r2, r3, #15
 800eb44:	4613      	mov	r3, r2
 800eb46:	00db      	lsls	r3, r3, #3
 800eb48:	4413      	add	r3, r2
 800eb4a:	009b      	lsls	r3, r3, #2
 800eb4c:	3310      	adds	r3, #16
 800eb4e:	687a      	ldr	r2, [r7, #4]
 800eb50:	4413      	add	r3, r2
 800eb52:	3304      	adds	r3, #4
 800eb54:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800eb56:	68fb      	ldr	r3, [r7, #12]
 800eb58:	2201      	movs	r2, #1
 800eb5a:	705a      	strb	r2, [r3, #1]
 800eb5c:	e00d      	b.n	800eb7a <HAL_PCD_EP_SetStall+0x62>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 800eb5e:	78fa      	ldrb	r2, [r7, #3]
 800eb60:	4613      	mov	r3, r2
 800eb62:	00db      	lsls	r3, r3, #3
 800eb64:	4413      	add	r3, r2
 800eb66:	009b      	lsls	r3, r3, #2
 800eb68:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800eb6c:	687a      	ldr	r2, [r7, #4]
 800eb6e:	4413      	add	r3, r2
 800eb70:	3304      	adds	r3, #4
 800eb72:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800eb74:	68fb      	ldr	r3, [r7, #12]
 800eb76:	2200      	movs	r2, #0
 800eb78:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 1U;
 800eb7a:	68fb      	ldr	r3, [r7, #12]
 800eb7c:	2201      	movs	r2, #1
 800eb7e:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800eb80:	78fb      	ldrb	r3, [r7, #3]
 800eb82:	f003 030f 	and.w	r3, r3, #15
 800eb86:	b2da      	uxtb	r2, r3
 800eb88:	68fb      	ldr	r3, [r7, #12]
 800eb8a:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800eb8c:	687b      	ldr	r3, [r7, #4]
 800eb8e:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800eb92:	2b01      	cmp	r3, #1
 800eb94:	d101      	bne.n	800eb9a <HAL_PCD_EP_SetStall+0x82>
 800eb96:	2302      	movs	r3, #2
 800eb98:	e01d      	b.n	800ebd6 <HAL_PCD_EP_SetStall+0xbe>
 800eb9a:	687b      	ldr	r3, [r7, #4]
 800eb9c:	2201      	movs	r2, #1
 800eb9e:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  (void)USB_EPSetStall(hpcd->Instance, ep);
 800eba2:	687b      	ldr	r3, [r7, #4]
 800eba4:	681b      	ldr	r3, [r3, #0]
 800eba6:	68f9      	ldr	r1, [r7, #12]
 800eba8:	4618      	mov	r0, r3
 800ebaa:	f005 ffef 	bl	8014b8c <USB_EPSetStall>

  if ((ep_addr & EP_ADDR_MSK) == 0U)
 800ebae:	78fb      	ldrb	r3, [r7, #3]
 800ebb0:	f003 030f 	and.w	r3, r3, #15
 800ebb4:	2b00      	cmp	r3, #0
 800ebb6:	d109      	bne.n	800ebcc <HAL_PCD_EP_SetStall+0xb4>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, (uint8_t)hpcd->Init.dma_enable, (uint8_t *)hpcd->Setup);
 800ebb8:	687b      	ldr	r3, [r7, #4]
 800ebba:	6818      	ldr	r0, [r3, #0]
 800ebbc:	687b      	ldr	r3, [r7, #4]
 800ebbe:	7999      	ldrb	r1, [r3, #6]
 800ebc0:	687b      	ldr	r3, [r7, #4]
 800ebc2:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800ebc6:	461a      	mov	r2, r3
 800ebc8:	f006 f9e0 	bl	8014f8c <USB_EP0_OutStart>
  }

  __HAL_UNLOCK(hpcd);
 800ebcc:	687b      	ldr	r3, [r7, #4]
 800ebce:	2200      	movs	r2, #0
 800ebd0:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 800ebd4:	2300      	movs	r3, #0
}
 800ebd6:	4618      	mov	r0, r3
 800ebd8:	3710      	adds	r7, #16
 800ebda:	46bd      	mov	sp, r7
 800ebdc:	bd80      	pop	{r7, pc}

0800ebde <HAL_PCD_EP_ClrStall>:
  * @param  hpcd PCD handle
  * @param  ep_addr endpoint address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800ebde:	b580      	push	{r7, lr}
 800ebe0:	b084      	sub	sp, #16
 800ebe2:	af00      	add	r7, sp, #0
 800ebe4:	6078      	str	r0, [r7, #4]
 800ebe6:	460b      	mov	r3, r1
 800ebe8:	70fb      	strb	r3, [r7, #3]
  PCD_EPTypeDef *ep;

  if (((uint32_t)ep_addr & 0x0FU) > hpcd->Init.dev_endpoints)
 800ebea:	78fb      	ldrb	r3, [r7, #3]
 800ebec:	f003 030f 	and.w	r3, r3, #15
 800ebf0:	687a      	ldr	r2, [r7, #4]
 800ebf2:	7912      	ldrb	r2, [r2, #4]
 800ebf4:	4293      	cmp	r3, r2
 800ebf6:	d901      	bls.n	800ebfc <HAL_PCD_EP_ClrStall+0x1e>
  {
    return HAL_ERROR;
 800ebf8:	2301      	movs	r3, #1
 800ebfa:	e042      	b.n	800ec82 <HAL_PCD_EP_ClrStall+0xa4>
  }

  if ((0x80U & ep_addr) == 0x80U)
 800ebfc:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800ec00:	2b00      	cmp	r3, #0
 800ec02:	da0f      	bge.n	800ec24 <HAL_PCD_EP_ClrStall+0x46>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800ec04:	78fb      	ldrb	r3, [r7, #3]
 800ec06:	f003 020f 	and.w	r2, r3, #15
 800ec0a:	4613      	mov	r3, r2
 800ec0c:	00db      	lsls	r3, r3, #3
 800ec0e:	4413      	add	r3, r2
 800ec10:	009b      	lsls	r3, r3, #2
 800ec12:	3310      	adds	r3, #16
 800ec14:	687a      	ldr	r2, [r7, #4]
 800ec16:	4413      	add	r3, r2
 800ec18:	3304      	adds	r3, #4
 800ec1a:	60fb      	str	r3, [r7, #12]
    ep->is_in = 1U;
 800ec1c:	68fb      	ldr	r3, [r7, #12]
 800ec1e:	2201      	movs	r2, #1
 800ec20:	705a      	strb	r2, [r3, #1]
 800ec22:	e00f      	b.n	800ec44 <HAL_PCD_EP_ClrStall+0x66>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800ec24:	78fb      	ldrb	r3, [r7, #3]
 800ec26:	f003 020f 	and.w	r2, r3, #15
 800ec2a:	4613      	mov	r3, r2
 800ec2c:	00db      	lsls	r3, r3, #3
 800ec2e:	4413      	add	r3, r2
 800ec30:	009b      	lsls	r3, r3, #2
 800ec32:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800ec36:	687a      	ldr	r2, [r7, #4]
 800ec38:	4413      	add	r3, r2
 800ec3a:	3304      	adds	r3, #4
 800ec3c:	60fb      	str	r3, [r7, #12]
    ep->is_in = 0U;
 800ec3e:	68fb      	ldr	r3, [r7, #12]
 800ec40:	2200      	movs	r2, #0
 800ec42:	705a      	strb	r2, [r3, #1]
  }

  ep->is_stall = 0U;
 800ec44:	68fb      	ldr	r3, [r7, #12]
 800ec46:	2200      	movs	r2, #0
 800ec48:	709a      	strb	r2, [r3, #2]
  ep->num = ep_addr & EP_ADDR_MSK;
 800ec4a:	78fb      	ldrb	r3, [r7, #3]
 800ec4c:	f003 030f 	and.w	r3, r3, #15
 800ec50:	b2da      	uxtb	r2, r3
 800ec52:	68fb      	ldr	r3, [r7, #12]
 800ec54:	701a      	strb	r2, [r3, #0]

  __HAL_LOCK(hpcd);
 800ec56:	687b      	ldr	r3, [r7, #4]
 800ec58:	f893 3494 	ldrb.w	r3, [r3, #1172]	@ 0x494
 800ec5c:	2b01      	cmp	r3, #1
 800ec5e:	d101      	bne.n	800ec64 <HAL_PCD_EP_ClrStall+0x86>
 800ec60:	2302      	movs	r3, #2
 800ec62:	e00e      	b.n	800ec82 <HAL_PCD_EP_ClrStall+0xa4>
 800ec64:	687b      	ldr	r3, [r7, #4]
 800ec66:	2201      	movs	r2, #1
 800ec68:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494
  (void)USB_EPClearStall(hpcd->Instance, ep);
 800ec6c:	687b      	ldr	r3, [r7, #4]
 800ec6e:	681b      	ldr	r3, [r3, #0]
 800ec70:	68f9      	ldr	r1, [r7, #12]
 800ec72:	4618      	mov	r0, r3
 800ec74:	f005 fff8 	bl	8014c68 <USB_EPClearStall>
  __HAL_UNLOCK(hpcd);
 800ec78:	687b      	ldr	r3, [r7, #4]
 800ec7a:	2200      	movs	r2, #0
 800ec7c:	f883 2494 	strb.w	r2, [r3, #1172]	@ 0x494

  return HAL_OK;
 800ec80:	2300      	movs	r3, #0
}
 800ec82:	4618      	mov	r0, r3
 800ec84:	3710      	adds	r7, #16
 800ec86:	46bd      	mov	sp, r7
 800ec88:	bd80      	pop	{r7, pc}

0800ec8a <HAL_PCD_EP_Abort>:
   * @param  hpcd PCD handle
   * @param  ep_addr endpoint address
   * @retval HAL status
   */
HAL_StatusTypeDef HAL_PCD_EP_Abort(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
 800ec8a:	b580      	push	{r7, lr}
 800ec8c:	b084      	sub	sp, #16
 800ec8e:	af00      	add	r7, sp, #0
 800ec90:	6078      	str	r0, [r7, #4]
 800ec92:	460b      	mov	r3, r1
 800ec94:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef ret;
  PCD_EPTypeDef *ep;

  if ((0x80U & ep_addr) == 0x80U)
 800ec96:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800ec9a:	2b00      	cmp	r3, #0
 800ec9c:	da0c      	bge.n	800ecb8 <HAL_PCD_EP_Abort+0x2e>
  {
    ep = &hpcd->IN_ep[ep_addr & EP_ADDR_MSK];
 800ec9e:	78fb      	ldrb	r3, [r7, #3]
 800eca0:	f003 020f 	and.w	r2, r3, #15
 800eca4:	4613      	mov	r3, r2
 800eca6:	00db      	lsls	r3, r3, #3
 800eca8:	4413      	add	r3, r2
 800ecaa:	009b      	lsls	r3, r3, #2
 800ecac:	3310      	adds	r3, #16
 800ecae:	687a      	ldr	r2, [r7, #4]
 800ecb0:	4413      	add	r3, r2
 800ecb2:	3304      	adds	r3, #4
 800ecb4:	60fb      	str	r3, [r7, #12]
 800ecb6:	e00c      	b.n	800ecd2 <HAL_PCD_EP_Abort+0x48>
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & EP_ADDR_MSK];
 800ecb8:	78fb      	ldrb	r3, [r7, #3]
 800ecba:	f003 020f 	and.w	r2, r3, #15
 800ecbe:	4613      	mov	r3, r2
 800ecc0:	00db      	lsls	r3, r3, #3
 800ecc2:	4413      	add	r3, r2
 800ecc4:	009b      	lsls	r3, r3, #2
 800ecc6:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800ecca:	687a      	ldr	r2, [r7, #4]
 800eccc:	4413      	add	r3, r2
 800ecce:	3304      	adds	r3, #4
 800ecd0:	60fb      	str	r3, [r7, #12]
  }

  /* Stop Xfer */
  ret = USB_EPStopXfer(hpcd->Instance, ep);
 800ecd2:	687b      	ldr	r3, [r7, #4]
 800ecd4:	681b      	ldr	r3, [r3, #0]
 800ecd6:	68f9      	ldr	r1, [r7, #12]
 800ecd8:	4618      	mov	r0, r3
 800ecda:	f005 fe17 	bl	801490c <USB_EPStopXfer>
 800ecde:	4603      	mov	r3, r0
 800ece0:	72fb      	strb	r3, [r7, #11]

  return ret;
 800ece2:	7afb      	ldrb	r3, [r7, #11]
}
 800ece4:	4618      	mov	r0, r3
 800ece6:	3710      	adds	r7, #16
 800ece8:	46bd      	mov	sp, r7
 800ecea:	bd80      	pop	{r7, pc}

0800ecec <PCD_WriteEmptyTxFifo>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_WriteEmptyTxFifo(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 800ecec:	b580      	push	{r7, lr}
 800ecee:	b08a      	sub	sp, #40	@ 0x28
 800ecf0:	af02      	add	r7, sp, #8
 800ecf2:	6078      	str	r0, [r7, #4]
 800ecf4:	6039      	str	r1, [r7, #0]
  USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800ecf6:	687b      	ldr	r3, [r7, #4]
 800ecf8:	681b      	ldr	r3, [r3, #0]
 800ecfa:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800ecfc:	697b      	ldr	r3, [r7, #20]
 800ecfe:	613b      	str	r3, [r7, #16]
  USB_OTG_EPTypeDef *ep;
  uint32_t len;
  uint32_t len32b;
  uint32_t fifoemptymsk;

  ep = &hpcd->IN_ep[epnum];
 800ed00:	683a      	ldr	r2, [r7, #0]
 800ed02:	4613      	mov	r3, r2
 800ed04:	00db      	lsls	r3, r3, #3
 800ed06:	4413      	add	r3, r2
 800ed08:	009b      	lsls	r3, r3, #2
 800ed0a:	3310      	adds	r3, #16
 800ed0c:	687a      	ldr	r2, [r7, #4]
 800ed0e:	4413      	add	r3, r2
 800ed10:	3304      	adds	r3, #4
 800ed12:	60fb      	str	r3, [r7, #12]

  if (ep->xfer_count > ep->xfer_len)
 800ed14:	68fb      	ldr	r3, [r7, #12]
 800ed16:	695a      	ldr	r2, [r3, #20]
 800ed18:	68fb      	ldr	r3, [r7, #12]
 800ed1a:	691b      	ldr	r3, [r3, #16]
 800ed1c:	429a      	cmp	r2, r3
 800ed1e:	d901      	bls.n	800ed24 <PCD_WriteEmptyTxFifo+0x38>
  {
    return HAL_ERROR;
 800ed20:	2301      	movs	r3, #1
 800ed22:	e06b      	b.n	800edfc <PCD_WriteEmptyTxFifo+0x110>
  }

  len = ep->xfer_len - ep->xfer_count;
 800ed24:	68fb      	ldr	r3, [r7, #12]
 800ed26:	691a      	ldr	r2, [r3, #16]
 800ed28:	68fb      	ldr	r3, [r7, #12]
 800ed2a:	695b      	ldr	r3, [r3, #20]
 800ed2c:	1ad3      	subs	r3, r2, r3
 800ed2e:	61fb      	str	r3, [r7, #28]

  if (len > ep->maxpacket)
 800ed30:	68fb      	ldr	r3, [r7, #12]
 800ed32:	689b      	ldr	r3, [r3, #8]
 800ed34:	69fa      	ldr	r2, [r7, #28]
 800ed36:	429a      	cmp	r2, r3
 800ed38:	d902      	bls.n	800ed40 <PCD_WriteEmptyTxFifo+0x54>
  {
    len = ep->maxpacket;
 800ed3a:	68fb      	ldr	r3, [r7, #12]
 800ed3c:	689b      	ldr	r3, [r3, #8]
 800ed3e:	61fb      	str	r3, [r7, #28]
  }

  len32b = (len + 3U) / 4U;
 800ed40:	69fb      	ldr	r3, [r7, #28]
 800ed42:	3303      	adds	r3, #3
 800ed44:	089b      	lsrs	r3, r3, #2
 800ed46:	61bb      	str	r3, [r7, #24]

  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800ed48:	e02a      	b.n	800eda0 <PCD_WriteEmptyTxFifo+0xb4>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
  {
    /* Write the FIFO */
    len = ep->xfer_len - ep->xfer_count;
 800ed4a:	68fb      	ldr	r3, [r7, #12]
 800ed4c:	691a      	ldr	r2, [r3, #16]
 800ed4e:	68fb      	ldr	r3, [r7, #12]
 800ed50:	695b      	ldr	r3, [r3, #20]
 800ed52:	1ad3      	subs	r3, r2, r3
 800ed54:	61fb      	str	r3, [r7, #28]

    if (len > ep->maxpacket)
 800ed56:	68fb      	ldr	r3, [r7, #12]
 800ed58:	689b      	ldr	r3, [r3, #8]
 800ed5a:	69fa      	ldr	r2, [r7, #28]
 800ed5c:	429a      	cmp	r2, r3
 800ed5e:	d902      	bls.n	800ed66 <PCD_WriteEmptyTxFifo+0x7a>
    {
      len = ep->maxpacket;
 800ed60:	68fb      	ldr	r3, [r7, #12]
 800ed62:	689b      	ldr	r3, [r3, #8]
 800ed64:	61fb      	str	r3, [r7, #28]
    }
    len32b = (len + 3U) / 4U;
 800ed66:	69fb      	ldr	r3, [r7, #28]
 800ed68:	3303      	adds	r3, #3
 800ed6a:	089b      	lsrs	r3, r3, #2
 800ed6c:	61bb      	str	r3, [r7, #24]

    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 800ed6e:	68fb      	ldr	r3, [r7, #12]
 800ed70:	68d9      	ldr	r1, [r3, #12]
 800ed72:	683b      	ldr	r3, [r7, #0]
 800ed74:	b2da      	uxtb	r2, r3
 800ed76:	69fb      	ldr	r3, [r7, #28]
 800ed78:	b298      	uxth	r0, r3
                          (uint8_t)hpcd->Init.dma_enable);
 800ed7a:	687b      	ldr	r3, [r7, #4]
 800ed7c:	799b      	ldrb	r3, [r3, #6]
    (void)USB_WritePacket(USBx, ep->xfer_buff, (uint8_t)epnum, (uint16_t)len,
 800ed7e:	9300      	str	r3, [sp, #0]
 800ed80:	4603      	mov	r3, r0
 800ed82:	6978      	ldr	r0, [r7, #20]
 800ed84:	f005 fe6c 	bl	8014a60 <USB_WritePacket>

    ep->xfer_buff  += len;
 800ed88:	68fb      	ldr	r3, [r7, #12]
 800ed8a:	68da      	ldr	r2, [r3, #12]
 800ed8c:	69fb      	ldr	r3, [r7, #28]
 800ed8e:	441a      	add	r2, r3
 800ed90:	68fb      	ldr	r3, [r7, #12]
 800ed92:	60da      	str	r2, [r3, #12]
    ep->xfer_count += len;
 800ed94:	68fb      	ldr	r3, [r7, #12]
 800ed96:	695a      	ldr	r2, [r3, #20]
 800ed98:	69fb      	ldr	r3, [r7, #28]
 800ed9a:	441a      	add	r2, r3
 800ed9c:	68fb      	ldr	r3, [r7, #12]
 800ed9e:	615a      	str	r2, [r3, #20]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800eda0:	683b      	ldr	r3, [r7, #0]
 800eda2:	015a      	lsls	r2, r3, #5
 800eda4:	693b      	ldr	r3, [r7, #16]
 800eda6:	4413      	add	r3, r2
 800eda8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 800edac:	699b      	ldr	r3, [r3, #24]
 800edae:	b29b      	uxth	r3, r3
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800edb0:	69ba      	ldr	r2, [r7, #24]
 800edb2:	429a      	cmp	r2, r3
 800edb4:	d809      	bhi.n	800edca <PCD_WriteEmptyTxFifo+0xde>
 800edb6:	68fb      	ldr	r3, [r7, #12]
 800edb8:	695a      	ldr	r2, [r3, #20]
 800edba:	68fb      	ldr	r3, [r7, #12]
 800edbc:	691b      	ldr	r3, [r3, #16]
  while (((USBx_INEP(epnum)->DTXFSTS & USB_OTG_DTXFSTS_INEPTFSAV) >= len32b) &&
 800edbe:	429a      	cmp	r2, r3
 800edc0:	d203      	bcs.n	800edca <PCD_WriteEmptyTxFifo+0xde>
         (ep->xfer_count < ep->xfer_len) && (ep->xfer_len != 0U))
 800edc2:	68fb      	ldr	r3, [r7, #12]
 800edc4:	691b      	ldr	r3, [r3, #16]
 800edc6:	2b00      	cmp	r3, #0
 800edc8:	d1bf      	bne.n	800ed4a <PCD_WriteEmptyTxFifo+0x5e>
  }

  if (ep->xfer_len <= ep->xfer_count)
 800edca:	68fb      	ldr	r3, [r7, #12]
 800edcc:	691a      	ldr	r2, [r3, #16]
 800edce:	68fb      	ldr	r3, [r7, #12]
 800edd0:	695b      	ldr	r3, [r3, #20]
 800edd2:	429a      	cmp	r2, r3
 800edd4:	d811      	bhi.n	800edfa <PCD_WriteEmptyTxFifo+0x10e>
  {
    fifoemptymsk = (uint32_t)(0x1UL << (epnum & EP_ADDR_MSK));
 800edd6:	683b      	ldr	r3, [r7, #0]
 800edd8:	f003 030f 	and.w	r3, r3, #15
 800eddc:	2201      	movs	r2, #1
 800edde:	fa02 f303 	lsl.w	r3, r2, r3
 800ede2:	60bb      	str	r3, [r7, #8]
    USBx_DEVICE->DIEPEMPMSK &= ~fifoemptymsk;
 800ede4:	693b      	ldr	r3, [r7, #16]
 800ede6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 800edea:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800edec:	68bb      	ldr	r3, [r7, #8]
 800edee:	43db      	mvns	r3, r3
 800edf0:	6939      	ldr	r1, [r7, #16]
 800edf2:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 800edf6:	4013      	ands	r3, r2
 800edf8:	634b      	str	r3, [r1, #52]	@ 0x34
  }

  return HAL_OK;
 800edfa:	2300      	movs	r3, #0
}
 800edfc:	4618      	mov	r0, r3
 800edfe:	3720      	adds	r7, #32
 800ee00:	46bd      	mov	sp, r7
 800ee02:	bd80      	pop	{r7, pc}

0800ee04 <PCD_EP_OutXfrComplete_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 800ee04:	b580      	push	{r7, lr}
 800ee06:	b088      	sub	sp, #32
 800ee08:	af00      	add	r7, sp, #0
 800ee0a:	6078      	str	r0, [r7, #4]
 800ee0c:	6039      	str	r1, [r7, #0]
  USB_OTG_EPTypeDef *ep;
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800ee0e:	687b      	ldr	r3, [r7, #4]
 800ee10:	681b      	ldr	r3, [r3, #0]
 800ee12:	61fb      	str	r3, [r7, #28]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800ee14:	69fb      	ldr	r3, [r7, #28]
 800ee16:	61bb      	str	r3, [r7, #24]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 800ee18:	69fb      	ldr	r3, [r7, #28]
 800ee1a:	333c      	adds	r3, #60	@ 0x3c
 800ee1c:	3304      	adds	r3, #4
 800ee1e:	681b      	ldr	r3, [r3, #0]
 800ee20:	617b      	str	r3, [r7, #20]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800ee22:	683b      	ldr	r3, [r7, #0]
 800ee24:	015a      	lsls	r2, r3, #5
 800ee26:	69bb      	ldr	r3, [r7, #24]
 800ee28:	4413      	add	r3, r2
 800ee2a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ee2e:	689b      	ldr	r3, [r3, #8]
 800ee30:	613b      	str	r3, [r7, #16]

  if (hpcd->Init.dma_enable == 1U)
 800ee32:	687b      	ldr	r3, [r7, #4]
 800ee34:	799b      	ldrb	r3, [r3, #6]
 800ee36:	2b01      	cmp	r3, #1
 800ee38:	d17b      	bne.n	800ef32 <PCD_EP_OutXfrComplete_int+0x12e>
  {
    if ((DoepintReg & USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP) /* Class C */
 800ee3a:	693b      	ldr	r3, [r7, #16]
 800ee3c:	f003 0308 	and.w	r3, r3, #8
 800ee40:	2b00      	cmp	r3, #0
 800ee42:	d015      	beq.n	800ee70 <PCD_EP_OutXfrComplete_int+0x6c>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800ee44:	697b      	ldr	r3, [r7, #20]
 800ee46:	4a61      	ldr	r2, [pc, #388]	@ (800efcc <PCD_EP_OutXfrComplete_int+0x1c8>)
 800ee48:	4293      	cmp	r3, r2
 800ee4a:	f240 80b9 	bls.w	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 800ee4e:	693b      	ldr	r3, [r7, #16]
 800ee50:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800ee54:	2b00      	cmp	r3, #0
 800ee56:	f000 80b3 	beq.w	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800ee5a:	683b      	ldr	r3, [r7, #0]
 800ee5c:	015a      	lsls	r2, r3, #5
 800ee5e:	69bb      	ldr	r3, [r7, #24]
 800ee60:	4413      	add	r3, r2
 800ee62:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ee66:	461a      	mov	r2, r3
 800ee68:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800ee6c:	6093      	str	r3, [r2, #8]
 800ee6e:	e0a7      	b.n	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
    }
    else if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR) /* Class E */
 800ee70:	693b      	ldr	r3, [r7, #16]
 800ee72:	f003 0320 	and.w	r3, r3, #32
 800ee76:	2b00      	cmp	r3, #0
 800ee78:	d009      	beq.n	800ee8e <PCD_EP_OutXfrComplete_int+0x8a>
    {
      CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800ee7a:	683b      	ldr	r3, [r7, #0]
 800ee7c:	015a      	lsls	r2, r3, #5
 800ee7e:	69bb      	ldr	r3, [r7, #24]
 800ee80:	4413      	add	r3, r2
 800ee82:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ee86:	461a      	mov	r2, r3
 800ee88:	2320      	movs	r3, #32
 800ee8a:	6093      	str	r3, [r2, #8]
 800ee8c:	e098      	b.n	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
    }
    else if ((DoepintReg & (USB_OTG_DOEPINT_STUP | USB_OTG_DOEPINT_OTEPSPR)) == 0U)
 800ee8e:	693b      	ldr	r3, [r7, #16]
 800ee90:	f003 0328 	and.w	r3, r3, #40	@ 0x28
 800ee94:	2b00      	cmp	r3, #0
 800ee96:	f040 8093 	bne.w	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800ee9a:	697b      	ldr	r3, [r7, #20]
 800ee9c:	4a4b      	ldr	r2, [pc, #300]	@ (800efcc <PCD_EP_OutXfrComplete_int+0x1c8>)
 800ee9e:	4293      	cmp	r3, r2
 800eea0:	d90f      	bls.n	800eec2 <PCD_EP_OutXfrComplete_int+0xbe>
          ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 800eea2:	693b      	ldr	r3, [r7, #16]
 800eea4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
      if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800eea8:	2b00      	cmp	r3, #0
 800eeaa:	d00a      	beq.n	800eec2 <PCD_EP_OutXfrComplete_int+0xbe>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800eeac:	683b      	ldr	r3, [r7, #0]
 800eeae:	015a      	lsls	r2, r3, #5
 800eeb0:	69bb      	ldr	r3, [r7, #24]
 800eeb2:	4413      	add	r3, r2
 800eeb4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800eeb8:	461a      	mov	r2, r3
 800eeba:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800eebe:	6093      	str	r3, [r2, #8]
 800eec0:	e07e      	b.n	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        ep = &hpcd->OUT_ep[epnum];
 800eec2:	683a      	ldr	r2, [r7, #0]
 800eec4:	4613      	mov	r3, r2
 800eec6:	00db      	lsls	r3, r3, #3
 800eec8:	4413      	add	r3, r2
 800eeca:	009b      	lsls	r3, r3, #2
 800eecc:	f503 7314 	add.w	r3, r3, #592	@ 0x250
 800eed0:	687a      	ldr	r2, [r7, #4]
 800eed2:	4413      	add	r3, r2
 800eed4:	3304      	adds	r3, #4
 800eed6:	60fb      	str	r3, [r7, #12]

        /* out data packet received over EP */
        ep->xfer_count = ep->xfer_size - (USBx_OUTEP(epnum)->DOEPTSIZ & USB_OTG_DOEPTSIZ_XFRSIZ);
 800eed8:	68fb      	ldr	r3, [r7, #12]
 800eeda:	6a1a      	ldr	r2, [r3, #32]
 800eedc:	683b      	ldr	r3, [r7, #0]
 800eede:	0159      	lsls	r1, r3, #5
 800eee0:	69bb      	ldr	r3, [r7, #24]
 800eee2:	440b      	add	r3, r1
 800eee4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800eee8:	691b      	ldr	r3, [r3, #16]
 800eeea:	f3c3 0312 	ubfx	r3, r3, #0, #19
 800eeee:	1ad2      	subs	r2, r2, r3
 800eef0:	68fb      	ldr	r3, [r7, #12]
 800eef2:	615a      	str	r2, [r3, #20]

        if (epnum == 0U)
 800eef4:	683b      	ldr	r3, [r7, #0]
 800eef6:	2b00      	cmp	r3, #0
 800eef8:	d114      	bne.n	800ef24 <PCD_EP_OutXfrComplete_int+0x120>
        {
          if (ep->xfer_len == 0U)
 800eefa:	68fb      	ldr	r3, [r7, #12]
 800eefc:	691b      	ldr	r3, [r3, #16]
 800eefe:	2b00      	cmp	r3, #0
 800ef00:	d109      	bne.n	800ef16 <PCD_EP_OutXfrComplete_int+0x112>
          {
            /* this is ZLP, so prepare EP0 for next setup */
            (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800ef02:	687b      	ldr	r3, [r7, #4]
 800ef04:	6818      	ldr	r0, [r3, #0]
 800ef06:	687b      	ldr	r3, [r7, #4]
 800ef08:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800ef0c:	461a      	mov	r2, r3
 800ef0e:	2101      	movs	r1, #1
 800ef10:	f006 f83c 	bl	8014f8c <USB_EP0_OutStart>
 800ef14:	e006      	b.n	800ef24 <PCD_EP_OutXfrComplete_int+0x120>
          }
          else
          {
            ep->xfer_buff += ep->xfer_count;
 800ef16:	68fb      	ldr	r3, [r7, #12]
 800ef18:	68da      	ldr	r2, [r3, #12]
 800ef1a:	68fb      	ldr	r3, [r7, #12]
 800ef1c:	695b      	ldr	r3, [r3, #20]
 800ef1e:	441a      	add	r2, r3
 800ef20:	68fb      	ldr	r3, [r7, #12]
 800ef22:	60da      	str	r2, [r3, #12]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800ef24:	683b      	ldr	r3, [r7, #0]
 800ef26:	b2db      	uxtb	r3, r3
 800ef28:	4619      	mov	r1, r3
 800ef2a:	6878      	ldr	r0, [r7, #4]
 800ef2c:	f00c fd7e 	bl	801ba2c <HAL_PCD_DataOutStageCallback>
 800ef30:	e046      	b.n	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
      /* ... */
    }
  }
  else
  {
    if (gSNPSiD == USB_OTG_CORE_ID_310A)
 800ef32:	697b      	ldr	r3, [r7, #20]
 800ef34:	4a26      	ldr	r2, [pc, #152]	@ (800efd0 <PCD_EP_OutXfrComplete_int+0x1cc>)
 800ef36:	4293      	cmp	r3, r2
 800ef38:	d124      	bne.n	800ef84 <PCD_EP_OutXfrComplete_int+0x180>
    {
      /* StupPktRcvd = 1 this is a setup packet */
      if ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
 800ef3a:	693b      	ldr	r3, [r7, #16]
 800ef3c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800ef40:	2b00      	cmp	r3, #0
 800ef42:	d00a      	beq.n	800ef5a <PCD_EP_OutXfrComplete_int+0x156>
      {
        CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800ef44:	683b      	ldr	r3, [r7, #0]
 800ef46:	015a      	lsls	r2, r3, #5
 800ef48:	69bb      	ldr	r3, [r7, #24]
 800ef4a:	4413      	add	r3, r2
 800ef4c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ef50:	461a      	mov	r2, r3
 800ef52:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800ef56:	6093      	str	r3, [r2, #8]
 800ef58:	e032      	b.n	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
      }
      else
      {
        if ((DoepintReg & USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
 800ef5a:	693b      	ldr	r3, [r7, #16]
 800ef5c:	f003 0320 	and.w	r3, r3, #32
 800ef60:	2b00      	cmp	r3, #0
 800ef62:	d008      	beq.n	800ef76 <PCD_EP_OutXfrComplete_int+0x172>
        {
          CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
 800ef64:	683b      	ldr	r3, [r7, #0]
 800ef66:	015a      	lsls	r2, r3, #5
 800ef68:	69bb      	ldr	r3, [r7, #24]
 800ef6a:	4413      	add	r3, r2
 800ef6c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800ef70:	461a      	mov	r2, r3
 800ef72:	2320      	movs	r3, #32
 800ef74:	6093      	str	r3, [r2, #8]
        }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
        hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
        HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800ef76:	683b      	ldr	r3, [r7, #0]
 800ef78:	b2db      	uxtb	r3, r3
 800ef7a:	4619      	mov	r1, r3
 800ef7c:	6878      	ldr	r0, [r7, #4]
 800ef7e:	f00c fd55 	bl	801ba2c <HAL_PCD_DataOutStageCallback>
 800ef82:	e01d      	b.n	800efc0 <PCD_EP_OutXfrComplete_int+0x1bc>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
      }
    }
    else
    {
      if ((epnum == 0U) && (hpcd->OUT_ep[epnum].xfer_len == 0U))
 800ef84:	683b      	ldr	r3, [r7, #0]
 800ef86:	2b00      	cmp	r3, #0
 800ef88:	d114      	bne.n	800efb4 <PCD_EP_OutXfrComplete_int+0x1b0>
 800ef8a:	6879      	ldr	r1, [r7, #4]
 800ef8c:	683a      	ldr	r2, [r7, #0]
 800ef8e:	4613      	mov	r3, r2
 800ef90:	00db      	lsls	r3, r3, #3
 800ef92:	4413      	add	r3, r2
 800ef94:	009b      	lsls	r3, r3, #2
 800ef96:	440b      	add	r3, r1
 800ef98:	f503 7319 	add.w	r3, r3, #612	@ 0x264
 800ef9c:	681b      	ldr	r3, [r3, #0]
 800ef9e:	2b00      	cmp	r3, #0
 800efa0:	d108      	bne.n	800efb4 <PCD_EP_OutXfrComplete_int+0x1b0>
      {
        /* this is ZLP, so prepare EP0 for next setup */
        (void)USB_EP0_OutStart(hpcd->Instance, 0U, (uint8_t *)hpcd->Setup);
 800efa2:	687b      	ldr	r3, [r7, #4]
 800efa4:	6818      	ldr	r0, [r3, #0]
 800efa6:	687b      	ldr	r3, [r7, #4]
 800efa8:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800efac:	461a      	mov	r2, r3
 800efae:	2100      	movs	r1, #0
 800efb0:	f005 ffec 	bl	8014f8c <USB_EP0_OutStart>
      }

#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
      hpcd->DataOutStageCallback(hpcd, (uint8_t)epnum);
#else
      HAL_PCD_DataOutStageCallback(hpcd, (uint8_t)epnum);
 800efb4:	683b      	ldr	r3, [r7, #0]
 800efb6:	b2db      	uxtb	r3, r3
 800efb8:	4619      	mov	r1, r3
 800efba:	6878      	ldr	r0, [r7, #4]
 800efbc:	f00c fd36 	bl	801ba2c <HAL_PCD_DataOutStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
    }
  }

  return HAL_OK;
 800efc0:	2300      	movs	r3, #0
}
 800efc2:	4618      	mov	r0, r3
 800efc4:	3720      	adds	r7, #32
 800efc6:	46bd      	mov	sp, r7
 800efc8:	bd80      	pop	{r7, pc}
 800efca:	bf00      	nop
 800efcc:	4f54300a 	.word	0x4f54300a
 800efd0:	4f54310a 	.word	0x4f54310a

0800efd4 <PCD_EP_OutSetupPacket_int>:
  * @param  hpcd PCD handle
  * @param  epnum endpoint number
  * @retval HAL status
  */
static HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(PCD_HandleTypeDef *hpcd, uint32_t epnum)
{
 800efd4:	b580      	push	{r7, lr}
 800efd6:	b086      	sub	sp, #24
 800efd8:	af00      	add	r7, sp, #0
 800efda:	6078      	str	r0, [r7, #4]
 800efdc:	6039      	str	r1, [r7, #0]
  const USB_OTG_GlobalTypeDef *USBx = hpcd->Instance;
 800efde:	687b      	ldr	r3, [r7, #4]
 800efe0:	681b      	ldr	r3, [r3, #0]
 800efe2:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 800efe4:	697b      	ldr	r3, [r7, #20]
 800efe6:	613b      	str	r3, [r7, #16]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 800efe8:	697b      	ldr	r3, [r7, #20]
 800efea:	333c      	adds	r3, #60	@ 0x3c
 800efec:	3304      	adds	r3, #4
 800efee:	681b      	ldr	r3, [r3, #0]
 800eff0:	60fb      	str	r3, [r7, #12]
  uint32_t DoepintReg = USBx_OUTEP(epnum)->DOEPINT;
 800eff2:	683b      	ldr	r3, [r7, #0]
 800eff4:	015a      	lsls	r2, r3, #5
 800eff6:	693b      	ldr	r3, [r7, #16]
 800eff8:	4413      	add	r3, r2
 800effa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800effe:	689b      	ldr	r3, [r3, #8]
 800f000:	60bb      	str	r3, [r7, #8]

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800f002:	68fb      	ldr	r3, [r7, #12]
 800f004:	4a15      	ldr	r2, [pc, #84]	@ (800f05c <PCD_EP_OutSetupPacket_int+0x88>)
 800f006:	4293      	cmp	r3, r2
 800f008:	d90e      	bls.n	800f028 <PCD_EP_OutSetupPacket_int+0x54>
      ((DoepintReg & USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
 800f00a:	68bb      	ldr	r3, [r7, #8]
 800f00c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
  if ((gSNPSiD > USB_OTG_CORE_ID_300A) &&
 800f010:	2b00      	cmp	r3, #0
 800f012:	d009      	beq.n	800f028 <PCD_EP_OutSetupPacket_int+0x54>
  {
    CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
 800f014:	683b      	ldr	r3, [r7, #0]
 800f016:	015a      	lsls	r2, r3, #5
 800f018:	693b      	ldr	r3, [r7, #16]
 800f01a:	4413      	add	r3, r2
 800f01c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 800f020:	461a      	mov	r2, r3
 800f022:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800f026:	6093      	str	r3, [r2, #8]

  /* Inform the upper layer that a setup packet is available */
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
  hpcd->SetupStageCallback(hpcd);
#else
  HAL_PCD_SetupStageCallback(hpcd);
 800f028:	6878      	ldr	r0, [r7, #4]
 800f02a:	f00c fced 	bl	801ba08 <HAL_PCD_SetupStageCallback>
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */

  if ((gSNPSiD > USB_OTG_CORE_ID_300A) && (hpcd->Init.dma_enable == 1U))
 800f02e:	68fb      	ldr	r3, [r7, #12]
 800f030:	4a0a      	ldr	r2, [pc, #40]	@ (800f05c <PCD_EP_OutSetupPacket_int+0x88>)
 800f032:	4293      	cmp	r3, r2
 800f034:	d90c      	bls.n	800f050 <PCD_EP_OutSetupPacket_int+0x7c>
 800f036:	687b      	ldr	r3, [r7, #4]
 800f038:	799b      	ldrb	r3, [r3, #6]
 800f03a:	2b01      	cmp	r3, #1
 800f03c:	d108      	bne.n	800f050 <PCD_EP_OutSetupPacket_int+0x7c>
  {
    (void)USB_EP0_OutStart(hpcd->Instance, 1U, (uint8_t *)hpcd->Setup);
 800f03e:	687b      	ldr	r3, [r7, #4]
 800f040:	6818      	ldr	r0, [r3, #0]
 800f042:	687b      	ldr	r3, [r7, #4]
 800f044:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 800f048:	461a      	mov	r2, r3
 800f04a:	2101      	movs	r1, #1
 800f04c:	f005 ff9e 	bl	8014f8c <USB_EP0_OutStart>
  }

  return HAL_OK;
 800f050:	2300      	movs	r3, #0
}
 800f052:	4618      	mov	r0, r3
 800f054:	3718      	adds	r7, #24
 800f056:	46bd      	mov	sp, r7
 800f058:	bd80      	pop	{r7, pc}
 800f05a:	bf00      	nop
 800f05c:	4f54300a 	.word	0x4f54300a

0800f060 <HAL_PCDEx_SetTxFiFo>:
  * @param  fifo The number of Tx fifo
  * @param  size Fifo size
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size)
{
 800f060:	b480      	push	{r7}
 800f062:	b085      	sub	sp, #20
 800f064:	af00      	add	r7, sp, #0
 800f066:	6078      	str	r0, [r7, #4]
 800f068:	460b      	mov	r3, r1
 800f06a:	70fb      	strb	r3, [r7, #3]
 800f06c:	4613      	mov	r3, r2
 800f06e:	803b      	strh	r3, [r7, #0]
         --> Txn should be configured with the minimum space of 16 words
     The FIFO is used optimally when used TxFIFOs are allocated in the top
         of the FIFO.Ex: use EP1 and EP2 as IN instead of EP1 and EP3 as IN ones.
     When DMA is used 3n * FIFO locations should be reserved for internal DMA registers */

  Tx_Offset = hpcd->Instance->GRXFSIZ;
 800f070:	687b      	ldr	r3, [r7, #4]
 800f072:	681b      	ldr	r3, [r3, #0]
 800f074:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f076:	60bb      	str	r3, [r7, #8]

  if (fifo == 0U)
 800f078:	78fb      	ldrb	r3, [r7, #3]
 800f07a:	2b00      	cmp	r3, #0
 800f07c:	d107      	bne.n	800f08e <HAL_PCDEx_SetTxFiFo+0x2e>
  {
    hpcd->Instance->DIEPTXF0_HNPTXFSIZ = ((uint32_t)size << 16) | Tx_Offset;
 800f07e:	883b      	ldrh	r3, [r7, #0]
 800f080:	0419      	lsls	r1, r3, #16
 800f082:	687b      	ldr	r3, [r7, #4]
 800f084:	681b      	ldr	r3, [r3, #0]
 800f086:	68ba      	ldr	r2, [r7, #8]
 800f088:	430a      	orrs	r2, r1
 800f08a:	629a      	str	r2, [r3, #40]	@ 0x28
 800f08c:	e028      	b.n	800f0e0 <HAL_PCDEx_SetTxFiFo+0x80>
  }
  else
  {
    Tx_Offset += (hpcd->Instance->DIEPTXF0_HNPTXFSIZ) >> 16;
 800f08e:	687b      	ldr	r3, [r7, #4]
 800f090:	681b      	ldr	r3, [r3, #0]
 800f092:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f094:	0c1b      	lsrs	r3, r3, #16
 800f096:	68ba      	ldr	r2, [r7, #8]
 800f098:	4413      	add	r3, r2
 800f09a:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 800f09c:	2300      	movs	r3, #0
 800f09e:	73fb      	strb	r3, [r7, #15]
 800f0a0:	e00d      	b.n	800f0be <HAL_PCDEx_SetTxFiFo+0x5e>
    {
      Tx_Offset += (hpcd->Instance->DIEPTXF[i] >> 16);
 800f0a2:	687b      	ldr	r3, [r7, #4]
 800f0a4:	681a      	ldr	r2, [r3, #0]
 800f0a6:	7bfb      	ldrb	r3, [r7, #15]
 800f0a8:	3340      	adds	r3, #64	@ 0x40
 800f0aa:	009b      	lsls	r3, r3, #2
 800f0ac:	4413      	add	r3, r2
 800f0ae:	685b      	ldr	r3, [r3, #4]
 800f0b0:	0c1b      	lsrs	r3, r3, #16
 800f0b2:	68ba      	ldr	r2, [r7, #8]
 800f0b4:	4413      	add	r3, r2
 800f0b6:	60bb      	str	r3, [r7, #8]
    for (i = 0U; i < (fifo - 1U); i++)
 800f0b8:	7bfb      	ldrb	r3, [r7, #15]
 800f0ba:	3301      	adds	r3, #1
 800f0bc:	73fb      	strb	r3, [r7, #15]
 800f0be:	7bfa      	ldrb	r2, [r7, #15]
 800f0c0:	78fb      	ldrb	r3, [r7, #3]
 800f0c2:	3b01      	subs	r3, #1
 800f0c4:	429a      	cmp	r2, r3
 800f0c6:	d3ec      	bcc.n	800f0a2 <HAL_PCDEx_SetTxFiFo+0x42>
    }

    /* Multiply Tx_Size by 2 to get higher performance */
    hpcd->Instance->DIEPTXF[fifo - 1U] = ((uint32_t)size << 16) | Tx_Offset;
 800f0c8:	883b      	ldrh	r3, [r7, #0]
 800f0ca:	0418      	lsls	r0, r3, #16
 800f0cc:	687b      	ldr	r3, [r7, #4]
 800f0ce:	6819      	ldr	r1, [r3, #0]
 800f0d0:	78fb      	ldrb	r3, [r7, #3]
 800f0d2:	3b01      	subs	r3, #1
 800f0d4:	68ba      	ldr	r2, [r7, #8]
 800f0d6:	4302      	orrs	r2, r0
 800f0d8:	3340      	adds	r3, #64	@ 0x40
 800f0da:	009b      	lsls	r3, r3, #2
 800f0dc:	440b      	add	r3, r1
 800f0de:	605a      	str	r2, [r3, #4]
  }

  return HAL_OK;
 800f0e0:	2300      	movs	r3, #0
}
 800f0e2:	4618      	mov	r0, r3
 800f0e4:	3714      	adds	r7, #20
 800f0e6:	46bd      	mov	sp, r7
 800f0e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0ec:	4770      	bx	lr

0800f0ee <HAL_PCDEx_SetRxFiFo>:
  * @param  hpcd PCD handle
  * @param  size Size of Rx fifo
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size)
{
 800f0ee:	b480      	push	{r7}
 800f0f0:	b083      	sub	sp, #12
 800f0f2:	af00      	add	r7, sp, #0
 800f0f4:	6078      	str	r0, [r7, #4]
 800f0f6:	460b      	mov	r3, r1
 800f0f8:	807b      	strh	r3, [r7, #2]
  hpcd->Instance->GRXFSIZ = size;
 800f0fa:	687b      	ldr	r3, [r7, #4]
 800f0fc:	681b      	ldr	r3, [r3, #0]
 800f0fe:	887a      	ldrh	r2, [r7, #2]
 800f100:	625a      	str	r2, [r3, #36]	@ 0x24

  return HAL_OK;
 800f102:	2300      	movs	r3, #0
}
 800f104:	4618      	mov	r0, r3
 800f106:	370c      	adds	r7, #12
 800f108:	46bd      	mov	sp, r7
 800f10a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f10e:	4770      	bx	lr

0800f110 <HAL_PCDEx_LPM_Callback>:
  * @param  hpcd PCD handle
  * @param  msg LPM message
  * @retval HAL status
  */
__weak void HAL_PCDEx_LPM_Callback(PCD_HandleTypeDef *hpcd, PCD_LPM_MsgTypeDef msg)
{
 800f110:	b480      	push	{r7}
 800f112:	b083      	sub	sp, #12
 800f114:	af00      	add	r7, sp, #0
 800f116:	6078      	str	r0, [r7, #4]
 800f118:	460b      	mov	r3, r1
 800f11a:	70fb      	strb	r3, [r7, #3]
  UNUSED(msg);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PCDEx_LPM_Callback could be implemented in the user file
   */
}
 800f11c:	bf00      	nop
 800f11e:	370c      	adds	r7, #12
 800f120:	46bd      	mov	sp, r7
 800f122:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f126:	4770      	bx	lr

0800f128 <HAL_RCC_OscConfig>:
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 800f128:	b580      	push	{r7, lr}
 800f12a:	b086      	sub	sp, #24
 800f12c:	af00      	add	r7, sp, #0
 800f12e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart, pll_config;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 800f130:	687b      	ldr	r3, [r7, #4]
 800f132:	2b00      	cmp	r3, #0
 800f134:	d101      	bne.n	800f13a <HAL_RCC_OscConfig+0x12>
  {
    return HAL_ERROR;
 800f136:	2301      	movs	r3, #1
 800f138:	e267      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800f13a:	687b      	ldr	r3, [r7, #4]
 800f13c:	681b      	ldr	r3, [r3, #0]
 800f13e:	f003 0301 	and.w	r3, r3, #1
 800f142:	2b00      	cmp	r3, #0
 800f144:	d075      	beq.n	800f232 <HAL_RCC_OscConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 800f146:	4b88      	ldr	r3, [pc, #544]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f148:	689b      	ldr	r3, [r3, #8]
 800f14a:	f003 030c 	and.w	r3, r3, #12
 800f14e:	2b04      	cmp	r3, #4
 800f150:	d00c      	beq.n	800f16c <HAL_RCC_OscConfig+0x44>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800f152:	4b85      	ldr	r3, [pc, #532]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f154:	689b      	ldr	r3, [r3, #8]
 800f156:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 800f15a:	2b08      	cmp	r3, #8
 800f15c:	d112      	bne.n	800f184 <HAL_RCC_OscConfig+0x5c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 800f15e:	4b82      	ldr	r3, [pc, #520]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f160:	685b      	ldr	r3, [r3, #4]
 800f162:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800f166:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800f16a:	d10b      	bne.n	800f184 <HAL_RCC_OscConfig+0x5c>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800f16c:	4b7e      	ldr	r3, [pc, #504]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f16e:	681b      	ldr	r3, [r3, #0]
 800f170:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800f174:	2b00      	cmp	r3, #0
 800f176:	d05b      	beq.n	800f230 <HAL_RCC_OscConfig+0x108>
 800f178:	687b      	ldr	r3, [r7, #4]
 800f17a:	685b      	ldr	r3, [r3, #4]
 800f17c:	2b00      	cmp	r3, #0
 800f17e:	d157      	bne.n	800f230 <HAL_RCC_OscConfig+0x108>
      {
        return HAL_ERROR;
 800f180:	2301      	movs	r3, #1
 800f182:	e242      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800f184:	687b      	ldr	r3, [r7, #4]
 800f186:	685b      	ldr	r3, [r3, #4]
 800f188:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800f18c:	d106      	bne.n	800f19c <HAL_RCC_OscConfig+0x74>
 800f18e:	4b76      	ldr	r3, [pc, #472]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f190:	681b      	ldr	r3, [r3, #0]
 800f192:	4a75      	ldr	r2, [pc, #468]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f194:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800f198:	6013      	str	r3, [r2, #0]
 800f19a:	e01d      	b.n	800f1d8 <HAL_RCC_OscConfig+0xb0>
 800f19c:	687b      	ldr	r3, [r7, #4]
 800f19e:	685b      	ldr	r3, [r3, #4]
 800f1a0:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800f1a4:	d10c      	bne.n	800f1c0 <HAL_RCC_OscConfig+0x98>
 800f1a6:	4b70      	ldr	r3, [pc, #448]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1a8:	681b      	ldr	r3, [r3, #0]
 800f1aa:	4a6f      	ldr	r2, [pc, #444]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1ac:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800f1b0:	6013      	str	r3, [r2, #0]
 800f1b2:	4b6d      	ldr	r3, [pc, #436]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1b4:	681b      	ldr	r3, [r3, #0]
 800f1b6:	4a6c      	ldr	r2, [pc, #432]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1b8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800f1bc:	6013      	str	r3, [r2, #0]
 800f1be:	e00b      	b.n	800f1d8 <HAL_RCC_OscConfig+0xb0>
 800f1c0:	4b69      	ldr	r3, [pc, #420]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1c2:	681b      	ldr	r3, [r3, #0]
 800f1c4:	4a68      	ldr	r2, [pc, #416]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1c6:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 800f1ca:	6013      	str	r3, [r2, #0]
 800f1cc:	4b66      	ldr	r3, [pc, #408]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1ce:	681b      	ldr	r3, [r3, #0]
 800f1d0:	4a65      	ldr	r2, [pc, #404]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1d2:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800f1d6:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 800f1d8:	687b      	ldr	r3, [r7, #4]
 800f1da:	685b      	ldr	r3, [r3, #4]
 800f1dc:	2b00      	cmp	r3, #0
 800f1de:	d013      	beq.n	800f208 <HAL_RCC_OscConfig+0xe0>
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800f1e0:	f7f9 fd50 	bl	8008c84 <HAL_GetTick>
 800f1e4:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800f1e6:	e008      	b.n	800f1fa <HAL_RCC_OscConfig+0xd2>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800f1e8:	f7f9 fd4c 	bl	8008c84 <HAL_GetTick>
 800f1ec:	4602      	mov	r2, r0
 800f1ee:	693b      	ldr	r3, [r7, #16]
 800f1f0:	1ad3      	subs	r3, r2, r3
 800f1f2:	2b64      	cmp	r3, #100	@ 0x64
 800f1f4:	d901      	bls.n	800f1fa <HAL_RCC_OscConfig+0xd2>
          {
            return HAL_TIMEOUT;
 800f1f6:	2303      	movs	r3, #3
 800f1f8:	e207      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800f1fa:	4b5b      	ldr	r3, [pc, #364]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f1fc:	681b      	ldr	r3, [r3, #0]
 800f1fe:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800f202:	2b00      	cmp	r3, #0
 800f204:	d0f0      	beq.n	800f1e8 <HAL_RCC_OscConfig+0xc0>
 800f206:	e014      	b.n	800f232 <HAL_RCC_OscConfig+0x10a>
        }
      }
      else
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800f208:	f7f9 fd3c 	bl	8008c84 <HAL_GetTick>
 800f20c:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800f20e:	e008      	b.n	800f222 <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800f210:	f7f9 fd38 	bl	8008c84 <HAL_GetTick>
 800f214:	4602      	mov	r2, r0
 800f216:	693b      	ldr	r3, [r7, #16]
 800f218:	1ad3      	subs	r3, r2, r3
 800f21a:	2b64      	cmp	r3, #100	@ 0x64
 800f21c:	d901      	bls.n	800f222 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800f21e:	2303      	movs	r3, #3
 800f220:	e1f3      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800f222:	4b51      	ldr	r3, [pc, #324]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f224:	681b      	ldr	r3, [r3, #0]
 800f226:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800f22a:	2b00      	cmp	r3, #0
 800f22c:	d1f0      	bne.n	800f210 <HAL_RCC_OscConfig+0xe8>
 800f22e:	e000      	b.n	800f232 <HAL_RCC_OscConfig+0x10a>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800f230:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800f232:	687b      	ldr	r3, [r7, #4]
 800f234:	681b      	ldr	r3, [r3, #0]
 800f236:	f003 0302 	and.w	r3, r3, #2
 800f23a:	2b00      	cmp	r3, #0
 800f23c:	d063      	beq.n	800f306 <HAL_RCC_OscConfig+0x1de>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800f23e:	4b4a      	ldr	r3, [pc, #296]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f240:	689b      	ldr	r3, [r3, #8]
 800f242:	f003 030c 	and.w	r3, r3, #12
 800f246:	2b00      	cmp	r3, #0
 800f248:	d00b      	beq.n	800f262 <HAL_RCC_OscConfig+0x13a>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800f24a:	4b47      	ldr	r3, [pc, #284]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f24c:	689b      	ldr	r3, [r3, #8]
 800f24e:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 800f252:	2b08      	cmp	r3, #8
 800f254:	d11c      	bne.n	800f290 <HAL_RCC_OscConfig+0x168>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 800f256:	4b44      	ldr	r3, [pc, #272]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f258:	685b      	ldr	r3, [r3, #4]
 800f25a:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800f25e:	2b00      	cmp	r3, #0
 800f260:	d116      	bne.n	800f290 <HAL_RCC_OscConfig+0x168>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800f262:	4b41      	ldr	r3, [pc, #260]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f264:	681b      	ldr	r3, [r3, #0]
 800f266:	f003 0302 	and.w	r3, r3, #2
 800f26a:	2b00      	cmp	r3, #0
 800f26c:	d005      	beq.n	800f27a <HAL_RCC_OscConfig+0x152>
 800f26e:	687b      	ldr	r3, [r7, #4]
 800f270:	68db      	ldr	r3, [r3, #12]
 800f272:	2b01      	cmp	r3, #1
 800f274:	d001      	beq.n	800f27a <HAL_RCC_OscConfig+0x152>
      {
        return HAL_ERROR;
 800f276:	2301      	movs	r3, #1
 800f278:	e1c7      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800f27a:	4b3b      	ldr	r3, [pc, #236]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f27c:	681b      	ldr	r3, [r3, #0]
 800f27e:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800f282:	687b      	ldr	r3, [r7, #4]
 800f284:	691b      	ldr	r3, [r3, #16]
 800f286:	00db      	lsls	r3, r3, #3
 800f288:	4937      	ldr	r1, [pc, #220]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f28a:	4313      	orrs	r3, r2
 800f28c:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800f28e:	e03a      	b.n	800f306 <HAL_RCC_OscConfig+0x1de>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 800f290:	687b      	ldr	r3, [r7, #4]
 800f292:	68db      	ldr	r3, [r3, #12]
 800f294:	2b00      	cmp	r3, #0
 800f296:	d020      	beq.n	800f2da <HAL_RCC_OscConfig+0x1b2>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800f298:	4b34      	ldr	r3, [pc, #208]	@ (800f36c <HAL_RCC_OscConfig+0x244>)
 800f29a:	2201      	movs	r2, #1
 800f29c:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800f29e:	f7f9 fcf1 	bl	8008c84 <HAL_GetTick>
 800f2a2:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800f2a4:	e008      	b.n	800f2b8 <HAL_RCC_OscConfig+0x190>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800f2a6:	f7f9 fced 	bl	8008c84 <HAL_GetTick>
 800f2aa:	4602      	mov	r2, r0
 800f2ac:	693b      	ldr	r3, [r7, #16]
 800f2ae:	1ad3      	subs	r3, r2, r3
 800f2b0:	2b02      	cmp	r3, #2
 800f2b2:	d901      	bls.n	800f2b8 <HAL_RCC_OscConfig+0x190>
          {
            return HAL_TIMEOUT;
 800f2b4:	2303      	movs	r3, #3
 800f2b6:	e1a8      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800f2b8:	4b2b      	ldr	r3, [pc, #172]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f2ba:	681b      	ldr	r3, [r3, #0]
 800f2bc:	f003 0302 	and.w	r3, r3, #2
 800f2c0:	2b00      	cmp	r3, #0
 800f2c2:	d0f0      	beq.n	800f2a6 <HAL_RCC_OscConfig+0x17e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value. */
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800f2c4:	4b28      	ldr	r3, [pc, #160]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f2c6:	681b      	ldr	r3, [r3, #0]
 800f2c8:	f023 02f8 	bic.w	r2, r3, #248	@ 0xf8
 800f2cc:	687b      	ldr	r3, [r7, #4]
 800f2ce:	691b      	ldr	r3, [r3, #16]
 800f2d0:	00db      	lsls	r3, r3, #3
 800f2d2:	4925      	ldr	r1, [pc, #148]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f2d4:	4313      	orrs	r3, r2
 800f2d6:	600b      	str	r3, [r1, #0]
 800f2d8:	e015      	b.n	800f306 <HAL_RCC_OscConfig+0x1de>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800f2da:	4b24      	ldr	r3, [pc, #144]	@ (800f36c <HAL_RCC_OscConfig+0x244>)
 800f2dc:	2200      	movs	r2, #0
 800f2de:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800f2e0:	f7f9 fcd0 	bl	8008c84 <HAL_GetTick>
 800f2e4:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800f2e6:	e008      	b.n	800f2fa <HAL_RCC_OscConfig+0x1d2>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800f2e8:	f7f9 fccc 	bl	8008c84 <HAL_GetTick>
 800f2ec:	4602      	mov	r2, r0
 800f2ee:	693b      	ldr	r3, [r7, #16]
 800f2f0:	1ad3      	subs	r3, r2, r3
 800f2f2:	2b02      	cmp	r3, #2
 800f2f4:	d901      	bls.n	800f2fa <HAL_RCC_OscConfig+0x1d2>
          {
            return HAL_TIMEOUT;
 800f2f6:	2303      	movs	r3, #3
 800f2f8:	e187      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800f2fa:	4b1b      	ldr	r3, [pc, #108]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f2fc:	681b      	ldr	r3, [r3, #0]
 800f2fe:	f003 0302 	and.w	r3, r3, #2
 800f302:	2b00      	cmp	r3, #0
 800f304:	d1f0      	bne.n	800f2e8 <HAL_RCC_OscConfig+0x1c0>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800f306:	687b      	ldr	r3, [r7, #4]
 800f308:	681b      	ldr	r3, [r3, #0]
 800f30a:	f003 0308 	and.w	r3, r3, #8
 800f30e:	2b00      	cmp	r3, #0
 800f310:	d036      	beq.n	800f380 <HAL_RCC_OscConfig+0x258>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 800f312:	687b      	ldr	r3, [r7, #4]
 800f314:	695b      	ldr	r3, [r3, #20]
 800f316:	2b00      	cmp	r3, #0
 800f318:	d016      	beq.n	800f348 <HAL_RCC_OscConfig+0x220>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800f31a:	4b15      	ldr	r3, [pc, #84]	@ (800f370 <HAL_RCC_OscConfig+0x248>)
 800f31c:	2201      	movs	r2, #1
 800f31e:	601a      	str	r2, [r3, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800f320:	f7f9 fcb0 	bl	8008c84 <HAL_GetTick>
 800f324:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800f326:	e008      	b.n	800f33a <HAL_RCC_OscConfig+0x212>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800f328:	f7f9 fcac 	bl	8008c84 <HAL_GetTick>
 800f32c:	4602      	mov	r2, r0
 800f32e:	693b      	ldr	r3, [r7, #16]
 800f330:	1ad3      	subs	r3, r2, r3
 800f332:	2b02      	cmp	r3, #2
 800f334:	d901      	bls.n	800f33a <HAL_RCC_OscConfig+0x212>
        {
          return HAL_TIMEOUT;
 800f336:	2303      	movs	r3, #3
 800f338:	e167      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800f33a:	4b0b      	ldr	r3, [pc, #44]	@ (800f368 <HAL_RCC_OscConfig+0x240>)
 800f33c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800f33e:	f003 0302 	and.w	r3, r3, #2
 800f342:	2b00      	cmp	r3, #0
 800f344:	d0f0      	beq.n	800f328 <HAL_RCC_OscConfig+0x200>
 800f346:	e01b      	b.n	800f380 <HAL_RCC_OscConfig+0x258>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 800f348:	4b09      	ldr	r3, [pc, #36]	@ (800f370 <HAL_RCC_OscConfig+0x248>)
 800f34a:	2200      	movs	r2, #0
 800f34c:	601a      	str	r2, [r3, #0]

      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800f34e:	f7f9 fc99 	bl	8008c84 <HAL_GetTick>
 800f352:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800f354:	e00e      	b.n	800f374 <HAL_RCC_OscConfig+0x24c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800f356:	f7f9 fc95 	bl	8008c84 <HAL_GetTick>
 800f35a:	4602      	mov	r2, r0
 800f35c:	693b      	ldr	r3, [r7, #16]
 800f35e:	1ad3      	subs	r3, r2, r3
 800f360:	2b02      	cmp	r3, #2
 800f362:	d907      	bls.n	800f374 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 800f364:	2303      	movs	r3, #3
 800f366:	e150      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
 800f368:	40023800 	.word	0x40023800
 800f36c:	42470000 	.word	0x42470000
 800f370:	42470e80 	.word	0x42470e80
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800f374:	4b88      	ldr	r3, [pc, #544]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f376:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800f378:	f003 0302 	and.w	r3, r3, #2
 800f37c:	2b00      	cmp	r3, #0
 800f37e:	d1ea      	bne.n	800f356 <HAL_RCC_OscConfig+0x22e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800f380:	687b      	ldr	r3, [r7, #4]
 800f382:	681b      	ldr	r3, [r3, #0]
 800f384:	f003 0304 	and.w	r3, r3, #4
 800f388:	2b00      	cmp	r3, #0
 800f38a:	f000 8097 	beq.w	800f4bc <HAL_RCC_OscConfig+0x394>
  {
    FlagStatus       pwrclkchanged = RESET;
 800f38e:	2300      	movs	r3, #0
 800f390:	75fb      	strb	r3, [r7, #23]
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800f392:	4b81      	ldr	r3, [pc, #516]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f394:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f396:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800f39a:	2b00      	cmp	r3, #0
 800f39c:	d10f      	bne.n	800f3be <HAL_RCC_OscConfig+0x296>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 800f39e:	2300      	movs	r3, #0
 800f3a0:	60bb      	str	r3, [r7, #8]
 800f3a2:	4b7d      	ldr	r3, [pc, #500]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f3a4:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f3a6:	4a7c      	ldr	r2, [pc, #496]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f3a8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800f3ac:	6413      	str	r3, [r2, #64]	@ 0x40
 800f3ae:	4b7a      	ldr	r3, [pc, #488]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f3b0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f3b2:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800f3b6:	60bb      	str	r3, [r7, #8]
 800f3b8:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
 800f3ba:	2301      	movs	r3, #1
 800f3bc:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800f3be:	4b77      	ldr	r3, [pc, #476]	@ (800f59c <HAL_RCC_OscConfig+0x474>)
 800f3c0:	681b      	ldr	r3, [r3, #0]
 800f3c2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800f3c6:	2b00      	cmp	r3, #0
 800f3c8:	d118      	bne.n	800f3fc <HAL_RCC_OscConfig+0x2d4>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800f3ca:	4b74      	ldr	r3, [pc, #464]	@ (800f59c <HAL_RCC_OscConfig+0x474>)
 800f3cc:	681b      	ldr	r3, [r3, #0]
 800f3ce:	4a73      	ldr	r2, [pc, #460]	@ (800f59c <HAL_RCC_OscConfig+0x474>)
 800f3d0:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800f3d4:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 800f3d6:	f7f9 fc55 	bl	8008c84 <HAL_GetTick>
 800f3da:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800f3dc:	e008      	b.n	800f3f0 <HAL_RCC_OscConfig+0x2c8>
      {
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800f3de:	f7f9 fc51 	bl	8008c84 <HAL_GetTick>
 800f3e2:	4602      	mov	r2, r0
 800f3e4:	693b      	ldr	r3, [r7, #16]
 800f3e6:	1ad3      	subs	r3, r2, r3
 800f3e8:	2b02      	cmp	r3, #2
 800f3ea:	d901      	bls.n	800f3f0 <HAL_RCC_OscConfig+0x2c8>
        {
          return HAL_TIMEOUT;
 800f3ec:	2303      	movs	r3, #3
 800f3ee:	e10c      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800f3f0:	4b6a      	ldr	r3, [pc, #424]	@ (800f59c <HAL_RCC_OscConfig+0x474>)
 800f3f2:	681b      	ldr	r3, [r3, #0]
 800f3f4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800f3f8:	2b00      	cmp	r3, #0
 800f3fa:	d0f0      	beq.n	800f3de <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800f3fc:	687b      	ldr	r3, [r7, #4]
 800f3fe:	689b      	ldr	r3, [r3, #8]
 800f400:	2b01      	cmp	r3, #1
 800f402:	d106      	bne.n	800f412 <HAL_RCC_OscConfig+0x2ea>
 800f404:	4b64      	ldr	r3, [pc, #400]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f406:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f408:	4a63      	ldr	r2, [pc, #396]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f40a:	f043 0301 	orr.w	r3, r3, #1
 800f40e:	6713      	str	r3, [r2, #112]	@ 0x70
 800f410:	e01c      	b.n	800f44c <HAL_RCC_OscConfig+0x324>
 800f412:	687b      	ldr	r3, [r7, #4]
 800f414:	689b      	ldr	r3, [r3, #8]
 800f416:	2b05      	cmp	r3, #5
 800f418:	d10c      	bne.n	800f434 <HAL_RCC_OscConfig+0x30c>
 800f41a:	4b5f      	ldr	r3, [pc, #380]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f41c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f41e:	4a5e      	ldr	r2, [pc, #376]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f420:	f043 0304 	orr.w	r3, r3, #4
 800f424:	6713      	str	r3, [r2, #112]	@ 0x70
 800f426:	4b5c      	ldr	r3, [pc, #368]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f428:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f42a:	4a5b      	ldr	r2, [pc, #364]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f42c:	f043 0301 	orr.w	r3, r3, #1
 800f430:	6713      	str	r3, [r2, #112]	@ 0x70
 800f432:	e00b      	b.n	800f44c <HAL_RCC_OscConfig+0x324>
 800f434:	4b58      	ldr	r3, [pc, #352]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f436:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f438:	4a57      	ldr	r2, [pc, #348]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f43a:	f023 0301 	bic.w	r3, r3, #1
 800f43e:	6713      	str	r3, [r2, #112]	@ 0x70
 800f440:	4b55      	ldr	r3, [pc, #340]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f442:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f444:	4a54      	ldr	r2, [pc, #336]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f446:	f023 0304 	bic.w	r3, r3, #4
 800f44a:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 800f44c:	687b      	ldr	r3, [r7, #4]
 800f44e:	689b      	ldr	r3, [r3, #8]
 800f450:	2b00      	cmp	r3, #0
 800f452:	d015      	beq.n	800f480 <HAL_RCC_OscConfig+0x358>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800f454:	f7f9 fc16 	bl	8008c84 <HAL_GetTick>
 800f458:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800f45a:	e00a      	b.n	800f472 <HAL_RCC_OscConfig+0x34a>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800f45c:	f7f9 fc12 	bl	8008c84 <HAL_GetTick>
 800f460:	4602      	mov	r2, r0
 800f462:	693b      	ldr	r3, [r7, #16]
 800f464:	1ad3      	subs	r3, r2, r3
 800f466:	f241 3288 	movw	r2, #5000	@ 0x1388
 800f46a:	4293      	cmp	r3, r2
 800f46c:	d901      	bls.n	800f472 <HAL_RCC_OscConfig+0x34a>
        {
          return HAL_TIMEOUT;
 800f46e:	2303      	movs	r3, #3
 800f470:	e0cb      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800f472:	4b49      	ldr	r3, [pc, #292]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f474:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f476:	f003 0302 	and.w	r3, r3, #2
 800f47a:	2b00      	cmp	r3, #0
 800f47c:	d0ee      	beq.n	800f45c <HAL_RCC_OscConfig+0x334>
 800f47e:	e014      	b.n	800f4aa <HAL_RCC_OscConfig+0x382>
      }
    }
    else
    {
      /* Get Start Tick */
      tickstart = HAL_GetTick();
 800f480:	f7f9 fc00 	bl	8008c84 <HAL_GetTick>
 800f484:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800f486:	e00a      	b.n	800f49e <HAL_RCC_OscConfig+0x376>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800f488:	f7f9 fbfc 	bl	8008c84 <HAL_GetTick>
 800f48c:	4602      	mov	r2, r0
 800f48e:	693b      	ldr	r3, [r7, #16]
 800f490:	1ad3      	subs	r3, r2, r3
 800f492:	f241 3288 	movw	r2, #5000	@ 0x1388
 800f496:	4293      	cmp	r3, r2
 800f498:	d901      	bls.n	800f49e <HAL_RCC_OscConfig+0x376>
        {
          return HAL_TIMEOUT;
 800f49a:	2303      	movs	r3, #3
 800f49c:	e0b5      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800f49e:	4b3e      	ldr	r3, [pc, #248]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f4a0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800f4a2:	f003 0302 	and.w	r3, r3, #2
 800f4a6:	2b00      	cmp	r3, #0
 800f4a8:	d1ee      	bne.n	800f488 <HAL_RCC_OscConfig+0x360>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 800f4aa:	7dfb      	ldrb	r3, [r7, #23]
 800f4ac:	2b01      	cmp	r3, #1
 800f4ae:	d105      	bne.n	800f4bc <HAL_RCC_OscConfig+0x394>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800f4b0:	4b39      	ldr	r3, [pc, #228]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f4b2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800f4b4:	4a38      	ldr	r2, [pc, #224]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f4b6:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800f4ba:	6413      	str	r3, [r2, #64]	@ 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800f4bc:	687b      	ldr	r3, [r7, #4]
 800f4be:	699b      	ldr	r3, [r3, #24]
 800f4c0:	2b00      	cmp	r3, #0
 800f4c2:	f000 80a1 	beq.w	800f608 <HAL_RCC_OscConfig+0x4e0>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 800f4c6:	4b34      	ldr	r3, [pc, #208]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f4c8:	689b      	ldr	r3, [r3, #8]
 800f4ca:	f003 030c 	and.w	r3, r3, #12
 800f4ce:	2b08      	cmp	r3, #8
 800f4d0:	d05c      	beq.n	800f58c <HAL_RCC_OscConfig+0x464>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800f4d2:	687b      	ldr	r3, [r7, #4]
 800f4d4:	699b      	ldr	r3, [r3, #24]
 800f4d6:	2b02      	cmp	r3, #2
 800f4d8:	d141      	bne.n	800f55e <HAL_RCC_OscConfig+0x436>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800f4da:	4b31      	ldr	r3, [pc, #196]	@ (800f5a0 <HAL_RCC_OscConfig+0x478>)
 800f4dc:	2200      	movs	r2, #0
 800f4de:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800f4e0:	f7f9 fbd0 	bl	8008c84 <HAL_GetTick>
 800f4e4:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800f4e6:	e008      	b.n	800f4fa <HAL_RCC_OscConfig+0x3d2>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800f4e8:	f7f9 fbcc 	bl	8008c84 <HAL_GetTick>
 800f4ec:	4602      	mov	r2, r0
 800f4ee:	693b      	ldr	r3, [r7, #16]
 800f4f0:	1ad3      	subs	r3, r2, r3
 800f4f2:	2b02      	cmp	r3, #2
 800f4f4:	d901      	bls.n	800f4fa <HAL_RCC_OscConfig+0x3d2>
          {
            return HAL_TIMEOUT;
 800f4f6:	2303      	movs	r3, #3
 800f4f8:	e087      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800f4fa:	4b27      	ldr	r3, [pc, #156]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f4fc:	681b      	ldr	r3, [r3, #0]
 800f4fe:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800f502:	2b00      	cmp	r3, #0
 800f504:	d1f0      	bne.n	800f4e8 <HAL_RCC_OscConfig+0x3c0>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 800f506:	687b      	ldr	r3, [r7, #4]
 800f508:	69da      	ldr	r2, [r3, #28]
 800f50a:	687b      	ldr	r3, [r7, #4]
 800f50c:	6a1b      	ldr	r3, [r3, #32]
 800f50e:	431a      	orrs	r2, r3
 800f510:	687b      	ldr	r3, [r7, #4]
 800f512:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800f514:	019b      	lsls	r3, r3, #6
 800f516:	431a      	orrs	r2, r3
 800f518:	687b      	ldr	r3, [r7, #4]
 800f51a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f51c:	085b      	lsrs	r3, r3, #1
 800f51e:	3b01      	subs	r3, #1
 800f520:	041b      	lsls	r3, r3, #16
 800f522:	431a      	orrs	r2, r3
 800f524:	687b      	ldr	r3, [r7, #4]
 800f526:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800f528:	061b      	lsls	r3, r3, #24
 800f52a:	491b      	ldr	r1, [pc, #108]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f52c:	4313      	orrs	r3, r2
 800f52e:	604b      	str	r3, [r1, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800f530:	4b1b      	ldr	r3, [pc, #108]	@ (800f5a0 <HAL_RCC_OscConfig+0x478>)
 800f532:	2201      	movs	r2, #1
 800f534:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800f536:	f7f9 fba5 	bl	8008c84 <HAL_GetTick>
 800f53a:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800f53c:	e008      	b.n	800f550 <HAL_RCC_OscConfig+0x428>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800f53e:	f7f9 fba1 	bl	8008c84 <HAL_GetTick>
 800f542:	4602      	mov	r2, r0
 800f544:	693b      	ldr	r3, [r7, #16]
 800f546:	1ad3      	subs	r3, r2, r3
 800f548:	2b02      	cmp	r3, #2
 800f54a:	d901      	bls.n	800f550 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 800f54c:	2303      	movs	r3, #3
 800f54e:	e05c      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800f550:	4b11      	ldr	r3, [pc, #68]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f552:	681b      	ldr	r3, [r3, #0]
 800f554:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800f558:	2b00      	cmp	r3, #0
 800f55a:	d0f0      	beq.n	800f53e <HAL_RCC_OscConfig+0x416>
 800f55c:	e054      	b.n	800f608 <HAL_RCC_OscConfig+0x4e0>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800f55e:	4b10      	ldr	r3, [pc, #64]	@ (800f5a0 <HAL_RCC_OscConfig+0x478>)
 800f560:	2200      	movs	r2, #0
 800f562:	601a      	str	r2, [r3, #0]

        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800f564:	f7f9 fb8e 	bl	8008c84 <HAL_GetTick>
 800f568:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800f56a:	e008      	b.n	800f57e <HAL_RCC_OscConfig+0x456>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800f56c:	f7f9 fb8a 	bl	8008c84 <HAL_GetTick>
 800f570:	4602      	mov	r2, r0
 800f572:	693b      	ldr	r3, [r7, #16]
 800f574:	1ad3      	subs	r3, r2, r3
 800f576:	2b02      	cmp	r3, #2
 800f578:	d901      	bls.n	800f57e <HAL_RCC_OscConfig+0x456>
          {
            return HAL_TIMEOUT;
 800f57a:	2303      	movs	r3, #3
 800f57c:	e045      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800f57e:	4b06      	ldr	r3, [pc, #24]	@ (800f598 <HAL_RCC_OscConfig+0x470>)
 800f580:	681b      	ldr	r3, [r3, #0]
 800f582:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800f586:	2b00      	cmp	r3, #0
 800f588:	d1f0      	bne.n	800f56c <HAL_RCC_OscConfig+0x444>
 800f58a:	e03d      	b.n	800f608 <HAL_RCC_OscConfig+0x4e0>
      }
    }
    else
    {
      /* Check if there is a request to disable the PLL used as System clock source */
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800f58c:	687b      	ldr	r3, [r7, #4]
 800f58e:	699b      	ldr	r3, [r3, #24]
 800f590:	2b01      	cmp	r3, #1
 800f592:	d107      	bne.n	800f5a4 <HAL_RCC_OscConfig+0x47c>
      {
        return HAL_ERROR;
 800f594:	2301      	movs	r3, #1
 800f596:	e038      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
 800f598:	40023800 	.word	0x40023800
 800f59c:	40007000 	.word	0x40007000
 800f5a0:	42470060 	.word	0x42470060
      }
      else
      {
        /* Do not return HAL_ERROR if request repeats the current configuration */
        pll_config = RCC->PLLCFGR;
 800f5a4:	4b1b      	ldr	r3, [pc, #108]	@ (800f614 <HAL_RCC_OscConfig+0x4ec>)
 800f5a6:	685b      	ldr	r3, [r3, #4]
 800f5a8:	60fb      	str	r3, [r7, #12]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
#else
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800f5aa:	687b      	ldr	r3, [r7, #4]
 800f5ac:	699b      	ldr	r3, [r3, #24]
 800f5ae:	2b01      	cmp	r3, #1
 800f5b0:	d028      	beq.n	800f604 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800f5b2:	68fb      	ldr	r3, [r7, #12]
 800f5b4:	f403 0280 	and.w	r2, r3, #4194304	@ 0x400000
 800f5b8:	687b      	ldr	r3, [r7, #4]
 800f5ba:	69db      	ldr	r3, [r3, #28]
        if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800f5bc:	429a      	cmp	r2, r3
 800f5be:	d121      	bne.n	800f604 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800f5c0:	68fb      	ldr	r3, [r7, #12]
 800f5c2:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 800f5c6:	687b      	ldr	r3, [r7, #4]
 800f5c8:	6a1b      	ldr	r3, [r3, #32]
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800f5ca:	429a      	cmp	r2, r3
 800f5cc:	d11a      	bne.n	800f604 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800f5ce:	68fa      	ldr	r2, [r7, #12]
 800f5d0:	f647 73c0 	movw	r3, #32704	@ 0x7fc0
 800f5d4:	4013      	ands	r3, r2
 800f5d6:	687a      	ldr	r2, [r7, #4]
 800f5d8:	6a52      	ldr	r2, [r2, #36]	@ 0x24
 800f5da:	0192      	lsls	r2, r2, #6
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != (RCC_OscInitStruct->PLL.PLLM) << RCC_PLLCFGR_PLLM_Pos) ||
 800f5dc:	4293      	cmp	r3, r2
 800f5de:	d111      	bne.n	800f604 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 800f5e0:	68fb      	ldr	r3, [r7, #12]
 800f5e2:	f403 3240 	and.w	r2, r3, #196608	@ 0x30000
 800f5e6:	687b      	ldr	r3, [r7, #4]
 800f5e8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800f5ea:	085b      	lsrs	r3, r3, #1
 800f5ec:	3b01      	subs	r3, #1
 800f5ee:	041b      	lsls	r3, r3, #16
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos) ||
 800f5f0:	429a      	cmp	r2, r3
 800f5f2:	d107      	bne.n	800f604 <HAL_RCC_OscConfig+0x4dc>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
 800f5f4:	68fb      	ldr	r3, [r7, #12]
 800f5f6:	f003 6270 	and.w	r2, r3, #251658240	@ 0xf000000
 800f5fa:	687b      	ldr	r3, [r7, #4]
 800f5fc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800f5fe:	061b      	lsls	r3, r3, #24
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U)) << RCC_PLLCFGR_PLLP_Pos) ||
 800f600:	429a      	cmp	r2, r3
 800f602:	d001      	beq.n	800f608 <HAL_RCC_OscConfig+0x4e0>
#endif
        {
          return HAL_ERROR;
 800f604:	2301      	movs	r3, #1
 800f606:	e000      	b.n	800f60a <HAL_RCC_OscConfig+0x4e2>
        }
      }
    }
  }
  return HAL_OK;
 800f608:	2300      	movs	r3, #0
}
 800f60a:	4618      	mov	r0, r3
 800f60c:	3718      	adds	r7, #24
 800f60e:	46bd      	mov	sp, r7
 800f610:	bd80      	pop	{r7, pc}
 800f612:	bf00      	nop
 800f614:	40023800 	.word	0x40023800

0800f618 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800f618:	b580      	push	{r7, lr}
 800f61a:	b084      	sub	sp, #16
 800f61c:	af00      	add	r7, sp, #0
 800f61e:	6078      	str	r0, [r7, #4]
 800f620:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800f622:	687b      	ldr	r3, [r7, #4]
 800f624:	2b00      	cmp	r3, #0
 800f626:	d101      	bne.n	800f62c <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 800f628:	2301      	movs	r3, #1
 800f62a:	e0cc      	b.n	800f7c6 <HAL_RCC_ClockConfig+0x1ae>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800f62c:	4b68      	ldr	r3, [pc, #416]	@ (800f7d0 <HAL_RCC_ClockConfig+0x1b8>)
 800f62e:	681b      	ldr	r3, [r3, #0]
 800f630:	f003 0307 	and.w	r3, r3, #7
 800f634:	683a      	ldr	r2, [r7, #0]
 800f636:	429a      	cmp	r2, r3
 800f638:	d90c      	bls.n	800f654 <HAL_RCC_ClockConfig+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800f63a:	4b65      	ldr	r3, [pc, #404]	@ (800f7d0 <HAL_RCC_ClockConfig+0x1b8>)
 800f63c:	683a      	ldr	r2, [r7, #0]
 800f63e:	b2d2      	uxtb	r2, r2
 800f640:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800f642:	4b63      	ldr	r3, [pc, #396]	@ (800f7d0 <HAL_RCC_ClockConfig+0x1b8>)
 800f644:	681b      	ldr	r3, [r3, #0]
 800f646:	f003 0307 	and.w	r3, r3, #7
 800f64a:	683a      	ldr	r2, [r7, #0]
 800f64c:	429a      	cmp	r2, r3
 800f64e:	d001      	beq.n	800f654 <HAL_RCC_ClockConfig+0x3c>
    {
      return HAL_ERROR;
 800f650:	2301      	movs	r3, #1
 800f652:	e0b8      	b.n	800f7c6 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800f654:	687b      	ldr	r3, [r7, #4]
 800f656:	681b      	ldr	r3, [r3, #0]
 800f658:	f003 0302 	and.w	r3, r3, #2
 800f65c:	2b00      	cmp	r3, #0
 800f65e:	d020      	beq.n	800f6a2 <HAL_RCC_ClockConfig+0x8a>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800f660:	687b      	ldr	r3, [r7, #4]
 800f662:	681b      	ldr	r3, [r3, #0]
 800f664:	f003 0304 	and.w	r3, r3, #4
 800f668:	2b00      	cmp	r3, #0
 800f66a:	d005      	beq.n	800f678 <HAL_RCC_ClockConfig+0x60>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800f66c:	4b59      	ldr	r3, [pc, #356]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f66e:	689b      	ldr	r3, [r3, #8]
 800f670:	4a58      	ldr	r2, [pc, #352]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f672:	f443 53e0 	orr.w	r3, r3, #7168	@ 0x1c00
 800f676:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800f678:	687b      	ldr	r3, [r7, #4]
 800f67a:	681b      	ldr	r3, [r3, #0]
 800f67c:	f003 0308 	and.w	r3, r3, #8
 800f680:	2b00      	cmp	r3, #0
 800f682:	d005      	beq.n	800f690 <HAL_RCC_ClockConfig+0x78>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 800f684:	4b53      	ldr	r3, [pc, #332]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f686:	689b      	ldr	r3, [r3, #8]
 800f688:	4a52      	ldr	r2, [pc, #328]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f68a:	f443 4360 	orr.w	r3, r3, #57344	@ 0xe000
 800f68e:	6093      	str	r3, [r2, #8]
    }

    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800f690:	4b50      	ldr	r3, [pc, #320]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f692:	689b      	ldr	r3, [r3, #8]
 800f694:	f023 02f0 	bic.w	r2, r3, #240	@ 0xf0
 800f698:	687b      	ldr	r3, [r7, #4]
 800f69a:	689b      	ldr	r3, [r3, #8]
 800f69c:	494d      	ldr	r1, [pc, #308]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f69e:	4313      	orrs	r3, r2
 800f6a0:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800f6a2:	687b      	ldr	r3, [r7, #4]
 800f6a4:	681b      	ldr	r3, [r3, #0]
 800f6a6:	f003 0301 	and.w	r3, r3, #1
 800f6aa:	2b00      	cmp	r3, #0
 800f6ac:	d044      	beq.n	800f738 <HAL_RCC_ClockConfig+0x120>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800f6ae:	687b      	ldr	r3, [r7, #4]
 800f6b0:	685b      	ldr	r3, [r3, #4]
 800f6b2:	2b01      	cmp	r3, #1
 800f6b4:	d107      	bne.n	800f6c6 <HAL_RCC_ClockConfig+0xae>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800f6b6:	4b47      	ldr	r3, [pc, #284]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f6b8:	681b      	ldr	r3, [r3, #0]
 800f6ba:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800f6be:	2b00      	cmp	r3, #0
 800f6c0:	d119      	bne.n	800f6f6 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800f6c2:	2301      	movs	r3, #1
 800f6c4:	e07f      	b.n	800f7c6 <HAL_RCC_ClockConfig+0x1ae>
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800f6c6:	687b      	ldr	r3, [r7, #4]
 800f6c8:	685b      	ldr	r3, [r3, #4]
 800f6ca:	2b02      	cmp	r3, #2
 800f6cc:	d003      	beq.n	800f6d6 <HAL_RCC_ClockConfig+0xbe>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
 800f6ce:	687b      	ldr	r3, [r7, #4]
 800f6d0:	685b      	ldr	r3, [r3, #4]
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   ||
 800f6d2:	2b03      	cmp	r3, #3
 800f6d4:	d107      	bne.n	800f6e6 <HAL_RCC_ClockConfig+0xce>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800f6d6:	4b3f      	ldr	r3, [pc, #252]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f6d8:	681b      	ldr	r3, [r3, #0]
 800f6da:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800f6de:	2b00      	cmp	r3, #0
 800f6e0:	d109      	bne.n	800f6f6 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800f6e2:	2301      	movs	r3, #1
 800f6e4:	e06f      	b.n	800f7c6 <HAL_RCC_ClockConfig+0x1ae>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800f6e6:	4b3b      	ldr	r3, [pc, #236]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f6e8:	681b      	ldr	r3, [r3, #0]
 800f6ea:	f003 0302 	and.w	r3, r3, #2
 800f6ee:	2b00      	cmp	r3, #0
 800f6f0:	d101      	bne.n	800f6f6 <HAL_RCC_ClockConfig+0xde>
      {
        return HAL_ERROR;
 800f6f2:	2301      	movs	r3, #1
 800f6f4:	e067      	b.n	800f7c6 <HAL_RCC_ClockConfig+0x1ae>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800f6f6:	4b37      	ldr	r3, [pc, #220]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f6f8:	689b      	ldr	r3, [r3, #8]
 800f6fa:	f023 0203 	bic.w	r2, r3, #3
 800f6fe:	687b      	ldr	r3, [r7, #4]
 800f700:	685b      	ldr	r3, [r3, #4]
 800f702:	4934      	ldr	r1, [pc, #208]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f704:	4313      	orrs	r3, r2
 800f706:	608b      	str	r3, [r1, #8]

    /* Get Start Tick */
    tickstart = HAL_GetTick();
 800f708:	f7f9 fabc 	bl	8008c84 <HAL_GetTick>
 800f70c:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800f70e:	e00a      	b.n	800f726 <HAL_RCC_ClockConfig+0x10e>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800f710:	f7f9 fab8 	bl	8008c84 <HAL_GetTick>
 800f714:	4602      	mov	r2, r0
 800f716:	68fb      	ldr	r3, [r7, #12]
 800f718:	1ad3      	subs	r3, r2, r3
 800f71a:	f241 3288 	movw	r2, #5000	@ 0x1388
 800f71e:	4293      	cmp	r3, r2
 800f720:	d901      	bls.n	800f726 <HAL_RCC_ClockConfig+0x10e>
      {
        return HAL_TIMEOUT;
 800f722:	2303      	movs	r3, #3
 800f724:	e04f      	b.n	800f7c6 <HAL_RCC_ClockConfig+0x1ae>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800f726:	4b2b      	ldr	r3, [pc, #172]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f728:	689b      	ldr	r3, [r3, #8]
 800f72a:	f003 020c 	and.w	r2, r3, #12
 800f72e:	687b      	ldr	r3, [r7, #4]
 800f730:	685b      	ldr	r3, [r3, #4]
 800f732:	009b      	lsls	r3, r3, #2
 800f734:	429a      	cmp	r2, r3
 800f736:	d1eb      	bne.n	800f710 <HAL_RCC_ClockConfig+0xf8>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800f738:	4b25      	ldr	r3, [pc, #148]	@ (800f7d0 <HAL_RCC_ClockConfig+0x1b8>)
 800f73a:	681b      	ldr	r3, [r3, #0]
 800f73c:	f003 0307 	and.w	r3, r3, #7
 800f740:	683a      	ldr	r2, [r7, #0]
 800f742:	429a      	cmp	r2, r3
 800f744:	d20c      	bcs.n	800f760 <HAL_RCC_ClockConfig+0x148>
  {
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800f746:	4b22      	ldr	r3, [pc, #136]	@ (800f7d0 <HAL_RCC_ClockConfig+0x1b8>)
 800f748:	683a      	ldr	r2, [r7, #0]
 800f74a:	b2d2      	uxtb	r2, r2
 800f74c:	701a      	strb	r2, [r3, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800f74e:	4b20      	ldr	r3, [pc, #128]	@ (800f7d0 <HAL_RCC_ClockConfig+0x1b8>)
 800f750:	681b      	ldr	r3, [r3, #0]
 800f752:	f003 0307 	and.w	r3, r3, #7
 800f756:	683a      	ldr	r2, [r7, #0]
 800f758:	429a      	cmp	r2, r3
 800f75a:	d001      	beq.n	800f760 <HAL_RCC_ClockConfig+0x148>
    {
      return HAL_ERROR;
 800f75c:	2301      	movs	r3, #1
 800f75e:	e032      	b.n	800f7c6 <HAL_RCC_ClockConfig+0x1ae>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800f760:	687b      	ldr	r3, [r7, #4]
 800f762:	681b      	ldr	r3, [r3, #0]
 800f764:	f003 0304 	and.w	r3, r3, #4
 800f768:	2b00      	cmp	r3, #0
 800f76a:	d008      	beq.n	800f77e <HAL_RCC_ClockConfig+0x166>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800f76c:	4b19      	ldr	r3, [pc, #100]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f76e:	689b      	ldr	r3, [r3, #8]
 800f770:	f423 52e0 	bic.w	r2, r3, #7168	@ 0x1c00
 800f774:	687b      	ldr	r3, [r7, #4]
 800f776:	68db      	ldr	r3, [r3, #12]
 800f778:	4916      	ldr	r1, [pc, #88]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f77a:	4313      	orrs	r3, r2
 800f77c:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800f77e:	687b      	ldr	r3, [r7, #4]
 800f780:	681b      	ldr	r3, [r3, #0]
 800f782:	f003 0308 	and.w	r3, r3, #8
 800f786:	2b00      	cmp	r3, #0
 800f788:	d009      	beq.n	800f79e <HAL_RCC_ClockConfig+0x186>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800f78a:	4b12      	ldr	r3, [pc, #72]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f78c:	689b      	ldr	r3, [r3, #8]
 800f78e:	f423 4260 	bic.w	r2, r3, #57344	@ 0xe000
 800f792:	687b      	ldr	r3, [r7, #4]
 800f794:	691b      	ldr	r3, [r3, #16]
 800f796:	00db      	lsls	r3, r3, #3
 800f798:	490e      	ldr	r1, [pc, #56]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f79a:	4313      	orrs	r3, r2
 800f79c:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 800f79e:	f000 f821 	bl	800f7e4 <HAL_RCC_GetSysClockFreq>
 800f7a2:	4602      	mov	r2, r0
 800f7a4:	4b0b      	ldr	r3, [pc, #44]	@ (800f7d4 <HAL_RCC_ClockConfig+0x1bc>)
 800f7a6:	689b      	ldr	r3, [r3, #8]
 800f7a8:	091b      	lsrs	r3, r3, #4
 800f7aa:	f003 030f 	and.w	r3, r3, #15
 800f7ae:	490a      	ldr	r1, [pc, #40]	@ (800f7d8 <HAL_RCC_ClockConfig+0x1c0>)
 800f7b0:	5ccb      	ldrb	r3, [r1, r3]
 800f7b2:	fa22 f303 	lsr.w	r3, r2, r3
 800f7b6:	4a09      	ldr	r2, [pc, #36]	@ (800f7dc <HAL_RCC_ClockConfig+0x1c4>)
 800f7b8:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings */
  HAL_InitTick (uwTickPrio);
 800f7ba:	4b09      	ldr	r3, [pc, #36]	@ (800f7e0 <HAL_RCC_ClockConfig+0x1c8>)
 800f7bc:	681b      	ldr	r3, [r3, #0]
 800f7be:	4618      	mov	r0, r3
 800f7c0:	f7f9 fa1c 	bl	8008bfc <HAL_InitTick>

  return HAL_OK;
 800f7c4:	2300      	movs	r3, #0
}
 800f7c6:	4618      	mov	r0, r3
 800f7c8:	3710      	adds	r7, #16
 800f7ca:	46bd      	mov	sp, r7
 800f7cc:	bd80      	pop	{r7, pc}
 800f7ce:	bf00      	nop
 800f7d0:	40023c00 	.word	0x40023c00
 800f7d4:	40023800 	.word	0x40023800
 800f7d8:	08025024 	.word	0x08025024
 800f7dc:	20000040 	.word	0x20000040
 800f7e0:	200000a4 	.word	0x200000a4

0800f7e4 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
__weak uint32_t HAL_RCC_GetSysClockFreq(void)
{
 800f7e4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800f7e8:	b090      	sub	sp, #64	@ 0x40
 800f7ea:	af00      	add	r7, sp, #0
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
 800f7ec:	2300      	movs	r3, #0
 800f7ee:	637b      	str	r3, [r7, #52]	@ 0x34
 800f7f0:	2300      	movs	r3, #0
 800f7f2:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f7f4:	2300      	movs	r3, #0
 800f7f6:	633b      	str	r3, [r7, #48]	@ 0x30
  uint32_t sysclockfreq = 0U;
 800f7f8:	2300      	movs	r3, #0
 800f7fa:	63bb      	str	r3, [r7, #56]	@ 0x38

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800f7fc:	4b59      	ldr	r3, [pc, #356]	@ (800f964 <HAL_RCC_GetSysClockFreq+0x180>)
 800f7fe:	689b      	ldr	r3, [r3, #8]
 800f800:	f003 030c 	and.w	r3, r3, #12
 800f804:	2b08      	cmp	r3, #8
 800f806:	d00d      	beq.n	800f824 <HAL_RCC_GetSysClockFreq+0x40>
 800f808:	2b08      	cmp	r3, #8
 800f80a:	f200 80a1 	bhi.w	800f950 <HAL_RCC_GetSysClockFreq+0x16c>
 800f80e:	2b00      	cmp	r3, #0
 800f810:	d002      	beq.n	800f818 <HAL_RCC_GetSysClockFreq+0x34>
 800f812:	2b04      	cmp	r3, #4
 800f814:	d003      	beq.n	800f81e <HAL_RCC_GetSysClockFreq+0x3a>
 800f816:	e09b      	b.n	800f950 <HAL_RCC_GetSysClockFreq+0x16c>
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 800f818:	4b53      	ldr	r3, [pc, #332]	@ (800f968 <HAL_RCC_GetSysClockFreq+0x184>)
 800f81a:	63bb      	str	r3, [r7, #56]	@ 0x38
       break;
 800f81c:	e09b      	b.n	800f956 <HAL_RCC_GetSysClockFreq+0x172>
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800f81e:	4b53      	ldr	r3, [pc, #332]	@ (800f96c <HAL_RCC_GetSysClockFreq+0x188>)
 800f820:	63bb      	str	r3, [r7, #56]	@ 0x38
      break;
 800f822:	e098      	b.n	800f956 <HAL_RCC_GetSysClockFreq+0x172>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800f824:	4b4f      	ldr	r3, [pc, #316]	@ (800f964 <HAL_RCC_GetSysClockFreq+0x180>)
 800f826:	685b      	ldr	r3, [r3, #4]
 800f828:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800f82c:	637b      	str	r3, [r7, #52]	@ 0x34
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 800f82e:	4b4d      	ldr	r3, [pc, #308]	@ (800f964 <HAL_RCC_GetSysClockFreq+0x180>)
 800f830:	685b      	ldr	r3, [r3, #4]
 800f832:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800f836:	2b00      	cmp	r3, #0
 800f838:	d028      	beq.n	800f88c <HAL_RCC_GetSysClockFreq+0xa8>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800f83a:	4b4a      	ldr	r3, [pc, #296]	@ (800f964 <HAL_RCC_GetSysClockFreq+0x180>)
 800f83c:	685b      	ldr	r3, [r3, #4]
 800f83e:	099b      	lsrs	r3, r3, #6
 800f840:	2200      	movs	r2, #0
 800f842:	623b      	str	r3, [r7, #32]
 800f844:	627a      	str	r2, [r7, #36]	@ 0x24
 800f846:	6a3b      	ldr	r3, [r7, #32]
 800f848:	f3c3 0008 	ubfx	r0, r3, #0, #9
 800f84c:	2100      	movs	r1, #0
 800f84e:	4b47      	ldr	r3, [pc, #284]	@ (800f96c <HAL_RCC_GetSysClockFreq+0x188>)
 800f850:	fb03 f201 	mul.w	r2, r3, r1
 800f854:	2300      	movs	r3, #0
 800f856:	fb00 f303 	mul.w	r3, r0, r3
 800f85a:	4413      	add	r3, r2
 800f85c:	4a43      	ldr	r2, [pc, #268]	@ (800f96c <HAL_RCC_GetSysClockFreq+0x188>)
 800f85e:	fba0 1202 	umull	r1, r2, r0, r2
 800f862:	62fa      	str	r2, [r7, #44]	@ 0x2c
 800f864:	460a      	mov	r2, r1
 800f866:	62ba      	str	r2, [r7, #40]	@ 0x28
 800f868:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f86a:	4413      	add	r3, r2
 800f86c:	62fb      	str	r3, [r7, #44]	@ 0x2c
 800f86e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f870:	2200      	movs	r2, #0
 800f872:	61bb      	str	r3, [r7, #24]
 800f874:	61fa      	str	r2, [r7, #28]
 800f876:	e9d7 2306 	ldrd	r2, r3, [r7, #24]
 800f87a:	e9d7 010a 	ldrd	r0, r1, [r7, #40]	@ 0x28
 800f87e:	f7f1 fa4b 	bl	8000d18 <__aeabi_uldivmod>
 800f882:	4602      	mov	r2, r0
 800f884:	460b      	mov	r3, r1
 800f886:	4613      	mov	r3, r2
 800f888:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800f88a:	e053      	b.n	800f934 <HAL_RCC_GetSysClockFreq+0x150>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 800f88c:	4b35      	ldr	r3, [pc, #212]	@ (800f964 <HAL_RCC_GetSysClockFreq+0x180>)
 800f88e:	685b      	ldr	r3, [r3, #4]
 800f890:	099b      	lsrs	r3, r3, #6
 800f892:	2200      	movs	r2, #0
 800f894:	613b      	str	r3, [r7, #16]
 800f896:	617a      	str	r2, [r7, #20]
 800f898:	693b      	ldr	r3, [r7, #16]
 800f89a:	f3c3 0a08 	ubfx	sl, r3, #0, #9
 800f89e:	f04f 0b00 	mov.w	fp, #0
 800f8a2:	4652      	mov	r2, sl
 800f8a4:	465b      	mov	r3, fp
 800f8a6:	f04f 0000 	mov.w	r0, #0
 800f8aa:	f04f 0100 	mov.w	r1, #0
 800f8ae:	0159      	lsls	r1, r3, #5
 800f8b0:	ea41 61d2 	orr.w	r1, r1, r2, lsr #27
 800f8b4:	0150      	lsls	r0, r2, #5
 800f8b6:	4602      	mov	r2, r0
 800f8b8:	460b      	mov	r3, r1
 800f8ba:	ebb2 080a 	subs.w	r8, r2, sl
 800f8be:	eb63 090b 	sbc.w	r9, r3, fp
 800f8c2:	f04f 0200 	mov.w	r2, #0
 800f8c6:	f04f 0300 	mov.w	r3, #0
 800f8ca:	ea4f 1389 	mov.w	r3, r9, lsl #6
 800f8ce:	ea43 6398 	orr.w	r3, r3, r8, lsr #26
 800f8d2:	ea4f 1288 	mov.w	r2, r8, lsl #6
 800f8d6:	ebb2 0408 	subs.w	r4, r2, r8
 800f8da:	eb63 0509 	sbc.w	r5, r3, r9
 800f8de:	f04f 0200 	mov.w	r2, #0
 800f8e2:	f04f 0300 	mov.w	r3, #0
 800f8e6:	00eb      	lsls	r3, r5, #3
 800f8e8:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 800f8ec:	00e2      	lsls	r2, r4, #3
 800f8ee:	4614      	mov	r4, r2
 800f8f0:	461d      	mov	r5, r3
 800f8f2:	eb14 030a 	adds.w	r3, r4, sl
 800f8f6:	603b      	str	r3, [r7, #0]
 800f8f8:	eb45 030b 	adc.w	r3, r5, fp
 800f8fc:	607b      	str	r3, [r7, #4]
 800f8fe:	f04f 0200 	mov.w	r2, #0
 800f902:	f04f 0300 	mov.w	r3, #0
 800f906:	e9d7 4500 	ldrd	r4, r5, [r7]
 800f90a:	4629      	mov	r1, r5
 800f90c:	028b      	lsls	r3, r1, #10
 800f90e:	4621      	mov	r1, r4
 800f910:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
 800f914:	4621      	mov	r1, r4
 800f916:	028a      	lsls	r2, r1, #10
 800f918:	4610      	mov	r0, r2
 800f91a:	4619      	mov	r1, r3
 800f91c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800f91e:	2200      	movs	r2, #0
 800f920:	60bb      	str	r3, [r7, #8]
 800f922:	60fa      	str	r2, [r7, #12]
 800f924:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 800f928:	f7f1 f9f6 	bl	8000d18 <__aeabi_uldivmod>
 800f92c:	4602      	mov	r2, r0
 800f92e:	460b      	mov	r3, r1
 800f930:	4613      	mov	r3, r2
 800f932:	63fb      	str	r3, [r7, #60]	@ 0x3c
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) *2U);
 800f934:	4b0b      	ldr	r3, [pc, #44]	@ (800f964 <HAL_RCC_GetSysClockFreq+0x180>)
 800f936:	685b      	ldr	r3, [r3, #4]
 800f938:	0c1b      	lsrs	r3, r3, #16
 800f93a:	f003 0303 	and.w	r3, r3, #3
 800f93e:	3301      	adds	r3, #1
 800f940:	005b      	lsls	r3, r3, #1
 800f942:	633b      	str	r3, [r7, #48]	@ 0x30

      sysclockfreq = pllvco/pllp;
 800f944:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 800f946:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800f948:	fbb2 f3f3 	udiv	r3, r2, r3
 800f94c:	63bb      	str	r3, [r7, #56]	@ 0x38
      break;
 800f94e:	e002      	b.n	800f956 <HAL_RCC_GetSysClockFreq+0x172>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 800f950:	4b05      	ldr	r3, [pc, #20]	@ (800f968 <HAL_RCC_GetSysClockFreq+0x184>)
 800f952:	63bb      	str	r3, [r7, #56]	@ 0x38
      break;
 800f954:	bf00      	nop
    }
  }
  return sysclockfreq;
 800f956:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
}
 800f958:	4618      	mov	r0, r3
 800f95a:	3740      	adds	r7, #64	@ 0x40
 800f95c:	46bd      	mov	sp, r7
 800f95e:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800f962:	bf00      	nop
 800f964:	40023800 	.word	0x40023800
 800f968:	00f42400 	.word	0x00f42400
 800f96c:	017d7840 	.word	0x017d7840

0800f970 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 800f970:	b480      	push	{r7}
 800f972:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 800f974:	4b03      	ldr	r3, [pc, #12]	@ (800f984 <HAL_RCC_GetHCLKFreq+0x14>)
 800f976:	681b      	ldr	r3, [r3, #0]
}
 800f978:	4618      	mov	r0, r3
 800f97a:	46bd      	mov	sp, r7
 800f97c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f980:	4770      	bx	lr
 800f982:	bf00      	nop
 800f984:	20000040 	.word	0x20000040

0800f988 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 800f988:	b580      	push	{r7, lr}
 800f98a:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 800f98c:	f7ff fff0 	bl	800f970 <HAL_RCC_GetHCLKFreq>
 800f990:	4602      	mov	r2, r0
 800f992:	4b05      	ldr	r3, [pc, #20]	@ (800f9a8 <HAL_RCC_GetPCLK1Freq+0x20>)
 800f994:	689b      	ldr	r3, [r3, #8]
 800f996:	0a9b      	lsrs	r3, r3, #10
 800f998:	f003 0307 	and.w	r3, r3, #7
 800f99c:	4903      	ldr	r1, [pc, #12]	@ (800f9ac <HAL_RCC_GetPCLK1Freq+0x24>)
 800f99e:	5ccb      	ldrb	r3, [r1, r3]
 800f9a0:	fa22 f303 	lsr.w	r3, r2, r3
}
 800f9a4:	4618      	mov	r0, r3
 800f9a6:	bd80      	pop	{r7, pc}
 800f9a8:	40023800 	.word	0x40023800
 800f9ac:	08025034 	.word	0x08025034

0800f9b0 <HAL_RCCEx_PeriphCLKConfig>:
  *        domain (RTC and RCC_BDCR register expect BKPSRAM) will be reset
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800f9b0:	b580      	push	{r7, lr}
 800f9b2:	b086      	sub	sp, #24
 800f9b4:	af00      	add	r7, sp, #0
 800f9b6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0U;
 800f9b8:	2300      	movs	r3, #0
 800f9ba:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg1 = 0U;
 800f9bc:	2300      	movs	r3, #0
 800f9be:	613b      	str	r3, [r7, #16]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- I2S configuration ---------------------------*/
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 800f9c0:	687b      	ldr	r3, [r7, #4]
 800f9c2:	681b      	ldr	r3, [r3, #0]
 800f9c4:	f003 0301 	and.w	r3, r3, #1
 800f9c8:	2b00      	cmp	r3, #0
 800f9ca:	d105      	bne.n	800f9d8 <HAL_RCCEx_PeriphCLKConfig+0x28>
     (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
 800f9cc:	687b      	ldr	r3, [r7, #4]
 800f9ce:	681b      	ldr	r3, [r3, #0]
 800f9d0:	f003 0304 	and.w	r3, r3, #4
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
 800f9d4:	2b00      	cmp	r3, #0
 800f9d6:	d038      	beq.n	800fa4a <HAL_RCCEx_PeriphCLKConfig+0x9a>
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
#if defined(STM32F411xE)
    assert_param(IS_RCC_PLLI2SM_VALUE(PeriphClkInit->PLLI2S.PLLI2SM));
#endif /* STM32F411xE */
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 800f9d8:	4b68      	ldr	r3, [pc, #416]	@ (800fb7c <HAL_RCCEx_PeriphCLKConfig+0x1cc>)
 800f9da:	2200      	movs	r2, #0
 800f9dc:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 800f9de:	f7f9 f951 	bl	8008c84 <HAL_GetTick>
 800f9e2:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800f9e4:	e008      	b.n	800f9f8 <HAL_RCCEx_PeriphCLKConfig+0x48>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800f9e6:	f7f9 f94d 	bl	8008c84 <HAL_GetTick>
 800f9ea:	4602      	mov	r2, r0
 800f9ec:	697b      	ldr	r3, [r7, #20]
 800f9ee:	1ad3      	subs	r3, r2, r3
 800f9f0:	2b02      	cmp	r3, #2
 800f9f2:	d901      	bls.n	800f9f8 <HAL_RCCEx_PeriphCLKConfig+0x48>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800f9f4:	2303      	movs	r3, #3
 800f9f6:	e0bd      	b.n	800fb74 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 800f9f8:	4b61      	ldr	r3, [pc, #388]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800f9fa:	681b      	ldr	r3, [r3, #0]
 800f9fc:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800fa00:	2b00      	cmp	r3, #0
 800fa02:	d1f0      	bne.n	800f9e6 <HAL_RCCEx_PeriphCLKConfig+0x36>

#if defined(STM32F411xE)
    /* Configure the PLLI2S division factors */
    /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SM, PeriphClkInit->PLLI2S.PLLI2SN, PeriphClkInit->PLLI2S.PLLI2SR);
 800fa04:	687b      	ldr	r3, [r7, #4]
 800fa06:	685a      	ldr	r2, [r3, #4]
 800fa08:	687b      	ldr	r3, [r7, #4]
 800fa0a:	689b      	ldr	r3, [r3, #8]
 800fa0c:	019b      	lsls	r3, r3, #6
 800fa0e:	431a      	orrs	r2, r3
 800fa10:	687b      	ldr	r3, [r7, #4]
 800fa12:	68db      	ldr	r3, [r3, #12]
 800fa14:	071b      	lsls	r3, r3, #28
 800fa16:	495a      	ldr	r1, [pc, #360]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fa18:	4313      	orrs	r3, r2
 800fa1a:	f8c1 3084 	str.w	r3, [r1, #132]	@ 0x84
    /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
    __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
#endif /* STM32F411xE */

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 800fa1e:	4b57      	ldr	r3, [pc, #348]	@ (800fb7c <HAL_RCCEx_PeriphCLKConfig+0x1cc>)
 800fa20:	2201      	movs	r2, #1
 800fa22:	601a      	str	r2, [r3, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 800fa24:	f7f9 f92e 	bl	8008c84 <HAL_GetTick>
 800fa28:	6178      	str	r0, [r7, #20]
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800fa2a:	e008      	b.n	800fa3e <HAL_RCCEx_PeriphCLKConfig+0x8e>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 800fa2c:	f7f9 f92a 	bl	8008c84 <HAL_GetTick>
 800fa30:	4602      	mov	r2, r0
 800fa32:	697b      	ldr	r3, [r7, #20]
 800fa34:	1ad3      	subs	r3, r2, r3
 800fa36:	2b02      	cmp	r3, #2
 800fa38:	d901      	bls.n	800fa3e <HAL_RCCEx_PeriphCLKConfig+0x8e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800fa3a:	2303      	movs	r3, #3
 800fa3c:	e09a      	b.n	800fb74 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800fa3e:	4b50      	ldr	r3, [pc, #320]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fa40:	681b      	ldr	r3, [r3, #0]
 800fa42:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800fa46:	2b00      	cmp	r3, #0
 800fa48:	d0f0      	beq.n	800fa2c <HAL_RCCEx_PeriphCLKConfig+0x7c>
      }
    }
  }

  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800fa4a:	687b      	ldr	r3, [r7, #4]
 800fa4c:	681b      	ldr	r3, [r3, #0]
 800fa4e:	f003 0302 	and.w	r3, r3, #2
 800fa52:	2b00      	cmp	r3, #0
 800fa54:	f000 8083 	beq.w	800fb5e <HAL_RCCEx_PeriphCLKConfig+0x1ae>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800fa58:	2300      	movs	r3, #0
 800fa5a:	60fb      	str	r3, [r7, #12]
 800fa5c:	4b48      	ldr	r3, [pc, #288]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fa5e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fa60:	4a47      	ldr	r2, [pc, #284]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fa62:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800fa66:	6413      	str	r3, [r2, #64]	@ 0x40
 800fa68:	4b45      	ldr	r3, [pc, #276]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fa6a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fa6c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 800fa70:	60fb      	str	r3, [r7, #12]
 800fa72:	68fb      	ldr	r3, [r7, #12]

    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 800fa74:	4b43      	ldr	r3, [pc, #268]	@ (800fb84 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800fa76:	681b      	ldr	r3, [r3, #0]
 800fa78:	4a42      	ldr	r2, [pc, #264]	@ (800fb84 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800fa7a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800fa7e:	6013      	str	r3, [r2, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 800fa80:	f7f9 f900 	bl	8008c84 <HAL_GetTick>
 800fa84:	6178      	str	r0, [r7, #20]

    while((PWR->CR & PWR_CR_DBP) == RESET)
 800fa86:	e008      	b.n	800fa9a <HAL_RCCEx_PeriphCLKConfig+0xea>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800fa88:	f7f9 f8fc 	bl	8008c84 <HAL_GetTick>
 800fa8c:	4602      	mov	r2, r0
 800fa8e:	697b      	ldr	r3, [r7, #20]
 800fa90:	1ad3      	subs	r3, r2, r3
 800fa92:	2b02      	cmp	r3, #2
 800fa94:	d901      	bls.n	800fa9a <HAL_RCCEx_PeriphCLKConfig+0xea>
      {
        return HAL_TIMEOUT;
 800fa96:	2303      	movs	r3, #3
 800fa98:	e06c      	b.n	800fb74 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800fa9a:	4b3a      	ldr	r3, [pc, #232]	@ (800fb84 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 800fa9c:	681b      	ldr	r3, [r3, #0]
 800fa9e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800faa2:	2b00      	cmp	r3, #0
 800faa4:	d0f0      	beq.n	800fa88 <HAL_RCCEx_PeriphCLKConfig+0xd8>
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800faa6:	4b36      	ldr	r3, [pc, #216]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800faa8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800faaa:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800faae:	613b      	str	r3, [r7, #16]
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800fab0:	693b      	ldr	r3, [r7, #16]
 800fab2:	2b00      	cmp	r3, #0
 800fab4:	d02f      	beq.n	800fb16 <HAL_RCCEx_PeriphCLKConfig+0x166>
 800fab6:	687b      	ldr	r3, [r7, #4]
 800fab8:	691b      	ldr	r3, [r3, #16]
 800faba:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800fabe:	693a      	ldr	r2, [r7, #16]
 800fac0:	429a      	cmp	r2, r3
 800fac2:	d028      	beq.n	800fb16 <HAL_RCCEx_PeriphCLKConfig+0x166>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800fac4:	4b2e      	ldr	r3, [pc, #184]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fac6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800fac8:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800facc:	613b      	str	r3, [r7, #16]
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 800face:	4b2e      	ldr	r3, [pc, #184]	@ (800fb88 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 800fad0:	2201      	movs	r2, #1
 800fad2:	601a      	str	r2, [r3, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 800fad4:	4b2c      	ldr	r3, [pc, #176]	@ (800fb88 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 800fad6:	2200      	movs	r2, #0
 800fad8:	601a      	str	r2, [r3, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 800fada:	4a29      	ldr	r2, [pc, #164]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fadc:	693b      	ldr	r3, [r7, #16]
 800fade:	6713      	str	r3, [r2, #112]	@ 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 800fae0:	4b27      	ldr	r3, [pc, #156]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fae2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800fae4:	f003 0301 	and.w	r3, r3, #1
 800fae8:	2b01      	cmp	r3, #1
 800faea:	d114      	bne.n	800fb16 <HAL_RCCEx_PeriphCLKConfig+0x166>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 800faec:	f7f9 f8ca 	bl	8008c84 <HAL_GetTick>
 800faf0:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800faf2:	e00a      	b.n	800fb0a <HAL_RCCEx_PeriphCLKConfig+0x15a>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800faf4:	f7f9 f8c6 	bl	8008c84 <HAL_GetTick>
 800faf8:	4602      	mov	r2, r0
 800fafa:	697b      	ldr	r3, [r7, #20]
 800fafc:	1ad3      	subs	r3, r2, r3
 800fafe:	f241 3288 	movw	r2, #5000	@ 0x1388
 800fb02:	4293      	cmp	r3, r2
 800fb04:	d901      	bls.n	800fb0a <HAL_RCCEx_PeriphCLKConfig+0x15a>
          {
            return HAL_TIMEOUT;
 800fb06:	2303      	movs	r3, #3
 800fb08:	e034      	b.n	800fb74 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800fb0a:	4b1d      	ldr	r3, [pc, #116]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fb0c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800fb0e:	f003 0302 	and.w	r3, r3, #2
 800fb12:	2b00      	cmp	r3, #0
 800fb14:	d0ee      	beq.n	800faf4 <HAL_RCCEx_PeriphCLKConfig+0x144>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800fb16:	687b      	ldr	r3, [r7, #4]
 800fb18:	691b      	ldr	r3, [r3, #16]
 800fb1a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800fb1e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800fb22:	d10d      	bne.n	800fb40 <HAL_RCCEx_PeriphCLKConfig+0x190>
 800fb24:	4b16      	ldr	r3, [pc, #88]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fb26:	689b      	ldr	r3, [r3, #8]
 800fb28:	f423 12f8 	bic.w	r2, r3, #2031616	@ 0x1f0000
 800fb2c:	687b      	ldr	r3, [r7, #4]
 800fb2e:	691b      	ldr	r3, [r3, #16]
 800fb30:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 800fb34:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800fb38:	4911      	ldr	r1, [pc, #68]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fb3a:	4313      	orrs	r3, r2
 800fb3c:	608b      	str	r3, [r1, #8]
 800fb3e:	e005      	b.n	800fb4c <HAL_RCCEx_PeriphCLKConfig+0x19c>
 800fb40:	4b0f      	ldr	r3, [pc, #60]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fb42:	689b      	ldr	r3, [r3, #8]
 800fb44:	4a0e      	ldr	r2, [pc, #56]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fb46:	f423 13f8 	bic.w	r3, r3, #2031616	@ 0x1f0000
 800fb4a:	6093      	str	r3, [r2, #8]
 800fb4c:	4b0c      	ldr	r3, [pc, #48]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fb4e:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 800fb50:	687b      	ldr	r3, [r7, #4]
 800fb52:	691b      	ldr	r3, [r3, #16]
 800fb54:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800fb58:	4909      	ldr	r1, [pc, #36]	@ (800fb80 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 800fb5a:	4313      	orrs	r3, r2
 800fb5c:	670b      	str	r3, [r1, #112]	@ 0x70
  }
#if defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 800fb5e:	687b      	ldr	r3, [r7, #4]
 800fb60:	681b      	ldr	r3, [r3, #0]
 800fb62:	f003 0308 	and.w	r3, r3, #8
 800fb66:	2b00      	cmp	r3, #0
 800fb68:	d003      	beq.n	800fb72 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800fb6a:	687b      	ldr	r3, [r7, #4]
 800fb6c:	7d1a      	ldrb	r2, [r3, #20]
 800fb6e:	4b07      	ldr	r3, [pc, #28]	@ (800fb8c <HAL_RCCEx_PeriphCLKConfig+0x1dc>)
 800fb70:	601a      	str	r2, [r3, #0]
  }
#endif /* STM32F401xC || STM32F401xE || STM32F411xE */
  return HAL_OK;
 800fb72:	2300      	movs	r3, #0
}
 800fb74:	4618      	mov	r0, r3
 800fb76:	3718      	adds	r7, #24
 800fb78:	46bd      	mov	sp, r7
 800fb7a:	bd80      	pop	{r7, pc}
 800fb7c:	42470068 	.word	0x42470068
 800fb80:	40023800 	.word	0x40023800
 800fb84:	40007000 	.word	0x40007000
 800fb88:	42470e40 	.word	0x42470e40
 800fb8c:	424711e0 	.word	0x424711e0

0800fb90 <HAL_RCCEx_GetPeriphCLKFreq>:
  *         This parameter can be one of the following values:
  *            @arg RCC_PERIPHCLK_I2S: I2S peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 800fb90:	b480      	push	{r7}
 800fb92:	b087      	sub	sp, #28
 800fb94:	af00      	add	r7, sp, #0
 800fb96:	6078      	str	r0, [r7, #4]
  /* This variable used to store the I2S clock frequency (value in Hz) */
  uint32_t frequency = 0U;
 800fb98:	2300      	movs	r3, #0
 800fb9a:	617b      	str	r3, [r7, #20]
  /* This variable used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0U;
 800fb9c:	2300      	movs	r3, #0
 800fb9e:	613b      	str	r3, [r7, #16]
  uint32_t srcclk = 0U;
 800fba0:	2300      	movs	r3, #0
 800fba2:	60fb      	str	r3, [r7, #12]
  /* This variable used to store the VCO Output (value in Hz) */
  uint32_t vcooutput = 0U;
 800fba4:	2300      	movs	r3, #0
 800fba6:	60bb      	str	r3, [r7, #8]
  switch (PeriphClk)
 800fba8:	687b      	ldr	r3, [r7, #4]
 800fbaa:	2b01      	cmp	r3, #1
 800fbac:	d141      	bne.n	800fc32 <HAL_RCCEx_GetPeriphCLKFreq+0xa2>
  {
  case RCC_PERIPHCLK_I2S:
    {
      /* Get the current I2S source */
      srcclk = __HAL_RCC_GET_I2S_SOURCE();
 800fbae:	4b25      	ldr	r3, [pc, #148]	@ (800fc44 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 800fbb0:	689b      	ldr	r3, [r3, #8]
 800fbb2:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800fbb6:	60fb      	str	r3, [r7, #12]
 800fbb8:	68fb      	ldr	r3, [r7, #12]
 800fbba:	2b00      	cmp	r3, #0
 800fbbc:	d006      	beq.n	800fbcc <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
 800fbbe:	68fb      	ldr	r3, [r7, #12]
 800fbc0:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800fbc4:	d131      	bne.n	800fc2a <HAL_RCCEx_GetPeriphCLKFreq+0x9a>
      {
      /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
      case RCC_I2SCLKSOURCE_EXT:
        {
          /* Set the I2S clock to the external clock  value */
          frequency = EXTERNAL_CLOCK_VALUE;
 800fbc6:	4b20      	ldr	r3, [pc, #128]	@ (800fc48 <HAL_RCCEx_GetPeriphCLKFreq+0xb8>)
 800fbc8:	617b      	str	r3, [r7, #20]
          break;
 800fbca:	e031      	b.n	800fc30 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
      case RCC_I2SCLKSOURCE_PLLI2S:
        {
#if defined(STM32F411xE)
          /* Configure the PLLI2S division factor */
          /* PLLI2S_VCO Input  = PLL_SOURCE/PLLI2SM */
          if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 800fbcc:	4b1d      	ldr	r3, [pc, #116]	@ (800fc44 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 800fbce:	685b      	ldr	r3, [r3, #4]
 800fbd0:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 800fbd4:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800fbd8:	d109      	bne.n	800fbee <HAL_RCCEx_GetPeriphCLKFreq+0x5e>
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
 800fbda:	4b1a      	ldr	r3, [pc, #104]	@ (800fc44 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 800fbdc:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800fbe0:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800fbe4:	4a19      	ldr	r2, [pc, #100]	@ (800fc4c <HAL_RCCEx_GetPeriphCLKFreq+0xbc>)
 800fbe6:	fbb2 f3f3 	udiv	r3, r2, r3
 800fbea:	613b      	str	r3, [r7, #16]
 800fbec:	e008      	b.n	800fc00 <HAL_RCCEx_GetPeriphCLKFreq+0x70>
          }
          else
          {
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SM));
 800fbee:	4b15      	ldr	r3, [pc, #84]	@ (800fc44 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 800fbf0:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800fbf4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800fbf8:	4a15      	ldr	r2, [pc, #84]	@ (800fc50 <HAL_RCCEx_GetPeriphCLKFreq+0xc0>)
 800fbfa:	fbb2 f3f3 	udiv	r3, r2, r3
 800fbfe:	613b      	str	r3, [r7, #16]
            /* Get the I2S source clock value */
            vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
          }
#endif /* STM32F411xE */
          /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
          vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
 800fc00:	4b10      	ldr	r3, [pc, #64]	@ (800fc44 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 800fc02:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800fc06:	099b      	lsrs	r3, r3, #6
 800fc08:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800fc0c:	693b      	ldr	r3, [r7, #16]
 800fc0e:	fb02 f303 	mul.w	r3, r2, r3
 800fc12:	60bb      	str	r3, [r7, #8]
          /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
          frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
 800fc14:	4b0b      	ldr	r3, [pc, #44]	@ (800fc44 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>)
 800fc16:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 800fc1a:	0f1b      	lsrs	r3, r3, #28
 800fc1c:	f003 0307 	and.w	r3, r3, #7
 800fc20:	68ba      	ldr	r2, [r7, #8]
 800fc22:	fbb2 f3f3 	udiv	r3, r2, r3
 800fc26:	617b      	str	r3, [r7, #20]
          break;
 800fc28:	e002      	b.n	800fc30 <HAL_RCCEx_GetPeriphCLKFreq+0xa0>
        }
        /* Clock not enabled for I2S*/
      default:
        {
          frequency = 0U;
 800fc2a:	2300      	movs	r3, #0
 800fc2c:	617b      	str	r3, [r7, #20]
          break;
 800fc2e:	bf00      	nop
        }
      }
      break;
 800fc30:	e000      	b.n	800fc34 <HAL_RCCEx_GetPeriphCLKFreq+0xa4>
    }
  default:
    {
       break;
 800fc32:	bf00      	nop
    }
  }
  return frequency;
 800fc34:	697b      	ldr	r3, [r7, #20]
}
 800fc36:	4618      	mov	r0, r3
 800fc38:	371c      	adds	r7, #28
 800fc3a:	46bd      	mov	sp, r7
 800fc3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fc40:	4770      	bx	lr
 800fc42:	bf00      	nop
 800fc44:	40023800 	.word	0x40023800
 800fc48:	00bb8000 	.word	0x00bb8000
 800fc4c:	017d7840 	.word	0x017d7840
 800fc50:	00f42400 	.word	0x00f42400

0800fc54 <HAL_SD_Init>:
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd: Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
 800fc54:	b580      	push	{r7, lr}
 800fc56:	b082      	sub	sp, #8
 800fc58:	af00      	add	r7, sp, #0
 800fc5a:	6078      	str	r0, [r7, #4]
  /* Check the SD handle allocation */
  if(hsd == NULL)
 800fc5c:	687b      	ldr	r3, [r7, #4]
 800fc5e:	2b00      	cmp	r3, #0
 800fc60:	d101      	bne.n	800fc66 <HAL_SD_Init+0x12>
  {
    return HAL_ERROR;
 800fc62:	2301      	movs	r3, #1
 800fc64:	e022      	b.n	800fcac <HAL_SD_Init+0x58>
  assert_param(IS_SDIO_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
  assert_param(IS_SDIO_BUS_WIDE(hsd->Init.BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
  assert_param(IS_SDIO_CLKDIV(hsd->Init.ClockDiv));

  if(hsd->State == HAL_SD_STATE_RESET)
 800fc66:	687b      	ldr	r3, [r7, #4]
 800fc68:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800fc6c:	b2db      	uxtb	r3, r3
 800fc6e:	2b00      	cmp	r3, #0
 800fc70:	d105      	bne.n	800fc7e <HAL_SD_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
 800fc72:	687b      	ldr	r3, [r7, #4]
 800fc74:	2200      	movs	r2, #0
 800fc76:	771a      	strb	r2, [r3, #28]

    /* Init the low level hardware */
    hsd->MspInitCallback(hsd);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SD_MspInit(hsd);
 800fc78:	6878      	ldr	r0, [r7, #4]
 800fc7a:	f7f8 f973 	bl	8007f64 <HAL_SD_MspInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }

  hsd->State = HAL_SD_STATE_BUSY;
 800fc7e:	687b      	ldr	r3, [r7, #4]
 800fc80:	2203      	movs	r2, #3
 800fc82:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  /* Initialize the Card parameters */
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800fc86:	6878      	ldr	r0, [r7, #4]
 800fc88:	f000 f814 	bl	800fcb4 <HAL_SD_InitCard>
 800fc8c:	4603      	mov	r3, r0
 800fc8e:	2b00      	cmp	r3, #0
 800fc90:	d001      	beq.n	800fc96 <HAL_SD_Init+0x42>
  {
    return HAL_ERROR;
 800fc92:	2301      	movs	r3, #1
 800fc94:	e00a      	b.n	800fcac <HAL_SD_Init+0x58>
  }

  /* Initialize the error code */
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800fc96:	687b      	ldr	r3, [r7, #4]
 800fc98:	2200      	movs	r2, #0
 800fc9a:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Initialize the SD operation */
  hsd->Context = SD_CONTEXT_NONE;
 800fc9c:	687b      	ldr	r3, [r7, #4]
 800fc9e:	2200      	movs	r2, #0
 800fca0:	631a      	str	r2, [r3, #48]	@ 0x30

  /* Initialize the SD state */
  hsd->State = HAL_SD_STATE_READY;
 800fca2:	687b      	ldr	r3, [r7, #4]
 800fca4:	2201      	movs	r2, #1
 800fca6:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  return HAL_OK;
 800fcaa:	2300      	movs	r3, #0
}
 800fcac:	4618      	mov	r0, r3
 800fcae:	3708      	adds	r7, #8
 800fcb0:	46bd      	mov	sp, r7
 800fcb2:	bd80      	pop	{r7, pc}

0800fcb4 <HAL_SD_InitCard>:
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
 800fcb4:	b5b0      	push	{r4, r5, r7, lr}
 800fcb6:	b08e      	sub	sp, #56	@ 0x38
 800fcb8:	af04      	add	r7, sp, #16
 800fcba:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  HAL_StatusTypeDef status;
  SD_InitTypeDef Init;
  
  /* Default SDIO peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
 800fcbc:	2300      	movs	r3, #0
 800fcbe:	60bb      	str	r3, [r7, #8]
  Init.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
 800fcc0:	2300      	movs	r3, #0
 800fcc2:	60fb      	str	r3, [r7, #12]
  Init.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
 800fcc4:	2300      	movs	r3, #0
 800fcc6:	613b      	str	r3, [r7, #16]
  Init.BusWide             = SDIO_BUS_WIDE_1B;
 800fcc8:	2300      	movs	r3, #0
 800fcca:	617b      	str	r3, [r7, #20]
  Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
 800fccc:	2300      	movs	r3, #0
 800fcce:	61bb      	str	r3, [r7, #24]
  Init.ClockDiv            = SDIO_INIT_CLK_DIV;
 800fcd0:	2376      	movs	r3, #118	@ 0x76
 800fcd2:	61fb      	str	r3, [r7, #28]

  /* Initialize SDIO peripheral interface with default configuration */
  status = SDIO_Init(hsd->Instance, Init);
 800fcd4:	687b      	ldr	r3, [r7, #4]
 800fcd6:	681d      	ldr	r5, [r3, #0]
 800fcd8:	466c      	mov	r4, sp
 800fcda:	f107 0314 	add.w	r3, r7, #20
 800fcde:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800fce2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 800fce6:	f107 0308 	add.w	r3, r7, #8
 800fcea:	cb0e      	ldmia	r3, {r1, r2, r3}
 800fcec:	4628      	mov	r0, r5
 800fcee:	f003 f928 	bl	8012f42 <SDIO_Init>
 800fcf2:	4603      	mov	r3, r0
 800fcf4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  if(status != HAL_OK)
 800fcf8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 800fcfc:	2b00      	cmp	r3, #0
 800fcfe:	d001      	beq.n	800fd04 <HAL_SD_InitCard+0x50>
  {
    return HAL_ERROR;
 800fd00:	2301      	movs	r3, #1
 800fd02:	e04f      	b.n	800fda4 <HAL_SD_InitCard+0xf0>
  }

  /* Disable SDIO Clock */
  __HAL_SD_DISABLE(hsd);
 800fd04:	4b29      	ldr	r3, [pc, #164]	@ (800fdac <HAL_SD_InitCard+0xf8>)
 800fd06:	2200      	movs	r2, #0
 800fd08:	601a      	str	r2, [r3, #0]

  /* Set Power State to ON */
  (void)SDIO_PowerState_ON(hsd->Instance);
 800fd0a:	687b      	ldr	r3, [r7, #4]
 800fd0c:	681b      	ldr	r3, [r3, #0]
 800fd0e:	4618      	mov	r0, r3
 800fd10:	f003 f960 	bl	8012fd4 <SDIO_PowerState_ON>

  /* Enable SDIO Clock */
  __HAL_SD_ENABLE(hsd);
 800fd14:	4b25      	ldr	r3, [pc, #148]	@ (800fdac <HAL_SD_InitCard+0xf8>)
 800fd16:	2201      	movs	r2, #1
 800fd18:	601a      	str	r2, [r3, #0]

  /* Required power up waiting time before starting the SD initialization  sequence */
  HAL_Delay(2);
 800fd1a:	2002      	movs	r0, #2
 800fd1c:	f7f8 ffbe 	bl	8008c9c <HAL_Delay>

  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd);
 800fd20:	6878      	ldr	r0, [r7, #4]
 800fd22:	f001 f80f 	bl	8010d44 <SD_PowerON>
 800fd26:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
 800fd28:	6a3b      	ldr	r3, [r7, #32]
 800fd2a:	2b00      	cmp	r3, #0
 800fd2c:	d00b      	beq.n	800fd46 <HAL_SD_InitCard+0x92>
  {
    hsd->State = HAL_SD_STATE_READY;
 800fd2e:	687b      	ldr	r3, [r7, #4]
 800fd30:	2201      	movs	r2, #1
 800fd32:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    hsd->ErrorCode |= errorstate;
 800fd36:	687b      	ldr	r3, [r7, #4]
 800fd38:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800fd3a:	6a3b      	ldr	r3, [r7, #32]
 800fd3c:	431a      	orrs	r2, r3
 800fd3e:	687b      	ldr	r3, [r7, #4]
 800fd40:	639a      	str	r2, [r3, #56]	@ 0x38
    return HAL_ERROR;
 800fd42:	2301      	movs	r3, #1
 800fd44:	e02e      	b.n	800fda4 <HAL_SD_InitCard+0xf0>
  }

  /* Card initialization */
  errorstate = SD_InitCard(hsd);
 800fd46:	6878      	ldr	r0, [r7, #4]
 800fd48:	f000 ff2e 	bl	8010ba8 <SD_InitCard>
 800fd4c:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
 800fd4e:	6a3b      	ldr	r3, [r7, #32]
 800fd50:	2b00      	cmp	r3, #0
 800fd52:	d00b      	beq.n	800fd6c <HAL_SD_InitCard+0xb8>
  {
    hsd->State = HAL_SD_STATE_READY;
 800fd54:	687b      	ldr	r3, [r7, #4]
 800fd56:	2201      	movs	r2, #1
 800fd58:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    hsd->ErrorCode |= errorstate;
 800fd5c:	687b      	ldr	r3, [r7, #4]
 800fd5e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800fd60:	6a3b      	ldr	r3, [r7, #32]
 800fd62:	431a      	orrs	r2, r3
 800fd64:	687b      	ldr	r3, [r7, #4]
 800fd66:	639a      	str	r2, [r3, #56]	@ 0x38
    return HAL_ERROR;
 800fd68:	2301      	movs	r3, #1
 800fd6a:	e01b      	b.n	800fda4 <HAL_SD_InitCard+0xf0>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800fd6c:	687b      	ldr	r3, [r7, #4]
 800fd6e:	681b      	ldr	r3, [r3, #0]
 800fd70:	f44f 7100 	mov.w	r1, #512	@ 0x200
 800fd74:	4618      	mov	r0, r3
 800fd76:	f003 f9bf 	bl	80130f8 <SDMMC_CmdBlockLength>
 800fd7a:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
 800fd7c:	6a3b      	ldr	r3, [r7, #32]
 800fd7e:	2b00      	cmp	r3, #0
 800fd80:	d00f      	beq.n	800fda2 <HAL_SD_InitCard+0xee>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800fd82:	687b      	ldr	r3, [r7, #4]
 800fd84:	681b      	ldr	r3, [r3, #0]
 800fd86:	4a0a      	ldr	r2, [pc, #40]	@ (800fdb0 <HAL_SD_InitCard+0xfc>)
 800fd88:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
 800fd8a:	687b      	ldr	r3, [r7, #4]
 800fd8c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800fd8e:	6a3b      	ldr	r3, [r7, #32]
 800fd90:	431a      	orrs	r2, r3
 800fd92:	687b      	ldr	r3, [r7, #4]
 800fd94:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->State = HAL_SD_STATE_READY;
 800fd96:	687b      	ldr	r3, [r7, #4]
 800fd98:	2201      	movs	r2, #1
 800fd9a:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 800fd9e:	2301      	movs	r3, #1
 800fda0:	e000      	b.n	800fda4 <HAL_SD_InitCard+0xf0>
  }

  return HAL_OK;
 800fda2:	2300      	movs	r3, #0
}
 800fda4:	4618      	mov	r0, r3
 800fda6:	3728      	adds	r7, #40	@ 0x28
 800fda8:	46bd      	mov	sp, r7
 800fdaa:	bdb0      	pop	{r4, r5, r7, pc}
 800fdac:	422580a0 	.word	0x422580a0
 800fdb0:	004005ff 	.word	0x004005ff

0800fdb4 <HAL_SD_ReadBlocks_DMA>:
  * @param  BlockAdd: Block Address from where data is to be read
  * @param  NumberOfBlocks: Number of blocks to read.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
{
 800fdb4:	b580      	push	{r7, lr}
 800fdb6:	b08c      	sub	sp, #48	@ 0x30
 800fdb8:	af00      	add	r7, sp, #0
 800fdba:	60f8      	str	r0, [r7, #12]
 800fdbc:	60b9      	str	r1, [r7, #8]
 800fdbe:	607a      	str	r2, [r7, #4]
 800fdc0:	603b      	str	r3, [r7, #0]
  SDIO_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
 800fdc2:	687b      	ldr	r3, [r7, #4]
 800fdc4:	62bb      	str	r3, [r7, #40]	@ 0x28

  if(NULL == pData)
 800fdc6:	68bb      	ldr	r3, [r7, #8]
 800fdc8:	2b00      	cmp	r3, #0
 800fdca:	d107      	bne.n	800fddc <HAL_SD_ReadBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800fdcc:	68fb      	ldr	r3, [r7, #12]
 800fdce:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800fdd0:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 800fdd4:	68fb      	ldr	r3, [r7, #12]
 800fdd6:	639a      	str	r2, [r3, #56]	@ 0x38
    return HAL_ERROR;
 800fdd8:	2301      	movs	r3, #1
 800fdda:	e0c0      	b.n	800ff5e <HAL_SD_ReadBlocks_DMA+0x1aa>
  }

  if(hsd->State == HAL_SD_STATE_READY)
 800fddc:	68fb      	ldr	r3, [r7, #12]
 800fdde:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800fde2:	b2db      	uxtb	r3, r3
 800fde4:	2b01      	cmp	r3, #1
 800fde6:	f040 80b9 	bne.w	800ff5c <HAL_SD_ReadBlocks_DMA+0x1a8>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800fdea:	68fb      	ldr	r3, [r7, #12]
 800fdec:	2200      	movs	r2, #0
 800fdee:	639a      	str	r2, [r3, #56]	@ 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800fdf0:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800fdf2:	683b      	ldr	r3, [r7, #0]
 800fdf4:	441a      	add	r2, r3
 800fdf6:	68fb      	ldr	r3, [r7, #12]
 800fdf8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800fdfa:	429a      	cmp	r2, r3
 800fdfc:	d907      	bls.n	800fe0e <HAL_SD_ReadBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800fdfe:	68fb      	ldr	r3, [r7, #12]
 800fe00:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800fe02:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
 800fe06:	68fb      	ldr	r3, [r7, #12]
 800fe08:	639a      	str	r2, [r3, #56]	@ 0x38
      return HAL_ERROR;
 800fe0a:	2301      	movs	r3, #1
 800fe0c:	e0a7      	b.n	800ff5e <HAL_SD_ReadBlocks_DMA+0x1aa>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 800fe0e:	68fb      	ldr	r3, [r7, #12]
 800fe10:	2203      	movs	r2, #3
 800fe12:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800fe16:	68fb      	ldr	r3, [r7, #12]
 800fe18:	681b      	ldr	r3, [r3, #0]
 800fe1a:	2200      	movs	r2, #0
 800fe1c:	62da      	str	r2, [r3, #44]	@ 0x2c

#if defined(SDIO_STA_STBITERR)
    __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND | SDIO_IT_STBITERR));
 800fe1e:	68fb      	ldr	r3, [r7, #12]
 800fe20:	681b      	ldr	r3, [r3, #0]
 800fe22:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fe24:	68fa      	ldr	r2, [r7, #12]
 800fe26:	6812      	ldr	r2, [r2, #0]
 800fe28:	f443 734a 	orr.w	r3, r3, #808	@ 0x328
 800fe2c:	f043 0302 	orr.w	r3, r3, #2
 800fe30:	63d3      	str	r3, [r2, #60]	@ 0x3c
#else /* SDIO_STA_STBITERR not defined */
    __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND));
#endif /* SDIO_STA_STBITERR */

    /* Set the DMA transfer complete callback */
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
 800fe32:	68fb      	ldr	r3, [r7, #12]
 800fe34:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fe36:	4a4c      	ldr	r2, [pc, #304]	@ (800ff68 <HAL_SD_ReadBlocks_DMA+0x1b4>)
 800fe38:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Set the DMA error callback */
    hsd->hdmarx->XferErrorCallback = SD_DMAError;
 800fe3a:	68fb      	ldr	r3, [r7, #12]
 800fe3c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fe3e:	4a4b      	ldr	r2, [pc, #300]	@ (800ff6c <HAL_SD_ReadBlocks_DMA+0x1b8>)
 800fe40:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Set the DMA Abort callback */
    hsd->hdmarx->XferAbortCallback = NULL;
 800fe42:	68fb      	ldr	r3, [r7, #12]
 800fe44:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fe46:	2200      	movs	r2, #0
 800fe48:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Force DMA Direction */
    hsd->hdmarx->Init.Direction = DMA_PERIPH_TO_MEMORY;
 800fe4a:	68fb      	ldr	r3, [r7, #12]
 800fe4c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fe4e:	2200      	movs	r2, #0
 800fe50:	609a      	str	r2, [r3, #8]
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
 800fe52:	68fb      	ldr	r3, [r7, #12]
 800fe54:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fe56:	681b      	ldr	r3, [r3, #0]
 800fe58:	681b      	ldr	r3, [r3, #0]
 800fe5a:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 800fe5e:	68fb      	ldr	r3, [r7, #12]
 800fe60:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fe62:	689a      	ldr	r2, [r3, #8]
 800fe64:	68fb      	ldr	r3, [r7, #12]
 800fe66:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800fe68:	681b      	ldr	r3, [r3, #0]
 800fe6a:	430a      	orrs	r2, r1
 800fe6c:	601a      	str	r2, [r3, #0]

    /* Enable the DMA Channel */
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 800fe6e:	68fb      	ldr	r3, [r7, #12]
 800fe70:	6c18      	ldr	r0, [r3, #64]	@ 0x40
 800fe72:	68fb      	ldr	r3, [r7, #12]
 800fe74:	681b      	ldr	r3, [r3, #0]
 800fe76:	3380      	adds	r3, #128	@ 0x80
 800fe78:	4619      	mov	r1, r3
 800fe7a:	68ba      	ldr	r2, [r7, #8]
 800fe7c:	683b      	ldr	r3, [r7, #0]
 800fe7e:	025b      	lsls	r3, r3, #9
 800fe80:	089b      	lsrs	r3, r3, #2
 800fe82:	f7f9 f97f 	bl	8009184 <HAL_DMA_Start_IT>
 800fe86:	4603      	mov	r3, r0
 800fe88:	2b00      	cmp	r3, #0
 800fe8a:	d017      	beq.n	800febc <HAL_SD_ReadBlocks_DMA+0x108>
    {
      __HAL_SD_DISABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND));
 800fe8c:	68fb      	ldr	r3, [r7, #12]
 800fe8e:	681b      	ldr	r3, [r3, #0]
 800fe90:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800fe92:	68fb      	ldr	r3, [r7, #12]
 800fe94:	681b      	ldr	r3, [r3, #0]
 800fe96:	f422 7295 	bic.w	r2, r2, #298	@ 0x12a
 800fe9a:	63da      	str	r2, [r3, #60]	@ 0x3c
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800fe9c:	68fb      	ldr	r3, [r7, #12]
 800fe9e:	681b      	ldr	r3, [r3, #0]
 800fea0:	4a33      	ldr	r2, [pc, #204]	@ (800ff70 <HAL_SD_ReadBlocks_DMA+0x1bc>)
 800fea2:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 800fea4:	68fb      	ldr	r3, [r7, #12]
 800fea6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800fea8:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 800feac:	68fb      	ldr	r3, [r7, #12]
 800feae:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->State = HAL_SD_STATE_READY;
 800feb0:	68fb      	ldr	r3, [r7, #12]
 800feb2:	2201      	movs	r2, #1
 800feb4:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      return HAL_ERROR;
 800feb8:	2301      	movs	r3, #1
 800feba:	e050      	b.n	800ff5e <HAL_SD_ReadBlocks_DMA+0x1aa>
    }
    else
    {
      /* Enable SD DMA transfer */
      __HAL_SD_DMA_ENABLE(hsd);
 800febc:	4b2d      	ldr	r3, [pc, #180]	@ (800ff74 <HAL_SD_ReadBlocks_DMA+0x1c0>)
 800febe:	2201      	movs	r2, #1
 800fec0:	601a      	str	r2, [r3, #0]

      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800fec2:	68fb      	ldr	r3, [r7, #12]
 800fec4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800fec6:	2b01      	cmp	r3, #1
 800fec8:	d002      	beq.n	800fed0 <HAL_SD_ReadBlocks_DMA+0x11c>
      {
        add *= 512U;
 800feca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800fecc:	025b      	lsls	r3, r3, #9
 800fece:	62bb      	str	r3, [r7, #40]	@ 0x28
      }

      /* Configure the SD DPSM (Data Path State Machine) */
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800fed0:	f04f 33ff 	mov.w	r3, #4294967295
 800fed4:	613b      	str	r3, [r7, #16]
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 800fed6:	683b      	ldr	r3, [r7, #0]
 800fed8:	025b      	lsls	r3, r3, #9
 800feda:	617b      	str	r3, [r7, #20]
      config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 800fedc:	2390      	movs	r3, #144	@ 0x90
 800fede:	61bb      	str	r3, [r7, #24]
      config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 800fee0:	2302      	movs	r3, #2
 800fee2:	61fb      	str	r3, [r7, #28]
      config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 800fee4:	2300      	movs	r3, #0
 800fee6:	623b      	str	r3, [r7, #32]
      config.DPSM          = SDIO_DPSM_ENABLE;
 800fee8:	2301      	movs	r3, #1
 800feea:	627b      	str	r3, [r7, #36]	@ 0x24
      (void)SDIO_ConfigData(hsd->Instance, &config);
 800feec:	68fb      	ldr	r3, [r7, #12]
 800feee:	681b      	ldr	r3, [r3, #0]
 800fef0:	f107 0210 	add.w	r2, r7, #16
 800fef4:	4611      	mov	r1, r2
 800fef6:	4618      	mov	r0, r3
 800fef8:	f003 f8d2 	bl	80130a0 <SDIO_ConfigData>

      /* Read Blocks in DMA mode */
      if(NumberOfBlocks > 1U)
 800fefc:	683b      	ldr	r3, [r7, #0]
 800fefe:	2b01      	cmp	r3, #1
 800ff00:	d90a      	bls.n	800ff18 <HAL_SD_ReadBlocks_DMA+0x164>
      {
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 800ff02:	68fb      	ldr	r3, [r7, #12]
 800ff04:	2282      	movs	r2, #130	@ 0x82
 800ff06:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Read Multi Block command */
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 800ff08:	68fb      	ldr	r3, [r7, #12]
 800ff0a:	681b      	ldr	r3, [r3, #0]
 800ff0c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800ff0e:	4618      	mov	r0, r3
 800ff10:	f003 f936 	bl	8013180 <SDMMC_CmdReadMultiBlock>
 800ff14:	62f8      	str	r0, [r7, #44]	@ 0x2c
 800ff16:	e009      	b.n	800ff2c <HAL_SD_ReadBlocks_DMA+0x178>
      }
      else
      {
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
 800ff18:	68fb      	ldr	r3, [r7, #12]
 800ff1a:	2281      	movs	r2, #129	@ 0x81
 800ff1c:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Read Single Block command */
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800ff1e:	68fb      	ldr	r3, [r7, #12]
 800ff20:	681b      	ldr	r3, [r3, #0]
 800ff22:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800ff24:	4618      	mov	r0, r3
 800ff26:	f003 f909 	bl	801313c <SDMMC_CmdReadSingleBlock>
 800ff2a:	62f8      	str	r0, [r7, #44]	@ 0x2c
      }
      if(errorstate != HAL_SD_ERROR_NONE)
 800ff2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ff2e:	2b00      	cmp	r3, #0
 800ff30:	d012      	beq.n	800ff58 <HAL_SD_ReadBlocks_DMA+0x1a4>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 800ff32:	68fb      	ldr	r3, [r7, #12]
 800ff34:	681b      	ldr	r3, [r3, #0]
 800ff36:	4a0e      	ldr	r2, [pc, #56]	@ (800ff70 <HAL_SD_ReadBlocks_DMA+0x1bc>)
 800ff38:	639a      	str	r2, [r3, #56]	@ 0x38
        hsd->ErrorCode |= errorstate;
 800ff3a:	68fb      	ldr	r3, [r7, #12]
 800ff3c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800ff3e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800ff40:	431a      	orrs	r2, r3
 800ff42:	68fb      	ldr	r3, [r7, #12]
 800ff44:	639a      	str	r2, [r3, #56]	@ 0x38
        hsd->State = HAL_SD_STATE_READY;
 800ff46:	68fb      	ldr	r3, [r7, #12]
 800ff48:	2201      	movs	r2, #1
 800ff4a:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800ff4e:	68fb      	ldr	r3, [r7, #12]
 800ff50:	2200      	movs	r2, #0
 800ff52:	631a      	str	r2, [r3, #48]	@ 0x30
        return HAL_ERROR;
 800ff54:	2301      	movs	r3, #1
 800ff56:	e002      	b.n	800ff5e <HAL_SD_ReadBlocks_DMA+0x1aa>
      }

      return HAL_OK;
 800ff58:	2300      	movs	r3, #0
 800ff5a:	e000      	b.n	800ff5e <HAL_SD_ReadBlocks_DMA+0x1aa>
    }
  }
  else
  {
    return HAL_BUSY;
 800ff5c:	2302      	movs	r3, #2
  }
}
 800ff5e:	4618      	mov	r0, r3
 800ff60:	3730      	adds	r7, #48	@ 0x30
 800ff62:	46bd      	mov	sp, r7
 800ff64:	bd80      	pop	{r7, pc}
 800ff66:	bf00      	nop
 800ff68:	080109b7 	.word	0x080109b7
 800ff6c:	08010a29 	.word	0x08010a29
 800ff70:	004005ff 	.word	0x004005ff
 800ff74:	4225858c 	.word	0x4225858c

0800ff78 <HAL_SD_WriteBlocks_DMA>:
  * @param  BlockAdd: Block Address where data will be written
  * @param  NumberOfBlocks: Number of blocks to write
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
{
 800ff78:	b580      	push	{r7, lr}
 800ff7a:	b08c      	sub	sp, #48	@ 0x30
 800ff7c:	af00      	add	r7, sp, #0
 800ff7e:	60f8      	str	r0, [r7, #12]
 800ff80:	60b9      	str	r1, [r7, #8]
 800ff82:	607a      	str	r2, [r7, #4]
 800ff84:	603b      	str	r3, [r7, #0]
  SDIO_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
 800ff86:	687b      	ldr	r3, [r7, #4]
 800ff88:	62bb      	str	r3, [r7, #40]	@ 0x28

  if(NULL == pData)
 800ff8a:	68bb      	ldr	r3, [r7, #8]
 800ff8c:	2b00      	cmp	r3, #0
 800ff8e:	d107      	bne.n	800ffa0 <HAL_SD_WriteBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800ff90:	68fb      	ldr	r3, [r7, #12]
 800ff92:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800ff94:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 800ff98:	68fb      	ldr	r3, [r7, #12]
 800ff9a:	639a      	str	r2, [r3, #56]	@ 0x38
    return HAL_ERROR;
 800ff9c:	2301      	movs	r3, #1
 800ff9e:	e0c5      	b.n	801012c <HAL_SD_WriteBlocks_DMA+0x1b4>
  }

  if(hsd->State == HAL_SD_STATE_READY)
 800ffa0:	68fb      	ldr	r3, [r7, #12]
 800ffa2:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800ffa6:	b2db      	uxtb	r3, r3
 800ffa8:	2b01      	cmp	r3, #1
 800ffaa:	f040 80be 	bne.w	801012a <HAL_SD_WriteBlocks_DMA+0x1b2>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800ffae:	68fb      	ldr	r3, [r7, #12]
 800ffb0:	2200      	movs	r2, #0
 800ffb2:	639a      	str	r2, [r3, #56]	@ 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800ffb4:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800ffb6:	683b      	ldr	r3, [r7, #0]
 800ffb8:	441a      	add	r2, r3
 800ffba:	68fb      	ldr	r3, [r7, #12]
 800ffbc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800ffbe:	429a      	cmp	r2, r3
 800ffc0:	d907      	bls.n	800ffd2 <HAL_SD_WriteBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800ffc2:	68fb      	ldr	r3, [r7, #12]
 800ffc4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800ffc6:	f043 7200 	orr.w	r2, r3, #33554432	@ 0x2000000
 800ffca:	68fb      	ldr	r3, [r7, #12]
 800ffcc:	639a      	str	r2, [r3, #56]	@ 0x38
      return HAL_ERROR;
 800ffce:	2301      	movs	r3, #1
 800ffd0:	e0ac      	b.n	801012c <HAL_SD_WriteBlocks_DMA+0x1b4>
    }

    hsd->State = HAL_SD_STATE_BUSY;
 800ffd2:	68fb      	ldr	r3, [r7, #12]
 800ffd4:	2203      	movs	r2, #3
 800ffd6:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
 800ffda:	68fb      	ldr	r3, [r7, #12]
 800ffdc:	681b      	ldr	r3, [r3, #0]
 800ffde:	2200      	movs	r2, #0
 800ffe0:	62da      	str	r2, [r3, #44]	@ 0x2c

    /* Enable SD Error interrupts */
#if defined(SDIO_STA_STBITERR)
    __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR));
 800ffe2:	68fb      	ldr	r3, [r7, #12]
 800ffe4:	681b      	ldr	r3, [r3, #0]
 800ffe6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800ffe8:	68fa      	ldr	r2, [r7, #12]
 800ffea:	6812      	ldr	r2, [r2, #0]
 800ffec:	f443 7306 	orr.w	r3, r3, #536	@ 0x218
 800fff0:	f043 0302 	orr.w	r3, r3, #2
 800fff4:	63d3      	str	r3, [r2, #60]	@ 0x3c
#else /* SDIO_STA_STBITERR not defined */
    __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR));   
#endif /* SDIO_STA_STBITERR */

    /* Set the DMA transfer complete callback */
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
 800fff6:	68fb      	ldr	r3, [r7, #12]
 800fff8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800fffa:	4a4e      	ldr	r2, [pc, #312]	@ (8010134 <HAL_SD_WriteBlocks_DMA+0x1bc>)
 800fffc:	63da      	str	r2, [r3, #60]	@ 0x3c

    /* Set the DMA error callback */
    hsd->hdmatx->XferErrorCallback = SD_DMAError;
 800fffe:	68fb      	ldr	r3, [r7, #12]
 8010000:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010002:	4a4d      	ldr	r2, [pc, #308]	@ (8010138 <HAL_SD_WriteBlocks_DMA+0x1c0>)
 8010004:	64da      	str	r2, [r3, #76]	@ 0x4c

    /* Set the DMA Abort callback */
    hsd->hdmatx->XferAbortCallback = NULL;
 8010006:	68fb      	ldr	r3, [r7, #12]
 8010008:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801000a:	2200      	movs	r2, #0
 801000c:	651a      	str	r2, [r3, #80]	@ 0x50

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 801000e:	68fb      	ldr	r3, [r7, #12]
 8010010:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010012:	2b01      	cmp	r3, #1
 8010014:	d002      	beq.n	801001c <HAL_SD_WriteBlocks_DMA+0xa4>
    {
      add *= 512U;
 8010016:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8010018:	025b      	lsls	r3, r3, #9
 801001a:	62bb      	str	r3, [r7, #40]	@ 0x28
    }

    /* Write Blocks in Polling mode */
    if(NumberOfBlocks > 1U)
 801001c:	683b      	ldr	r3, [r7, #0]
 801001e:	2b01      	cmp	r3, #1
 8010020:	d90a      	bls.n	8010038 <HAL_SD_WriteBlocks_DMA+0xc0>
    {
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
 8010022:	68fb      	ldr	r3, [r7, #12]
 8010024:	22a0      	movs	r2, #160	@ 0xa0
 8010026:	631a      	str	r2, [r3, #48]	@ 0x30

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 8010028:	68fb      	ldr	r3, [r7, #12]
 801002a:	681b      	ldr	r3, [r3, #0]
 801002c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 801002e:	4618      	mov	r0, r3
 8010030:	f003 f8ea 	bl	8013208 <SDMMC_CmdWriteMultiBlock>
 8010034:	62f8      	str	r0, [r7, #44]	@ 0x2c
 8010036:	e009      	b.n	801004c <HAL_SD_WriteBlocks_DMA+0xd4>
    }
    else
    {
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
 8010038:	68fb      	ldr	r3, [r7, #12]
 801003a:	2290      	movs	r2, #144	@ 0x90
 801003c:	631a      	str	r2, [r3, #48]	@ 0x30

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 801003e:	68fb      	ldr	r3, [r7, #12]
 8010040:	681b      	ldr	r3, [r3, #0]
 8010042:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8010044:	4618      	mov	r0, r3
 8010046:	f003 f8bd 	bl	80131c4 <SDMMC_CmdWriteSingleBlock>
 801004a:	62f8      	str	r0, [r7, #44]	@ 0x2c
    }
    if(errorstate != HAL_SD_ERROR_NONE)
 801004c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801004e:	2b00      	cmp	r3, #0
 8010050:	d012      	beq.n	8010078 <HAL_SD_WriteBlocks_DMA+0x100>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8010052:	68fb      	ldr	r3, [r7, #12]
 8010054:	681b      	ldr	r3, [r3, #0]
 8010056:	4a39      	ldr	r2, [pc, #228]	@ (801013c <HAL_SD_WriteBlocks_DMA+0x1c4>)
 8010058:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= errorstate;
 801005a:	68fb      	ldr	r3, [r7, #12]
 801005c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801005e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8010060:	431a      	orrs	r2, r3
 8010062:	68fb      	ldr	r3, [r7, #12]
 8010064:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->State = HAL_SD_STATE_READY;
 8010066:	68fb      	ldr	r3, [r7, #12]
 8010068:	2201      	movs	r2, #1
 801006a:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 801006e:	68fb      	ldr	r3, [r7, #12]
 8010070:	2200      	movs	r2, #0
 8010072:	631a      	str	r2, [r3, #48]	@ 0x30
      return HAL_ERROR;
 8010074:	2301      	movs	r3, #1
 8010076:	e059      	b.n	801012c <HAL_SD_WriteBlocks_DMA+0x1b4>
    }

    /* Enable SDIO DMA transfer */
    __HAL_SD_DMA_ENABLE(hsd);
 8010078:	4b31      	ldr	r3, [pc, #196]	@ (8010140 <HAL_SD_WriteBlocks_DMA+0x1c8>)
 801007a:	2201      	movs	r2, #1
 801007c:	601a      	str	r2, [r3, #0]

    /* Force DMA Direction */
    hsd->hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
 801007e:	68fb      	ldr	r3, [r7, #12]
 8010080:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010082:	2240      	movs	r2, #64	@ 0x40
 8010084:	609a      	str	r2, [r3, #8]
    MODIFY_REG(hsd->hdmatx->Instance->CR, DMA_SxCR_DIR, hsd->hdmatx->Init.Direction);
 8010086:	68fb      	ldr	r3, [r7, #12]
 8010088:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801008a:	681b      	ldr	r3, [r3, #0]
 801008c:	681b      	ldr	r3, [r3, #0]
 801008e:	f023 01c0 	bic.w	r1, r3, #192	@ 0xc0
 8010092:	68fb      	ldr	r3, [r7, #12]
 8010094:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010096:	689a      	ldr	r2, [r3, #8]
 8010098:	68fb      	ldr	r3, [r7, #12]
 801009a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801009c:	681b      	ldr	r3, [r3, #0]
 801009e:	430a      	orrs	r2, r1
 80100a0:	601a      	str	r2, [r3, #0]

    /* Enable the DMA Channel */
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
 80100a2:	68fb      	ldr	r3, [r7, #12]
 80100a4:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 80100a6:	68b9      	ldr	r1, [r7, #8]
 80100a8:	68fb      	ldr	r3, [r7, #12]
 80100aa:	681b      	ldr	r3, [r3, #0]
 80100ac:	3380      	adds	r3, #128	@ 0x80
 80100ae:	461a      	mov	r2, r3
 80100b0:	683b      	ldr	r3, [r7, #0]
 80100b2:	025b      	lsls	r3, r3, #9
 80100b4:	089b      	lsrs	r3, r3, #2
 80100b6:	f7f9 f865 	bl	8009184 <HAL_DMA_Start_IT>
 80100ba:	4603      	mov	r3, r0
 80100bc:	2b00      	cmp	r3, #0
 80100be:	d01c      	beq.n	80100fa <HAL_SD_WriteBlocks_DMA+0x182>
    {
#if defined(SDIO_STA_STBITERR)
      __HAL_SD_DISABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR));
 80100c0:	68fb      	ldr	r3, [r7, #12]
 80100c2:	681b      	ldr	r3, [r3, #0]
 80100c4:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80100c6:	68fa      	ldr	r2, [r7, #12]
 80100c8:	6812      	ldr	r2, [r2, #0]
 80100ca:	f423 7306 	bic.w	r3, r3, #536	@ 0x218
 80100ce:	f023 0302 	bic.w	r3, r3, #2
 80100d2:	63d3      	str	r3, [r2, #60]	@ 0x3c
#else /* SDIO_STA_STBITERR not defined */
      __HAL_SD_DISABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR));   
#endif /* SDIO_STA_STBITERR */
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80100d4:	68fb      	ldr	r3, [r7, #12]
 80100d6:	681b      	ldr	r3, [r3, #0]
 80100d8:	4a18      	ldr	r2, [pc, #96]	@ (801013c <HAL_SD_WriteBlocks_DMA+0x1c4>)
 80100da:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 80100dc:	68fb      	ldr	r3, [r7, #12]
 80100de:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80100e0:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 80100e4:	68fb      	ldr	r3, [r7, #12]
 80100e6:	639a      	str	r2, [r3, #56]	@ 0x38
      hsd->State = HAL_SD_STATE_READY;
 80100e8:	68fb      	ldr	r3, [r7, #12]
 80100ea:	2201      	movs	r2, #1
 80100ec:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 80100f0:	68fb      	ldr	r3, [r7, #12]
 80100f2:	2200      	movs	r2, #0
 80100f4:	631a      	str	r2, [r3, #48]	@ 0x30
      return HAL_ERROR;
 80100f6:	2301      	movs	r3, #1
 80100f8:	e018      	b.n	801012c <HAL_SD_WriteBlocks_DMA+0x1b4>
    }
    else
    {
      /* Configure the SD DPSM (Data Path State Machine) */
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
 80100fa:	f04f 33ff 	mov.w	r3, #4294967295
 80100fe:	613b      	str	r3, [r7, #16]
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
 8010100:	683b      	ldr	r3, [r7, #0]
 8010102:	025b      	lsls	r3, r3, #9
 8010104:	617b      	str	r3, [r7, #20]
      config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
 8010106:	2390      	movs	r3, #144	@ 0x90
 8010108:	61bb      	str	r3, [r7, #24]
      config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
 801010a:	2300      	movs	r3, #0
 801010c:	61fb      	str	r3, [r7, #28]
      config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 801010e:	2300      	movs	r3, #0
 8010110:	623b      	str	r3, [r7, #32]
      config.DPSM          = SDIO_DPSM_ENABLE;
 8010112:	2301      	movs	r3, #1
 8010114:	627b      	str	r3, [r7, #36]	@ 0x24
      (void)SDIO_ConfigData(hsd->Instance, &config);
 8010116:	68fb      	ldr	r3, [r7, #12]
 8010118:	681b      	ldr	r3, [r3, #0]
 801011a:	f107 0210 	add.w	r2, r7, #16
 801011e:	4611      	mov	r1, r2
 8010120:	4618      	mov	r0, r3
 8010122:	f002 ffbd 	bl	80130a0 <SDIO_ConfigData>

      return HAL_OK;
 8010126:	2300      	movs	r3, #0
 8010128:	e000      	b.n	801012c <HAL_SD_WriteBlocks_DMA+0x1b4>
    }
  }
  else
  {
    return HAL_BUSY;
 801012a:	2302      	movs	r3, #2
  }
}
 801012c:	4618      	mov	r0, r3
 801012e:	3730      	adds	r7, #48	@ 0x30
 8010130:	46bd      	mov	sp, r7
 8010132:	bd80      	pop	{r7, pc}
 8010134:	0801098d 	.word	0x0801098d
 8010138:	08010a29 	.word	0x08010a29
 801013c:	004005ff 	.word	0x004005ff
 8010140:	4225858c 	.word	0x4225858c

08010144 <HAL_SD_IRQHandler>:
  * @brief  This function handles SD card interrupt request.
  * @param  hsd: Pointer to SD handle
  * @retval None
  */
void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
{
 8010144:	b580      	push	{r7, lr}
 8010146:	b084      	sub	sp, #16
 8010148:	af00      	add	r7, sp, #0
 801014a:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  uint32_t context = hsd->Context;
 801014c:	687b      	ldr	r3, [r7, #4]
 801014e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8010150:	60fb      	str	r3, [r7, #12]

  /* Check for SDIO interrupt flags */
  if((__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 8010152:	687b      	ldr	r3, [r7, #4]
 8010154:	681b      	ldr	r3, [r3, #0]
 8010156:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8010158:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 801015c:	2b00      	cmp	r3, #0
 801015e:	d008      	beq.n	8010172 <HAL_SD_IRQHandler+0x2e>
 8010160:	68fb      	ldr	r3, [r7, #12]
 8010162:	f003 0308 	and.w	r3, r3, #8
 8010166:	2b00      	cmp	r3, #0
 8010168:	d003      	beq.n	8010172 <HAL_SD_IRQHandler+0x2e>
  {
    SD_Read_IT(hsd);
 801016a:	6878      	ldr	r0, [r7, #4]
 801016c:	f001 f810 	bl	8011190 <SD_Read_IT>
 8010170:	e165      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
  }

  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DATAEND) != RESET)
 8010172:	687b      	ldr	r3, [r7, #4]
 8010174:	681b      	ldr	r3, [r3, #0]
 8010176:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8010178:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 801017c:	2b00      	cmp	r3, #0
 801017e:	f000 808f 	beq.w	80102a0 <HAL_SD_IRQHandler+0x15c>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DATAEND);
 8010182:	687b      	ldr	r3, [r7, #4]
 8010184:	681b      	ldr	r3, [r3, #0]
 8010186:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801018a:	639a      	str	r2, [r3, #56]	@ 0x38

#if defined(SDIO_STA_STBITERR)
    __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND  | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
 801018c:	687b      	ldr	r3, [r7, #4]
 801018e:	681b      	ldr	r3, [r3, #0]
 8010190:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010192:	687a      	ldr	r2, [r7, #4]
 8010194:	6812      	ldr	r2, [r2, #0]
 8010196:	f423 4343 	bic.w	r3, r3, #49920	@ 0xc300
 801019a:	f023 033a 	bic.w	r3, r3, #58	@ 0x3a
 801019e:	63d3      	str	r3, [r2, #60]	@ 0x3c
    __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND  | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
                             SDIO_IT_TXUNDERR | SDIO_IT_RXOVERR  | SDIO_IT_TXFIFOHE |\
                             SDIO_IT_RXFIFOHF);
#endif /* SDIO_STA_STBITERR */

    hsd->Instance->DCTRL &= ~(SDIO_DCTRL_DTEN);
 80101a0:	687b      	ldr	r3, [r7, #4]
 80101a2:	681b      	ldr	r3, [r3, #0]
 80101a4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80101a6:	687b      	ldr	r3, [r7, #4]
 80101a8:	681b      	ldr	r3, [r3, #0]
 80101aa:	f022 0201 	bic.w	r2, r2, #1
 80101ae:	62da      	str	r2, [r3, #44]	@ 0x2c
    
    if((context & SD_CONTEXT_IT) != 0U)
 80101b0:	68fb      	ldr	r3, [r7, #12]
 80101b2:	f003 0308 	and.w	r3, r3, #8
 80101b6:	2b00      	cmp	r3, #0
 80101b8:	d039      	beq.n	801022e <HAL_SD_IRQHandler+0xea>
    {
      if(((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 80101ba:	68fb      	ldr	r3, [r7, #12]
 80101bc:	f003 0302 	and.w	r3, r3, #2
 80101c0:	2b00      	cmp	r3, #0
 80101c2:	d104      	bne.n	80101ce <HAL_SD_IRQHandler+0x8a>
 80101c4:	68fb      	ldr	r3, [r7, #12]
 80101c6:	f003 0320 	and.w	r3, r3, #32
 80101ca:	2b00      	cmp	r3, #0
 80101cc:	d011      	beq.n	80101f2 <HAL_SD_IRQHandler+0xae>
      {
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 80101ce:	687b      	ldr	r3, [r7, #4]
 80101d0:	681b      	ldr	r3, [r3, #0]
 80101d2:	4618      	mov	r0, r3
 80101d4:	f003 f83a 	bl	801324c <SDMMC_CmdStopTransfer>
 80101d8:	60b8      	str	r0, [r7, #8]
        if(errorstate != HAL_SD_ERROR_NONE)
 80101da:	68bb      	ldr	r3, [r7, #8]
 80101dc:	2b00      	cmp	r3, #0
 80101de:	d008      	beq.n	80101f2 <HAL_SD_IRQHandler+0xae>
        {
          hsd->ErrorCode |= errorstate;
 80101e0:	687b      	ldr	r3, [r7, #4]
 80101e2:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80101e4:	68bb      	ldr	r3, [r7, #8]
 80101e6:	431a      	orrs	r2, r3
 80101e8:	687b      	ldr	r3, [r7, #4]
 80101ea:	639a      	str	r2, [r3, #56]	@ 0x38
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
          hsd->ErrorCallback(hsd);
#else
          HAL_SD_ErrorCallback(hsd);
 80101ec:	6878      	ldr	r0, [r7, #4]
 80101ee:	f000 f92f 	bl	8010450 <HAL_SD_ErrorCallback>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
        }
      }

      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 80101f2:	687b      	ldr	r3, [r7, #4]
 80101f4:	681b      	ldr	r3, [r3, #0]
 80101f6:	f240 523a 	movw	r2, #1338	@ 0x53a
 80101fa:	639a      	str	r2, [r3, #56]	@ 0x38

      hsd->State = HAL_SD_STATE_READY;
 80101fc:	687b      	ldr	r3, [r7, #4]
 80101fe:	2201      	movs	r2, #1
 8010200:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8010204:	687b      	ldr	r3, [r7, #4]
 8010206:	2200      	movs	r2, #0
 8010208:	631a      	str	r2, [r3, #48]	@ 0x30
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 801020a:	68fb      	ldr	r3, [r7, #12]
 801020c:	f003 0301 	and.w	r3, r3, #1
 8010210:	2b00      	cmp	r3, #0
 8010212:	d104      	bne.n	801021e <HAL_SD_IRQHandler+0xda>
 8010214:	68fb      	ldr	r3, [r7, #12]
 8010216:	f003 0302 	and.w	r3, r3, #2
 801021a:	2b00      	cmp	r3, #0
 801021c:	d003      	beq.n	8010226 <HAL_SD_IRQHandler+0xe2>
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->RxCpltCallback(hsd);
#else
        HAL_SD_RxCpltCallback(hsd);
 801021e:	6878      	ldr	r0, [r7, #4]
 8010220:	f7f7 fe80 	bl	8007f24 <HAL_SD_RxCpltCallback>
 8010224:	e10b      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
      else
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->TxCpltCallback(hsd);
#else
        HAL_SD_TxCpltCallback(hsd);
 8010226:	6878      	ldr	r0, [r7, #4]
 8010228:	f7f7 fe8c 	bl	8007f44 <HAL_SD_TxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
 801022c:	e107      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
    else if((context & SD_CONTEXT_DMA) != 0U)
 801022e:	68fb      	ldr	r3, [r7, #12]
 8010230:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8010234:	2b00      	cmp	r3, #0
 8010236:	f000 8102 	beq.w	801043e <HAL_SD_IRQHandler+0x2fa>
      if((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
 801023a:	68fb      	ldr	r3, [r7, #12]
 801023c:	f003 0320 	and.w	r3, r3, #32
 8010240:	2b00      	cmp	r3, #0
 8010242:	d011      	beq.n	8010268 <HAL_SD_IRQHandler+0x124>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8010244:	687b      	ldr	r3, [r7, #4]
 8010246:	681b      	ldr	r3, [r3, #0]
 8010248:	4618      	mov	r0, r3
 801024a:	f002 ffff 	bl	801324c <SDMMC_CmdStopTransfer>
 801024e:	60b8      	str	r0, [r7, #8]
        if(errorstate != HAL_SD_ERROR_NONE)
 8010250:	68bb      	ldr	r3, [r7, #8]
 8010252:	2b00      	cmp	r3, #0
 8010254:	d008      	beq.n	8010268 <HAL_SD_IRQHandler+0x124>
          hsd->ErrorCode |= errorstate;
 8010256:	687b      	ldr	r3, [r7, #4]
 8010258:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801025a:	68bb      	ldr	r3, [r7, #8]
 801025c:	431a      	orrs	r2, r3
 801025e:	687b      	ldr	r3, [r7, #4]
 8010260:	639a      	str	r2, [r3, #56]	@ 0x38
          HAL_SD_ErrorCallback(hsd);
 8010262:	6878      	ldr	r0, [r7, #4]
 8010264:	f000 f8f4 	bl	8010450 <HAL_SD_ErrorCallback>
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) == 0U) && ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) == 0U))
 8010268:	68fb      	ldr	r3, [r7, #12]
 801026a:	f003 0301 	and.w	r3, r3, #1
 801026e:	2b00      	cmp	r3, #0
 8010270:	f040 80e5 	bne.w	801043e <HAL_SD_IRQHandler+0x2fa>
 8010274:	68fb      	ldr	r3, [r7, #12]
 8010276:	f003 0302 	and.w	r3, r3, #2
 801027a:	2b00      	cmp	r3, #0
 801027c:	f040 80df 	bne.w	801043e <HAL_SD_IRQHandler+0x2fa>
        hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
 8010280:	687b      	ldr	r3, [r7, #4]
 8010282:	681b      	ldr	r3, [r3, #0]
 8010284:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8010286:	687b      	ldr	r3, [r7, #4]
 8010288:	681b      	ldr	r3, [r3, #0]
 801028a:	f022 0208 	bic.w	r2, r2, #8
 801028e:	62da      	str	r2, [r3, #44]	@ 0x2c
        hsd->State = HAL_SD_STATE_READY;
 8010290:	687b      	ldr	r3, [r7, #4]
 8010292:	2201      	movs	r2, #1
 8010294:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        HAL_SD_TxCpltCallback(hsd);
 8010298:	6878      	ldr	r0, [r7, #4]
 801029a:	f7f7 fe53 	bl	8007f44 <HAL_SD_TxCpltCallback>
}
 801029e:	e0ce      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
  else if((__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
 80102a0:	687b      	ldr	r3, [r7, #4]
 80102a2:	681b      	ldr	r3, [r3, #0]
 80102a4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80102a6:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80102aa:	2b00      	cmp	r3, #0
 80102ac:	d008      	beq.n	80102c0 <HAL_SD_IRQHandler+0x17c>
 80102ae:	68fb      	ldr	r3, [r7, #12]
 80102b0:	f003 0308 	and.w	r3, r3, #8
 80102b4:	2b00      	cmp	r3, #0
 80102b6:	d003      	beq.n	80102c0 <HAL_SD_IRQHandler+0x17c>
    SD_Write_IT(hsd);
 80102b8:	6878      	ldr	r0, [r7, #4]
 80102ba:	f000 ffba 	bl	8011232 <SD_Write_IT>
 80102be:	e0be      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_RXOVERR | SDIO_FLAG_TXUNDERR | SDIO_FLAG_STBITERR) != RESET)
 80102c0:	687b      	ldr	r3, [r7, #4]
 80102c2:	681b      	ldr	r3, [r3, #0]
 80102c4:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80102c6:	f240 233a 	movw	r3, #570	@ 0x23a
 80102ca:	4013      	ands	r3, r2
 80102cc:	2b00      	cmp	r3, #0
 80102ce:	f000 80b6 	beq.w	801043e <HAL_SD_IRQHandler+0x2fa>
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL) != RESET)
 80102d2:	687b      	ldr	r3, [r7, #4]
 80102d4:	681b      	ldr	r3, [r3, #0]
 80102d6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80102d8:	f003 0302 	and.w	r3, r3, #2
 80102dc:	2b00      	cmp	r3, #0
 80102de:	d005      	beq.n	80102ec <HAL_SD_IRQHandler+0x1a8>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 80102e0:	687b      	ldr	r3, [r7, #4]
 80102e2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80102e4:	f043 0202 	orr.w	r2, r3, #2
 80102e8:	687b      	ldr	r3, [r7, #4]
 80102ea:	639a      	str	r2, [r3, #56]	@ 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT) != RESET)
 80102ec:	687b      	ldr	r3, [r7, #4]
 80102ee:	681b      	ldr	r3, [r3, #0]
 80102f0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80102f2:	f003 0308 	and.w	r3, r3, #8
 80102f6:	2b00      	cmp	r3, #0
 80102f8:	d005      	beq.n	8010306 <HAL_SD_IRQHandler+0x1c2>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 80102fa:	687b      	ldr	r3, [r7, #4]
 80102fc:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80102fe:	f043 0208 	orr.w	r2, r3, #8
 8010302:	687b      	ldr	r3, [r7, #4]
 8010304:	639a      	str	r2, [r3, #56]	@ 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR) != RESET)
 8010306:	687b      	ldr	r3, [r7, #4]
 8010308:	681b      	ldr	r3, [r3, #0]
 801030a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801030c:	f003 0320 	and.w	r3, r3, #32
 8010310:	2b00      	cmp	r3, #0
 8010312:	d005      	beq.n	8010320 <HAL_SD_IRQHandler+0x1dc>
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 8010314:	687b      	ldr	r3, [r7, #4]
 8010316:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010318:	f043 0220 	orr.w	r2, r3, #32
 801031c:	687b      	ldr	r3, [r7, #4]
 801031e:	639a      	str	r2, [r3, #56]	@ 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR) != RESET)
 8010320:	687b      	ldr	r3, [r7, #4]
 8010322:	681b      	ldr	r3, [r3, #0]
 8010324:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8010326:	f003 0310 	and.w	r3, r3, #16
 801032a:	2b00      	cmp	r3, #0
 801032c:	d005      	beq.n	801033a <HAL_SD_IRQHandler+0x1f6>
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 801032e:	687b      	ldr	r3, [r7, #4]
 8010330:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010332:	f043 0210 	orr.w	r2, r3, #16
 8010336:	687b      	ldr	r3, [r7, #4]
 8010338:	639a      	str	r2, [r3, #56]	@ 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_STBITERR) != RESET)
 801033a:	687b      	ldr	r3, [r7, #4]
 801033c:	681b      	ldr	r3, [r3, #0]
 801033e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8010340:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8010344:	2b00      	cmp	r3, #0
 8010346:	d005      	beq.n	8010354 <HAL_SD_IRQHandler+0x210>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 8010348:	687b      	ldr	r3, [r7, #4]
 801034a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801034c:	f043 0208 	orr.w	r2, r3, #8
 8010350:	687b      	ldr	r3, [r7, #4]
 8010352:	639a      	str	r2, [r3, #56]	@ 0x38
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS | SDIO_FLAG_STBITERR);
 8010354:	687b      	ldr	r3, [r7, #4]
 8010356:	681b      	ldr	r3, [r3, #0]
 8010358:	f240 723a 	movw	r2, #1850	@ 0x73a
 801035c:	639a      	str	r2, [r3, #56]	@ 0x38
    __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
 801035e:	687b      	ldr	r3, [r7, #4]
 8010360:	681b      	ldr	r3, [r3, #0]
 8010362:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010364:	687a      	ldr	r2, [r7, #4]
 8010366:	6812      	ldr	r2, [r2, #0]
 8010368:	f423 734e 	bic.w	r3, r3, #824	@ 0x338
 801036c:	f023 0302 	bic.w	r3, r3, #2
 8010370:	63d3      	str	r3, [r2, #60]	@ 0x3c
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8010372:	687b      	ldr	r3, [r7, #4]
 8010374:	681b      	ldr	r3, [r3, #0]
 8010376:	4618      	mov	r0, r3
 8010378:	f002 ff68 	bl	801324c <SDMMC_CmdStopTransfer>
 801037c:	4602      	mov	r2, r0
 801037e:	687b      	ldr	r3, [r7, #4]
 8010380:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010382:	431a      	orrs	r2, r3
 8010384:	687b      	ldr	r3, [r7, #4]
 8010386:	639a      	str	r2, [r3, #56]	@ 0x38
    if((context & SD_CONTEXT_IT) != 0U)
 8010388:	68fb      	ldr	r3, [r7, #12]
 801038a:	f003 0308 	and.w	r3, r3, #8
 801038e:	2b00      	cmp	r3, #0
 8010390:	d00a      	beq.n	80103a8 <HAL_SD_IRQHandler+0x264>
      hsd->State = HAL_SD_STATE_READY;
 8010392:	687b      	ldr	r3, [r7, #4]
 8010394:	2201      	movs	r2, #1
 8010396:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 801039a:	687b      	ldr	r3, [r7, #4]
 801039c:	2200      	movs	r2, #0
 801039e:	631a      	str	r2, [r3, #48]	@ 0x30
      HAL_SD_ErrorCallback(hsd);
 80103a0:	6878      	ldr	r0, [r7, #4]
 80103a2:	f000 f855 	bl	8010450 <HAL_SD_ErrorCallback>
}
 80103a6:	e04a      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
    else if((context & SD_CONTEXT_DMA) != 0U)
 80103a8:	68fb      	ldr	r3, [r7, #12]
 80103aa:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80103ae:	2b00      	cmp	r3, #0
 80103b0:	d045      	beq.n	801043e <HAL_SD_IRQHandler+0x2fa>
      if(((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
 80103b2:	68fb      	ldr	r3, [r7, #12]
 80103b4:	f003 0310 	and.w	r3, r3, #16
 80103b8:	2b00      	cmp	r3, #0
 80103ba:	d104      	bne.n	80103c6 <HAL_SD_IRQHandler+0x282>
 80103bc:	68fb      	ldr	r3, [r7, #12]
 80103be:	f003 0320 	and.w	r3, r3, #32
 80103c2:	2b00      	cmp	r3, #0
 80103c4:	d011      	beq.n	80103ea <HAL_SD_IRQHandler+0x2a6>
        hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
 80103c6:	687b      	ldr	r3, [r7, #4]
 80103c8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80103ca:	4a1f      	ldr	r2, [pc, #124]	@ (8010448 <HAL_SD_IRQHandler+0x304>)
 80103cc:	651a      	str	r2, [r3, #80]	@ 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
 80103ce:	687b      	ldr	r3, [r7, #4]
 80103d0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80103d2:	4618      	mov	r0, r3
 80103d4:	f7f8 ff9e 	bl	8009314 <HAL_DMA_Abort_IT>
 80103d8:	4603      	mov	r3, r0
 80103da:	2b00      	cmp	r3, #0
 80103dc:	d02f      	beq.n	801043e <HAL_SD_IRQHandler+0x2fa>
          SD_DMATxAbort(hsd->hdmatx);
 80103de:	687b      	ldr	r3, [r7, #4]
 80103e0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80103e2:	4618      	mov	r0, r3
 80103e4:	f000 fb72 	bl	8010acc <SD_DMATxAbort>
        if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
 80103e8:	e029      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
      else if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
 80103ea:	68fb      	ldr	r3, [r7, #12]
 80103ec:	f003 0301 	and.w	r3, r3, #1
 80103f0:	2b00      	cmp	r3, #0
 80103f2:	d104      	bne.n	80103fe <HAL_SD_IRQHandler+0x2ba>
 80103f4:	68fb      	ldr	r3, [r7, #12]
 80103f6:	f003 0302 	and.w	r3, r3, #2
 80103fa:	2b00      	cmp	r3, #0
 80103fc:	d011      	beq.n	8010422 <HAL_SD_IRQHandler+0x2de>
        hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
 80103fe:	687b      	ldr	r3, [r7, #4]
 8010400:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8010402:	4a12      	ldr	r2, [pc, #72]	@ (801044c <HAL_SD_IRQHandler+0x308>)
 8010404:	651a      	str	r2, [r3, #80]	@ 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
 8010406:	687b      	ldr	r3, [r7, #4]
 8010408:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801040a:	4618      	mov	r0, r3
 801040c:	f7f8 ff82 	bl	8009314 <HAL_DMA_Abort_IT>
 8010410:	4603      	mov	r3, r0
 8010412:	2b00      	cmp	r3, #0
 8010414:	d013      	beq.n	801043e <HAL_SD_IRQHandler+0x2fa>
          SD_DMARxAbort(hsd->hdmarx);
 8010416:	687b      	ldr	r3, [r7, #4]
 8010418:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801041a:	4618      	mov	r0, r3
 801041c:	f000 fb8d 	bl	8010b3a <SD_DMARxAbort>
        if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
 8010420:	e00d      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
        hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8010422:	687b      	ldr	r3, [r7, #4]
 8010424:	2200      	movs	r2, #0
 8010426:	639a      	str	r2, [r3, #56]	@ 0x38
        hsd->State = HAL_SD_STATE_READY;
 8010428:	687b      	ldr	r3, [r7, #4]
 801042a:	2201      	movs	r2, #1
 801042c:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        hsd->Context = SD_CONTEXT_NONE;
 8010430:	687b      	ldr	r3, [r7, #4]
 8010432:	2200      	movs	r2, #0
 8010434:	631a      	str	r2, [r3, #48]	@ 0x30
        HAL_SD_AbortCallback(hsd);
 8010436:	6878      	ldr	r0, [r7, #4]
 8010438:	f000 f814 	bl	8010464 <HAL_SD_AbortCallback>
}
 801043c:	e7ff      	b.n	801043e <HAL_SD_IRQHandler+0x2fa>
 801043e:	bf00      	nop
 8010440:	3710      	adds	r7, #16
 8010442:	46bd      	mov	sp, r7
 8010444:	bd80      	pop	{r7, pc}
 8010446:	bf00      	nop
 8010448:	08010acd 	.word	0x08010acd
 801044c:	08010b3b 	.word	0x08010b3b

08010450 <HAL_SD_ErrorCallback>:
  * @brief SD error callbacks
  * @param hsd: Pointer SD handle
  * @retval None
  */
__weak void HAL_SD_ErrorCallback(SD_HandleTypeDef *hsd)
{
 8010450:	b480      	push	{r7}
 8010452:	b083      	sub	sp, #12
 8010454:	af00      	add	r7, sp, #0
 8010456:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SD_ErrorCallback can be implemented in the user file
   */
}
 8010458:	bf00      	nop
 801045a:	370c      	adds	r7, #12
 801045c:	46bd      	mov	sp, r7
 801045e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010462:	4770      	bx	lr

08010464 <HAL_SD_AbortCallback>:
  * @brief SD Abort callbacks
  * @param hsd: Pointer SD handle
  * @retval None
  */
__weak void HAL_SD_AbortCallback(SD_HandleTypeDef *hsd)
{
 8010464:	b480      	push	{r7}
 8010466:	b083      	sub	sp, #12
 8010468:	af00      	add	r7, sp, #0
 801046a:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SD_AbortCallback can be implemented in the user file
   */
}
 801046c:	bf00      	nop
 801046e:	370c      	adds	r7, #12
 8010470:	46bd      	mov	sp, r7
 8010472:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010476:	4770      	bx	lr

08010478 <HAL_SD_GetCardCSD>:
  * @param  pCSD: Pointer to a HAL_SD_CardCSDTypeDef structure that  
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
 8010478:	b480      	push	{r7}
 801047a:	b083      	sub	sp, #12
 801047c:	af00      	add	r7, sp, #0
 801047e:	6078      	str	r0, [r7, #4]
 8010480:	6039      	str	r1, [r7, #0]
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8010482:	687b      	ldr	r3, [r7, #4]
 8010484:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8010486:	0f9b      	lsrs	r3, r3, #30
 8010488:	b2da      	uxtb	r2, r3
 801048a:	683b      	ldr	r3, [r7, #0]
 801048c:	701a      	strb	r2, [r3, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 801048e:	687b      	ldr	r3, [r7, #4]
 8010490:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8010492:	0e9b      	lsrs	r3, r3, #26
 8010494:	b2db      	uxtb	r3, r3
 8010496:	f003 030f 	and.w	r3, r3, #15
 801049a:	b2da      	uxtb	r2, r3
 801049c:	683b      	ldr	r3, [r7, #0]
 801049e:	705a      	strb	r2, [r3, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 80104a0:	687b      	ldr	r3, [r7, #4]
 80104a2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80104a4:	0e1b      	lsrs	r3, r3, #24
 80104a6:	b2db      	uxtb	r3, r3
 80104a8:	f003 0303 	and.w	r3, r3, #3
 80104ac:	b2da      	uxtb	r2, r3
 80104ae:	683b      	ldr	r3, [r7, #0]
 80104b0:	709a      	strb	r2, [r3, #2]

  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 80104b2:	687b      	ldr	r3, [r7, #4]
 80104b4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80104b6:	0c1b      	lsrs	r3, r3, #16
 80104b8:	b2da      	uxtb	r2, r3
 80104ba:	683b      	ldr	r3, [r7, #0]
 80104bc:	70da      	strb	r2, [r3, #3]

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 80104be:	687b      	ldr	r3, [r7, #4]
 80104c0:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80104c2:	0a1b      	lsrs	r3, r3, #8
 80104c4:	b2da      	uxtb	r2, r3
 80104c6:	683b      	ldr	r3, [r7, #0]
 80104c8:	711a      	strb	r2, [r3, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 80104ca:	687b      	ldr	r3, [r7, #4]
 80104cc:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80104ce:	b2da      	uxtb	r2, r3
 80104d0:	683b      	ldr	r3, [r7, #0]
 80104d2:	715a      	strb	r2, [r3, #5]

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 80104d4:	687b      	ldr	r3, [r7, #4]
 80104d6:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80104d8:	0d1b      	lsrs	r3, r3, #20
 80104da:	b29a      	uxth	r2, r3
 80104dc:	683b      	ldr	r3, [r7, #0]
 80104de:	80da      	strh	r2, [r3, #6]

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 80104e0:	687b      	ldr	r3, [r7, #4]
 80104e2:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80104e4:	0c1b      	lsrs	r3, r3, #16
 80104e6:	b2db      	uxtb	r3, r3
 80104e8:	f003 030f 	and.w	r3, r3, #15
 80104ec:	b2da      	uxtb	r2, r3
 80104ee:	683b      	ldr	r3, [r7, #0]
 80104f0:	721a      	strb	r2, [r3, #8]

  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 80104f2:	687b      	ldr	r3, [r7, #4]
 80104f4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80104f6:	0bdb      	lsrs	r3, r3, #15
 80104f8:	b2db      	uxtb	r3, r3
 80104fa:	f003 0301 	and.w	r3, r3, #1
 80104fe:	b2da      	uxtb	r2, r3
 8010500:	683b      	ldr	r3, [r7, #0]
 8010502:	725a      	strb	r2, [r3, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 8010504:	687b      	ldr	r3, [r7, #4]
 8010506:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8010508:	0b9b      	lsrs	r3, r3, #14
 801050a:	b2db      	uxtb	r3, r3
 801050c:	f003 0301 	and.w	r3, r3, #1
 8010510:	b2da      	uxtb	r2, r3
 8010512:	683b      	ldr	r3, [r7, #0]
 8010514:	729a      	strb	r2, [r3, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 8010516:	687b      	ldr	r3, [r7, #4]
 8010518:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801051a:	0b5b      	lsrs	r3, r3, #13
 801051c:	b2db      	uxtb	r3, r3
 801051e:	f003 0301 	and.w	r3, r3, #1
 8010522:	b2da      	uxtb	r2, r3
 8010524:	683b      	ldr	r3, [r7, #0]
 8010526:	72da      	strb	r2, [r3, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 8010528:	687b      	ldr	r3, [r7, #4]
 801052a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801052c:	0b1b      	lsrs	r3, r3, #12
 801052e:	b2db      	uxtb	r3, r3
 8010530:	f003 0301 	and.w	r3, r3, #1
 8010534:	b2da      	uxtb	r2, r3
 8010536:	683b      	ldr	r3, [r7, #0]
 8010538:	731a      	strb	r2, [r3, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
 801053a:	683b      	ldr	r3, [r7, #0]
 801053c:	2200      	movs	r2, #0
 801053e:	735a      	strb	r2, [r3, #13]

  if(hsd->SdCard.CardType == CARD_SDSC)
 8010540:	687b      	ldr	r3, [r7, #4]
 8010542:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010544:	2b00      	cmp	r3, #0
 8010546:	d163      	bne.n	8010610 <HAL_SD_GetCardCSD+0x198>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 8010548:	687b      	ldr	r3, [r7, #4]
 801054a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801054c:	009a      	lsls	r2, r3, #2
 801054e:	f640 73fc 	movw	r3, #4092	@ 0xffc
 8010552:	4013      	ands	r3, r2
 8010554:	687a      	ldr	r2, [r7, #4]
 8010556:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
 8010558:	0f92      	lsrs	r2, r2, #30
 801055a:	431a      	orrs	r2, r3
 801055c:	683b      	ldr	r3, [r7, #0]
 801055e:	611a      	str	r2, [r3, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 8010560:	687b      	ldr	r3, [r7, #4]
 8010562:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8010564:	0edb      	lsrs	r3, r3, #27
 8010566:	b2db      	uxtb	r3, r3
 8010568:	f003 0307 	and.w	r3, r3, #7
 801056c:	b2da      	uxtb	r2, r3
 801056e:	683b      	ldr	r3, [r7, #0]
 8010570:	751a      	strb	r2, [r3, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 8010572:	687b      	ldr	r3, [r7, #4]
 8010574:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8010576:	0e1b      	lsrs	r3, r3, #24
 8010578:	b2db      	uxtb	r3, r3
 801057a:	f003 0307 	and.w	r3, r3, #7
 801057e:	b2da      	uxtb	r2, r3
 8010580:	683b      	ldr	r3, [r7, #0]
 8010582:	755a      	strb	r2, [r3, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 8010584:	687b      	ldr	r3, [r7, #4]
 8010586:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8010588:	0d5b      	lsrs	r3, r3, #21
 801058a:	b2db      	uxtb	r3, r3
 801058c:	f003 0307 	and.w	r3, r3, #7
 8010590:	b2da      	uxtb	r2, r3
 8010592:	683b      	ldr	r3, [r7, #0]
 8010594:	759a      	strb	r2, [r3, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 8010596:	687b      	ldr	r3, [r7, #4]
 8010598:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801059a:	0c9b      	lsrs	r3, r3, #18
 801059c:	b2db      	uxtb	r3, r3
 801059e:	f003 0307 	and.w	r3, r3, #7
 80105a2:	b2da      	uxtb	r2, r3
 80105a4:	683b      	ldr	r3, [r7, #0]
 80105a6:	75da      	strb	r2, [r3, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 80105a8:	687b      	ldr	r3, [r7, #4]
 80105aa:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80105ac:	0bdb      	lsrs	r3, r3, #15
 80105ae:	b2db      	uxtb	r3, r3
 80105b0:	f003 0307 	and.w	r3, r3, #7
 80105b4:	b2da      	uxtb	r2, r3
 80105b6:	683b      	ldr	r3, [r7, #0]
 80105b8:	761a      	strb	r2, [r3, #24]

    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 80105ba:	683b      	ldr	r3, [r7, #0]
 80105bc:	691b      	ldr	r3, [r3, #16]
 80105be:	1c5a      	adds	r2, r3, #1
 80105c0:	687b      	ldr	r3, [r7, #4]
 80105c2:	655a      	str	r2, [r3, #84]	@ 0x54
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 80105c4:	683b      	ldr	r3, [r7, #0]
 80105c6:	7e1b      	ldrb	r3, [r3, #24]
 80105c8:	b2db      	uxtb	r3, r3
 80105ca:	f003 0307 	and.w	r3, r3, #7
 80105ce:	3302      	adds	r3, #2
 80105d0:	2201      	movs	r2, #1
 80105d2:	fa02 f303 	lsl.w	r3, r2, r3
 80105d6:	687a      	ldr	r2, [r7, #4]
 80105d8:	6d52      	ldr	r2, [r2, #84]	@ 0x54
 80105da:	fb03 f202 	mul.w	r2, r3, r2
 80105de:	687b      	ldr	r3, [r7, #4]
 80105e0:	655a      	str	r2, [r3, #84]	@ 0x54
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 80105e2:	683b      	ldr	r3, [r7, #0]
 80105e4:	7a1b      	ldrb	r3, [r3, #8]
 80105e6:	b2db      	uxtb	r3, r3
 80105e8:	f003 030f 	and.w	r3, r3, #15
 80105ec:	2201      	movs	r2, #1
 80105ee:	409a      	lsls	r2, r3
 80105f0:	687b      	ldr	r3, [r7, #4]
 80105f2:	659a      	str	r2, [r3, #88]	@ 0x58

    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 80105f4:	687b      	ldr	r3, [r7, #4]
 80105f6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80105f8:	687a      	ldr	r2, [r7, #4]
 80105fa:	6d92      	ldr	r2, [r2, #88]	@ 0x58
 80105fc:	0a52      	lsrs	r2, r2, #9
 80105fe:	fb03 f202 	mul.w	r2, r3, r2
 8010602:	687b      	ldr	r3, [r7, #4]
 8010604:	65da      	str	r2, [r3, #92]	@ 0x5c
    hsd->SdCard.LogBlockSize = 512U;
 8010606:	687b      	ldr	r3, [r7, #4]
 8010608:	f44f 7200 	mov.w	r2, #512	@ 0x200
 801060c:	661a      	str	r2, [r3, #96]	@ 0x60
 801060e:	e031      	b.n	8010674 <HAL_SD_GetCardCSD+0x1fc>
  }
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 8010610:	687b      	ldr	r3, [r7, #4]
 8010612:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010614:	2b01      	cmp	r3, #1
 8010616:	d11d      	bne.n	8010654 <HAL_SD_GetCardCSD+0x1dc>
  {
    /* Byte 7 */
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 8010618:	687b      	ldr	r3, [r7, #4]
 801061a:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 801061c:	041b      	lsls	r3, r3, #16
 801061e:	f403 127c 	and.w	r2, r3, #4128768	@ 0x3f0000
 8010622:	687b      	ldr	r3, [r7, #4]
 8010624:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8010626:	0c1b      	lsrs	r3, r3, #16
 8010628:	431a      	orrs	r2, r3
 801062a:	683b      	ldr	r3, [r7, #0]
 801062c:	611a      	str	r2, [r3, #16]

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 801062e:	683b      	ldr	r3, [r7, #0]
 8010630:	691b      	ldr	r3, [r3, #16]
 8010632:	3301      	adds	r3, #1
 8010634:	029a      	lsls	r2, r3, #10
 8010636:	687b      	ldr	r3, [r7, #4]
 8010638:	655a      	str	r2, [r3, #84]	@ 0x54
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 801063a:	687b      	ldr	r3, [r7, #4]
 801063c:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 801063e:	687b      	ldr	r3, [r7, #4]
 8010640:	65da      	str	r2, [r3, #92]	@ 0x5c
    hsd->SdCard.BlockSize = 512U;
 8010642:	687b      	ldr	r3, [r7, #4]
 8010644:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8010648:	659a      	str	r2, [r3, #88]	@ 0x58
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 801064a:	687b      	ldr	r3, [r7, #4]
 801064c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 801064e:	687b      	ldr	r3, [r7, #4]
 8010650:	661a      	str	r2, [r3, #96]	@ 0x60
 8010652:	e00f      	b.n	8010674 <HAL_SD_GetCardCSD+0x1fc>
  }
  else
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8010654:	687b      	ldr	r3, [r7, #4]
 8010656:	681b      	ldr	r3, [r3, #0]
 8010658:	4a58      	ldr	r2, [pc, #352]	@ (80107bc <HAL_SD_GetCardCSD+0x344>)
 801065a:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 801065c:	687b      	ldr	r3, [r7, #4]
 801065e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010660:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 8010664:	687b      	ldr	r3, [r7, #4]
 8010666:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->State = HAL_SD_STATE_READY;
 8010668:	687b      	ldr	r3, [r7, #4]
 801066a:	2201      	movs	r2, #1
 801066c:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    return HAL_ERROR;
 8010670:	2301      	movs	r3, #1
 8010672:	e09d      	b.n	80107b0 <HAL_SD_GetCardCSD+0x338>
  }

  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 8010674:	687b      	ldr	r3, [r7, #4]
 8010676:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8010678:	0b9b      	lsrs	r3, r3, #14
 801067a:	b2db      	uxtb	r3, r3
 801067c:	f003 0301 	and.w	r3, r3, #1
 8010680:	b2da      	uxtb	r2, r3
 8010682:	683b      	ldr	r3, [r7, #0]
 8010684:	765a      	strb	r2, [r3, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 8010686:	687b      	ldr	r3, [r7, #4]
 8010688:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801068a:	09db      	lsrs	r3, r3, #7
 801068c:	b2db      	uxtb	r3, r3
 801068e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8010692:	b2da      	uxtb	r2, r3
 8010694:	683b      	ldr	r3, [r7, #0]
 8010696:	769a      	strb	r2, [r3, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 8010698:	687b      	ldr	r3, [r7, #4]
 801069a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 801069c:	b2db      	uxtb	r3, r3
 801069e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80106a2:	b2da      	uxtb	r2, r3
 80106a4:	683b      	ldr	r3, [r7, #0]
 80106a6:	76da      	strb	r2, [r3, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 80106a8:	687b      	ldr	r3, [r7, #4]
 80106aa:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80106ac:	0fdb      	lsrs	r3, r3, #31
 80106ae:	b2da      	uxtb	r2, r3
 80106b0:	683b      	ldr	r3, [r7, #0]
 80106b2:	771a      	strb	r2, [r3, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 80106b4:	687b      	ldr	r3, [r7, #4]
 80106b6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80106b8:	0f5b      	lsrs	r3, r3, #29
 80106ba:	b2db      	uxtb	r3, r3
 80106bc:	f003 0303 	and.w	r3, r3, #3
 80106c0:	b2da      	uxtb	r2, r3
 80106c2:	683b      	ldr	r3, [r7, #0]
 80106c4:	775a      	strb	r2, [r3, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 80106c6:	687b      	ldr	r3, [r7, #4]
 80106c8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80106ca:	0e9b      	lsrs	r3, r3, #26
 80106cc:	b2db      	uxtb	r3, r3
 80106ce:	f003 0307 	and.w	r3, r3, #7
 80106d2:	b2da      	uxtb	r2, r3
 80106d4:	683b      	ldr	r3, [r7, #0]
 80106d6:	779a      	strb	r2, [r3, #30]

  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 80106d8:	687b      	ldr	r3, [r7, #4]
 80106da:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80106dc:	0d9b      	lsrs	r3, r3, #22
 80106de:	b2db      	uxtb	r3, r3
 80106e0:	f003 030f 	and.w	r3, r3, #15
 80106e4:	b2da      	uxtb	r2, r3
 80106e6:	683b      	ldr	r3, [r7, #0]
 80106e8:	77da      	strb	r2, [r3, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 80106ea:	687b      	ldr	r3, [r7, #4]
 80106ec:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80106ee:	0d5b      	lsrs	r3, r3, #21
 80106f0:	b2db      	uxtb	r3, r3
 80106f2:	f003 0301 	and.w	r3, r3, #1
 80106f6:	b2da      	uxtb	r2, r3
 80106f8:	683b      	ldr	r3, [r7, #0]
 80106fa:	f883 2020 	strb.w	r2, [r3, #32]

  pCSD->Reserved3 = 0;
 80106fe:	683b      	ldr	r3, [r7, #0]
 8010700:	2200      	movs	r2, #0
 8010702:	f883 2021 	strb.w	r2, [r3, #33]	@ 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 8010706:	687b      	ldr	r3, [r7, #4]
 8010708:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801070a:	0c1b      	lsrs	r3, r3, #16
 801070c:	b2db      	uxtb	r3, r3
 801070e:	f003 0301 	and.w	r3, r3, #1
 8010712:	b2da      	uxtb	r2, r3
 8010714:	683b      	ldr	r3, [r7, #0]
 8010716:	f883 2022 	strb.w	r2, [r3, #34]	@ 0x22

  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 801071a:	687b      	ldr	r3, [r7, #4]
 801071c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801071e:	0bdb      	lsrs	r3, r3, #15
 8010720:	b2db      	uxtb	r3, r3
 8010722:	f003 0301 	and.w	r3, r3, #1
 8010726:	b2da      	uxtb	r2, r3
 8010728:	683b      	ldr	r3, [r7, #0]
 801072a:	f883 2023 	strb.w	r2, [r3, #35]	@ 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 801072e:	687b      	ldr	r3, [r7, #4]
 8010730:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8010732:	0b9b      	lsrs	r3, r3, #14
 8010734:	b2db      	uxtb	r3, r3
 8010736:	f003 0301 	and.w	r3, r3, #1
 801073a:	b2da      	uxtb	r2, r3
 801073c:	683b      	ldr	r3, [r7, #0]
 801073e:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 8010742:	687b      	ldr	r3, [r7, #4]
 8010744:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8010746:	0b5b      	lsrs	r3, r3, #13
 8010748:	b2db      	uxtb	r3, r3
 801074a:	f003 0301 	and.w	r3, r3, #1
 801074e:	b2da      	uxtb	r2, r3
 8010750:	683b      	ldr	r3, [r7, #0]
 8010752:	f883 2025 	strb.w	r2, [r3, #37]	@ 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8010756:	687b      	ldr	r3, [r7, #4]
 8010758:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801075a:	0b1b      	lsrs	r3, r3, #12
 801075c:	b2db      	uxtb	r3, r3
 801075e:	f003 0301 	and.w	r3, r3, #1
 8010762:	b2da      	uxtb	r2, r3
 8010764:	683b      	ldr	r3, [r7, #0]
 8010766:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 801076a:	687b      	ldr	r3, [r7, #4]
 801076c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 801076e:	0a9b      	lsrs	r3, r3, #10
 8010770:	b2db      	uxtb	r3, r3
 8010772:	f003 0303 	and.w	r3, r3, #3
 8010776:	b2da      	uxtb	r2, r3
 8010778:	683b      	ldr	r3, [r7, #0]
 801077a:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27

  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 801077e:	687b      	ldr	r3, [r7, #4]
 8010780:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8010782:	0a1b      	lsrs	r3, r3, #8
 8010784:	b2db      	uxtb	r3, r3
 8010786:	f003 0303 	and.w	r3, r3, #3
 801078a:	b2da      	uxtb	r2, r3
 801078c:	683b      	ldr	r3, [r7, #0]
 801078e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8010792:	687b      	ldr	r3, [r7, #4]
 8010794:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8010796:	085b      	lsrs	r3, r3, #1
 8010798:	b2db      	uxtb	r3, r3
 801079a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801079e:	b2da      	uxtb	r2, r3
 80107a0:	683b      	ldr	r3, [r7, #0]
 80107a2:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29

  pCSD->Reserved4 = 1;
 80107a6:	683b      	ldr	r3, [r7, #0]
 80107a8:	2201      	movs	r2, #1
 80107aa:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a

  return HAL_OK;
 80107ae:	2300      	movs	r3, #0
}
 80107b0:	4618      	mov	r0, r3
 80107b2:	370c      	adds	r7, #12
 80107b4:	46bd      	mov	sp, r7
 80107b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80107ba:	4770      	bx	lr
 80107bc:	004005ff 	.word	0x004005ff

080107c0 <HAL_SD_GetCardInfo>:
  * @param  pCardInfo: Pointer to the HAL_SD_CardInfoTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
{
 80107c0:	b480      	push	{r7}
 80107c2:	b083      	sub	sp, #12
 80107c4:	af00      	add	r7, sp, #0
 80107c6:	6078      	str	r0, [r7, #4]
 80107c8:	6039      	str	r1, [r7, #0]
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 80107ca:	687b      	ldr	r3, [r7, #4]
 80107cc:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 80107ce:	683b      	ldr	r3, [r7, #0]
 80107d0:	601a      	str	r2, [r3, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 80107d2:	687b      	ldr	r3, [r7, #4]
 80107d4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 80107d6:	683b      	ldr	r3, [r7, #0]
 80107d8:	605a      	str	r2, [r3, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 80107da:	687b      	ldr	r3, [r7, #4]
 80107dc:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80107de:	683b      	ldr	r3, [r7, #0]
 80107e0:	609a      	str	r2, [r3, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 80107e2:	687b      	ldr	r3, [r7, #4]
 80107e4:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 80107e6:	683b      	ldr	r3, [r7, #0]
 80107e8:	60da      	str	r2, [r3, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 80107ea:	687b      	ldr	r3, [r7, #4]
 80107ec:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 80107ee:	683b      	ldr	r3, [r7, #0]
 80107f0:	611a      	str	r2, [r3, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 80107f2:	687b      	ldr	r3, [r7, #4]
 80107f4:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80107f6:	683b      	ldr	r3, [r7, #0]
 80107f8:	615a      	str	r2, [r3, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 80107fa:	687b      	ldr	r3, [r7, #4]
 80107fc:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 80107fe:	683b      	ldr	r3, [r7, #0]
 8010800:	619a      	str	r2, [r3, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 8010802:	687b      	ldr	r3, [r7, #4]
 8010804:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8010806:	683b      	ldr	r3, [r7, #0]
 8010808:	61da      	str	r2, [r3, #28]

  return HAL_OK;
 801080a:	2300      	movs	r3, #0
}
 801080c:	4618      	mov	r0, r3
 801080e:	370c      	adds	r7, #12
 8010810:	46bd      	mov	sp, r7
 8010812:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010816:	4770      	bx	lr

08010818 <HAL_SD_ConfigWideBusOperation>:
  *            @arg SDIO_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDIO_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
 8010818:	b5b0      	push	{r4, r5, r7, lr}
 801081a:	b08e      	sub	sp, #56	@ 0x38
 801081c:	af04      	add	r7, sp, #16
 801081e:	6078      	str	r0, [r7, #4]
 8010820:	6039      	str	r1, [r7, #0]
  SDIO_InitTypeDef Init;
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
 8010822:	2300      	movs	r3, #0
 8010824:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

  /* Check the parameters */
  assert_param(IS_SDIO_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
 8010828:	687b      	ldr	r3, [r7, #4]
 801082a:	2203      	movs	r2, #3
 801082c:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  if(hsd->SdCard.CardType != CARD_SECURED)
 8010830:	687b      	ldr	r3, [r7, #4]
 8010832:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010834:	2b03      	cmp	r3, #3
 8010836:	d02e      	beq.n	8010896 <HAL_SD_ConfigWideBusOperation+0x7e>
  {
    if(WideMode == SDIO_BUS_WIDE_8B)
 8010838:	683b      	ldr	r3, [r7, #0]
 801083a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 801083e:	d106      	bne.n	801084e <HAL_SD_ConfigWideBusOperation+0x36>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8010840:	687b      	ldr	r3, [r7, #4]
 8010842:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010844:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 8010848:	687b      	ldr	r3, [r7, #4]
 801084a:	639a      	str	r2, [r3, #56]	@ 0x38
 801084c:	e029      	b.n	80108a2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if(WideMode == SDIO_BUS_WIDE_4B)
 801084e:	683b      	ldr	r3, [r7, #0]
 8010850:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8010854:	d10a      	bne.n	801086c <HAL_SD_ConfigWideBusOperation+0x54>
    {
      errorstate = SD_WideBus_Enable(hsd);
 8010856:	6878      	ldr	r0, [r7, #4]
 8010858:	f000 fb2a 	bl	8010eb0 <SD_WideBus_Enable>
 801085c:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
 801085e:	687b      	ldr	r3, [r7, #4]
 8010860:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8010862:	6a3b      	ldr	r3, [r7, #32]
 8010864:	431a      	orrs	r2, r3
 8010866:	687b      	ldr	r3, [r7, #4]
 8010868:	639a      	str	r2, [r3, #56]	@ 0x38
 801086a:	e01a      	b.n	80108a2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if(WideMode == SDIO_BUS_WIDE_1B)
 801086c:	683b      	ldr	r3, [r7, #0]
 801086e:	2b00      	cmp	r3, #0
 8010870:	d10a      	bne.n	8010888 <HAL_SD_ConfigWideBusOperation+0x70>
    {
      errorstate = SD_WideBus_Disable(hsd);
 8010872:	6878      	ldr	r0, [r7, #4]
 8010874:	f000 fb67 	bl	8010f46 <SD_WideBus_Disable>
 8010878:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
 801087a:	687b      	ldr	r3, [r7, #4]
 801087c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 801087e:	6a3b      	ldr	r3, [r7, #32]
 8010880:	431a      	orrs	r2, r3
 8010882:	687b      	ldr	r3, [r7, #4]
 8010884:	639a      	str	r2, [r3, #56]	@ 0x38
 8010886:	e00c      	b.n	80108a2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else
    {
      /* WideMode is not a valid argument*/
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8010888:	687b      	ldr	r3, [r7, #4]
 801088a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801088c:	f043 6200 	orr.w	r2, r3, #134217728	@ 0x8000000
 8010890:	687b      	ldr	r3, [r7, #4]
 8010892:	639a      	str	r2, [r3, #56]	@ 0x38
 8010894:	e005      	b.n	80108a2 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
  }
  else
  {
    /* MMC Card does not support this feature */
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8010896:	687b      	ldr	r3, [r7, #4]
 8010898:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801089a:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 801089e:	687b      	ldr	r3, [r7, #4]
 80108a0:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 80108a2:	687b      	ldr	r3, [r7, #4]
 80108a4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80108a6:	2b00      	cmp	r3, #0
 80108a8:	d00b      	beq.n	80108c2 <HAL_SD_ConfigWideBusOperation+0xaa>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 80108aa:	687b      	ldr	r3, [r7, #4]
 80108ac:	681b      	ldr	r3, [r3, #0]
 80108ae:	4a26      	ldr	r2, [pc, #152]	@ (8010948 <HAL_SD_ConfigWideBusOperation+0x130>)
 80108b0:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->State = HAL_SD_STATE_READY;
 80108b2:	687b      	ldr	r3, [r7, #4]
 80108b4:	2201      	movs	r2, #1
 80108b6:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
    status = HAL_ERROR;
 80108ba:	2301      	movs	r3, #1
 80108bc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 80108c0:	e01f      	b.n	8010902 <HAL_SD_ConfigWideBusOperation+0xea>
  }
  else
  {
    /* Configure the SDIO peripheral */
    Init.ClockEdge           = hsd->Init.ClockEdge;
 80108c2:	687b      	ldr	r3, [r7, #4]
 80108c4:	685b      	ldr	r3, [r3, #4]
 80108c6:	60bb      	str	r3, [r7, #8]
    Init.ClockBypass         = hsd->Init.ClockBypass;
 80108c8:	687b      	ldr	r3, [r7, #4]
 80108ca:	689b      	ldr	r3, [r3, #8]
 80108cc:	60fb      	str	r3, [r7, #12]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 80108ce:	687b      	ldr	r3, [r7, #4]
 80108d0:	68db      	ldr	r3, [r3, #12]
 80108d2:	613b      	str	r3, [r7, #16]
    Init.BusWide             = WideMode;
 80108d4:	683b      	ldr	r3, [r7, #0]
 80108d6:	617b      	str	r3, [r7, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 80108d8:	687b      	ldr	r3, [r7, #4]
 80108da:	695b      	ldr	r3, [r3, #20]
 80108dc:	61bb      	str	r3, [r7, #24]
    Init.ClockDiv            = hsd->Init.ClockDiv;
 80108de:	687b      	ldr	r3, [r7, #4]
 80108e0:	699b      	ldr	r3, [r3, #24]
 80108e2:	61fb      	str	r3, [r7, #28]
    (void)SDIO_Init(hsd->Instance, Init);
 80108e4:	687b      	ldr	r3, [r7, #4]
 80108e6:	681d      	ldr	r5, [r3, #0]
 80108e8:	466c      	mov	r4, sp
 80108ea:	f107 0314 	add.w	r3, r7, #20
 80108ee:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80108f2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 80108f6:	f107 0308 	add.w	r3, r7, #8
 80108fa:	cb0e      	ldmia	r3, {r1, r2, r3}
 80108fc:	4628      	mov	r0, r5
 80108fe:	f002 fb20 	bl	8012f42 <SDIO_Init>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8010902:	687b      	ldr	r3, [r7, #4]
 8010904:	681b      	ldr	r3, [r3, #0]
 8010906:	f44f 7100 	mov.w	r1, #512	@ 0x200
 801090a:	4618      	mov	r0, r3
 801090c:	f002 fbf4 	bl	80130f8 <SDMMC_CmdBlockLength>
 8010910:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
 8010912:	6a3b      	ldr	r3, [r7, #32]
 8010914:	2b00      	cmp	r3, #0
 8010916:	d00c      	beq.n	8010932 <HAL_SD_ConfigWideBusOperation+0x11a>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8010918:	687b      	ldr	r3, [r7, #4]
 801091a:	681b      	ldr	r3, [r3, #0]
 801091c:	4a0a      	ldr	r2, [pc, #40]	@ (8010948 <HAL_SD_ConfigWideBusOperation+0x130>)
 801091e:	639a      	str	r2, [r3, #56]	@ 0x38
    hsd->ErrorCode |= errorstate;
 8010920:	687b      	ldr	r3, [r7, #4]
 8010922:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8010924:	6a3b      	ldr	r3, [r7, #32]
 8010926:	431a      	orrs	r2, r3
 8010928:	687b      	ldr	r3, [r7, #4]
 801092a:	639a      	str	r2, [r3, #56]	@ 0x38
    status = HAL_ERROR;
 801092c:	2301      	movs	r3, #1
 801092e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
 8010932:	687b      	ldr	r3, [r7, #4]
 8010934:	2201      	movs	r2, #1
 8010936:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  return status;
 801093a:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
 801093e:	4618      	mov	r0, r3
 8010940:	3728      	adds	r7, #40	@ 0x28
 8010942:	46bd      	mov	sp, r7
 8010944:	bdb0      	pop	{r4, r5, r7, pc}
 8010946:	bf00      	nop
 8010948:	004005ff 	.word	0x004005ff

0801094c <HAL_SD_GetCardState>:
  * @brief  Gets the current sd card data state.
  * @param  hsd: pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
 801094c:	b580      	push	{r7, lr}
 801094e:	b086      	sub	sp, #24
 8010950:	af00      	add	r7, sp, #0
 8010952:	6078      	str	r0, [r7, #4]
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0;
 8010954:	2300      	movs	r3, #0
 8010956:	60fb      	str	r3, [r7, #12]

  errorstate = SD_SendStatus(hsd, &resp1);
 8010958:	f107 030c 	add.w	r3, r7, #12
 801095c:	4619      	mov	r1, r3
 801095e:	6878      	ldr	r0, [r7, #4]
 8010960:	f000 fa7e 	bl	8010e60 <SD_SendStatus>
 8010964:	6178      	str	r0, [r7, #20]
  if(errorstate != HAL_SD_ERROR_NONE)
 8010966:	697b      	ldr	r3, [r7, #20]
 8010968:	2b00      	cmp	r3, #0
 801096a:	d005      	beq.n	8010978 <HAL_SD_GetCardState+0x2c>
  {
    hsd->ErrorCode |= errorstate;
 801096c:	687b      	ldr	r3, [r7, #4]
 801096e:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 8010970:	697b      	ldr	r3, [r7, #20]
 8010972:	431a      	orrs	r2, r3
 8010974:	687b      	ldr	r3, [r7, #4]
 8010976:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);
 8010978:	68fb      	ldr	r3, [r7, #12]
 801097a:	0a5b      	lsrs	r3, r3, #9
 801097c:	f003 030f 	and.w	r3, r3, #15
 8010980:	613b      	str	r3, [r7, #16]

  return (HAL_SD_CardStateTypeDef)cardstate;
 8010982:	693b      	ldr	r3, [r7, #16]
}
 8010984:	4618      	mov	r0, r3
 8010986:	3718      	adds	r7, #24
 8010988:	46bd      	mov	sp, r7
 801098a:	bd80      	pop	{r7, pc}

0801098c <SD_DMATransmitCplt>:
  * @brief  DMA SD transmit process complete callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 801098c:	b480      	push	{r7}
 801098e:	b085      	sub	sp, #20
 8010990:	af00      	add	r7, sp, #0
 8010992:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8010994:	687b      	ldr	r3, [r7, #4]
 8010996:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010998:	60fb      	str	r3, [r7, #12]

  /* Enable DATAEND Interrupt */
  __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DATAEND));
 801099a:	68fb      	ldr	r3, [r7, #12]
 801099c:	681b      	ldr	r3, [r3, #0]
 801099e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80109a0:	68fb      	ldr	r3, [r7, #12]
 80109a2:	681b      	ldr	r3, [r3, #0]
 80109a4:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80109a8:	63da      	str	r2, [r3, #60]	@ 0x3c
}
 80109aa:	bf00      	nop
 80109ac:	3714      	adds	r7, #20
 80109ae:	46bd      	mov	sp, r7
 80109b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80109b4:	4770      	bx	lr

080109b6 <SD_DMAReceiveCplt>:
  * @brief  DMA SD receive process complete callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 80109b6:	b580      	push	{r7, lr}
 80109b8:	b084      	sub	sp, #16
 80109ba:	af00      	add	r7, sp, #0
 80109bc:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 80109be:	687b      	ldr	r3, [r7, #4]
 80109c0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80109c2:	60fb      	str	r3, [r7, #12]
  uint32_t errorstate;

  /* Send stop command in multiblock write */
  if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
 80109c4:	68fb      	ldr	r3, [r7, #12]
 80109c6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80109c8:	2b82      	cmp	r3, #130	@ 0x82
 80109ca:	d111      	bne.n	80109f0 <SD_DMAReceiveCplt+0x3a>
  {
    errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 80109cc:	68fb      	ldr	r3, [r7, #12]
 80109ce:	681b      	ldr	r3, [r3, #0]
 80109d0:	4618      	mov	r0, r3
 80109d2:	f002 fc3b 	bl	801324c <SDMMC_CmdStopTransfer>
 80109d6:	60b8      	str	r0, [r7, #8]
    if(errorstate != HAL_SD_ERROR_NONE)
 80109d8:	68bb      	ldr	r3, [r7, #8]
 80109da:	2b00      	cmp	r3, #0
 80109dc:	d008      	beq.n	80109f0 <SD_DMAReceiveCplt+0x3a>
    {
      hsd->ErrorCode |= errorstate;
 80109de:	68fb      	ldr	r3, [r7, #12]
 80109e0:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 80109e2:	68bb      	ldr	r3, [r7, #8]
 80109e4:	431a      	orrs	r2, r3
 80109e6:	68fb      	ldr	r3, [r7, #12]
 80109e8:	639a      	str	r2, [r3, #56]	@ 0x38
#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
      hsd->ErrorCallback(hsd);
#else
      HAL_SD_ErrorCallback(hsd);
 80109ea:	68f8      	ldr	r0, [r7, #12]
 80109ec:	f7ff fd30 	bl	8010450 <HAL_SD_ErrorCallback>
    }
  }

  /* Disable the DMA transfer for transmit request by setting the DMAEN bit
  in the SD DCTRL register */
  hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
 80109f0:	68fb      	ldr	r3, [r7, #12]
 80109f2:	681b      	ldr	r3, [r3, #0]
 80109f4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80109f6:	68fb      	ldr	r3, [r7, #12]
 80109f8:	681b      	ldr	r3, [r3, #0]
 80109fa:	f022 0208 	bic.w	r2, r2, #8
 80109fe:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Clear all the static flags */
  __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 8010a00:	68fb      	ldr	r3, [r7, #12]
 8010a02:	681b      	ldr	r3, [r3, #0]
 8010a04:	f240 523a 	movw	r2, #1338	@ 0x53a
 8010a08:	639a      	str	r2, [r3, #56]	@ 0x38

  hsd->State = HAL_SD_STATE_READY;
 8010a0a:	68fb      	ldr	r3, [r7, #12]
 8010a0c:	2201      	movs	r2, #1
 8010a0e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hsd->Context = SD_CONTEXT_NONE;
 8010a12:	68fb      	ldr	r3, [r7, #12]
 8010a14:	2200      	movs	r2, #0
 8010a16:	631a      	str	r2, [r3, #48]	@ 0x30

#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
  hsd->RxCpltCallback(hsd);
#else
  HAL_SD_RxCpltCallback(hsd);
 8010a18:	68f8      	ldr	r0, [r7, #12]
 8010a1a:	f7f7 fa83 	bl	8007f24 <HAL_SD_RxCpltCallback>
#endif
}
 8010a1e:	bf00      	nop
 8010a20:	3710      	adds	r7, #16
 8010a22:	46bd      	mov	sp, r7
 8010a24:	bd80      	pop	{r7, pc}
	...

08010a28 <SD_DMAError>:
  * @brief  DMA SD communication error callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMAError(DMA_HandleTypeDef *hdma)
{
 8010a28:	b580      	push	{r7, lr}
 8010a2a:	b086      	sub	sp, #24
 8010a2c:	af00      	add	r7, sp, #0
 8010a2e:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8010a30:	687b      	ldr	r3, [r7, #4]
 8010a32:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010a34:	617b      	str	r3, [r7, #20]
  HAL_SD_CardStateTypeDef CardState;
  uint32_t RxErrorCode, TxErrorCode;

  /* if DMA error is FIFO error ignore it */
  if(HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
 8010a36:	6878      	ldr	r0, [r7, #4]
 8010a38:	f7f8 fe26 	bl	8009688 <HAL_DMA_GetError>
 8010a3c:	4603      	mov	r3, r0
 8010a3e:	2b02      	cmp	r3, #2
 8010a40:	d03e      	beq.n	8010ac0 <SD_DMAError+0x98>
  {
    RxErrorCode = hsd->hdmarx->ErrorCode;
 8010a42:	697b      	ldr	r3, [r7, #20]
 8010a44:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8010a46:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8010a48:	613b      	str	r3, [r7, #16]
    TxErrorCode = hsd->hdmatx->ErrorCode;  
 8010a4a:	697b      	ldr	r3, [r7, #20]
 8010a4c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8010a4e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8010a50:	60fb      	str	r3, [r7, #12]
    if((RxErrorCode == HAL_DMA_ERROR_TE) || (TxErrorCode == HAL_DMA_ERROR_TE))
 8010a52:	693b      	ldr	r3, [r7, #16]
 8010a54:	2b01      	cmp	r3, #1
 8010a56:	d002      	beq.n	8010a5e <SD_DMAError+0x36>
 8010a58:	68fb      	ldr	r3, [r7, #12]
 8010a5a:	2b01      	cmp	r3, #1
 8010a5c:	d12d      	bne.n	8010aba <SD_DMAError+0x92>
    {
      /* Clear All flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
 8010a5e:	697b      	ldr	r3, [r7, #20]
 8010a60:	681b      	ldr	r3, [r3, #0]
 8010a62:	4a19      	ldr	r2, [pc, #100]	@ (8010ac8 <SD_DMAError+0xa0>)
 8010a64:	639a      	str	r2, [r3, #56]	@ 0x38

      /* Disable All interrupts */
      __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
 8010a66:	697b      	ldr	r3, [r7, #20]
 8010a68:	681b      	ldr	r3, [r3, #0]
 8010a6a:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8010a6c:	697b      	ldr	r3, [r7, #20]
 8010a6e:	681b      	ldr	r3, [r3, #0]
 8010a70:	f422 729d 	bic.w	r2, r2, #314	@ 0x13a
 8010a74:	63da      	str	r2, [r3, #60]	@ 0x3c
        SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);

      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
 8010a76:	697b      	ldr	r3, [r7, #20]
 8010a78:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010a7a:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8010a7e:	697b      	ldr	r3, [r7, #20]
 8010a80:	639a      	str	r2, [r3, #56]	@ 0x38
      CardState = HAL_SD_GetCardState(hsd);
 8010a82:	6978      	ldr	r0, [r7, #20]
 8010a84:	f7ff ff62 	bl	801094c <HAL_SD_GetCardState>
 8010a88:	60b8      	str	r0, [r7, #8]
      if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 8010a8a:	68bb      	ldr	r3, [r7, #8]
 8010a8c:	2b06      	cmp	r3, #6
 8010a8e:	d002      	beq.n	8010a96 <SD_DMAError+0x6e>
 8010a90:	68bb      	ldr	r3, [r7, #8]
 8010a92:	2b05      	cmp	r3, #5
 8010a94:	d10a      	bne.n	8010aac <SD_DMAError+0x84>
      {
        hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8010a96:	697b      	ldr	r3, [r7, #20]
 8010a98:	681b      	ldr	r3, [r3, #0]
 8010a9a:	4618      	mov	r0, r3
 8010a9c:	f002 fbd6 	bl	801324c <SDMMC_CmdStopTransfer>
 8010aa0:	4602      	mov	r2, r0
 8010aa2:	697b      	ldr	r3, [r7, #20]
 8010aa4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010aa6:	431a      	orrs	r2, r3
 8010aa8:	697b      	ldr	r3, [r7, #20]
 8010aaa:	639a      	str	r2, [r3, #56]	@ 0x38
      }

      hsd->State= HAL_SD_STATE_READY;
 8010aac:	697b      	ldr	r3, [r7, #20]
 8010aae:	2201      	movs	r2, #1
 8010ab0:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8010ab4:	697b      	ldr	r3, [r7, #20]
 8010ab6:	2200      	movs	r2, #0
 8010ab8:	631a      	str	r2, [r3, #48]	@ 0x30
    }

#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
    hsd->ErrorCallback(hsd);
#else
    HAL_SD_ErrorCallback(hsd);
 8010aba:	6978      	ldr	r0, [r7, #20]
 8010abc:	f7ff fcc8 	bl	8010450 <HAL_SD_ErrorCallback>
#endif
  }
}
 8010ac0:	bf00      	nop
 8010ac2:	3718      	adds	r7, #24
 8010ac4:	46bd      	mov	sp, r7
 8010ac6:	bd80      	pop	{r7, pc}
 8010ac8:	004005ff 	.word	0x004005ff

08010acc <SD_DMATxAbort>:
  * @brief  DMA SD Tx Abort callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMATxAbort(DMA_HandleTypeDef *hdma)
{
 8010acc:	b580      	push	{r7, lr}
 8010ace:	b084      	sub	sp, #16
 8010ad0:	af00      	add	r7, sp, #0
 8010ad2:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8010ad4:	687b      	ldr	r3, [r7, #4]
 8010ad6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010ad8:	60fb      	str	r3, [r7, #12]
  HAL_SD_CardStateTypeDef CardState;

  /* Clear All flags */
  __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 8010ada:	68fb      	ldr	r3, [r7, #12]
 8010adc:	681b      	ldr	r3, [r3, #0]
 8010ade:	f240 523a 	movw	r2, #1338	@ 0x53a
 8010ae2:	639a      	str	r2, [r3, #56]	@ 0x38

  CardState = HAL_SD_GetCardState(hsd);
 8010ae4:	68f8      	ldr	r0, [r7, #12]
 8010ae6:	f7ff ff31 	bl	801094c <HAL_SD_GetCardState>
 8010aea:	60b8      	str	r0, [r7, #8]
  hsd->State = HAL_SD_STATE_READY;
 8010aec:	68fb      	ldr	r3, [r7, #12]
 8010aee:	2201      	movs	r2, #1
 8010af0:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hsd->Context = SD_CONTEXT_NONE;
 8010af4:	68fb      	ldr	r3, [r7, #12]
 8010af6:	2200      	movs	r2, #0
 8010af8:	631a      	str	r2, [r3, #48]	@ 0x30
  if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 8010afa:	68bb      	ldr	r3, [r7, #8]
 8010afc:	2b06      	cmp	r3, #6
 8010afe:	d002      	beq.n	8010b06 <SD_DMATxAbort+0x3a>
 8010b00:	68bb      	ldr	r3, [r7, #8]
 8010b02:	2b05      	cmp	r3, #5
 8010b04:	d10a      	bne.n	8010b1c <SD_DMATxAbort+0x50>
  {
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8010b06:	68fb      	ldr	r3, [r7, #12]
 8010b08:	681b      	ldr	r3, [r3, #0]
 8010b0a:	4618      	mov	r0, r3
 8010b0c:	f002 fb9e 	bl	801324c <SDMMC_CmdStopTransfer>
 8010b10:	4602      	mov	r2, r0
 8010b12:	68fb      	ldr	r3, [r7, #12]
 8010b14:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b16:	431a      	orrs	r2, r3
 8010b18:	68fb      	ldr	r3, [r7, #12]
 8010b1a:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  if(hsd->ErrorCode == HAL_SD_ERROR_NONE)
 8010b1c:	68fb      	ldr	r3, [r7, #12]
 8010b1e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b20:	2b00      	cmp	r3, #0
 8010b22:	d103      	bne.n	8010b2c <SD_DMATxAbort+0x60>
  {
#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
    hsd->AbortCpltCallback(hsd);
#else
    HAL_SD_AbortCallback(hsd);
 8010b24:	68f8      	ldr	r0, [r7, #12]
 8010b26:	f7ff fc9d 	bl	8010464 <HAL_SD_AbortCallback>
    hsd->ErrorCallback(hsd);
#else
    HAL_SD_ErrorCallback(hsd);
#endif
  }
}
 8010b2a:	e002      	b.n	8010b32 <SD_DMATxAbort+0x66>
    HAL_SD_ErrorCallback(hsd);
 8010b2c:	68f8      	ldr	r0, [r7, #12]
 8010b2e:	f7ff fc8f 	bl	8010450 <HAL_SD_ErrorCallback>
}
 8010b32:	bf00      	nop
 8010b34:	3710      	adds	r7, #16
 8010b36:	46bd      	mov	sp, r7
 8010b38:	bd80      	pop	{r7, pc}

08010b3a <SD_DMARxAbort>:
  * @brief  DMA SD Rx Abort callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMARxAbort(DMA_HandleTypeDef *hdma)
{
 8010b3a:	b580      	push	{r7, lr}
 8010b3c:	b084      	sub	sp, #16
 8010b3e:	af00      	add	r7, sp, #0
 8010b40:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
 8010b42:	687b      	ldr	r3, [r7, #4]
 8010b44:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b46:	60fb      	str	r3, [r7, #12]
  HAL_SD_CardStateTypeDef CardState;

  /* Clear All flags */
  __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 8010b48:	68fb      	ldr	r3, [r7, #12]
 8010b4a:	681b      	ldr	r3, [r3, #0]
 8010b4c:	f240 523a 	movw	r2, #1338	@ 0x53a
 8010b50:	639a      	str	r2, [r3, #56]	@ 0x38

  CardState = HAL_SD_GetCardState(hsd);
 8010b52:	68f8      	ldr	r0, [r7, #12]
 8010b54:	f7ff fefa 	bl	801094c <HAL_SD_GetCardState>
 8010b58:	60b8      	str	r0, [r7, #8]
  hsd->State = HAL_SD_STATE_READY;
 8010b5a:	68fb      	ldr	r3, [r7, #12]
 8010b5c:	2201      	movs	r2, #1
 8010b5e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
  hsd->Context = SD_CONTEXT_NONE;
 8010b62:	68fb      	ldr	r3, [r7, #12]
 8010b64:	2200      	movs	r2, #0
 8010b66:	631a      	str	r2, [r3, #48]	@ 0x30
  if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
 8010b68:	68bb      	ldr	r3, [r7, #8]
 8010b6a:	2b06      	cmp	r3, #6
 8010b6c:	d002      	beq.n	8010b74 <SD_DMARxAbort+0x3a>
 8010b6e:	68bb      	ldr	r3, [r7, #8]
 8010b70:	2b05      	cmp	r3, #5
 8010b72:	d10a      	bne.n	8010b8a <SD_DMARxAbort+0x50>
  {
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
 8010b74:	68fb      	ldr	r3, [r7, #12]
 8010b76:	681b      	ldr	r3, [r3, #0]
 8010b78:	4618      	mov	r0, r3
 8010b7a:	f002 fb67 	bl	801324c <SDMMC_CmdStopTransfer>
 8010b7e:	4602      	mov	r2, r0
 8010b80:	68fb      	ldr	r3, [r7, #12]
 8010b82:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b84:	431a      	orrs	r2, r3
 8010b86:	68fb      	ldr	r3, [r7, #12]
 8010b88:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  if(hsd->ErrorCode == HAL_SD_ERROR_NONE)
 8010b8a:	68fb      	ldr	r3, [r7, #12]
 8010b8c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8010b8e:	2b00      	cmp	r3, #0
 8010b90:	d103      	bne.n	8010b9a <SD_DMARxAbort+0x60>
  {
#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
    hsd->AbortCpltCallback(hsd);
#else
    HAL_SD_AbortCallback(hsd);
 8010b92:	68f8      	ldr	r0, [r7, #12]
 8010b94:	f7ff fc66 	bl	8010464 <HAL_SD_AbortCallback>
    hsd->ErrorCallback(hsd);
#else
    HAL_SD_ErrorCallback(hsd);
#endif
  }
}
 8010b98:	e002      	b.n	8010ba0 <SD_DMARxAbort+0x66>
    HAL_SD_ErrorCallback(hsd);
 8010b9a:	68f8      	ldr	r0, [r7, #12]
 8010b9c:	f7ff fc58 	bl	8010450 <HAL_SD_ErrorCallback>
}
 8010ba0:	bf00      	nop
 8010ba2:	3710      	adds	r7, #16
 8010ba4:	46bd      	mov	sp, r7
 8010ba6:	bd80      	pop	{r7, pc}

08010ba8 <SD_InitCard>:
  * @brief  Initializes the sd card.
  * @param  hsd: Pointer to SD handle
  * @retval SD Card error state
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
 8010ba8:	b5b0      	push	{r4, r5, r7, lr}
 8010baa:	b094      	sub	sp, #80	@ 0x50
 8010bac:	af04      	add	r7, sp, #16
 8010bae:	6078      	str	r0, [r7, #4]
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 1U;
 8010bb0:	2301      	movs	r3, #1
 8010bb2:	81fb      	strh	r3, [r7, #14]

  /* Check the power State */
  if(SDIO_GetPowerState(hsd->Instance) == 0U)
 8010bb4:	687b      	ldr	r3, [r7, #4]
 8010bb6:	681b      	ldr	r3, [r3, #0]
 8010bb8:	4618      	mov	r0, r3
 8010bba:	f002 fa19 	bl	8012ff0 <SDIO_GetPowerState>
 8010bbe:	4603      	mov	r3, r0
 8010bc0:	2b00      	cmp	r3, #0
 8010bc2:	d102      	bne.n	8010bca <SD_InitCard+0x22>
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8010bc4:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
 8010bc8:	e0b8      	b.n	8010d3c <SD_InitCard+0x194>
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
 8010bca:	687b      	ldr	r3, [r7, #4]
 8010bcc:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010bce:	2b03      	cmp	r3, #3
 8010bd0:	d02f      	beq.n	8010c32 <SD_InitCard+0x8a>
  {
    /* Send CMD2 ALL_SEND_CID */
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 8010bd2:	687b      	ldr	r3, [r7, #4]
 8010bd4:	681b      	ldr	r3, [r3, #0]
 8010bd6:	4618      	mov	r0, r3
 8010bd8:	f002 fc42 	bl	8013460 <SDMMC_CmdSendCID>
 8010bdc:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if(errorstate != HAL_SD_ERROR_NONE)
 8010bde:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010be0:	2b00      	cmp	r3, #0
 8010be2:	d001      	beq.n	8010be8 <SD_InitCard+0x40>
    {
      return errorstate;
 8010be4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010be6:	e0a9      	b.n	8010d3c <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8010be8:	687b      	ldr	r3, [r7, #4]
 8010bea:	681b      	ldr	r3, [r3, #0]
 8010bec:	2100      	movs	r1, #0
 8010bee:	4618      	mov	r0, r3
 8010bf0:	f002 fa43 	bl	801307a <SDIO_GetResponse>
 8010bf4:	4602      	mov	r2, r0
 8010bf6:	687b      	ldr	r3, [r7, #4]
 8010bf8:	675a      	str	r2, [r3, #116]	@ 0x74
      hsd->CID[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 8010bfa:	687b      	ldr	r3, [r7, #4]
 8010bfc:	681b      	ldr	r3, [r3, #0]
 8010bfe:	2104      	movs	r1, #4
 8010c00:	4618      	mov	r0, r3
 8010c02:	f002 fa3a 	bl	801307a <SDIO_GetResponse>
 8010c06:	4602      	mov	r2, r0
 8010c08:	687b      	ldr	r3, [r7, #4]
 8010c0a:	679a      	str	r2, [r3, #120]	@ 0x78
      hsd->CID[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 8010c0c:	687b      	ldr	r3, [r7, #4]
 8010c0e:	681b      	ldr	r3, [r3, #0]
 8010c10:	2108      	movs	r1, #8
 8010c12:	4618      	mov	r0, r3
 8010c14:	f002 fa31 	bl	801307a <SDIO_GetResponse>
 8010c18:	4602      	mov	r2, r0
 8010c1a:	687b      	ldr	r3, [r7, #4]
 8010c1c:	67da      	str	r2, [r3, #124]	@ 0x7c
      hsd->CID[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 8010c1e:	687b      	ldr	r3, [r7, #4]
 8010c20:	681b      	ldr	r3, [r3, #0]
 8010c22:	210c      	movs	r1, #12
 8010c24:	4618      	mov	r0, r3
 8010c26:	f002 fa28 	bl	801307a <SDIO_GetResponse>
 8010c2a:	4602      	mov	r2, r0
 8010c2c:	687b      	ldr	r3, [r7, #4]
 8010c2e:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
    }
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
 8010c32:	687b      	ldr	r3, [r7, #4]
 8010c34:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010c36:	2b03      	cmp	r3, #3
 8010c38:	d00d      	beq.n	8010c56 <SD_InitCard+0xae>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 8010c3a:	687b      	ldr	r3, [r7, #4]
 8010c3c:	681b      	ldr	r3, [r3, #0]
 8010c3e:	f107 020e 	add.w	r2, r7, #14
 8010c42:	4611      	mov	r1, r2
 8010c44:	4618      	mov	r0, r3
 8010c46:	f002 fc48 	bl	80134da <SDMMC_CmdSetRelAdd>
 8010c4a:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if(errorstate != HAL_SD_ERROR_NONE)
 8010c4c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010c4e:	2b00      	cmp	r3, #0
 8010c50:	d001      	beq.n	8010c56 <SD_InitCard+0xae>
    {
      return errorstate;
 8010c52:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010c54:	e072      	b.n	8010d3c <SD_InitCard+0x194>
    }
  }
  if(hsd->SdCard.CardType != CARD_SECURED)
 8010c56:	687b      	ldr	r3, [r7, #4]
 8010c58:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8010c5a:	2b03      	cmp	r3, #3
 8010c5c:	d036      	beq.n	8010ccc <SD_InitCard+0x124>
  {
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;
 8010c5e:	89fb      	ldrh	r3, [r7, #14]
 8010c60:	461a      	mov	r2, r3
 8010c62:	687b      	ldr	r3, [r7, #4]
 8010c64:	651a      	str	r2, [r3, #80]	@ 0x50

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8010c66:	687b      	ldr	r3, [r7, #4]
 8010c68:	681a      	ldr	r2, [r3, #0]
 8010c6a:	687b      	ldr	r3, [r7, #4]
 8010c6c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8010c6e:	041b      	lsls	r3, r3, #16
 8010c70:	4619      	mov	r1, r3
 8010c72:	4610      	mov	r0, r2
 8010c74:	f002 fc12 	bl	801349c <SDMMC_CmdSendCSD>
 8010c78:	63f8      	str	r0, [r7, #60]	@ 0x3c
    if(errorstate != HAL_SD_ERROR_NONE)
 8010c7a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010c7c:	2b00      	cmp	r3, #0
 8010c7e:	d001      	beq.n	8010c84 <SD_InitCard+0xdc>
    {
      return errorstate;
 8010c80:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010c82:	e05b      	b.n	8010d3c <SD_InitCard+0x194>
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8010c84:	687b      	ldr	r3, [r7, #4]
 8010c86:	681b      	ldr	r3, [r3, #0]
 8010c88:	2100      	movs	r1, #0
 8010c8a:	4618      	mov	r0, r3
 8010c8c:	f002 f9f5 	bl	801307a <SDIO_GetResponse>
 8010c90:	4602      	mov	r2, r0
 8010c92:	687b      	ldr	r3, [r7, #4]
 8010c94:	665a      	str	r2, [r3, #100]	@ 0x64
      hsd->CSD[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
 8010c96:	687b      	ldr	r3, [r7, #4]
 8010c98:	681b      	ldr	r3, [r3, #0]
 8010c9a:	2104      	movs	r1, #4
 8010c9c:	4618      	mov	r0, r3
 8010c9e:	f002 f9ec 	bl	801307a <SDIO_GetResponse>
 8010ca2:	4602      	mov	r2, r0
 8010ca4:	687b      	ldr	r3, [r7, #4]
 8010ca6:	669a      	str	r2, [r3, #104]	@ 0x68
      hsd->CSD[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
 8010ca8:	687b      	ldr	r3, [r7, #4]
 8010caa:	681b      	ldr	r3, [r3, #0]
 8010cac:	2108      	movs	r1, #8
 8010cae:	4618      	mov	r0, r3
 8010cb0:	f002 f9e3 	bl	801307a <SDIO_GetResponse>
 8010cb4:	4602      	mov	r2, r0
 8010cb6:	687b      	ldr	r3, [r7, #4]
 8010cb8:	66da      	str	r2, [r3, #108]	@ 0x6c
      hsd->CSD[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
 8010cba:	687b      	ldr	r3, [r7, #4]
 8010cbc:	681b      	ldr	r3, [r3, #0]
 8010cbe:	210c      	movs	r1, #12
 8010cc0:	4618      	mov	r0, r3
 8010cc2:	f002 f9da 	bl	801307a <SDIO_GetResponse>
 8010cc6:	4602      	mov	r2, r0
 8010cc8:	687b      	ldr	r3, [r7, #4]
 8010cca:	671a      	str	r2, [r3, #112]	@ 0x70
    }
  }

  /* Get the Card Class */
  hsd->SdCard.Class = (SDIO_GetResponse(hsd->Instance, SDIO_RESP2) >> 20U);
 8010ccc:	687b      	ldr	r3, [r7, #4]
 8010cce:	681b      	ldr	r3, [r3, #0]
 8010cd0:	2104      	movs	r1, #4
 8010cd2:	4618      	mov	r0, r3
 8010cd4:	f002 f9d1 	bl	801307a <SDIO_GetResponse>
 8010cd8:	4603      	mov	r3, r0
 8010cda:	0d1a      	lsrs	r2, r3, #20
 8010cdc:	687b      	ldr	r3, [r7, #4]
 8010cde:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 8010ce0:	f107 0310 	add.w	r3, r7, #16
 8010ce4:	4619      	mov	r1, r3
 8010ce6:	6878      	ldr	r0, [r7, #4]
 8010ce8:	f7ff fbc6 	bl	8010478 <HAL_SD_GetCardCSD>
 8010cec:	4603      	mov	r3, r0
 8010cee:	2b00      	cmp	r3, #0
 8010cf0:	d002      	beq.n	8010cf8 <SD_InitCard+0x150>
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8010cf2:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8010cf6:	e021      	b.n	8010d3c <SD_InitCard+0x194>
  }

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 8010cf8:	687b      	ldr	r3, [r7, #4]
 8010cfa:	6819      	ldr	r1, [r3, #0]
 8010cfc:	687b      	ldr	r3, [r7, #4]
 8010cfe:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8010d00:	041b      	lsls	r3, r3, #16
 8010d02:	2200      	movs	r2, #0
 8010d04:	461c      	mov	r4, r3
 8010d06:	4615      	mov	r5, r2
 8010d08:	4622      	mov	r2, r4
 8010d0a:	462b      	mov	r3, r5
 8010d0c:	4608      	mov	r0, r1
 8010d0e:	f002 fabf 	bl	8013290 <SDMMC_CmdSelDesel>
 8010d12:	63f8      	str	r0, [r7, #60]	@ 0x3c
  if(errorstate != HAL_SD_ERROR_NONE)
 8010d14:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010d16:	2b00      	cmp	r3, #0
 8010d18:	d001      	beq.n	8010d1e <SD_InitCard+0x176>
  {
    return errorstate;
 8010d1a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8010d1c:	e00e      	b.n	8010d3c <SD_InitCard+0x194>
  }

  /* Configure SDIO peripheral interface */
  (void)SDIO_Init(hsd->Instance, hsd->Init);
 8010d1e:	687b      	ldr	r3, [r7, #4]
 8010d20:	681d      	ldr	r5, [r3, #0]
 8010d22:	687b      	ldr	r3, [r7, #4]
 8010d24:	466c      	mov	r4, sp
 8010d26:	f103 0210 	add.w	r2, r3, #16
 8010d2a:	ca07      	ldmia	r2, {r0, r1, r2}
 8010d2c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 8010d30:	3304      	adds	r3, #4
 8010d32:	cb0e      	ldmia	r3, {r1, r2, r3}
 8010d34:	4628      	mov	r0, r5
 8010d36:	f002 f904 	bl	8012f42 <SDIO_Init>

  /* All cards are initialized */
  return HAL_SD_ERROR_NONE;
 8010d3a:	2300      	movs	r3, #0
}
 8010d3c:	4618      	mov	r0, r3
 8010d3e:	3740      	adds	r7, #64	@ 0x40
 8010d40:	46bd      	mov	sp, r7
 8010d42:	bdb0      	pop	{r4, r5, r7, pc}

08010d44 <SD_PowerON>:
  *         in the SD handle.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
 8010d44:	b580      	push	{r7, lr}
 8010d46:	b086      	sub	sp, #24
 8010d48:	af00      	add	r7, sp, #0
 8010d4a:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8010d4c:	2300      	movs	r3, #0
 8010d4e:	60bb      	str	r3, [r7, #8]
  uint32_t response = 0U, validvoltage = 0U;
 8010d50:	2300      	movs	r3, #0
 8010d52:	617b      	str	r3, [r7, #20]
 8010d54:	2300      	movs	r3, #0
 8010d56:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8010d58:	687b      	ldr	r3, [r7, #4]
 8010d5a:	681b      	ldr	r3, [r3, #0]
 8010d5c:	4618      	mov	r0, r3
 8010d5e:	f002 faba 	bl	80132d6 <SDMMC_CmdGoIdleState>
 8010d62:	60f8      	str	r0, [r7, #12]
  if(errorstate != HAL_SD_ERROR_NONE)
 8010d64:	68fb      	ldr	r3, [r7, #12]
 8010d66:	2b00      	cmp	r3, #0
 8010d68:	d001      	beq.n	8010d6e <SD_PowerON+0x2a>
  {
    return errorstate;
 8010d6a:	68fb      	ldr	r3, [r7, #12]
 8010d6c:	e072      	b.n	8010e54 <SD_PowerON+0x110>
  }

  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 8010d6e:	687b      	ldr	r3, [r7, #4]
 8010d70:	681b      	ldr	r3, [r3, #0]
 8010d72:	4618      	mov	r0, r3
 8010d74:	f002 facd 	bl	8013312 <SDMMC_CmdOperCond>
 8010d78:	60f8      	str	r0, [r7, #12]
  if(errorstate != HAL_SD_ERROR_NONE)
 8010d7a:	68fb      	ldr	r3, [r7, #12]
 8010d7c:	2b00      	cmp	r3, #0
 8010d7e:	d00d      	beq.n	8010d9c <SD_PowerON+0x58>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
 8010d80:	687b      	ldr	r3, [r7, #4]
 8010d82:	2200      	movs	r2, #0
 8010d84:	649a      	str	r2, [r3, #72]	@ 0x48
    /* CMD0: GO_IDLE_STATE */
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8010d86:	687b      	ldr	r3, [r7, #4]
 8010d88:	681b      	ldr	r3, [r3, #0]
 8010d8a:	4618      	mov	r0, r3
 8010d8c:	f002 faa3 	bl	80132d6 <SDMMC_CmdGoIdleState>
 8010d90:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010d92:	68fb      	ldr	r3, [r7, #12]
 8010d94:	2b00      	cmp	r3, #0
 8010d96:	d004      	beq.n	8010da2 <SD_PowerON+0x5e>
    {
      return errorstate;
 8010d98:	68fb      	ldr	r3, [r7, #12]
 8010d9a:	e05b      	b.n	8010e54 <SD_PowerON+0x110>
    }

  }
  else
  {
    hsd->SdCard.CardVersion = CARD_V2_X;
 8010d9c:	687b      	ldr	r3, [r7, #4]
 8010d9e:	2201      	movs	r2, #1
 8010da0:	649a      	str	r2, [r3, #72]	@ 0x48
  }

  if( hsd->SdCard.CardVersion == CARD_V2_X)
 8010da2:	687b      	ldr	r3, [r7, #4]
 8010da4:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8010da6:	2b01      	cmp	r3, #1
 8010da8:	d137      	bne.n	8010e1a <SD_PowerON+0xd6>
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8010daa:	687b      	ldr	r3, [r7, #4]
 8010dac:	681b      	ldr	r3, [r3, #0]
 8010dae:	2100      	movs	r1, #0
 8010db0:	4618      	mov	r0, r3
 8010db2:	f002 facd 	bl	8013350 <SDMMC_CmdAppCommand>
 8010db6:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010db8:	68fb      	ldr	r3, [r7, #12]
 8010dba:	2b00      	cmp	r3, #0
 8010dbc:	d02d      	beq.n	8010e1a <SD_PowerON+0xd6>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8010dbe:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8010dc2:	e047      	b.n	8010e54 <SD_PowerON+0x110>
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8010dc4:	687b      	ldr	r3, [r7, #4]
 8010dc6:	681b      	ldr	r3, [r3, #0]
 8010dc8:	2100      	movs	r1, #0
 8010dca:	4618      	mov	r0, r3
 8010dcc:	f002 fac0 	bl	8013350 <SDMMC_CmdAppCommand>
 8010dd0:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010dd2:	68fb      	ldr	r3, [r7, #12]
 8010dd4:	2b00      	cmp	r3, #0
 8010dd6:	d001      	beq.n	8010ddc <SD_PowerON+0x98>
    {
      return errorstate;
 8010dd8:	68fb      	ldr	r3, [r7, #12]
 8010dda:	e03b      	b.n	8010e54 <SD_PowerON+0x110>
    }

    /* Send CMD41 */
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 8010ddc:	687b      	ldr	r3, [r7, #4]
 8010dde:	681b      	ldr	r3, [r3, #0]
 8010de0:	491e      	ldr	r1, [pc, #120]	@ (8010e5c <SD_PowerON+0x118>)
 8010de2:	4618      	mov	r0, r3
 8010de4:	f002 fad6 	bl	8013394 <SDMMC_CmdAppOperCommand>
 8010de8:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010dea:	68fb      	ldr	r3, [r7, #12]
 8010dec:	2b00      	cmp	r3, #0
 8010dee:	d002      	beq.n	8010df6 <SD_PowerON+0xb2>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 8010df0:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
 8010df4:	e02e      	b.n	8010e54 <SD_PowerON+0x110>
    }

    /* Get command response */
    response = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8010df6:	687b      	ldr	r3, [r7, #4]
 8010df8:	681b      	ldr	r3, [r3, #0]
 8010dfa:	2100      	movs	r1, #0
 8010dfc:	4618      	mov	r0, r3
 8010dfe:	f002 f93c 	bl	801307a <SDIO_GetResponse>
 8010e02:	6178      	str	r0, [r7, #20]

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
 8010e04:	697b      	ldr	r3, [r7, #20]
 8010e06:	0fdb      	lsrs	r3, r3, #31
 8010e08:	2b01      	cmp	r3, #1
 8010e0a:	d101      	bne.n	8010e10 <SD_PowerON+0xcc>
 8010e0c:	2301      	movs	r3, #1
 8010e0e:	e000      	b.n	8010e12 <SD_PowerON+0xce>
 8010e10:	2300      	movs	r3, #0
 8010e12:	613b      	str	r3, [r7, #16]

    count++;
 8010e14:	68bb      	ldr	r3, [r7, #8]
 8010e16:	3301      	adds	r3, #1
 8010e18:	60bb      	str	r3, [r7, #8]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 8010e1a:	68bb      	ldr	r3, [r7, #8]
 8010e1c:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
 8010e20:	4293      	cmp	r3, r2
 8010e22:	d802      	bhi.n	8010e2a <SD_PowerON+0xe6>
 8010e24:	693b      	ldr	r3, [r7, #16]
 8010e26:	2b00      	cmp	r3, #0
 8010e28:	d0cc      	beq.n	8010dc4 <SD_PowerON+0x80>
  }

  if(count >= SDMMC_MAX_VOLT_TRIAL)
 8010e2a:	68bb      	ldr	r3, [r7, #8]
 8010e2c:	f64f 72fe 	movw	r2, #65534	@ 0xfffe
 8010e30:	4293      	cmp	r3, r2
 8010e32:	d902      	bls.n	8010e3a <SD_PowerON+0xf6>
  {
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 8010e34:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8010e38:	e00c      	b.n	8010e54 <SD_PowerON+0x110>
  }

  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8010e3a:	697b      	ldr	r3, [r7, #20]
 8010e3c:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 8010e40:	2b00      	cmp	r3, #0
 8010e42:	d003      	beq.n	8010e4c <SD_PowerON+0x108>
  {
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 8010e44:	687b      	ldr	r3, [r7, #4]
 8010e46:	2201      	movs	r2, #1
 8010e48:	645a      	str	r2, [r3, #68]	@ 0x44
 8010e4a:	e002      	b.n	8010e52 <SD_PowerON+0x10e>
  }
  else
  {
    hsd->SdCard.CardType = CARD_SDSC;
 8010e4c:	687b      	ldr	r3, [r7, #4]
 8010e4e:	2200      	movs	r2, #0
 8010e50:	645a      	str	r2, [r3, #68]	@ 0x44
  }


  return HAL_SD_ERROR_NONE;
 8010e52:	2300      	movs	r3, #0
}
 8010e54:	4618      	mov	r0, r3
 8010e56:	3718      	adds	r7, #24
 8010e58:	46bd      	mov	sp, r7
 8010e5a:	bd80      	pop	{r7, pc}
 8010e5c:	c1100000 	.word	0xc1100000

08010e60 <SD_SendStatus>:
  * @param  pCardStatus: pointer to the buffer that will contain the SD card
  *         status (Card Status register)
  * @retval error state
  */
static uint32_t SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
{
 8010e60:	b580      	push	{r7, lr}
 8010e62:	b084      	sub	sp, #16
 8010e64:	af00      	add	r7, sp, #0
 8010e66:	6078      	str	r0, [r7, #4]
 8010e68:	6039      	str	r1, [r7, #0]
  uint32_t errorstate;

  if(pCardStatus == NULL)
 8010e6a:	683b      	ldr	r3, [r7, #0]
 8010e6c:	2b00      	cmp	r3, #0
 8010e6e:	d102      	bne.n	8010e76 <SD_SendStatus+0x16>
  {
    return HAL_SD_ERROR_PARAM;
 8010e70:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8010e74:	e018      	b.n	8010ea8 <SD_SendStatus+0x48>
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8010e76:	687b      	ldr	r3, [r7, #4]
 8010e78:	681a      	ldr	r2, [r3, #0]
 8010e7a:	687b      	ldr	r3, [r7, #4]
 8010e7c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8010e7e:	041b      	lsls	r3, r3, #16
 8010e80:	4619      	mov	r1, r3
 8010e82:	4610      	mov	r0, r2
 8010e84:	f002 fb4a 	bl	801351c <SDMMC_CmdSendStatus>
 8010e88:	60f8      	str	r0, [r7, #12]
  if(errorstate != HAL_SD_ERROR_NONE)
 8010e8a:	68fb      	ldr	r3, [r7, #12]
 8010e8c:	2b00      	cmp	r3, #0
 8010e8e:	d001      	beq.n	8010e94 <SD_SendStatus+0x34>
  {
    return errorstate;
 8010e90:	68fb      	ldr	r3, [r7, #12]
 8010e92:	e009      	b.n	8010ea8 <SD_SendStatus+0x48>
  }

  /* Get SD card status */
  *pCardStatus = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
 8010e94:	687b      	ldr	r3, [r7, #4]
 8010e96:	681b      	ldr	r3, [r3, #0]
 8010e98:	2100      	movs	r1, #0
 8010e9a:	4618      	mov	r0, r3
 8010e9c:	f002 f8ed 	bl	801307a <SDIO_GetResponse>
 8010ea0:	4602      	mov	r2, r0
 8010ea2:	683b      	ldr	r3, [r7, #0]
 8010ea4:	601a      	str	r2, [r3, #0]

  return HAL_SD_ERROR_NONE;
 8010ea6:	2300      	movs	r3, #0
}
 8010ea8:	4618      	mov	r0, r3
 8010eaa:	3710      	adds	r7, #16
 8010eac:	46bd      	mov	sp, r7
 8010eae:	bd80      	pop	{r7, pc}

08010eb0 <SD_WideBus_Enable>:
  * @brief  Enables the SDIO wide bus mode.
  * @param  hsd: pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
 8010eb0:	b580      	push	{r7, lr}
 8010eb2:	b086      	sub	sp, #24
 8010eb4:	af00      	add	r7, sp, #0
 8010eb6:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0U, 0U};
 8010eb8:	2300      	movs	r3, #0
 8010eba:	60fb      	str	r3, [r7, #12]
 8010ebc:	2300      	movs	r3, #0
 8010ebe:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8010ec0:	687b      	ldr	r3, [r7, #4]
 8010ec2:	681b      	ldr	r3, [r3, #0]
 8010ec4:	2100      	movs	r1, #0
 8010ec6:	4618      	mov	r0, r3
 8010ec8:	f002 f8d7 	bl	801307a <SDIO_GetResponse>
 8010ecc:	4603      	mov	r3, r0
 8010ece:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8010ed2:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8010ed6:	d102      	bne.n	8010ede <SD_WideBus_Enable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8010ed8:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8010edc:	e02f      	b.n	8010f3e <SD_WideBus_Enable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 8010ede:	f107 030c 	add.w	r3, r7, #12
 8010ee2:	4619      	mov	r1, r3
 8010ee4:	6878      	ldr	r0, [r7, #4]
 8010ee6:	f000 f879 	bl	8010fdc <SD_FindSCR>
 8010eea:	6178      	str	r0, [r7, #20]
  if(errorstate != HAL_SD_ERROR_NONE)
 8010eec:	697b      	ldr	r3, [r7, #20]
 8010eee:	2b00      	cmp	r3, #0
 8010ef0:	d001      	beq.n	8010ef6 <SD_WideBus_Enable+0x46>
  {
    return errorstate;
 8010ef2:	697b      	ldr	r3, [r7, #20]
 8010ef4:	e023      	b.n	8010f3e <SD_WideBus_Enable+0x8e>
  }

  /* If requested card supports wide bus operation */
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8010ef6:	693b      	ldr	r3, [r7, #16]
 8010ef8:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8010efc:	2b00      	cmp	r3, #0
 8010efe:	d01c      	beq.n	8010f3a <SD_WideBus_Enable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8010f00:	687b      	ldr	r3, [r7, #4]
 8010f02:	681a      	ldr	r2, [r3, #0]
 8010f04:	687b      	ldr	r3, [r7, #4]
 8010f06:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8010f08:	041b      	lsls	r3, r3, #16
 8010f0a:	4619      	mov	r1, r3
 8010f0c:	4610      	mov	r0, r2
 8010f0e:	f002 fa1f 	bl	8013350 <SDMMC_CmdAppCommand>
 8010f12:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010f14:	697b      	ldr	r3, [r7, #20]
 8010f16:	2b00      	cmp	r3, #0
 8010f18:	d001      	beq.n	8010f1e <SD_WideBus_Enable+0x6e>
    {
      return errorstate;
 8010f1a:	697b      	ldr	r3, [r7, #20]
 8010f1c:	e00f      	b.n	8010f3e <SD_WideBus_Enable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 8010f1e:	687b      	ldr	r3, [r7, #4]
 8010f20:	681b      	ldr	r3, [r3, #0]
 8010f22:	2102      	movs	r1, #2
 8010f24:	4618      	mov	r0, r3
 8010f26:	f002 fa58 	bl	80133da <SDMMC_CmdBusWidth>
 8010f2a:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010f2c:	697b      	ldr	r3, [r7, #20]
 8010f2e:	2b00      	cmp	r3, #0
 8010f30:	d001      	beq.n	8010f36 <SD_WideBus_Enable+0x86>
    {
      return errorstate;
 8010f32:	697b      	ldr	r3, [r7, #20]
 8010f34:	e003      	b.n	8010f3e <SD_WideBus_Enable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
 8010f36:	2300      	movs	r3, #0
 8010f38:	e001      	b.n	8010f3e <SD_WideBus_Enable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8010f3a:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
 8010f3e:	4618      	mov	r0, r3
 8010f40:	3718      	adds	r7, #24
 8010f42:	46bd      	mov	sp, r7
 8010f44:	bd80      	pop	{r7, pc}

08010f46 <SD_WideBus_Disable>:
  * @brief  Disables the SDIO wide bus mode.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
 8010f46:	b580      	push	{r7, lr}
 8010f48:	b086      	sub	sp, #24
 8010f4a:	af00      	add	r7, sp, #0
 8010f4c:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0U, 0U};
 8010f4e:	2300      	movs	r3, #0
 8010f50:	60fb      	str	r3, [r7, #12]
 8010f52:	2300      	movs	r3, #0
 8010f54:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 8010f56:	687b      	ldr	r3, [r7, #4]
 8010f58:	681b      	ldr	r3, [r3, #0]
 8010f5a:	2100      	movs	r1, #0
 8010f5c:	4618      	mov	r0, r3
 8010f5e:	f002 f88c 	bl	801307a <SDIO_GetResponse>
 8010f62:	4603      	mov	r3, r0
 8010f64:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8010f68:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8010f6c:	d102      	bne.n	8010f74 <SD_WideBus_Disable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 8010f6e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8010f72:	e02f      	b.n	8010fd4 <SD_WideBus_Disable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
 8010f74:	f107 030c 	add.w	r3, r7, #12
 8010f78:	4619      	mov	r1, r3
 8010f7a:	6878      	ldr	r0, [r7, #4]
 8010f7c:	f000 f82e 	bl	8010fdc <SD_FindSCR>
 8010f80:	6178      	str	r0, [r7, #20]
  if(errorstate != HAL_SD_ERROR_NONE)
 8010f82:	697b      	ldr	r3, [r7, #20]
 8010f84:	2b00      	cmp	r3, #0
 8010f86:	d001      	beq.n	8010f8c <SD_WideBus_Disable+0x46>
  {
    return errorstate;
 8010f88:	697b      	ldr	r3, [r7, #20]
 8010f8a:	e023      	b.n	8010fd4 <SD_WideBus_Disable+0x8e>
  }

  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 8010f8c:	693b      	ldr	r3, [r7, #16]
 8010f8e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8010f92:	2b00      	cmp	r3, #0
 8010f94:	d01c      	beq.n	8010fd0 <SD_WideBus_Disable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 8010f96:	687b      	ldr	r3, [r7, #4]
 8010f98:	681a      	ldr	r2, [r3, #0]
 8010f9a:	687b      	ldr	r3, [r7, #4]
 8010f9c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8010f9e:	041b      	lsls	r3, r3, #16
 8010fa0:	4619      	mov	r1, r3
 8010fa2:	4610      	mov	r0, r2
 8010fa4:	f002 f9d4 	bl	8013350 <SDMMC_CmdAppCommand>
 8010fa8:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010faa:	697b      	ldr	r3, [r7, #20]
 8010fac:	2b00      	cmp	r3, #0
 8010fae:	d001      	beq.n	8010fb4 <SD_WideBus_Disable+0x6e>
    {
      return errorstate;
 8010fb0:	697b      	ldr	r3, [r7, #20]
 8010fb2:	e00f      	b.n	8010fd4 <SD_WideBus_Disable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 8010fb4:	687b      	ldr	r3, [r7, #4]
 8010fb6:	681b      	ldr	r3, [r3, #0]
 8010fb8:	2100      	movs	r1, #0
 8010fba:	4618      	mov	r0, r3
 8010fbc:	f002 fa0d 	bl	80133da <SDMMC_CmdBusWidth>
 8010fc0:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
 8010fc2:	697b      	ldr	r3, [r7, #20]
 8010fc4:	2b00      	cmp	r3, #0
 8010fc6:	d001      	beq.n	8010fcc <SD_WideBus_Disable+0x86>
    {
      return errorstate;
 8010fc8:	697b      	ldr	r3, [r7, #20]
 8010fca:	e003      	b.n	8010fd4 <SD_WideBus_Disable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
 8010fcc:	2300      	movs	r3, #0
 8010fce:	e001      	b.n	8010fd4 <SD_WideBus_Disable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 8010fd0:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
  }
}
 8010fd4:	4618      	mov	r0, r3
 8010fd6:	3718      	adds	r7, #24
 8010fd8:	46bd      	mov	sp, r7
 8010fda:	bd80      	pop	{r7, pc}

08010fdc <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 8010fdc:	b590      	push	{r4, r7, lr}
 8010fde:	b08f      	sub	sp, #60	@ 0x3c
 8010fe0:	af00      	add	r7, sp, #0
 8010fe2:	6078      	str	r0, [r7, #4]
 8010fe4:	6039      	str	r1, [r7, #0]
  SDIO_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8010fe6:	f7f7 fe4d 	bl	8008c84 <HAL_GetTick>
 8010fea:	6338      	str	r0, [r7, #48]	@ 0x30
  uint32_t index = 0U;
 8010fec:	2300      	movs	r3, #0
 8010fee:	637b      	str	r3, [r7, #52]	@ 0x34
  uint32_t tempscr[2U] = {0U, 0U};
 8010ff0:	2300      	movs	r3, #0
 8010ff2:	60bb      	str	r3, [r7, #8]
 8010ff4:	2300      	movs	r3, #0
 8010ff6:	60fb      	str	r3, [r7, #12]
  uint32_t *scr = pSCR;
 8010ff8:	683b      	ldr	r3, [r7, #0]
 8010ffa:	62fb      	str	r3, [r7, #44]	@ 0x2c

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 8010ffc:	687b      	ldr	r3, [r7, #4]
 8010ffe:	681b      	ldr	r3, [r3, #0]
 8011000:	2108      	movs	r1, #8
 8011002:	4618      	mov	r0, r3
 8011004:	f002 f878 	bl	80130f8 <SDMMC_CmdBlockLength>
 8011008:	62b8      	str	r0, [r7, #40]	@ 0x28
  if(errorstate != HAL_SD_ERROR_NONE)
 801100a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801100c:	2b00      	cmp	r3, #0
 801100e:	d001      	beq.n	8011014 <SD_FindSCR+0x38>
  {
    return errorstate;
 8011010:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011012:	e0b9      	b.n	8011188 <SD_FindSCR+0x1ac>
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 8011014:	687b      	ldr	r3, [r7, #4]
 8011016:	681a      	ldr	r2, [r3, #0]
 8011018:	687b      	ldr	r3, [r7, #4]
 801101a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 801101c:	041b      	lsls	r3, r3, #16
 801101e:	4619      	mov	r1, r3
 8011020:	4610      	mov	r0, r2
 8011022:	f002 f995 	bl	8013350 <SDMMC_CmdAppCommand>
 8011026:	62b8      	str	r0, [r7, #40]	@ 0x28
  if(errorstate != HAL_SD_ERROR_NONE)
 8011028:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801102a:	2b00      	cmp	r3, #0
 801102c:	d001      	beq.n	8011032 <SD_FindSCR+0x56>
  {
    return errorstate;
 801102e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011030:	e0aa      	b.n	8011188 <SD_FindSCR+0x1ac>
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8011032:	f04f 33ff 	mov.w	r3, #4294967295
 8011036:	613b      	str	r3, [r7, #16]
  config.DataLength    = 8U;
 8011038:	2308      	movs	r3, #8
 801103a:	617b      	str	r3, [r7, #20]
  config.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
 801103c:	2330      	movs	r3, #48	@ 0x30
 801103e:	61bb      	str	r3, [r7, #24]
  config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
 8011040:	2302      	movs	r3, #2
 8011042:	61fb      	str	r3, [r7, #28]
  config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
 8011044:	2300      	movs	r3, #0
 8011046:	623b      	str	r3, [r7, #32]
  config.DPSM          = SDIO_DPSM_ENABLE;
 8011048:	2301      	movs	r3, #1
 801104a:	627b      	str	r3, [r7, #36]	@ 0x24
  (void)SDIO_ConfigData(hsd->Instance, &config);
 801104c:	687b      	ldr	r3, [r7, #4]
 801104e:	681b      	ldr	r3, [r3, #0]
 8011050:	f107 0210 	add.w	r2, r7, #16
 8011054:	4611      	mov	r1, r2
 8011056:	4618      	mov	r0, r3
 8011058:	f002 f822 	bl	80130a0 <SDIO_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 801105c:	687b      	ldr	r3, [r7, #4]
 801105e:	681b      	ldr	r3, [r3, #0]
 8011060:	4618      	mov	r0, r3
 8011062:	f002 f9dc 	bl	801341e <SDMMC_CmdSendSCR>
 8011066:	62b8      	str	r0, [r7, #40]	@ 0x28
  if(errorstate != HAL_SD_ERROR_NONE)
 8011068:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801106a:	2b00      	cmp	r3, #0
 801106c:	d02a      	beq.n	80110c4 <SD_FindSCR+0xe8>
  {
    return errorstate;
 801106e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011070:	e08a      	b.n	8011188 <SD_FindSCR+0x1ac>
  }

  while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT))
  {
    if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
 8011072:	687b      	ldr	r3, [r7, #4]
 8011074:	681b      	ldr	r3, [r3, #0]
 8011076:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011078:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 801107c:	2b00      	cmp	r3, #0
 801107e:	d00f      	beq.n	80110a0 <SD_FindSCR+0xc4>
    {
      *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
 8011080:	687b      	ldr	r3, [r7, #4]
 8011082:	6819      	ldr	r1, [r3, #0]
 8011084:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8011086:	009b      	lsls	r3, r3, #2
 8011088:	f107 0208 	add.w	r2, r7, #8
 801108c:	18d4      	adds	r4, r2, r3
 801108e:	4608      	mov	r0, r1
 8011090:	f001 ff82 	bl	8012f98 <SDIO_ReadFIFO>
 8011094:	4603      	mov	r3, r0
 8011096:	6023      	str	r3, [r4, #0]
      index++;
 8011098:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801109a:	3301      	adds	r3, #1
 801109c:	637b      	str	r3, [r7, #52]	@ 0x34
 801109e:	e006      	b.n	80110ae <SD_FindSCR+0xd2>
    }
    else if(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXACT))
 80110a0:	687b      	ldr	r3, [r7, #4]
 80110a2:	681b      	ldr	r3, [r3, #0]
 80110a4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80110a6:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80110aa:	2b00      	cmp	r3, #0
 80110ac:	d012      	beq.n	80110d4 <SD_FindSCR+0xf8>
    {
      break;
    }

    if((HAL_GetTick() - tickstart) >=  SDMMC_SWDATATIMEOUT)
 80110ae:	f7f7 fde9 	bl	8008c84 <HAL_GetTick>
 80110b2:	4602      	mov	r2, r0
 80110b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80110b6:	1ad3      	subs	r3, r2, r3
 80110b8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80110bc:	d102      	bne.n	80110c4 <SD_FindSCR+0xe8>
    {
      return HAL_SD_ERROR_TIMEOUT;
 80110be:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 80110c2:	e061      	b.n	8011188 <SD_FindSCR+0x1ac>
  while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT))
 80110c4:	687b      	ldr	r3, [r7, #4]
 80110c6:	681b      	ldr	r3, [r3, #0]
 80110c8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80110ca:	f003 032a 	and.w	r3, r3, #42	@ 0x2a
 80110ce:	2b00      	cmp	r3, #0
 80110d0:	d0cf      	beq.n	8011072 <SD_FindSCR+0x96>
 80110d2:	e000      	b.n	80110d6 <SD_FindSCR+0xfa>
      break;
 80110d4:	bf00      	nop
    }
  }

#if defined(SDIO_STA_STBITERR)
  if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT) || (__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_STBITERR)))
 80110d6:	687b      	ldr	r3, [r7, #4]
 80110d8:	681b      	ldr	r3, [r3, #0]
 80110da:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80110dc:	f003 0308 	and.w	r3, r3, #8
 80110e0:	2b00      	cmp	r3, #0
 80110e2:	d106      	bne.n	80110f2 <SD_FindSCR+0x116>
 80110e4:	687b      	ldr	r3, [r7, #4]
 80110e6:	681b      	ldr	r3, [r3, #0]
 80110e8:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80110ea:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80110ee:	2b00      	cmp	r3, #0
 80110f0:	d005      	beq.n	80110fe <SD_FindSCR+0x122>
#else /* SDIO_STA_STBITERR not defined */
  if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
#endif /* SDIO_STA_STBITERR */
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
 80110f2:	687b      	ldr	r3, [r7, #4]
 80110f4:	681b      	ldr	r3, [r3, #0]
 80110f6:	2208      	movs	r2, #8
 80110f8:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_TIMEOUT;
 80110fa:	2308      	movs	r3, #8
 80110fc:	e044      	b.n	8011188 <SD_FindSCR+0x1ac>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
 80110fe:	687b      	ldr	r3, [r7, #4]
 8011100:	681b      	ldr	r3, [r3, #0]
 8011102:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8011104:	f003 0302 	and.w	r3, r3, #2
 8011108:	2b00      	cmp	r3, #0
 801110a:	d005      	beq.n	8011118 <SD_FindSCR+0x13c>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
 801110c:	687b      	ldr	r3, [r7, #4]
 801110e:	681b      	ldr	r3, [r3, #0]
 8011110:	2202      	movs	r2, #2
 8011112:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_DATA_CRC_FAIL;
 8011114:	2302      	movs	r3, #2
 8011116:	e037      	b.n	8011188 <SD_FindSCR+0x1ac>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
 8011118:	687b      	ldr	r3, [r7, #4]
 801111a:	681b      	ldr	r3, [r3, #0]
 801111c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801111e:	f003 0320 	and.w	r3, r3, #32
 8011122:	2b00      	cmp	r3, #0
 8011124:	d005      	beq.n	8011132 <SD_FindSCR+0x156>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
 8011126:	687b      	ldr	r3, [r7, #4]
 8011128:	681b      	ldr	r3, [r3, #0]
 801112a:	2220      	movs	r2, #32
 801112c:	639a      	str	r2, [r3, #56]	@ 0x38

    return HAL_SD_ERROR_RX_OVERRUN;
 801112e:	2320      	movs	r3, #32
 8011130:	e02a      	b.n	8011188 <SD_FindSCR+0x1ac>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_DATA_FLAGS);
 8011132:	687b      	ldr	r3, [r7, #4]
 8011134:	681b      	ldr	r3, [r3, #0]
 8011136:	f240 523a 	movw	r2, #1338	@ 0x53a
 801113a:	639a      	str	r2, [r3, #56]	@ 0x38

    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 801113c:	68fb      	ldr	r3, [r7, #12]
 801113e:	061a      	lsls	r2, r3, #24
 8011140:	68fb      	ldr	r3, [r7, #12]
 8011142:	021b      	lsls	r3, r3, #8
 8011144:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8011148:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
 801114a:	68fb      	ldr	r3, [r7, #12]
 801114c:	0a1b      	lsrs	r3, r3, #8
 801114e:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 8011152:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
 8011154:	68fb      	ldr	r3, [r7, #12]
 8011156:	0e1b      	lsrs	r3, r3, #24
 8011158:	431a      	orrs	r2, r3
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
 801115a:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801115c:	601a      	str	r2, [r3, #0]
    scr++;
 801115e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011160:	3304      	adds	r3, #4
 8011162:	62fb      	str	r3, [r7, #44]	@ 0x2c
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 8011164:	68bb      	ldr	r3, [r7, #8]
 8011166:	061a      	lsls	r2, r3, #24
 8011168:	68bb      	ldr	r3, [r7, #8]
 801116a:	021b      	lsls	r3, r3, #8
 801116c:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
 8011170:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));
 8011172:	68bb      	ldr	r3, [r7, #8]
 8011174:	0a1b      	lsrs	r3, r3, #8
 8011176:	f403 437f 	and.w	r3, r3, #65280	@ 0xff00
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 801117a:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));
 801117c:	68bb      	ldr	r3, [r7, #8]
 801117e:	0e1b      	lsrs	r3, r3, #24
 8011180:	431a      	orrs	r2, r3
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 8011182:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011184:	601a      	str	r2, [r3, #0]

  }

  return HAL_SD_ERROR_NONE;
 8011186:	2300      	movs	r3, #0
}
 8011188:	4618      	mov	r0, r3
 801118a:	373c      	adds	r7, #60	@ 0x3c
 801118c:	46bd      	mov	sp, r7
 801118e:	bd90      	pop	{r4, r7, pc}

08011190 <SD_Read_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Read_IT(SD_HandleTypeDef *hsd)
{
 8011190:	b580      	push	{r7, lr}
 8011192:	b086      	sub	sp, #24
 8011194:	af00      	add	r7, sp, #0
 8011196:	6078      	str	r0, [r7, #4]
  uint32_t count, data, dataremaining;
  uint8_t* tmp;

  tmp = hsd->pRxBuffPtr;
 8011198:	687b      	ldr	r3, [r7, #4]
 801119a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801119c:	60fb      	str	r3, [r7, #12]
  dataremaining = hsd->RxXferSize;
 801119e:	687b      	ldr	r3, [r7, #4]
 80111a0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80111a2:	613b      	str	r3, [r7, #16]

  if (dataremaining > 0U)
 80111a4:	693b      	ldr	r3, [r7, #16]
 80111a6:	2b00      	cmp	r3, #0
 80111a8:	d03f      	beq.n	801122a <SD_Read_IT+0x9a>
  {
    /* Read data from SDIO Rx FIFO */
    for(count = 0U; count < 8U; count++)
 80111aa:	2300      	movs	r3, #0
 80111ac:	617b      	str	r3, [r7, #20]
 80111ae:	e033      	b.n	8011218 <SD_Read_IT+0x88>
    {
      data = SDIO_ReadFIFO(hsd->Instance);
 80111b0:	687b      	ldr	r3, [r7, #4]
 80111b2:	681b      	ldr	r3, [r3, #0]
 80111b4:	4618      	mov	r0, r3
 80111b6:	f001 feef 	bl	8012f98 <SDIO_ReadFIFO>
 80111ba:	60b8      	str	r0, [r7, #8]
      *tmp = (uint8_t)(data & 0xFFU);
 80111bc:	68bb      	ldr	r3, [r7, #8]
 80111be:	b2da      	uxtb	r2, r3
 80111c0:	68fb      	ldr	r3, [r7, #12]
 80111c2:	701a      	strb	r2, [r3, #0]
      tmp++;
 80111c4:	68fb      	ldr	r3, [r7, #12]
 80111c6:	3301      	adds	r3, #1
 80111c8:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 80111ca:	693b      	ldr	r3, [r7, #16]
 80111cc:	3b01      	subs	r3, #1
 80111ce:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
 80111d0:	68bb      	ldr	r3, [r7, #8]
 80111d2:	0a1b      	lsrs	r3, r3, #8
 80111d4:	b2da      	uxtb	r2, r3
 80111d6:	68fb      	ldr	r3, [r7, #12]
 80111d8:	701a      	strb	r2, [r3, #0]
      tmp++;
 80111da:	68fb      	ldr	r3, [r7, #12]
 80111dc:	3301      	adds	r3, #1
 80111de:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 80111e0:	693b      	ldr	r3, [r7, #16]
 80111e2:	3b01      	subs	r3, #1
 80111e4:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
 80111e6:	68bb      	ldr	r3, [r7, #8]
 80111e8:	0c1b      	lsrs	r3, r3, #16
 80111ea:	b2da      	uxtb	r2, r3
 80111ec:	68fb      	ldr	r3, [r7, #12]
 80111ee:	701a      	strb	r2, [r3, #0]
      tmp++;
 80111f0:	68fb      	ldr	r3, [r7, #12]
 80111f2:	3301      	adds	r3, #1
 80111f4:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 80111f6:	693b      	ldr	r3, [r7, #16]
 80111f8:	3b01      	subs	r3, #1
 80111fa:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
 80111fc:	68bb      	ldr	r3, [r7, #8]
 80111fe:	0e1b      	lsrs	r3, r3, #24
 8011200:	b2da      	uxtb	r2, r3
 8011202:	68fb      	ldr	r3, [r7, #12]
 8011204:	701a      	strb	r2, [r3, #0]
      tmp++;
 8011206:	68fb      	ldr	r3, [r7, #12]
 8011208:	3301      	adds	r3, #1
 801120a:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 801120c:	693b      	ldr	r3, [r7, #16]
 801120e:	3b01      	subs	r3, #1
 8011210:	613b      	str	r3, [r7, #16]
    for(count = 0U; count < 8U; count++)
 8011212:	697b      	ldr	r3, [r7, #20]
 8011214:	3301      	adds	r3, #1
 8011216:	617b      	str	r3, [r7, #20]
 8011218:	697b      	ldr	r3, [r7, #20]
 801121a:	2b07      	cmp	r3, #7
 801121c:	d9c8      	bls.n	80111b0 <SD_Read_IT+0x20>
    }

    hsd->pRxBuffPtr = tmp;
 801121e:	687b      	ldr	r3, [r7, #4]
 8011220:	68fa      	ldr	r2, [r7, #12]
 8011222:	629a      	str	r2, [r3, #40]	@ 0x28
    hsd->RxXferSize = dataremaining;
 8011224:	687b      	ldr	r3, [r7, #4]
 8011226:	693a      	ldr	r2, [r7, #16]
 8011228:	62da      	str	r2, [r3, #44]	@ 0x2c
  }
}
 801122a:	bf00      	nop
 801122c:	3718      	adds	r7, #24
 801122e:	46bd      	mov	sp, r7
 8011230:	bd80      	pop	{r7, pc}

08011232 <SD_Write_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Write_IT(SD_HandleTypeDef *hsd)
{
 8011232:	b580      	push	{r7, lr}
 8011234:	b086      	sub	sp, #24
 8011236:	af00      	add	r7, sp, #0
 8011238:	6078      	str	r0, [r7, #4]
  uint32_t count, data, dataremaining;
  uint8_t* tmp;

  tmp = hsd->pTxBuffPtr;
 801123a:	687b      	ldr	r3, [r7, #4]
 801123c:	6a1b      	ldr	r3, [r3, #32]
 801123e:	60fb      	str	r3, [r7, #12]
  dataremaining = hsd->TxXferSize;
 8011240:	687b      	ldr	r3, [r7, #4]
 8011242:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8011244:	613b      	str	r3, [r7, #16]

  if (dataremaining > 0U)
 8011246:	693b      	ldr	r3, [r7, #16]
 8011248:	2b00      	cmp	r3, #0
 801124a:	d043      	beq.n	80112d4 <SD_Write_IT+0xa2>
  {
    /* Write data to SDIO Tx FIFO */
    for(count = 0U; count < 8U; count++)
 801124c:	2300      	movs	r3, #0
 801124e:	617b      	str	r3, [r7, #20]
 8011250:	e037      	b.n	80112c2 <SD_Write_IT+0x90>
    {
      data = (uint32_t)(*tmp);
 8011252:	68fb      	ldr	r3, [r7, #12]
 8011254:	781b      	ldrb	r3, [r3, #0]
 8011256:	60bb      	str	r3, [r7, #8]
      tmp++;
 8011258:	68fb      	ldr	r3, [r7, #12]
 801125a:	3301      	adds	r3, #1
 801125c:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 801125e:	693b      	ldr	r3, [r7, #16]
 8011260:	3b01      	subs	r3, #1
 8011262:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 8U);
 8011264:	68fb      	ldr	r3, [r7, #12]
 8011266:	781b      	ldrb	r3, [r3, #0]
 8011268:	021a      	lsls	r2, r3, #8
 801126a:	68bb      	ldr	r3, [r7, #8]
 801126c:	4313      	orrs	r3, r2
 801126e:	60bb      	str	r3, [r7, #8]
      tmp++;
 8011270:	68fb      	ldr	r3, [r7, #12]
 8011272:	3301      	adds	r3, #1
 8011274:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 8011276:	693b      	ldr	r3, [r7, #16]
 8011278:	3b01      	subs	r3, #1
 801127a:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 16U);
 801127c:	68fb      	ldr	r3, [r7, #12]
 801127e:	781b      	ldrb	r3, [r3, #0]
 8011280:	041a      	lsls	r2, r3, #16
 8011282:	68bb      	ldr	r3, [r7, #8]
 8011284:	4313      	orrs	r3, r2
 8011286:	60bb      	str	r3, [r7, #8]
      tmp++;
 8011288:	68fb      	ldr	r3, [r7, #12]
 801128a:	3301      	adds	r3, #1
 801128c:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 801128e:	693b      	ldr	r3, [r7, #16]
 8011290:	3b01      	subs	r3, #1
 8011292:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 24U);
 8011294:	68fb      	ldr	r3, [r7, #12]
 8011296:	781b      	ldrb	r3, [r3, #0]
 8011298:	061a      	lsls	r2, r3, #24
 801129a:	68bb      	ldr	r3, [r7, #8]
 801129c:	4313      	orrs	r3, r2
 801129e:	60bb      	str	r3, [r7, #8]
      tmp++;
 80112a0:	68fb      	ldr	r3, [r7, #12]
 80112a2:	3301      	adds	r3, #1
 80112a4:	60fb      	str	r3, [r7, #12]
      dataremaining--;
 80112a6:	693b      	ldr	r3, [r7, #16]
 80112a8:	3b01      	subs	r3, #1
 80112aa:	613b      	str	r3, [r7, #16]
      (void)SDIO_WriteFIFO(hsd->Instance, &data);
 80112ac:	687b      	ldr	r3, [r7, #4]
 80112ae:	681b      	ldr	r3, [r3, #0]
 80112b0:	f107 0208 	add.w	r2, r7, #8
 80112b4:	4611      	mov	r1, r2
 80112b6:	4618      	mov	r0, r3
 80112b8:	f001 fe7b 	bl	8012fb2 <SDIO_WriteFIFO>
    for(count = 0U; count < 8U; count++)
 80112bc:	697b      	ldr	r3, [r7, #20]
 80112be:	3301      	adds	r3, #1
 80112c0:	617b      	str	r3, [r7, #20]
 80112c2:	697b      	ldr	r3, [r7, #20]
 80112c4:	2b07      	cmp	r3, #7
 80112c6:	d9c4      	bls.n	8011252 <SD_Write_IT+0x20>
    }

    hsd->pTxBuffPtr = tmp;
 80112c8:	687b      	ldr	r3, [r7, #4]
 80112ca:	68fa      	ldr	r2, [r7, #12]
 80112cc:	621a      	str	r2, [r3, #32]
    hsd->TxXferSize = dataremaining;
 80112ce:	687b      	ldr	r3, [r7, #4]
 80112d0:	693a      	ldr	r2, [r7, #16]
 80112d2:	625a      	str	r2, [r3, #36]	@ 0x24
  }
}
 80112d4:	bf00      	nop
 80112d6:	3718      	adds	r7, #24
 80112d8:	46bd      	mov	sp, r7
 80112da:	bd80      	pop	{r7, pc}

080112dc <HAL_SPI_Init>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80112dc:	b580      	push	{r7, lr}
 80112de:	b082      	sub	sp, #8
 80112e0:	af00      	add	r7, sp, #0
 80112e2:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80112e4:	687b      	ldr	r3, [r7, #4]
 80112e6:	2b00      	cmp	r3, #0
 80112e8:	d101      	bne.n	80112ee <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80112ea:	2301      	movs	r3, #1
 80112ec:	e07b      	b.n	80113e6 <HAL_SPI_Init+0x10a>
  assert_param(IS_SPI_DATASIZE(hspi->Init.DataSize));
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80112ee:	687b      	ldr	r3, [r7, #4]
 80112f0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80112f2:	2b00      	cmp	r3, #0
 80112f4:	d108      	bne.n	8011308 <HAL_SPI_Init+0x2c>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80112f6:	687b      	ldr	r3, [r7, #4]
 80112f8:	685b      	ldr	r3, [r3, #4]
 80112fa:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 80112fe:	d009      	beq.n	8011314 <HAL_SPI_Init+0x38>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8011300:	687b      	ldr	r3, [r7, #4]
 8011302:	2200      	movs	r2, #0
 8011304:	61da      	str	r2, [r3, #28]
 8011306:	e005      	b.n	8011314 <HAL_SPI_Init+0x38>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8011308:	687b      	ldr	r3, [r7, #4]
 801130a:	2200      	movs	r2, #0
 801130c:	611a      	str	r2, [r3, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 801130e:	687b      	ldr	r3, [r7, #4]
 8011310:	2200      	movs	r2, #0
 8011312:	615a      	str	r2, [r3, #20]
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8011314:	687b      	ldr	r3, [r7, #4]
 8011316:	2200      	movs	r2, #0
 8011318:	629a      	str	r2, [r3, #40]	@ 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 801131a:	687b      	ldr	r3, [r7, #4]
 801131c:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 8011320:	b2db      	uxtb	r3, r3
 8011322:	2b00      	cmp	r3, #0
 8011324:	d106      	bne.n	8011334 <HAL_SPI_Init+0x58>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8011326:	687b      	ldr	r3, [r7, #4]
 8011328:	2200      	movs	r2, #0
 801132a:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 801132e:	6878      	ldr	r0, [r7, #4]
 8011330:	f7f7 f9d2 	bl	80086d8 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8011334:	687b      	ldr	r3, [r7, #4]
 8011336:	2202      	movs	r2, #2
 8011338:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 801133c:	687b      	ldr	r3, [r7, #4]
 801133e:	681b      	ldr	r3, [r3, #0]
 8011340:	681a      	ldr	r2, [r3, #0]
 8011342:	687b      	ldr	r3, [r7, #4]
 8011344:	681b      	ldr	r3, [r3, #0]
 8011346:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 801134a:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 801134c:	687b      	ldr	r3, [r7, #4]
 801134e:	685b      	ldr	r3, [r3, #4]
 8011350:	f403 7282 	and.w	r2, r3, #260	@ 0x104
 8011354:	687b      	ldr	r3, [r7, #4]
 8011356:	689b      	ldr	r3, [r3, #8]
 8011358:	f403 4304 	and.w	r3, r3, #33792	@ 0x8400
 801135c:	431a      	orrs	r2, r3
 801135e:	687b      	ldr	r3, [r7, #4]
 8011360:	68db      	ldr	r3, [r3, #12]
 8011362:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8011366:	431a      	orrs	r2, r3
 8011368:	687b      	ldr	r3, [r7, #4]
 801136a:	691b      	ldr	r3, [r3, #16]
 801136c:	f003 0302 	and.w	r3, r3, #2
 8011370:	431a      	orrs	r2, r3
 8011372:	687b      	ldr	r3, [r7, #4]
 8011374:	695b      	ldr	r3, [r3, #20]
 8011376:	f003 0301 	and.w	r3, r3, #1
 801137a:	431a      	orrs	r2, r3
 801137c:	687b      	ldr	r3, [r7, #4]
 801137e:	699b      	ldr	r3, [r3, #24]
 8011380:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8011384:	431a      	orrs	r2, r3
 8011386:	687b      	ldr	r3, [r7, #4]
 8011388:	69db      	ldr	r3, [r3, #28]
 801138a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 801138e:	431a      	orrs	r2, r3
 8011390:	687b      	ldr	r3, [r7, #4]
 8011392:	6a1b      	ldr	r3, [r3, #32]
 8011394:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8011398:	ea42 0103 	orr.w	r1, r2, r3
 801139c:	687b      	ldr	r3, [r7, #4]
 801139e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80113a0:	f403 5200 	and.w	r2, r3, #8192	@ 0x2000
 80113a4:	687b      	ldr	r3, [r7, #4]
 80113a6:	681b      	ldr	r3, [r3, #0]
 80113a8:	430a      	orrs	r2, r1
 80113aa:	601a      	str	r2, [r3, #0]
                                  (hspi->Init.BaudRatePrescaler & SPI_CR1_BR_Msk) |
                                  (hspi->Init.FirstBit  & SPI_CR1_LSBFIRST) |
                                  (hspi->Init.CRCCalculation & SPI_CR1_CRCEN)));

  /* Configure : NSS management, TI Mode */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | (hspi->Init.TIMode & SPI_CR2_FRF)));
 80113ac:	687b      	ldr	r3, [r7, #4]
 80113ae:	699b      	ldr	r3, [r3, #24]
 80113b0:	0c1b      	lsrs	r3, r3, #16
 80113b2:	f003 0104 	and.w	r1, r3, #4
 80113b6:	687b      	ldr	r3, [r7, #4]
 80113b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80113ba:	f003 0210 	and.w	r2, r3, #16
 80113be:	687b      	ldr	r3, [r7, #4]
 80113c0:	681b      	ldr	r3, [r3, #0]
 80113c2:	430a      	orrs	r2, r1
 80113c4:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80113c6:	687b      	ldr	r3, [r7, #4]
 80113c8:	681b      	ldr	r3, [r3, #0]
 80113ca:	69da      	ldr	r2, [r3, #28]
 80113cc:	687b      	ldr	r3, [r7, #4]
 80113ce:	681b      	ldr	r3, [r3, #0]
 80113d0:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 80113d4:	61da      	str	r2, [r3, #28]
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80113d6:	687b      	ldr	r3, [r7, #4]
 80113d8:	2200      	movs	r2, #0
 80113da:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80113dc:	687b      	ldr	r3, [r7, #4]
 80113de:	2201      	movs	r2, #1
 80113e0:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  return HAL_OK;
 80113e4:	2300      	movs	r3, #0
}
 80113e6:	4618      	mov	r0, r3
 80113e8:	3708      	adds	r7, #8
 80113ea:	46bd      	mov	sp, r7
 80113ec:	bd80      	pop	{r7, pc}

080113ee <HAL_SPI_DeInit>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
 80113ee:	b580      	push	{r7, lr}
 80113f0:	b082      	sub	sp, #8
 80113f2:	af00      	add	r7, sp, #0
 80113f4:	6078      	str	r0, [r7, #4]
  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80113f6:	687b      	ldr	r3, [r7, #4]
 80113f8:	2b00      	cmp	r3, #0
 80113fa:	d101      	bne.n	8011400 <HAL_SPI_DeInit+0x12>
  {
    return HAL_ERROR;
 80113fc:	2301      	movs	r3, #1
 80113fe:	e01a      	b.n	8011436 <HAL_SPI_DeInit+0x48>
  }

  /* Check SPI Instance parameter */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));

  hspi->State = HAL_SPI_STATE_BUSY;
 8011400:	687b      	ldr	r3, [r7, #4]
 8011402:	2202      	movs	r2, #2
 8011404:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
 8011408:	687b      	ldr	r3, [r7, #4]
 801140a:	681b      	ldr	r3, [r3, #0]
 801140c:	681a      	ldr	r2, [r3, #0]
 801140e:	687b      	ldr	r3, [r7, #4]
 8011410:	681b      	ldr	r3, [r3, #0]
 8011412:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8011416:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  hspi->MspDeInitCallback(hspi);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_SPI_MspDeInit(hspi);
 8011418:	6878      	ldr	r0, [r7, #4]
 801141a:	f7f7 fa73 	bl	8008904 <HAL_SPI_MspDeInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 801141e:	687b      	ldr	r3, [r7, #4]
 8011420:	2200      	movs	r2, #0
 8011422:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->State = HAL_SPI_STATE_RESET;
 8011424:	687b      	ldr	r3, [r7, #4]
 8011426:	2200      	movs	r2, #0
 8011428:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

  /* Release Lock */
  __HAL_UNLOCK(hspi);
 801142c:	687b      	ldr	r3, [r7, #4]
 801142e:	2200      	movs	r2, #0
 8011430:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  return HAL_OK;
 8011434:	2300      	movs	r3, #0
}
 8011436:	4618      	mov	r0, r3
 8011438:	3708      	adds	r7, #8
 801143a:	46bd      	mov	sp, r7
 801143c:	bd80      	pop	{r7, pc}

0801143e <HAL_SPI_Transmit>:
  * @param  Size amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 801143e:	b580      	push	{r7, lr}
 8011440:	b088      	sub	sp, #32
 8011442:	af00      	add	r7, sp, #0
 8011444:	60f8      	str	r0, [r7, #12]
 8011446:	60b9      	str	r1, [r7, #8]
 8011448:	603b      	str	r3, [r7, #0]
 801144a:	4613      	mov	r3, r2
 801144c:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 801144e:	2300      	movs	r3, #0
 8011450:	77fb      	strb	r3, [r7, #31]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8011452:	68fb      	ldr	r3, [r7, #12]
 8011454:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8011458:	2b01      	cmp	r3, #1
 801145a:	d101      	bne.n	8011460 <HAL_SPI_Transmit+0x22>
 801145c:	2302      	movs	r3, #2
 801145e:	e12d      	b.n	80116bc <HAL_SPI_Transmit+0x27e>
 8011460:	68fb      	ldr	r3, [r7, #12]
 8011462:	2201      	movs	r2, #1
 8011464:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8011468:	f7f7 fc0c 	bl	8008c84 <HAL_GetTick>
 801146c:	61b8      	str	r0, [r7, #24]
  initial_TxXferCount = Size;
 801146e:	88fb      	ldrh	r3, [r7, #6]
 8011470:	82fb      	strh	r3, [r7, #22]

  if (hspi->State != HAL_SPI_STATE_READY)
 8011472:	68fb      	ldr	r3, [r7, #12]
 8011474:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 8011478:	b2db      	uxtb	r3, r3
 801147a:	2b01      	cmp	r3, #1
 801147c:	d002      	beq.n	8011484 <HAL_SPI_Transmit+0x46>
  {
    errorcode = HAL_BUSY;
 801147e:	2302      	movs	r3, #2
 8011480:	77fb      	strb	r3, [r7, #31]
    goto error;
 8011482:	e116      	b.n	80116b2 <HAL_SPI_Transmit+0x274>
  }

  if ((pData == NULL) || (Size == 0U))
 8011484:	68bb      	ldr	r3, [r7, #8]
 8011486:	2b00      	cmp	r3, #0
 8011488:	d002      	beq.n	8011490 <HAL_SPI_Transmit+0x52>
 801148a:	88fb      	ldrh	r3, [r7, #6]
 801148c:	2b00      	cmp	r3, #0
 801148e:	d102      	bne.n	8011496 <HAL_SPI_Transmit+0x58>
  {
    errorcode = HAL_ERROR;
 8011490:	2301      	movs	r3, #1
 8011492:	77fb      	strb	r3, [r7, #31]
    goto error;
 8011494:	e10d      	b.n	80116b2 <HAL_SPI_Transmit+0x274>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8011496:	68fb      	ldr	r3, [r7, #12]
 8011498:	2203      	movs	r2, #3
 801149a:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 801149e:	68fb      	ldr	r3, [r7, #12]
 80114a0:	2200      	movs	r2, #0
 80114a2:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 80114a4:	68fb      	ldr	r3, [r7, #12]
 80114a6:	68ba      	ldr	r2, [r7, #8]
 80114a8:	631a      	str	r2, [r3, #48]	@ 0x30
  hspi->TxXferSize  = Size;
 80114aa:	68fb      	ldr	r3, [r7, #12]
 80114ac:	88fa      	ldrh	r2, [r7, #6]
 80114ae:	869a      	strh	r2, [r3, #52]	@ 0x34
  hspi->TxXferCount = Size;
 80114b0:	68fb      	ldr	r3, [r7, #12]
 80114b2:	88fa      	ldrh	r2, [r7, #6]
 80114b4:	86da      	strh	r2, [r3, #54]	@ 0x36

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 80114b6:	68fb      	ldr	r3, [r7, #12]
 80114b8:	2200      	movs	r2, #0
 80114ba:	639a      	str	r2, [r3, #56]	@ 0x38
  hspi->RxXferSize  = 0U;
 80114bc:	68fb      	ldr	r3, [r7, #12]
 80114be:	2200      	movs	r2, #0
 80114c0:	879a      	strh	r2, [r3, #60]	@ 0x3c
  hspi->RxXferCount = 0U;
 80114c2:	68fb      	ldr	r3, [r7, #12]
 80114c4:	2200      	movs	r2, #0
 80114c6:	87da      	strh	r2, [r3, #62]	@ 0x3e
  hspi->TxISR       = NULL;
 80114c8:	68fb      	ldr	r3, [r7, #12]
 80114ca:	2200      	movs	r2, #0
 80114cc:	645a      	str	r2, [r3, #68]	@ 0x44
  hspi->RxISR       = NULL;
 80114ce:	68fb      	ldr	r3, [r7, #12]
 80114d0:	2200      	movs	r2, #0
 80114d2:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Configure communication direction : 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 80114d4:	68fb      	ldr	r3, [r7, #12]
 80114d6:	689b      	ldr	r3, [r3, #8]
 80114d8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 80114dc:	d10f      	bne.n	80114fe <HAL_SPI_Transmit+0xc0>
  {
    /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
    __HAL_SPI_DISABLE(hspi);
 80114de:	68fb      	ldr	r3, [r7, #12]
 80114e0:	681b      	ldr	r3, [r3, #0]
 80114e2:	681a      	ldr	r2, [r3, #0]
 80114e4:	68fb      	ldr	r3, [r7, #12]
 80114e6:	681b      	ldr	r3, [r3, #0]
 80114e8:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 80114ec:	601a      	str	r2, [r3, #0]
    SPI_1LINE_TX(hspi);
 80114ee:	68fb      	ldr	r3, [r7, #12]
 80114f0:	681b      	ldr	r3, [r3, #0]
 80114f2:	681a      	ldr	r2, [r3, #0]
 80114f4:	68fb      	ldr	r3, [r7, #12]
 80114f6:	681b      	ldr	r3, [r3, #0]
 80114f8:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 80114fc:	601a      	str	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80114fe:	68fb      	ldr	r3, [r7, #12]
 8011500:	681b      	ldr	r3, [r3, #0]
 8011502:	681b      	ldr	r3, [r3, #0]
 8011504:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8011508:	2b40      	cmp	r3, #64	@ 0x40
 801150a:	d007      	beq.n	801151c <HAL_SPI_Transmit+0xde>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 801150c:	68fb      	ldr	r3, [r7, #12]
 801150e:	681b      	ldr	r3, [r3, #0]
 8011510:	681a      	ldr	r2, [r3, #0]
 8011512:	68fb      	ldr	r3, [r7, #12]
 8011514:	681b      	ldr	r3, [r3, #0]
 8011516:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 801151a:	601a      	str	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 801151c:	68fb      	ldr	r3, [r7, #12]
 801151e:	68db      	ldr	r3, [r3, #12]
 8011520:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8011524:	d14f      	bne.n	80115c6 <HAL_SPI_Transmit+0x188>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8011526:	68fb      	ldr	r3, [r7, #12]
 8011528:	685b      	ldr	r3, [r3, #4]
 801152a:	2b00      	cmp	r3, #0
 801152c:	d002      	beq.n	8011534 <HAL_SPI_Transmit+0xf6>
 801152e:	8afb      	ldrh	r3, [r7, #22]
 8011530:	2b01      	cmp	r3, #1
 8011532:	d142      	bne.n	80115ba <HAL_SPI_Transmit+0x17c>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8011534:	68fb      	ldr	r3, [r7, #12]
 8011536:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011538:	881a      	ldrh	r2, [r3, #0]
 801153a:	68fb      	ldr	r3, [r7, #12]
 801153c:	681b      	ldr	r3, [r3, #0]
 801153e:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8011540:	68fb      	ldr	r3, [r7, #12]
 8011542:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011544:	1c9a      	adds	r2, r3, #2
 8011546:	68fb      	ldr	r3, [r7, #12]
 8011548:	631a      	str	r2, [r3, #48]	@ 0x30
      hspi->TxXferCount--;
 801154a:	68fb      	ldr	r3, [r7, #12]
 801154c:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 801154e:	b29b      	uxth	r3, r3
 8011550:	3b01      	subs	r3, #1
 8011552:	b29a      	uxth	r2, r3
 8011554:	68fb      	ldr	r3, [r7, #12]
 8011556:	86da      	strh	r2, [r3, #54]	@ 0x36
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 8011558:	e02f      	b.n	80115ba <HAL_SPI_Transmit+0x17c>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 801155a:	68fb      	ldr	r3, [r7, #12]
 801155c:	681b      	ldr	r3, [r3, #0]
 801155e:	689b      	ldr	r3, [r3, #8]
 8011560:	f003 0302 	and.w	r3, r3, #2
 8011564:	2b02      	cmp	r3, #2
 8011566:	d112      	bne.n	801158e <HAL_SPI_Transmit+0x150>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8011568:	68fb      	ldr	r3, [r7, #12]
 801156a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801156c:	881a      	ldrh	r2, [r3, #0]
 801156e:	68fb      	ldr	r3, [r7, #12]
 8011570:	681b      	ldr	r3, [r3, #0]
 8011572:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8011574:	68fb      	ldr	r3, [r7, #12]
 8011576:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011578:	1c9a      	adds	r2, r3, #2
 801157a:	68fb      	ldr	r3, [r7, #12]
 801157c:	631a      	str	r2, [r3, #48]	@ 0x30
        hspi->TxXferCount--;
 801157e:	68fb      	ldr	r3, [r7, #12]
 8011580:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011582:	b29b      	uxth	r3, r3
 8011584:	3b01      	subs	r3, #1
 8011586:	b29a      	uxth	r2, r3
 8011588:	68fb      	ldr	r3, [r7, #12]
 801158a:	86da      	strh	r2, [r3, #54]	@ 0x36
 801158c:	e015      	b.n	80115ba <HAL_SPI_Transmit+0x17c>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 801158e:	f7f7 fb79 	bl	8008c84 <HAL_GetTick>
 8011592:	4602      	mov	r2, r0
 8011594:	69bb      	ldr	r3, [r7, #24]
 8011596:	1ad3      	subs	r3, r2, r3
 8011598:	683a      	ldr	r2, [r7, #0]
 801159a:	429a      	cmp	r2, r3
 801159c:	d803      	bhi.n	80115a6 <HAL_SPI_Transmit+0x168>
 801159e:	683b      	ldr	r3, [r7, #0]
 80115a0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80115a4:	d102      	bne.n	80115ac <HAL_SPI_Transmit+0x16e>
 80115a6:	683b      	ldr	r3, [r7, #0]
 80115a8:	2b00      	cmp	r3, #0
 80115aa:	d106      	bne.n	80115ba <HAL_SPI_Transmit+0x17c>
        {
          errorcode = HAL_TIMEOUT;
 80115ac:	2303      	movs	r3, #3
 80115ae:	77fb      	strb	r3, [r7, #31]
          hspi->State = HAL_SPI_STATE_READY;
 80115b0:	68fb      	ldr	r3, [r7, #12]
 80115b2:	2201      	movs	r2, #1
 80115b4:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
          goto error;
 80115b8:	e07b      	b.n	80116b2 <HAL_SPI_Transmit+0x274>
    while (hspi->TxXferCount > 0U)
 80115ba:	68fb      	ldr	r3, [r7, #12]
 80115bc:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 80115be:	b29b      	uxth	r3, r3
 80115c0:	2b00      	cmp	r3, #0
 80115c2:	d1ca      	bne.n	801155a <HAL_SPI_Transmit+0x11c>
 80115c4:	e050      	b.n	8011668 <HAL_SPI_Transmit+0x22a>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80115c6:	68fb      	ldr	r3, [r7, #12]
 80115c8:	685b      	ldr	r3, [r3, #4]
 80115ca:	2b00      	cmp	r3, #0
 80115cc:	d002      	beq.n	80115d4 <HAL_SPI_Transmit+0x196>
 80115ce:	8afb      	ldrh	r3, [r7, #22]
 80115d0:	2b01      	cmp	r3, #1
 80115d2:	d144      	bne.n	801165e <HAL_SPI_Transmit+0x220>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 80115d4:	68fb      	ldr	r3, [r7, #12]
 80115d6:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 80115d8:	68fb      	ldr	r3, [r7, #12]
 80115da:	681b      	ldr	r3, [r3, #0]
 80115dc:	330c      	adds	r3, #12
 80115de:	7812      	ldrb	r2, [r2, #0]
 80115e0:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 80115e2:	68fb      	ldr	r3, [r7, #12]
 80115e4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80115e6:	1c5a      	adds	r2, r3, #1
 80115e8:	68fb      	ldr	r3, [r7, #12]
 80115ea:	631a      	str	r2, [r3, #48]	@ 0x30
      hspi->TxXferCount--;
 80115ec:	68fb      	ldr	r3, [r7, #12]
 80115ee:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 80115f0:	b29b      	uxth	r3, r3
 80115f2:	3b01      	subs	r3, #1
 80115f4:	b29a      	uxth	r2, r3
 80115f6:	68fb      	ldr	r3, [r7, #12]
 80115f8:	86da      	strh	r2, [r3, #54]	@ 0x36
    }
    while (hspi->TxXferCount > 0U)
 80115fa:	e030      	b.n	801165e <HAL_SPI_Transmit+0x220>
    {
      /* Wait until TXE flag is set to send data */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80115fc:	68fb      	ldr	r3, [r7, #12]
 80115fe:	681b      	ldr	r3, [r3, #0]
 8011600:	689b      	ldr	r3, [r3, #8]
 8011602:	f003 0302 	and.w	r3, r3, #2
 8011606:	2b02      	cmp	r3, #2
 8011608:	d113      	bne.n	8011632 <HAL_SPI_Transmit+0x1f4>
      {
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 801160a:	68fb      	ldr	r3, [r7, #12]
 801160c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801160e:	68fb      	ldr	r3, [r7, #12]
 8011610:	681b      	ldr	r3, [r3, #0]
 8011612:	330c      	adds	r3, #12
 8011614:	7812      	ldrb	r2, [r2, #0]
 8011616:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 8011618:	68fb      	ldr	r3, [r7, #12]
 801161a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801161c:	1c5a      	adds	r2, r3, #1
 801161e:	68fb      	ldr	r3, [r7, #12]
 8011620:	631a      	str	r2, [r3, #48]	@ 0x30
        hspi->TxXferCount--;
 8011622:	68fb      	ldr	r3, [r7, #12]
 8011624:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011626:	b29b      	uxth	r3, r3
 8011628:	3b01      	subs	r3, #1
 801162a:	b29a      	uxth	r2, r3
 801162c:	68fb      	ldr	r3, [r7, #12]
 801162e:	86da      	strh	r2, [r3, #54]	@ 0x36
 8011630:	e015      	b.n	801165e <HAL_SPI_Transmit+0x220>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8011632:	f7f7 fb27 	bl	8008c84 <HAL_GetTick>
 8011636:	4602      	mov	r2, r0
 8011638:	69bb      	ldr	r3, [r7, #24]
 801163a:	1ad3      	subs	r3, r2, r3
 801163c:	683a      	ldr	r2, [r7, #0]
 801163e:	429a      	cmp	r2, r3
 8011640:	d803      	bhi.n	801164a <HAL_SPI_Transmit+0x20c>
 8011642:	683b      	ldr	r3, [r7, #0]
 8011644:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011648:	d102      	bne.n	8011650 <HAL_SPI_Transmit+0x212>
 801164a:	683b      	ldr	r3, [r7, #0]
 801164c:	2b00      	cmp	r3, #0
 801164e:	d106      	bne.n	801165e <HAL_SPI_Transmit+0x220>
        {
          errorcode = HAL_TIMEOUT;
 8011650:	2303      	movs	r3, #3
 8011652:	77fb      	strb	r3, [r7, #31]
          hspi->State = HAL_SPI_STATE_READY;
 8011654:	68fb      	ldr	r3, [r7, #12]
 8011656:	2201      	movs	r2, #1
 8011658:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
          goto error;
 801165c:	e029      	b.n	80116b2 <HAL_SPI_Transmit+0x274>
    while (hspi->TxXferCount > 0U)
 801165e:	68fb      	ldr	r3, [r7, #12]
 8011660:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011662:	b29b      	uxth	r3, r3
 8011664:	2b00      	cmp	r3, #0
 8011666:	d1c9      	bne.n	80115fc <HAL_SPI_Transmit+0x1be>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8011668:	69ba      	ldr	r2, [r7, #24]
 801166a:	6839      	ldr	r1, [r7, #0]
 801166c:	68f8      	ldr	r0, [r7, #12]
 801166e:	f000 fce7 	bl	8012040 <SPI_EndRxTxTransaction>
 8011672:	4603      	mov	r3, r0
 8011674:	2b00      	cmp	r3, #0
 8011676:	d002      	beq.n	801167e <HAL_SPI_Transmit+0x240>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8011678:	68fb      	ldr	r3, [r7, #12]
 801167a:	2220      	movs	r2, #32
 801167c:	655a      	str	r2, [r3, #84]	@ 0x54
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 801167e:	68fb      	ldr	r3, [r7, #12]
 8011680:	689b      	ldr	r3, [r3, #8]
 8011682:	2b00      	cmp	r3, #0
 8011684:	d10a      	bne.n	801169c <HAL_SPI_Transmit+0x25e>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8011686:	2300      	movs	r3, #0
 8011688:	613b      	str	r3, [r7, #16]
 801168a:	68fb      	ldr	r3, [r7, #12]
 801168c:	681b      	ldr	r3, [r3, #0]
 801168e:	68db      	ldr	r3, [r3, #12]
 8011690:	613b      	str	r3, [r7, #16]
 8011692:	68fb      	ldr	r3, [r7, #12]
 8011694:	681b      	ldr	r3, [r3, #0]
 8011696:	689b      	ldr	r3, [r3, #8]
 8011698:	613b      	str	r3, [r7, #16]
 801169a:	693b      	ldr	r3, [r7, #16]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 801169c:	68fb      	ldr	r3, [r7, #12]
 801169e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80116a0:	2b00      	cmp	r3, #0
 80116a2:	d002      	beq.n	80116aa <HAL_SPI_Transmit+0x26c>
  {
    errorcode = HAL_ERROR;
 80116a4:	2301      	movs	r3, #1
 80116a6:	77fb      	strb	r3, [r7, #31]
 80116a8:	e003      	b.n	80116b2 <HAL_SPI_Transmit+0x274>
  }
  else
  {
    hspi->State = HAL_SPI_STATE_READY;
 80116aa:	68fb      	ldr	r3, [r7, #12]
 80116ac:	2201      	movs	r2, #1
 80116ae:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  }

error:
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 80116b2:	68fb      	ldr	r3, [r7, #12]
 80116b4:	2200      	movs	r2, #0
 80116b6:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  return errorcode;
 80116ba:	7ffb      	ldrb	r3, [r7, #31]
}
 80116bc:	4618      	mov	r0, r3
 80116be:	3720      	adds	r7, #32
 80116c0:	46bd      	mov	sp, r7
 80116c2:	bd80      	pop	{r7, pc}

080116c4 <HAL_SPI_Receive>:
  * @param  Size amount of data to be received
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Receive(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80116c4:	b580      	push	{r7, lr}
 80116c6:	b088      	sub	sp, #32
 80116c8:	af02      	add	r7, sp, #8
 80116ca:	60f8      	str	r0, [r7, #12]
 80116cc:	60b9      	str	r1, [r7, #8]
 80116ce:	603b      	str	r3, [r7, #0]
 80116d0:	4613      	mov	r3, r2
 80116d2:	80fb      	strh	r3, [r7, #6]
#if (USE_SPI_CRC != 0U)
  __IO uint32_t tmpreg = 0U;
#endif /* USE_SPI_CRC */
  uint32_t tickstart;
  HAL_StatusTypeDef errorcode = HAL_OK;
 80116d4:	2300      	movs	r3, #0
 80116d6:	75fb      	strb	r3, [r7, #23]

  if (hspi->State != HAL_SPI_STATE_READY)
 80116d8:	68fb      	ldr	r3, [r7, #12]
 80116da:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 80116de:	b2db      	uxtb	r3, r3
 80116e0:	2b01      	cmp	r3, #1
 80116e2:	d002      	beq.n	80116ea <HAL_SPI_Receive+0x26>
  {
    errorcode = HAL_BUSY;
 80116e4:	2302      	movs	r3, #2
 80116e6:	75fb      	strb	r3, [r7, #23]
    goto error;
 80116e8:	e0fb      	b.n	80118e2 <HAL_SPI_Receive+0x21e>
  }

  if ((hspi->Init.Mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES))
 80116ea:	68fb      	ldr	r3, [r7, #12]
 80116ec:	685b      	ldr	r3, [r3, #4]
 80116ee:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 80116f2:	d112      	bne.n	801171a <HAL_SPI_Receive+0x56>
 80116f4:	68fb      	ldr	r3, [r7, #12]
 80116f6:	689b      	ldr	r3, [r3, #8]
 80116f8:	2b00      	cmp	r3, #0
 80116fa:	d10e      	bne.n	801171a <HAL_SPI_Receive+0x56>
  {
    hspi->State = HAL_SPI_STATE_BUSY_RX;
 80116fc:	68fb      	ldr	r3, [r7, #12]
 80116fe:	2204      	movs	r2, #4
 8011700:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
    /* Call transmit-receive function to send Dummy data on Tx line and generate clock on CLK line */
    return HAL_SPI_TransmitReceive(hspi, pData, pData, Size, Timeout);
 8011704:	88fa      	ldrh	r2, [r7, #6]
 8011706:	683b      	ldr	r3, [r7, #0]
 8011708:	9300      	str	r3, [sp, #0]
 801170a:	4613      	mov	r3, r2
 801170c:	68ba      	ldr	r2, [r7, #8]
 801170e:	68b9      	ldr	r1, [r7, #8]
 8011710:	68f8      	ldr	r0, [r7, #12]
 8011712:	f000 f8ef 	bl	80118f4 <HAL_SPI_TransmitReceive>
 8011716:	4603      	mov	r3, r0
 8011718:	e0e8      	b.n	80118ec <HAL_SPI_Receive+0x228>
  }

  /* Process Locked */
  __HAL_LOCK(hspi);
 801171a:	68fb      	ldr	r3, [r7, #12]
 801171c:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8011720:	2b01      	cmp	r3, #1
 8011722:	d101      	bne.n	8011728 <HAL_SPI_Receive+0x64>
 8011724:	2302      	movs	r3, #2
 8011726:	e0e1      	b.n	80118ec <HAL_SPI_Receive+0x228>
 8011728:	68fb      	ldr	r3, [r7, #12]
 801172a:	2201      	movs	r2, #1
 801172c:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8011730:	f7f7 faa8 	bl	8008c84 <HAL_GetTick>
 8011734:	6138      	str	r0, [r7, #16]

  if ((pData == NULL) || (Size == 0U))
 8011736:	68bb      	ldr	r3, [r7, #8]
 8011738:	2b00      	cmp	r3, #0
 801173a:	d002      	beq.n	8011742 <HAL_SPI_Receive+0x7e>
 801173c:	88fb      	ldrh	r3, [r7, #6]
 801173e:	2b00      	cmp	r3, #0
 8011740:	d102      	bne.n	8011748 <HAL_SPI_Receive+0x84>
  {
    errorcode = HAL_ERROR;
 8011742:	2301      	movs	r3, #1
 8011744:	75fb      	strb	r3, [r7, #23]
    goto error;
 8011746:	e0cc      	b.n	80118e2 <HAL_SPI_Receive+0x21e>
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_RX;
 8011748:	68fb      	ldr	r3, [r7, #12]
 801174a:	2204      	movs	r2, #4
 801174c:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8011750:	68fb      	ldr	r3, [r7, #12]
 8011752:	2200      	movs	r2, #0
 8011754:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pData;
 8011756:	68fb      	ldr	r3, [r7, #12]
 8011758:	68ba      	ldr	r2, [r7, #8]
 801175a:	639a      	str	r2, [r3, #56]	@ 0x38
  hspi->RxXferSize  = Size;
 801175c:	68fb      	ldr	r3, [r7, #12]
 801175e:	88fa      	ldrh	r2, [r7, #6]
 8011760:	879a      	strh	r2, [r3, #60]	@ 0x3c
  hspi->RxXferCount = Size;
 8011762:	68fb      	ldr	r3, [r7, #12]
 8011764:	88fa      	ldrh	r2, [r7, #6]
 8011766:	87da      	strh	r2, [r3, #62]	@ 0x3e

  /*Init field not used in handle to zero */
  hspi->pTxBuffPtr  = (uint8_t *)NULL;
 8011768:	68fb      	ldr	r3, [r7, #12]
 801176a:	2200      	movs	r2, #0
 801176c:	631a      	str	r2, [r3, #48]	@ 0x30
  hspi->TxXferSize  = 0U;
 801176e:	68fb      	ldr	r3, [r7, #12]
 8011770:	2200      	movs	r2, #0
 8011772:	869a      	strh	r2, [r3, #52]	@ 0x34
  hspi->TxXferCount = 0U;
 8011774:	68fb      	ldr	r3, [r7, #12]
 8011776:	2200      	movs	r2, #0
 8011778:	86da      	strh	r2, [r3, #54]	@ 0x36
  hspi->RxISR       = NULL;
 801177a:	68fb      	ldr	r3, [r7, #12]
 801177c:	2200      	movs	r2, #0
 801177e:	641a      	str	r2, [r3, #64]	@ 0x40
  hspi->TxISR       = NULL;
 8011780:	68fb      	ldr	r3, [r7, #12]
 8011782:	2200      	movs	r2, #0
 8011784:	645a      	str	r2, [r3, #68]	@ 0x44
    hspi->RxXferCount--;
  }
#endif /* USE_SPI_CRC */

  /* Configure communication direction: 1Line */
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8011786:	68fb      	ldr	r3, [r7, #12]
 8011788:	689b      	ldr	r3, [r3, #8]
 801178a:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 801178e:	d10f      	bne.n	80117b0 <HAL_SPI_Receive+0xec>
  {
    /* Disable SPI Peripheral before set 1Line direction (BIDIOE bit) */
    __HAL_SPI_DISABLE(hspi);
 8011790:	68fb      	ldr	r3, [r7, #12]
 8011792:	681b      	ldr	r3, [r3, #0]
 8011794:	681a      	ldr	r2, [r3, #0]
 8011796:	68fb      	ldr	r3, [r7, #12]
 8011798:	681b      	ldr	r3, [r3, #0]
 801179a:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 801179e:	601a      	str	r2, [r3, #0]
    SPI_1LINE_RX(hspi);
 80117a0:	68fb      	ldr	r3, [r7, #12]
 80117a2:	681b      	ldr	r3, [r3, #0]
 80117a4:	681a      	ldr	r2, [r3, #0]
 80117a6:	68fb      	ldr	r3, [r7, #12]
 80117a8:	681b      	ldr	r3, [r3, #0]
 80117aa:	f422 4280 	bic.w	r2, r2, #16384	@ 0x4000
 80117ae:	601a      	str	r2, [r3, #0]
  }

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80117b0:	68fb      	ldr	r3, [r7, #12]
 80117b2:	681b      	ldr	r3, [r3, #0]
 80117b4:	681b      	ldr	r3, [r3, #0]
 80117b6:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80117ba:	2b40      	cmp	r3, #64	@ 0x40
 80117bc:	d007      	beq.n	80117ce <HAL_SPI_Receive+0x10a>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80117be:	68fb      	ldr	r3, [r7, #12]
 80117c0:	681b      	ldr	r3, [r3, #0]
 80117c2:	681a      	ldr	r2, [r3, #0]
 80117c4:	68fb      	ldr	r3, [r7, #12]
 80117c6:	681b      	ldr	r3, [r3, #0]
 80117c8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80117cc:	601a      	str	r2, [r3, #0]
  }

  /* Receive data in 8 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_8BIT)
 80117ce:	68fb      	ldr	r3, [r7, #12]
 80117d0:	68db      	ldr	r3, [r3, #12]
 80117d2:	2b00      	cmp	r3, #0
 80117d4:	d16a      	bne.n	80118ac <HAL_SPI_Receive+0x1e8>
  {
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
 80117d6:	e032      	b.n	801183e <HAL_SPI_Receive+0x17a>
    {
      /* Check the RXNE flag */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 80117d8:	68fb      	ldr	r3, [r7, #12]
 80117da:	681b      	ldr	r3, [r3, #0]
 80117dc:	689b      	ldr	r3, [r3, #8]
 80117de:	f003 0301 	and.w	r3, r3, #1
 80117e2:	2b01      	cmp	r3, #1
 80117e4:	d115      	bne.n	8011812 <HAL_SPI_Receive+0x14e>
      {
        /* read the received data */
        (* (uint8_t *)hspi->pRxBuffPtr) = *(__IO uint8_t *)&hspi->Instance->DR;
 80117e6:	68fb      	ldr	r3, [r7, #12]
 80117e8:	681b      	ldr	r3, [r3, #0]
 80117ea:	f103 020c 	add.w	r2, r3, #12
 80117ee:	68fb      	ldr	r3, [r7, #12]
 80117f0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80117f2:	7812      	ldrb	r2, [r2, #0]
 80117f4:	b2d2      	uxtb	r2, r2
 80117f6:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint8_t);
 80117f8:	68fb      	ldr	r3, [r7, #12]
 80117fa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80117fc:	1c5a      	adds	r2, r3, #1
 80117fe:	68fb      	ldr	r3, [r7, #12]
 8011800:	639a      	str	r2, [r3, #56]	@ 0x38
        hspi->RxXferCount--;
 8011802:	68fb      	ldr	r3, [r7, #12]
 8011804:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011806:	b29b      	uxth	r3, r3
 8011808:	3b01      	subs	r3, #1
 801180a:	b29a      	uxth	r2, r3
 801180c:	68fb      	ldr	r3, [r7, #12]
 801180e:	87da      	strh	r2, [r3, #62]	@ 0x3e
 8011810:	e015      	b.n	801183e <HAL_SPI_Receive+0x17a>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8011812:	f7f7 fa37 	bl	8008c84 <HAL_GetTick>
 8011816:	4602      	mov	r2, r0
 8011818:	693b      	ldr	r3, [r7, #16]
 801181a:	1ad3      	subs	r3, r2, r3
 801181c:	683a      	ldr	r2, [r7, #0]
 801181e:	429a      	cmp	r2, r3
 8011820:	d803      	bhi.n	801182a <HAL_SPI_Receive+0x166>
 8011822:	683b      	ldr	r3, [r7, #0]
 8011824:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011828:	d102      	bne.n	8011830 <HAL_SPI_Receive+0x16c>
 801182a:	683b      	ldr	r3, [r7, #0]
 801182c:	2b00      	cmp	r3, #0
 801182e:	d106      	bne.n	801183e <HAL_SPI_Receive+0x17a>
        {
          errorcode = HAL_TIMEOUT;
 8011830:	2303      	movs	r3, #3
 8011832:	75fb      	strb	r3, [r7, #23]
          hspi->State = HAL_SPI_STATE_READY;
 8011834:	68fb      	ldr	r3, [r7, #12]
 8011836:	2201      	movs	r2, #1
 8011838:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
          goto error;
 801183c:	e051      	b.n	80118e2 <HAL_SPI_Receive+0x21e>
    while (hspi->RxXferCount > 0U)
 801183e:	68fb      	ldr	r3, [r7, #12]
 8011840:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011842:	b29b      	uxth	r3, r3
 8011844:	2b00      	cmp	r3, #0
 8011846:	d1c7      	bne.n	80117d8 <HAL_SPI_Receive+0x114>
 8011848:	e035      	b.n	80118b6 <HAL_SPI_Receive+0x1f2>
  {
    /* Transfer loop */
    while (hspi->RxXferCount > 0U)
    {
      /* Check the RXNE flag */
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE))
 801184a:	68fb      	ldr	r3, [r7, #12]
 801184c:	681b      	ldr	r3, [r3, #0]
 801184e:	689b      	ldr	r3, [r3, #8]
 8011850:	f003 0301 	and.w	r3, r3, #1
 8011854:	2b01      	cmp	r3, #1
 8011856:	d113      	bne.n	8011880 <HAL_SPI_Receive+0x1bc>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8011858:	68fb      	ldr	r3, [r7, #12]
 801185a:	681b      	ldr	r3, [r3, #0]
 801185c:	68da      	ldr	r2, [r3, #12]
 801185e:	68fb      	ldr	r3, [r7, #12]
 8011860:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011862:	b292      	uxth	r2, r2
 8011864:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8011866:	68fb      	ldr	r3, [r7, #12]
 8011868:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801186a:	1c9a      	adds	r2, r3, #2
 801186c:	68fb      	ldr	r3, [r7, #12]
 801186e:	639a      	str	r2, [r3, #56]	@ 0x38
        hspi->RxXferCount--;
 8011870:	68fb      	ldr	r3, [r7, #12]
 8011872:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011874:	b29b      	uxth	r3, r3
 8011876:	3b01      	subs	r3, #1
 8011878:	b29a      	uxth	r2, r3
 801187a:	68fb      	ldr	r3, [r7, #12]
 801187c:	87da      	strh	r2, [r3, #62]	@ 0x3e
 801187e:	e015      	b.n	80118ac <HAL_SPI_Receive+0x1e8>
      }
      else
      {
        /* Timeout management */
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8011880:	f7f7 fa00 	bl	8008c84 <HAL_GetTick>
 8011884:	4602      	mov	r2, r0
 8011886:	693b      	ldr	r3, [r7, #16]
 8011888:	1ad3      	subs	r3, r2, r3
 801188a:	683a      	ldr	r2, [r7, #0]
 801188c:	429a      	cmp	r2, r3
 801188e:	d803      	bhi.n	8011898 <HAL_SPI_Receive+0x1d4>
 8011890:	683b      	ldr	r3, [r7, #0]
 8011892:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011896:	d102      	bne.n	801189e <HAL_SPI_Receive+0x1da>
 8011898:	683b      	ldr	r3, [r7, #0]
 801189a:	2b00      	cmp	r3, #0
 801189c:	d106      	bne.n	80118ac <HAL_SPI_Receive+0x1e8>
        {
          errorcode = HAL_TIMEOUT;
 801189e:	2303      	movs	r3, #3
 80118a0:	75fb      	strb	r3, [r7, #23]
          hspi->State = HAL_SPI_STATE_READY;
 80118a2:	68fb      	ldr	r3, [r7, #12]
 80118a4:	2201      	movs	r2, #1
 80118a6:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
          goto error;
 80118aa:	e01a      	b.n	80118e2 <HAL_SPI_Receive+0x21e>
    while (hspi->RxXferCount > 0U)
 80118ac:	68fb      	ldr	r3, [r7, #12]
 80118ae:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 80118b0:	b29b      	uxth	r3, r3
 80118b2:	2b00      	cmp	r3, #0
 80118b4:	d1c9      	bne.n	801184a <HAL_SPI_Receive+0x186>
    UNUSED(tmpreg);
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 80118b6:	693a      	ldr	r2, [r7, #16]
 80118b8:	6839      	ldr	r1, [r7, #0]
 80118ba:	68f8      	ldr	r0, [r7, #12]
 80118bc:	f000 fb5a 	bl	8011f74 <SPI_EndRxTransaction>
 80118c0:	4603      	mov	r3, r0
 80118c2:	2b00      	cmp	r3, #0
 80118c4:	d002      	beq.n	80118cc <HAL_SPI_Receive+0x208>
  {
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 80118c6:	68fb      	ldr	r3, [r7, #12]
 80118c8:	2220      	movs	r2, #32
 80118ca:	655a      	str	r2, [r3, #84]	@ 0x54
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_CRC);
    __HAL_SPI_CLEAR_CRCERRFLAG(hspi);
  }
#endif /* USE_SPI_CRC */

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 80118cc:	68fb      	ldr	r3, [r7, #12]
 80118ce:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80118d0:	2b00      	cmp	r3, #0
 80118d2:	d002      	beq.n	80118da <HAL_SPI_Receive+0x216>
  {
    errorcode = HAL_ERROR;
 80118d4:	2301      	movs	r3, #1
 80118d6:	75fb      	strb	r3, [r7, #23]
 80118d8:	e003      	b.n	80118e2 <HAL_SPI_Receive+0x21e>
  }
  else
  {
    hspi->State = HAL_SPI_STATE_READY;
 80118da:	68fb      	ldr	r3, [r7, #12]
 80118dc:	2201      	movs	r2, #1
 80118de:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  }

error :
  __HAL_UNLOCK(hspi);
 80118e2:	68fb      	ldr	r3, [r7, #12]
 80118e4:	2200      	movs	r2, #0
 80118e6:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  return errorcode;
 80118ea:	7dfb      	ldrb	r3, [r7, #23]
}
 80118ec:	4618      	mov	r0, r3
 80118ee:	3718      	adds	r7, #24
 80118f0:	46bd      	mov	sp, r7
 80118f2:	bd80      	pop	{r7, pc}

080118f4 <HAL_SPI_TransmitReceive>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, uint8_t *pTxData, uint8_t *pRxData, uint16_t Size,
                                          uint32_t Timeout)
{
 80118f4:	b580      	push	{r7, lr}
 80118f6:	b08c      	sub	sp, #48	@ 0x30
 80118f8:	af00      	add	r7, sp, #0
 80118fa:	60f8      	str	r0, [r7, #12]
 80118fc:	60b9      	str	r1, [r7, #8]
 80118fe:	607a      	str	r2, [r7, #4]
 8011900:	807b      	strh	r3, [r7, #2]
#if (USE_SPI_CRC != 0U)
  __IO uint32_t tmpreg = 0U;
#endif /* USE_SPI_CRC */

  /* Variable used to alternate Rx and Tx during transfer */
  uint32_t             txallowed = 1U;
 8011902:	2301      	movs	r3, #1
 8011904:	62fb      	str	r3, [r7, #44]	@ 0x2c
  HAL_StatusTypeDef    errorcode = HAL_OK;
 8011906:	2300      	movs	r3, #0
 8011908:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 801190c:	68fb      	ldr	r3, [r7, #12]
 801190e:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8011912:	2b01      	cmp	r3, #1
 8011914:	d101      	bne.n	801191a <HAL_SPI_TransmitReceive+0x26>
 8011916:	2302      	movs	r3, #2
 8011918:	e198      	b.n	8011c4c <HAL_SPI_TransmitReceive+0x358>
 801191a:	68fb      	ldr	r3, [r7, #12]
 801191c:	2201      	movs	r2, #1
 801191e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8011922:	f7f7 f9af 	bl	8008c84 <HAL_GetTick>
 8011926:	6278      	str	r0, [r7, #36]	@ 0x24

  /* Init temporary variables */
  tmp_state           = hspi->State;
 8011928:	68fb      	ldr	r3, [r7, #12]
 801192a:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 801192e:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
  tmp_mode            = hspi->Init.Mode;
 8011932:	68fb      	ldr	r3, [r7, #12]
 8011934:	685b      	ldr	r3, [r3, #4]
 8011936:	61fb      	str	r3, [r7, #28]
  initial_TxXferCount = Size;
 8011938:	887b      	ldrh	r3, [r7, #2]
 801193a:	837b      	strh	r3, [r7, #26]

  if (!((tmp_state == HAL_SPI_STATE_READY) || \
 801193c:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8011940:	2b01      	cmp	r3, #1
 8011942:	d00f      	beq.n	8011964 <HAL_SPI_TransmitReceive+0x70>
 8011944:	69fb      	ldr	r3, [r7, #28]
 8011946:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 801194a:	d107      	bne.n	801195c <HAL_SPI_TransmitReceive+0x68>
        ((tmp_mode == SPI_MODE_MASTER) && (hspi->Init.Direction == SPI_DIRECTION_2LINES) && (tmp_state == HAL_SPI_STATE_BUSY_RX))))
 801194c:	68fb      	ldr	r3, [r7, #12]
 801194e:	689b      	ldr	r3, [r3, #8]
 8011950:	2b00      	cmp	r3, #0
 8011952:	d103      	bne.n	801195c <HAL_SPI_TransmitReceive+0x68>
 8011954:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8011958:	2b04      	cmp	r3, #4
 801195a:	d003      	beq.n	8011964 <HAL_SPI_TransmitReceive+0x70>
  {
    errorcode = HAL_BUSY;
 801195c:	2302      	movs	r3, #2
 801195e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    goto error;
 8011962:	e16d      	b.n	8011c40 <HAL_SPI_TransmitReceive+0x34c>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0U))
 8011964:	68bb      	ldr	r3, [r7, #8]
 8011966:	2b00      	cmp	r3, #0
 8011968:	d005      	beq.n	8011976 <HAL_SPI_TransmitReceive+0x82>
 801196a:	687b      	ldr	r3, [r7, #4]
 801196c:	2b00      	cmp	r3, #0
 801196e:	d002      	beq.n	8011976 <HAL_SPI_TransmitReceive+0x82>
 8011970:	887b      	ldrh	r3, [r7, #2]
 8011972:	2b00      	cmp	r3, #0
 8011974:	d103      	bne.n	801197e <HAL_SPI_TransmitReceive+0x8a>
  {
    errorcode = HAL_ERROR;
 8011976:	2301      	movs	r3, #1
 8011978:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    goto error;
 801197c:	e160      	b.n	8011c40 <HAL_SPI_TransmitReceive+0x34c>
  }

  /* Don't overwrite in case of HAL_SPI_STATE_BUSY_RX */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 801197e:	68fb      	ldr	r3, [r7, #12]
 8011980:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 8011984:	b2db      	uxtb	r3, r3
 8011986:	2b04      	cmp	r3, #4
 8011988:	d003      	beq.n	8011992 <HAL_SPI_TransmitReceive+0x9e>
  {
    hspi->State = HAL_SPI_STATE_BUSY_TX_RX;
 801198a:	68fb      	ldr	r3, [r7, #12]
 801198c:	2205      	movs	r2, #5
 801198e:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  }

  /* Set the transaction information */
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8011992:	68fb      	ldr	r3, [r7, #12]
 8011994:	2200      	movs	r2, #0
 8011996:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8011998:	68fb      	ldr	r3, [r7, #12]
 801199a:	687a      	ldr	r2, [r7, #4]
 801199c:	639a      	str	r2, [r3, #56]	@ 0x38
  hspi->RxXferCount = Size;
 801199e:	68fb      	ldr	r3, [r7, #12]
 80119a0:	887a      	ldrh	r2, [r7, #2]
 80119a2:	87da      	strh	r2, [r3, #62]	@ 0x3e
  hspi->RxXferSize  = Size;
 80119a4:	68fb      	ldr	r3, [r7, #12]
 80119a6:	887a      	ldrh	r2, [r7, #2]
 80119a8:	879a      	strh	r2, [r3, #60]	@ 0x3c
  hspi->pTxBuffPtr  = (uint8_t *)pTxData;
 80119aa:	68fb      	ldr	r3, [r7, #12]
 80119ac:	68ba      	ldr	r2, [r7, #8]
 80119ae:	631a      	str	r2, [r3, #48]	@ 0x30
  hspi->TxXferCount = Size;
 80119b0:	68fb      	ldr	r3, [r7, #12]
 80119b2:	887a      	ldrh	r2, [r7, #2]
 80119b4:	86da      	strh	r2, [r3, #54]	@ 0x36
  hspi->TxXferSize  = Size;
 80119b6:	68fb      	ldr	r3, [r7, #12]
 80119b8:	887a      	ldrh	r2, [r7, #2]
 80119ba:	869a      	strh	r2, [r3, #52]	@ 0x34

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 80119bc:	68fb      	ldr	r3, [r7, #12]
 80119be:	2200      	movs	r2, #0
 80119c0:	641a      	str	r2, [r3, #64]	@ 0x40
  hspi->TxISR       = NULL;
 80119c2:	68fb      	ldr	r3, [r7, #12]
 80119c4:	2200      	movs	r2, #0
 80119c6:	645a      	str	r2, [r3, #68]	@ 0x44
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 80119c8:	68fb      	ldr	r3, [r7, #12]
 80119ca:	681b      	ldr	r3, [r3, #0]
 80119cc:	681b      	ldr	r3, [r3, #0]
 80119ce:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80119d2:	2b40      	cmp	r3, #64	@ 0x40
 80119d4:	d007      	beq.n	80119e6 <HAL_SPI_TransmitReceive+0xf2>
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 80119d6:	68fb      	ldr	r3, [r7, #12]
 80119d8:	681b      	ldr	r3, [r3, #0]
 80119da:	681a      	ldr	r2, [r3, #0]
 80119dc:	68fb      	ldr	r3, [r7, #12]
 80119de:	681b      	ldr	r3, [r3, #0]
 80119e0:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 80119e4:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 16 Bit mode */
  if (hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 80119e6:	68fb      	ldr	r3, [r7, #12]
 80119e8:	68db      	ldr	r3, [r3, #12]
 80119ea:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 80119ee:	d17c      	bne.n	8011aea <HAL_SPI_TransmitReceive+0x1f6>
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 80119f0:	68fb      	ldr	r3, [r7, #12]
 80119f2:	685b      	ldr	r3, [r3, #4]
 80119f4:	2b00      	cmp	r3, #0
 80119f6:	d002      	beq.n	80119fe <HAL_SPI_TransmitReceive+0x10a>
 80119f8:	8b7b      	ldrh	r3, [r7, #26]
 80119fa:	2b01      	cmp	r3, #1
 80119fc:	d16a      	bne.n	8011ad4 <HAL_SPI_TransmitReceive+0x1e0>
    {
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 80119fe:	68fb      	ldr	r3, [r7, #12]
 8011a00:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011a02:	881a      	ldrh	r2, [r3, #0]
 8011a04:	68fb      	ldr	r3, [r7, #12]
 8011a06:	681b      	ldr	r3, [r3, #0]
 8011a08:	60da      	str	r2, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8011a0a:	68fb      	ldr	r3, [r7, #12]
 8011a0c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011a0e:	1c9a      	adds	r2, r3, #2
 8011a10:	68fb      	ldr	r3, [r7, #12]
 8011a12:	631a      	str	r2, [r3, #48]	@ 0x30
      hspi->TxXferCount--;
 8011a14:	68fb      	ldr	r3, [r7, #12]
 8011a16:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011a18:	b29b      	uxth	r3, r3
 8011a1a:	3b01      	subs	r3, #1
 8011a1c:	b29a      	uxth	r2, r3
 8011a1e:	68fb      	ldr	r3, [r7, #12]
 8011a20:	86da      	strh	r2, [r3, #54]	@ 0x36
        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
      }
#endif /* USE_SPI_CRC */

    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8011a22:	e057      	b.n	8011ad4 <HAL_SPI_TransmitReceive+0x1e0>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8011a24:	68fb      	ldr	r3, [r7, #12]
 8011a26:	681b      	ldr	r3, [r3, #0]
 8011a28:	689b      	ldr	r3, [r3, #8]
 8011a2a:	f003 0302 	and.w	r3, r3, #2
 8011a2e:	2b02      	cmp	r3, #2
 8011a30:	d11b      	bne.n	8011a6a <HAL_SPI_TransmitReceive+0x176>
 8011a32:	68fb      	ldr	r3, [r7, #12]
 8011a34:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011a36:	b29b      	uxth	r3, r3
 8011a38:	2b00      	cmp	r3, #0
 8011a3a:	d016      	beq.n	8011a6a <HAL_SPI_TransmitReceive+0x176>
 8011a3c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011a3e:	2b01      	cmp	r3, #1
 8011a40:	d113      	bne.n	8011a6a <HAL_SPI_TransmitReceive+0x176>
      {
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8011a42:	68fb      	ldr	r3, [r7, #12]
 8011a44:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011a46:	881a      	ldrh	r2, [r3, #0]
 8011a48:	68fb      	ldr	r3, [r7, #12]
 8011a4a:	681b      	ldr	r3, [r3, #0]
 8011a4c:	60da      	str	r2, [r3, #12]
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8011a4e:	68fb      	ldr	r3, [r7, #12]
 8011a50:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011a52:	1c9a      	adds	r2, r3, #2
 8011a54:	68fb      	ldr	r3, [r7, #12]
 8011a56:	631a      	str	r2, [r3, #48]	@ 0x30
        hspi->TxXferCount--;
 8011a58:	68fb      	ldr	r3, [r7, #12]
 8011a5a:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011a5c:	b29b      	uxth	r3, r3
 8011a5e:	3b01      	subs	r3, #1
 8011a60:	b29a      	uxth	r2, r3
 8011a62:	68fb      	ldr	r3, [r7, #12]
 8011a64:	86da      	strh	r2, [r3, #54]	@ 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 8011a66:	2300      	movs	r3, #0
 8011a68:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Check RXNE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8011a6a:	68fb      	ldr	r3, [r7, #12]
 8011a6c:	681b      	ldr	r3, [r3, #0]
 8011a6e:	689b      	ldr	r3, [r3, #8]
 8011a70:	f003 0301 	and.w	r3, r3, #1
 8011a74:	2b01      	cmp	r3, #1
 8011a76:	d119      	bne.n	8011aac <HAL_SPI_TransmitReceive+0x1b8>
 8011a78:	68fb      	ldr	r3, [r7, #12]
 8011a7a:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011a7c:	b29b      	uxth	r3, r3
 8011a7e:	2b00      	cmp	r3, #0
 8011a80:	d014      	beq.n	8011aac <HAL_SPI_TransmitReceive+0x1b8>
      {
        *((uint16_t *)hspi->pRxBuffPtr) = (uint16_t)hspi->Instance->DR;
 8011a82:	68fb      	ldr	r3, [r7, #12]
 8011a84:	681b      	ldr	r3, [r3, #0]
 8011a86:	68da      	ldr	r2, [r3, #12]
 8011a88:	68fb      	ldr	r3, [r7, #12]
 8011a8a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011a8c:	b292      	uxth	r2, r2
 8011a8e:	801a      	strh	r2, [r3, #0]
        hspi->pRxBuffPtr += sizeof(uint16_t);
 8011a90:	68fb      	ldr	r3, [r7, #12]
 8011a92:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011a94:	1c9a      	adds	r2, r3, #2
 8011a96:	68fb      	ldr	r3, [r7, #12]
 8011a98:	639a      	str	r2, [r3, #56]	@ 0x38
        hspi->RxXferCount--;
 8011a9a:	68fb      	ldr	r3, [r7, #12]
 8011a9c:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011a9e:	b29b      	uxth	r3, r3
 8011aa0:	3b01      	subs	r3, #1
 8011aa2:	b29a      	uxth	r2, r3
 8011aa4:	68fb      	ldr	r3, [r7, #12]
 8011aa6:	87da      	strh	r2, [r3, #62]	@ 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 8011aa8:	2301      	movs	r3, #1
 8011aaa:	62fb      	str	r3, [r7, #44]	@ 0x2c
      }
      if (((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY))
 8011aac:	f7f7 f8ea 	bl	8008c84 <HAL_GetTick>
 8011ab0:	4602      	mov	r2, r0
 8011ab2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011ab4:	1ad3      	subs	r3, r2, r3
 8011ab6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011ab8:	429a      	cmp	r2, r3
 8011aba:	d80b      	bhi.n	8011ad4 <HAL_SPI_TransmitReceive+0x1e0>
 8011abc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011abe:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011ac2:	d007      	beq.n	8011ad4 <HAL_SPI_TransmitReceive+0x1e0>
      {
        errorcode = HAL_TIMEOUT;
 8011ac4:	2303      	movs	r3, #3
 8011ac6:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
        hspi->State = HAL_SPI_STATE_READY;
 8011aca:	68fb      	ldr	r3, [r7, #12]
 8011acc:	2201      	movs	r2, #1
 8011ace:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
        goto error;
 8011ad2:	e0b5      	b.n	8011c40 <HAL_SPI_TransmitReceive+0x34c>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8011ad4:	68fb      	ldr	r3, [r7, #12]
 8011ad6:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011ad8:	b29b      	uxth	r3, r3
 8011ada:	2b00      	cmp	r3, #0
 8011adc:	d1a2      	bne.n	8011a24 <HAL_SPI_TransmitReceive+0x130>
 8011ade:	68fb      	ldr	r3, [r7, #12]
 8011ae0:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011ae2:	b29b      	uxth	r3, r3
 8011ae4:	2b00      	cmp	r3, #0
 8011ae6:	d19d      	bne.n	8011a24 <HAL_SPI_TransmitReceive+0x130>
 8011ae8:	e080      	b.n	8011bec <HAL_SPI_TransmitReceive+0x2f8>
    }
  }
  /* Transmit and Receive data in 8 Bit mode */
  else
  {
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8011aea:	68fb      	ldr	r3, [r7, #12]
 8011aec:	685b      	ldr	r3, [r3, #4]
 8011aee:	2b00      	cmp	r3, #0
 8011af0:	d002      	beq.n	8011af8 <HAL_SPI_TransmitReceive+0x204>
 8011af2:	8b7b      	ldrh	r3, [r7, #26]
 8011af4:	2b01      	cmp	r3, #1
 8011af6:	d16f      	bne.n	8011bd8 <HAL_SPI_TransmitReceive+0x2e4>
    {
      *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8011af8:	68fb      	ldr	r3, [r7, #12]
 8011afa:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8011afc:	68fb      	ldr	r3, [r7, #12]
 8011afe:	681b      	ldr	r3, [r3, #0]
 8011b00:	330c      	adds	r3, #12
 8011b02:	7812      	ldrb	r2, [r2, #0]
 8011b04:	701a      	strb	r2, [r3, #0]
      hspi->pTxBuffPtr += sizeof(uint8_t);
 8011b06:	68fb      	ldr	r3, [r7, #12]
 8011b08:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011b0a:	1c5a      	adds	r2, r3, #1
 8011b0c:	68fb      	ldr	r3, [r7, #12]
 8011b0e:	631a      	str	r2, [r3, #48]	@ 0x30
      hspi->TxXferCount--;
 8011b10:	68fb      	ldr	r3, [r7, #12]
 8011b12:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011b14:	b29b      	uxth	r3, r3
 8011b16:	3b01      	subs	r3, #1
 8011b18:	b29a      	uxth	r2, r3
 8011b1a:	68fb      	ldr	r3, [r7, #12]
 8011b1c:	86da      	strh	r2, [r3, #54]	@ 0x36
      {
        SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
      }
#endif /* USE_SPI_CRC */
    }
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8011b1e:	e05b      	b.n	8011bd8 <HAL_SPI_TransmitReceive+0x2e4>
    {
      /* Check TXE flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE)) && (hspi->TxXferCount > 0U) && (txallowed == 1U))
 8011b20:	68fb      	ldr	r3, [r7, #12]
 8011b22:	681b      	ldr	r3, [r3, #0]
 8011b24:	689b      	ldr	r3, [r3, #8]
 8011b26:	f003 0302 	and.w	r3, r3, #2
 8011b2a:	2b02      	cmp	r3, #2
 8011b2c:	d11c      	bne.n	8011b68 <HAL_SPI_TransmitReceive+0x274>
 8011b2e:	68fb      	ldr	r3, [r7, #12]
 8011b30:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011b32:	b29b      	uxth	r3, r3
 8011b34:	2b00      	cmp	r3, #0
 8011b36:	d017      	beq.n	8011b68 <HAL_SPI_TransmitReceive+0x274>
 8011b38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8011b3a:	2b01      	cmp	r3, #1
 8011b3c:	d114      	bne.n	8011b68 <HAL_SPI_TransmitReceive+0x274>
      {
        *(__IO uint8_t *)&hspi->Instance->DR = (*hspi->pTxBuffPtr);
 8011b3e:	68fb      	ldr	r3, [r7, #12]
 8011b40:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8011b42:	68fb      	ldr	r3, [r7, #12]
 8011b44:	681b      	ldr	r3, [r3, #0]
 8011b46:	330c      	adds	r3, #12
 8011b48:	7812      	ldrb	r2, [r2, #0]
 8011b4a:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr++;
 8011b4c:	68fb      	ldr	r3, [r7, #12]
 8011b4e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8011b50:	1c5a      	adds	r2, r3, #1
 8011b52:	68fb      	ldr	r3, [r7, #12]
 8011b54:	631a      	str	r2, [r3, #48]	@ 0x30
        hspi->TxXferCount--;
 8011b56:	68fb      	ldr	r3, [r7, #12]
 8011b58:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011b5a:	b29b      	uxth	r3, r3
 8011b5c:	3b01      	subs	r3, #1
 8011b5e:	b29a      	uxth	r2, r3
 8011b60:	68fb      	ldr	r3, [r7, #12]
 8011b62:	86da      	strh	r2, [r3, #54]	@ 0x36
        /* Next Data is a reception (Rx). Tx not allowed */
        txallowed = 0U;
 8011b64:	2300      	movs	r3, #0
 8011b66:	62fb      	str	r3, [r7, #44]	@ 0x2c
        }
#endif /* USE_SPI_CRC */
      }

      /* Wait until RXNE flag is reset */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXNE)) && (hspi->RxXferCount > 0U))
 8011b68:	68fb      	ldr	r3, [r7, #12]
 8011b6a:	681b      	ldr	r3, [r3, #0]
 8011b6c:	689b      	ldr	r3, [r3, #8]
 8011b6e:	f003 0301 	and.w	r3, r3, #1
 8011b72:	2b01      	cmp	r3, #1
 8011b74:	d119      	bne.n	8011baa <HAL_SPI_TransmitReceive+0x2b6>
 8011b76:	68fb      	ldr	r3, [r7, #12]
 8011b78:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011b7a:	b29b      	uxth	r3, r3
 8011b7c:	2b00      	cmp	r3, #0
 8011b7e:	d014      	beq.n	8011baa <HAL_SPI_TransmitReceive+0x2b6>
      {
        (*(uint8_t *)hspi->pRxBuffPtr) = hspi->Instance->DR;
 8011b80:	68fb      	ldr	r3, [r7, #12]
 8011b82:	681b      	ldr	r3, [r3, #0]
 8011b84:	68da      	ldr	r2, [r3, #12]
 8011b86:	68fb      	ldr	r3, [r7, #12]
 8011b88:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011b8a:	b2d2      	uxtb	r2, r2
 8011b8c:	701a      	strb	r2, [r3, #0]
        hspi->pRxBuffPtr++;
 8011b8e:	68fb      	ldr	r3, [r7, #12]
 8011b90:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011b92:	1c5a      	adds	r2, r3, #1
 8011b94:	68fb      	ldr	r3, [r7, #12]
 8011b96:	639a      	str	r2, [r3, #56]	@ 0x38
        hspi->RxXferCount--;
 8011b98:	68fb      	ldr	r3, [r7, #12]
 8011b9a:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011b9c:	b29b      	uxth	r3, r3
 8011b9e:	3b01      	subs	r3, #1
 8011ba0:	b29a      	uxth	r2, r3
 8011ba2:	68fb      	ldr	r3, [r7, #12]
 8011ba4:	87da      	strh	r2, [r3, #62]	@ 0x3e
        /* Next Data is a Transmission (Tx). Tx is allowed */
        txallowed = 1U;
 8011ba6:	2301      	movs	r3, #1
 8011ba8:	62fb      	str	r3, [r7, #44]	@ 0x2c
      }
      if ((((HAL_GetTick() - tickstart) >=  Timeout) && ((Timeout != HAL_MAX_DELAY))) || (Timeout == 0U))
 8011baa:	f7f7 f86b 	bl	8008c84 <HAL_GetTick>
 8011bae:	4602      	mov	r2, r0
 8011bb0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8011bb2:	1ad3      	subs	r3, r2, r3
 8011bb4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8011bb6:	429a      	cmp	r2, r3
 8011bb8:	d803      	bhi.n	8011bc2 <HAL_SPI_TransmitReceive+0x2ce>
 8011bba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bbc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011bc0:	d102      	bne.n	8011bc8 <HAL_SPI_TransmitReceive+0x2d4>
 8011bc2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8011bc4:	2b00      	cmp	r3, #0
 8011bc6:	d107      	bne.n	8011bd8 <HAL_SPI_TransmitReceive+0x2e4>
      {
        errorcode = HAL_TIMEOUT;
 8011bc8:	2303      	movs	r3, #3
 8011bca:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
        hspi->State = HAL_SPI_STATE_READY;
 8011bce:	68fb      	ldr	r3, [r7, #12]
 8011bd0:	2201      	movs	r2, #1
 8011bd2:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
        goto error;
 8011bd6:	e033      	b.n	8011c40 <HAL_SPI_TransmitReceive+0x34c>
    while ((hspi->TxXferCount > 0U) || (hspi->RxXferCount > 0U))
 8011bd8:	68fb      	ldr	r3, [r7, #12]
 8011bda:	8edb      	ldrh	r3, [r3, #54]	@ 0x36
 8011bdc:	b29b      	uxth	r3, r3
 8011bde:	2b00      	cmp	r3, #0
 8011be0:	d19e      	bne.n	8011b20 <HAL_SPI_TransmitReceive+0x22c>
 8011be2:	68fb      	ldr	r3, [r7, #12]
 8011be4:	8fdb      	ldrh	r3, [r3, #62]	@ 0x3e
 8011be6:	b29b      	uxth	r3, r3
 8011be8:	2b00      	cmp	r3, #0
 8011bea:	d199      	bne.n	8011b20 <HAL_SPI_TransmitReceive+0x22c>
    errorcode = HAL_ERROR;
  }
#endif /* USE_SPI_CRC */

  /* Check the end of the transaction */
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8011bec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8011bee:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8011bf0:	68f8      	ldr	r0, [r7, #12]
 8011bf2:	f000 fa25 	bl	8012040 <SPI_EndRxTxTransaction>
 8011bf6:	4603      	mov	r3, r0
 8011bf8:	2b00      	cmp	r3, #0
 8011bfa:	d006      	beq.n	8011c0a <HAL_SPI_TransmitReceive+0x316>
  {
    errorcode = HAL_ERROR;
 8011bfc:	2301      	movs	r3, #1
 8011bfe:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8011c02:	68fb      	ldr	r3, [r7, #12]
 8011c04:	2220      	movs	r2, #32
 8011c06:	655a      	str	r2, [r3, #84]	@ 0x54
    goto error;
 8011c08:	e01a      	b.n	8011c40 <HAL_SPI_TransmitReceive+0x34c>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8011c0a:	68fb      	ldr	r3, [r7, #12]
 8011c0c:	689b      	ldr	r3, [r3, #8]
 8011c0e:	2b00      	cmp	r3, #0
 8011c10:	d10a      	bne.n	8011c28 <HAL_SPI_TransmitReceive+0x334>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8011c12:	2300      	movs	r3, #0
 8011c14:	617b      	str	r3, [r7, #20]
 8011c16:	68fb      	ldr	r3, [r7, #12]
 8011c18:	681b      	ldr	r3, [r3, #0]
 8011c1a:	68db      	ldr	r3, [r3, #12]
 8011c1c:	617b      	str	r3, [r7, #20]
 8011c1e:	68fb      	ldr	r3, [r7, #12]
 8011c20:	681b      	ldr	r3, [r3, #0]
 8011c22:	689b      	ldr	r3, [r3, #8]
 8011c24:	617b      	str	r3, [r7, #20]
 8011c26:	697b      	ldr	r3, [r7, #20]
  }

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8011c28:	68fb      	ldr	r3, [r7, #12]
 8011c2a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011c2c:	2b00      	cmp	r3, #0
 8011c2e:	d003      	beq.n	8011c38 <HAL_SPI_TransmitReceive+0x344>
  {
    errorcode = HAL_ERROR;
 8011c30:	2301      	movs	r3, #1
 8011c32:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
 8011c36:	e003      	b.n	8011c40 <HAL_SPI_TransmitReceive+0x34c>
  }
  else
  {
    hspi->State = HAL_SPI_STATE_READY;
 8011c38:	68fb      	ldr	r3, [r7, #12]
 8011c3a:	2201      	movs	r2, #1
 8011c3c:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
  }
  
error :
  __HAL_UNLOCK(hspi);
 8011c40:	68fb      	ldr	r3, [r7, #12]
 8011c42:	2200      	movs	r2, #0
 8011c44:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  return errorcode;
 8011c48:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
}
 8011c4c:	4618      	mov	r0, r3
 8011c4e:	3730      	adds	r7, #48	@ 0x30
 8011c50:	46bd      	mov	sp, r7
 8011c52:	bd80      	pop	{r7, pc}

08011c54 <HAL_SPI_IRQHandler>:
  * @param  hspi pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 8011c54:	b580      	push	{r7, lr}
 8011c56:	b088      	sub	sp, #32
 8011c58:	af00      	add	r7, sp, #0
 8011c5a:	6078      	str	r0, [r7, #4]
  uint32_t itsource = hspi->Instance->CR2;
 8011c5c:	687b      	ldr	r3, [r7, #4]
 8011c5e:	681b      	ldr	r3, [r3, #0]
 8011c60:	685b      	ldr	r3, [r3, #4]
 8011c62:	61fb      	str	r3, [r7, #28]
  uint32_t itflag   = hspi->Instance->SR;
 8011c64:	687b      	ldr	r3, [r7, #4]
 8011c66:	681b      	ldr	r3, [r3, #0]
 8011c68:	689b      	ldr	r3, [r3, #8]
 8011c6a:	61bb      	str	r3, [r7, #24]

  /* SPI in mode Receiver ----------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8011c6c:	69bb      	ldr	r3, [r7, #24]
 8011c6e:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8011c72:	2b00      	cmp	r3, #0
 8011c74:	d10e      	bne.n	8011c94 <HAL_SPI_IRQHandler+0x40>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 8011c76:	69bb      	ldr	r3, [r7, #24]
 8011c78:	f003 0301 	and.w	r3, r3, #1
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) == RESET) &&
 8011c7c:	2b00      	cmp	r3, #0
 8011c7e:	d009      	beq.n	8011c94 <HAL_SPI_IRQHandler+0x40>
      (SPI_CHECK_FLAG(itflag, SPI_FLAG_RXNE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_RXNE) != RESET))
 8011c80:	69fb      	ldr	r3, [r7, #28]
 8011c82:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8011c86:	2b00      	cmp	r3, #0
 8011c88:	d004      	beq.n	8011c94 <HAL_SPI_IRQHandler+0x40>
  {
    hspi->RxISR(hspi);
 8011c8a:	687b      	ldr	r3, [r7, #4]
 8011c8c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8011c8e:	6878      	ldr	r0, [r7, #4]
 8011c90:	4798      	blx	r3
    return;
 8011c92:	e0ce      	b.n	8011e32 <HAL_SPI_IRQHandler+0x1de>
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if ((SPI_CHECK_FLAG(itflag, SPI_FLAG_TXE) != RESET) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_TXE) != RESET))
 8011c94:	69bb      	ldr	r3, [r7, #24]
 8011c96:	f003 0302 	and.w	r3, r3, #2
 8011c9a:	2b00      	cmp	r3, #0
 8011c9c:	d009      	beq.n	8011cb2 <HAL_SPI_IRQHandler+0x5e>
 8011c9e:	69fb      	ldr	r3, [r7, #28]
 8011ca0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8011ca4:	2b00      	cmp	r3, #0
 8011ca6:	d004      	beq.n	8011cb2 <HAL_SPI_IRQHandler+0x5e>
  {
    hspi->TxISR(hspi);
 8011ca8:	687b      	ldr	r3, [r7, #4]
 8011caa:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8011cac:	6878      	ldr	r0, [r7, #4]
 8011cae:	4798      	blx	r3
    return;
 8011cb0:	e0bf      	b.n	8011e32 <HAL_SPI_IRQHandler+0x1de>
  }

  /* SPI in Error Treatment --------------------------------------------------*/
  if (((SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET) || (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 8011cb2:	69bb      	ldr	r3, [r7, #24]
 8011cb4:	f003 0320 	and.w	r3, r3, #32
 8011cb8:	2b00      	cmp	r3, #0
 8011cba:	d10a      	bne.n	8011cd2 <HAL_SPI_IRQHandler+0x7e>
 8011cbc:	69bb      	ldr	r3, [r7, #24]
 8011cbe:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8011cc2:	2b00      	cmp	r3, #0
 8011cc4:	d105      	bne.n	8011cd2 <HAL_SPI_IRQHandler+0x7e>
       || (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)) && (SPI_CHECK_IT_SOURCE(itsource, SPI_IT_ERR) != RESET))
 8011cc6:	69bb      	ldr	r3, [r7, #24]
 8011cc8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8011ccc:	2b00      	cmp	r3, #0
 8011cce:	f000 80b0 	beq.w	8011e32 <HAL_SPI_IRQHandler+0x1de>
 8011cd2:	69fb      	ldr	r3, [r7, #28]
 8011cd4:	f003 0320 	and.w	r3, r3, #32
 8011cd8:	2b00      	cmp	r3, #0
 8011cda:	f000 80aa 	beq.w	8011e32 <HAL_SPI_IRQHandler+0x1de>
  {
    /* SPI Overrun error interrupt occurred ----------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_OVR) != RESET)
 8011cde:	69bb      	ldr	r3, [r7, #24]
 8011ce0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8011ce4:	2b00      	cmp	r3, #0
 8011ce6:	d023      	beq.n	8011d30 <HAL_SPI_IRQHandler+0xdc>
    {
      if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8011ce8:	687b      	ldr	r3, [r7, #4]
 8011cea:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
 8011cee:	b2db      	uxtb	r3, r3
 8011cf0:	2b03      	cmp	r3, #3
 8011cf2:	d011      	beq.n	8011d18 <HAL_SPI_IRQHandler+0xc4>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8011cf4:	687b      	ldr	r3, [r7, #4]
 8011cf6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011cf8:	f043 0204 	orr.w	r2, r3, #4
 8011cfc:	687b      	ldr	r3, [r7, #4]
 8011cfe:	655a      	str	r2, [r3, #84]	@ 0x54
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8011d00:	2300      	movs	r3, #0
 8011d02:	617b      	str	r3, [r7, #20]
 8011d04:	687b      	ldr	r3, [r7, #4]
 8011d06:	681b      	ldr	r3, [r3, #0]
 8011d08:	68db      	ldr	r3, [r3, #12]
 8011d0a:	617b      	str	r3, [r7, #20]
 8011d0c:	687b      	ldr	r3, [r7, #4]
 8011d0e:	681b      	ldr	r3, [r3, #0]
 8011d10:	689b      	ldr	r3, [r3, #8]
 8011d12:	617b      	str	r3, [r7, #20]
 8011d14:	697b      	ldr	r3, [r7, #20]
 8011d16:	e00b      	b.n	8011d30 <HAL_SPI_IRQHandler+0xdc>
      }
      else
      {
        __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8011d18:	2300      	movs	r3, #0
 8011d1a:	613b      	str	r3, [r7, #16]
 8011d1c:	687b      	ldr	r3, [r7, #4]
 8011d1e:	681b      	ldr	r3, [r3, #0]
 8011d20:	68db      	ldr	r3, [r3, #12]
 8011d22:	613b      	str	r3, [r7, #16]
 8011d24:	687b      	ldr	r3, [r7, #4]
 8011d26:	681b      	ldr	r3, [r3, #0]
 8011d28:	689b      	ldr	r3, [r3, #8]
 8011d2a:	613b      	str	r3, [r7, #16]
 8011d2c:	693b      	ldr	r3, [r7, #16]
        return;
 8011d2e:	e080      	b.n	8011e32 <HAL_SPI_IRQHandler+0x1de>
      }
    }

    /* SPI Mode Fault error interrupt occurred -------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_MODF) != RESET)
 8011d30:	69bb      	ldr	r3, [r7, #24]
 8011d32:	f003 0320 	and.w	r3, r3, #32
 8011d36:	2b00      	cmp	r3, #0
 8011d38:	d014      	beq.n	8011d64 <HAL_SPI_IRQHandler+0x110>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8011d3a:	687b      	ldr	r3, [r7, #4]
 8011d3c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011d3e:	f043 0201 	orr.w	r2, r3, #1
 8011d42:	687b      	ldr	r3, [r7, #4]
 8011d44:	655a      	str	r2, [r3, #84]	@ 0x54
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8011d46:	2300      	movs	r3, #0
 8011d48:	60fb      	str	r3, [r7, #12]
 8011d4a:	687b      	ldr	r3, [r7, #4]
 8011d4c:	681b      	ldr	r3, [r3, #0]
 8011d4e:	689b      	ldr	r3, [r3, #8]
 8011d50:	60fb      	str	r3, [r7, #12]
 8011d52:	687b      	ldr	r3, [r7, #4]
 8011d54:	681b      	ldr	r3, [r3, #0]
 8011d56:	681a      	ldr	r2, [r3, #0]
 8011d58:	687b      	ldr	r3, [r7, #4]
 8011d5a:	681b      	ldr	r3, [r3, #0]
 8011d5c:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8011d60:	601a      	str	r2, [r3, #0]
 8011d62:	68fb      	ldr	r3, [r7, #12]
    }

    /* SPI Frame error interrupt occurred ------------------------------------*/
    if (SPI_CHECK_FLAG(itflag, SPI_FLAG_FRE) != RESET)
 8011d64:	69bb      	ldr	r3, [r7, #24]
 8011d66:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8011d6a:	2b00      	cmp	r3, #0
 8011d6c:	d00c      	beq.n	8011d88 <HAL_SPI_IRQHandler+0x134>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8011d6e:	687b      	ldr	r3, [r7, #4]
 8011d70:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011d72:	f043 0208 	orr.w	r2, r3, #8
 8011d76:	687b      	ldr	r3, [r7, #4]
 8011d78:	655a      	str	r2, [r3, #84]	@ 0x54
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 8011d7a:	2300      	movs	r3, #0
 8011d7c:	60bb      	str	r3, [r7, #8]
 8011d7e:	687b      	ldr	r3, [r7, #4]
 8011d80:	681b      	ldr	r3, [r3, #0]
 8011d82:	689b      	ldr	r3, [r3, #8]
 8011d84:	60bb      	str	r3, [r7, #8]
 8011d86:	68bb      	ldr	r3, [r7, #8]
    }

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8011d88:	687b      	ldr	r3, [r7, #4]
 8011d8a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011d8c:	2b00      	cmp	r3, #0
 8011d8e:	d04f      	beq.n	8011e30 <HAL_SPI_IRQHandler+0x1dc>
    {
      /* Disable all interrupts */
      __HAL_SPI_DISABLE_IT(hspi, SPI_IT_RXNE | SPI_IT_TXE | SPI_IT_ERR);
 8011d90:	687b      	ldr	r3, [r7, #4]
 8011d92:	681b      	ldr	r3, [r3, #0]
 8011d94:	685a      	ldr	r2, [r3, #4]
 8011d96:	687b      	ldr	r3, [r7, #4]
 8011d98:	681b      	ldr	r3, [r3, #0]
 8011d9a:	f022 02e0 	bic.w	r2, r2, #224	@ 0xe0
 8011d9e:	605a      	str	r2, [r3, #4]

      hspi->State = HAL_SPI_STATE_READY;
 8011da0:	687b      	ldr	r3, [r7, #4]
 8011da2:	2201      	movs	r2, #1
 8011da4:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51
      /* Disable the SPI DMA requests if enabled */
      if ((HAL_IS_BIT_SET(itsource, SPI_CR2_TXDMAEN)) || (HAL_IS_BIT_SET(itsource, SPI_CR2_RXDMAEN)))
 8011da8:	69fb      	ldr	r3, [r7, #28]
 8011daa:	f003 0302 	and.w	r3, r3, #2
 8011dae:	2b00      	cmp	r3, #0
 8011db0:	d104      	bne.n	8011dbc <HAL_SPI_IRQHandler+0x168>
 8011db2:	69fb      	ldr	r3, [r7, #28]
 8011db4:	f003 0301 	and.w	r3, r3, #1
 8011db8:	2b00      	cmp	r3, #0
 8011dba:	d034      	beq.n	8011e26 <HAL_SPI_IRQHandler+0x1d2>
      {
        CLEAR_BIT(hspi->Instance->CR2, (SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN));
 8011dbc:	687b      	ldr	r3, [r7, #4]
 8011dbe:	681b      	ldr	r3, [r3, #0]
 8011dc0:	685a      	ldr	r2, [r3, #4]
 8011dc2:	687b      	ldr	r3, [r7, #4]
 8011dc4:	681b      	ldr	r3, [r3, #0]
 8011dc6:	f022 0203 	bic.w	r2, r2, #3
 8011dca:	605a      	str	r2, [r3, #4]

        /* Abort the SPI DMA Rx channel */
        if (hspi->hdmarx != NULL)
 8011dcc:	687b      	ldr	r3, [r7, #4]
 8011dce:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8011dd0:	2b00      	cmp	r3, #0
 8011dd2:	d011      	beq.n	8011df8 <HAL_SPI_IRQHandler+0x1a4>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 8011dd4:	687b      	ldr	r3, [r7, #4]
 8011dd6:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8011dd8:	4a17      	ldr	r2, [pc, #92]	@ (8011e38 <HAL_SPI_IRQHandler+0x1e4>)
 8011dda:	651a      	str	r2, [r3, #80]	@ 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 8011ddc:	687b      	ldr	r3, [r7, #4]
 8011dde:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8011de0:	4618      	mov	r0, r3
 8011de2:	f7f7 fa97 	bl	8009314 <HAL_DMA_Abort_IT>
 8011de6:	4603      	mov	r3, r0
 8011de8:	2b00      	cmp	r3, #0
 8011dea:	d005      	beq.n	8011df8 <HAL_SPI_IRQHandler+0x1a4>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8011dec:	687b      	ldr	r3, [r7, #4]
 8011dee:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011df0:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8011df4:	687b      	ldr	r3, [r7, #4]
 8011df6:	655a      	str	r2, [r3, #84]	@ 0x54
          }
        }
        /* Abort the SPI DMA Tx channel */
        if (hspi->hdmatx != NULL)
 8011df8:	687b      	ldr	r3, [r7, #4]
 8011dfa:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8011dfc:	2b00      	cmp	r3, #0
 8011dfe:	d016      	beq.n	8011e2e <HAL_SPI_IRQHandler+0x1da>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 8011e00:	687b      	ldr	r3, [r7, #4]
 8011e02:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8011e04:	4a0c      	ldr	r2, [pc, #48]	@ (8011e38 <HAL_SPI_IRQHandler+0x1e4>)
 8011e06:	651a      	str	r2, [r3, #80]	@ 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 8011e08:	687b      	ldr	r3, [r7, #4]
 8011e0a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8011e0c:	4618      	mov	r0, r3
 8011e0e:	f7f7 fa81 	bl	8009314 <HAL_DMA_Abort_IT>
 8011e12:	4603      	mov	r3, r0
 8011e14:	2b00      	cmp	r3, #0
 8011e16:	d00a      	beq.n	8011e2e <HAL_SPI_IRQHandler+0x1da>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8011e18:	687b      	ldr	r3, [r7, #4]
 8011e1a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011e1c:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8011e20:	687b      	ldr	r3, [r7, #4]
 8011e22:	655a      	str	r2, [r3, #84]	@ 0x54
        if (hspi->hdmatx != NULL)
 8011e24:	e003      	b.n	8011e2e <HAL_SPI_IRQHandler+0x1da>
      {
        /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
        hspi->ErrorCallback(hspi);
#else
        HAL_SPI_ErrorCallback(hspi);
 8011e26:	6878      	ldr	r0, [r7, #4]
 8011e28:	f7f6 fc40 	bl	80086ac <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      }
    }
    return;
 8011e2c:	e000      	b.n	8011e30 <HAL_SPI_IRQHandler+0x1dc>
        if (hspi->hdmatx != NULL)
 8011e2e:	bf00      	nop
    return;
 8011e30:	bf00      	nop
  }
}
 8011e32:	3720      	adds	r7, #32
 8011e34:	46bd      	mov	sp, r7
 8011e36:	bd80      	pop	{r7, pc}
 8011e38:	08011e3d 	.word	0x08011e3d

08011e3c <SPI_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8011e3c:	b580      	push	{r7, lr}
 8011e3e:	b084      	sub	sp, #16
 8011e40:	af00      	add	r7, sp, #0
 8011e42:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8011e44:	687b      	ldr	r3, [r7, #4]
 8011e46:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8011e48:	60fb      	str	r3, [r7, #12]
  hspi->RxXferCount = 0U;
 8011e4a:	68fb      	ldr	r3, [r7, #12]
 8011e4c:	2200      	movs	r2, #0
 8011e4e:	87da      	strh	r2, [r3, #62]	@ 0x3e
  hspi->TxXferCount = 0U;
 8011e50:	68fb      	ldr	r3, [r7, #12]
 8011e52:	2200      	movs	r2, #0
 8011e54:	86da      	strh	r2, [r3, #54]	@ 0x36

  /* Call user error callback */
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1U)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
 8011e56:	68f8      	ldr	r0, [r7, #12]
 8011e58:	f7f6 fc28 	bl	80086ac <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 8011e5c:	bf00      	nop
 8011e5e:	3710      	adds	r7, #16
 8011e60:	46bd      	mov	sp, r7
 8011e62:	bd80      	pop	{r7, pc}

08011e64 <SPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
                                                       uint32_t Timeout, uint32_t Tickstart)
{
 8011e64:	b580      	push	{r7, lr}
 8011e66:	b088      	sub	sp, #32
 8011e68:	af00      	add	r7, sp, #0
 8011e6a:	60f8      	str	r0, [r7, #12]
 8011e6c:	60b9      	str	r1, [r7, #8]
 8011e6e:	603b      	str	r3, [r7, #0]
 8011e70:	4613      	mov	r3, r2
 8011e72:	71fb      	strb	r3, [r7, #7]
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 8011e74:	f7f6 ff06 	bl	8008c84 <HAL_GetTick>
 8011e78:	4602      	mov	r2, r0
 8011e7a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8011e7c:	1a9b      	subs	r3, r3, r2
 8011e7e:	683a      	ldr	r2, [r7, #0]
 8011e80:	4413      	add	r3, r2
 8011e82:	61fb      	str	r3, [r7, #28]
  tmp_tickstart = HAL_GetTick();
 8011e84:	f7f6 fefe 	bl	8008c84 <HAL_GetTick>
 8011e88:	61b8      	str	r0, [r7, #24]

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 8011e8a:	4b39      	ldr	r3, [pc, #228]	@ (8011f70 <SPI_WaitFlagStateUntilTimeout+0x10c>)
 8011e8c:	681b      	ldr	r3, [r3, #0]
 8011e8e:	015b      	lsls	r3, r3, #5
 8011e90:	0d1b      	lsrs	r3, r3, #20
 8011e92:	69fa      	ldr	r2, [r7, #28]
 8011e94:	fb02 f303 	mul.w	r3, r2, r3
 8011e98:	617b      	str	r3, [r7, #20]

  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8011e9a:	e054      	b.n	8011f46 <SPI_WaitFlagStateUntilTimeout+0xe2>
  {
    if (Timeout != HAL_MAX_DELAY)
 8011e9c:	683b      	ldr	r3, [r7, #0]
 8011e9e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8011ea2:	d050      	beq.n	8011f46 <SPI_WaitFlagStateUntilTimeout+0xe2>
    {
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8011ea4:	f7f6 feee 	bl	8008c84 <HAL_GetTick>
 8011ea8:	4602      	mov	r2, r0
 8011eaa:	69bb      	ldr	r3, [r7, #24]
 8011eac:	1ad3      	subs	r3, r2, r3
 8011eae:	69fa      	ldr	r2, [r7, #28]
 8011eb0:	429a      	cmp	r2, r3
 8011eb2:	d902      	bls.n	8011eba <SPI_WaitFlagStateUntilTimeout+0x56>
 8011eb4:	69fb      	ldr	r3, [r7, #28]
 8011eb6:	2b00      	cmp	r3, #0
 8011eb8:	d13d      	bne.n	8011f36 <SPI_WaitFlagStateUntilTimeout+0xd2>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
           on both master and slave sides in order to resynchronize the master
           and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8011eba:	68fb      	ldr	r3, [r7, #12]
 8011ebc:	681b      	ldr	r3, [r3, #0]
 8011ebe:	685a      	ldr	r2, [r3, #4]
 8011ec0:	68fb      	ldr	r3, [r7, #12]
 8011ec2:	681b      	ldr	r3, [r3, #0]
 8011ec4:	f022 02e0 	bic.w	r2, r2, #224	@ 0xe0
 8011ec8:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8011eca:	68fb      	ldr	r3, [r7, #12]
 8011ecc:	685b      	ldr	r3, [r3, #4]
 8011ece:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8011ed2:	d111      	bne.n	8011ef8 <SPI_WaitFlagStateUntilTimeout+0x94>
 8011ed4:	68fb      	ldr	r3, [r7, #12]
 8011ed6:	689b      	ldr	r3, [r3, #8]
 8011ed8:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8011edc:	d004      	beq.n	8011ee8 <SPI_WaitFlagStateUntilTimeout+0x84>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8011ede:	68fb      	ldr	r3, [r7, #12]
 8011ee0:	689b      	ldr	r3, [r3, #8]
 8011ee2:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8011ee6:	d107      	bne.n	8011ef8 <SPI_WaitFlagStateUntilTimeout+0x94>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 8011ee8:	68fb      	ldr	r3, [r7, #12]
 8011eea:	681b      	ldr	r3, [r3, #0]
 8011eec:	681a      	ldr	r2, [r3, #0]
 8011eee:	68fb      	ldr	r3, [r7, #12]
 8011ef0:	681b      	ldr	r3, [r3, #0]
 8011ef2:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8011ef6:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8011ef8:	68fb      	ldr	r3, [r7, #12]
 8011efa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8011efc:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8011f00:	d10f      	bne.n	8011f22 <SPI_WaitFlagStateUntilTimeout+0xbe>
        {
          SPI_RESET_CRC(hspi);
 8011f02:	68fb      	ldr	r3, [r7, #12]
 8011f04:	681b      	ldr	r3, [r3, #0]
 8011f06:	681a      	ldr	r2, [r3, #0]
 8011f08:	68fb      	ldr	r3, [r7, #12]
 8011f0a:	681b      	ldr	r3, [r3, #0]
 8011f0c:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8011f10:	601a      	str	r2, [r3, #0]
 8011f12:	68fb      	ldr	r3, [r7, #12]
 8011f14:	681b      	ldr	r3, [r3, #0]
 8011f16:	681a      	ldr	r2, [r3, #0]
 8011f18:	68fb      	ldr	r3, [r7, #12]
 8011f1a:	681b      	ldr	r3, [r3, #0]
 8011f1c:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8011f20:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 8011f22:	68fb      	ldr	r3, [r7, #12]
 8011f24:	2201      	movs	r2, #1
 8011f26:	f883 2051 	strb.w	r2, [r3, #81]	@ 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8011f2a:	68fb      	ldr	r3, [r7, #12]
 8011f2c:	2200      	movs	r2, #0
 8011f2e:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

        return HAL_TIMEOUT;
 8011f32:	2303      	movs	r3, #3
 8011f34:	e017      	b.n	8011f66 <SPI_WaitFlagStateUntilTimeout+0x102>
      }
      /* If Systick is disabled or not incremented, deactivate timeout to go in disable loop procedure */
      if (count == 0U)
 8011f36:	697b      	ldr	r3, [r7, #20]
 8011f38:	2b00      	cmp	r3, #0
 8011f3a:	d101      	bne.n	8011f40 <SPI_WaitFlagStateUntilTimeout+0xdc>
      {
        tmp_timeout = 0U;
 8011f3c:	2300      	movs	r3, #0
 8011f3e:	61fb      	str	r3, [r7, #28]
      }
      count--;
 8011f40:	697b      	ldr	r3, [r7, #20]
 8011f42:	3b01      	subs	r3, #1
 8011f44:	617b      	str	r3, [r7, #20]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8011f46:	68fb      	ldr	r3, [r7, #12]
 8011f48:	681b      	ldr	r3, [r3, #0]
 8011f4a:	689a      	ldr	r2, [r3, #8]
 8011f4c:	68bb      	ldr	r3, [r7, #8]
 8011f4e:	4013      	ands	r3, r2
 8011f50:	68ba      	ldr	r2, [r7, #8]
 8011f52:	429a      	cmp	r2, r3
 8011f54:	bf0c      	ite	eq
 8011f56:	2301      	moveq	r3, #1
 8011f58:	2300      	movne	r3, #0
 8011f5a:	b2db      	uxtb	r3, r3
 8011f5c:	461a      	mov	r2, r3
 8011f5e:	79fb      	ldrb	r3, [r7, #7]
 8011f60:	429a      	cmp	r2, r3
 8011f62:	d19b      	bne.n	8011e9c <SPI_WaitFlagStateUntilTimeout+0x38>
    }
  }

  return HAL_OK;
 8011f64:	2300      	movs	r3, #0
}
 8011f66:	4618      	mov	r0, r3
 8011f68:	3720      	adds	r7, #32
 8011f6a:	46bd      	mov	sp, r7
 8011f6c:	bd80      	pop	{r7, pc}
 8011f6e:	bf00      	nop
 8011f70:	20000040 	.word	0x20000040

08011f74 <SPI_EndRxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTransaction(SPI_HandleTypeDef *hspi,  uint32_t Timeout, uint32_t Tickstart)
{
 8011f74:	b580      	push	{r7, lr}
 8011f76:	b086      	sub	sp, #24
 8011f78:	af02      	add	r7, sp, #8
 8011f7a:	60f8      	str	r0, [r7, #12]
 8011f7c:	60b9      	str	r1, [r7, #8]
 8011f7e:	607a      	str	r2, [r7, #4]
  if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8011f80:	68fb      	ldr	r3, [r7, #12]
 8011f82:	685b      	ldr	r3, [r3, #4]
 8011f84:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8011f88:	d111      	bne.n	8011fae <SPI_EndRxTransaction+0x3a>
 8011f8a:	68fb      	ldr	r3, [r7, #12]
 8011f8c:	689b      	ldr	r3, [r3, #8]
 8011f8e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8011f92:	d004      	beq.n	8011f9e <SPI_EndRxTransaction+0x2a>
                                               || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8011f94:	68fb      	ldr	r3, [r7, #12]
 8011f96:	689b      	ldr	r3, [r3, #8]
 8011f98:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8011f9c:	d107      	bne.n	8011fae <SPI_EndRxTransaction+0x3a>
  {
    /* Disable SPI peripheral */
    __HAL_SPI_DISABLE(hspi);
 8011f9e:	68fb      	ldr	r3, [r7, #12]
 8011fa0:	681b      	ldr	r3, [r3, #0]
 8011fa2:	681a      	ldr	r2, [r3, #0]
 8011fa4:	68fb      	ldr	r3, [r7, #12]
 8011fa6:	681b      	ldr	r3, [r3, #0]
 8011fa8:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8011fac:	601a      	str	r2, [r3, #0]
  }

  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 8011fae:	68fb      	ldr	r3, [r7, #12]
 8011fb0:	685b      	ldr	r3, [r3, #4]
 8011fb2:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8011fb6:	d12a      	bne.n	801200e <SPI_EndRxTransaction+0x9a>
  {
    if (hspi->Init.Direction != SPI_DIRECTION_2LINES_RXONLY)
 8011fb8:	68fb      	ldr	r3, [r7, #12]
 8011fba:	689b      	ldr	r3, [r3, #8]
 8011fbc:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8011fc0:	d012      	beq.n	8011fe8 <SPI_EndRxTransaction+0x74>
    {
      /* Control the BSY flag */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8011fc2:	687b      	ldr	r3, [r7, #4]
 8011fc4:	9300      	str	r3, [sp, #0]
 8011fc6:	68bb      	ldr	r3, [r7, #8]
 8011fc8:	2200      	movs	r2, #0
 8011fca:	2180      	movs	r1, #128	@ 0x80
 8011fcc:	68f8      	ldr	r0, [r7, #12]
 8011fce:	f7ff ff49 	bl	8011e64 <SPI_WaitFlagStateUntilTimeout>
 8011fd2:	4603      	mov	r3, r0
 8011fd4:	2b00      	cmp	r3, #0
 8011fd6:	d02d      	beq.n	8012034 <SPI_EndRxTransaction+0xc0>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8011fd8:	68fb      	ldr	r3, [r7, #12]
 8011fda:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8011fdc:	f043 0220 	orr.w	r2, r3, #32
 8011fe0:	68fb      	ldr	r3, [r7, #12]
 8011fe2:	655a      	str	r2, [r3, #84]	@ 0x54
        return HAL_TIMEOUT;
 8011fe4:	2303      	movs	r3, #3
 8011fe6:	e026      	b.n	8012036 <SPI_EndRxTransaction+0xc2>
      }
    }
    else
    {
      /* Wait the RXNE reset */
      if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 8011fe8:	687b      	ldr	r3, [r7, #4]
 8011fea:	9300      	str	r3, [sp, #0]
 8011fec:	68bb      	ldr	r3, [r7, #8]
 8011fee:	2200      	movs	r2, #0
 8011ff0:	2101      	movs	r1, #1
 8011ff2:	68f8      	ldr	r0, [r7, #12]
 8011ff4:	f7ff ff36 	bl	8011e64 <SPI_WaitFlagStateUntilTimeout>
 8011ff8:	4603      	mov	r3, r0
 8011ffa:	2b00      	cmp	r3, #0
 8011ffc:	d01a      	beq.n	8012034 <SPI_EndRxTransaction+0xc0>
      {
        SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8011ffe:	68fb      	ldr	r3, [r7, #12]
 8012000:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8012002:	f043 0220 	orr.w	r2, r3, #32
 8012006:	68fb      	ldr	r3, [r7, #12]
 8012008:	655a      	str	r2, [r3, #84]	@ 0x54
        return HAL_TIMEOUT;
 801200a:	2303      	movs	r3, #3
 801200c:	e013      	b.n	8012036 <SPI_EndRxTransaction+0xc2>
    }
  }
  else
  {
    /* Wait the RXNE reset */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_RXNE, RESET, Timeout, Tickstart) != HAL_OK)
 801200e:	687b      	ldr	r3, [r7, #4]
 8012010:	9300      	str	r3, [sp, #0]
 8012012:	68bb      	ldr	r3, [r7, #8]
 8012014:	2200      	movs	r2, #0
 8012016:	2101      	movs	r1, #1
 8012018:	68f8      	ldr	r0, [r7, #12]
 801201a:	f7ff ff23 	bl	8011e64 <SPI_WaitFlagStateUntilTimeout>
 801201e:	4603      	mov	r3, r0
 8012020:	2b00      	cmp	r3, #0
 8012022:	d007      	beq.n	8012034 <SPI_EndRxTransaction+0xc0>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8012024:	68fb      	ldr	r3, [r7, #12]
 8012026:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8012028:	f043 0220 	orr.w	r2, r3, #32
 801202c:	68fb      	ldr	r3, [r7, #12]
 801202e:	655a      	str	r2, [r3, #84]	@ 0x54
      return HAL_TIMEOUT;
 8012030:	2303      	movs	r3, #3
 8012032:	e000      	b.n	8012036 <SPI_EndRxTransaction+0xc2>
    }
  }
  return HAL_OK;
 8012034:	2300      	movs	r3, #0
}
 8012036:	4618      	mov	r0, r3
 8012038:	3710      	adds	r7, #16
 801203a:	46bd      	mov	sp, r7
 801203c:	bd80      	pop	{r7, pc}
	...

08012040 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8012040:	b580      	push	{r7, lr}
 8012042:	b088      	sub	sp, #32
 8012044:	af02      	add	r7, sp, #8
 8012046:	60f8      	str	r0, [r7, #12]
 8012048:	60b9      	str	r1, [r7, #8]
 801204a:	607a      	str	r2, [r7, #4]
  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, Tickstart) != HAL_OK)
 801204c:	687b      	ldr	r3, [r7, #4]
 801204e:	9300      	str	r3, [sp, #0]
 8012050:	68bb      	ldr	r3, [r7, #8]
 8012052:	2201      	movs	r2, #1
 8012054:	2102      	movs	r1, #2
 8012056:	68f8      	ldr	r0, [r7, #12]
 8012058:	f7ff ff04 	bl	8011e64 <SPI_WaitFlagStateUntilTimeout>
 801205c:	4603      	mov	r3, r0
 801205e:	2b00      	cmp	r3, #0
 8012060:	d007      	beq.n	8012072 <SPI_EndRxTxTransaction+0x32>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8012062:	68fb      	ldr	r3, [r7, #12]
 8012064:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8012066:	f043 0220 	orr.w	r2, r3, #32
 801206a:	68fb      	ldr	r3, [r7, #12]
 801206c:	655a      	str	r2, [r3, #84]	@ 0x54
    return HAL_TIMEOUT;
 801206e:	2303      	movs	r3, #3
 8012070:	e032      	b.n	80120d8 <SPI_EndRxTxTransaction+0x98>
  }

  /* Timeout in s */
  __IO uint32_t count = SPI_BSY_FLAG_WORKAROUND_TIMEOUT * (SystemCoreClock / 24U / 1000000U);
 8012072:	4b1b      	ldr	r3, [pc, #108]	@ (80120e0 <SPI_EndRxTxTransaction+0xa0>)
 8012074:	681b      	ldr	r3, [r3, #0]
 8012076:	4a1b      	ldr	r2, [pc, #108]	@ (80120e4 <SPI_EndRxTxTransaction+0xa4>)
 8012078:	fba2 2303 	umull	r2, r3, r2, r3
 801207c:	0d5b      	lsrs	r3, r3, #21
 801207e:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8012082:	fb02 f303 	mul.w	r3, r2, r3
 8012086:	617b      	str	r3, [r7, #20]
  /* Erratasheet: BSY bit may stay high at the end of a data transfer in Slave mode */
  if (hspi->Init.Mode == SPI_MODE_MASTER)
 8012088:	68fb      	ldr	r3, [r7, #12]
 801208a:	685b      	ldr	r3, [r3, #4]
 801208c:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8012090:	d112      	bne.n	80120b8 <SPI_EndRxTxTransaction+0x78>
  {
    /* Control the BSY flag */
    if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8012092:	687b      	ldr	r3, [r7, #4]
 8012094:	9300      	str	r3, [sp, #0]
 8012096:	68bb      	ldr	r3, [r7, #8]
 8012098:	2200      	movs	r2, #0
 801209a:	2180      	movs	r1, #128	@ 0x80
 801209c:	68f8      	ldr	r0, [r7, #12]
 801209e:	f7ff fee1 	bl	8011e64 <SPI_WaitFlagStateUntilTimeout>
 80120a2:	4603      	mov	r3, r0
 80120a4:	2b00      	cmp	r3, #0
 80120a6:	d016      	beq.n	80120d6 <SPI_EndRxTxTransaction+0x96>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 80120a8:	68fb      	ldr	r3, [r7, #12]
 80120aa:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80120ac:	f043 0220 	orr.w	r2, r3, #32
 80120b0:	68fb      	ldr	r3, [r7, #12]
 80120b2:	655a      	str	r2, [r3, #84]	@ 0x54
      return HAL_TIMEOUT;
 80120b4:	2303      	movs	r3, #3
 80120b6:	e00f      	b.n	80120d8 <SPI_EndRxTxTransaction+0x98>
    * User have to calculate the timeout value to fit with the time of 1 byte transfer.
    * This time is directly link with the SPI clock from Master device.
    */
    do
    {
      if (count == 0U)
 80120b8:	697b      	ldr	r3, [r7, #20]
 80120ba:	2b00      	cmp	r3, #0
 80120bc:	d00a      	beq.n	80120d4 <SPI_EndRxTxTransaction+0x94>
      {
        break;
      }
      count--;
 80120be:	697b      	ldr	r3, [r7, #20]
 80120c0:	3b01      	subs	r3, #1
 80120c2:	617b      	str	r3, [r7, #20]
    } while (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_BSY) != RESET);
 80120c4:	68fb      	ldr	r3, [r7, #12]
 80120c6:	681b      	ldr	r3, [r3, #0]
 80120c8:	689b      	ldr	r3, [r3, #8]
 80120ca:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 80120ce:	2b80      	cmp	r3, #128	@ 0x80
 80120d0:	d0f2      	beq.n	80120b8 <SPI_EndRxTxTransaction+0x78>
 80120d2:	e000      	b.n	80120d6 <SPI_EndRxTxTransaction+0x96>
        break;
 80120d4:	bf00      	nop
  }

  return HAL_OK;
 80120d6:	2300      	movs	r3, #0
}
 80120d8:	4618      	mov	r0, r3
 80120da:	3718      	adds	r7, #24
 80120dc:	46bd      	mov	sp, r7
 80120de:	bd80      	pop	{r7, pc}
 80120e0:	20000040 	.word	0x20000040
 80120e4:	165e9f81 	.word	0x165e9f81

080120e8 <HAL_UART_Transmit>:
  * @param  Size  Amount of data elements (u8 or u16) to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80120e8:	b580      	push	{r7, lr}
 80120ea:	b08a      	sub	sp, #40	@ 0x28
 80120ec:	af02      	add	r7, sp, #8
 80120ee:	60f8      	str	r0, [r7, #12]
 80120f0:	60b9      	str	r1, [r7, #8]
 80120f2:	603b      	str	r3, [r7, #0]
 80120f4:	4613      	mov	r3, r2
 80120f6:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart = 0U;
 80120f8:	2300      	movs	r3, #0
 80120fa:	617b      	str	r3, [r7, #20]

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 80120fc:	68fb      	ldr	r3, [r7, #12]
 80120fe:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8012102:	b2db      	uxtb	r3, r3
 8012104:	2b20      	cmp	r3, #32
 8012106:	d175      	bne.n	80121f4 <HAL_UART_Transmit+0x10c>
  {
    if ((pData == NULL) || (Size == 0U))
 8012108:	68bb      	ldr	r3, [r7, #8]
 801210a:	2b00      	cmp	r3, #0
 801210c:	d002      	beq.n	8012114 <HAL_UART_Transmit+0x2c>
 801210e:	88fb      	ldrh	r3, [r7, #6]
 8012110:	2b00      	cmp	r3, #0
 8012112:	d101      	bne.n	8012118 <HAL_UART_Transmit+0x30>
    {
      return  HAL_ERROR;
 8012114:	2301      	movs	r3, #1
 8012116:	e06e      	b.n	80121f6 <HAL_UART_Transmit+0x10e>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8012118:	68fb      	ldr	r3, [r7, #12]
 801211a:	2200      	movs	r2, #0
 801211c:	645a      	str	r2, [r3, #68]	@ 0x44
    huart->gState = HAL_UART_STATE_BUSY_TX;
 801211e:	68fb      	ldr	r3, [r7, #12]
 8012120:	2221      	movs	r2, #33	@ 0x21
 8012122:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8012126:	f7f6 fdad 	bl	8008c84 <HAL_GetTick>
 801212a:	6178      	str	r0, [r7, #20]

    huart->TxXferSize = Size;
 801212c:	68fb      	ldr	r3, [r7, #12]
 801212e:	88fa      	ldrh	r2, [r7, #6]
 8012130:	849a      	strh	r2, [r3, #36]	@ 0x24
    huart->TxXferCount = Size;
 8012132:	68fb      	ldr	r3, [r7, #12]
 8012134:	88fa      	ldrh	r2, [r7, #6]
 8012136:	84da      	strh	r2, [r3, #38]	@ 0x26

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8012138:	68fb      	ldr	r3, [r7, #12]
 801213a:	689b      	ldr	r3, [r3, #8]
 801213c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8012140:	d108      	bne.n	8012154 <HAL_UART_Transmit+0x6c>
 8012142:	68fb      	ldr	r3, [r7, #12]
 8012144:	691b      	ldr	r3, [r3, #16]
 8012146:	2b00      	cmp	r3, #0
 8012148:	d104      	bne.n	8012154 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
 801214a:	2300      	movs	r3, #0
 801214c:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 801214e:	68bb      	ldr	r3, [r7, #8]
 8012150:	61bb      	str	r3, [r7, #24]
 8012152:	e003      	b.n	801215c <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
 8012154:	68bb      	ldr	r3, [r7, #8]
 8012156:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 8012158:	2300      	movs	r3, #0
 801215a:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 801215c:	e02e      	b.n	80121bc <HAL_UART_Transmit+0xd4>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 801215e:	683b      	ldr	r3, [r7, #0]
 8012160:	9300      	str	r3, [sp, #0]
 8012162:	697b      	ldr	r3, [r7, #20]
 8012164:	2200      	movs	r2, #0
 8012166:	2180      	movs	r1, #128	@ 0x80
 8012168:	68f8      	ldr	r0, [r7, #12]
 801216a:	f000 fc31 	bl	80129d0 <UART_WaitOnFlagUntilTimeout>
 801216e:	4603      	mov	r3, r0
 8012170:	2b00      	cmp	r3, #0
 8012172:	d005      	beq.n	8012180 <HAL_UART_Transmit+0x98>
      {
        huart->gState = HAL_UART_STATE_READY;
 8012174:	68fb      	ldr	r3, [r7, #12]
 8012176:	2220      	movs	r2, #32
 8012178:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

        return HAL_TIMEOUT;
 801217c:	2303      	movs	r3, #3
 801217e:	e03a      	b.n	80121f6 <HAL_UART_Transmit+0x10e>
      }
      if (pdata8bits == NULL)
 8012180:	69fb      	ldr	r3, [r7, #28]
 8012182:	2b00      	cmp	r3, #0
 8012184:	d10b      	bne.n	801219e <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 8012186:	69bb      	ldr	r3, [r7, #24]
 8012188:	881b      	ldrh	r3, [r3, #0]
 801218a:	461a      	mov	r2, r3
 801218c:	68fb      	ldr	r3, [r7, #12]
 801218e:	681b      	ldr	r3, [r3, #0]
 8012190:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8012194:	605a      	str	r2, [r3, #4]
        pdata16bits++;
 8012196:	69bb      	ldr	r3, [r7, #24]
 8012198:	3302      	adds	r3, #2
 801219a:	61bb      	str	r3, [r7, #24]
 801219c:	e007      	b.n	80121ae <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 801219e:	69fb      	ldr	r3, [r7, #28]
 80121a0:	781a      	ldrb	r2, [r3, #0]
 80121a2:	68fb      	ldr	r3, [r7, #12]
 80121a4:	681b      	ldr	r3, [r3, #0]
 80121a6:	605a      	str	r2, [r3, #4]
        pdata8bits++;
 80121a8:	69fb      	ldr	r3, [r7, #28]
 80121aa:	3301      	adds	r3, #1
 80121ac:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 80121ae:	68fb      	ldr	r3, [r7, #12]
 80121b0:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
 80121b2:	b29b      	uxth	r3, r3
 80121b4:	3b01      	subs	r3, #1
 80121b6:	b29a      	uxth	r2, r3
 80121b8:	68fb      	ldr	r3, [r7, #12]
 80121ba:	84da      	strh	r2, [r3, #38]	@ 0x26
    while (huart->TxXferCount > 0U)
 80121bc:	68fb      	ldr	r3, [r7, #12]
 80121be:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
 80121c0:	b29b      	uxth	r3, r3
 80121c2:	2b00      	cmp	r3, #0
 80121c4:	d1cb      	bne.n	801215e <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80121c6:	683b      	ldr	r3, [r7, #0]
 80121c8:	9300      	str	r3, [sp, #0]
 80121ca:	697b      	ldr	r3, [r7, #20]
 80121cc:	2200      	movs	r2, #0
 80121ce:	2140      	movs	r1, #64	@ 0x40
 80121d0:	68f8      	ldr	r0, [r7, #12]
 80121d2:	f000 fbfd 	bl	80129d0 <UART_WaitOnFlagUntilTimeout>
 80121d6:	4603      	mov	r3, r0
 80121d8:	2b00      	cmp	r3, #0
 80121da:	d005      	beq.n	80121e8 <HAL_UART_Transmit+0x100>
    {
      huart->gState = HAL_UART_STATE_READY;
 80121dc:	68fb      	ldr	r3, [r7, #12]
 80121de:	2220      	movs	r2, #32
 80121e0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

      return HAL_TIMEOUT;
 80121e4:	2303      	movs	r3, #3
 80121e6:	e006      	b.n	80121f6 <HAL_UART_Transmit+0x10e>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 80121e8:	68fb      	ldr	r3, [r7, #12]
 80121ea:	2220      	movs	r2, #32
 80121ec:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    return HAL_OK;
 80121f0:	2300      	movs	r3, #0
 80121f2:	e000      	b.n	80121f6 <HAL_UART_Transmit+0x10e>
  }
  else
  {
    return HAL_BUSY;
 80121f4:	2302      	movs	r3, #2
  }
}
 80121f6:	4618      	mov	r0, r3
 80121f8:	3720      	adds	r7, #32
 80121fa:	46bd      	mov	sp, r7
 80121fc:	bd80      	pop	{r7, pc}

080121fe <HAL_UART_Receive_DMA>:
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @note   When the UART parity is enabled (PCE = 1) the received data contains the parity bit.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 80121fe:	b580      	push	{r7, lr}
 8012200:	b084      	sub	sp, #16
 8012202:	af00      	add	r7, sp, #0
 8012204:	60f8      	str	r0, [r7, #12]
 8012206:	60b9      	str	r1, [r7, #8]
 8012208:	4613      	mov	r3, r2
 801220a:	80fb      	strh	r3, [r7, #6]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 801220c:	68fb      	ldr	r3, [r7, #12]
 801220e:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8012212:	b2db      	uxtb	r3, r3
 8012214:	2b20      	cmp	r3, #32
 8012216:	d112      	bne.n	801223e <HAL_UART_Receive_DMA+0x40>
  {
    if ((pData == NULL) || (Size == 0U))
 8012218:	68bb      	ldr	r3, [r7, #8]
 801221a:	2b00      	cmp	r3, #0
 801221c:	d002      	beq.n	8012224 <HAL_UART_Receive_DMA+0x26>
 801221e:	88fb      	ldrh	r3, [r7, #6]
 8012220:	2b00      	cmp	r3, #0
 8012222:	d101      	bne.n	8012228 <HAL_UART_Receive_DMA+0x2a>
    {
      return HAL_ERROR;
 8012224:	2301      	movs	r3, #1
 8012226:	e00b      	b.n	8012240 <HAL_UART_Receive_DMA+0x42>
    }

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8012228:	68fb      	ldr	r3, [r7, #12]
 801222a:	2200      	movs	r2, #0
 801222c:	631a      	str	r2, [r3, #48]	@ 0x30

    return (UART_Start_Receive_DMA(huart, pData, Size));
 801222e:	88fb      	ldrh	r3, [r7, #6]
 8012230:	461a      	mov	r2, r3
 8012232:	68b9      	ldr	r1, [r7, #8]
 8012234:	68f8      	ldr	r0, [r7, #12]
 8012236:	f000 fc25 	bl	8012a84 <UART_Start_Receive_DMA>
 801223a:	4603      	mov	r3, r0
 801223c:	e000      	b.n	8012240 <HAL_UART_Receive_DMA+0x42>
  }
  else
  {
    return HAL_BUSY;
 801223e:	2302      	movs	r3, #2
  }
}
 8012240:	4618      	mov	r0, r3
 8012242:	3710      	adds	r7, #16
 8012244:	46bd      	mov	sp, r7
 8012246:	bd80      	pop	{r7, pc}

08012248 <HAL_UART_IRQHandler>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8012248:	b580      	push	{r7, lr}
 801224a:	b0ba      	sub	sp, #232	@ 0xe8
 801224c:	af00      	add	r7, sp, #0
 801224e:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8012250:	687b      	ldr	r3, [r7, #4]
 8012252:	681b      	ldr	r3, [r3, #0]
 8012254:	681b      	ldr	r3, [r3, #0]
 8012256:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 801225a:	687b      	ldr	r3, [r7, #4]
 801225c:	681b      	ldr	r3, [r3, #0]
 801225e:	68db      	ldr	r3, [r3, #12]
 8012260:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8012264:	687b      	ldr	r3, [r7, #4]
 8012266:	681b      	ldr	r3, [r3, #0]
 8012268:	695b      	ldr	r3, [r3, #20]
 801226a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
  uint32_t errorflags = 0x00U;
 801226e:	2300      	movs	r3, #0
 8012270:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
  uint32_t dmarequest = 0x00U;
 8012274:	2300      	movs	r3, #0
 8012276:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
 801227a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801227e:	f003 030f 	and.w	r3, r3, #15
 8012282:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
  if (errorflags == RESET)
 8012286:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 801228a:	2b00      	cmp	r3, #0
 801228c:	d10f      	bne.n	80122ae <HAL_UART_IRQHandler+0x66>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 801228e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8012292:	f003 0320 	and.w	r3, r3, #32
 8012296:	2b00      	cmp	r3, #0
 8012298:	d009      	beq.n	80122ae <HAL_UART_IRQHandler+0x66>
 801229a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801229e:	f003 0320 	and.w	r3, r3, #32
 80122a2:	2b00      	cmp	r3, #0
 80122a4:	d003      	beq.n	80122ae <HAL_UART_IRQHandler+0x66>
    {
      UART_Receive_IT(huart);
 80122a6:	6878      	ldr	r0, [r7, #4]
 80122a8:	f000 fd8d 	bl	8012dc6 <UART_Receive_IT>
      return;
 80122ac:	e25b      	b.n	8012766 <HAL_UART_IRQHandler+0x51e>
    }
  }

  /* If some errors occur */
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET)
 80122ae:	f8d7 30d8 	ldr.w	r3, [r7, #216]	@ 0xd8
 80122b2:	2b00      	cmp	r3, #0
 80122b4:	f000 80de 	beq.w	8012474 <HAL_UART_IRQHandler+0x22c>
 80122b8:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 80122bc:	f003 0301 	and.w	r3, r3, #1
 80122c0:	2b00      	cmp	r3, #0
 80122c2:	d106      	bne.n	80122d2 <HAL_UART_IRQHandler+0x8a>
                                || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 80122c4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80122c8:	f403 7390 	and.w	r3, r3, #288	@ 0x120
 80122cc:	2b00      	cmp	r3, #0
 80122ce:	f000 80d1 	beq.w	8012474 <HAL_UART_IRQHandler+0x22c>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 80122d2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80122d6:	f003 0301 	and.w	r3, r3, #1
 80122da:	2b00      	cmp	r3, #0
 80122dc:	d00b      	beq.n	80122f6 <HAL_UART_IRQHandler+0xae>
 80122de:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 80122e2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80122e6:	2b00      	cmp	r3, #0
 80122e8:	d005      	beq.n	80122f6 <HAL_UART_IRQHandler+0xae>
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80122ea:	687b      	ldr	r3, [r7, #4]
 80122ec:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80122ee:	f043 0201 	orr.w	r2, r3, #1
 80122f2:	687b      	ldr	r3, [r7, #4]
 80122f4:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* UART noise error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80122f6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 80122fa:	f003 0304 	and.w	r3, r3, #4
 80122fe:	2b00      	cmp	r3, #0
 8012300:	d00b      	beq.n	801231a <HAL_UART_IRQHandler+0xd2>
 8012302:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 8012306:	f003 0301 	and.w	r3, r3, #1
 801230a:	2b00      	cmp	r3, #0
 801230c:	d005      	beq.n	801231a <HAL_UART_IRQHandler+0xd2>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 801230e:	687b      	ldr	r3, [r7, #4]
 8012310:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8012312:	f043 0202 	orr.w	r2, r3, #2
 8012316:	687b      	ldr	r3, [r7, #4]
 8012318:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* UART frame error interrupt occurred -----------------------------------*/
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 801231a:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801231e:	f003 0302 	and.w	r3, r3, #2
 8012322:	2b00      	cmp	r3, #0
 8012324:	d00b      	beq.n	801233e <HAL_UART_IRQHandler+0xf6>
 8012326:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801232a:	f003 0301 	and.w	r3, r3, #1
 801232e:	2b00      	cmp	r3, #0
 8012330:	d005      	beq.n	801233e <HAL_UART_IRQHandler+0xf6>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8012332:	687b      	ldr	r3, [r7, #4]
 8012334:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8012336:	f043 0204 	orr.w	r2, r3, #4
 801233a:	687b      	ldr	r3, [r7, #4]
 801233c:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* UART Over-Run interrupt occurred --------------------------------------*/
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET)
 801233e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8012342:	f003 0308 	and.w	r3, r3, #8
 8012346:	2b00      	cmp	r3, #0
 8012348:	d011      	beq.n	801236e <HAL_UART_IRQHandler+0x126>
 801234a:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801234e:	f003 0320 	and.w	r3, r3, #32
 8012352:	2b00      	cmp	r3, #0
 8012354:	d105      	bne.n	8012362 <HAL_UART_IRQHandler+0x11a>
                                                 || ((cr3its & USART_CR3_EIE) != RESET)))
 8012356:	f8d7 30dc 	ldr.w	r3, [r7, #220]	@ 0xdc
 801235a:	f003 0301 	and.w	r3, r3, #1
 801235e:	2b00      	cmp	r3, #0
 8012360:	d005      	beq.n	801236e <HAL_UART_IRQHandler+0x126>
    {
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8012362:	687b      	ldr	r3, [r7, #4]
 8012364:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8012366:	f043 0208 	orr.w	r2, r3, #8
 801236a:	687b      	ldr	r3, [r7, #4]
 801236c:	645a      	str	r2, [r3, #68]	@ 0x44
    }

    /* Call UART Error Call back function if need be --------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 801236e:	687b      	ldr	r3, [r7, #4]
 8012370:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8012372:	2b00      	cmp	r3, #0
 8012374:	f000 81f2 	beq.w	801275c <HAL_UART_IRQHandler+0x514>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8012378:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 801237c:	f003 0320 	and.w	r3, r3, #32
 8012380:	2b00      	cmp	r3, #0
 8012382:	d008      	beq.n	8012396 <HAL_UART_IRQHandler+0x14e>
 8012384:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8012388:	f003 0320 	and.w	r3, r3, #32
 801238c:	2b00      	cmp	r3, #0
 801238e:	d002      	beq.n	8012396 <HAL_UART_IRQHandler+0x14e>
      {
        UART_Receive_IT(huart);
 8012390:	6878      	ldr	r0, [r7, #4]
 8012392:	f000 fd18 	bl	8012dc6 <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8012396:	687b      	ldr	r3, [r7, #4]
 8012398:	681b      	ldr	r3, [r3, #0]
 801239a:	695b      	ldr	r3, [r3, #20]
 801239c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80123a0:	2b40      	cmp	r3, #64	@ 0x40
 80123a2:	bf0c      	ite	eq
 80123a4:	2301      	moveq	r3, #1
 80123a6:	2300      	movne	r3, #0
 80123a8:	b2db      	uxtb	r3, r3
 80123aa:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 80123ae:	687b      	ldr	r3, [r7, #4]
 80123b0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80123b2:	f003 0308 	and.w	r3, r3, #8
 80123b6:	2b00      	cmp	r3, #0
 80123b8:	d103      	bne.n	80123c2 <HAL_UART_IRQHandler+0x17a>
 80123ba:	f8d7 30d4 	ldr.w	r3, [r7, #212]	@ 0xd4
 80123be:	2b00      	cmp	r3, #0
 80123c0:	d04f      	beq.n	8012462 <HAL_UART_IRQHandler+0x21a>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 80123c2:	6878      	ldr	r0, [r7, #4]
 80123c4:	f000 fc20 	bl	8012c08 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80123c8:	687b      	ldr	r3, [r7, #4]
 80123ca:	681b      	ldr	r3, [r3, #0]
 80123cc:	695b      	ldr	r3, [r3, #20]
 80123ce:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80123d2:	2b40      	cmp	r3, #64	@ 0x40
 80123d4:	d141      	bne.n	801245a <HAL_UART_IRQHandler+0x212>
        {
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80123d6:	687b      	ldr	r3, [r7, #4]
 80123d8:	681b      	ldr	r3, [r3, #0]
 80123da:	3314      	adds	r3, #20
 80123dc:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80123e0:	f8d7 309c 	ldr.w	r3, [r7, #156]	@ 0x9c
 80123e4:	e853 3f00 	ldrex	r3, [r3]
 80123e8:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
   return(result);
 80123ec:	f8d7 3098 	ldr.w	r3, [r7, #152]	@ 0x98
 80123f0:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80123f4:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 80123f8:	687b      	ldr	r3, [r7, #4]
 80123fa:	681b      	ldr	r3, [r3, #0]
 80123fc:	3314      	adds	r3, #20
 80123fe:	f8d7 20d0 	ldr.w	r2, [r7, #208]	@ 0xd0
 8012402:	f8c7 20a8 	str.w	r2, [r7, #168]	@ 0xa8
 8012406:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801240a:	f8d7 10a4 	ldr.w	r1, [r7, #164]	@ 0xa4
 801240e:	f8d7 20a8 	ldr.w	r2, [r7, #168]	@ 0xa8
 8012412:	e841 2300 	strex	r3, r2, [r1]
 8012416:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
   return(result);
 801241a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	@ 0xa0
 801241e:	2b00      	cmp	r3, #0
 8012420:	d1d9      	bne.n	80123d6 <HAL_UART_IRQHandler+0x18e>

          /* Abort the UART DMA Rx stream */
          if (huart->hdmarx != NULL)
 8012422:	687b      	ldr	r3, [r7, #4]
 8012424:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012426:	2b00      	cmp	r3, #0
 8012428:	d013      	beq.n	8012452 <HAL_UART_IRQHandler+0x20a>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 801242a:	687b      	ldr	r3, [r7, #4]
 801242c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 801242e:	4a7e      	ldr	r2, [pc, #504]	@ (8012628 <HAL_UART_IRQHandler+0x3e0>)
 8012430:	651a      	str	r2, [r3, #80]	@ 0x50
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8012432:	687b      	ldr	r3, [r7, #4]
 8012434:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012436:	4618      	mov	r0, r3
 8012438:	f7f6 ff6c 	bl	8009314 <HAL_DMA_Abort_IT>
 801243c:	4603      	mov	r3, r0
 801243e:	2b00      	cmp	r3, #0
 8012440:	d016      	beq.n	8012470 <HAL_UART_IRQHandler+0x228>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8012442:	687b      	ldr	r3, [r7, #4]
 8012444:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012446:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8012448:	687a      	ldr	r2, [r7, #4]
 801244a:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 801244c:	4610      	mov	r0, r2
 801244e:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8012450:	e00e      	b.n	8012470 <HAL_UART_IRQHandler+0x228>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 8012452:	6878      	ldr	r0, [r7, #4]
 8012454:	f000 f9a8 	bl	80127a8 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8012458:	e00a      	b.n	8012470 <HAL_UART_IRQHandler+0x228>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 801245a:	6878      	ldr	r0, [r7, #4]
 801245c:	f000 f9a4 	bl	80127a8 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8012460:	e006      	b.n	8012470 <HAL_UART_IRQHandler+0x228>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 8012462:	6878      	ldr	r0, [r7, #4]
 8012464:	f000 f9a0 	bl	80127a8 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8012468:	687b      	ldr	r3, [r7, #4]
 801246a:	2200      	movs	r2, #0
 801246c:	645a      	str	r2, [r3, #68]	@ 0x44
      }
    }
    return;
 801246e:	e175      	b.n	801275c <HAL_UART_IRQHandler+0x514>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8012470:	bf00      	nop
    return;
 8012472:	e173      	b.n	801275c <HAL_UART_IRQHandler+0x514>
  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8012474:	687b      	ldr	r3, [r7, #4]
 8012476:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012478:	2b01      	cmp	r3, #1
 801247a:	f040 814f 	bne.w	801271c <HAL_UART_IRQHandler+0x4d4>
      && ((isrflags & USART_SR_IDLE) != 0U)
 801247e:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8012482:	f003 0310 	and.w	r3, r3, #16
 8012486:	2b00      	cmp	r3, #0
 8012488:	f000 8148 	beq.w	801271c <HAL_UART_IRQHandler+0x4d4>
      && ((cr1its & USART_SR_IDLE) != 0U))
 801248c:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 8012490:	f003 0310 	and.w	r3, r3, #16
 8012494:	2b00      	cmp	r3, #0
 8012496:	f000 8141 	beq.w	801271c <HAL_UART_IRQHandler+0x4d4>
  {
    __HAL_UART_CLEAR_IDLEFLAG(huart);
 801249a:	2300      	movs	r3, #0
 801249c:	60bb      	str	r3, [r7, #8]
 801249e:	687b      	ldr	r3, [r7, #4]
 80124a0:	681b      	ldr	r3, [r3, #0]
 80124a2:	681b      	ldr	r3, [r3, #0]
 80124a4:	60bb      	str	r3, [r7, #8]
 80124a6:	687b      	ldr	r3, [r7, #4]
 80124a8:	681b      	ldr	r3, [r3, #0]
 80124aa:	685b      	ldr	r3, [r3, #4]
 80124ac:	60bb      	str	r3, [r7, #8]
 80124ae:	68bb      	ldr	r3, [r7, #8]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80124b0:	687b      	ldr	r3, [r7, #4]
 80124b2:	681b      	ldr	r3, [r3, #0]
 80124b4:	695b      	ldr	r3, [r3, #20]
 80124b6:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80124ba:	2b40      	cmp	r3, #64	@ 0x40
 80124bc:	f040 80b6 	bne.w	801262c <HAL_UART_IRQHandler+0x3e4>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 80124c0:	687b      	ldr	r3, [r7, #4]
 80124c2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80124c4:	681b      	ldr	r3, [r3, #0]
 80124c6:	685b      	ldr	r3, [r3, #4]
 80124c8:	f8a7 30be 	strh.w	r3, [r7, #190]	@ 0xbe
      if ((nb_remaining_rx_data > 0U)
 80124cc:	f8b7 30be 	ldrh.w	r3, [r7, #190]	@ 0xbe
 80124d0:	2b00      	cmp	r3, #0
 80124d2:	f000 8145 	beq.w	8012760 <HAL_UART_IRQHandler+0x518>
          && (nb_remaining_rx_data < huart->RxXferSize))
 80124d6:	687b      	ldr	r3, [r7, #4]
 80124d8:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 80124da:	f8b7 20be 	ldrh.w	r2, [r7, #190]	@ 0xbe
 80124de:	429a      	cmp	r2, r3
 80124e0:	f080 813e 	bcs.w	8012760 <HAL_UART_IRQHandler+0x518>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 80124e4:	687b      	ldr	r3, [r7, #4]
 80124e6:	f8b7 20be 	ldrh.w	r2, [r7, #190]	@ 0xbe
 80124ea:	85da      	strh	r2, [r3, #46]	@ 0x2e

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 80124ec:	687b      	ldr	r3, [r7, #4]
 80124ee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80124f0:	69db      	ldr	r3, [r3, #28]
 80124f2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80124f6:	f000 8088 	beq.w	801260a <HAL_UART_IRQHandler+0x3c2>
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80124fa:	687b      	ldr	r3, [r7, #4]
 80124fc:	681b      	ldr	r3, [r3, #0]
 80124fe:	330c      	adds	r3, #12
 8012500:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012504:	f8d7 3088 	ldr.w	r3, [r7, #136]	@ 0x88
 8012508:	e853 3f00 	ldrex	r3, [r3]
 801250c:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
   return(result);
 8012510:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8012514:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8012518:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 801251c:	687b      	ldr	r3, [r7, #4]
 801251e:	681b      	ldr	r3, [r3, #0]
 8012520:	330c      	adds	r3, #12
 8012522:	f8d7 20b8 	ldr.w	r2, [r7, #184]	@ 0xb8
 8012526:	f8c7 2094 	str.w	r2, [r7, #148]	@ 0x94
 801252a:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801252e:	f8d7 1090 	ldr.w	r1, [r7, #144]	@ 0x90
 8012532:	f8d7 2094 	ldr.w	r2, [r7, #148]	@ 0x94
 8012536:	e841 2300 	strex	r3, r2, [r1]
 801253a:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
   return(result);
 801253e:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8012542:	2b00      	cmp	r3, #0
 8012544:	d1d9      	bne.n	80124fa <HAL_UART_IRQHandler+0x2b2>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8012546:	687b      	ldr	r3, [r7, #4]
 8012548:	681b      	ldr	r3, [r3, #0]
 801254a:	3314      	adds	r3, #20
 801254c:	677b      	str	r3, [r7, #116]	@ 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801254e:	6f7b      	ldr	r3, [r7, #116]	@ 0x74
 8012550:	e853 3f00 	ldrex	r3, [r3]
 8012554:	673b      	str	r3, [r7, #112]	@ 0x70
   return(result);
 8012556:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8012558:	f023 0301 	bic.w	r3, r3, #1
 801255c:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8012560:	687b      	ldr	r3, [r7, #4]
 8012562:	681b      	ldr	r3, [r3, #0]
 8012564:	3314      	adds	r3, #20
 8012566:	f8d7 20b4 	ldr.w	r2, [r7, #180]	@ 0xb4
 801256a:	f8c7 2080 	str.w	r2, [r7, #128]	@ 0x80
 801256e:	67fb      	str	r3, [r7, #124]	@ 0x7c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012570:	6ff9      	ldr	r1, [r7, #124]	@ 0x7c
 8012572:	f8d7 2080 	ldr.w	r2, [r7, #128]	@ 0x80
 8012576:	e841 2300 	strex	r3, r2, [r1]
 801257a:	67bb      	str	r3, [r7, #120]	@ 0x78
   return(result);
 801257c:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 801257e:	2b00      	cmp	r3, #0
 8012580:	d1e1      	bne.n	8012546 <HAL_UART_IRQHandler+0x2fe>

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8012582:	687b      	ldr	r3, [r7, #4]
 8012584:	681b      	ldr	r3, [r3, #0]
 8012586:	3314      	adds	r3, #20
 8012588:	663b      	str	r3, [r7, #96]	@ 0x60
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801258a:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 801258c:	e853 3f00 	ldrex	r3, [r3]
 8012590:	65fb      	str	r3, [r7, #92]	@ 0x5c
   return(result);
 8012592:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8012594:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8012598:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 801259c:	687b      	ldr	r3, [r7, #4]
 801259e:	681b      	ldr	r3, [r3, #0]
 80125a0:	3314      	adds	r3, #20
 80125a2:	f8d7 20b0 	ldr.w	r2, [r7, #176]	@ 0xb0
 80125a6:	66fa      	str	r2, [r7, #108]	@ 0x6c
 80125a8:	66bb      	str	r3, [r7, #104]	@ 0x68
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80125aa:	6eb9      	ldr	r1, [r7, #104]	@ 0x68
 80125ac:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 80125ae:	e841 2300 	strex	r3, r2, [r1]
 80125b2:	667b      	str	r3, [r7, #100]	@ 0x64
   return(result);
 80125b4:	6e7b      	ldr	r3, [r7, #100]	@ 0x64
 80125b6:	2b00      	cmp	r3, #0
 80125b8:	d1e3      	bne.n	8012582 <HAL_UART_IRQHandler+0x33a>

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 80125ba:	687b      	ldr	r3, [r7, #4]
 80125bc:	2220      	movs	r2, #32
 80125be:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80125c2:	687b      	ldr	r3, [r7, #4]
 80125c4:	2200      	movs	r2, #0
 80125c6:	631a      	str	r2, [r3, #48]	@ 0x30

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80125c8:	687b      	ldr	r3, [r7, #4]
 80125ca:	681b      	ldr	r3, [r3, #0]
 80125cc:	330c      	adds	r3, #12
 80125ce:	64fb      	str	r3, [r7, #76]	@ 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80125d0:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80125d2:	e853 3f00 	ldrex	r3, [r3]
 80125d6:	64bb      	str	r3, [r7, #72]	@ 0x48
   return(result);
 80125d8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80125da:	f023 0310 	bic.w	r3, r3, #16
 80125de:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 80125e2:	687b      	ldr	r3, [r7, #4]
 80125e4:	681b      	ldr	r3, [r3, #0]
 80125e6:	330c      	adds	r3, #12
 80125e8:	f8d7 20ac 	ldr.w	r2, [r7, #172]	@ 0xac
 80125ec:	65ba      	str	r2, [r7, #88]	@ 0x58
 80125ee:	657b      	str	r3, [r7, #84]	@ 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80125f0:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80125f2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80125f4:	e841 2300 	strex	r3, r2, [r1]
 80125f8:	653b      	str	r3, [r7, #80]	@ 0x50
   return(result);
 80125fa:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80125fc:	2b00      	cmp	r3, #0
 80125fe:	d1e3      	bne.n	80125c8 <HAL_UART_IRQHandler+0x380>

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 8012600:	687b      	ldr	r3, [r7, #4]
 8012602:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012604:	4618      	mov	r0, r3
 8012606:	f7f6 fe15 	bl	8009234 <HAL_DMA_Abort>
        }

        /* Initialize type of RxEvent that correspond to RxEvent callback execution;
        In this case, Rx Event type is Idle Event */
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 801260a:	687b      	ldr	r3, [r7, #4]
 801260c:	2202      	movs	r2, #2
 801260e:	635a      	str	r2, [r3, #52]	@ 0x34
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8012610:	687b      	ldr	r3, [r7, #4]
 8012612:	8d9a      	ldrh	r2, [r3, #44]	@ 0x2c
 8012614:	687b      	ldr	r3, [r7, #4]
 8012616:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 8012618:	b29b      	uxth	r3, r3
 801261a:	1ad3      	subs	r3, r2, r3
 801261c:	b29b      	uxth	r3, r3
 801261e:	4619      	mov	r1, r3
 8012620:	6878      	ldr	r0, [r7, #4]
 8012622:	f000 f8cb 	bl	80127bc <HAL_UARTEx_RxEventCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      return;
 8012626:	e09b      	b.n	8012760 <HAL_UART_IRQHandler+0x518>
 8012628:	08012ccf 	.word	0x08012ccf
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 801262c:	687b      	ldr	r3, [r7, #4]
 801262e:	8d9a      	ldrh	r2, [r3, #44]	@ 0x2c
 8012630:	687b      	ldr	r3, [r7, #4]
 8012632:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 8012634:	b29b      	uxth	r3, r3
 8012636:	1ad3      	subs	r3, r2, r3
 8012638:	f8a7 30ce 	strh.w	r3, [r7, #206]	@ 0xce
      if ((huart->RxXferCount > 0U)
 801263c:	687b      	ldr	r3, [r7, #4]
 801263e:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 8012640:	b29b      	uxth	r3, r3
 8012642:	2b00      	cmp	r3, #0
 8012644:	f000 808e 	beq.w	8012764 <HAL_UART_IRQHandler+0x51c>
          && (nb_rx_data > 0U))
 8012648:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	@ 0xce
 801264c:	2b00      	cmp	r3, #0
 801264e:	f000 8089 	beq.w	8012764 <HAL_UART_IRQHandler+0x51c>
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8012652:	687b      	ldr	r3, [r7, #4]
 8012654:	681b      	ldr	r3, [r3, #0]
 8012656:	330c      	adds	r3, #12
 8012658:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 801265a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801265c:	e853 3f00 	ldrex	r3, [r3]
 8012660:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 8012662:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012664:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 8012668:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 801266c:	687b      	ldr	r3, [r7, #4]
 801266e:	681b      	ldr	r3, [r3, #0]
 8012670:	330c      	adds	r3, #12
 8012672:	f8d7 20c8 	ldr.w	r2, [r7, #200]	@ 0xc8
 8012676:	647a      	str	r2, [r7, #68]	@ 0x44
 8012678:	643b      	str	r3, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801267a:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 801267c:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 801267e:	e841 2300 	strex	r3, r2, [r1]
 8012682:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 8012684:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012686:	2b00      	cmp	r3, #0
 8012688:	d1e3      	bne.n	8012652 <HAL_UART_IRQHandler+0x40a>

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801268a:	687b      	ldr	r3, [r7, #4]
 801268c:	681b      	ldr	r3, [r3, #0]
 801268e:	3314      	adds	r3, #20
 8012690:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012692:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012694:	e853 3f00 	ldrex	r3, [r3]
 8012698:	623b      	str	r3, [r7, #32]
   return(result);
 801269a:	6a3b      	ldr	r3, [r7, #32]
 801269c:	f023 0301 	bic.w	r3, r3, #1
 80126a0:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 80126a4:	687b      	ldr	r3, [r7, #4]
 80126a6:	681b      	ldr	r3, [r3, #0]
 80126a8:	3314      	adds	r3, #20
 80126aa:	f8d7 20c4 	ldr.w	r2, [r7, #196]	@ 0xc4
 80126ae:	633a      	str	r2, [r7, #48]	@ 0x30
 80126b0:	62fb      	str	r3, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80126b2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 80126b4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 80126b6:	e841 2300 	strex	r3, r2, [r1]
 80126ba:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 80126bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80126be:	2b00      	cmp	r3, #0
 80126c0:	d1e3      	bne.n	801268a <HAL_UART_IRQHandler+0x442>

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 80126c2:	687b      	ldr	r3, [r7, #4]
 80126c4:	2220      	movs	r2, #32
 80126c6:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 80126ca:	687b      	ldr	r3, [r7, #4]
 80126cc:	2200      	movs	r2, #0
 80126ce:	631a      	str	r2, [r3, #48]	@ 0x30

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80126d0:	687b      	ldr	r3, [r7, #4]
 80126d2:	681b      	ldr	r3, [r3, #0]
 80126d4:	330c      	adds	r3, #12
 80126d6:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80126d8:	693b      	ldr	r3, [r7, #16]
 80126da:	e853 3f00 	ldrex	r3, [r3]
 80126de:	60fb      	str	r3, [r7, #12]
   return(result);
 80126e0:	68fb      	ldr	r3, [r7, #12]
 80126e2:	f023 0310 	bic.w	r3, r3, #16
 80126e6:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 80126ea:	687b      	ldr	r3, [r7, #4]
 80126ec:	681b      	ldr	r3, [r3, #0]
 80126ee:	330c      	adds	r3, #12
 80126f0:	f8d7 20c0 	ldr.w	r2, [r7, #192]	@ 0xc0
 80126f4:	61fa      	str	r2, [r7, #28]
 80126f6:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80126f8:	69b9      	ldr	r1, [r7, #24]
 80126fa:	69fa      	ldr	r2, [r7, #28]
 80126fc:	e841 2300 	strex	r3, r2, [r1]
 8012700:	617b      	str	r3, [r7, #20]
   return(result);
 8012702:	697b      	ldr	r3, [r7, #20]
 8012704:	2b00      	cmp	r3, #0
 8012706:	d1e3      	bne.n	80126d0 <HAL_UART_IRQHandler+0x488>

        /* Initialize type of RxEvent that correspond to RxEvent callback execution;
           In this case, Rx Event type is Idle Event */
        huart->RxEventType = HAL_UART_RXEVENT_IDLE;
 8012708:	687b      	ldr	r3, [r7, #4]
 801270a:	2202      	movs	r2, #2
 801270c:	635a      	str	r2, [r3, #52]	@ 0x34
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 801270e:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	@ 0xce
 8012712:	4619      	mov	r1, r3
 8012714:	6878      	ldr	r0, [r7, #4]
 8012716:	f000 f851 	bl	80127bc <HAL_UARTEx_RxEventCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      return;
 801271a:	e023      	b.n	8012764 <HAL_UART_IRQHandler+0x51c>
    }
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 801271c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8012720:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012724:	2b00      	cmp	r3, #0
 8012726:	d009      	beq.n	801273c <HAL_UART_IRQHandler+0x4f4>
 8012728:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801272c:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012730:	2b00      	cmp	r3, #0
 8012732:	d003      	beq.n	801273c <HAL_UART_IRQHandler+0x4f4>
  {
    UART_Transmit_IT(huart);
 8012734:	6878      	ldr	r0, [r7, #4]
 8012736:	f000 fade 	bl	8012cf6 <UART_Transmit_IT>
    return;
 801273a:	e014      	b.n	8012766 <HAL_UART_IRQHandler+0x51e>
  }

  /* UART in mode Transmitter end --------------------------------------------*/
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 801273c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	@ 0xe4
 8012740:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8012744:	2b00      	cmp	r3, #0
 8012746:	d00e      	beq.n	8012766 <HAL_UART_IRQHandler+0x51e>
 8012748:	f8d7 30e0 	ldr.w	r3, [r7, #224]	@ 0xe0
 801274c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8012750:	2b00      	cmp	r3, #0
 8012752:	d008      	beq.n	8012766 <HAL_UART_IRQHandler+0x51e>
  {
    UART_EndTransmit_IT(huart);
 8012754:	6878      	ldr	r0, [r7, #4]
 8012756:	f000 fb1e 	bl	8012d96 <UART_EndTransmit_IT>
    return;
 801275a:	e004      	b.n	8012766 <HAL_UART_IRQHandler+0x51e>
    return;
 801275c:	bf00      	nop
 801275e:	e002      	b.n	8012766 <HAL_UART_IRQHandler+0x51e>
      return;
 8012760:	bf00      	nop
 8012762:	e000      	b.n	8012766 <HAL_UART_IRQHandler+0x51e>
      return;
 8012764:	bf00      	nop
  }
}
 8012766:	37e8      	adds	r7, #232	@ 0xe8
 8012768:	46bd      	mov	sp, r7
 801276a:	bd80      	pop	{r7, pc}

0801276c <HAL_UART_TxCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 801276c:	b480      	push	{r7}
 801276e:	b083      	sub	sp, #12
 8012770:	af00      	add	r7, sp, #0
 8012772:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxCpltCallback could be implemented in the user file
   */
}
 8012774:	bf00      	nop
 8012776:	370c      	adds	r7, #12
 8012778:	46bd      	mov	sp, r7
 801277a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801277e:	4770      	bx	lr

08012780 <HAL_UART_RxCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 8012780:	b480      	push	{r7}
 8012782:	b083      	sub	sp, #12
 8012784:	af00      	add	r7, sp, #0
 8012786:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxCpltCallback could be implemented in the user file
   */
}
 8012788:	bf00      	nop
 801278a:	370c      	adds	r7, #12
 801278c:	46bd      	mov	sp, r7
 801278e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012792:	4770      	bx	lr

08012794 <HAL_UART_RxHalfCpltCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 8012794:	b480      	push	{r7}
 8012796:	b083      	sub	sp, #12
 8012798:	af00      	add	r7, sp, #0
 801279a:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback could be implemented in the user file
   */
}
 801279c:	bf00      	nop
 801279e:	370c      	adds	r7, #12
 80127a0:	46bd      	mov	sp, r7
 80127a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127a6:	4770      	bx	lr

080127a8 <HAL_UART_ErrorCallback>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 80127a8:	b480      	push	{r7}
 80127aa:	b083      	sub	sp, #12
 80127ac:	af00      	add	r7, sp, #0
 80127ae:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(huart);
  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_ErrorCallback could be implemented in the user file
   */
}
 80127b0:	bf00      	nop
 80127b2:	370c      	adds	r7, #12
 80127b4:	46bd      	mov	sp, r7
 80127b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127ba:	4770      	bx	lr

080127bc <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 80127bc:	b480      	push	{r7}
 80127be:	b083      	sub	sp, #12
 80127c0:	af00      	add	r7, sp, #0
 80127c2:	6078      	str	r0, [r7, #4]
 80127c4:	460b      	mov	r3, r1
 80127c6:	807b      	strh	r3, [r7, #2]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 80127c8:	bf00      	nop
 80127ca:	370c      	adds	r7, #12
 80127cc:	46bd      	mov	sp, r7
 80127ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80127d2:	4770      	bx	lr

080127d4 <UART_DMAReceiveCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 80127d4:	b580      	push	{r7, lr}
 80127d6:	b09c      	sub	sp, #112	@ 0x70
 80127d8:	af00      	add	r7, sp, #0
 80127da:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80127dc:	687b      	ldr	r3, [r7, #4]
 80127de:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80127e0:	66fb      	str	r3, [r7, #108]	@ 0x6c

  /* DMA Normal mode*/
  if ((hdma->Instance->CR & DMA_SxCR_CIRC) == 0U)
 80127e2:	687b      	ldr	r3, [r7, #4]
 80127e4:	681b      	ldr	r3, [r3, #0]
 80127e6:	681b      	ldr	r3, [r3, #0]
 80127e8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80127ec:	2b00      	cmp	r3, #0
 80127ee:	d172      	bne.n	80128d6 <UART_DMAReceiveCplt+0x102>
  {
    huart->RxXferCount = 0U;
 80127f0:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80127f2:	2200      	movs	r2, #0
 80127f4:	85da      	strh	r2, [r3, #46]	@ 0x2e

    /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 80127f6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80127f8:	681b      	ldr	r3, [r3, #0]
 80127fa:	330c      	adds	r3, #12
 80127fc:	64fb      	str	r3, [r7, #76]	@ 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80127fe:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8012800:	e853 3f00 	ldrex	r3, [r3]
 8012804:	64bb      	str	r3, [r7, #72]	@ 0x48
   return(result);
 8012806:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8012808:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 801280c:	66bb      	str	r3, [r7, #104]	@ 0x68
 801280e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012810:	681b      	ldr	r3, [r3, #0]
 8012812:	330c      	adds	r3, #12
 8012814:	6eba      	ldr	r2, [r7, #104]	@ 0x68
 8012816:	65ba      	str	r2, [r7, #88]	@ 0x58
 8012818:	657b      	str	r3, [r7, #84]	@ 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801281a:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 801281c:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 801281e:	e841 2300 	strex	r3, r2, [r1]
 8012822:	653b      	str	r3, [r7, #80]	@ 0x50
   return(result);
 8012824:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8012826:	2b00      	cmp	r3, #0
 8012828:	d1e5      	bne.n	80127f6 <UART_DMAReceiveCplt+0x22>
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 801282a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801282c:	681b      	ldr	r3, [r3, #0]
 801282e:	3314      	adds	r3, #20
 8012830:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012832:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012834:	e853 3f00 	ldrex	r3, [r3]
 8012838:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 801283a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801283c:	f023 0301 	bic.w	r3, r3, #1
 8012840:	667b      	str	r3, [r7, #100]	@ 0x64
 8012842:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012844:	681b      	ldr	r3, [r3, #0]
 8012846:	3314      	adds	r3, #20
 8012848:	6e7a      	ldr	r2, [r7, #100]	@ 0x64
 801284a:	647a      	str	r2, [r7, #68]	@ 0x44
 801284c:	643b      	str	r3, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 801284e:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 8012850:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8012852:	e841 2300 	strex	r3, r2, [r1]
 8012856:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 8012858:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801285a:	2b00      	cmp	r3, #0
 801285c:	d1e5      	bne.n	801282a <UART_DMAReceiveCplt+0x56>

    /* Disable the DMA transfer for the receiver request by setting the DMAR bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 801285e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012860:	681b      	ldr	r3, [r3, #0]
 8012862:	3314      	adds	r3, #20
 8012864:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012866:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012868:	e853 3f00 	ldrex	r3, [r3]
 801286c:	623b      	str	r3, [r7, #32]
   return(result);
 801286e:	6a3b      	ldr	r3, [r7, #32]
 8012870:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8012874:	663b      	str	r3, [r7, #96]	@ 0x60
 8012876:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012878:	681b      	ldr	r3, [r3, #0]
 801287a:	3314      	adds	r3, #20
 801287c:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 801287e:	633a      	str	r2, [r7, #48]	@ 0x30
 8012880:	62fb      	str	r3, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012882:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 8012884:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8012886:	e841 2300 	strex	r3, r2, [r1]
 801288a:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 801288c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801288e:	2b00      	cmp	r3, #0
 8012890:	d1e5      	bne.n	801285e <UART_DMAReceiveCplt+0x8a>

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 8012892:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8012894:	2220      	movs	r2, #32
 8012896:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 801289a:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 801289c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801289e:	2b01      	cmp	r3, #1
 80128a0:	d119      	bne.n	80128d6 <UART_DMAReceiveCplt+0x102>
    {
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 80128a2:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80128a4:	681b      	ldr	r3, [r3, #0]
 80128a6:	330c      	adds	r3, #12
 80128a8:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80128aa:	693b      	ldr	r3, [r7, #16]
 80128ac:	e853 3f00 	ldrex	r3, [r3]
 80128b0:	60fb      	str	r3, [r7, #12]
   return(result);
 80128b2:	68fb      	ldr	r3, [r7, #12]
 80128b4:	f023 0310 	bic.w	r3, r3, #16
 80128b8:	65fb      	str	r3, [r7, #92]	@ 0x5c
 80128ba:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80128bc:	681b      	ldr	r3, [r3, #0]
 80128be:	330c      	adds	r3, #12
 80128c0:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 80128c2:	61fa      	str	r2, [r7, #28]
 80128c4:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80128c6:	69b9      	ldr	r1, [r7, #24]
 80128c8:	69fa      	ldr	r2, [r7, #28]
 80128ca:	e841 2300 	strex	r3, r2, [r1]
 80128ce:	617b      	str	r3, [r7, #20]
   return(result);
 80128d0:	697b      	ldr	r3, [r7, #20]
 80128d2:	2b00      	cmp	r3, #0
 80128d4:	d1e5      	bne.n	80128a2 <UART_DMAReceiveCplt+0xce>
    }
  }

  /* Initialize type of RxEvent that correspond to RxEvent callback execution;
   In this case, Rx Event type is Transfer Complete */
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 80128d6:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80128d8:	2200      	movs	r2, #0
 80128da:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 80128dc:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80128de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80128e0:	2b01      	cmp	r3, #1
 80128e2:	d106      	bne.n	80128f2 <UART_DMAReceiveCplt+0x11e>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 80128e4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 80128e6:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 80128e8:	4619      	mov	r1, r3
 80128ea:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 80128ec:	f7ff ff66 	bl	80127bc <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx complete callback*/
    HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 80128f0:	e002      	b.n	80128f8 <UART_DMAReceiveCplt+0x124>
    HAL_UART_RxCpltCallback(huart);
 80128f2:	6ef8      	ldr	r0, [r7, #108]	@ 0x6c
 80128f4:	f7ff ff44 	bl	8012780 <HAL_UART_RxCpltCallback>
}
 80128f8:	bf00      	nop
 80128fa:	3770      	adds	r7, #112	@ 0x70
 80128fc:	46bd      	mov	sp, r7
 80128fe:	bd80      	pop	{r7, pc}

08012900 <UART_DMARxHalfCplt>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 8012900:	b580      	push	{r7, lr}
 8012902:	b084      	sub	sp, #16
 8012904:	af00      	add	r7, sp, #0
 8012906:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8012908:	687b      	ldr	r3, [r7, #4]
 801290a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801290c:	60fb      	str	r3, [r7, #12]

  /* Initialize type of RxEvent that correspond to RxEvent callback execution;
     In this case, Rx Event type is Half Transfer */
  huart->RxEventType = HAL_UART_RXEVENT_HT;
 801290e:	68fb      	ldr	r3, [r7, #12]
 8012910:	2201      	movs	r2, #1
 8012912:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8012914:	68fb      	ldr	r3, [r7, #12]
 8012916:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012918:	2b01      	cmp	r3, #1
 801291a:	d108      	bne.n	801292e <UART_DMARxHalfCplt+0x2e>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize / 2U);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
 801291c:	68fb      	ldr	r3, [r7, #12]
 801291e:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 8012920:	085b      	lsrs	r3, r3, #1
 8012922:	b29b      	uxth	r3, r3
 8012924:	4619      	mov	r1, r3
 8012926:	68f8      	ldr	r0, [r7, #12]
 8012928:	f7ff ff48 	bl	80127bc <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx Half complete callback*/
    HAL_UART_RxHalfCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 801292c:	e002      	b.n	8012934 <UART_DMARxHalfCplt+0x34>
    HAL_UART_RxHalfCpltCallback(huart);
 801292e:	68f8      	ldr	r0, [r7, #12]
 8012930:	f7ff ff30 	bl	8012794 <HAL_UART_RxHalfCpltCallback>
}
 8012934:	bf00      	nop
 8012936:	3710      	adds	r7, #16
 8012938:	46bd      	mov	sp, r7
 801293a:	bd80      	pop	{r7, pc}

0801293c <UART_DMAError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 801293c:	b580      	push	{r7, lr}
 801293e:	b084      	sub	sp, #16
 8012940:	af00      	add	r7, sp, #0
 8012942:	6078      	str	r0, [r7, #4]
  uint32_t dmarequest = 0x00U;
 8012944:	2300      	movs	r3, #0
 8012946:	60fb      	str	r3, [r7, #12]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8012948:	687b      	ldr	r3, [r7, #4]
 801294a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801294c:	60bb      	str	r3, [r7, #8]

  /* Stop UART DMA Tx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
 801294e:	68bb      	ldr	r3, [r7, #8]
 8012950:	681b      	ldr	r3, [r3, #0]
 8012952:	695b      	ldr	r3, [r3, #20]
 8012954:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8012958:	2b80      	cmp	r3, #128	@ 0x80
 801295a:	bf0c      	ite	eq
 801295c:	2301      	moveq	r3, #1
 801295e:	2300      	movne	r3, #0
 8012960:	b2db      	uxtb	r3, r3
 8012962:	60fb      	str	r3, [r7, #12]
  if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
 8012964:	68bb      	ldr	r3, [r7, #8]
 8012966:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 801296a:	b2db      	uxtb	r3, r3
 801296c:	2b21      	cmp	r3, #33	@ 0x21
 801296e:	d108      	bne.n	8012982 <UART_DMAError+0x46>
 8012970:	68fb      	ldr	r3, [r7, #12]
 8012972:	2b00      	cmp	r3, #0
 8012974:	d005      	beq.n	8012982 <UART_DMAError+0x46>
  {
    huart->TxXferCount = 0x00U;
 8012976:	68bb      	ldr	r3, [r7, #8]
 8012978:	2200      	movs	r2, #0
 801297a:	84da      	strh	r2, [r3, #38]	@ 0x26
    UART_EndTxTransfer(huart);
 801297c:	68b8      	ldr	r0, [r7, #8]
 801297e:	f000 f91b 	bl	8012bb8 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8012982:	68bb      	ldr	r3, [r7, #8]
 8012984:	681b      	ldr	r3, [r3, #0]
 8012986:	695b      	ldr	r3, [r3, #20]
 8012988:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801298c:	2b40      	cmp	r3, #64	@ 0x40
 801298e:	bf0c      	ite	eq
 8012990:	2301      	moveq	r3, #1
 8012992:	2300      	movne	r3, #0
 8012994:	b2db      	uxtb	r3, r3
 8012996:	60fb      	str	r3, [r7, #12]
  if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
 8012998:	68bb      	ldr	r3, [r7, #8]
 801299a:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 801299e:	b2db      	uxtb	r3, r3
 80129a0:	2b22      	cmp	r3, #34	@ 0x22
 80129a2:	d108      	bne.n	80129b6 <UART_DMAError+0x7a>
 80129a4:	68fb      	ldr	r3, [r7, #12]
 80129a6:	2b00      	cmp	r3, #0
 80129a8:	d005      	beq.n	80129b6 <UART_DMAError+0x7a>
  {
    huart->RxXferCount = 0x00U;
 80129aa:	68bb      	ldr	r3, [r7, #8]
 80129ac:	2200      	movs	r2, #0
 80129ae:	85da      	strh	r2, [r3, #46]	@ 0x2e
    UART_EndRxTransfer(huart);
 80129b0:	68b8      	ldr	r0, [r7, #8]
 80129b2:	f000 f929 	bl	8012c08 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 80129b6:	68bb      	ldr	r3, [r7, #8]
 80129b8:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 80129ba:	f043 0210 	orr.w	r2, r3, #16
 80129be:	68bb      	ldr	r3, [r7, #8]
 80129c0:	645a      	str	r2, [r3, #68]	@ 0x44
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 80129c2:	68b8      	ldr	r0, [r7, #8]
 80129c4:	f7ff fef0 	bl	80127a8 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 80129c8:	bf00      	nop
 80129ca:	3710      	adds	r7, #16
 80129cc:	46bd      	mov	sp, r7
 80129ce:	bd80      	pop	{r7, pc}

080129d0 <UART_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                                     uint32_t Tickstart, uint32_t Timeout)
{
 80129d0:	b580      	push	{r7, lr}
 80129d2:	b086      	sub	sp, #24
 80129d4:	af00      	add	r7, sp, #0
 80129d6:	60f8      	str	r0, [r7, #12]
 80129d8:	60b9      	str	r1, [r7, #8]
 80129da:	603b      	str	r3, [r7, #0]
 80129dc:	4613      	mov	r3, r2
 80129de:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80129e0:	e03b      	b.n	8012a5a <UART_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80129e2:	6a3b      	ldr	r3, [r7, #32]
 80129e4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80129e8:	d037      	beq.n	8012a5a <UART_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80129ea:	f7f6 f94b 	bl	8008c84 <HAL_GetTick>
 80129ee:	4602      	mov	r2, r0
 80129f0:	683b      	ldr	r3, [r7, #0]
 80129f2:	1ad3      	subs	r3, r2, r3
 80129f4:	6a3a      	ldr	r2, [r7, #32]
 80129f6:	429a      	cmp	r2, r3
 80129f8:	d302      	bcc.n	8012a00 <UART_WaitOnFlagUntilTimeout+0x30>
 80129fa:	6a3b      	ldr	r3, [r7, #32]
 80129fc:	2b00      	cmp	r3, #0
 80129fe:	d101      	bne.n	8012a04 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 8012a00:	2303      	movs	r3, #3
 8012a02:	e03a      	b.n	8012a7a <UART_WaitOnFlagUntilTimeout+0xaa>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 8012a04:	68fb      	ldr	r3, [r7, #12]
 8012a06:	681b      	ldr	r3, [r3, #0]
 8012a08:	68db      	ldr	r3, [r3, #12]
 8012a0a:	f003 0304 	and.w	r3, r3, #4
 8012a0e:	2b00      	cmp	r3, #0
 8012a10:	d023      	beq.n	8012a5a <UART_WaitOnFlagUntilTimeout+0x8a>
 8012a12:	68bb      	ldr	r3, [r7, #8]
 8012a14:	2b80      	cmp	r3, #128	@ 0x80
 8012a16:	d020      	beq.n	8012a5a <UART_WaitOnFlagUntilTimeout+0x8a>
 8012a18:	68bb      	ldr	r3, [r7, #8]
 8012a1a:	2b40      	cmp	r3, #64	@ 0x40
 8012a1c:	d01d      	beq.n	8012a5a <UART_WaitOnFlagUntilTimeout+0x8a>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 8012a1e:	68fb      	ldr	r3, [r7, #12]
 8012a20:	681b      	ldr	r3, [r3, #0]
 8012a22:	681b      	ldr	r3, [r3, #0]
 8012a24:	f003 0308 	and.w	r3, r3, #8
 8012a28:	2b08      	cmp	r3, #8
 8012a2a:	d116      	bne.n	8012a5a <UART_WaitOnFlagUntilTimeout+0x8a>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_OREFLAG(huart);
 8012a2c:	2300      	movs	r3, #0
 8012a2e:	617b      	str	r3, [r7, #20]
 8012a30:	68fb      	ldr	r3, [r7, #12]
 8012a32:	681b      	ldr	r3, [r3, #0]
 8012a34:	681b      	ldr	r3, [r3, #0]
 8012a36:	617b      	str	r3, [r7, #20]
 8012a38:	68fb      	ldr	r3, [r7, #12]
 8012a3a:	681b      	ldr	r3, [r3, #0]
 8012a3c:	685b      	ldr	r3, [r3, #4]
 8012a3e:	617b      	str	r3, [r7, #20]
 8012a40:	697b      	ldr	r3, [r7, #20]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 8012a42:	68f8      	ldr	r0, [r7, #12]
 8012a44:	f000 f8e0 	bl	8012c08 <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 8012a48:	68fb      	ldr	r3, [r7, #12]
 8012a4a:	2208      	movs	r2, #8
 8012a4c:	645a      	str	r2, [r3, #68]	@ 0x44

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8012a4e:	68fb      	ldr	r3, [r7, #12]
 8012a50:	2200      	movs	r2, #0
 8012a52:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
 8012a56:	2301      	movs	r3, #1
 8012a58:	e00f      	b.n	8012a7a <UART_WaitOnFlagUntilTimeout+0xaa>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8012a5a:	68fb      	ldr	r3, [r7, #12]
 8012a5c:	681b      	ldr	r3, [r3, #0]
 8012a5e:	681a      	ldr	r2, [r3, #0]
 8012a60:	68bb      	ldr	r3, [r7, #8]
 8012a62:	4013      	ands	r3, r2
 8012a64:	68ba      	ldr	r2, [r7, #8]
 8012a66:	429a      	cmp	r2, r3
 8012a68:	bf0c      	ite	eq
 8012a6a:	2301      	moveq	r3, #1
 8012a6c:	2300      	movne	r3, #0
 8012a6e:	b2db      	uxtb	r3, r3
 8012a70:	461a      	mov	r2, r3
 8012a72:	79fb      	ldrb	r3, [r7, #7]
 8012a74:	429a      	cmp	r2, r3
 8012a76:	d0b4      	beq.n	80129e2 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8012a78:	2300      	movs	r3, #0
}
 8012a7a:	4618      	mov	r0, r3
 8012a7c:	3718      	adds	r7, #24
 8012a7e:	46bd      	mov	sp, r7
 8012a80:	bd80      	pop	{r7, pc}
	...

08012a84 <UART_Start_Receive_DMA>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8012a84:	b580      	push	{r7, lr}
 8012a86:	b098      	sub	sp, #96	@ 0x60
 8012a88:	af00      	add	r7, sp, #0
 8012a8a:	60f8      	str	r0, [r7, #12]
 8012a8c:	60b9      	str	r1, [r7, #8]
 8012a8e:	4613      	mov	r3, r2
 8012a90:	80fb      	strh	r3, [r7, #6]
  uint32_t *tmp;

  huart->pRxBuffPtr = pData;
 8012a92:	68ba      	ldr	r2, [r7, #8]
 8012a94:	68fb      	ldr	r3, [r7, #12]
 8012a96:	629a      	str	r2, [r3, #40]	@ 0x28
  huart->RxXferSize = Size;
 8012a98:	68fb      	ldr	r3, [r7, #12]
 8012a9a:	88fa      	ldrh	r2, [r7, #6]
 8012a9c:	859a      	strh	r2, [r3, #44]	@ 0x2c

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8012a9e:	68fb      	ldr	r3, [r7, #12]
 8012aa0:	2200      	movs	r2, #0
 8012aa2:	645a      	str	r2, [r3, #68]	@ 0x44
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8012aa4:	68fb      	ldr	r3, [r7, #12]
 8012aa6:	2222      	movs	r2, #34	@ 0x22
 8012aa8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  /* Set the UART DMA transfer complete callback */
  huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8012aac:	68fb      	ldr	r3, [r7, #12]
 8012aae:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012ab0:	4a3e      	ldr	r2, [pc, #248]	@ (8012bac <UART_Start_Receive_DMA+0x128>)
 8012ab2:	63da      	str	r2, [r3, #60]	@ 0x3c

  /* Set the UART DMA Half transfer complete callback */
  huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8012ab4:	68fb      	ldr	r3, [r7, #12]
 8012ab6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012ab8:	4a3d      	ldr	r2, [pc, #244]	@ (8012bb0 <UART_Start_Receive_DMA+0x12c>)
 8012aba:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Set the DMA error callback */
  huart->hdmarx->XferErrorCallback = UART_DMAError;
 8012abc:	68fb      	ldr	r3, [r7, #12]
 8012abe:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012ac0:	4a3c      	ldr	r2, [pc, #240]	@ (8012bb4 <UART_Start_Receive_DMA+0x130>)
 8012ac2:	64da      	str	r2, [r3, #76]	@ 0x4c

  /* Set the DMA abort callback */
  huart->hdmarx->XferAbortCallback = NULL;
 8012ac4:	68fb      	ldr	r3, [r7, #12]
 8012ac6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8012ac8:	2200      	movs	r2, #0
 8012aca:	651a      	str	r2, [r3, #80]	@ 0x50

  /* Enable the DMA stream */
  tmp = (uint32_t *)&pData;
 8012acc:	f107 0308 	add.w	r3, r7, #8
 8012ad0:	65fb      	str	r3, [r7, #92]	@ 0x5c
  HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
 8012ad2:	68fb      	ldr	r3, [r7, #12]
 8012ad4:	6bd8      	ldr	r0, [r3, #60]	@ 0x3c
 8012ad6:	68fb      	ldr	r3, [r7, #12]
 8012ad8:	681b      	ldr	r3, [r3, #0]
 8012ada:	3304      	adds	r3, #4
 8012adc:	4619      	mov	r1, r3
 8012ade:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8012ae0:	681a      	ldr	r2, [r3, #0]
 8012ae2:	88fb      	ldrh	r3, [r7, #6]
 8012ae4:	f7f6 fb4e 	bl	8009184 <HAL_DMA_Start_IT>

  /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
  __HAL_UART_CLEAR_OREFLAG(huart);
 8012ae8:	2300      	movs	r3, #0
 8012aea:	613b      	str	r3, [r7, #16]
 8012aec:	68fb      	ldr	r3, [r7, #12]
 8012aee:	681b      	ldr	r3, [r3, #0]
 8012af0:	681b      	ldr	r3, [r3, #0]
 8012af2:	613b      	str	r3, [r7, #16]
 8012af4:	68fb      	ldr	r3, [r7, #12]
 8012af6:	681b      	ldr	r3, [r3, #0]
 8012af8:	685b      	ldr	r3, [r3, #4]
 8012afa:	613b      	str	r3, [r7, #16]
 8012afc:	693b      	ldr	r3, [r7, #16]

  if (huart->Init.Parity != UART_PARITY_NONE)
 8012afe:	68fb      	ldr	r3, [r7, #12]
 8012b00:	691b      	ldr	r3, [r3, #16]
 8012b02:	2b00      	cmp	r3, #0
 8012b04:	d019      	beq.n	8012b3a <UART_Start_Receive_DMA+0xb6>
  {
    /* Enable the UART Parity Error Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8012b06:	68fb      	ldr	r3, [r7, #12]
 8012b08:	681b      	ldr	r3, [r3, #0]
 8012b0a:	330c      	adds	r3, #12
 8012b0c:	643b      	str	r3, [r7, #64]	@ 0x40
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012b0e:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8012b10:	e853 3f00 	ldrex	r3, [r3]
 8012b14:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 8012b16:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8012b18:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8012b1c:	65bb      	str	r3, [r7, #88]	@ 0x58
 8012b1e:	68fb      	ldr	r3, [r7, #12]
 8012b20:	681b      	ldr	r3, [r3, #0]
 8012b22:	330c      	adds	r3, #12
 8012b24:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 8012b26:	64fa      	str	r2, [r7, #76]	@ 0x4c
 8012b28:	64bb      	str	r3, [r7, #72]	@ 0x48
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012b2a:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 8012b2c:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8012b2e:	e841 2300 	strex	r3, r2, [r1]
 8012b32:	647b      	str	r3, [r7, #68]	@ 0x44
   return(result);
 8012b34:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8012b36:	2b00      	cmp	r3, #0
 8012b38:	d1e5      	bne.n	8012b06 <UART_Start_Receive_DMA+0x82>
  }

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8012b3a:	68fb      	ldr	r3, [r7, #12]
 8012b3c:	681b      	ldr	r3, [r3, #0]
 8012b3e:	3314      	adds	r3, #20
 8012b40:	62fb      	str	r3, [r7, #44]	@ 0x2c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012b42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012b44:	e853 3f00 	ldrex	r3, [r3]
 8012b48:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 8012b4a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012b4c:	f043 0301 	orr.w	r3, r3, #1
 8012b50:	657b      	str	r3, [r7, #84]	@ 0x54
 8012b52:	68fb      	ldr	r3, [r7, #12]
 8012b54:	681b      	ldr	r3, [r3, #0]
 8012b56:	3314      	adds	r3, #20
 8012b58:	6d7a      	ldr	r2, [r7, #84]	@ 0x54
 8012b5a:	63ba      	str	r2, [r7, #56]	@ 0x38
 8012b5c:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012b5e:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 8012b60:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8012b62:	e841 2300 	strex	r3, r2, [r1]
 8012b66:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 8012b68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012b6a:	2b00      	cmp	r3, #0
 8012b6c:	d1e5      	bne.n	8012b3a <UART_Start_Receive_DMA+0xb6>

  /* Enable the DMA transfer for the receiver request by setting the DMAR bit
  in the UART CR3 register */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8012b6e:	68fb      	ldr	r3, [r7, #12]
 8012b70:	681b      	ldr	r3, [r3, #0]
 8012b72:	3314      	adds	r3, #20
 8012b74:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012b76:	69bb      	ldr	r3, [r7, #24]
 8012b78:	e853 3f00 	ldrex	r3, [r3]
 8012b7c:	617b      	str	r3, [r7, #20]
   return(result);
 8012b7e:	697b      	ldr	r3, [r7, #20]
 8012b80:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8012b84:	653b      	str	r3, [r7, #80]	@ 0x50
 8012b86:	68fb      	ldr	r3, [r7, #12]
 8012b88:	681b      	ldr	r3, [r3, #0]
 8012b8a:	3314      	adds	r3, #20
 8012b8c:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8012b8e:	627a      	str	r2, [r7, #36]	@ 0x24
 8012b90:	623b      	str	r3, [r7, #32]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012b92:	6a39      	ldr	r1, [r7, #32]
 8012b94:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012b96:	e841 2300 	strex	r3, r2, [r1]
 8012b9a:	61fb      	str	r3, [r7, #28]
   return(result);
 8012b9c:	69fb      	ldr	r3, [r7, #28]
 8012b9e:	2b00      	cmp	r3, #0
 8012ba0:	d1e5      	bne.n	8012b6e <UART_Start_Receive_DMA+0xea>

  return HAL_OK;
 8012ba2:	2300      	movs	r3, #0
}
 8012ba4:	4618      	mov	r0, r3
 8012ba6:	3760      	adds	r7, #96	@ 0x60
 8012ba8:	46bd      	mov	sp, r7
 8012baa:	bd80      	pop	{r7, pc}
 8012bac:	080127d5 	.word	0x080127d5
 8012bb0:	08012901 	.word	0x08012901
 8012bb4:	0801293d 	.word	0x0801293d

08012bb8 <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 8012bb8:	b480      	push	{r7}
 8012bba:	b089      	sub	sp, #36	@ 0x24
 8012bbc:	af00      	add	r7, sp, #0
 8012bbe:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE and TCIE interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 8012bc0:	687b      	ldr	r3, [r7, #4]
 8012bc2:	681b      	ldr	r3, [r3, #0]
 8012bc4:	330c      	adds	r3, #12
 8012bc6:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012bc8:	68fb      	ldr	r3, [r7, #12]
 8012bca:	e853 3f00 	ldrex	r3, [r3]
 8012bce:	60bb      	str	r3, [r7, #8]
   return(result);
 8012bd0:	68bb      	ldr	r3, [r7, #8]
 8012bd2:	f023 03c0 	bic.w	r3, r3, #192	@ 0xc0
 8012bd6:	61fb      	str	r3, [r7, #28]
 8012bd8:	687b      	ldr	r3, [r7, #4]
 8012bda:	681b      	ldr	r3, [r3, #0]
 8012bdc:	330c      	adds	r3, #12
 8012bde:	69fa      	ldr	r2, [r7, #28]
 8012be0:	61ba      	str	r2, [r7, #24]
 8012be2:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012be4:	6979      	ldr	r1, [r7, #20]
 8012be6:	69ba      	ldr	r2, [r7, #24]
 8012be8:	e841 2300 	strex	r3, r2, [r1]
 8012bec:	613b      	str	r3, [r7, #16]
   return(result);
 8012bee:	693b      	ldr	r3, [r7, #16]
 8012bf0:	2b00      	cmp	r3, #0
 8012bf2:	d1e5      	bne.n	8012bc0 <UART_EndTxTransfer+0x8>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8012bf4:	687b      	ldr	r3, [r7, #4]
 8012bf6:	2220      	movs	r2, #32
 8012bf8:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
}
 8012bfc:	bf00      	nop
 8012bfe:	3724      	adds	r7, #36	@ 0x24
 8012c00:	46bd      	mov	sp, r7
 8012c02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012c06:	4770      	bx	lr

08012c08 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8012c08:	b480      	push	{r7}
 8012c0a:	b095      	sub	sp, #84	@ 0x54
 8012c0c:	af00      	add	r7, sp, #0
 8012c0e:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8012c10:	687b      	ldr	r3, [r7, #4]
 8012c12:	681b      	ldr	r3, [r3, #0]
 8012c14:	330c      	adds	r3, #12
 8012c16:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012c18:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8012c1a:	e853 3f00 	ldrex	r3, [r3]
 8012c1e:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 8012c20:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8012c22:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 8012c26:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8012c28:	687b      	ldr	r3, [r7, #4]
 8012c2a:	681b      	ldr	r3, [r3, #0]
 8012c2c:	330c      	adds	r3, #12
 8012c2e:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8012c30:	643a      	str	r2, [r7, #64]	@ 0x40
 8012c32:	63fb      	str	r3, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012c34:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 8012c36:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 8012c38:	e841 2300 	strex	r3, r2, [r1]
 8012c3c:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
 8012c3e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8012c40:	2b00      	cmp	r3, #0
 8012c42:	d1e5      	bne.n	8012c10 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8012c44:	687b      	ldr	r3, [r7, #4]
 8012c46:	681b      	ldr	r3, [r3, #0]
 8012c48:	3314      	adds	r3, #20
 8012c4a:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012c4c:	6a3b      	ldr	r3, [r7, #32]
 8012c4e:	e853 3f00 	ldrex	r3, [r3]
 8012c52:	61fb      	str	r3, [r7, #28]
   return(result);
 8012c54:	69fb      	ldr	r3, [r7, #28]
 8012c56:	f023 0301 	bic.w	r3, r3, #1
 8012c5a:	64bb      	str	r3, [r7, #72]	@ 0x48
 8012c5c:	687b      	ldr	r3, [r7, #4]
 8012c5e:	681b      	ldr	r3, [r3, #0]
 8012c60:	3314      	adds	r3, #20
 8012c62:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8012c64:	62fa      	str	r2, [r7, #44]	@ 0x2c
 8012c66:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012c68:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8012c6a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8012c6c:	e841 2300 	strex	r3, r2, [r1]
 8012c70:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 8012c72:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8012c74:	2b00      	cmp	r3, #0
 8012c76:	d1e5      	bne.n	8012c44 <UART_EndRxTransfer+0x3c>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8012c78:	687b      	ldr	r3, [r7, #4]
 8012c7a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012c7c:	2b01      	cmp	r3, #1
 8012c7e:	d119      	bne.n	8012cb4 <UART_EndRxTransfer+0xac>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8012c80:	687b      	ldr	r3, [r7, #4]
 8012c82:	681b      	ldr	r3, [r3, #0]
 8012c84:	330c      	adds	r3, #12
 8012c86:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012c88:	68fb      	ldr	r3, [r7, #12]
 8012c8a:	e853 3f00 	ldrex	r3, [r3]
 8012c8e:	60bb      	str	r3, [r7, #8]
   return(result);
 8012c90:	68bb      	ldr	r3, [r7, #8]
 8012c92:	f023 0310 	bic.w	r3, r3, #16
 8012c96:	647b      	str	r3, [r7, #68]	@ 0x44
 8012c98:	687b      	ldr	r3, [r7, #4]
 8012c9a:	681b      	ldr	r3, [r3, #0]
 8012c9c:	330c      	adds	r3, #12
 8012c9e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 8012ca0:	61ba      	str	r2, [r7, #24]
 8012ca2:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012ca4:	6979      	ldr	r1, [r7, #20]
 8012ca6:	69ba      	ldr	r2, [r7, #24]
 8012ca8:	e841 2300 	strex	r3, r2, [r1]
 8012cac:	613b      	str	r3, [r7, #16]
   return(result);
 8012cae:	693b      	ldr	r3, [r7, #16]
 8012cb0:	2b00      	cmp	r3, #0
 8012cb2:	d1e5      	bne.n	8012c80 <UART_EndRxTransfer+0x78>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8012cb4:	687b      	ldr	r3, [r7, #4]
 8012cb6:	2220      	movs	r2, #32
 8012cb8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8012cbc:	687b      	ldr	r3, [r7, #4]
 8012cbe:	2200      	movs	r2, #0
 8012cc0:	631a      	str	r2, [r3, #48]	@ 0x30
}
 8012cc2:	bf00      	nop
 8012cc4:	3754      	adds	r7, #84	@ 0x54
 8012cc6:	46bd      	mov	sp, r7
 8012cc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ccc:	4770      	bx	lr

08012cce <UART_DMAAbortOnError>:
  * @param  hdma  Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA module.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8012cce:	b580      	push	{r7, lr}
 8012cd0:	b084      	sub	sp, #16
 8012cd2:	af00      	add	r7, sp, #0
 8012cd4:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8012cd6:	687b      	ldr	r3, [r7, #4]
 8012cd8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8012cda:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0x00U;
 8012cdc:	68fb      	ldr	r3, [r7, #12]
 8012cde:	2200      	movs	r2, #0
 8012ce0:	85da      	strh	r2, [r3, #46]	@ 0x2e
  huart->TxXferCount = 0x00U;
 8012ce2:	68fb      	ldr	r3, [r7, #12]
 8012ce4:	2200      	movs	r2, #0
 8012ce6:	84da      	strh	r2, [r3, #38]	@ 0x26
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 8012ce8:	68f8      	ldr	r0, [r7, #12]
 8012cea:	f7ff fd5d 	bl	80127a8 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 8012cee:	bf00      	nop
 8012cf0:	3710      	adds	r7, #16
 8012cf2:	46bd      	mov	sp, r7
 8012cf4:	bd80      	pop	{r7, pc}

08012cf6 <UART_Transmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
 8012cf6:	b480      	push	{r7}
 8012cf8:	b085      	sub	sp, #20
 8012cfa:	af00      	add	r7, sp, #0
 8012cfc:	6078      	str	r0, [r7, #4]
  const uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8012cfe:	687b      	ldr	r3, [r7, #4]
 8012d00:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8012d04:	b2db      	uxtb	r3, r3
 8012d06:	2b21      	cmp	r3, #33	@ 0x21
 8012d08:	d13e      	bne.n	8012d88 <UART_Transmit_IT+0x92>
  {
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8012d0a:	687b      	ldr	r3, [r7, #4]
 8012d0c:	689b      	ldr	r3, [r3, #8]
 8012d0e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8012d12:	d114      	bne.n	8012d3e <UART_Transmit_IT+0x48>
 8012d14:	687b      	ldr	r3, [r7, #4]
 8012d16:	691b      	ldr	r3, [r3, #16]
 8012d18:	2b00      	cmp	r3, #0
 8012d1a:	d110      	bne.n	8012d3e <UART_Transmit_IT+0x48>
    {
      tmp = (const uint16_t *) huart->pTxBuffPtr;
 8012d1c:	687b      	ldr	r3, [r7, #4]
 8012d1e:	6a1b      	ldr	r3, [r3, #32]
 8012d20:	60fb      	str	r3, [r7, #12]
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 8012d22:	68fb      	ldr	r3, [r7, #12]
 8012d24:	881b      	ldrh	r3, [r3, #0]
 8012d26:	461a      	mov	r2, r3
 8012d28:	687b      	ldr	r3, [r7, #4]
 8012d2a:	681b      	ldr	r3, [r3, #0]
 8012d2c:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8012d30:	605a      	str	r2, [r3, #4]
      huart->pTxBuffPtr += 2U;
 8012d32:	687b      	ldr	r3, [r7, #4]
 8012d34:	6a1b      	ldr	r3, [r3, #32]
 8012d36:	1c9a      	adds	r2, r3, #2
 8012d38:	687b      	ldr	r3, [r7, #4]
 8012d3a:	621a      	str	r2, [r3, #32]
 8012d3c:	e008      	b.n	8012d50 <UART_Transmit_IT+0x5a>
    }
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 8012d3e:	687b      	ldr	r3, [r7, #4]
 8012d40:	6a1b      	ldr	r3, [r3, #32]
 8012d42:	1c59      	adds	r1, r3, #1
 8012d44:	687a      	ldr	r2, [r7, #4]
 8012d46:	6211      	str	r1, [r2, #32]
 8012d48:	781a      	ldrb	r2, [r3, #0]
 8012d4a:	687b      	ldr	r3, [r7, #4]
 8012d4c:	681b      	ldr	r3, [r3, #0]
 8012d4e:	605a      	str	r2, [r3, #4]
    }

    if (--huart->TxXferCount == 0U)
 8012d50:	687b      	ldr	r3, [r7, #4]
 8012d52:	8cdb      	ldrh	r3, [r3, #38]	@ 0x26
 8012d54:	b29b      	uxth	r3, r3
 8012d56:	3b01      	subs	r3, #1
 8012d58:	b29b      	uxth	r3, r3
 8012d5a:	687a      	ldr	r2, [r7, #4]
 8012d5c:	4619      	mov	r1, r3
 8012d5e:	84d1      	strh	r1, [r2, #38]	@ 0x26
 8012d60:	2b00      	cmp	r3, #0
 8012d62:	d10f      	bne.n	8012d84 <UART_Transmit_IT+0x8e>
    {
      /* Disable the UART Transmit Data Register Empty Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 8012d64:	687b      	ldr	r3, [r7, #4]
 8012d66:	681b      	ldr	r3, [r3, #0]
 8012d68:	68da      	ldr	r2, [r3, #12]
 8012d6a:	687b      	ldr	r3, [r7, #4]
 8012d6c:	681b      	ldr	r3, [r3, #0]
 8012d6e:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8012d72:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 8012d74:	687b      	ldr	r3, [r7, #4]
 8012d76:	681b      	ldr	r3, [r3, #0]
 8012d78:	68da      	ldr	r2, [r3, #12]
 8012d7a:	687b      	ldr	r3, [r7, #4]
 8012d7c:	681b      	ldr	r3, [r3, #0]
 8012d7e:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8012d82:	60da      	str	r2, [r3, #12]
    }
    return HAL_OK;
 8012d84:	2300      	movs	r3, #0
 8012d86:	e000      	b.n	8012d8a <UART_Transmit_IT+0x94>
  }
  else
  {
    return HAL_BUSY;
 8012d88:	2302      	movs	r3, #2
  }
}
 8012d8a:	4618      	mov	r0, r3
 8012d8c:	3714      	adds	r7, #20
 8012d8e:	46bd      	mov	sp, r7
 8012d90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012d94:	4770      	bx	lr

08012d96 <UART_EndTransmit_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 8012d96:	b580      	push	{r7, lr}
 8012d98:	b082      	sub	sp, #8
 8012d9a:	af00      	add	r7, sp, #0
 8012d9c:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8012d9e:	687b      	ldr	r3, [r7, #4]
 8012da0:	681b      	ldr	r3, [r3, #0]
 8012da2:	68da      	ldr	r2, [r3, #12]
 8012da4:	687b      	ldr	r3, [r7, #4]
 8012da6:	681b      	ldr	r3, [r3, #0]
 8012da8:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8012dac:	60da      	str	r2, [r3, #12]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8012dae:	687b      	ldr	r3, [r7, #4]
 8012db0:	2220      	movs	r2, #32
 8012db2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 8012db6:	6878      	ldr	r0, [r7, #4]
 8012db8:	f7ff fcd8 	bl	801276c <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */

  return HAL_OK;
 8012dbc:	2300      	movs	r3, #0
}
 8012dbe:	4618      	mov	r0, r3
 8012dc0:	3708      	adds	r7, #8
 8012dc2:	46bd      	mov	sp, r7
 8012dc4:	bd80      	pop	{r7, pc}

08012dc6 <UART_Receive_IT>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 8012dc6:	b580      	push	{r7, lr}
 8012dc8:	b08c      	sub	sp, #48	@ 0x30
 8012dca:	af00      	add	r7, sp, #0
 8012dcc:	6078      	str	r0, [r7, #4]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8012dce:	687b      	ldr	r3, [r7, #4]
 8012dd0:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8012dd4:	b2db      	uxtb	r3, r3
 8012dd6:	2b22      	cmp	r3, #34	@ 0x22
 8012dd8:	f040 80ae 	bne.w	8012f38 <UART_Receive_IT+0x172>
  {
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8012ddc:	687b      	ldr	r3, [r7, #4]
 8012dde:	689b      	ldr	r3, [r3, #8]
 8012de0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8012de4:	d117      	bne.n	8012e16 <UART_Receive_IT+0x50>
 8012de6:	687b      	ldr	r3, [r7, #4]
 8012de8:	691b      	ldr	r3, [r3, #16]
 8012dea:	2b00      	cmp	r3, #0
 8012dec:	d113      	bne.n	8012e16 <UART_Receive_IT+0x50>
    {
      pdata8bits  = NULL;
 8012dee:	2300      	movs	r3, #0
 8012df0:	62fb      	str	r3, [r7, #44]	@ 0x2c
      pdata16bits = (uint16_t *) huart->pRxBuffPtr;
 8012df2:	687b      	ldr	r3, [r7, #4]
 8012df4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012df6:	62bb      	str	r3, [r7, #40]	@ 0x28
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8012df8:	687b      	ldr	r3, [r7, #4]
 8012dfa:	681b      	ldr	r3, [r3, #0]
 8012dfc:	685b      	ldr	r3, [r3, #4]
 8012dfe:	b29b      	uxth	r3, r3
 8012e00:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8012e04:	b29a      	uxth	r2, r3
 8012e06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8012e08:	801a      	strh	r2, [r3, #0]
      huart->pRxBuffPtr += 2U;
 8012e0a:	687b      	ldr	r3, [r7, #4]
 8012e0c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012e0e:	1c9a      	adds	r2, r3, #2
 8012e10:	687b      	ldr	r3, [r7, #4]
 8012e12:	629a      	str	r2, [r3, #40]	@ 0x28
 8012e14:	e026      	b.n	8012e64 <UART_Receive_IT+0x9e>
    }
    else
    {
      pdata8bits = (uint8_t *) huart->pRxBuffPtr;
 8012e16:	687b      	ldr	r3, [r7, #4]
 8012e18:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012e1a:	62fb      	str	r3, [r7, #44]	@ 0x2c
      pdata16bits  = NULL;
 8012e1c:	2300      	movs	r3, #0
 8012e1e:	62bb      	str	r3, [r7, #40]	@ 0x28

      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8012e20:	687b      	ldr	r3, [r7, #4]
 8012e22:	689b      	ldr	r3, [r3, #8]
 8012e24:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8012e28:	d007      	beq.n	8012e3a <UART_Receive_IT+0x74>
 8012e2a:	687b      	ldr	r3, [r7, #4]
 8012e2c:	689b      	ldr	r3, [r3, #8]
 8012e2e:	2b00      	cmp	r3, #0
 8012e30:	d10a      	bne.n	8012e48 <UART_Receive_IT+0x82>
 8012e32:	687b      	ldr	r3, [r7, #4]
 8012e34:	691b      	ldr	r3, [r3, #16]
 8012e36:	2b00      	cmp	r3, #0
 8012e38:	d106      	bne.n	8012e48 <UART_Receive_IT+0x82>
      {
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8012e3a:	687b      	ldr	r3, [r7, #4]
 8012e3c:	681b      	ldr	r3, [r3, #0]
 8012e3e:	685b      	ldr	r3, [r3, #4]
 8012e40:	b2da      	uxtb	r2, r3
 8012e42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012e44:	701a      	strb	r2, [r3, #0]
 8012e46:	e008      	b.n	8012e5a <UART_Receive_IT+0x94>
      }
      else
      {
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8012e48:	687b      	ldr	r3, [r7, #4]
 8012e4a:	681b      	ldr	r3, [r3, #0]
 8012e4c:	685b      	ldr	r3, [r3, #4]
 8012e4e:	b2db      	uxtb	r3, r3
 8012e50:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8012e54:	b2da      	uxtb	r2, r3
 8012e56:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8012e58:	701a      	strb	r2, [r3, #0]
      }
      huart->pRxBuffPtr += 1U;
 8012e5a:	687b      	ldr	r3, [r7, #4]
 8012e5c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8012e5e:	1c5a      	adds	r2, r3, #1
 8012e60:	687b      	ldr	r3, [r7, #4]
 8012e62:	629a      	str	r2, [r3, #40]	@ 0x28
    }

    if (--huart->RxXferCount == 0U)
 8012e64:	687b      	ldr	r3, [r7, #4]
 8012e66:	8ddb      	ldrh	r3, [r3, #46]	@ 0x2e
 8012e68:	b29b      	uxth	r3, r3
 8012e6a:	3b01      	subs	r3, #1
 8012e6c:	b29b      	uxth	r3, r3
 8012e6e:	687a      	ldr	r2, [r7, #4]
 8012e70:	4619      	mov	r1, r3
 8012e72:	85d1      	strh	r1, [r2, #46]	@ 0x2e
 8012e74:	2b00      	cmp	r3, #0
 8012e76:	d15d      	bne.n	8012f34 <UART_Receive_IT+0x16e>
    {
      /* Disable the UART Data Register not empty Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8012e78:	687b      	ldr	r3, [r7, #4]
 8012e7a:	681b      	ldr	r3, [r3, #0]
 8012e7c:	68da      	ldr	r2, [r3, #12]
 8012e7e:	687b      	ldr	r3, [r7, #4]
 8012e80:	681b      	ldr	r3, [r3, #0]
 8012e82:	f022 0220 	bic.w	r2, r2, #32
 8012e86:	60da      	str	r2, [r3, #12]

      /* Disable the UART Parity Error Interrupt */
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8012e88:	687b      	ldr	r3, [r7, #4]
 8012e8a:	681b      	ldr	r3, [r3, #0]
 8012e8c:	68da      	ldr	r2, [r3, #12]
 8012e8e:	687b      	ldr	r3, [r7, #4]
 8012e90:	681b      	ldr	r3, [r3, #0]
 8012e92:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8012e96:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8012e98:	687b      	ldr	r3, [r7, #4]
 8012e9a:	681b      	ldr	r3, [r3, #0]
 8012e9c:	695a      	ldr	r2, [r3, #20]
 8012e9e:	687b      	ldr	r3, [r7, #4]
 8012ea0:	681b      	ldr	r3, [r3, #0]
 8012ea2:	f022 0201 	bic.w	r2, r2, #1
 8012ea6:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8012ea8:	687b      	ldr	r3, [r7, #4]
 8012eaa:	2220      	movs	r2, #32
 8012eac:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

      /* Initialize type of RxEvent to Transfer Complete */
      huart->RxEventType = HAL_UART_RXEVENT_TC;
 8012eb0:	687b      	ldr	r3, [r7, #4]
 8012eb2:	2200      	movs	r2, #0
 8012eb4:	635a      	str	r2, [r3, #52]	@ 0x34

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8012eb6:	687b      	ldr	r3, [r7, #4]
 8012eb8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8012eba:	2b01      	cmp	r3, #1
 8012ebc:	d135      	bne.n	8012f2a <UART_Receive_IT+0x164>
      {
        /* Set reception type to Standard */
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8012ebe:	687b      	ldr	r3, [r7, #4]
 8012ec0:	2200      	movs	r2, #0
 8012ec2:	631a      	str	r2, [r3, #48]	@ 0x30

        /* Disable IDLE interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8012ec4:	687b      	ldr	r3, [r7, #4]
 8012ec6:	681b      	ldr	r3, [r3, #0]
 8012ec8:	330c      	adds	r3, #12
 8012eca:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8012ecc:	697b      	ldr	r3, [r7, #20]
 8012ece:	e853 3f00 	ldrex	r3, [r3]
 8012ed2:	613b      	str	r3, [r7, #16]
   return(result);
 8012ed4:	693b      	ldr	r3, [r7, #16]
 8012ed6:	f023 0310 	bic.w	r3, r3, #16
 8012eda:	627b      	str	r3, [r7, #36]	@ 0x24
 8012edc:	687b      	ldr	r3, [r7, #4]
 8012ede:	681b      	ldr	r3, [r3, #0]
 8012ee0:	330c      	adds	r3, #12
 8012ee2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8012ee4:	623a      	str	r2, [r7, #32]
 8012ee6:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8012ee8:	69f9      	ldr	r1, [r7, #28]
 8012eea:	6a3a      	ldr	r2, [r7, #32]
 8012eec:	e841 2300 	strex	r3, r2, [r1]
 8012ef0:	61bb      	str	r3, [r7, #24]
   return(result);
 8012ef2:	69bb      	ldr	r3, [r7, #24]
 8012ef4:	2b00      	cmp	r3, #0
 8012ef6:	d1e5      	bne.n	8012ec4 <UART_Receive_IT+0xfe>

        /* Check if IDLE flag is set */
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_IDLE))
 8012ef8:	687b      	ldr	r3, [r7, #4]
 8012efa:	681b      	ldr	r3, [r3, #0]
 8012efc:	681b      	ldr	r3, [r3, #0]
 8012efe:	f003 0310 	and.w	r3, r3, #16
 8012f02:	2b10      	cmp	r3, #16
 8012f04:	d10a      	bne.n	8012f1c <UART_Receive_IT+0x156>
        {
          /* Clear IDLE flag in ISR */
          __HAL_UART_CLEAR_IDLEFLAG(huart);
 8012f06:	2300      	movs	r3, #0
 8012f08:	60fb      	str	r3, [r7, #12]
 8012f0a:	687b      	ldr	r3, [r7, #4]
 8012f0c:	681b      	ldr	r3, [r3, #0]
 8012f0e:	681b      	ldr	r3, [r3, #0]
 8012f10:	60fb      	str	r3, [r7, #12]
 8012f12:	687b      	ldr	r3, [r7, #4]
 8012f14:	681b      	ldr	r3, [r3, #0]
 8012f16:	685b      	ldr	r3, [r3, #4]
 8012f18:	60fb      	str	r3, [r7, #12]
 8012f1a:	68fb      	ldr	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 8012f1c:	687b      	ldr	r3, [r7, #4]
 8012f1e:	8d9b      	ldrh	r3, [r3, #44]	@ 0x2c
 8012f20:	4619      	mov	r1, r3
 8012f22:	6878      	ldr	r0, [r7, #4]
 8012f24:	f7ff fc4a 	bl	80127bc <HAL_UARTEx_RxEventCallback>
 8012f28:	e002      	b.n	8012f30 <UART_Receive_IT+0x16a>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxCpltCallback(huart);
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
 8012f2a:	6878      	ldr	r0, [r7, #4]
 8012f2c:	f7ff fc28 	bl	8012780 <HAL_UART_RxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }

      return HAL_OK;
 8012f30:	2300      	movs	r3, #0
 8012f32:	e002      	b.n	8012f3a <UART_Receive_IT+0x174>
    }
    return HAL_OK;
 8012f34:	2300      	movs	r3, #0
 8012f36:	e000      	b.n	8012f3a <UART_Receive_IT+0x174>
  }
  else
  {
    return HAL_BUSY;
 8012f38:	2302      	movs	r3, #2
  }
}
 8012f3a:	4618      	mov	r0, r3
 8012f3c:	3730      	adds	r7, #48	@ 0x30
 8012f3e:	46bd      	mov	sp, r7
 8012f40:	bd80      	pop	{r7, pc}

08012f42 <SDIO_Init>:
  * @param  SDIOx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
{
 8012f42:	b084      	sub	sp, #16
 8012f44:	b480      	push	{r7}
 8012f46:	b085      	sub	sp, #20
 8012f48:	af00      	add	r7, sp, #0
 8012f4a:	6078      	str	r0, [r7, #4]
 8012f4c:	f107 001c 	add.w	r0, r7, #28
 8012f50:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0;
 8012f54:	2300      	movs	r3, #0
 8012f56:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
  
  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
 8012f58:	69fa      	ldr	r2, [r7, #28]
             Init.ClockBypass         |\
 8012f5a:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           |\
 8012f5c:	431a      	orrs	r2, r3
             Init.ClockPowerSave      |\
 8012f5e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
             Init.ClockBypass         |\
 8012f60:	431a      	orrs	r2, r3
             Init.BusWide             |\
 8012f62:	6abb      	ldr	r3, [r7, #40]	@ 0x28
             Init.ClockPowerSave      |\
 8012f64:	431a      	orrs	r2, r3
             Init.HardwareFlowControl |\
 8012f66:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
             Init.BusWide             |\
 8012f68:	431a      	orrs	r2, r3
             Init.ClockDiv
 8012f6a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
             Init.HardwareFlowControl |\
 8012f6c:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           |\
 8012f6e:	68fa      	ldr	r2, [r7, #12]
 8012f70:	4313      	orrs	r3, r2
 8012f72:	60fb      	str	r3, [r7, #12]
             ); 
  
  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
 8012f74:	687b      	ldr	r3, [r7, #4]
 8012f76:	685b      	ldr	r3, [r3, #4]
 8012f78:	f423 43fd 	bic.w	r3, r3, #32384	@ 0x7e80
 8012f7c:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 8012f80:	68fa      	ldr	r2, [r7, #12]
 8012f82:	431a      	orrs	r2, r3
 8012f84:	687b      	ldr	r3, [r7, #4]
 8012f86:	605a      	str	r2, [r3, #4]

  return HAL_OK;
 8012f88:	2300      	movs	r3, #0
}
 8012f8a:	4618      	mov	r0, r3
 8012f8c:	3714      	adds	r7, #20
 8012f8e:	46bd      	mov	sp, r7
 8012f90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012f94:	b004      	add	sp, #16
 8012f96:	4770      	bx	lr

08012f98 <SDIO_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling) 
  * @param  SDIOx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDIO_ReadFIFO(SDIO_TypeDef *SDIOx)
{
 8012f98:	b480      	push	{r7}
 8012f9a:	b083      	sub	sp, #12
 8012f9c:	af00      	add	r7, sp, #0
 8012f9e:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */ 
  return (SDIOx->FIFO);
 8012fa0:	687b      	ldr	r3, [r7, #4]
 8012fa2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
}
 8012fa6:	4618      	mov	r0, r3
 8012fa8:	370c      	adds	r7, #12
 8012faa:	46bd      	mov	sp, r7
 8012fac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012fb0:	4770      	bx	lr

08012fb2 <SDIO_WriteFIFO>:
  * @param  SDIOx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
{ 
 8012fb2:	b480      	push	{r7}
 8012fb4:	b083      	sub	sp, #12
 8012fb6:	af00      	add	r7, sp, #0
 8012fb8:	6078      	str	r0, [r7, #4]
 8012fba:	6039      	str	r1, [r7, #0]
  /* Write data to FIFO */ 
  SDIOx->FIFO = *pWriteData;
 8012fbc:	683b      	ldr	r3, [r7, #0]
 8012fbe:	681a      	ldr	r2, [r3, #0]
 8012fc0:	687b      	ldr	r3, [r7, #4]
 8012fc2:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80

  return HAL_OK;
 8012fc6:	2300      	movs	r3, #0
}
 8012fc8:	4618      	mov	r0, r3
 8012fca:	370c      	adds	r7, #12
 8012fcc:	46bd      	mov	sp, r7
 8012fce:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012fd2:	4770      	bx	lr

08012fd4 <SDIO_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON. 
  * @param  SDIOx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
{  
 8012fd4:	b480      	push	{r7}
 8012fd6:	b083      	sub	sp, #12
 8012fd8:	af00      	add	r7, sp, #0
 8012fda:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */ 
  SDIOx->POWER = SDIO_POWER_PWRCTRL;
 8012fdc:	687b      	ldr	r3, [r7, #4]
 8012fde:	2203      	movs	r2, #3
 8012fe0:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8012fe2:	2300      	movs	r3, #0
}
 8012fe4:	4618      	mov	r0, r3
 8012fe6:	370c      	adds	r7, #12
 8012fe8:	46bd      	mov	sp, r7
 8012fea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012fee:	4770      	bx	lr

08012ff0 <SDIO_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
{
 8012ff0:	b480      	push	{r7}
 8012ff2:	b083      	sub	sp, #12
 8012ff4:	af00      	add	r7, sp, #0
 8012ff6:	6078      	str	r0, [r7, #4]
  return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
 8012ff8:	687b      	ldr	r3, [r7, #4]
 8012ffa:	681b      	ldr	r3, [r3, #0]
 8012ffc:	f003 0303 	and.w	r3, r3, #3
}
 8013000:	4618      	mov	r0, r3
 8013002:	370c      	adds	r7, #12
 8013004:	46bd      	mov	sp, r7
 8013006:	f85d 7b04 	ldr.w	r7, [sp], #4
 801300a:	4770      	bx	lr

0801300c <SDIO_SendCommand>:
  * @param  Command: pointer to a SDIO_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *Command)
{
 801300c:	b480      	push	{r7}
 801300e:	b085      	sub	sp, #20
 8013010:	af00      	add	r7, sp, #0
 8013012:	6078      	str	r0, [r7, #4]
 8013014:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8013016:	2300      	movs	r3, #0
 8013018:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_RESPONSE(Command->Response));
  assert_param(IS_SDIO_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDIO_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDIOx->ARG = Command->Argument;
 801301a:	683b      	ldr	r3, [r7, #0]
 801301c:	681a      	ldr	r2, [r3, #0]
 801301e:	687b      	ldr	r3, [r7, #4]
 8013020:	609a      	str	r2, [r3, #8]

  /* Set SDMMC command parameters */
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
 8013022:	683b      	ldr	r3, [r7, #0]
 8013024:	685a      	ldr	r2, [r3, #4]
                       Command->Response         |\
 8013026:	683b      	ldr	r3, [r7, #0]
 8013028:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
 801302a:	431a      	orrs	r2, r3
                       Command->WaitForInterrupt |\
 801302c:	683b      	ldr	r3, [r7, #0]
 801302e:	68db      	ldr	r3, [r3, #12]
                       Command->Response         |\
 8013030:	431a      	orrs	r2, r3
                       Command->CPSM);
 8013032:	683b      	ldr	r3, [r7, #0]
 8013034:	691b      	ldr	r3, [r3, #16]
                       Command->WaitForInterrupt |\
 8013036:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
 8013038:	68fa      	ldr	r2, [r7, #12]
 801303a:	4313      	orrs	r3, r2
 801303c:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDMMC CMD register */
  MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
 801303e:	687b      	ldr	r3, [r7, #4]
 8013040:	68db      	ldr	r3, [r3, #12]
 8013042:	f423 637f 	bic.w	r3, r3, #4080	@ 0xff0
 8013046:	f023 030f 	bic.w	r3, r3, #15
 801304a:	68fa      	ldr	r2, [r7, #12]
 801304c:	431a      	orrs	r2, r3
 801304e:	687b      	ldr	r3, [r7, #4]
 8013050:	60da      	str	r2, [r3, #12]
  
  return HAL_OK;  
 8013052:	2300      	movs	r3, #0
}
 8013054:	4618      	mov	r0, r3
 8013056:	3714      	adds	r7, #20
 8013058:	46bd      	mov	sp, r7
 801305a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801305e:	4770      	bx	lr

08013060 <SDIO_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDIOx: Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
{
 8013060:	b480      	push	{r7}
 8013062:	b083      	sub	sp, #12
 8013064:	af00      	add	r7, sp, #0
 8013066:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDIOx->RESPCMD);
 8013068:	687b      	ldr	r3, [r7, #4]
 801306a:	691b      	ldr	r3, [r3, #16]
 801306c:	b2db      	uxtb	r3, r3
}
 801306e:	4618      	mov	r0, r3
 8013070:	370c      	adds	r7, #12
 8013072:	46bd      	mov	sp, r7
 8013074:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013078:	4770      	bx	lr

0801307a <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDIO_GetResponse(SDIO_TypeDef *SDIOx, uint32_t Response)
{
 801307a:	b480      	push	{r7}
 801307c:	b085      	sub	sp, #20
 801307e:	af00      	add	r7, sp, #0
 8013080:	6078      	str	r0, [r7, #4]
 8013082:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(Response));
  
  /* Get the response */
  tmp = (uint32_t)(&(SDIOx->RESP1)) + Response;
 8013084:	687b      	ldr	r3, [r7, #4]
 8013086:	3314      	adds	r3, #20
 8013088:	461a      	mov	r2, r3
 801308a:	683b      	ldr	r3, [r7, #0]
 801308c:	4413      	add	r3, r2
 801308e:	60fb      	str	r3, [r7, #12]
  
  return (*(__IO uint32_t *) tmp);
 8013090:	68fb      	ldr	r3, [r7, #12]
 8013092:	681b      	ldr	r3, [r3, #0]
}  
 8013094:	4618      	mov	r0, r3
 8013096:	3714      	adds	r7, #20
 8013098:	46bd      	mov	sp, r7
 801309a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801309e:	4770      	bx	lr

080130a0 <SDIO_ConfigData>:
  * @param  Data : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDIO_ConfigData(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* Data)
{
 80130a0:	b480      	push	{r7}
 80130a2:	b085      	sub	sp, #20
 80130a4:	af00      	add	r7, sp, #0
 80130a6:	6078      	str	r0, [r7, #4]
 80130a8:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 80130aa:	2300      	movs	r3, #0
 80130ac:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDIO_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDIO_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDIO_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDIOx->DTIMER = Data->DataTimeOut;
 80130ae:	683b      	ldr	r3, [r7, #0]
 80130b0:	681a      	ldr	r2, [r3, #0]
 80130b2:	687b      	ldr	r3, [r7, #4]
 80130b4:	625a      	str	r2, [r3, #36]	@ 0x24

  /* Set the SDMMC DataLength value */
  SDIOx->DLEN = Data->DataLength;
 80130b6:	683b      	ldr	r3, [r7, #0]
 80130b8:	685a      	ldr	r2, [r3, #4]
 80130ba:	687b      	ldr	r3, [r7, #4]
 80130bc:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 80130be:	683b      	ldr	r3, [r7, #0]
 80130c0:	689a      	ldr	r2, [r3, #8]
                       Data->TransferDir   |\
 80130c2:	683b      	ldr	r3, [r7, #0]
 80130c4:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 80130c6:	431a      	orrs	r2, r3
                       Data->TransferMode  |\
 80130c8:	683b      	ldr	r3, [r7, #0]
 80130ca:	691b      	ldr	r3, [r3, #16]
                       Data->TransferDir   |\
 80130cc:	431a      	orrs	r2, r3
                       Data->DPSM);
 80130ce:	683b      	ldr	r3, [r7, #0]
 80130d0:	695b      	ldr	r3, [r3, #20]
                       Data->TransferMode  |\
 80130d2:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 80130d4:	68fa      	ldr	r2, [r7, #12]
 80130d6:	4313      	orrs	r3, r2
 80130d8:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 80130da:	687b      	ldr	r3, [r7, #4]
 80130dc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80130de:	f023 02f7 	bic.w	r2, r3, #247	@ 0xf7
 80130e2:	68fb      	ldr	r3, [r7, #12]
 80130e4:	431a      	orrs	r2, r3
 80130e6:	687b      	ldr	r3, [r7, #4]
 80130e8:	62da      	str	r2, [r3, #44]	@ 0x2c

  return HAL_OK;
 80130ea:	2300      	movs	r3, #0

}
 80130ec:	4618      	mov	r0, r3
 80130ee:	3714      	adds	r7, #20
 80130f0:	46bd      	mov	sp, r7
 80130f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80130f6:	4770      	bx	lr

080130f8 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Length command and check the response
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDIO_TypeDef *SDIOx, uint32_t BlockSize)
{
 80130f8:	b580      	push	{r7, lr}
 80130fa:	b088      	sub	sp, #32
 80130fc:	af00      	add	r7, sp, #0
 80130fe:	6078      	str	r0, [r7, #4]
 8013100:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 8013102:	683b      	ldr	r3, [r7, #0]
 8013104:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 8013106:	2310      	movs	r3, #16
 8013108:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 801310a:	2340      	movs	r3, #64	@ 0x40
 801310c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 801310e:	2300      	movs	r3, #0
 8013110:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8013112:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8013116:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8013118:	f107 0308 	add.w	r3, r7, #8
 801311c:	4619      	mov	r1, r3
 801311e:	6878      	ldr	r0, [r7, #4]
 8013120:	f7ff ff74 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SET_BLOCKLEN, SDIO_CMDTIMEOUT);
 8013124:	f241 3288 	movw	r2, #5000	@ 0x1388
 8013128:	2110      	movs	r1, #16
 801312a:	6878      	ldr	r0, [r7, #4]
 801312c:	f000 fa18 	bl	8013560 <SDMMC_GetCmdResp1>
 8013130:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013132:	69fb      	ldr	r3, [r7, #28]
}
 8013134:	4618      	mov	r0, r3
 8013136:	3720      	adds	r7, #32
 8013138:	46bd      	mov	sp, r7
 801313a:	bd80      	pop	{r7, pc}

0801313c <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDIO_TypeDef *SDIOx, uint32_t ReadAdd)
{
 801313c:	b580      	push	{r7, lr}
 801313e:	b088      	sub	sp, #32
 8013140:	af00      	add	r7, sp, #0
 8013142:	6078      	str	r0, [r7, #4]
 8013144:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 8013146:	683b      	ldr	r3, [r7, #0]
 8013148:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 801314a:	2311      	movs	r3, #17
 801314c:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 801314e:	2340      	movs	r3, #64	@ 0x40
 8013150:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013152:	2300      	movs	r3, #0
 8013154:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8013156:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801315a:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 801315c:	f107 0308 	add.w	r3, r7, #8
 8013160:	4619      	mov	r1, r3
 8013162:	6878      	ldr	r0, [r7, #4]
 8013164:	f7ff ff52 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
 8013168:	f241 3288 	movw	r2, #5000	@ 0x1388
 801316c:	2111      	movs	r1, #17
 801316e:	6878      	ldr	r0, [r7, #4]
 8013170:	f000 f9f6 	bl	8013560 <SDMMC_GetCmdResp1>
 8013174:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013176:	69fb      	ldr	r3, [r7, #28]
}
 8013178:	4618      	mov	r0, r3
 801317a:	3720      	adds	r7, #32
 801317c:	46bd      	mov	sp, r7
 801317e:	bd80      	pop	{r7, pc}

08013180 <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDIO_TypeDef *SDIOx, uint32_t ReadAdd)
{
 8013180:	b580      	push	{r7, lr}
 8013182:	b088      	sub	sp, #32
 8013184:	af00      	add	r7, sp, #0
 8013186:	6078      	str	r0, [r7, #4]
 8013188:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 801318a:	683b      	ldr	r3, [r7, #0]
 801318c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 801318e:	2312      	movs	r3, #18
 8013190:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8013192:	2340      	movs	r3, #64	@ 0x40
 8013194:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013196:	2300      	movs	r3, #0
 8013198:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 801319a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801319e:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80131a0:	f107 0308 	add.w	r3, r7, #8
 80131a4:	4619      	mov	r1, r3
 80131a6:	6878      	ldr	r0, [r7, #4]
 80131a8:	f7ff ff30 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_MULT_BLOCK, SDIO_CMDTIMEOUT);
 80131ac:	f241 3288 	movw	r2, #5000	@ 0x1388
 80131b0:	2112      	movs	r1, #18
 80131b2:	6878      	ldr	r0, [r7, #4]
 80131b4:	f000 f9d4 	bl	8013560 <SDMMC_GetCmdResp1>
 80131b8:	61f8      	str	r0, [r7, #28]

  return errorstate;
 80131ba:	69fb      	ldr	r3, [r7, #28]
}
 80131bc:	4618      	mov	r0, r3
 80131be:	3720      	adds	r7, #32
 80131c0:	46bd      	mov	sp, r7
 80131c2:	bd80      	pop	{r7, pc}

080131c4 <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDIO_TypeDef *SDIOx, uint32_t WriteAdd)
{
 80131c4:	b580      	push	{r7, lr}
 80131c6:	b088      	sub	sp, #32
 80131c8:	af00      	add	r7, sp, #0
 80131ca:	6078      	str	r0, [r7, #4]
 80131cc:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 80131ce:	683b      	ldr	r3, [r7, #0]
 80131d0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 80131d2:	2318      	movs	r3, #24
 80131d4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80131d6:	2340      	movs	r3, #64	@ 0x40
 80131d8:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80131da:	2300      	movs	r3, #0
 80131dc:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80131de:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80131e2:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80131e4:	f107 0308 	add.w	r3, r7, #8
 80131e8:	4619      	mov	r1, r3
 80131ea:	6878      	ldr	r0, [r7, #4]
 80131ec:	f7ff ff0e 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
 80131f0:	f241 3288 	movw	r2, #5000	@ 0x1388
 80131f4:	2118      	movs	r1, #24
 80131f6:	6878      	ldr	r0, [r7, #4]
 80131f8:	f000 f9b2 	bl	8013560 <SDMMC_GetCmdResp1>
 80131fc:	61f8      	str	r0, [r7, #28]

  return errorstate;
 80131fe:	69fb      	ldr	r3, [r7, #28]
}
 8013200:	4618      	mov	r0, r3
 8013202:	3720      	adds	r7, #32
 8013204:	46bd      	mov	sp, r7
 8013206:	bd80      	pop	{r7, pc}

08013208 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDIO_TypeDef *SDIOx, uint32_t WriteAdd)
{
 8013208:	b580      	push	{r7, lr}
 801320a:	b088      	sub	sp, #32
 801320c:	af00      	add	r7, sp, #0
 801320e:	6078      	str	r0, [r7, #4]
 8013210:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 8013212:	683b      	ldr	r3, [r7, #0]
 8013214:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 8013216:	2319      	movs	r3, #25
 8013218:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 801321a:	2340      	movs	r3, #64	@ 0x40
 801321c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 801321e:	2300      	movs	r3, #0
 8013220:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8013222:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8013226:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8013228:	f107 0308 	add.w	r3, r7, #8
 801322c:	4619      	mov	r1, r3
 801322e:	6878      	ldr	r0, [r7, #4]
 8013230:	f7ff feec 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_MULT_BLOCK, SDIO_CMDTIMEOUT);
 8013234:	f241 3288 	movw	r2, #5000	@ 0x1388
 8013238:	2119      	movs	r1, #25
 801323a:	6878      	ldr	r0, [r7, #4]
 801323c:	f000 f990 	bl	8013560 <SDMMC_GetCmdResp1>
 8013240:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013242:	69fb      	ldr	r3, [r7, #28]
}
 8013244:	4618      	mov	r0, r3
 8013246:	3720      	adds	r7, #32
 8013248:	46bd      	mov	sp, r7
 801324a:	bd80      	pop	{r7, pc}

0801324c <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDIO_TypeDef *SDIOx)
{
 801324c:	b580      	push	{r7, lr}
 801324e:	b088      	sub	sp, #32
 8013250:	af00      	add	r7, sp, #0
 8013252:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
 8013254:	2300      	movs	r3, #0
 8013256:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 8013258:	230c      	movs	r3, #12
 801325a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 801325c:	2340      	movs	r3, #64	@ 0x40
 801325e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013260:	2300      	movs	r3, #0
 8013262:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8013264:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8013268:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 801326a:	f107 0308 	add.w	r3, r7, #8
 801326e:	4619      	mov	r1, r3
 8013270:	6878      	ldr	r0, [r7, #4]
 8013272:	f7ff fecb 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_STOP_TRANSMISSION, SDIO_STOPTRANSFERTIMEOUT);
 8013276:	4a05      	ldr	r2, [pc, #20]	@ (801328c <SDMMC_CmdStopTransfer+0x40>)
 8013278:	210c      	movs	r1, #12
 801327a:	6878      	ldr	r0, [r7, #4]
 801327c:	f000 f970 	bl	8013560 <SDMMC_GetCmdResp1>
 8013280:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013282:	69fb      	ldr	r3, [r7, #28]
}
 8013284:	4618      	mov	r0, r3
 8013286:	3720      	adds	r7, #32
 8013288:	46bd      	mov	sp, r7
 801328a:	bd80      	pop	{r7, pc}
 801328c:	05f5e100 	.word	0x05f5e100

08013290 <SDMMC_CmdSelDesel>:
  * @param  SDIOx: Pointer to SDIO register base 
  * @param  addr: Address of the card to be selected  
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDIO_TypeDef *SDIOx, uint64_t Addr)
{
 8013290:	b580      	push	{r7, lr}
 8013292:	b08a      	sub	sp, #40	@ 0x28
 8013294:	af00      	add	r7, sp, #0
 8013296:	60f8      	str	r0, [r7, #12]
 8013298:	e9c7 2300 	strd	r2, r3, [r7]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 801329c:	683b      	ldr	r3, [r7, #0]
 801329e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 80132a0:	2307      	movs	r3, #7
 80132a2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80132a4:	2340      	movs	r3, #64	@ 0x40
 80132a6:	61bb      	str	r3, [r7, #24]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80132a8:	2300      	movs	r3, #0
 80132aa:	61fb      	str	r3, [r7, #28]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80132ac:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80132b0:	623b      	str	r3, [r7, #32]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80132b2:	f107 0310 	add.w	r3, r7, #16
 80132b6:	4619      	mov	r1, r3
 80132b8:	68f8      	ldr	r0, [r7, #12]
 80132ba:	f7ff fea7 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEL_DESEL_CARD, SDIO_CMDTIMEOUT);
 80132be:	f241 3288 	movw	r2, #5000	@ 0x1388
 80132c2:	2107      	movs	r1, #7
 80132c4:	68f8      	ldr	r0, [r7, #12]
 80132c6:	f000 f94b 	bl	8013560 <SDMMC_GetCmdResp1>
 80132ca:	6278      	str	r0, [r7, #36]	@ 0x24

  return errorstate;
 80132cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 80132ce:	4618      	mov	r0, r3
 80132d0:	3728      	adds	r7, #40	@ 0x28
 80132d2:	46bd      	mov	sp, r7
 80132d4:	bd80      	pop	{r7, pc}

080132d6 <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDIO_TypeDef *SDIOx)
{
 80132d6:	b580      	push	{r7, lr}
 80132d8:	b088      	sub	sp, #32
 80132da:	af00      	add	r7, sp, #0
 80132dc:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = 0U;
 80132de:	2300      	movs	r3, #0
 80132e0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 80132e2:	2300      	movs	r3, #0
 80132e4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_NO;
 80132e6:	2300      	movs	r3, #0
 80132e8:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80132ea:	2300      	movs	r3, #0
 80132ec:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80132ee:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80132f2:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80132f4:	f107 0308 	add.w	r3, r7, #8
 80132f8:	4619      	mov	r1, r3
 80132fa:	6878      	ldr	r0, [r7, #4]
 80132fc:	f7ff fe86 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDIOx);
 8013300:	6878      	ldr	r0, [r7, #4]
 8013302:	f000 fb65 	bl	80139d0 <SDMMC_GetCmdError>
 8013306:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013308:	69fb      	ldr	r3, [r7, #28]
}
 801330a:	4618      	mov	r0, r3
 801330c:	3720      	adds	r7, #32
 801330e:	46bd      	mov	sp, r7
 8013310:	bd80      	pop	{r7, pc}

08013312 <SDMMC_CmdOperCond>:
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDIO_TypeDef *SDIOx)
{
 8013312:	b580      	push	{r7, lr}
 8013314:	b088      	sub	sp, #32
 8013316:	af00      	add	r7, sp, #0
 8013318:	6078      	str	r0, [r7, #4]
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
 801331a:	f44f 73d5 	mov.w	r3, #426	@ 0x1aa
 801331e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 8013320:	2308      	movs	r3, #8
 8013322:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8013324:	2340      	movs	r3, #64	@ 0x40
 8013326:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013328:	2300      	movs	r3, #0
 801332a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 801332c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8013330:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8013332:	f107 0308 	add.w	r3, r7, #8
 8013336:	4619      	mov	r1, r3
 8013338:	6878      	ldr	r0, [r7, #4]
 801333a:	f7ff fe67 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp7(SDIOx);
 801333e:	6878      	ldr	r0, [r7, #4]
 8013340:	f000 faf8 	bl	8013934 <SDMMC_GetCmdResp7>
 8013344:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013346:	69fb      	ldr	r3, [r7, #28]
}
 8013348:	4618      	mov	r0, r3
 801334a:	3720      	adds	r7, #32
 801334c:	46bd      	mov	sp, r7
 801334e:	bd80      	pop	{r7, pc}

08013350 <SDMMC_CmdAppCommand>:
  * @param  SDIOx: Pointer to SDIO register base 
  * @param  Argument: Command Argument 
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDIO_TypeDef *SDIOx, uint32_t Argument)
{
 8013350:	b580      	push	{r7, lr}
 8013352:	b088      	sub	sp, #32
 8013354:	af00      	add	r7, sp, #0
 8013356:	6078      	str	r0, [r7, #4]
 8013358:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 801335a:	683b      	ldr	r3, [r7, #0]
 801335c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 801335e:	2337      	movs	r3, #55	@ 0x37
 8013360:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 8013362:	2340      	movs	r3, #64	@ 0x40
 8013364:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013366:	2300      	movs	r3, #0
 8013368:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 801336a:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801336e:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 8013370:	f107 0308 	add.w	r3, r7, #8
 8013374:	4619      	mov	r1, r3
 8013376:	6878      	ldr	r0, [r7, #4]
 8013378:	f7ff fe48 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  /* If there is a HAL_ERROR, it is a MMC card, else
  it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_CMD, SDIO_CMDTIMEOUT);
 801337c:	f241 3288 	movw	r2, #5000	@ 0x1388
 8013380:	2137      	movs	r1, #55	@ 0x37
 8013382:	6878      	ldr	r0, [r7, #4]
 8013384:	f000 f8ec 	bl	8013560 <SDMMC_GetCmdResp1>
 8013388:	61f8      	str	r0, [r7, #28]

  return errorstate;
 801338a:	69fb      	ldr	r3, [r7, #28]
}
 801338c:	4618      	mov	r0, r3
 801338e:	3720      	adds	r7, #32
 8013390:	46bd      	mov	sp, r7
 8013392:	bd80      	pop	{r7, pc}

08013394 <SDMMC_CmdAppOperCommand>:
  * @param  SDIOx: Pointer to SDIO register base 
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDIO_TypeDef *SDIOx, uint32_t Argument)
{
 8013394:	b580      	push	{r7, lr}
 8013396:	b088      	sub	sp, #32
 8013398:	af00      	add	r7, sp, #0
 801339a:	6078      	str	r0, [r7, #4]
 801339c:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 801339e:	683b      	ldr	r3, [r7, #0]
 80133a0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80133a4:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 80133a8:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
 80133aa:	2329      	movs	r3, #41	@ 0x29
 80133ac:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80133ae:	2340      	movs	r3, #64	@ 0x40
 80133b0:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80133b2:	2300      	movs	r3, #0
 80133b4:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80133b6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80133ba:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80133bc:	f107 0308 	add.w	r3, r7, #8
 80133c0:	4619      	mov	r1, r3
 80133c2:	6878      	ldr	r0, [r7, #4]
 80133c4:	f7ff fe22 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDIOx);
 80133c8:	6878      	ldr	r0, [r7, #4]
 80133ca:	f000 f9ff 	bl	80137cc <SDMMC_GetCmdResp3>
 80133ce:	61f8      	str	r0, [r7, #28]

  return errorstate;
 80133d0:	69fb      	ldr	r3, [r7, #28]
}
 80133d2:	4618      	mov	r0, r3
 80133d4:	3720      	adds	r7, #32
 80133d6:	46bd      	mov	sp, r7
 80133d8:	bd80      	pop	{r7, pc}

080133da <SDMMC_CmdBusWidth>:
  * @param  SDIOx: Pointer to SDIO register base 
  * @param  BusWidth: BusWidth
  * @retval HAL status
  */
uint32_t SDMMC_CmdBusWidth(SDIO_TypeDef *SDIOx, uint32_t BusWidth)
{
 80133da:	b580      	push	{r7, lr}
 80133dc:	b088      	sub	sp, #32
 80133de:	af00      	add	r7, sp, #0
 80133e0:	6078      	str	r0, [r7, #4]
 80133e2:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
 80133e4:	683b      	ldr	r3, [r7, #0]
 80133e6:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
 80133e8:	2306      	movs	r3, #6
 80133ea:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80133ec:	2340      	movs	r3, #64	@ 0x40
 80133ee:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80133f0:	2300      	movs	r3, #0
 80133f2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80133f4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80133f8:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80133fa:	f107 0308 	add.w	r3, r7, #8
 80133fe:	4619      	mov	r1, r3
 8013400:	6878      	ldr	r0, [r7, #4]
 8013402:	f7ff fe03 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDIO_CMDTIMEOUT);
 8013406:	f241 3288 	movw	r2, #5000	@ 0x1388
 801340a:	2106      	movs	r1, #6
 801340c:	6878      	ldr	r0, [r7, #4]
 801340e:	f000 f8a7 	bl	8013560 <SDMMC_GetCmdResp1>
 8013412:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013414:	69fb      	ldr	r3, [r7, #28]
}
 8013416:	4618      	mov	r0, r3
 8013418:	3720      	adds	r7, #32
 801341a:	46bd      	mov	sp, r7
 801341c:	bd80      	pop	{r7, pc}

0801341e <SDMMC_CmdSendSCR>:
  * @brief  Send the Send SCR command and check the response.
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDIO_TypeDef *SDIOx)
{
 801341e:	b580      	push	{r7, lr}
 8013420:	b088      	sub	sp, #32
 8013422:	af00      	add	r7, sp, #0
 8013424:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
 8013426:	2300      	movs	r3, #0
 8013428:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
 801342a:	2333      	movs	r3, #51	@ 0x33
 801342c:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 801342e:	2340      	movs	r3, #64	@ 0x40
 8013430:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013432:	2300      	movs	r3, #0
 8013434:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8013436:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801343a:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 801343c:	f107 0308 	add.w	r3, r7, #8
 8013440:	4619      	mov	r1, r3
 8013442:	6878      	ldr	r0, [r7, #4]
 8013444:	f7ff fde2 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_APP_SEND_SCR, SDIO_CMDTIMEOUT);
 8013448:	f241 3288 	movw	r2, #5000	@ 0x1388
 801344c:	2133      	movs	r1, #51	@ 0x33
 801344e:	6878      	ldr	r0, [r7, #4]
 8013450:	f000 f886 	bl	8013560 <SDMMC_GetCmdResp1>
 8013454:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013456:	69fb      	ldr	r3, [r7, #28]
}
 8013458:	4618      	mov	r0, r3
 801345a:	3720      	adds	r7, #32
 801345c:	46bd      	mov	sp, r7
 801345e:	bd80      	pop	{r7, pc}

08013460 <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDIOx: Pointer to SDIO register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDIO_TypeDef *SDIOx)
{
 8013460:	b580      	push	{r7, lr}
 8013462:	b088      	sub	sp, #32
 8013464:	af00      	add	r7, sp, #0
 8013466:	6078      	str	r0, [r7, #4]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
 8013468:	2300      	movs	r3, #0
 801346a:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 801346c:	2302      	movs	r3, #2
 801346e:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
 8013470:	23c0      	movs	r3, #192	@ 0xc0
 8013472:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013474:	2300      	movs	r3, #0
 8013476:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8013478:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801347c:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 801347e:	f107 0308 	add.w	r3, r7, #8
 8013482:	4619      	mov	r1, r3
 8013484:	6878      	ldr	r0, [r7, #4]
 8013486:	f7ff fdc1 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDIOx);
 801348a:	6878      	ldr	r0, [r7, #4]
 801348c:	f000 f956 	bl	801373c <SDMMC_GetCmdResp2>
 8013490:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013492:	69fb      	ldr	r3, [r7, #28]
}
 8013494:	4618      	mov	r0, r3
 8013496:	3720      	adds	r7, #32
 8013498:	46bd      	mov	sp, r7
 801349a:	bd80      	pop	{r7, pc}

0801349c <SDMMC_CmdSendCSD>:
  * @param  SDIOx: Pointer to SDIO register base 
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDIO_TypeDef *SDIOx, uint32_t Argument)
{
 801349c:	b580      	push	{r7, lr}
 801349e:	b088      	sub	sp, #32
 80134a0:	af00      	add	r7, sp, #0
 80134a2:	6078      	str	r0, [r7, #4]
 80134a4:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
 80134a6:	683b      	ldr	r3, [r7, #0]
 80134a8:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 80134aa:	2309      	movs	r3, #9
 80134ac:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
 80134ae:	23c0      	movs	r3, #192	@ 0xc0
 80134b0:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80134b2:	2300      	movs	r3, #0
 80134b4:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80134b6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80134ba:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80134bc:	f107 0308 	add.w	r3, r7, #8
 80134c0:	4619      	mov	r1, r3
 80134c2:	6878      	ldr	r0, [r7, #4]
 80134c4:	f7ff fda2 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDIOx);
 80134c8:	6878      	ldr	r0, [r7, #4]
 80134ca:	f000 f937 	bl	801373c <SDMMC_GetCmdResp2>
 80134ce:	61f8      	str	r0, [r7, #28]

  return errorstate;
 80134d0:	69fb      	ldr	r3, [r7, #28]
}
 80134d2:	4618      	mov	r0, r3
 80134d4:	3720      	adds	r7, #32
 80134d6:	46bd      	mov	sp, r7
 80134d8:	bd80      	pop	{r7, pc}

080134da <SDMMC_CmdSetRelAdd>:
  * @param  SDIOx: Pointer to SDIO register base 
  * @param  pRCA: Card RCA  
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDIO_TypeDef *SDIOx, uint16_t *pRCA)
{
 80134da:	b580      	push	{r7, lr}
 80134dc:	b088      	sub	sp, #32
 80134de:	af00      	add	r7, sp, #0
 80134e0:	6078      	str	r0, [r7, #4]
 80134e2:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
 80134e4:	2300      	movs	r3, #0
 80134e6:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 80134e8:	2303      	movs	r3, #3
 80134ea:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 80134ec:	2340      	movs	r3, #64	@ 0x40
 80134ee:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 80134f0:	2300      	movs	r3, #0
 80134f2:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 80134f4:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80134f8:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 80134fa:	f107 0308 	add.w	r3, r7, #8
 80134fe:	4619      	mov	r1, r3
 8013500:	6878      	ldr	r0, [r7, #4]
 8013502:	f7ff fd83 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp6(SDIOx, SDMMC_CMD_SET_REL_ADDR, pRCA);
 8013506:	683a      	ldr	r2, [r7, #0]
 8013508:	2103      	movs	r1, #3
 801350a:	6878      	ldr	r0, [r7, #4]
 801350c:	f000 f99c 	bl	8013848 <SDMMC_GetCmdResp6>
 8013510:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013512:	69fb      	ldr	r3, [r7, #28]
}
 8013514:	4618      	mov	r0, r3
 8013516:	3720      	adds	r7, #32
 8013518:	46bd      	mov	sp, r7
 801351a:	bd80      	pop	{r7, pc}

0801351c <SDMMC_CmdSendStatus>:
  * @param  SDIOx: Pointer to SDIO register base 
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDIO_TypeDef *SDIOx, uint32_t Argument)
{
 801351c:	b580      	push	{r7, lr}
 801351e:	b088      	sub	sp, #32
 8013520:	af00      	add	r7, sp, #0
 8013522:	6078      	str	r0, [r7, #4]
 8013524:	6039      	str	r1, [r7, #0]
  SDIO_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = Argument;
 8013526:	683b      	ldr	r3, [r7, #0]
 8013528:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 801352a:	230d      	movs	r3, #13
 801352c:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
 801352e:	2340      	movs	r3, #64	@ 0x40
 8013530:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
 8013532:	2300      	movs	r3, #0
 8013534:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
 8013536:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801353a:	61bb      	str	r3, [r7, #24]
  (void)SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
 801353c:	f107 0308 	add.w	r3, r7, #8
 8013540:	4619      	mov	r1, r3
 8013542:	6878      	ldr	r0, [r7, #4]
 8013544:	f7ff fd62 	bl	801300c <SDIO_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEND_STATUS, SDIO_CMDTIMEOUT);
 8013548:	f241 3288 	movw	r2, #5000	@ 0x1388
 801354c:	210d      	movs	r1, #13
 801354e:	6878      	ldr	r0, [r7, #4]
 8013550:	f000 f806 	bl	8013560 <SDMMC_GetCmdResp1>
 8013554:	61f8      	str	r0, [r7, #28]

  return errorstate;
 8013556:	69fb      	ldr	r3, [r7, #28]
}
 8013558:	4618      	mov	r0, r3
 801355a:	3720      	adds	r7, #32
 801355c:	46bd      	mov	sp, r7
 801355e:	bd80      	pop	{r7, pc}

08013560 <SDMMC_GetCmdResp1>:
  * @param  SDIOx Pointer to SDMMC register base
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDIO_TypeDef *SDIOx, uint8_t SD_CMD, uint32_t Timeout)
{
 8013560:	b580      	push	{r7, lr}
 8013562:	b088      	sub	sp, #32
 8013564:	af00      	add	r7, sp, #0
 8013566:	60f8      	str	r0, [r7, #12]
 8013568:	460b      	mov	r3, r1
 801356a:	607a      	str	r2, [r7, #4]
 801356c:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;
  
  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801356e:	4b70      	ldr	r3, [pc, #448]	@ (8013730 <SDMMC_GetCmdResp1+0x1d0>)
 8013570:	681b      	ldr	r3, [r3, #0]
 8013572:	4a70      	ldr	r2, [pc, #448]	@ (8013734 <SDMMC_GetCmdResp1+0x1d4>)
 8013574:	fba2 2303 	umull	r2, r3, r2, r3
 8013578:	0a5a      	lsrs	r2, r3, #9
 801357a:	687b      	ldr	r3, [r7, #4]
 801357c:	fb02 f303 	mul.w	r3, r2, r3
 8013580:	61fb      	str	r3, [r7, #28]
  
  do
  {
    if (count-- == 0U)
 8013582:	69fb      	ldr	r3, [r7, #28]
 8013584:	1e5a      	subs	r2, r3, #1
 8013586:	61fa      	str	r2, [r7, #28]
 8013588:	2b00      	cmp	r3, #0
 801358a:	d102      	bne.n	8013592 <SDMMC_GetCmdResp1+0x32>
    {
      return SDMMC_ERROR_TIMEOUT;
 801358c:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8013590:	e0c9      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
    }
    sta_reg = SDIOx->STA;
 8013592:	68fb      	ldr	r3, [r7, #12]
 8013594:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013596:	61bb      	str	r3, [r7, #24]
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013598:	69bb      	ldr	r3, [r7, #24]
 801359a:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 801359e:	2b00      	cmp	r3, #0
 80135a0:	d0ef      	beq.n	8013582 <SDMMC_GetCmdResp1+0x22>
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 80135a2:	69bb      	ldr	r3, [r7, #24]
 80135a4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 80135a8:	2b00      	cmp	r3, #0
 80135aa:	d1ea      	bne.n	8013582 <SDMMC_GetCmdResp1+0x22>
    
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 80135ac:	68fb      	ldr	r3, [r7, #12]
 80135ae:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80135b0:	f003 0304 	and.w	r3, r3, #4
 80135b4:	2b00      	cmp	r3, #0
 80135b6:	d004      	beq.n	80135c2 <SDMMC_GetCmdResp1+0x62>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 80135b8:	68fb      	ldr	r3, [r7, #12]
 80135ba:	2204      	movs	r2, #4
 80135bc:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80135be:	2304      	movs	r3, #4
 80135c0:	e0b1      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 80135c2:	68fb      	ldr	r3, [r7, #12]
 80135c4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80135c6:	f003 0301 	and.w	r3, r3, #1
 80135ca:	2b00      	cmp	r3, #0
 80135cc:	d004      	beq.n	80135d8 <SDMMC_GetCmdResp1+0x78>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80135ce:	68fb      	ldr	r3, [r7, #12]
 80135d0:	2201      	movs	r2, #1
 80135d2:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80135d4:	2301      	movs	r3, #1
 80135d6:	e0a6      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  {
    /* Nothing to do */
  }
  
  /* Clear all the static flags */
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 80135d8:	68fb      	ldr	r3, [r7, #12]
 80135da:	22c5      	movs	r2, #197	@ 0xc5
 80135dc:	639a      	str	r2, [r3, #56]	@ 0x38
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
 80135de:	68f8      	ldr	r0, [r7, #12]
 80135e0:	f7ff fd3e 	bl	8013060 <SDIO_GetCommandResponse>
 80135e4:	4603      	mov	r3, r0
 80135e6:	461a      	mov	r2, r3
 80135e8:	7afb      	ldrb	r3, [r7, #11]
 80135ea:	4293      	cmp	r3, r2
 80135ec:	d001      	beq.n	80135f2 <SDMMC_GetCmdResp1+0x92>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80135ee:	2301      	movs	r3, #1
 80135f0:	e099      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
 80135f2:	2100      	movs	r1, #0
 80135f4:	68f8      	ldr	r0, [r7, #12]
 80135f6:	f7ff fd40 	bl	801307a <SDIO_GetResponse>
 80135fa:	6178      	str	r0, [r7, #20]
  
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 80135fc:	697a      	ldr	r2, [r7, #20]
 80135fe:	4b4e      	ldr	r3, [pc, #312]	@ (8013738 <SDMMC_GetCmdResp1+0x1d8>)
 8013600:	4013      	ands	r3, r2
 8013602:	2b00      	cmp	r3, #0
 8013604:	d101      	bne.n	801360a <SDMMC_GetCmdResp1+0xaa>
  {
    return SDMMC_ERROR_NONE;
 8013606:	2300      	movs	r3, #0
 8013608:	e08d      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 801360a:	697b      	ldr	r3, [r7, #20]
 801360c:	2b00      	cmp	r3, #0
 801360e:	da02      	bge.n	8013616 <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8013610:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8013614:	e087      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8013616:	697b      	ldr	r3, [r7, #20]
 8013618:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
 801361c:	2b00      	cmp	r3, #0
 801361e:	d001      	beq.n	8013624 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
 8013620:	2340      	movs	r3, #64	@ 0x40
 8013622:	e080      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8013624:	697b      	ldr	r3, [r7, #20]
 8013626:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 801362a:	2b00      	cmp	r3, #0
 801362c:	d001      	beq.n	8013632 <SDMMC_GetCmdResp1+0xd2>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 801362e:	2380      	movs	r3, #128	@ 0x80
 8013630:	e079      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8013632:	697b      	ldr	r3, [r7, #20]
 8013634:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8013638:	2b00      	cmp	r3, #0
 801363a:	d002      	beq.n	8013642 <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 801363c:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8013640:	e071      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8013642:	697b      	ldr	r3, [r7, #20]
 8013644:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8013648:	2b00      	cmp	r3, #0
 801364a:	d002      	beq.n	8013652 <SDMMC_GetCmdResp1+0xf2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 801364c:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8013650:	e069      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8013652:	697b      	ldr	r3, [r7, #20]
 8013654:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
 8013658:	2b00      	cmp	r3, #0
 801365a:	d002      	beq.n	8013662 <SDMMC_GetCmdResp1+0x102>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 801365c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8013660:	e061      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8013662:	697b      	ldr	r3, [r7, #20]
 8013664:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8013668:	2b00      	cmp	r3, #0
 801366a:	d002      	beq.n	8013672 <SDMMC_GetCmdResp1+0x112>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 801366c:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8013670:	e059      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8013672:	697b      	ldr	r3, [r7, #20]
 8013674:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8013678:	2b00      	cmp	r3, #0
 801367a:	d002      	beq.n	8013682 <SDMMC_GetCmdResp1+0x122>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 801367c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8013680:	e051      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8013682:	697b      	ldr	r3, [r7, #20]
 8013684:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8013688:	2b00      	cmp	r3, #0
 801368a:	d002      	beq.n	8013692 <SDMMC_GetCmdResp1+0x132>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 801368c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8013690:	e049      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8013692:	697b      	ldr	r3, [r7, #20]
 8013694:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8013698:	2b00      	cmp	r3, #0
 801369a:	d002      	beq.n	80136a2 <SDMMC_GetCmdResp1+0x142>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
 801369c:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 80136a0:	e041      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 80136a2:	697b      	ldr	r3, [r7, #20]
 80136a4:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80136a8:	2b00      	cmp	r3, #0
 80136aa:	d002      	beq.n	80136b2 <SDMMC_GetCmdResp1+0x152>
  {
    return SDMMC_ERROR_CC_ERR;
 80136ac:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 80136b0:	e039      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 80136b2:	697b      	ldr	r3, [r7, #20]
 80136b4:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 80136b8:	2b00      	cmp	r3, #0
 80136ba:	d002      	beq.n	80136c2 <SDMMC_GetCmdResp1+0x162>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 80136bc:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
 80136c0:	e031      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 80136c2:	697b      	ldr	r3, [r7, #20]
 80136c4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80136c8:	2b00      	cmp	r3, #0
 80136ca:	d002      	beq.n	80136d2 <SDMMC_GetCmdResp1+0x172>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 80136cc:	f44f 2380 	mov.w	r3, #262144	@ 0x40000
 80136d0:	e029      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 80136d2:	697b      	ldr	r3, [r7, #20]
 80136d4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80136d8:	2b00      	cmp	r3, #0
 80136da:	d002      	beq.n	80136e2 <SDMMC_GetCmdResp1+0x182>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 80136dc:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 80136e0:	e021      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 80136e2:	697b      	ldr	r3, [r7, #20]
 80136e4:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80136e8:	2b00      	cmp	r3, #0
 80136ea:	d002      	beq.n	80136f2 <SDMMC_GetCmdResp1+0x192>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
 80136ec:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 80136f0:	e019      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 80136f2:	697b      	ldr	r3, [r7, #20]
 80136f4:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 80136f8:	2b00      	cmp	r3, #0
 80136fa:	d002      	beq.n	8013702 <SDMMC_GetCmdResp1+0x1a2>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 80136fc:	f44f 1300 	mov.w	r3, #2097152	@ 0x200000
 8013700:	e011      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 8013702:	697b      	ldr	r3, [r7, #20]
 8013704:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8013708:	2b00      	cmp	r3, #0
 801370a:	d002      	beq.n	8013712 <SDMMC_GetCmdResp1+0x1b2>
  {
    return SDMMC_ERROR_ERASE_RESET;
 801370c:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
 8013710:	e009      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
 8013712:	697b      	ldr	r3, [r7, #20]
 8013714:	f003 0308 	and.w	r3, r3, #8
 8013718:	2b00      	cmp	r3, #0
 801371a:	d002      	beq.n	8013722 <SDMMC_GetCmdResp1+0x1c2>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
 801371c:	f44f 0300 	mov.w	r3, #8388608	@ 0x800000
 8013720:	e001      	b.n	8013726 <SDMMC_GetCmdResp1+0x1c6>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8013722:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
 8013726:	4618      	mov	r0, r3
 8013728:	3720      	adds	r7, #32
 801372a:	46bd      	mov	sp, r7
 801372c:	bd80      	pop	{r7, pc}
 801372e:	bf00      	nop
 8013730:	20000040 	.word	0x20000040
 8013734:	10624dd3 	.word	0x10624dd3
 8013738:	fdffe008 	.word	0xfdffe008

0801373c <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  SDIOx Pointer to SDMMC register base
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDIO_TypeDef *SDIOx)
{
 801373c:	b480      	push	{r7}
 801373e:	b085      	sub	sp, #20
 8013740:	af00      	add	r7, sp, #0
 8013742:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8013744:	4b1f      	ldr	r3, [pc, #124]	@ (80137c4 <SDMMC_GetCmdResp2+0x88>)
 8013746:	681b      	ldr	r3, [r3, #0]
 8013748:	4a1f      	ldr	r2, [pc, #124]	@ (80137c8 <SDMMC_GetCmdResp2+0x8c>)
 801374a:	fba2 2303 	umull	r2, r3, r2, r3
 801374e:	0a5b      	lsrs	r3, r3, #9
 8013750:	f241 3288 	movw	r2, #5000	@ 0x1388
 8013754:	fb02 f303 	mul.w	r3, r2, r3
 8013758:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
 801375a:	68fb      	ldr	r3, [r7, #12]
 801375c:	1e5a      	subs	r2, r3, #1
 801375e:	60fa      	str	r2, [r7, #12]
 8013760:	2b00      	cmp	r3, #0
 8013762:	d102      	bne.n	801376a <SDMMC_GetCmdResp2+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 8013764:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8013768:	e026      	b.n	80137b8 <SDMMC_GetCmdResp2+0x7c>
    }
    sta_reg = SDIOx->STA;
 801376a:	687b      	ldr	r3, [r7, #4]
 801376c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801376e:	60bb      	str	r3, [r7, #8]
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013770:	68bb      	ldr	r3, [r7, #8]
 8013772:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 8013776:	2b00      	cmp	r3, #0
 8013778:	d0ef      	beq.n	801375a <SDMMC_GetCmdResp2+0x1e>
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 801377a:	68bb      	ldr	r3, [r7, #8]
 801377c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013780:	2b00      	cmp	r3, #0
 8013782:	d1ea      	bne.n	801375a <SDMMC_GetCmdResp2+0x1e>
    
  if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 8013784:	687b      	ldr	r3, [r7, #4]
 8013786:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013788:	f003 0304 	and.w	r3, r3, #4
 801378c:	2b00      	cmp	r3, #0
 801378e:	d004      	beq.n	801379a <SDMMC_GetCmdResp2+0x5e>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 8013790:	687b      	ldr	r3, [r7, #4]
 8013792:	2204      	movs	r2, #4
 8013794:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8013796:	2304      	movs	r3, #4
 8013798:	e00e      	b.n	80137b8 <SDMMC_GetCmdResp2+0x7c>
  }
  else if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 801379a:	687b      	ldr	r3, [r7, #4]
 801379c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801379e:	f003 0301 	and.w	r3, r3, #1
 80137a2:	2b00      	cmp	r3, #0
 80137a4:	d004      	beq.n	80137b0 <SDMMC_GetCmdResp2+0x74>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80137a6:	687b      	ldr	r3, [r7, #4]
 80137a8:	2201      	movs	r2, #1
 80137aa:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80137ac:	2301      	movs	r3, #1
 80137ae:	e003      	b.n	80137b8 <SDMMC_GetCmdResp2+0x7c>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 80137b0:	687b      	ldr	r3, [r7, #4]
 80137b2:	22c5      	movs	r2, #197	@ 0xc5
 80137b4:	639a      	str	r2, [r3, #56]	@ 0x38
  }

  return SDMMC_ERROR_NONE;
 80137b6:	2300      	movs	r3, #0
}
 80137b8:	4618      	mov	r0, r3
 80137ba:	3714      	adds	r7, #20
 80137bc:	46bd      	mov	sp, r7
 80137be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80137c2:	4770      	bx	lr
 80137c4:	20000040 	.word	0x20000040
 80137c8:	10624dd3 	.word	0x10624dd3

080137cc <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  SDIOx Pointer to SDMMC register base
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDIO_TypeDef *SDIOx)
{
 80137cc:	b480      	push	{r7}
 80137ce:	b085      	sub	sp, #20
 80137d0:	af00      	add	r7, sp, #0
 80137d2:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80137d4:	4b1a      	ldr	r3, [pc, #104]	@ (8013840 <SDMMC_GetCmdResp3+0x74>)
 80137d6:	681b      	ldr	r3, [r3, #0]
 80137d8:	4a1a      	ldr	r2, [pc, #104]	@ (8013844 <SDMMC_GetCmdResp3+0x78>)
 80137da:	fba2 2303 	umull	r2, r3, r2, r3
 80137de:	0a5b      	lsrs	r3, r3, #9
 80137e0:	f241 3288 	movw	r2, #5000	@ 0x1388
 80137e4:	fb02 f303 	mul.w	r3, r2, r3
 80137e8:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
 80137ea:	68fb      	ldr	r3, [r7, #12]
 80137ec:	1e5a      	subs	r2, r3, #1
 80137ee:	60fa      	str	r2, [r7, #12]
 80137f0:	2b00      	cmp	r3, #0
 80137f2:	d102      	bne.n	80137fa <SDMMC_GetCmdResp3+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 80137f4:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 80137f8:	e01b      	b.n	8013832 <SDMMC_GetCmdResp3+0x66>
    }
    sta_reg = SDIOx->STA;
 80137fa:	687b      	ldr	r3, [r7, #4]
 80137fc:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80137fe:	60bb      	str	r3, [r7, #8]
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013800:	68bb      	ldr	r3, [r7, #8]
 8013802:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 8013806:	2b00      	cmp	r3, #0
 8013808:	d0ef      	beq.n	80137ea <SDMMC_GetCmdResp3+0x1e>
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 801380a:	68bb      	ldr	r3, [r7, #8]
 801380c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013810:	2b00      	cmp	r3, #0
 8013812:	d1ea      	bne.n	80137ea <SDMMC_GetCmdResp3+0x1e>
    
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 8013814:	687b      	ldr	r3, [r7, #4]
 8013816:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013818:	f003 0304 	and.w	r3, r3, #4
 801381c:	2b00      	cmp	r3, #0
 801381e:	d004      	beq.n	801382a <SDMMC_GetCmdResp3+0x5e>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 8013820:	687b      	ldr	r3, [r7, #4]
 8013822:	2204      	movs	r2, #4
 8013824:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8013826:	2304      	movs	r3, #4
 8013828:	e003      	b.n	8013832 <SDMMC_GetCmdResp3+0x66>
  }
  else
  {  
    /* Clear all the static flags */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 801382a:	687b      	ldr	r3, [r7, #4]
 801382c:	22c5      	movs	r2, #197	@ 0xc5
 801382e:	639a      	str	r2, [r3, #56]	@ 0x38
  }
  
  return SDMMC_ERROR_NONE;
 8013830:	2300      	movs	r3, #0
}
 8013832:	4618      	mov	r0, r3
 8013834:	3714      	adds	r7, #20
 8013836:	46bd      	mov	sp, r7
 8013838:	f85d 7b04 	ldr.w	r7, [sp], #4
 801383c:	4770      	bx	lr
 801383e:	bf00      	nop
 8013840:	20000040 	.word	0x20000040
 8013844:	10624dd3 	.word	0x10624dd3

08013848 <SDMMC_GetCmdResp6>:
  * @param  pRCA: Pointer to the variable that will contain the SD card relative 
  *         address RCA   
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp6(SDIO_TypeDef *SDIOx, uint8_t SD_CMD, uint16_t *pRCA)
{
 8013848:	b580      	push	{r7, lr}
 801384a:	b088      	sub	sp, #32
 801384c:	af00      	add	r7, sp, #0
 801384e:	60f8      	str	r0, [r7, #12]
 8013850:	460b      	mov	r3, r1
 8013852:	607a      	str	r2, [r7, #4]
 8013854:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8013856:	4b35      	ldr	r3, [pc, #212]	@ (801392c <SDMMC_GetCmdResp6+0xe4>)
 8013858:	681b      	ldr	r3, [r3, #0]
 801385a:	4a35      	ldr	r2, [pc, #212]	@ (8013930 <SDMMC_GetCmdResp6+0xe8>)
 801385c:	fba2 2303 	umull	r2, r3, r2, r3
 8013860:	0a5b      	lsrs	r3, r3, #9
 8013862:	f241 3288 	movw	r2, #5000	@ 0x1388
 8013866:	fb02 f303 	mul.w	r3, r2, r3
 801386a:	61fb      	str	r3, [r7, #28]
  
  do
  {
    if (count-- == 0U)
 801386c:	69fb      	ldr	r3, [r7, #28]
 801386e:	1e5a      	subs	r2, r3, #1
 8013870:	61fa      	str	r2, [r7, #28]
 8013872:	2b00      	cmp	r3, #0
 8013874:	d102      	bne.n	801387c <SDMMC_GetCmdResp6+0x34>
    {
      return SDMMC_ERROR_TIMEOUT;
 8013876:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 801387a:	e052      	b.n	8013922 <SDMMC_GetCmdResp6+0xda>
    }
    sta_reg = SDIOx->STA;
 801387c:	68fb      	ldr	r3, [r7, #12]
 801387e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013880:	61bb      	str	r3, [r7, #24]
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013882:	69bb      	ldr	r3, [r7, #24]
 8013884:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 8013888:	2b00      	cmp	r3, #0
 801388a:	d0ef      	beq.n	801386c <SDMMC_GetCmdResp6+0x24>
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 801388c:	69bb      	ldr	r3, [r7, #24]
 801388e:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013892:	2b00      	cmp	r3, #0
 8013894:	d1ea      	bne.n	801386c <SDMMC_GetCmdResp6+0x24>
    
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 8013896:	68fb      	ldr	r3, [r7, #12]
 8013898:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801389a:	f003 0304 	and.w	r3, r3, #4
 801389e:	2b00      	cmp	r3, #0
 80138a0:	d004      	beq.n	80138ac <SDMMC_GetCmdResp6+0x64>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 80138a2:	68fb      	ldr	r3, [r7, #12]
 80138a4:	2204      	movs	r2, #4
 80138a6:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80138a8:	2304      	movs	r3, #4
 80138aa:	e03a      	b.n	8013922 <SDMMC_GetCmdResp6+0xda>
  }
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 80138ac:	68fb      	ldr	r3, [r7, #12]
 80138ae:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80138b0:	f003 0301 	and.w	r3, r3, #1
 80138b4:	2b00      	cmp	r3, #0
 80138b6:	d004      	beq.n	80138c2 <SDMMC_GetCmdResp6+0x7a>
  {
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 80138b8:	68fb      	ldr	r3, [r7, #12]
 80138ba:	2201      	movs	r2, #1
 80138bc:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80138be:	2301      	movs	r3, #1
 80138c0:	e02f      	b.n	8013922 <SDMMC_GetCmdResp6+0xda>
  {
    /* Nothing to do */
  }
  
  /* Check response received is of desired command */
  if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
 80138c2:	68f8      	ldr	r0, [r7, #12]
 80138c4:	f7ff fbcc 	bl	8013060 <SDIO_GetCommandResponse>
 80138c8:	4603      	mov	r3, r0
 80138ca:	461a      	mov	r2, r3
 80138cc:	7afb      	ldrb	r3, [r7, #11]
 80138ce:	4293      	cmp	r3, r2
 80138d0:	d001      	beq.n	80138d6 <SDMMC_GetCmdResp6+0x8e>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80138d2:	2301      	movs	r3, #1
 80138d4:	e025      	b.n	8013922 <SDMMC_GetCmdResp6+0xda>
  }
  
  /* Clear all the static flags */
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 80138d6:	68fb      	ldr	r3, [r7, #12]
 80138d8:	22c5      	movs	r2, #197	@ 0xc5
 80138da:	639a      	str	r2, [r3, #56]	@ 0x38
  
  /* We have received response, retrieve it.  */
  response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
 80138dc:	2100      	movs	r1, #0
 80138de:	68f8      	ldr	r0, [r7, #12]
 80138e0:	f7ff fbcb 	bl	801307a <SDIO_GetResponse>
 80138e4:	6178      	str	r0, [r7, #20]
  
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 80138e6:	697b      	ldr	r3, [r7, #20]
 80138e8:	f403 4360 	and.w	r3, r3, #57344	@ 0xe000
 80138ec:	2b00      	cmp	r3, #0
 80138ee:	d106      	bne.n	80138fe <SDMMC_GetCmdResp6+0xb6>
  {
    *pRCA = (uint16_t) (response_r1 >> 16);
 80138f0:	697b      	ldr	r3, [r7, #20]
 80138f2:	0c1b      	lsrs	r3, r3, #16
 80138f4:	b29a      	uxth	r2, r3
 80138f6:	687b      	ldr	r3, [r7, #4]
 80138f8:	801a      	strh	r2, [r3, #0]
    
    return SDMMC_ERROR_NONE;
 80138fa:	2300      	movs	r3, #0
 80138fc:	e011      	b.n	8013922 <SDMMC_GetCmdResp6+0xda>
  }
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 80138fe:	697b      	ldr	r3, [r7, #20]
 8013900:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8013904:	2b00      	cmp	r3, #0
 8013906:	d002      	beq.n	801390e <SDMMC_GetCmdResp6+0xc6>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
 8013908:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 801390c:	e009      	b.n	8013922 <SDMMC_GetCmdResp6+0xda>
  }
  else if((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
 801390e:	697b      	ldr	r3, [r7, #20]
 8013910:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8013914:	2b00      	cmp	r3, #0
 8013916:	d002      	beq.n	801391e <SDMMC_GetCmdResp6+0xd6>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
 8013918:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 801391c:	e001      	b.n	8013922 <SDMMC_GetCmdResp6+0xda>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 801391e:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
  }
}
 8013922:	4618      	mov	r0, r3
 8013924:	3720      	adds	r7, #32
 8013926:	46bd      	mov	sp, r7
 8013928:	bd80      	pop	{r7, pc}
 801392a:	bf00      	nop
 801392c:	20000040 	.word	0x20000040
 8013930:	10624dd3 	.word	0x10624dd3

08013934 <SDMMC_GetCmdResp7>:
  * @brief  Checks for error conditions for R7 response.
  * @param  SDIOx Pointer to SDMMC register base
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp7(SDIO_TypeDef *SDIOx)
{
 8013934:	b480      	push	{r7}
 8013936:	b085      	sub	sp, #20
 8013938:	af00      	add	r7, sp, #0
 801393a:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801393c:	4b22      	ldr	r3, [pc, #136]	@ (80139c8 <SDMMC_GetCmdResp7+0x94>)
 801393e:	681b      	ldr	r3, [r3, #0]
 8013940:	4a22      	ldr	r2, [pc, #136]	@ (80139cc <SDMMC_GetCmdResp7+0x98>)
 8013942:	fba2 2303 	umull	r2, r3, r2, r3
 8013946:	0a5b      	lsrs	r3, r3, #9
 8013948:	f241 3288 	movw	r2, #5000	@ 0x1388
 801394c:	fb02 f303 	mul.w	r3, r2, r3
 8013950:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
 8013952:	68fb      	ldr	r3, [r7, #12]
 8013954:	1e5a      	subs	r2, r3, #1
 8013956:	60fa      	str	r2, [r7, #12]
 8013958:	2b00      	cmp	r3, #0
 801395a:	d102      	bne.n	8013962 <SDMMC_GetCmdResp7+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 801395c:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8013960:	e02c      	b.n	80139bc <SDMMC_GetCmdResp7+0x88>
    }
    sta_reg = SDIOx->STA;
 8013962:	687b      	ldr	r3, [r7, #4]
 8013964:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013966:	60bb      	str	r3, [r7, #8]
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013968:	68bb      	ldr	r3, [r7, #8]
 801396a:	f003 0345 	and.w	r3, r3, #69	@ 0x45
 801396e:	2b00      	cmp	r3, #0
 8013970:	d0ef      	beq.n	8013952 <SDMMC_GetCmdResp7+0x1e>
         ((sta_reg & SDIO_FLAG_CMDACT) != 0U ));
 8013972:	68bb      	ldr	r3, [r7, #8]
 8013974:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
  }while(((sta_reg & (SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT)) == 0U) ||
 8013978:	2b00      	cmp	r3, #0
 801397a:	d1ea      	bne.n	8013952 <SDMMC_GetCmdResp7+0x1e>
    
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
 801397c:	687b      	ldr	r3, [r7, #4]
 801397e:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013980:	f003 0304 	and.w	r3, r3, #4
 8013984:	2b00      	cmp	r3, #0
 8013986:	d004      	beq.n	8013992 <SDMMC_GetCmdResp7+0x5e>
  {
    /* Card is SD V2.0 compliant */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
 8013988:	687b      	ldr	r3, [r7, #4]
 801398a:	2204      	movs	r2, #4
 801398c:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 801398e:	2304      	movs	r3, #4
 8013990:	e014      	b.n	80139bc <SDMMC_GetCmdResp7+0x88>
  }
  else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
 8013992:	687b      	ldr	r3, [r7, #4]
 8013994:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013996:	f003 0301 	and.w	r3, r3, #1
 801399a:	2b00      	cmp	r3, #0
 801399c:	d004      	beq.n	80139a8 <SDMMC_GetCmdResp7+0x74>
  {
    /* Card is SD V2.0 compliant */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
 801399e:	687b      	ldr	r3, [r7, #4]
 80139a0:	2201      	movs	r2, #1
 80139a2:	639a      	str	r2, [r3, #56]	@ 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80139a4:	2301      	movs	r3, #1
 80139a6:	e009      	b.n	80139bc <SDMMC_GetCmdResp7+0x88>
  else
  {
    /* Nothing to do */
  }
  
  if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDREND))
 80139a8:	687b      	ldr	r3, [r7, #4]
 80139aa:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80139ac:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80139b0:	2b00      	cmp	r3, #0
 80139b2:	d002      	beq.n	80139ba <SDMMC_GetCmdResp7+0x86>
  {
    /* Card is SD V2.0 compliant */
    __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CMDREND);
 80139b4:	687b      	ldr	r3, [r7, #4]
 80139b6:	2240      	movs	r2, #64	@ 0x40
 80139b8:	639a      	str	r2, [r3, #56]	@ 0x38
  }
  
  return SDMMC_ERROR_NONE;
 80139ba:	2300      	movs	r3, #0
  
}
 80139bc:	4618      	mov	r0, r3
 80139be:	3714      	adds	r7, #20
 80139c0:	46bd      	mov	sp, r7
 80139c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80139c6:	4770      	bx	lr
 80139c8:	20000040 	.word	0x20000040
 80139cc:	10624dd3 	.word	0x10624dd3

080139d0 <SDMMC_GetCmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  SDIOx Pointer to SDMMC register base
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdError(SDIO_TypeDef *SDIOx)
{
 80139d0:	b480      	push	{r7}
 80139d2:	b085      	sub	sp, #20
 80139d4:	af00      	add	r7, sp, #0
 80139d6:	6078      	str	r0, [r7, #4]
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDIO_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80139d8:	4b11      	ldr	r3, [pc, #68]	@ (8013a20 <SDMMC_GetCmdError+0x50>)
 80139da:	681b      	ldr	r3, [r3, #0]
 80139dc:	4a11      	ldr	r2, [pc, #68]	@ (8013a24 <SDMMC_GetCmdError+0x54>)
 80139de:	fba2 2303 	umull	r2, r3, r2, r3
 80139e2:	0a5b      	lsrs	r3, r3, #9
 80139e4:	f241 3288 	movw	r2, #5000	@ 0x1388
 80139e8:	fb02 f303 	mul.w	r3, r2, r3
 80139ec:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
 80139ee:	68fb      	ldr	r3, [r7, #12]
 80139f0:	1e5a      	subs	r2, r3, #1
 80139f2:	60fa      	str	r2, [r7, #12]
 80139f4:	2b00      	cmp	r3, #0
 80139f6:	d102      	bne.n	80139fe <SDMMC_GetCmdError+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
 80139f8:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 80139fc:	e009      	b.n	8013a12 <SDMMC_GetCmdError+0x42>
    }
    
  }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDSENT));
 80139fe:	687b      	ldr	r3, [r7, #4]
 8013a00:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8013a02:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8013a06:	2b00      	cmp	r3, #0
 8013a08:	d0f1      	beq.n	80139ee <SDMMC_GetCmdError+0x1e>
  
  /* Clear all the static flags */
  __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_CMD_FLAGS);
 8013a0a:	687b      	ldr	r3, [r7, #4]
 8013a0c:	22c5      	movs	r2, #197	@ 0xc5
 8013a0e:	639a      	str	r2, [r3, #56]	@ 0x38
  
  return SDMMC_ERROR_NONE;
 8013a10:	2300      	movs	r3, #0
}
 8013a12:	4618      	mov	r0, r3
 8013a14:	3714      	adds	r7, #20
 8013a16:	46bd      	mov	sp, r7
 8013a18:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013a1c:	4770      	bx	lr
 8013a1e:	bf00      	nop
 8013a20:	20000040 	.word	0x20000040
 8013a24:	10624dd3 	.word	0x10624dd3

08013a28 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8013a28:	b084      	sub	sp, #16
 8013a2a:	b580      	push	{r7, lr}
 8013a2c:	b084      	sub	sp, #16
 8013a2e:	af00      	add	r7, sp, #0
 8013a30:	6078      	str	r0, [r7, #4]
 8013a32:	f107 001c 	add.w	r0, r7, #28
 8013a36:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8013a3a:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 8013a3e:	2b01      	cmp	r3, #1
 8013a40:	d123      	bne.n	8013a8a <USB_CoreInit+0x62>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8013a42:	687b      	ldr	r3, [r7, #4]
 8013a44:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013a46:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8013a4a:	687b      	ldr	r3, [r7, #4]
 8013a4c:	639a      	str	r2, [r3, #56]	@ 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8013a4e:	687b      	ldr	r3, [r7, #4]
 8013a50:	68db      	ldr	r3, [r3, #12]
 8013a52:	f423 0384 	bic.w	r3, r3, #4325376	@ 0x420000
 8013a56:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8013a5a:	687a      	ldr	r2, [r7, #4]
 8013a5c:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8013a5e:	687b      	ldr	r3, [r7, #4]
 8013a60:	68db      	ldr	r3, [r3, #12]
 8013a62:	f423 1240 	bic.w	r2, r3, #3145728	@ 0x300000
 8013a66:	687b      	ldr	r3, [r7, #4]
 8013a68:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 8013a6a:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8013a6e:	2b01      	cmp	r3, #1
 8013a70:	d105      	bne.n	8013a7e <USB_CoreInit+0x56>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8013a72:	687b      	ldr	r3, [r7, #4]
 8013a74:	68db      	ldr	r3, [r3, #12]
 8013a76:	f443 1280 	orr.w	r2, r3, #1048576	@ 0x100000
 8013a7a:	687b      	ldr	r3, [r7, #4]
 8013a7c:	60da      	str	r2, [r3, #12]
    }

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8013a7e:	6878      	ldr	r0, [r7, #4]
 8013a80:	f001 fae2 	bl	8015048 <USB_CoreReset>
 8013a84:	4603      	mov	r3, r0
 8013a86:	73fb      	strb	r3, [r7, #15]
 8013a88:	e01b      	b.n	8013ac2 <USB_CoreInit+0x9a>
  }
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8013a8a:	687b      	ldr	r3, [r7, #4]
 8013a8c:	68db      	ldr	r3, [r3, #12]
 8013a8e:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 8013a92:	687b      	ldr	r3, [r7, #4]
 8013a94:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select */
    ret = USB_CoreReset(USBx);
 8013a96:	6878      	ldr	r0, [r7, #4]
 8013a98:	f001 fad6 	bl	8015048 <USB_CoreReset>
 8013a9c:	4603      	mov	r3, r0
 8013a9e:	73fb      	strb	r3, [r7, #15]

    if (cfg.battery_charging_enable == 0U)
 8013aa0:	f897 3025 	ldrb.w	r3, [r7, #37]	@ 0x25
 8013aa4:	2b00      	cmp	r3, #0
 8013aa6:	d106      	bne.n	8013ab6 <USB_CoreInit+0x8e>
    {
      /* Activate the USB Transceiver */
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8013aa8:	687b      	ldr	r3, [r7, #4]
 8013aaa:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013aac:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8013ab0:	687b      	ldr	r3, [r7, #4]
 8013ab2:	639a      	str	r2, [r3, #56]	@ 0x38
 8013ab4:	e005      	b.n	8013ac2 <USB_CoreInit+0x9a>
    }
    else
    {
      /* Deactivate the USB Transceiver */
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8013ab6:	687b      	ldr	r3, [r7, #4]
 8013ab8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013aba:	f423 3280 	bic.w	r2, r3, #65536	@ 0x10000
 8013abe:	687b      	ldr	r3, [r7, #4]
 8013ac0:	639a      	str	r2, [r3, #56]	@ 0x38
    }
  }

  if (cfg.dma_enable == 1U)
 8013ac2:	7fbb      	ldrb	r3, [r7, #30]
 8013ac4:	2b01      	cmp	r3, #1
 8013ac6:	d10b      	bne.n	8013ae0 <USB_CoreInit+0xb8>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8013ac8:	687b      	ldr	r3, [r7, #4]
 8013aca:	689b      	ldr	r3, [r3, #8]
 8013acc:	f043 0206 	orr.w	r2, r3, #6
 8013ad0:	687b      	ldr	r3, [r7, #4]
 8013ad2:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8013ad4:	687b      	ldr	r3, [r7, #4]
 8013ad6:	689b      	ldr	r3, [r3, #8]
 8013ad8:	f043 0220 	orr.w	r2, r3, #32
 8013adc:	687b      	ldr	r3, [r7, #4]
 8013ade:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8013ae0:	7bfb      	ldrb	r3, [r7, #15]
}
 8013ae2:	4618      	mov	r0, r3
 8013ae4:	3710      	adds	r7, #16
 8013ae6:	46bd      	mov	sp, r7
 8013ae8:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8013aec:	b004      	add	sp, #16
 8013aee:	4770      	bx	lr

08013af0 <USB_SetTurnaroundTime>:
  * @param  hclk: AHB clock frequency
  * @retval USB turnaround time In PHY Clocks number
  */
HAL_StatusTypeDef USB_SetTurnaroundTime(USB_OTG_GlobalTypeDef *USBx,
                                        uint32_t hclk, uint8_t speed)
{
 8013af0:	b480      	push	{r7}
 8013af2:	b087      	sub	sp, #28
 8013af4:	af00      	add	r7, sp, #0
 8013af6:	60f8      	str	r0, [r7, #12]
 8013af8:	60b9      	str	r1, [r7, #8]
 8013afa:	4613      	mov	r3, r2
 8013afc:	71fb      	strb	r3, [r7, #7]

  /* The USBTRD is configured according to the tables below, depending on AHB frequency
  used by application. In the low AHB frequency range it is used to stretch enough the USB response
  time to IN tokens, the USB turnaround time, so to compensate for the longer AHB read access
  latency to the Data FIFO */
  if (speed == USBD_FS_SPEED)
 8013afe:	79fb      	ldrb	r3, [r7, #7]
 8013b00:	2b02      	cmp	r3, #2
 8013b02:	d165      	bne.n	8013bd0 <USB_SetTurnaroundTime+0xe0>
  {
    if ((hclk >= 14200000U) && (hclk < 15000000U))
 8013b04:	68bb      	ldr	r3, [r7, #8]
 8013b06:	4a41      	ldr	r2, [pc, #260]	@ (8013c0c <USB_SetTurnaroundTime+0x11c>)
 8013b08:	4293      	cmp	r3, r2
 8013b0a:	d906      	bls.n	8013b1a <USB_SetTurnaroundTime+0x2a>
 8013b0c:	68bb      	ldr	r3, [r7, #8]
 8013b0e:	4a40      	ldr	r2, [pc, #256]	@ (8013c10 <USB_SetTurnaroundTime+0x120>)
 8013b10:	4293      	cmp	r3, r2
 8013b12:	d202      	bcs.n	8013b1a <USB_SetTurnaroundTime+0x2a>
    {
      /* hclk Clock Range between 14.2-15 MHz */
      UsbTrd = 0xFU;
 8013b14:	230f      	movs	r3, #15
 8013b16:	617b      	str	r3, [r7, #20]
 8013b18:	e062      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 15000000U) && (hclk < 16000000U))
 8013b1a:	68bb      	ldr	r3, [r7, #8]
 8013b1c:	4a3c      	ldr	r2, [pc, #240]	@ (8013c10 <USB_SetTurnaroundTime+0x120>)
 8013b1e:	4293      	cmp	r3, r2
 8013b20:	d306      	bcc.n	8013b30 <USB_SetTurnaroundTime+0x40>
 8013b22:	68bb      	ldr	r3, [r7, #8]
 8013b24:	4a3b      	ldr	r2, [pc, #236]	@ (8013c14 <USB_SetTurnaroundTime+0x124>)
 8013b26:	4293      	cmp	r3, r2
 8013b28:	d202      	bcs.n	8013b30 <USB_SetTurnaroundTime+0x40>
    {
      /* hclk Clock Range between 15-16 MHz */
      UsbTrd = 0xEU;
 8013b2a:	230e      	movs	r3, #14
 8013b2c:	617b      	str	r3, [r7, #20]
 8013b2e:	e057      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 16000000U) && (hclk < 17200000U))
 8013b30:	68bb      	ldr	r3, [r7, #8]
 8013b32:	4a38      	ldr	r2, [pc, #224]	@ (8013c14 <USB_SetTurnaroundTime+0x124>)
 8013b34:	4293      	cmp	r3, r2
 8013b36:	d306      	bcc.n	8013b46 <USB_SetTurnaroundTime+0x56>
 8013b38:	68bb      	ldr	r3, [r7, #8]
 8013b3a:	4a37      	ldr	r2, [pc, #220]	@ (8013c18 <USB_SetTurnaroundTime+0x128>)
 8013b3c:	4293      	cmp	r3, r2
 8013b3e:	d202      	bcs.n	8013b46 <USB_SetTurnaroundTime+0x56>
    {
      /* hclk Clock Range between 16-17.2 MHz */
      UsbTrd = 0xDU;
 8013b40:	230d      	movs	r3, #13
 8013b42:	617b      	str	r3, [r7, #20]
 8013b44:	e04c      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 17200000U) && (hclk < 18500000U))
 8013b46:	68bb      	ldr	r3, [r7, #8]
 8013b48:	4a33      	ldr	r2, [pc, #204]	@ (8013c18 <USB_SetTurnaroundTime+0x128>)
 8013b4a:	4293      	cmp	r3, r2
 8013b4c:	d306      	bcc.n	8013b5c <USB_SetTurnaroundTime+0x6c>
 8013b4e:	68bb      	ldr	r3, [r7, #8]
 8013b50:	4a32      	ldr	r2, [pc, #200]	@ (8013c1c <USB_SetTurnaroundTime+0x12c>)
 8013b52:	4293      	cmp	r3, r2
 8013b54:	d802      	bhi.n	8013b5c <USB_SetTurnaroundTime+0x6c>
    {
      /* hclk Clock Range between 17.2-18.5 MHz */
      UsbTrd = 0xCU;
 8013b56:	230c      	movs	r3, #12
 8013b58:	617b      	str	r3, [r7, #20]
 8013b5a:	e041      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 18500000U) && (hclk < 20000000U))
 8013b5c:	68bb      	ldr	r3, [r7, #8]
 8013b5e:	4a2f      	ldr	r2, [pc, #188]	@ (8013c1c <USB_SetTurnaroundTime+0x12c>)
 8013b60:	4293      	cmp	r3, r2
 8013b62:	d906      	bls.n	8013b72 <USB_SetTurnaroundTime+0x82>
 8013b64:	68bb      	ldr	r3, [r7, #8]
 8013b66:	4a2e      	ldr	r2, [pc, #184]	@ (8013c20 <USB_SetTurnaroundTime+0x130>)
 8013b68:	4293      	cmp	r3, r2
 8013b6a:	d802      	bhi.n	8013b72 <USB_SetTurnaroundTime+0x82>
    {
      /* hclk Clock Range between 18.5-20 MHz */
      UsbTrd = 0xBU;
 8013b6c:	230b      	movs	r3, #11
 8013b6e:	617b      	str	r3, [r7, #20]
 8013b70:	e036      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 20000000U) && (hclk < 21800000U))
 8013b72:	68bb      	ldr	r3, [r7, #8]
 8013b74:	4a2a      	ldr	r2, [pc, #168]	@ (8013c20 <USB_SetTurnaroundTime+0x130>)
 8013b76:	4293      	cmp	r3, r2
 8013b78:	d906      	bls.n	8013b88 <USB_SetTurnaroundTime+0x98>
 8013b7a:	68bb      	ldr	r3, [r7, #8]
 8013b7c:	4a29      	ldr	r2, [pc, #164]	@ (8013c24 <USB_SetTurnaroundTime+0x134>)
 8013b7e:	4293      	cmp	r3, r2
 8013b80:	d802      	bhi.n	8013b88 <USB_SetTurnaroundTime+0x98>
    {
      /* hclk Clock Range between 20-21.8 MHz */
      UsbTrd = 0xAU;
 8013b82:	230a      	movs	r3, #10
 8013b84:	617b      	str	r3, [r7, #20]
 8013b86:	e02b      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 21800000U) && (hclk < 24000000U))
 8013b88:	68bb      	ldr	r3, [r7, #8]
 8013b8a:	4a26      	ldr	r2, [pc, #152]	@ (8013c24 <USB_SetTurnaroundTime+0x134>)
 8013b8c:	4293      	cmp	r3, r2
 8013b8e:	d906      	bls.n	8013b9e <USB_SetTurnaroundTime+0xae>
 8013b90:	68bb      	ldr	r3, [r7, #8]
 8013b92:	4a25      	ldr	r2, [pc, #148]	@ (8013c28 <USB_SetTurnaroundTime+0x138>)
 8013b94:	4293      	cmp	r3, r2
 8013b96:	d202      	bcs.n	8013b9e <USB_SetTurnaroundTime+0xae>
    {
      /* hclk Clock Range between 21.8-24 MHz */
      UsbTrd = 0x9U;
 8013b98:	2309      	movs	r3, #9
 8013b9a:	617b      	str	r3, [r7, #20]
 8013b9c:	e020      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 24000000U) && (hclk < 27700000U))
 8013b9e:	68bb      	ldr	r3, [r7, #8]
 8013ba0:	4a21      	ldr	r2, [pc, #132]	@ (8013c28 <USB_SetTurnaroundTime+0x138>)
 8013ba2:	4293      	cmp	r3, r2
 8013ba4:	d306      	bcc.n	8013bb4 <USB_SetTurnaroundTime+0xc4>
 8013ba6:	68bb      	ldr	r3, [r7, #8]
 8013ba8:	4a20      	ldr	r2, [pc, #128]	@ (8013c2c <USB_SetTurnaroundTime+0x13c>)
 8013baa:	4293      	cmp	r3, r2
 8013bac:	d802      	bhi.n	8013bb4 <USB_SetTurnaroundTime+0xc4>
    {
      /* hclk Clock Range between 24-27.7 MHz */
      UsbTrd = 0x8U;
 8013bae:	2308      	movs	r3, #8
 8013bb0:	617b      	str	r3, [r7, #20]
 8013bb2:	e015      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else if ((hclk >= 27700000U) && (hclk < 32000000U))
 8013bb4:	68bb      	ldr	r3, [r7, #8]
 8013bb6:	4a1d      	ldr	r2, [pc, #116]	@ (8013c2c <USB_SetTurnaroundTime+0x13c>)
 8013bb8:	4293      	cmp	r3, r2
 8013bba:	d906      	bls.n	8013bca <USB_SetTurnaroundTime+0xda>
 8013bbc:	68bb      	ldr	r3, [r7, #8]
 8013bbe:	4a1c      	ldr	r2, [pc, #112]	@ (8013c30 <USB_SetTurnaroundTime+0x140>)
 8013bc0:	4293      	cmp	r3, r2
 8013bc2:	d202      	bcs.n	8013bca <USB_SetTurnaroundTime+0xda>
    {
      /* hclk Clock Range between 27.7-32 MHz */
      UsbTrd = 0x7U;
 8013bc4:	2307      	movs	r3, #7
 8013bc6:	617b      	str	r3, [r7, #20]
 8013bc8:	e00a      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
    else /* if(hclk >= 32000000) */
    {
      /* hclk Clock Range between 32-200 MHz */
      UsbTrd = 0x6U;
 8013bca:	2306      	movs	r3, #6
 8013bcc:	617b      	str	r3, [r7, #20]
 8013bce:	e007      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
    }
  }
  else if (speed == USBD_HS_SPEED)
 8013bd0:	79fb      	ldrb	r3, [r7, #7]
 8013bd2:	2b00      	cmp	r3, #0
 8013bd4:	d102      	bne.n	8013bdc <USB_SetTurnaroundTime+0xec>
  {
    UsbTrd = USBD_HS_TRDT_VALUE;
 8013bd6:	2309      	movs	r3, #9
 8013bd8:	617b      	str	r3, [r7, #20]
 8013bda:	e001      	b.n	8013be0 <USB_SetTurnaroundTime+0xf0>
  }
  else
  {
    UsbTrd = USBD_DEFAULT_TRDT_VALUE;
 8013bdc:	2309      	movs	r3, #9
 8013bde:	617b      	str	r3, [r7, #20]
  }

  USBx->GUSBCFG &= ~USB_OTG_GUSBCFG_TRDT;
 8013be0:	68fb      	ldr	r3, [r7, #12]
 8013be2:	68db      	ldr	r3, [r3, #12]
 8013be4:	f423 5270 	bic.w	r2, r3, #15360	@ 0x3c00
 8013be8:	68fb      	ldr	r3, [r7, #12]
 8013bea:	60da      	str	r2, [r3, #12]
  USBx->GUSBCFG |= (uint32_t)((UsbTrd << 10) & USB_OTG_GUSBCFG_TRDT);
 8013bec:	68fb      	ldr	r3, [r7, #12]
 8013bee:	68da      	ldr	r2, [r3, #12]
 8013bf0:	697b      	ldr	r3, [r7, #20]
 8013bf2:	029b      	lsls	r3, r3, #10
 8013bf4:	f403 5370 	and.w	r3, r3, #15360	@ 0x3c00
 8013bf8:	431a      	orrs	r2, r3
 8013bfa:	68fb      	ldr	r3, [r7, #12]
 8013bfc:	60da      	str	r2, [r3, #12]

  return HAL_OK;
 8013bfe:	2300      	movs	r3, #0
}
 8013c00:	4618      	mov	r0, r3
 8013c02:	371c      	adds	r7, #28
 8013c04:	46bd      	mov	sp, r7
 8013c06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c0a:	4770      	bx	lr
 8013c0c:	00d8acbf 	.word	0x00d8acbf
 8013c10:	00e4e1c0 	.word	0x00e4e1c0
 8013c14:	00f42400 	.word	0x00f42400
 8013c18:	01067380 	.word	0x01067380
 8013c1c:	011a499f 	.word	0x011a499f
 8013c20:	01312cff 	.word	0x01312cff
 8013c24:	014ca43f 	.word	0x014ca43f
 8013c28:	016e3600 	.word	0x016e3600
 8013c2c:	01a6ab1f 	.word	0x01a6ab1f
 8013c30:	01e84800 	.word	0x01e84800

08013c34 <USB_EnableGlobalInt>:
  *         Enables the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8013c34:	b480      	push	{r7}
 8013c36:	b083      	sub	sp, #12
 8013c38:	af00      	add	r7, sp, #0
 8013c3a:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8013c3c:	687b      	ldr	r3, [r7, #4]
 8013c3e:	689b      	ldr	r3, [r3, #8]
 8013c40:	f043 0201 	orr.w	r2, r3, #1
 8013c44:	687b      	ldr	r3, [r7, #4]
 8013c46:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8013c48:	2300      	movs	r3, #0
}
 8013c4a:	4618      	mov	r0, r3
 8013c4c:	370c      	adds	r7, #12
 8013c4e:	46bd      	mov	sp, r7
 8013c50:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c54:	4770      	bx	lr

08013c56 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8013c56:	b480      	push	{r7}
 8013c58:	b083      	sub	sp, #12
 8013c5a:	af00      	add	r7, sp, #0
 8013c5c:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8013c5e:	687b      	ldr	r3, [r7, #4]
 8013c60:	689b      	ldr	r3, [r3, #8]
 8013c62:	f023 0201 	bic.w	r2, r3, #1
 8013c66:	687b      	ldr	r3, [r7, #4]
 8013c68:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8013c6a:	2300      	movs	r3, #0
}
 8013c6c:	4618      	mov	r0, r3
 8013c6e:	370c      	adds	r7, #12
 8013c70:	46bd      	mov	sp, r7
 8013c72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c76:	4770      	bx	lr

08013c78 <USB_SetCurrentMode>:
  *            @arg USB_DEVICE_MODE Peripheral mode
  *            @arg USB_HOST_MODE Host mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 8013c78:	b580      	push	{r7, lr}
 8013c7a:	b084      	sub	sp, #16
 8013c7c:	af00      	add	r7, sp, #0
 8013c7e:	6078      	str	r0, [r7, #4]
 8013c80:	460b      	mov	r3, r1
 8013c82:	70fb      	strb	r3, [r7, #3]
  uint32_t ms = 0U;
 8013c84:	2300      	movs	r3, #0
 8013c86:	60fb      	str	r3, [r7, #12]

  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8013c88:	687b      	ldr	r3, [r7, #4]
 8013c8a:	68db      	ldr	r3, [r3, #12]
 8013c8c:	f023 42c0 	bic.w	r2, r3, #1610612736	@ 0x60000000
 8013c90:	687b      	ldr	r3, [r7, #4]
 8013c92:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 8013c94:	78fb      	ldrb	r3, [r7, #3]
 8013c96:	2b01      	cmp	r3, #1
 8013c98:	d115      	bne.n	8013cc6 <USB_SetCurrentMode+0x4e>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8013c9a:	687b      	ldr	r3, [r7, #4]
 8013c9c:	68db      	ldr	r3, [r3, #12]
 8013c9e:	f043 5200 	orr.w	r2, r3, #536870912	@ 0x20000000
 8013ca2:	687b      	ldr	r3, [r7, #4]
 8013ca4:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 8013ca6:	200a      	movs	r0, #10
 8013ca8:	f7f4 fff8 	bl	8008c9c <HAL_Delay>
      ms += 10U;
 8013cac:	68fb      	ldr	r3, [r7, #12]
 8013cae:	330a      	adds	r3, #10
 8013cb0:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_HOST_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8013cb2:	6878      	ldr	r0, [r7, #4]
 8013cb4:	f001 f939 	bl	8014f2a <USB_GetMode>
 8013cb8:	4603      	mov	r3, r0
 8013cba:	2b01      	cmp	r3, #1
 8013cbc:	d01e      	beq.n	8013cfc <USB_SetCurrentMode+0x84>
 8013cbe:	68fb      	ldr	r3, [r7, #12]
 8013cc0:	2bc7      	cmp	r3, #199	@ 0xc7
 8013cc2:	d9f0      	bls.n	8013ca6 <USB_SetCurrentMode+0x2e>
 8013cc4:	e01a      	b.n	8013cfc <USB_SetCurrentMode+0x84>
  }
  else if (mode == USB_DEVICE_MODE)
 8013cc6:	78fb      	ldrb	r3, [r7, #3]
 8013cc8:	2b00      	cmp	r3, #0
 8013cca:	d115      	bne.n	8013cf8 <USB_SetCurrentMode+0x80>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8013ccc:	687b      	ldr	r3, [r7, #4]
 8013cce:	68db      	ldr	r3, [r3, #12]
 8013cd0:	f043 4280 	orr.w	r2, r3, #1073741824	@ 0x40000000
 8013cd4:	687b      	ldr	r3, [r7, #4]
 8013cd6:	60da      	str	r2, [r3, #12]

    do
    {
      HAL_Delay(10U);
 8013cd8:	200a      	movs	r0, #10
 8013cda:	f7f4 ffdf 	bl	8008c9c <HAL_Delay>
      ms += 10U;
 8013cde:	68fb      	ldr	r3, [r7, #12]
 8013ce0:	330a      	adds	r3, #10
 8013ce2:	60fb      	str	r3, [r7, #12]
    } while ((USB_GetMode(USBx) != (uint32_t)USB_DEVICE_MODE) && (ms < HAL_USB_CURRENT_MODE_MAX_DELAY_MS));
 8013ce4:	6878      	ldr	r0, [r7, #4]
 8013ce6:	f001 f920 	bl	8014f2a <USB_GetMode>
 8013cea:	4603      	mov	r3, r0
 8013cec:	2b00      	cmp	r3, #0
 8013cee:	d005      	beq.n	8013cfc <USB_SetCurrentMode+0x84>
 8013cf0:	68fb      	ldr	r3, [r7, #12]
 8013cf2:	2bc7      	cmp	r3, #199	@ 0xc7
 8013cf4:	d9f0      	bls.n	8013cd8 <USB_SetCurrentMode+0x60>
 8013cf6:	e001      	b.n	8013cfc <USB_SetCurrentMode+0x84>
  }
  else
  {
    return HAL_ERROR;
 8013cf8:	2301      	movs	r3, #1
 8013cfa:	e005      	b.n	8013d08 <USB_SetCurrentMode+0x90>
  }

  if (ms == HAL_USB_CURRENT_MODE_MAX_DELAY_MS)
 8013cfc:	68fb      	ldr	r3, [r7, #12]
 8013cfe:	2bc8      	cmp	r3, #200	@ 0xc8
 8013d00:	d101      	bne.n	8013d06 <USB_SetCurrentMode+0x8e>
  {
    return HAL_ERROR;
 8013d02:	2301      	movs	r3, #1
 8013d04:	e000      	b.n	8013d08 <USB_SetCurrentMode+0x90>
  }

  return HAL_OK;
 8013d06:	2300      	movs	r3, #0
}
 8013d08:	4618      	mov	r0, r3
 8013d0a:	3710      	adds	r7, #16
 8013d0c:	46bd      	mov	sp, r7
 8013d0e:	bd80      	pop	{r7, pc}

08013d10 <USB_DevInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8013d10:	b084      	sub	sp, #16
 8013d12:	b580      	push	{r7, lr}
 8013d14:	b086      	sub	sp, #24
 8013d16:	af00      	add	r7, sp, #0
 8013d18:	6078      	str	r0, [r7, #4]
 8013d1a:	f107 0024 	add.w	r0, r7, #36	@ 0x24
 8013d1e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret = HAL_OK;
 8013d22:	2300      	movs	r3, #0
 8013d24:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8013d26:	687b      	ldr	r3, [r7, #4]
 8013d28:	60fb      	str	r3, [r7, #12]
  uint32_t i;

  for (i = 0U; i < 15U; i++)
 8013d2a:	2300      	movs	r3, #0
 8013d2c:	613b      	str	r3, [r7, #16]
 8013d2e:	e009      	b.n	8013d44 <USB_DevInit+0x34>
  {
    USBx->DIEPTXF[i] = 0U;
 8013d30:	687a      	ldr	r2, [r7, #4]
 8013d32:	693b      	ldr	r3, [r7, #16]
 8013d34:	3340      	adds	r3, #64	@ 0x40
 8013d36:	009b      	lsls	r3, r3, #2
 8013d38:	4413      	add	r3, r2
 8013d3a:	2200      	movs	r2, #0
 8013d3c:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < 15U; i++)
 8013d3e:	693b      	ldr	r3, [r7, #16]
 8013d40:	3301      	adds	r3, #1
 8013d42:	613b      	str	r3, [r7, #16]
 8013d44:	693b      	ldr	r3, [r7, #16]
 8013d46:	2b0e      	cmp	r3, #14
 8013d48:	d9f2      	bls.n	8013d30 <USB_DevInit+0x20>
    /* Enable HW VBUS sensing */
    USBx->GCCFG |= USB_OTG_GCCFG_VBDEN;
  }
#else
  /* VBUS Sensing setup */
  if (cfg.vbus_sensing_enable == 0U)
 8013d4a:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8013d4e:	2b00      	cmp	r3, #0
 8013d50:	d11c      	bne.n	8013d8c <USB_DevInit+0x7c>
  {
    /*
     * Disable HW VBUS sensing. VBUS is internally considered to be always
     * at VBUS-Valid level (5V).
     */
    USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8013d52:	68fb      	ldr	r3, [r7, #12]
 8013d54:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8013d58:	685b      	ldr	r3, [r3, #4]
 8013d5a:	68fa      	ldr	r2, [r7, #12]
 8013d5c:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8013d60:	f043 0302 	orr.w	r3, r3, #2
 8013d64:	6053      	str	r3, [r2, #4]
    USBx->GCCFG |= USB_OTG_GCCFG_NOVBUSSENS;
 8013d66:	687b      	ldr	r3, [r7, #4]
 8013d68:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013d6a:	f443 1200 	orr.w	r2, r3, #2097152	@ 0x200000
 8013d6e:	687b      	ldr	r3, [r7, #4]
 8013d70:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSBSEN;
 8013d72:	687b      	ldr	r3, [r7, #4]
 8013d74:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013d76:	f423 2200 	bic.w	r2, r3, #524288	@ 0x80000
 8013d7a:	687b      	ldr	r3, [r7, #4]
 8013d7c:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG &= ~USB_OTG_GCCFG_VBUSASEN;
 8013d7e:	687b      	ldr	r3, [r7, #4]
 8013d80:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013d82:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
 8013d86:	687b      	ldr	r3, [r7, #4]
 8013d88:	639a      	str	r2, [r3, #56]	@ 0x38
 8013d8a:	e00b      	b.n	8013da4 <USB_DevInit+0x94>
  }
  else
  {
    /* Enable HW VBUS sensing */
    USBx->GCCFG &= ~USB_OTG_GCCFG_NOVBUSSENS;
 8013d8c:	687b      	ldr	r3, [r7, #4]
 8013d8e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013d90:	f423 1200 	bic.w	r2, r3, #2097152	@ 0x200000
 8013d94:	687b      	ldr	r3, [r7, #4]
 8013d96:	639a      	str	r2, [r3, #56]	@ 0x38
    USBx->GCCFG |= USB_OTG_GCCFG_VBUSBSEN;
 8013d98:	687b      	ldr	r3, [r7, #4]
 8013d9a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8013d9c:	f443 2200 	orr.w	r2, r3, #524288	@ 0x80000
 8013da0:	687b      	ldr	r3, [r7, #4]
 8013da2:	639a      	str	r2, [r3, #56]	@ 0x38
#endif /* defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx) || defined(STM32F412Zx) ||
          defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) || defined(STM32F413xx) ||
          defined(STM32F423xx) */

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8013da4:	68fb      	ldr	r3, [r7, #12]
 8013da6:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8013daa:	461a      	mov	r2, r3
 8013dac:	2300      	movs	r3, #0
 8013dae:	6013      	str	r3, [r2, #0]

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8013db0:	f897 3029 	ldrb.w	r3, [r7, #41]	@ 0x29
 8013db4:	2b01      	cmp	r3, #1
 8013db6:	d10d      	bne.n	8013dd4 <USB_DevInit+0xc4>
  {
    if (cfg.speed == USBD_HS_SPEED)
 8013db8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8013dbc:	2b00      	cmp	r3, #0
 8013dbe:	d104      	bne.n	8013dca <USB_DevInit+0xba>
    {
      /* Set Core speed to High speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH);
 8013dc0:	2100      	movs	r1, #0
 8013dc2:	6878      	ldr	r0, [r7, #4]
 8013dc4:	f000 f968 	bl	8014098 <USB_SetDevSpeed>
 8013dc8:	e008      	b.n	8013ddc <USB_DevInit+0xcc>
    }
    else
    {
      /* Set Core speed to Full speed mode */
      (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_HIGH_IN_FULL);
 8013dca:	2101      	movs	r1, #1
 8013dcc:	6878      	ldr	r0, [r7, #4]
 8013dce:	f000 f963 	bl	8014098 <USB_SetDevSpeed>
 8013dd2:	e003      	b.n	8013ddc <USB_DevInit+0xcc>
    }
  }
  else
  {
    /* Set Core speed to Full speed mode */
    (void)USB_SetDevSpeed(USBx, USB_OTG_SPEED_FULL);
 8013dd4:	2103      	movs	r1, #3
 8013dd6:	6878      	ldr	r0, [r7, #4]
 8013dd8:	f000 f95e 	bl	8014098 <USB_SetDevSpeed>
  }

  /* Flush the FIFOs */
  if (USB_FlushTxFifo(USBx, 0x10U) != HAL_OK) /* all Tx FIFOs */
 8013ddc:	2110      	movs	r1, #16
 8013dde:	6878      	ldr	r0, [r7, #4]
 8013de0:	f000 f8fa 	bl	8013fd8 <USB_FlushTxFifo>
 8013de4:	4603      	mov	r3, r0
 8013de6:	2b00      	cmp	r3, #0
 8013de8:	d001      	beq.n	8013dee <USB_DevInit+0xde>
  {
    ret = HAL_ERROR;
 8013dea:	2301      	movs	r3, #1
 8013dec:	75fb      	strb	r3, [r7, #23]
  }

  if (USB_FlushRxFifo(USBx) != HAL_OK)
 8013dee:	6878      	ldr	r0, [r7, #4]
 8013df0:	f000 f924 	bl	801403c <USB_FlushRxFifo>
 8013df4:	4603      	mov	r3, r0
 8013df6:	2b00      	cmp	r3, #0
 8013df8:	d001      	beq.n	8013dfe <USB_DevInit+0xee>
  {
    ret = HAL_ERROR;
 8013dfa:	2301      	movs	r3, #1
 8013dfc:	75fb      	strb	r3, [r7, #23]
  }

  /* Clear all pending Device Interrupts */
  USBx_DEVICE->DIEPMSK = 0U;
 8013dfe:	68fb      	ldr	r3, [r7, #12]
 8013e00:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8013e04:	461a      	mov	r2, r3
 8013e06:	2300      	movs	r3, #0
 8013e08:	6113      	str	r3, [r2, #16]
  USBx_DEVICE->DOEPMSK = 0U;
 8013e0a:	68fb      	ldr	r3, [r7, #12]
 8013e0c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8013e10:	461a      	mov	r2, r3
 8013e12:	2300      	movs	r3, #0
 8013e14:	6153      	str	r3, [r2, #20]
  USBx_DEVICE->DAINTMSK = 0U;
 8013e16:	68fb      	ldr	r3, [r7, #12]
 8013e18:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8013e1c:	461a      	mov	r2, r3
 8013e1e:	2300      	movs	r3, #0
 8013e20:	61d3      	str	r3, [r2, #28]

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8013e22:	2300      	movs	r3, #0
 8013e24:	613b      	str	r3, [r7, #16]
 8013e26:	e043      	b.n	8013eb0 <USB_DevInit+0x1a0>
  {
    if ((USBx_INEP(i)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8013e28:	693b      	ldr	r3, [r7, #16]
 8013e2a:	015a      	lsls	r2, r3, #5
 8013e2c:	68fb      	ldr	r3, [r7, #12]
 8013e2e:	4413      	add	r3, r2
 8013e30:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8013e34:	681b      	ldr	r3, [r3, #0]
 8013e36:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8013e3a:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8013e3e:	d118      	bne.n	8013e72 <USB_DevInit+0x162>
    {
      if (i == 0U)
 8013e40:	693b      	ldr	r3, [r7, #16]
 8013e42:	2b00      	cmp	r3, #0
 8013e44:	d10a      	bne.n	8013e5c <USB_DevInit+0x14c>
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_SNAK;
 8013e46:	693b      	ldr	r3, [r7, #16]
 8013e48:	015a      	lsls	r2, r3, #5
 8013e4a:	68fb      	ldr	r3, [r7, #12]
 8013e4c:	4413      	add	r3, r2
 8013e4e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8013e52:	461a      	mov	r2, r3
 8013e54:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8013e58:	6013      	str	r3, [r2, #0]
 8013e5a:	e013      	b.n	8013e84 <USB_DevInit+0x174>
      }
      else
      {
        USBx_INEP(i)->DIEPCTL = USB_OTG_DIEPCTL_EPDIS | USB_OTG_DIEPCTL_SNAK;
 8013e5c:	693b      	ldr	r3, [r7, #16]
 8013e5e:	015a      	lsls	r2, r3, #5
 8013e60:	68fb      	ldr	r3, [r7, #12]
 8013e62:	4413      	add	r3, r2
 8013e64:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8013e68:	461a      	mov	r2, r3
 8013e6a:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8013e6e:	6013      	str	r3, [r2, #0]
 8013e70:	e008      	b.n	8013e84 <USB_DevInit+0x174>
      }
    }
    else
    {
      USBx_INEP(i)->DIEPCTL = 0U;
 8013e72:	693b      	ldr	r3, [r7, #16]
 8013e74:	015a      	lsls	r2, r3, #5
 8013e76:	68fb      	ldr	r3, [r7, #12]
 8013e78:	4413      	add	r3, r2
 8013e7a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8013e7e:	461a      	mov	r2, r3
 8013e80:	2300      	movs	r3, #0
 8013e82:	6013      	str	r3, [r2, #0]
    }

    USBx_INEP(i)->DIEPTSIZ = 0U;
 8013e84:	693b      	ldr	r3, [r7, #16]
 8013e86:	015a      	lsls	r2, r3, #5
 8013e88:	68fb      	ldr	r3, [r7, #12]
 8013e8a:	4413      	add	r3, r2
 8013e8c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8013e90:	461a      	mov	r2, r3
 8013e92:	2300      	movs	r3, #0
 8013e94:	6113      	str	r3, [r2, #16]
    USBx_INEP(i)->DIEPINT  = 0xFB7FU;
 8013e96:	693b      	ldr	r3, [r7, #16]
 8013e98:	015a      	lsls	r2, r3, #5
 8013e9a:	68fb      	ldr	r3, [r7, #12]
 8013e9c:	4413      	add	r3, r2
 8013e9e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8013ea2:	461a      	mov	r2, r3
 8013ea4:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8013ea8:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8013eaa:	693b      	ldr	r3, [r7, #16]
 8013eac:	3301      	adds	r3, #1
 8013eae:	613b      	str	r3, [r7, #16]
 8013eb0:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8013eb4:	461a      	mov	r2, r3
 8013eb6:	693b      	ldr	r3, [r7, #16]
 8013eb8:	4293      	cmp	r3, r2
 8013eba:	d3b5      	bcc.n	8013e28 <USB_DevInit+0x118>
  }

  for (i = 0U; i < cfg.dev_endpoints; i++)
 8013ebc:	2300      	movs	r3, #0
 8013ebe:	613b      	str	r3, [r7, #16]
 8013ec0:	e043      	b.n	8013f4a <USB_DevInit+0x23a>
  {
    if ((USBx_OUTEP(i)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8013ec2:	693b      	ldr	r3, [r7, #16]
 8013ec4:	015a      	lsls	r2, r3, #5
 8013ec6:	68fb      	ldr	r3, [r7, #12]
 8013ec8:	4413      	add	r3, r2
 8013eca:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8013ece:	681b      	ldr	r3, [r3, #0]
 8013ed0:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8013ed4:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8013ed8:	d118      	bne.n	8013f0c <USB_DevInit+0x1fc>
    {
      if (i == 0U)
 8013eda:	693b      	ldr	r3, [r7, #16]
 8013edc:	2b00      	cmp	r3, #0
 8013ede:	d10a      	bne.n	8013ef6 <USB_DevInit+0x1e6>
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_SNAK;
 8013ee0:	693b      	ldr	r3, [r7, #16]
 8013ee2:	015a      	lsls	r2, r3, #5
 8013ee4:	68fb      	ldr	r3, [r7, #12]
 8013ee6:	4413      	add	r3, r2
 8013ee8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8013eec:	461a      	mov	r2, r3
 8013eee:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
 8013ef2:	6013      	str	r3, [r2, #0]
 8013ef4:	e013      	b.n	8013f1e <USB_DevInit+0x20e>
      }
      else
      {
        USBx_OUTEP(i)->DOEPCTL = USB_OTG_DOEPCTL_EPDIS | USB_OTG_DOEPCTL_SNAK;
 8013ef6:	693b      	ldr	r3, [r7, #16]
 8013ef8:	015a      	lsls	r2, r3, #5
 8013efa:	68fb      	ldr	r3, [r7, #12]
 8013efc:	4413      	add	r3, r2
 8013efe:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8013f02:	461a      	mov	r2, r3
 8013f04:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8013f08:	6013      	str	r3, [r2, #0]
 8013f0a:	e008      	b.n	8013f1e <USB_DevInit+0x20e>
      }
    }
    else
    {
      USBx_OUTEP(i)->DOEPCTL = 0U;
 8013f0c:	693b      	ldr	r3, [r7, #16]
 8013f0e:	015a      	lsls	r2, r3, #5
 8013f10:	68fb      	ldr	r3, [r7, #12]
 8013f12:	4413      	add	r3, r2
 8013f14:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8013f18:	461a      	mov	r2, r3
 8013f1a:	2300      	movs	r3, #0
 8013f1c:	6013      	str	r3, [r2, #0]
    }

    USBx_OUTEP(i)->DOEPTSIZ = 0U;
 8013f1e:	693b      	ldr	r3, [r7, #16]
 8013f20:	015a      	lsls	r2, r3, #5
 8013f22:	68fb      	ldr	r3, [r7, #12]
 8013f24:	4413      	add	r3, r2
 8013f26:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8013f2a:	461a      	mov	r2, r3
 8013f2c:	2300      	movs	r3, #0
 8013f2e:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(i)->DOEPINT  = 0xFB7FU;
 8013f30:	693b      	ldr	r3, [r7, #16]
 8013f32:	015a      	lsls	r2, r3, #5
 8013f34:	68fb      	ldr	r3, [r7, #12]
 8013f36:	4413      	add	r3, r2
 8013f38:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8013f3c:	461a      	mov	r2, r3
 8013f3e:	f64f 337f 	movw	r3, #64383	@ 0xfb7f
 8013f42:	6093      	str	r3, [r2, #8]
  for (i = 0U; i < cfg.dev_endpoints; i++)
 8013f44:	693b      	ldr	r3, [r7, #16]
 8013f46:	3301      	adds	r3, #1
 8013f48:	613b      	str	r3, [r7, #16]
 8013f4a:	f897 3024 	ldrb.w	r3, [r7, #36]	@ 0x24
 8013f4e:	461a      	mov	r2, r3
 8013f50:	693b      	ldr	r3, [r7, #16]
 8013f52:	4293      	cmp	r3, r2
 8013f54:	d3b5      	bcc.n	8013ec2 <USB_DevInit+0x1b2>
  }

  USBx_DEVICE->DIEPMSK &= ~(USB_OTG_DIEPMSK_TXFURM);
 8013f56:	68fb      	ldr	r3, [r7, #12]
 8013f58:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8013f5c:	691b      	ldr	r3, [r3, #16]
 8013f5e:	68fa      	ldr	r2, [r7, #12]
 8013f60:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8013f64:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8013f68:	6113      	str	r3, [r2, #16]

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 8013f6a:	687b      	ldr	r3, [r7, #4]
 8013f6c:	2200      	movs	r2, #0
 8013f6e:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xBFFFFFFFU;
 8013f70:	687b      	ldr	r3, [r7, #4]
 8013f72:	f06f 4280 	mvn.w	r2, #1073741824	@ 0x40000000
 8013f76:	615a      	str	r2, [r3, #20]

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 8013f78:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8013f7c:	2b00      	cmp	r3, #0
 8013f7e:	d105      	bne.n	8013f8c <USB_DevInit+0x27c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8013f80:	687b      	ldr	r3, [r7, #4]
 8013f82:	699b      	ldr	r3, [r3, #24]
 8013f84:	f043 0210 	orr.w	r2, r3, #16
 8013f88:	687b      	ldr	r3, [r7, #4]
 8013f8a:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Device mode ONLY */
  USBx->GINTMSK |= USB_OTG_GINTMSK_USBSUSPM | USB_OTG_GINTMSK_USBRST |
 8013f8c:	687b      	ldr	r3, [r7, #4]
 8013f8e:	699a      	ldr	r2, [r3, #24]
 8013f90:	4b10      	ldr	r3, [pc, #64]	@ (8013fd4 <USB_DevInit+0x2c4>)
 8013f92:	4313      	orrs	r3, r2
 8013f94:	687a      	ldr	r2, [r7, #4]
 8013f96:	6193      	str	r3, [r2, #24]
                   USB_OTG_GINTMSK_ENUMDNEM | USB_OTG_GINTMSK_IEPINT |
                   USB_OTG_GINTMSK_OEPINT   | USB_OTG_GINTMSK_IISOIXFRM |
                   USB_OTG_GINTMSK_PXFRM_IISOOXFRM | USB_OTG_GINTMSK_WUIM;

  if (cfg.Sof_enable != 0U)
 8013f98:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 8013f9c:	2b00      	cmp	r3, #0
 8013f9e:	d005      	beq.n	8013fac <USB_DevInit+0x29c>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_SOFM;
 8013fa0:	687b      	ldr	r3, [r7, #4]
 8013fa2:	699b      	ldr	r3, [r3, #24]
 8013fa4:	f043 0208 	orr.w	r2, r3, #8
 8013fa8:	687b      	ldr	r3, [r7, #4]
 8013faa:	619a      	str	r2, [r3, #24]
  }

  if (cfg.vbus_sensing_enable == 1U)
 8013fac:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8013fb0:	2b01      	cmp	r3, #1
 8013fb2:	d107      	bne.n	8013fc4 <USB_DevInit+0x2b4>
  {
    USBx->GINTMSK |= (USB_OTG_GINTMSK_SRQIM | USB_OTG_GINTMSK_OTGINT);
 8013fb4:	687b      	ldr	r3, [r7, #4]
 8013fb6:	699b      	ldr	r3, [r3, #24]
 8013fb8:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8013fbc:	f043 0304 	orr.w	r3, r3, #4
 8013fc0:	687a      	ldr	r2, [r7, #4]
 8013fc2:	6193      	str	r3, [r2, #24]
  }

  return ret;
 8013fc4:	7dfb      	ldrb	r3, [r7, #23]
}
 8013fc6:	4618      	mov	r0, r3
 8013fc8:	3718      	adds	r7, #24
 8013fca:	46bd      	mov	sp, r7
 8013fcc:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8013fd0:	b004      	add	sp, #16
 8013fd2:	4770      	bx	lr
 8013fd4:	803c3800 	.word	0x803c3800

08013fd8 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8013fd8:	b480      	push	{r7}
 8013fda:	b085      	sub	sp, #20
 8013fdc:	af00      	add	r7, sp, #0
 8013fde:	6078      	str	r0, [r7, #4]
 8013fe0:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8013fe2:	2300      	movs	r3, #0
 8013fe4:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8013fe6:	68fb      	ldr	r3, [r7, #12]
 8013fe8:	3301      	adds	r3, #1
 8013fea:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8013fec:	68fb      	ldr	r3, [r7, #12]
 8013fee:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8013ff2:	d901      	bls.n	8013ff8 <USB_FlushTxFifo+0x20>
    {
      return HAL_TIMEOUT;
 8013ff4:	2303      	movs	r3, #3
 8013ff6:	e01b      	b.n	8014030 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8013ff8:	687b      	ldr	r3, [r7, #4]
 8013ffa:	691b      	ldr	r3, [r3, #16]
 8013ffc:	2b00      	cmp	r3, #0
 8013ffe:	daf2      	bge.n	8013fe6 <USB_FlushTxFifo+0xe>

  /* Flush TX Fifo */
  count = 0U;
 8014000:	2300      	movs	r3, #0
 8014002:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8014004:	683b      	ldr	r3, [r7, #0]
 8014006:	019b      	lsls	r3, r3, #6
 8014008:	f043 0220 	orr.w	r2, r3, #32
 801400c:	687b      	ldr	r3, [r7, #4]
 801400e:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 8014010:	68fb      	ldr	r3, [r7, #12]
 8014012:	3301      	adds	r3, #1
 8014014:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8014016:	68fb      	ldr	r3, [r7, #12]
 8014018:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801401c:	d901      	bls.n	8014022 <USB_FlushTxFifo+0x4a>
    {
      return HAL_TIMEOUT;
 801401e:	2303      	movs	r3, #3
 8014020:	e006      	b.n	8014030 <USB_FlushTxFifo+0x58>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8014022:	687b      	ldr	r3, [r7, #4]
 8014024:	691b      	ldr	r3, [r3, #16]
 8014026:	f003 0320 	and.w	r3, r3, #32
 801402a:	2b20      	cmp	r3, #32
 801402c:	d0f0      	beq.n	8014010 <USB_FlushTxFifo+0x38>

  return HAL_OK;
 801402e:	2300      	movs	r3, #0
}
 8014030:	4618      	mov	r0, r3
 8014032:	3714      	adds	r7, #20
 8014034:	46bd      	mov	sp, r7
 8014036:	f85d 7b04 	ldr.w	r7, [sp], #4
 801403a:	4770      	bx	lr

0801403c <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo  Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 801403c:	b480      	push	{r7}
 801403e:	b085      	sub	sp, #20
 8014040:	af00      	add	r7, sp, #0
 8014042:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8014044:	2300      	movs	r3, #0
 8014046:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8014048:	68fb      	ldr	r3, [r7, #12]
 801404a:	3301      	adds	r3, #1
 801404c:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 801404e:	68fb      	ldr	r3, [r7, #12]
 8014050:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8014054:	d901      	bls.n	801405a <USB_FlushRxFifo+0x1e>
    {
      return HAL_TIMEOUT;
 8014056:	2303      	movs	r3, #3
 8014058:	e018      	b.n	801408c <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 801405a:	687b      	ldr	r3, [r7, #4]
 801405c:	691b      	ldr	r3, [r3, #16]
 801405e:	2b00      	cmp	r3, #0
 8014060:	daf2      	bge.n	8014048 <USB_FlushRxFifo+0xc>

  /* Flush RX Fifo */
  count = 0U;
 8014062:	2300      	movs	r3, #0
 8014064:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8014066:	687b      	ldr	r3, [r7, #4]
 8014068:	2210      	movs	r2, #16
 801406a:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 801406c:	68fb      	ldr	r3, [r7, #12]
 801406e:	3301      	adds	r3, #1
 8014070:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8014072:	68fb      	ldr	r3, [r7, #12]
 8014074:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8014078:	d901      	bls.n	801407e <USB_FlushRxFifo+0x42>
    {
      return HAL_TIMEOUT;
 801407a:	2303      	movs	r3, #3
 801407c:	e006      	b.n	801408c <USB_FlushRxFifo+0x50>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 801407e:	687b      	ldr	r3, [r7, #4]
 8014080:	691b      	ldr	r3, [r3, #16]
 8014082:	f003 0310 	and.w	r3, r3, #16
 8014086:	2b10      	cmp	r3, #16
 8014088:	d0f0      	beq.n	801406c <USB_FlushRxFifo+0x30>

  return HAL_OK;
 801408a:	2300      	movs	r3, #0
}
 801408c:	4618      	mov	r0, r3
 801408e:	3714      	adds	r7, #20
 8014090:	46bd      	mov	sp, r7
 8014092:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014096:	4770      	bx	lr

08014098 <USB_SetDevSpeed>:
  *            @arg USB_OTG_SPEED_HIGH_IN_FULL: High speed core in Full Speed mode
  *            @arg USB_OTG_SPEED_FULL: Full speed mode
  * @retval  Hal status
  */
HAL_StatusTypeDef USB_SetDevSpeed(const USB_OTG_GlobalTypeDef *USBx, uint8_t speed)
{
 8014098:	b480      	push	{r7}
 801409a:	b085      	sub	sp, #20
 801409c:	af00      	add	r7, sp, #0
 801409e:	6078      	str	r0, [r7, #4]
 80140a0:	460b      	mov	r3, r1
 80140a2:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80140a4:	687b      	ldr	r3, [r7, #4]
 80140a6:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG |= speed;
 80140a8:	68fb      	ldr	r3, [r7, #12]
 80140aa:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80140ae:	681a      	ldr	r2, [r3, #0]
 80140b0:	78fb      	ldrb	r3, [r7, #3]
 80140b2:	68f9      	ldr	r1, [r7, #12]
 80140b4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80140b8:	4313      	orrs	r3, r2
 80140ba:	600b      	str	r3, [r1, #0]
  return HAL_OK;
 80140bc:	2300      	movs	r3, #0
}
 80140be:	4618      	mov	r0, r3
 80140c0:	3714      	adds	r7, #20
 80140c2:	46bd      	mov	sp, r7
 80140c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80140c8:	4770      	bx	lr

080140ca <USB_GetDevSpeed>:
  *          This parameter can be one of these values:
  *            @arg USBD_HS_SPEED: High speed mode
  *            @arg USBD_FS_SPEED: Full speed mode
  */
uint8_t USB_GetDevSpeed(const USB_OTG_GlobalTypeDef *USBx)
{
 80140ca:	b480      	push	{r7}
 80140cc:	b087      	sub	sp, #28
 80140ce:	af00      	add	r7, sp, #0
 80140d0:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80140d2:	687b      	ldr	r3, [r7, #4]
 80140d4:	613b      	str	r3, [r7, #16]
  uint8_t speed;
  uint32_t DevEnumSpeed = USBx_DEVICE->DSTS & USB_OTG_DSTS_ENUMSPD;
 80140d6:	693b      	ldr	r3, [r7, #16]
 80140d8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80140dc:	689b      	ldr	r3, [r3, #8]
 80140de:	f003 0306 	and.w	r3, r3, #6
 80140e2:	60fb      	str	r3, [r7, #12]

  if (DevEnumSpeed == DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ)
 80140e4:	68fb      	ldr	r3, [r7, #12]
 80140e6:	2b00      	cmp	r3, #0
 80140e8:	d102      	bne.n	80140f0 <USB_GetDevSpeed+0x26>
  {
    speed = USBD_HS_SPEED;
 80140ea:	2300      	movs	r3, #0
 80140ec:	75fb      	strb	r3, [r7, #23]
 80140ee:	e00a      	b.n	8014106 <USB_GetDevSpeed+0x3c>
  }
  else if ((DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ) ||
 80140f0:	68fb      	ldr	r3, [r7, #12]
 80140f2:	2b02      	cmp	r3, #2
 80140f4:	d002      	beq.n	80140fc <USB_GetDevSpeed+0x32>
 80140f6:	68fb      	ldr	r3, [r7, #12]
 80140f8:	2b06      	cmp	r3, #6
 80140fa:	d102      	bne.n	8014102 <USB_GetDevSpeed+0x38>
           (DevEnumSpeed == DSTS_ENUMSPD_FS_PHY_48MHZ))
  {
    speed = USBD_FS_SPEED;
 80140fc:	2302      	movs	r3, #2
 80140fe:	75fb      	strb	r3, [r7, #23]
 8014100:	e001      	b.n	8014106 <USB_GetDevSpeed+0x3c>
  }
  else
  {
    speed = 0xFU;
 8014102:	230f      	movs	r3, #15
 8014104:	75fb      	strb	r3, [r7, #23]
  }

  return speed;
 8014106:	7dfb      	ldrb	r3, [r7, #23]
}
 8014108:	4618      	mov	r0, r3
 801410a:	371c      	adds	r7, #28
 801410c:	46bd      	mov	sp, r7
 801410e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014112:	4770      	bx	lr

08014114 <USB_ActivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8014114:	b480      	push	{r7}
 8014116:	b085      	sub	sp, #20
 8014118:	af00      	add	r7, sp, #0
 801411a:	6078      	str	r0, [r7, #4]
 801411c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 801411e:	687b      	ldr	r3, [r7, #4]
 8014120:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8014122:	683b      	ldr	r3, [r7, #0]
 8014124:	781b      	ldrb	r3, [r3, #0]
 8014126:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8014128:	683b      	ldr	r3, [r7, #0]
 801412a:	785b      	ldrb	r3, [r3, #1]
 801412c:	2b01      	cmp	r3, #1
 801412e:	d13a      	bne.n	80141a6 <USB_ActivateEndpoint+0x92>
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK));
 8014130:	68fb      	ldr	r3, [r7, #12]
 8014132:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014136:	69da      	ldr	r2, [r3, #28]
 8014138:	683b      	ldr	r3, [r7, #0]
 801413a:	781b      	ldrb	r3, [r3, #0]
 801413c:	f003 030f 	and.w	r3, r3, #15
 8014140:	2101      	movs	r1, #1
 8014142:	fa01 f303 	lsl.w	r3, r1, r3
 8014146:	b29b      	uxth	r3, r3
 8014148:	68f9      	ldr	r1, [r7, #12]
 801414a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 801414e:	4313      	orrs	r3, r2
 8014150:	61cb      	str	r3, [r1, #28]

    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_USBAEP) == 0U)
 8014152:	68bb      	ldr	r3, [r7, #8]
 8014154:	015a      	lsls	r2, r3, #5
 8014156:	68fb      	ldr	r3, [r7, #12]
 8014158:	4413      	add	r3, r2
 801415a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801415e:	681b      	ldr	r3, [r3, #0]
 8014160:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8014164:	2b00      	cmp	r3, #0
 8014166:	d155      	bne.n	8014214 <USB_ActivateEndpoint+0x100>
    {
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8014168:	68bb      	ldr	r3, [r7, #8]
 801416a:	015a      	lsls	r2, r3, #5
 801416c:	68fb      	ldr	r3, [r7, #12]
 801416e:	4413      	add	r3, r2
 8014170:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014174:	681a      	ldr	r2, [r3, #0]
 8014176:	683b      	ldr	r3, [r7, #0]
 8014178:	689b      	ldr	r3, [r3, #8]
 801417a:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 801417e:	683b      	ldr	r3, [r7, #0]
 8014180:	791b      	ldrb	r3, [r3, #4]
 8014182:	049b      	lsls	r3, r3, #18
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 8014184:	4319      	orrs	r1, r3
                                   ((uint32_t)ep->type << 18) | (epnum << 22) |
 8014186:	68bb      	ldr	r3, [r7, #8]
 8014188:	059b      	lsls	r3, r3, #22
 801418a:	430b      	orrs	r3, r1
      USBx_INEP(epnum)->DIEPCTL |= (ep->maxpacket & USB_OTG_DIEPCTL_MPSIZ) |
 801418c:	4313      	orrs	r3, r2
 801418e:	68ba      	ldr	r2, [r7, #8]
 8014190:	0151      	lsls	r1, r2, #5
 8014192:	68fa      	ldr	r2, [r7, #12]
 8014194:	440a      	add	r2, r1
 8014196:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 801419a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801419e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 80141a2:	6013      	str	r3, [r2, #0]
 80141a4:	e036      	b.n	8014214 <USB_ActivateEndpoint+0x100>
                                   USB_OTG_DIEPCTL_USBAEP;
    }
  }
  else
  {
    USBx_DEVICE->DAINTMSK |= USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16);
 80141a6:	68fb      	ldr	r3, [r7, #12]
 80141a8:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80141ac:	69da      	ldr	r2, [r3, #28]
 80141ae:	683b      	ldr	r3, [r7, #0]
 80141b0:	781b      	ldrb	r3, [r3, #0]
 80141b2:	f003 030f 	and.w	r3, r3, #15
 80141b6:	2101      	movs	r1, #1
 80141b8:	fa01 f303 	lsl.w	r3, r1, r3
 80141bc:	041b      	lsls	r3, r3, #16
 80141be:	68f9      	ldr	r1, [r7, #12]
 80141c0:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80141c4:	4313      	orrs	r3, r2
 80141c6:	61cb      	str	r3, [r1, #28]

    if (((USBx_OUTEP(epnum)->DOEPCTL) & USB_OTG_DOEPCTL_USBAEP) == 0U)
 80141c8:	68bb      	ldr	r3, [r7, #8]
 80141ca:	015a      	lsls	r2, r3, #5
 80141cc:	68fb      	ldr	r3, [r7, #12]
 80141ce:	4413      	add	r3, r2
 80141d0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80141d4:	681b      	ldr	r3, [r3, #0]
 80141d6:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80141da:	2b00      	cmp	r3, #0
 80141dc:	d11a      	bne.n	8014214 <USB_ActivateEndpoint+0x100>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 80141de:	68bb      	ldr	r3, [r7, #8]
 80141e0:	015a      	lsls	r2, r3, #5
 80141e2:	68fb      	ldr	r3, [r7, #12]
 80141e4:	4413      	add	r3, r2
 80141e6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80141ea:	681a      	ldr	r2, [r3, #0]
 80141ec:	683b      	ldr	r3, [r7, #0]
 80141ee:	689b      	ldr	r3, [r3, #8]
 80141f0:	f3c3 010a 	ubfx	r1, r3, #0, #11
                                    ((uint32_t)ep->type << 18) |
 80141f4:	683b      	ldr	r3, [r7, #0]
 80141f6:	791b      	ldrb	r3, [r3, #4]
 80141f8:	049b      	lsls	r3, r3, #18
      USBx_OUTEP(epnum)->DOEPCTL |= (ep->maxpacket & USB_OTG_DOEPCTL_MPSIZ) |
 80141fa:	430b      	orrs	r3, r1
 80141fc:	4313      	orrs	r3, r2
 80141fe:	68ba      	ldr	r2, [r7, #8]
 8014200:	0151      	lsls	r1, r2, #5
 8014202:	68fa      	ldr	r2, [r7, #12]
 8014204:	440a      	add	r2, r1
 8014206:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 801420a:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801420e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 8014212:	6013      	str	r3, [r2, #0]
                                    USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_USBAEP;
    }
  }
  return HAL_OK;
 8014214:	2300      	movs	r3, #0
}
 8014216:	4618      	mov	r0, r3
 8014218:	3714      	adds	r7, #20
 801421a:	46bd      	mov	sp, r7
 801421c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014220:	4770      	bx	lr
	...

08014224 <USB_DeactivateEndpoint>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DeactivateEndpoint(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8014224:	b480      	push	{r7}
 8014226:	b085      	sub	sp, #20
 8014228:	af00      	add	r7, sp, #0
 801422a:	6078      	str	r0, [r7, #4]
 801422c:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 801422e:	687b      	ldr	r3, [r7, #4]
 8014230:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8014232:	683b      	ldr	r3, [r7, #0]
 8014234:	781b      	ldrb	r3, [r3, #0]
 8014236:	60bb      	str	r3, [r7, #8]

  /* Read DEPCTLn register */
  if (ep->is_in == 1U)
 8014238:	683b      	ldr	r3, [r7, #0]
 801423a:	785b      	ldrb	r3, [r3, #1]
 801423c:	2b01      	cmp	r3, #1
 801423e:	d161      	bne.n	8014304 <USB_DeactivateEndpoint+0xe0>
  {
    if ((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 8014240:	68bb      	ldr	r3, [r7, #8]
 8014242:	015a      	lsls	r2, r3, #5
 8014244:	68fb      	ldr	r3, [r7, #12]
 8014246:	4413      	add	r3, r2
 8014248:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801424c:	681b      	ldr	r3, [r3, #0]
 801424e:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8014252:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8014256:	d11f      	bne.n	8014298 <USB_DeactivateEndpoint+0x74>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SNAK;
 8014258:	68bb      	ldr	r3, [r7, #8]
 801425a:	015a      	lsls	r2, r3, #5
 801425c:	68fb      	ldr	r3, [r7, #12]
 801425e:	4413      	add	r3, r2
 8014260:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014264:	681b      	ldr	r3, [r3, #0]
 8014266:	68ba      	ldr	r2, [r7, #8]
 8014268:	0151      	lsls	r1, r2, #5
 801426a:	68fa      	ldr	r2, [r7, #12]
 801426c:	440a      	add	r2, r1
 801426e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014272:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8014276:	6013      	str	r3, [r2, #0]
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_EPDIS;
 8014278:	68bb      	ldr	r3, [r7, #8]
 801427a:	015a      	lsls	r2, r3, #5
 801427c:	68fb      	ldr	r3, [r7, #12]
 801427e:	4413      	add	r3, r2
 8014280:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014284:	681b      	ldr	r3, [r3, #0]
 8014286:	68ba      	ldr	r2, [r7, #8]
 8014288:	0151      	lsls	r1, r2, #5
 801428a:	68fa      	ldr	r2, [r7, #12]
 801428c:	440a      	add	r2, r1
 801428e:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014292:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8014296:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 8014298:	68fb      	ldr	r3, [r7, #12]
 801429a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 801429e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 80142a0:	683b      	ldr	r3, [r7, #0]
 80142a2:	781b      	ldrb	r3, [r3, #0]
 80142a4:	f003 030f 	and.w	r3, r3, #15
 80142a8:	2101      	movs	r1, #1
 80142aa:	fa01 f303 	lsl.w	r3, r1, r3
 80142ae:	b29b      	uxth	r3, r3
 80142b0:	43db      	mvns	r3, r3
 80142b2:	68f9      	ldr	r1, [r7, #12]
 80142b4:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80142b8:	4013      	ands	r3, r2
 80142ba:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_IEPM & (uint32_t)(1UL << (ep->num & EP_ADDR_MSK)));
 80142bc:	68fb      	ldr	r3, [r7, #12]
 80142be:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80142c2:	69da      	ldr	r2, [r3, #28]
 80142c4:	683b      	ldr	r3, [r7, #0]
 80142c6:	781b      	ldrb	r3, [r3, #0]
 80142c8:	f003 030f 	and.w	r3, r3, #15
 80142cc:	2101      	movs	r1, #1
 80142ce:	fa01 f303 	lsl.w	r3, r1, r3
 80142d2:	b29b      	uxth	r3, r3
 80142d4:	43db      	mvns	r3, r3
 80142d6:	68f9      	ldr	r1, [r7, #12]
 80142d8:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80142dc:	4013      	ands	r3, r2
 80142de:	61cb      	str	r3, [r1, #28]
    USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_USBAEP |
 80142e0:	68bb      	ldr	r3, [r7, #8]
 80142e2:	015a      	lsls	r2, r3, #5
 80142e4:	68fb      	ldr	r3, [r7, #12]
 80142e6:	4413      	add	r3, r2
 80142e8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80142ec:	681a      	ldr	r2, [r3, #0]
 80142ee:	68bb      	ldr	r3, [r7, #8]
 80142f0:	0159      	lsls	r1, r3, #5
 80142f2:	68fb      	ldr	r3, [r7, #12]
 80142f4:	440b      	add	r3, r1
 80142f6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80142fa:	4619      	mov	r1, r3
 80142fc:	4b35      	ldr	r3, [pc, #212]	@ (80143d4 <USB_DeactivateEndpoint+0x1b0>)
 80142fe:	4013      	ands	r3, r2
 8014300:	600b      	str	r3, [r1, #0]
 8014302:	e060      	b.n	80143c6 <USB_DeactivateEndpoint+0x1a2>
                                   USB_OTG_DIEPCTL_SD0PID_SEVNFRM |
                                   USB_OTG_DIEPCTL_EPTYP);
  }
  else
  {
    if ((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8014304:	68bb      	ldr	r3, [r7, #8]
 8014306:	015a      	lsls	r2, r3, #5
 8014308:	68fb      	ldr	r3, [r7, #12]
 801430a:	4413      	add	r3, r2
 801430c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014310:	681b      	ldr	r3, [r3, #0]
 8014312:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8014316:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 801431a:	d11f      	bne.n	801435c <USB_DeactivateEndpoint+0x138>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SNAK;
 801431c:	68bb      	ldr	r3, [r7, #8]
 801431e:	015a      	lsls	r2, r3, #5
 8014320:	68fb      	ldr	r3, [r7, #12]
 8014322:	4413      	add	r3, r2
 8014324:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014328:	681b      	ldr	r3, [r3, #0]
 801432a:	68ba      	ldr	r2, [r7, #8]
 801432c:	0151      	lsls	r1, r2, #5
 801432e:	68fa      	ldr	r2, [r7, #12]
 8014330:	440a      	add	r2, r1
 8014332:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014336:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 801433a:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_EPDIS;
 801433c:	68bb      	ldr	r3, [r7, #8]
 801433e:	015a      	lsls	r2, r3, #5
 8014340:	68fb      	ldr	r3, [r7, #12]
 8014342:	4413      	add	r3, r2
 8014344:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014348:	681b      	ldr	r3, [r3, #0]
 801434a:	68ba      	ldr	r2, [r7, #8]
 801434c:	0151      	lsls	r1, r2, #5
 801434e:	68fa      	ldr	r2, [r7, #12]
 8014350:	440a      	add	r2, r1
 8014352:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014356:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 801435a:	6013      	str	r3, [r2, #0]
    }

    USBx_DEVICE->DEACHMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 801435c:	68fb      	ldr	r3, [r7, #12]
 801435e:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014362:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 8014364:	683b      	ldr	r3, [r7, #0]
 8014366:	781b      	ldrb	r3, [r3, #0]
 8014368:	f003 030f 	and.w	r3, r3, #15
 801436c:	2101      	movs	r1, #1
 801436e:	fa01 f303 	lsl.w	r3, r1, r3
 8014372:	041b      	lsls	r3, r3, #16
 8014374:	43db      	mvns	r3, r3
 8014376:	68f9      	ldr	r1, [r7, #12]
 8014378:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 801437c:	4013      	ands	r3, r2
 801437e:	63cb      	str	r3, [r1, #60]	@ 0x3c
    USBx_DEVICE->DAINTMSK &= ~(USB_OTG_DAINTMSK_OEPM & ((uint32_t)(1UL << (ep->num & EP_ADDR_MSK)) << 16));
 8014380:	68fb      	ldr	r3, [r7, #12]
 8014382:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014386:	69da      	ldr	r2, [r3, #28]
 8014388:	683b      	ldr	r3, [r7, #0]
 801438a:	781b      	ldrb	r3, [r3, #0]
 801438c:	f003 030f 	and.w	r3, r3, #15
 8014390:	2101      	movs	r1, #1
 8014392:	fa01 f303 	lsl.w	r3, r1, r3
 8014396:	041b      	lsls	r3, r3, #16
 8014398:	43db      	mvns	r3, r3
 801439a:	68f9      	ldr	r1, [r7, #12]
 801439c:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 80143a0:	4013      	ands	r3, r2
 80143a2:	61cb      	str	r3, [r1, #28]
    USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_USBAEP |
 80143a4:	68bb      	ldr	r3, [r7, #8]
 80143a6:	015a      	lsls	r2, r3, #5
 80143a8:	68fb      	ldr	r3, [r7, #12]
 80143aa:	4413      	add	r3, r2
 80143ac:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80143b0:	681a      	ldr	r2, [r3, #0]
 80143b2:	68bb      	ldr	r3, [r7, #8]
 80143b4:	0159      	lsls	r1, r3, #5
 80143b6:	68fb      	ldr	r3, [r7, #12]
 80143b8:	440b      	add	r3, r1
 80143ba:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80143be:	4619      	mov	r1, r3
 80143c0:	4b05      	ldr	r3, [pc, #20]	@ (80143d8 <USB_DeactivateEndpoint+0x1b4>)
 80143c2:	4013      	ands	r3, r2
 80143c4:	600b      	str	r3, [r1, #0]
                                    USB_OTG_DOEPCTL_MPSIZ |
                                    USB_OTG_DOEPCTL_SD0PID_SEVNFRM |
                                    USB_OTG_DOEPCTL_EPTYP);
  }

  return HAL_OK;
 80143c6:	2300      	movs	r3, #0
}
 80143c8:	4618      	mov	r0, r3
 80143ca:	3714      	adds	r7, #20
 80143cc:	46bd      	mov	sp, r7
 80143ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80143d2:	4770      	bx	lr
 80143d4:	ec337800 	.word	0xec337800
 80143d8:	eff37800 	.word	0xeff37800

080143dc <USB_EPStartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep, uint8_t dma)
{
 80143dc:	b580      	push	{r7, lr}
 80143de:	b08a      	sub	sp, #40	@ 0x28
 80143e0:	af02      	add	r7, sp, #8
 80143e2:	60f8      	str	r0, [r7, #12]
 80143e4:	60b9      	str	r1, [r7, #8]
 80143e6:	4613      	mov	r3, r2
 80143e8:	71fb      	strb	r3, [r7, #7]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80143ea:	68fb      	ldr	r3, [r7, #12]
 80143ec:	61fb      	str	r3, [r7, #28]
  uint32_t epnum = (uint32_t)ep->num;
 80143ee:	68bb      	ldr	r3, [r7, #8]
 80143f0:	781b      	ldrb	r3, [r3, #0]
 80143f2:	61bb      	str	r3, [r7, #24]
  uint16_t pktcnt;

  /* IN endpoint */
  if (ep->is_in == 1U)
 80143f4:	68bb      	ldr	r3, [r7, #8]
 80143f6:	785b      	ldrb	r3, [r3, #1]
 80143f8:	2b01      	cmp	r3, #1
 80143fa:	f040 817a 	bne.w	80146f2 <USB_EPStartXfer+0x316>
  {
    /* Zero Length Packet? */
    if (ep->xfer_len == 0U)
 80143fe:	68bb      	ldr	r3, [r7, #8]
 8014400:	691b      	ldr	r3, [r3, #16]
 8014402:	2b00      	cmp	r3, #0
 8014404:	d132      	bne.n	801446c <USB_EPStartXfer+0x90>
    {
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 8014406:	69bb      	ldr	r3, [r7, #24]
 8014408:	015a      	lsls	r2, r3, #5
 801440a:	69fb      	ldr	r3, [r7, #28]
 801440c:	4413      	add	r3, r2
 801440e:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014412:	691b      	ldr	r3, [r3, #16]
 8014414:	69ba      	ldr	r2, [r7, #24]
 8014416:	0151      	lsls	r1, r2, #5
 8014418:	69fa      	ldr	r2, [r7, #28]
 801441a:	440a      	add	r2, r1
 801441c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014420:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8014424:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8014428:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 801442a:	69bb      	ldr	r3, [r7, #24]
 801442c:	015a      	lsls	r2, r3, #5
 801442e:	69fb      	ldr	r3, [r7, #28]
 8014430:	4413      	add	r3, r2
 8014432:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014436:	691b      	ldr	r3, [r3, #16]
 8014438:	69ba      	ldr	r2, [r7, #24]
 801443a:	0151      	lsls	r1, r2, #5
 801443c:	69fa      	ldr	r2, [r7, #28]
 801443e:	440a      	add	r2, r1
 8014440:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014444:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8014448:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801444a:	69bb      	ldr	r3, [r7, #24]
 801444c:	015a      	lsls	r2, r3, #5
 801444e:	69fb      	ldr	r3, [r7, #28]
 8014450:	4413      	add	r3, r2
 8014452:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014456:	691b      	ldr	r3, [r3, #16]
 8014458:	69ba      	ldr	r2, [r7, #24]
 801445a:	0151      	lsls	r1, r2, #5
 801445c:	69fa      	ldr	r2, [r7, #28]
 801445e:	440a      	add	r2, r1
 8014460:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014464:	0cdb      	lsrs	r3, r3, #19
 8014466:	04db      	lsls	r3, r3, #19
 8014468:	6113      	str	r3, [r2, #16]
 801446a:	e092      	b.n	8014592 <USB_EPStartXfer+0x1b6>
      /* Program the transfer size and packet count
      * as follows: xfersize = N * maxpacket +
      * short_packet pktcnt = N + (short_packet
      * exist ? 1 : 0)
      */
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_XFRSIZ);
 801446c:	69bb      	ldr	r3, [r7, #24]
 801446e:	015a      	lsls	r2, r3, #5
 8014470:	69fb      	ldr	r3, [r7, #28]
 8014472:	4413      	add	r3, r2
 8014474:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014478:	691b      	ldr	r3, [r3, #16]
 801447a:	69ba      	ldr	r2, [r7, #24]
 801447c:	0151      	lsls	r1, r2, #5
 801447e:	69fa      	ldr	r2, [r7, #28]
 8014480:	440a      	add	r2, r1
 8014482:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014486:	0cdb      	lsrs	r3, r3, #19
 8014488:	04db      	lsls	r3, r3, #19
 801448a:	6113      	str	r3, [r2, #16]
      USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_PKTCNT);
 801448c:	69bb      	ldr	r3, [r7, #24]
 801448e:	015a      	lsls	r2, r3, #5
 8014490:	69fb      	ldr	r3, [r7, #28]
 8014492:	4413      	add	r3, r2
 8014494:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014498:	691b      	ldr	r3, [r3, #16]
 801449a:	69ba      	ldr	r2, [r7, #24]
 801449c:	0151      	lsls	r1, r2, #5
 801449e:	69fa      	ldr	r2, [r7, #28]
 80144a0:	440a      	add	r2, r1
 80144a2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80144a6:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 80144aa:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 80144ae:	6113      	str	r3, [r2, #16]

      if (epnum == 0U)
 80144b0:	69bb      	ldr	r3, [r7, #24]
 80144b2:	2b00      	cmp	r3, #0
 80144b4:	d11a      	bne.n	80144ec <USB_EPStartXfer+0x110>
      {
        if (ep->xfer_len > ep->maxpacket)
 80144b6:	68bb      	ldr	r3, [r7, #8]
 80144b8:	691a      	ldr	r2, [r3, #16]
 80144ba:	68bb      	ldr	r3, [r7, #8]
 80144bc:	689b      	ldr	r3, [r3, #8]
 80144be:	429a      	cmp	r2, r3
 80144c0:	d903      	bls.n	80144ca <USB_EPStartXfer+0xee>
        {
          ep->xfer_len = ep->maxpacket;
 80144c2:	68bb      	ldr	r3, [r7, #8]
 80144c4:	689a      	ldr	r2, [r3, #8]
 80144c6:	68bb      	ldr	r3, [r7, #8]
 80144c8:	611a      	str	r2, [r3, #16]
        }

        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT & (1U << 19));
 80144ca:	69bb      	ldr	r3, [r7, #24]
 80144cc:	015a      	lsls	r2, r3, #5
 80144ce:	69fb      	ldr	r3, [r7, #28]
 80144d0:	4413      	add	r3, r2
 80144d2:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80144d6:	691b      	ldr	r3, [r3, #16]
 80144d8:	69ba      	ldr	r2, [r7, #24]
 80144da:	0151      	lsls	r1, r2, #5
 80144dc:	69fa      	ldr	r2, [r7, #28]
 80144de:	440a      	add	r2, r1
 80144e0:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80144e4:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 80144e8:	6113      	str	r3, [r2, #16]
 80144ea:	e01b      	b.n	8014524 <USB_EPStartXfer+0x148>
      }
      else
      {
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 80144ec:	69bb      	ldr	r3, [r7, #24]
 80144ee:	015a      	lsls	r2, r3, #5
 80144f0:	69fb      	ldr	r3, [r7, #28]
 80144f2:	4413      	add	r3, r2
 80144f4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80144f8:	691a      	ldr	r2, [r3, #16]
                                       (((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket) << 19));
 80144fa:	68bb      	ldr	r3, [r7, #8]
 80144fc:	6919      	ldr	r1, [r3, #16]
 80144fe:	68bb      	ldr	r3, [r7, #8]
 8014500:	689b      	ldr	r3, [r3, #8]
 8014502:	440b      	add	r3, r1
 8014504:	1e59      	subs	r1, r3, #1
 8014506:	68bb      	ldr	r3, [r7, #8]
 8014508:	689b      	ldr	r3, [r3, #8]
 801450a:	fbb1 f3f3 	udiv	r3, r1, r3
 801450e:	04d9      	lsls	r1, r3, #19
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_PKTCNT &
 8014510:	4ba2      	ldr	r3, [pc, #648]	@ (801479c <USB_EPStartXfer+0x3c0>)
 8014512:	400b      	ands	r3, r1
 8014514:	69b9      	ldr	r1, [r7, #24]
 8014516:	0148      	lsls	r0, r1, #5
 8014518:	69f9      	ldr	r1, [r7, #28]
 801451a:	4401      	add	r1, r0
 801451c:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8014520:	4313      	orrs	r3, r2
 8014522:	610b      	str	r3, [r1, #16]
      }

      USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_XFRSIZ & ep->xfer_len);
 8014524:	69bb      	ldr	r3, [r7, #24]
 8014526:	015a      	lsls	r2, r3, #5
 8014528:	69fb      	ldr	r3, [r7, #28]
 801452a:	4413      	add	r3, r2
 801452c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014530:	691a      	ldr	r2, [r3, #16]
 8014532:	68bb      	ldr	r3, [r7, #8]
 8014534:	691b      	ldr	r3, [r3, #16]
 8014536:	f3c3 0312 	ubfx	r3, r3, #0, #19
 801453a:	69b9      	ldr	r1, [r7, #24]
 801453c:	0148      	lsls	r0, r1, #5
 801453e:	69f9      	ldr	r1, [r7, #28]
 8014540:	4401      	add	r1, r0
 8014542:	f501 6110 	add.w	r1, r1, #2304	@ 0x900
 8014546:	4313      	orrs	r3, r2
 8014548:	610b      	str	r3, [r1, #16]

      if (ep->type == EP_TYPE_ISOC)
 801454a:	68bb      	ldr	r3, [r7, #8]
 801454c:	791b      	ldrb	r3, [r3, #4]
 801454e:	2b01      	cmp	r3, #1
 8014550:	d11f      	bne.n	8014592 <USB_EPStartXfer+0x1b6>
      {
        USBx_INEP(epnum)->DIEPTSIZ &= ~(USB_OTG_DIEPTSIZ_MULCNT);
 8014552:	69bb      	ldr	r3, [r7, #24]
 8014554:	015a      	lsls	r2, r3, #5
 8014556:	69fb      	ldr	r3, [r7, #28]
 8014558:	4413      	add	r3, r2
 801455a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801455e:	691b      	ldr	r3, [r3, #16]
 8014560:	69ba      	ldr	r2, [r7, #24]
 8014562:	0151      	lsls	r1, r2, #5
 8014564:	69fa      	ldr	r2, [r7, #28]
 8014566:	440a      	add	r2, r1
 8014568:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 801456c:	f023 43c0 	bic.w	r3, r3, #1610612736	@ 0x60000000
 8014570:	6113      	str	r3, [r2, #16]
        USBx_INEP(epnum)->DIEPTSIZ |= (USB_OTG_DIEPTSIZ_MULCNT & (1U << 29));
 8014572:	69bb      	ldr	r3, [r7, #24]
 8014574:	015a      	lsls	r2, r3, #5
 8014576:	69fb      	ldr	r3, [r7, #28]
 8014578:	4413      	add	r3, r2
 801457a:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801457e:	691b      	ldr	r3, [r3, #16]
 8014580:	69ba      	ldr	r2, [r7, #24]
 8014582:	0151      	lsls	r1, r2, #5
 8014584:	69fa      	ldr	r2, [r7, #28]
 8014586:	440a      	add	r2, r1
 8014588:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 801458c:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 8014590:	6113      	str	r3, [r2, #16]
      }
    }

    if (dma == 1U)
 8014592:	79fb      	ldrb	r3, [r7, #7]
 8014594:	2b01      	cmp	r3, #1
 8014596:	d14b      	bne.n	8014630 <USB_EPStartXfer+0x254>
    {
      if ((uint32_t)ep->dma_addr != 0U)
 8014598:	68bb      	ldr	r3, [r7, #8]
 801459a:	69db      	ldr	r3, [r3, #28]
 801459c:	2b00      	cmp	r3, #0
 801459e:	d009      	beq.n	80145b4 <USB_EPStartXfer+0x1d8>
      {
        USBx_INEP(epnum)->DIEPDMA = (uint32_t)(ep->dma_addr);
 80145a0:	69bb      	ldr	r3, [r7, #24]
 80145a2:	015a      	lsls	r2, r3, #5
 80145a4:	69fb      	ldr	r3, [r7, #28]
 80145a6:	4413      	add	r3, r2
 80145a8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80145ac:	461a      	mov	r2, r3
 80145ae:	68bb      	ldr	r3, [r7, #8]
 80145b0:	69db      	ldr	r3, [r3, #28]
 80145b2:	6153      	str	r3, [r2, #20]
      }

      if (ep->type == EP_TYPE_ISOC)
 80145b4:	68bb      	ldr	r3, [r7, #8]
 80145b6:	791b      	ldrb	r3, [r3, #4]
 80145b8:	2b01      	cmp	r3, #1
 80145ba:	d128      	bne.n	801460e <USB_EPStartXfer+0x232>
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 80145bc:	69fb      	ldr	r3, [r7, #28]
 80145be:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80145c2:	689b      	ldr	r3, [r3, #8]
 80145c4:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80145c8:	2b00      	cmp	r3, #0
 80145ca:	d110      	bne.n	80145ee <USB_EPStartXfer+0x212>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 80145cc:	69bb      	ldr	r3, [r7, #24]
 80145ce:	015a      	lsls	r2, r3, #5
 80145d0:	69fb      	ldr	r3, [r7, #28]
 80145d2:	4413      	add	r3, r2
 80145d4:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80145d8:	681b      	ldr	r3, [r3, #0]
 80145da:	69ba      	ldr	r2, [r7, #24]
 80145dc:	0151      	lsls	r1, r2, #5
 80145de:	69fa      	ldr	r2, [r7, #28]
 80145e0:	440a      	add	r2, r1
 80145e2:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80145e6:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 80145ea:	6013      	str	r3, [r2, #0]
 80145ec:	e00f      	b.n	801460e <USB_EPStartXfer+0x232>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80145ee:	69bb      	ldr	r3, [r7, #24]
 80145f0:	015a      	lsls	r2, r3, #5
 80145f2:	69fb      	ldr	r3, [r7, #28]
 80145f4:	4413      	add	r3, r2
 80145f6:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80145fa:	681b      	ldr	r3, [r3, #0]
 80145fc:	69ba      	ldr	r2, [r7, #24]
 80145fe:	0151      	lsls	r1, r2, #5
 8014600:	69fa      	ldr	r2, [r7, #28]
 8014602:	440a      	add	r2, r1
 8014604:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014608:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801460c:	6013      	str	r3, [r2, #0]
        }
      }

      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 801460e:	69bb      	ldr	r3, [r7, #24]
 8014610:	015a      	lsls	r2, r3, #5
 8014612:	69fb      	ldr	r3, [r7, #28]
 8014614:	4413      	add	r3, r2
 8014616:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801461a:	681b      	ldr	r3, [r3, #0]
 801461c:	69ba      	ldr	r2, [r7, #24]
 801461e:	0151      	lsls	r1, r2, #5
 8014620:	69fa      	ldr	r2, [r7, #28]
 8014622:	440a      	add	r2, r1
 8014624:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014628:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 801462c:	6013      	str	r3, [r2, #0]
 801462e:	e165      	b.n	80148fc <USB_EPStartXfer+0x520>
    }
    else
    {
      /* EP enable, IN data in FIFO */
      USBx_INEP(epnum)->DIEPCTL |= (USB_OTG_DIEPCTL_CNAK | USB_OTG_DIEPCTL_EPENA);
 8014630:	69bb      	ldr	r3, [r7, #24]
 8014632:	015a      	lsls	r2, r3, #5
 8014634:	69fb      	ldr	r3, [r7, #28]
 8014636:	4413      	add	r3, r2
 8014638:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 801463c:	681b      	ldr	r3, [r3, #0]
 801463e:	69ba      	ldr	r2, [r7, #24]
 8014640:	0151      	lsls	r1, r2, #5
 8014642:	69fa      	ldr	r2, [r7, #28]
 8014644:	440a      	add	r2, r1
 8014646:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 801464a:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 801464e:	6013      	str	r3, [r2, #0]

      if (ep->type != EP_TYPE_ISOC)
 8014650:	68bb      	ldr	r3, [r7, #8]
 8014652:	791b      	ldrb	r3, [r3, #4]
 8014654:	2b01      	cmp	r3, #1
 8014656:	d015      	beq.n	8014684 <USB_EPStartXfer+0x2a8>
      {
        /* Enable the Tx FIFO Empty Interrupt for this EP */
        if (ep->xfer_len > 0U)
 8014658:	68bb      	ldr	r3, [r7, #8]
 801465a:	691b      	ldr	r3, [r3, #16]
 801465c:	2b00      	cmp	r3, #0
 801465e:	f000 814d 	beq.w	80148fc <USB_EPStartXfer+0x520>
        {
          USBx_DEVICE->DIEPEMPMSK |= 1UL << (ep->num & EP_ADDR_MSK);
 8014662:	69fb      	ldr	r3, [r7, #28]
 8014664:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014668:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 801466a:	68bb      	ldr	r3, [r7, #8]
 801466c:	781b      	ldrb	r3, [r3, #0]
 801466e:	f003 030f 	and.w	r3, r3, #15
 8014672:	2101      	movs	r1, #1
 8014674:	fa01 f303 	lsl.w	r3, r1, r3
 8014678:	69f9      	ldr	r1, [r7, #28]
 801467a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 801467e:	4313      	orrs	r3, r2
 8014680:	634b      	str	r3, [r1, #52]	@ 0x34
 8014682:	e13b      	b.n	80148fc <USB_EPStartXfer+0x520>
        }
      }
      else
      {
        if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 8014684:	69fb      	ldr	r3, [r7, #28]
 8014686:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 801468a:	689b      	ldr	r3, [r3, #8]
 801468c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8014690:	2b00      	cmp	r3, #0
 8014692:	d110      	bne.n	80146b6 <USB_EPStartXfer+0x2da>
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SODDFRM;
 8014694:	69bb      	ldr	r3, [r7, #24]
 8014696:	015a      	lsls	r2, r3, #5
 8014698:	69fb      	ldr	r3, [r7, #28]
 801469a:	4413      	add	r3, r2
 801469c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80146a0:	681b      	ldr	r3, [r3, #0]
 80146a2:	69ba      	ldr	r2, [r7, #24]
 80146a4:	0151      	lsls	r1, r2, #5
 80146a6:	69fa      	ldr	r2, [r7, #28]
 80146a8:	440a      	add	r2, r1
 80146aa:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80146ae:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 80146b2:	6013      	str	r3, [r2, #0]
 80146b4:	e00f      	b.n	80146d6 <USB_EPStartXfer+0x2fa>
        }
        else
        {
          USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM;
 80146b6:	69bb      	ldr	r3, [r7, #24]
 80146b8:	015a      	lsls	r2, r3, #5
 80146ba:	69fb      	ldr	r3, [r7, #28]
 80146bc:	4413      	add	r3, r2
 80146be:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80146c2:	681b      	ldr	r3, [r3, #0]
 80146c4:	69ba      	ldr	r2, [r7, #24]
 80146c6:	0151      	lsls	r1, r2, #5
 80146c8:	69fa      	ldr	r2, [r7, #28]
 80146ca:	440a      	add	r2, r1
 80146cc:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 80146d0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80146d4:	6013      	str	r3, [r2, #0]
        }

        (void)USB_WritePacket(USBx, ep->xfer_buff, ep->num, (uint16_t)ep->xfer_len, dma);
 80146d6:	68bb      	ldr	r3, [r7, #8]
 80146d8:	68d9      	ldr	r1, [r3, #12]
 80146da:	68bb      	ldr	r3, [r7, #8]
 80146dc:	781a      	ldrb	r2, [r3, #0]
 80146de:	68bb      	ldr	r3, [r7, #8]
 80146e0:	691b      	ldr	r3, [r3, #16]
 80146e2:	b298      	uxth	r0, r3
 80146e4:	79fb      	ldrb	r3, [r7, #7]
 80146e6:	9300      	str	r3, [sp, #0]
 80146e8:	4603      	mov	r3, r0
 80146ea:	68f8      	ldr	r0, [r7, #12]
 80146ec:	f000 f9b8 	bl	8014a60 <USB_WritePacket>
 80146f0:	e104      	b.n	80148fc <USB_EPStartXfer+0x520>
  {
    /* Program the transfer size and packet count as follows:
    * pktcnt = N
    * xfersize = N * maxpacket
    */
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_XFRSIZ);
 80146f2:	69bb      	ldr	r3, [r7, #24]
 80146f4:	015a      	lsls	r2, r3, #5
 80146f6:	69fb      	ldr	r3, [r7, #28]
 80146f8:	4413      	add	r3, r2
 80146fa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80146fe:	691b      	ldr	r3, [r3, #16]
 8014700:	69ba      	ldr	r2, [r7, #24]
 8014702:	0151      	lsls	r1, r2, #5
 8014704:	69fa      	ldr	r2, [r7, #28]
 8014706:	440a      	add	r2, r1
 8014708:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 801470c:	0cdb      	lsrs	r3, r3, #19
 801470e:	04db      	lsls	r3, r3, #19
 8014710:	6113      	str	r3, [r2, #16]
    USBx_OUTEP(epnum)->DOEPTSIZ &= ~(USB_OTG_DOEPTSIZ_PKTCNT);
 8014712:	69bb      	ldr	r3, [r7, #24]
 8014714:	015a      	lsls	r2, r3, #5
 8014716:	69fb      	ldr	r3, [r7, #28]
 8014718:	4413      	add	r3, r2
 801471a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 801471e:	691b      	ldr	r3, [r3, #16]
 8014720:	69ba      	ldr	r2, [r7, #24]
 8014722:	0151      	lsls	r1, r2, #5
 8014724:	69fa      	ldr	r2, [r7, #28]
 8014726:	440a      	add	r2, r1
 8014728:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 801472c:	f023 53ff 	bic.w	r3, r3, #534773760	@ 0x1fe00000
 8014730:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 8014734:	6113      	str	r3, [r2, #16]

    if (epnum == 0U)
 8014736:	69bb      	ldr	r3, [r7, #24]
 8014738:	2b00      	cmp	r3, #0
 801473a:	d131      	bne.n	80147a0 <USB_EPStartXfer+0x3c4>
    {
      if (ep->xfer_len > 0U)
 801473c:	68bb      	ldr	r3, [r7, #8]
 801473e:	691b      	ldr	r3, [r3, #16]
 8014740:	2b00      	cmp	r3, #0
 8014742:	d003      	beq.n	801474c <USB_EPStartXfer+0x370>
      {
        ep->xfer_len = ep->maxpacket;
 8014744:	68bb      	ldr	r3, [r7, #8]
 8014746:	689a      	ldr	r2, [r3, #8]
 8014748:	68bb      	ldr	r3, [r7, #8]
 801474a:	611a      	str	r2, [r3, #16]
      }

      /* Store transfer size, for EP0 this is equal to endpoint max packet size */
      ep->xfer_size = ep->maxpacket;
 801474c:	68bb      	ldr	r3, [r7, #8]
 801474e:	689a      	ldr	r2, [r3, #8]
 8014750:	68bb      	ldr	r3, [r7, #8]
 8014752:	621a      	str	r2, [r3, #32]

      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size);
 8014754:	69bb      	ldr	r3, [r7, #24]
 8014756:	015a      	lsls	r2, r3, #5
 8014758:	69fb      	ldr	r3, [r7, #28]
 801475a:	4413      	add	r3, r2
 801475c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014760:	691a      	ldr	r2, [r3, #16]
 8014762:	68bb      	ldr	r3, [r7, #8]
 8014764:	6a1b      	ldr	r3, [r3, #32]
 8014766:	f3c3 0312 	ubfx	r3, r3, #0, #19
 801476a:	69b9      	ldr	r1, [r7, #24]
 801476c:	0148      	lsls	r0, r1, #5
 801476e:	69f9      	ldr	r1, [r7, #28]
 8014770:	4401      	add	r1, r0
 8014772:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8014776:	4313      	orrs	r3, r2
 8014778:	610b      	str	r3, [r1, #16]
      USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 801477a:	69bb      	ldr	r3, [r7, #24]
 801477c:	015a      	lsls	r2, r3, #5
 801477e:	69fb      	ldr	r3, [r7, #28]
 8014780:	4413      	add	r3, r2
 8014782:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014786:	691b      	ldr	r3, [r3, #16]
 8014788:	69ba      	ldr	r2, [r7, #24]
 801478a:	0151      	lsls	r1, r2, #5
 801478c:	69fa      	ldr	r2, [r7, #28]
 801478e:	440a      	add	r2, r1
 8014790:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014794:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8014798:	6113      	str	r3, [r2, #16]
 801479a:	e061      	b.n	8014860 <USB_EPStartXfer+0x484>
 801479c:	1ff80000 	.word	0x1ff80000
    }
    else
    {
      if (ep->xfer_len == 0U)
 80147a0:	68bb      	ldr	r3, [r7, #8]
 80147a2:	691b      	ldr	r3, [r3, #16]
 80147a4:	2b00      	cmp	r3, #0
 80147a6:	d123      	bne.n	80147f0 <USB_EPStartXfer+0x414>
      {
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_XFRSIZ & ep->maxpacket);
 80147a8:	69bb      	ldr	r3, [r7, #24]
 80147aa:	015a      	lsls	r2, r3, #5
 80147ac:	69fb      	ldr	r3, [r7, #28]
 80147ae:	4413      	add	r3, r2
 80147b0:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80147b4:	691a      	ldr	r2, [r3, #16]
 80147b6:	68bb      	ldr	r3, [r7, #8]
 80147b8:	689b      	ldr	r3, [r3, #8]
 80147ba:	f3c3 0312 	ubfx	r3, r3, #0, #19
 80147be:	69b9      	ldr	r1, [r7, #24]
 80147c0:	0148      	lsls	r0, r1, #5
 80147c2:	69f9      	ldr	r1, [r7, #28]
 80147c4:	4401      	add	r1, r0
 80147c6:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 80147ca:	4313      	orrs	r3, r2
 80147cc:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 80147ce:	69bb      	ldr	r3, [r7, #24]
 80147d0:	015a      	lsls	r2, r3, #5
 80147d2:	69fb      	ldr	r3, [r7, #28]
 80147d4:	4413      	add	r3, r2
 80147d6:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80147da:	691b      	ldr	r3, [r3, #16]
 80147dc:	69ba      	ldr	r2, [r7, #24]
 80147de:	0151      	lsls	r1, r2, #5
 80147e0:	69fa      	ldr	r2, [r7, #28]
 80147e2:	440a      	add	r2, r1
 80147e4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80147e8:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 80147ec:	6113      	str	r3, [r2, #16]
 80147ee:	e037      	b.n	8014860 <USB_EPStartXfer+0x484>
      }
      else
      {
        pktcnt = (uint16_t)((ep->xfer_len + ep->maxpacket - 1U) / ep->maxpacket);
 80147f0:	68bb      	ldr	r3, [r7, #8]
 80147f2:	691a      	ldr	r2, [r3, #16]
 80147f4:	68bb      	ldr	r3, [r7, #8]
 80147f6:	689b      	ldr	r3, [r3, #8]
 80147f8:	4413      	add	r3, r2
 80147fa:	1e5a      	subs	r2, r3, #1
 80147fc:	68bb      	ldr	r3, [r7, #8]
 80147fe:	689b      	ldr	r3, [r3, #8]
 8014800:	fbb2 f3f3 	udiv	r3, r2, r3
 8014804:	82fb      	strh	r3, [r7, #22]
        ep->xfer_size = ep->maxpacket * pktcnt;
 8014806:	68bb      	ldr	r3, [r7, #8]
 8014808:	689b      	ldr	r3, [r3, #8]
 801480a:	8afa      	ldrh	r2, [r7, #22]
 801480c:	fb03 f202 	mul.w	r2, r3, r2
 8014810:	68bb      	ldr	r3, [r7, #8]
 8014812:	621a      	str	r2, [r3, #32]

        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_PKTCNT & ((uint32_t)pktcnt << 19);
 8014814:	69bb      	ldr	r3, [r7, #24]
 8014816:	015a      	lsls	r2, r3, #5
 8014818:	69fb      	ldr	r3, [r7, #28]
 801481a:	4413      	add	r3, r2
 801481c:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014820:	691a      	ldr	r2, [r3, #16]
 8014822:	8afb      	ldrh	r3, [r7, #22]
 8014824:	04d9      	lsls	r1, r3, #19
 8014826:	4b38      	ldr	r3, [pc, #224]	@ (8014908 <USB_EPStartXfer+0x52c>)
 8014828:	400b      	ands	r3, r1
 801482a:	69b9      	ldr	r1, [r7, #24]
 801482c:	0148      	lsls	r0, r1, #5
 801482e:	69f9      	ldr	r1, [r7, #28]
 8014830:	4401      	add	r1, r0
 8014832:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 8014836:	4313      	orrs	r3, r2
 8014838:	610b      	str	r3, [r1, #16]
        USBx_OUTEP(epnum)->DOEPTSIZ |= USB_OTG_DOEPTSIZ_XFRSIZ & ep->xfer_size;
 801483a:	69bb      	ldr	r3, [r7, #24]
 801483c:	015a      	lsls	r2, r3, #5
 801483e:	69fb      	ldr	r3, [r7, #28]
 8014840:	4413      	add	r3, r2
 8014842:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014846:	691a      	ldr	r2, [r3, #16]
 8014848:	68bb      	ldr	r3, [r7, #8]
 801484a:	6a1b      	ldr	r3, [r3, #32]
 801484c:	f3c3 0312 	ubfx	r3, r3, #0, #19
 8014850:	69b9      	ldr	r1, [r7, #24]
 8014852:	0148      	lsls	r0, r1, #5
 8014854:	69f9      	ldr	r1, [r7, #28]
 8014856:	4401      	add	r1, r0
 8014858:	f501 6130 	add.w	r1, r1, #2816	@ 0xb00
 801485c:	4313      	orrs	r3, r2
 801485e:	610b      	str	r3, [r1, #16]
      }
    }

    if (dma == 1U)
 8014860:	79fb      	ldrb	r3, [r7, #7]
 8014862:	2b01      	cmp	r3, #1
 8014864:	d10d      	bne.n	8014882 <USB_EPStartXfer+0x4a6>
    {
      if ((uint32_t)ep->xfer_buff != 0U)
 8014866:	68bb      	ldr	r3, [r7, #8]
 8014868:	68db      	ldr	r3, [r3, #12]
 801486a:	2b00      	cmp	r3, #0
 801486c:	d009      	beq.n	8014882 <USB_EPStartXfer+0x4a6>
      {
        USBx_OUTEP(epnum)->DOEPDMA = (uint32_t)(ep->xfer_buff);
 801486e:	68bb      	ldr	r3, [r7, #8]
 8014870:	68d9      	ldr	r1, [r3, #12]
 8014872:	69bb      	ldr	r3, [r7, #24]
 8014874:	015a      	lsls	r2, r3, #5
 8014876:	69fb      	ldr	r3, [r7, #28]
 8014878:	4413      	add	r3, r2
 801487a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 801487e:	460a      	mov	r2, r1
 8014880:	615a      	str	r2, [r3, #20]
      }
    }

    if (ep->type == EP_TYPE_ISOC)
 8014882:	68bb      	ldr	r3, [r7, #8]
 8014884:	791b      	ldrb	r3, [r3, #4]
 8014886:	2b01      	cmp	r3, #1
 8014888:	d128      	bne.n	80148dc <USB_EPStartXfer+0x500>
    {
      if ((USBx_DEVICE->DSTS & (1U << 8)) == 0U)
 801488a:	69fb      	ldr	r3, [r7, #28]
 801488c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014890:	689b      	ldr	r3, [r3, #8]
 8014892:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8014896:	2b00      	cmp	r3, #0
 8014898:	d110      	bne.n	80148bc <USB_EPStartXfer+0x4e0>
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SODDFRM;
 801489a:	69bb      	ldr	r3, [r7, #24]
 801489c:	015a      	lsls	r2, r3, #5
 801489e:	69fb      	ldr	r3, [r7, #28]
 80148a0:	4413      	add	r3, r2
 80148a2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80148a6:	681b      	ldr	r3, [r3, #0]
 80148a8:	69ba      	ldr	r2, [r7, #24]
 80148aa:	0151      	lsls	r1, r2, #5
 80148ac:	69fa      	ldr	r2, [r7, #28]
 80148ae:	440a      	add	r2, r1
 80148b0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80148b4:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
 80148b8:	6013      	str	r3, [r2, #0]
 80148ba:	e00f      	b.n	80148dc <USB_EPStartXfer+0x500>
      }
      else
      {
        USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM;
 80148bc:	69bb      	ldr	r3, [r7, #24]
 80148be:	015a      	lsls	r2, r3, #5
 80148c0:	69fb      	ldr	r3, [r7, #28]
 80148c2:	4413      	add	r3, r2
 80148c4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80148c8:	681b      	ldr	r3, [r3, #0]
 80148ca:	69ba      	ldr	r2, [r7, #24]
 80148cc:	0151      	lsls	r1, r2, #5
 80148ce:	69fa      	ldr	r2, [r7, #28]
 80148d0:	440a      	add	r2, r1
 80148d2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80148d6:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 80148da:	6013      	str	r3, [r2, #0]
      }
    }
    /* EP enable */
    USBx_OUTEP(epnum)->DOEPCTL |= (USB_OTG_DOEPCTL_CNAK | USB_OTG_DOEPCTL_EPENA);
 80148dc:	69bb      	ldr	r3, [r7, #24]
 80148de:	015a      	lsls	r2, r3, #5
 80148e0:	69fb      	ldr	r3, [r7, #28]
 80148e2:	4413      	add	r3, r2
 80148e4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80148e8:	681b      	ldr	r3, [r3, #0]
 80148ea:	69ba      	ldr	r2, [r7, #24]
 80148ec:	0151      	lsls	r1, r2, #5
 80148ee:	69fa      	ldr	r2, [r7, #28]
 80148f0:	440a      	add	r2, r1
 80148f2:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80148f6:	f043 4304 	orr.w	r3, r3, #2214592512	@ 0x84000000
 80148fa:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 80148fc:	2300      	movs	r3, #0
}
 80148fe:	4618      	mov	r0, r3
 8014900:	3720      	adds	r7, #32
 8014902:	46bd      	mov	sp, r7
 8014904:	bd80      	pop	{r7, pc}
 8014906:	bf00      	nop
 8014908:	1ff80000 	.word	0x1ff80000

0801490c <USB_EPStopXfer>:
   * @param  USBx  usb device instance
   * @param  ep pointer to endpoint structure
   * @retval HAL status
   */
HAL_StatusTypeDef USB_EPStopXfer(const USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep)
{
 801490c:	b480      	push	{r7}
 801490e:	b087      	sub	sp, #28
 8014910:	af00      	add	r7, sp, #0
 8014912:	6078      	str	r0, [r7, #4]
 8014914:	6039      	str	r1, [r7, #0]
  __IO uint32_t count = 0U;
 8014916:	2300      	movs	r3, #0
 8014918:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef ret = HAL_OK;
 801491a:	2300      	movs	r3, #0
 801491c:	75fb      	strb	r3, [r7, #23]
  uint32_t USBx_BASE = (uint32_t)USBx;
 801491e:	687b      	ldr	r3, [r7, #4]
 8014920:	613b      	str	r3, [r7, #16]

  /* IN endpoint */
  if (ep->is_in == 1U)
 8014922:	683b      	ldr	r3, [r7, #0]
 8014924:	785b      	ldrb	r3, [r3, #1]
 8014926:	2b01      	cmp	r3, #1
 8014928:	d14a      	bne.n	80149c0 <USB_EPStopXfer+0xb4>
  {
    /* EP enable, IN data in FIFO */
    if (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) == USB_OTG_DIEPCTL_EPENA)
 801492a:	683b      	ldr	r3, [r7, #0]
 801492c:	781b      	ldrb	r3, [r3, #0]
 801492e:	015a      	lsls	r2, r3, #5
 8014930:	693b      	ldr	r3, [r7, #16]
 8014932:	4413      	add	r3, r2
 8014934:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014938:	681b      	ldr	r3, [r3, #0]
 801493a:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 801493e:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8014942:	f040 8086 	bne.w	8014a52 <USB_EPStopXfer+0x146>
    {
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_SNAK);
 8014946:	683b      	ldr	r3, [r7, #0]
 8014948:	781b      	ldrb	r3, [r3, #0]
 801494a:	015a      	lsls	r2, r3, #5
 801494c:	693b      	ldr	r3, [r7, #16]
 801494e:	4413      	add	r3, r2
 8014950:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014954:	681b      	ldr	r3, [r3, #0]
 8014956:	683a      	ldr	r2, [r7, #0]
 8014958:	7812      	ldrb	r2, [r2, #0]
 801495a:	0151      	lsls	r1, r2, #5
 801495c:	693a      	ldr	r2, [r7, #16]
 801495e:	440a      	add	r2, r1
 8014960:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014964:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 8014968:	6013      	str	r3, [r2, #0]
      USBx_INEP(ep->num)->DIEPCTL |= (USB_OTG_DIEPCTL_EPDIS);
 801496a:	683b      	ldr	r3, [r7, #0]
 801496c:	781b      	ldrb	r3, [r3, #0]
 801496e:	015a      	lsls	r2, r3, #5
 8014970:	693b      	ldr	r3, [r7, #16]
 8014972:	4413      	add	r3, r2
 8014974:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014978:	681b      	ldr	r3, [r3, #0]
 801497a:	683a      	ldr	r2, [r7, #0]
 801497c:	7812      	ldrb	r2, [r2, #0]
 801497e:	0151      	lsls	r1, r2, #5
 8014980:	693a      	ldr	r2, [r7, #16]
 8014982:	440a      	add	r2, r1
 8014984:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014988:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 801498c:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 801498e:	68fb      	ldr	r3, [r7, #12]
 8014990:	3301      	adds	r3, #1
 8014992:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 8014994:	68fb      	ldr	r3, [r7, #12]
 8014996:	f242 7210 	movw	r2, #10000	@ 0x2710
 801499a:	4293      	cmp	r3, r2
 801499c:	d902      	bls.n	80149a4 <USB_EPStopXfer+0x98>
        {
          ret = HAL_ERROR;
 801499e:	2301      	movs	r3, #1
 80149a0:	75fb      	strb	r3, [r7, #23]
          break;
 80149a2:	e056      	b.n	8014a52 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_INEP(ep->num)->DIEPCTL) & USB_OTG_DIEPCTL_EPENA) ==  USB_OTG_DIEPCTL_EPENA);
 80149a4:	683b      	ldr	r3, [r7, #0]
 80149a6:	781b      	ldrb	r3, [r3, #0]
 80149a8:	015a      	lsls	r2, r3, #5
 80149aa:	693b      	ldr	r3, [r7, #16]
 80149ac:	4413      	add	r3, r2
 80149ae:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 80149b2:	681b      	ldr	r3, [r3, #0]
 80149b4:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80149b8:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80149bc:	d0e7      	beq.n	801498e <USB_EPStopXfer+0x82>
 80149be:	e048      	b.n	8014a52 <USB_EPStopXfer+0x146>
    }
  }
  else /* OUT endpoint */
  {
    if (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 80149c0:	683b      	ldr	r3, [r7, #0]
 80149c2:	781b      	ldrb	r3, [r3, #0]
 80149c4:	015a      	lsls	r2, r3, #5
 80149c6:	693b      	ldr	r3, [r7, #16]
 80149c8:	4413      	add	r3, r2
 80149ca:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80149ce:	681b      	ldr	r3, [r3, #0]
 80149d0:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 80149d4:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 80149d8:	d13b      	bne.n	8014a52 <USB_EPStopXfer+0x146>
    {
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_SNAK);
 80149da:	683b      	ldr	r3, [r7, #0]
 80149dc:	781b      	ldrb	r3, [r3, #0]
 80149de:	015a      	lsls	r2, r3, #5
 80149e0:	693b      	ldr	r3, [r7, #16]
 80149e2:	4413      	add	r3, r2
 80149e4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 80149e8:	681b      	ldr	r3, [r3, #0]
 80149ea:	683a      	ldr	r2, [r7, #0]
 80149ec:	7812      	ldrb	r2, [r2, #0]
 80149ee:	0151      	lsls	r1, r2, #5
 80149f0:	693a      	ldr	r2, [r7, #16]
 80149f2:	440a      	add	r2, r1
 80149f4:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 80149f8:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
 80149fc:	6013      	str	r3, [r2, #0]
      USBx_OUTEP(ep->num)->DOEPCTL |= (USB_OTG_DOEPCTL_EPDIS);
 80149fe:	683b      	ldr	r3, [r7, #0]
 8014a00:	781b      	ldrb	r3, [r3, #0]
 8014a02:	015a      	lsls	r2, r3, #5
 8014a04:	693b      	ldr	r3, [r7, #16]
 8014a06:	4413      	add	r3, r2
 8014a08:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014a0c:	681b      	ldr	r3, [r3, #0]
 8014a0e:	683a      	ldr	r2, [r7, #0]
 8014a10:	7812      	ldrb	r2, [r2, #0]
 8014a12:	0151      	lsls	r1, r2, #5
 8014a14:	693a      	ldr	r2, [r7, #16]
 8014a16:	440a      	add	r2, r1
 8014a18:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014a1c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8014a20:	6013      	str	r3, [r2, #0]

      do
      {
        count++;
 8014a22:	68fb      	ldr	r3, [r7, #12]
 8014a24:	3301      	adds	r3, #1
 8014a26:	60fb      	str	r3, [r7, #12]

        if (count > 10000U)
 8014a28:	68fb      	ldr	r3, [r7, #12]
 8014a2a:	f242 7210 	movw	r2, #10000	@ 0x2710
 8014a2e:	4293      	cmp	r3, r2
 8014a30:	d902      	bls.n	8014a38 <USB_EPStopXfer+0x12c>
        {
          ret = HAL_ERROR;
 8014a32:	2301      	movs	r3, #1
 8014a34:	75fb      	strb	r3, [r7, #23]
          break;
 8014a36:	e00c      	b.n	8014a52 <USB_EPStopXfer+0x146>
        }
      } while (((USBx_OUTEP(ep->num)->DOEPCTL) & USB_OTG_DOEPCTL_EPENA) ==  USB_OTG_DOEPCTL_EPENA);
 8014a38:	683b      	ldr	r3, [r7, #0]
 8014a3a:	781b      	ldrb	r3, [r3, #0]
 8014a3c:	015a      	lsls	r2, r3, #5
 8014a3e:	693b      	ldr	r3, [r7, #16]
 8014a40:	4413      	add	r3, r2
 8014a42:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014a46:	681b      	ldr	r3, [r3, #0]
 8014a48:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8014a4c:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8014a50:	d0e7      	beq.n	8014a22 <USB_EPStopXfer+0x116>
    }
  }

  return ret;
 8014a52:	7dfb      	ldrb	r3, [r7, #23]
}
 8014a54:	4618      	mov	r0, r3
 8014a56:	371c      	adds	r7, #28
 8014a58:	46bd      	mov	sp, r7
 8014a5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014a5e:	4770      	bx	lr

08014a60 <USB_WritePacket>:
  *           1 : DMA feature used
  * @retval HAL status
  */
HAL_StatusTypeDef USB_WritePacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *src,
                                  uint8_t ch_ep_num, uint16_t len, uint8_t dma)
{
 8014a60:	b480      	push	{r7}
 8014a62:	b089      	sub	sp, #36	@ 0x24
 8014a64:	af00      	add	r7, sp, #0
 8014a66:	60f8      	str	r0, [r7, #12]
 8014a68:	60b9      	str	r1, [r7, #8]
 8014a6a:	4611      	mov	r1, r2
 8014a6c:	461a      	mov	r2, r3
 8014a6e:	460b      	mov	r3, r1
 8014a70:	71fb      	strb	r3, [r7, #7]
 8014a72:	4613      	mov	r3, r2
 8014a74:	80bb      	strh	r3, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014a76:	68fb      	ldr	r3, [r7, #12]
 8014a78:	617b      	str	r3, [r7, #20]
  uint8_t *pSrc = src;
 8014a7a:	68bb      	ldr	r3, [r7, #8]
 8014a7c:	61fb      	str	r3, [r7, #28]
  uint32_t count32b;
  uint32_t i;

  if (dma == 0U)
 8014a7e:	f897 3028 	ldrb.w	r3, [r7, #40]	@ 0x28
 8014a82:	2b00      	cmp	r3, #0
 8014a84:	d123      	bne.n	8014ace <USB_WritePacket+0x6e>
  {
    count32b = ((uint32_t)len + 3U) / 4U;
 8014a86:	88bb      	ldrh	r3, [r7, #4]
 8014a88:	3303      	adds	r3, #3
 8014a8a:	089b      	lsrs	r3, r3, #2
 8014a8c:	613b      	str	r3, [r7, #16]
    for (i = 0U; i < count32b; i++)
 8014a8e:	2300      	movs	r3, #0
 8014a90:	61bb      	str	r3, [r7, #24]
 8014a92:	e018      	b.n	8014ac6 <USB_WritePacket+0x66>
    {
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8014a94:	79fb      	ldrb	r3, [r7, #7]
 8014a96:	031a      	lsls	r2, r3, #12
 8014a98:	697b      	ldr	r3, [r7, #20]
 8014a9a:	4413      	add	r3, r2
 8014a9c:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014aa0:	461a      	mov	r2, r3
 8014aa2:	69fb      	ldr	r3, [r7, #28]
 8014aa4:	681b      	ldr	r3, [r3, #0]
 8014aa6:	6013      	str	r3, [r2, #0]
      pSrc++;
 8014aa8:	69fb      	ldr	r3, [r7, #28]
 8014aaa:	3301      	adds	r3, #1
 8014aac:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8014aae:	69fb      	ldr	r3, [r7, #28]
 8014ab0:	3301      	adds	r3, #1
 8014ab2:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8014ab4:	69fb      	ldr	r3, [r7, #28]
 8014ab6:	3301      	adds	r3, #1
 8014ab8:	61fb      	str	r3, [r7, #28]
      pSrc++;
 8014aba:	69fb      	ldr	r3, [r7, #28]
 8014abc:	3301      	adds	r3, #1
 8014abe:	61fb      	str	r3, [r7, #28]
    for (i = 0U; i < count32b; i++)
 8014ac0:	69bb      	ldr	r3, [r7, #24]
 8014ac2:	3301      	adds	r3, #1
 8014ac4:	61bb      	str	r3, [r7, #24]
 8014ac6:	69ba      	ldr	r2, [r7, #24]
 8014ac8:	693b      	ldr	r3, [r7, #16]
 8014aca:	429a      	cmp	r2, r3
 8014acc:	d3e2      	bcc.n	8014a94 <USB_WritePacket+0x34>
    }
  }

  return HAL_OK;
 8014ace:	2300      	movs	r3, #0
}
 8014ad0:	4618      	mov	r0, r3
 8014ad2:	3724      	adds	r7, #36	@ 0x24
 8014ad4:	46bd      	mov	sp, r7
 8014ad6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ada:	4770      	bx	lr

08014adc <USB_ReadPacket>:
  * @param  dest  source pointer
  * @param  len  Number of bytes to read
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(const USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8014adc:	b480      	push	{r7}
 8014ade:	b08b      	sub	sp, #44	@ 0x2c
 8014ae0:	af00      	add	r7, sp, #0
 8014ae2:	60f8      	str	r0, [r7, #12]
 8014ae4:	60b9      	str	r1, [r7, #8]
 8014ae6:	4613      	mov	r3, r2
 8014ae8:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014aea:	68fb      	ldr	r3, [r7, #12]
 8014aec:	61bb      	str	r3, [r7, #24]
  uint8_t *pDest = dest;
 8014aee:	68bb      	ldr	r3, [r7, #8]
 8014af0:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t pData;
  uint32_t i;
  uint32_t count32b = (uint32_t)len >> 2U;
 8014af2:	88fb      	ldrh	r3, [r7, #6]
 8014af4:	089b      	lsrs	r3, r3, #2
 8014af6:	b29b      	uxth	r3, r3
 8014af8:	617b      	str	r3, [r7, #20]
  uint16_t remaining_bytes = len % 4U;
 8014afa:	88fb      	ldrh	r3, [r7, #6]
 8014afc:	f003 0303 	and.w	r3, r3, #3
 8014b00:	83fb      	strh	r3, [r7, #30]

  for (i = 0U; i < count32b; i++)
 8014b02:	2300      	movs	r3, #0
 8014b04:	623b      	str	r3, [r7, #32]
 8014b06:	e014      	b.n	8014b32 <USB_ReadPacket+0x56>
  {
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 8014b08:	69bb      	ldr	r3, [r7, #24]
 8014b0a:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014b0e:	681a      	ldr	r2, [r3, #0]
 8014b10:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b12:	601a      	str	r2, [r3, #0]
    pDest++;
 8014b14:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b16:	3301      	adds	r3, #1
 8014b18:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8014b1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b1c:	3301      	adds	r3, #1
 8014b1e:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8014b20:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b22:	3301      	adds	r3, #1
 8014b24:	627b      	str	r3, [r7, #36]	@ 0x24
    pDest++;
 8014b26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b28:	3301      	adds	r3, #1
 8014b2a:	627b      	str	r3, [r7, #36]	@ 0x24
  for (i = 0U; i < count32b; i++)
 8014b2c:	6a3b      	ldr	r3, [r7, #32]
 8014b2e:	3301      	adds	r3, #1
 8014b30:	623b      	str	r3, [r7, #32]
 8014b32:	6a3a      	ldr	r2, [r7, #32]
 8014b34:	697b      	ldr	r3, [r7, #20]
 8014b36:	429a      	cmp	r2, r3
 8014b38:	d3e6      	bcc.n	8014b08 <USB_ReadPacket+0x2c>
  }

  /* When Number of data is not word aligned, read the remaining byte */
  if (remaining_bytes != 0U)
 8014b3a:	8bfb      	ldrh	r3, [r7, #30]
 8014b3c:	2b00      	cmp	r3, #0
 8014b3e:	d01e      	beq.n	8014b7e <USB_ReadPacket+0xa2>
  {
    i = 0U;
 8014b40:	2300      	movs	r3, #0
 8014b42:	623b      	str	r3, [r7, #32]
    __UNALIGNED_UINT32_WRITE(&pData, USBx_DFIFO(0U));
 8014b44:	69bb      	ldr	r3, [r7, #24]
 8014b46:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 8014b4a:	461a      	mov	r2, r3
 8014b4c:	f107 0310 	add.w	r3, r7, #16
 8014b50:	6812      	ldr	r2, [r2, #0]
 8014b52:	601a      	str	r2, [r3, #0]

    do
    {
      *(uint8_t *)pDest = (uint8_t)(pData >> (8U * (uint8_t)(i)));
 8014b54:	693a      	ldr	r2, [r7, #16]
 8014b56:	6a3b      	ldr	r3, [r7, #32]
 8014b58:	b2db      	uxtb	r3, r3
 8014b5a:	00db      	lsls	r3, r3, #3
 8014b5c:	fa22 f303 	lsr.w	r3, r2, r3
 8014b60:	b2da      	uxtb	r2, r3
 8014b62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b64:	701a      	strb	r2, [r3, #0]
      i++;
 8014b66:	6a3b      	ldr	r3, [r7, #32]
 8014b68:	3301      	adds	r3, #1
 8014b6a:	623b      	str	r3, [r7, #32]
      pDest++;
 8014b6c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8014b6e:	3301      	adds	r3, #1
 8014b70:	627b      	str	r3, [r7, #36]	@ 0x24
      remaining_bytes--;
 8014b72:	8bfb      	ldrh	r3, [r7, #30]
 8014b74:	3b01      	subs	r3, #1
 8014b76:	83fb      	strh	r3, [r7, #30]
    } while (remaining_bytes != 0U);
 8014b78:	8bfb      	ldrh	r3, [r7, #30]
 8014b7a:	2b00      	cmp	r3, #0
 8014b7c:	d1ea      	bne.n	8014b54 <USB_ReadPacket+0x78>
  }

  return ((void *)pDest);
 8014b7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 8014b80:	4618      	mov	r0, r3
 8014b82:	372c      	adds	r7, #44	@ 0x2c
 8014b84:	46bd      	mov	sp, r7
 8014b86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014b8a:	4770      	bx	lr

08014b8c <USB_EPSetStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPSetStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8014b8c:	b480      	push	{r7}
 8014b8e:	b085      	sub	sp, #20
 8014b90:	af00      	add	r7, sp, #0
 8014b92:	6078      	str	r0, [r7, #4]
 8014b94:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014b96:	687b      	ldr	r3, [r7, #4]
 8014b98:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8014b9a:	683b      	ldr	r3, [r7, #0]
 8014b9c:	781b      	ldrb	r3, [r3, #0]
 8014b9e:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8014ba0:	683b      	ldr	r3, [r7, #0]
 8014ba2:	785b      	ldrb	r3, [r3, #1]
 8014ba4:	2b01      	cmp	r3, #1
 8014ba6:	d12c      	bne.n	8014c02 <USB_EPSetStall+0x76>
  {
    if (((USBx_INEP(epnum)->DIEPCTL & USB_OTG_DIEPCTL_EPENA) == 0U) && (epnum != 0U))
 8014ba8:	68bb      	ldr	r3, [r7, #8]
 8014baa:	015a      	lsls	r2, r3, #5
 8014bac:	68fb      	ldr	r3, [r7, #12]
 8014bae:	4413      	add	r3, r2
 8014bb0:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014bb4:	681b      	ldr	r3, [r3, #0]
 8014bb6:	2b00      	cmp	r3, #0
 8014bb8:	db12      	blt.n	8014be0 <USB_EPSetStall+0x54>
 8014bba:	68bb      	ldr	r3, [r7, #8]
 8014bbc:	2b00      	cmp	r3, #0
 8014bbe:	d00f      	beq.n	8014be0 <USB_EPSetStall+0x54>
    {
      USBx_INEP(epnum)->DIEPCTL &= ~(USB_OTG_DIEPCTL_EPDIS);
 8014bc0:	68bb      	ldr	r3, [r7, #8]
 8014bc2:	015a      	lsls	r2, r3, #5
 8014bc4:	68fb      	ldr	r3, [r7, #12]
 8014bc6:	4413      	add	r3, r2
 8014bc8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014bcc:	681b      	ldr	r3, [r3, #0]
 8014bce:	68ba      	ldr	r2, [r7, #8]
 8014bd0:	0151      	lsls	r1, r2, #5
 8014bd2:	68fa      	ldr	r2, [r7, #12]
 8014bd4:	440a      	add	r2, r1
 8014bd6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014bda:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8014bde:	6013      	str	r3, [r2, #0]
    }
    USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_STALL;
 8014be0:	68bb      	ldr	r3, [r7, #8]
 8014be2:	015a      	lsls	r2, r3, #5
 8014be4:	68fb      	ldr	r3, [r7, #12]
 8014be6:	4413      	add	r3, r2
 8014be8:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014bec:	681b      	ldr	r3, [r3, #0]
 8014bee:	68ba      	ldr	r2, [r7, #8]
 8014bf0:	0151      	lsls	r1, r2, #5
 8014bf2:	68fa      	ldr	r2, [r7, #12]
 8014bf4:	440a      	add	r2, r1
 8014bf6:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014bfa:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8014bfe:	6013      	str	r3, [r2, #0]
 8014c00:	e02b      	b.n	8014c5a <USB_EPSetStall+0xce>
  }
  else
  {
    if (((USBx_OUTEP(epnum)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == 0U) && (epnum != 0U))
 8014c02:	68bb      	ldr	r3, [r7, #8]
 8014c04:	015a      	lsls	r2, r3, #5
 8014c06:	68fb      	ldr	r3, [r7, #12]
 8014c08:	4413      	add	r3, r2
 8014c0a:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014c0e:	681b      	ldr	r3, [r3, #0]
 8014c10:	2b00      	cmp	r3, #0
 8014c12:	db12      	blt.n	8014c3a <USB_EPSetStall+0xae>
 8014c14:	68bb      	ldr	r3, [r7, #8]
 8014c16:	2b00      	cmp	r3, #0
 8014c18:	d00f      	beq.n	8014c3a <USB_EPSetStall+0xae>
    {
      USBx_OUTEP(epnum)->DOEPCTL &= ~(USB_OTG_DOEPCTL_EPDIS);
 8014c1a:	68bb      	ldr	r3, [r7, #8]
 8014c1c:	015a      	lsls	r2, r3, #5
 8014c1e:	68fb      	ldr	r3, [r7, #12]
 8014c20:	4413      	add	r3, r2
 8014c22:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014c26:	681b      	ldr	r3, [r3, #0]
 8014c28:	68ba      	ldr	r2, [r7, #8]
 8014c2a:	0151      	lsls	r1, r2, #5
 8014c2c:	68fa      	ldr	r2, [r7, #12]
 8014c2e:	440a      	add	r2, r1
 8014c30:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014c34:	f023 4380 	bic.w	r3, r3, #1073741824	@ 0x40000000
 8014c38:	6013      	str	r3, [r2, #0]
    }
    USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_STALL;
 8014c3a:	68bb      	ldr	r3, [r7, #8]
 8014c3c:	015a      	lsls	r2, r3, #5
 8014c3e:	68fb      	ldr	r3, [r7, #12]
 8014c40:	4413      	add	r3, r2
 8014c42:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014c46:	681b      	ldr	r3, [r3, #0]
 8014c48:	68ba      	ldr	r2, [r7, #8]
 8014c4a:	0151      	lsls	r1, r2, #5
 8014c4c:	68fa      	ldr	r2, [r7, #12]
 8014c4e:	440a      	add	r2, r1
 8014c50:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014c54:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 8014c58:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8014c5a:	2300      	movs	r3, #0
}
 8014c5c:	4618      	mov	r0, r3
 8014c5e:	3714      	adds	r7, #20
 8014c60:	46bd      	mov	sp, r7
 8014c62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014c66:	4770      	bx	lr

08014c68 <USB_EPClearStall>:
  * @param  USBx  Selected device
  * @param  ep pointer to endpoint structure
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EPClearStall(const USB_OTG_GlobalTypeDef *USBx, const USB_OTG_EPTypeDef *ep)
{
 8014c68:	b480      	push	{r7}
 8014c6a:	b085      	sub	sp, #20
 8014c6c:	af00      	add	r7, sp, #0
 8014c6e:	6078      	str	r0, [r7, #4]
 8014c70:	6039      	str	r1, [r7, #0]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014c72:	687b      	ldr	r3, [r7, #4]
 8014c74:	60fb      	str	r3, [r7, #12]
  uint32_t epnum = (uint32_t)ep->num;
 8014c76:	683b      	ldr	r3, [r7, #0]
 8014c78:	781b      	ldrb	r3, [r3, #0]
 8014c7a:	60bb      	str	r3, [r7, #8]

  if (ep->is_in == 1U)
 8014c7c:	683b      	ldr	r3, [r7, #0]
 8014c7e:	785b      	ldrb	r3, [r3, #1]
 8014c80:	2b01      	cmp	r3, #1
 8014c82:	d128      	bne.n	8014cd6 <USB_EPClearStall+0x6e>
  {
    USBx_INEP(epnum)->DIEPCTL &= ~USB_OTG_DIEPCTL_STALL;
 8014c84:	68bb      	ldr	r3, [r7, #8]
 8014c86:	015a      	lsls	r2, r3, #5
 8014c88:	68fb      	ldr	r3, [r7, #12]
 8014c8a:	4413      	add	r3, r2
 8014c8c:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014c90:	681b      	ldr	r3, [r3, #0]
 8014c92:	68ba      	ldr	r2, [r7, #8]
 8014c94:	0151      	lsls	r1, r2, #5
 8014c96:	68fa      	ldr	r2, [r7, #12]
 8014c98:	440a      	add	r2, r1
 8014c9a:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014c9e:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8014ca2:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8014ca4:	683b      	ldr	r3, [r7, #0]
 8014ca6:	791b      	ldrb	r3, [r3, #4]
 8014ca8:	2b03      	cmp	r3, #3
 8014caa:	d003      	beq.n	8014cb4 <USB_EPClearStall+0x4c>
 8014cac:	683b      	ldr	r3, [r7, #0]
 8014cae:	791b      	ldrb	r3, [r3, #4]
 8014cb0:	2b02      	cmp	r3, #2
 8014cb2:	d138      	bne.n	8014d26 <USB_EPClearStall+0xbe>
    {
      USBx_INEP(epnum)->DIEPCTL |= USB_OTG_DIEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8014cb4:	68bb      	ldr	r3, [r7, #8]
 8014cb6:	015a      	lsls	r2, r3, #5
 8014cb8:	68fb      	ldr	r3, [r7, #12]
 8014cba:	4413      	add	r3, r2
 8014cbc:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014cc0:	681b      	ldr	r3, [r3, #0]
 8014cc2:	68ba      	ldr	r2, [r7, #8]
 8014cc4:	0151      	lsls	r1, r2, #5
 8014cc6:	68fa      	ldr	r2, [r7, #12]
 8014cc8:	440a      	add	r2, r1
 8014cca:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014cce:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8014cd2:	6013      	str	r3, [r2, #0]
 8014cd4:	e027      	b.n	8014d26 <USB_EPClearStall+0xbe>
    }
  }
  else
  {
    USBx_OUTEP(epnum)->DOEPCTL &= ~USB_OTG_DOEPCTL_STALL;
 8014cd6:	68bb      	ldr	r3, [r7, #8]
 8014cd8:	015a      	lsls	r2, r3, #5
 8014cda:	68fb      	ldr	r3, [r7, #12]
 8014cdc:	4413      	add	r3, r2
 8014cde:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014ce2:	681b      	ldr	r3, [r3, #0]
 8014ce4:	68ba      	ldr	r2, [r7, #8]
 8014ce6:	0151      	lsls	r1, r2, #5
 8014ce8:	68fa      	ldr	r2, [r7, #12]
 8014cea:	440a      	add	r2, r1
 8014cec:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014cf0:	f423 1300 	bic.w	r3, r3, #2097152	@ 0x200000
 8014cf4:	6013      	str	r3, [r2, #0]
    if ((ep->type == EP_TYPE_INTR) || (ep->type == EP_TYPE_BULK))
 8014cf6:	683b      	ldr	r3, [r7, #0]
 8014cf8:	791b      	ldrb	r3, [r3, #4]
 8014cfa:	2b03      	cmp	r3, #3
 8014cfc:	d003      	beq.n	8014d06 <USB_EPClearStall+0x9e>
 8014cfe:	683b      	ldr	r3, [r7, #0]
 8014d00:	791b      	ldrb	r3, [r3, #4]
 8014d02:	2b02      	cmp	r3, #2
 8014d04:	d10f      	bne.n	8014d26 <USB_EPClearStall+0xbe>
    {
      USBx_OUTEP(epnum)->DOEPCTL |= USB_OTG_DOEPCTL_SD0PID_SEVNFRM; /* DATA0 */
 8014d06:	68bb      	ldr	r3, [r7, #8]
 8014d08:	015a      	lsls	r2, r3, #5
 8014d0a:	68fb      	ldr	r3, [r7, #12]
 8014d0c:	4413      	add	r3, r2
 8014d0e:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014d12:	681b      	ldr	r3, [r3, #0]
 8014d14:	68ba      	ldr	r2, [r7, #8]
 8014d16:	0151      	lsls	r1, r2, #5
 8014d18:	68fa      	ldr	r2, [r7, #12]
 8014d1a:	440a      	add	r2, r1
 8014d1c:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014d20:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8014d24:	6013      	str	r3, [r2, #0]
    }
  }
  return HAL_OK;
 8014d26:	2300      	movs	r3, #0
}
 8014d28:	4618      	mov	r0, r3
 8014d2a:	3714      	adds	r7, #20
 8014d2c:	46bd      	mov	sp, r7
 8014d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d32:	4770      	bx	lr

08014d34 <USB_SetDevAddress>:
  * @param  address  new device address to be assigned
  *          This parameter can be a value from 0 to 255
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetDevAddress(const USB_OTG_GlobalTypeDef *USBx, uint8_t address)
{
 8014d34:	b480      	push	{r7}
 8014d36:	b085      	sub	sp, #20
 8014d38:	af00      	add	r7, sp, #0
 8014d3a:	6078      	str	r0, [r7, #4]
 8014d3c:	460b      	mov	r3, r1
 8014d3e:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014d40:	687b      	ldr	r3, [r7, #4]
 8014d42:	60fb      	str	r3, [r7, #12]

  USBx_DEVICE->DCFG &= ~(USB_OTG_DCFG_DAD);
 8014d44:	68fb      	ldr	r3, [r7, #12]
 8014d46:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014d4a:	681b      	ldr	r3, [r3, #0]
 8014d4c:	68fa      	ldr	r2, [r7, #12]
 8014d4e:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8014d52:	f423 63fe 	bic.w	r3, r3, #2032	@ 0x7f0
 8014d56:	6013      	str	r3, [r2, #0]
  USBx_DEVICE->DCFG |= ((uint32_t)address << 4) & USB_OTG_DCFG_DAD;
 8014d58:	68fb      	ldr	r3, [r7, #12]
 8014d5a:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014d5e:	681a      	ldr	r2, [r3, #0]
 8014d60:	78fb      	ldrb	r3, [r7, #3]
 8014d62:	011b      	lsls	r3, r3, #4
 8014d64:	f403 63fe 	and.w	r3, r3, #2032	@ 0x7f0
 8014d68:	68f9      	ldr	r1, [r7, #12]
 8014d6a:	f501 6100 	add.w	r1, r1, #2048	@ 0x800
 8014d6e:	4313      	orrs	r3, r2
 8014d70:	600b      	str	r3, [r1, #0]

  return HAL_OK;
 8014d72:	2300      	movs	r3, #0
}
 8014d74:	4618      	mov	r0, r3
 8014d76:	3714      	adds	r7, #20
 8014d78:	46bd      	mov	sp, r7
 8014d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014d7e:	4770      	bx	lr

08014d80 <USB_DevConnect>:
  * @brief  USB_DevConnect : Connect the USB device by enabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevConnect(const USB_OTG_GlobalTypeDef *USBx)
{
 8014d80:	b480      	push	{r7}
 8014d82:	b085      	sub	sp, #20
 8014d84:	af00      	add	r7, sp, #0
 8014d86:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014d88:	687b      	ldr	r3, [r7, #4]
 8014d8a:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8014d8c:	68fb      	ldr	r3, [r7, #12]
 8014d8e:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8014d92:	681b      	ldr	r3, [r3, #0]
 8014d94:	68fa      	ldr	r2, [r7, #12]
 8014d96:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 8014d9a:	f023 0303 	bic.w	r3, r3, #3
 8014d9e:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL &= ~USB_OTG_DCTL_SDIS;
 8014da0:	68fb      	ldr	r3, [r7, #12]
 8014da2:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014da6:	685b      	ldr	r3, [r3, #4]
 8014da8:	68fa      	ldr	r2, [r7, #12]
 8014daa:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8014dae:	f023 0302 	bic.w	r3, r3, #2
 8014db2:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8014db4:	2300      	movs	r3, #0
}
 8014db6:	4618      	mov	r0, r3
 8014db8:	3714      	adds	r7, #20
 8014dba:	46bd      	mov	sp, r7
 8014dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014dc0:	4770      	bx	lr

08014dc2 <USB_DevDisconnect>:
  * @brief  USB_DevDisconnect : Disconnect the USB device by disabling Rpu
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevDisconnect(const USB_OTG_GlobalTypeDef *USBx)
{
 8014dc2:	b480      	push	{r7}
 8014dc4:	b085      	sub	sp, #20
 8014dc6:	af00      	add	r7, sp, #0
 8014dc8:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014dca:	687b      	ldr	r3, [r7, #4]
 8014dcc:	60fb      	str	r3, [r7, #12]

  /* In case phy is stopped, ensure to ungate and restore the phy CLK */
  USBx_PCGCCTL &= ~(USB_OTG_PCGCCTL_STOPCLK | USB_OTG_PCGCCTL_GATECLK);
 8014dce:	68fb      	ldr	r3, [r7, #12]
 8014dd0:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 8014dd4:	681b      	ldr	r3, [r3, #0]
 8014dd6:	68fa      	ldr	r2, [r7, #12]
 8014dd8:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 8014ddc:	f023 0303 	bic.w	r3, r3, #3
 8014de0:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_SDIS;
 8014de2:	68fb      	ldr	r3, [r7, #12]
 8014de4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014de8:	685b      	ldr	r3, [r3, #4]
 8014dea:	68fa      	ldr	r2, [r7, #12]
 8014dec:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8014df0:	f043 0302 	orr.w	r3, r3, #2
 8014df4:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8014df6:	2300      	movs	r3, #0
}
 8014df8:	4618      	mov	r0, r3
 8014dfa:	3714      	adds	r7, #20
 8014dfc:	46bd      	mov	sp, r7
 8014dfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e02:	4770      	bx	lr

08014e04 <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval USB Global Interrupt status
  */
uint32_t USB_ReadInterrupts(USB_OTG_GlobalTypeDef const *USBx)
{
 8014e04:	b480      	push	{r7}
 8014e06:	b085      	sub	sp, #20
 8014e08:	af00      	add	r7, sp, #0
 8014e0a:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8014e0c:	687b      	ldr	r3, [r7, #4]
 8014e0e:	695b      	ldr	r3, [r3, #20]
 8014e10:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 8014e12:	687b      	ldr	r3, [r7, #4]
 8014e14:	699b      	ldr	r3, [r3, #24]
 8014e16:	68fa      	ldr	r2, [r7, #12]
 8014e18:	4013      	ands	r3, r2
 8014e1a:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 8014e1c:	68fb      	ldr	r3, [r7, #12]
}
 8014e1e:	4618      	mov	r0, r3
 8014e20:	3714      	adds	r7, #20
 8014e22:	46bd      	mov	sp, r7
 8014e24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e28:	4770      	bx	lr

08014e2a <USB_ReadDevAllOutEpInterrupt>:
  * @brief  USB_ReadDevAllOutEpInterrupt: return the USB device OUT endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device OUT EP interrupt status
  */
uint32_t USB_ReadDevAllOutEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 8014e2a:	b480      	push	{r7}
 8014e2c:	b085      	sub	sp, #20
 8014e2e:	af00      	add	r7, sp, #0
 8014e30:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014e32:	687b      	ldr	r3, [r7, #4]
 8014e34:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8014e36:	68fb      	ldr	r3, [r7, #12]
 8014e38:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014e3c:	699b      	ldr	r3, [r3, #24]
 8014e3e:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8014e40:	68fb      	ldr	r3, [r7, #12]
 8014e42:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014e46:	69db      	ldr	r3, [r3, #28]
 8014e48:	68ba      	ldr	r2, [r7, #8]
 8014e4a:	4013      	ands	r3, r2
 8014e4c:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xffff0000U) >> 16);
 8014e4e:	68bb      	ldr	r3, [r7, #8]
 8014e50:	0c1b      	lsrs	r3, r3, #16
}
 8014e52:	4618      	mov	r0, r3
 8014e54:	3714      	adds	r7, #20
 8014e56:	46bd      	mov	sp, r7
 8014e58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e5c:	4770      	bx	lr

08014e5e <USB_ReadDevAllInEpInterrupt>:
  * @brief  USB_ReadDevAllInEpInterrupt: return the USB device IN endpoints interrupt status
  * @param  USBx  Selected device
  * @retval USB Device IN EP interrupt status
  */
uint32_t USB_ReadDevAllInEpInterrupt(const USB_OTG_GlobalTypeDef *USBx)
{
 8014e5e:	b480      	push	{r7}
 8014e60:	b085      	sub	sp, #20
 8014e62:	af00      	add	r7, sp, #0
 8014e64:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014e66:	687b      	ldr	r3, [r7, #4]
 8014e68:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_DEVICE->DAINT;
 8014e6a:	68fb      	ldr	r3, [r7, #12]
 8014e6c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014e70:	699b      	ldr	r3, [r3, #24]
 8014e72:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DAINTMSK;
 8014e74:	68fb      	ldr	r3, [r7, #12]
 8014e76:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014e7a:	69db      	ldr	r3, [r3, #28]
 8014e7c:	68ba      	ldr	r2, [r7, #8]
 8014e7e:	4013      	ands	r3, r2
 8014e80:	60bb      	str	r3, [r7, #8]

  return ((tmpreg & 0xFFFFU));
 8014e82:	68bb      	ldr	r3, [r7, #8]
 8014e84:	b29b      	uxth	r3, r3
}
 8014e86:	4618      	mov	r0, r3
 8014e88:	3714      	adds	r7, #20
 8014e8a:	46bd      	mov	sp, r7
 8014e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014e90:	4770      	bx	lr

08014e92 <USB_ReadDevOutEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device OUT EP Interrupt register
  */
uint32_t USB_ReadDevOutEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 8014e92:	b480      	push	{r7}
 8014e94:	b085      	sub	sp, #20
 8014e96:	af00      	add	r7, sp, #0
 8014e98:	6078      	str	r0, [r7, #4]
 8014e9a:	460b      	mov	r3, r1
 8014e9c:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014e9e:	687b      	ldr	r3, [r7, #4]
 8014ea0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  tmpreg  = USBx_OUTEP((uint32_t)epnum)->DOEPINT;
 8014ea2:	78fb      	ldrb	r3, [r7, #3]
 8014ea4:	015a      	lsls	r2, r3, #5
 8014ea6:	68fb      	ldr	r3, [r7, #12]
 8014ea8:	4413      	add	r3, r2
 8014eaa:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014eae:	689b      	ldr	r3, [r3, #8]
 8014eb0:	60bb      	str	r3, [r7, #8]
  tmpreg &= USBx_DEVICE->DOEPMSK;
 8014eb2:	68fb      	ldr	r3, [r7, #12]
 8014eb4:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014eb8:	695b      	ldr	r3, [r3, #20]
 8014eba:	68ba      	ldr	r2, [r7, #8]
 8014ebc:	4013      	ands	r3, r2
 8014ebe:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8014ec0:	68bb      	ldr	r3, [r7, #8]
}
 8014ec2:	4618      	mov	r0, r3
 8014ec4:	3714      	adds	r7, #20
 8014ec6:	46bd      	mov	sp, r7
 8014ec8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ecc:	4770      	bx	lr

08014ece <USB_ReadDevInEPInterrupt>:
  * @param  epnum  endpoint number
  *          This parameter can be a value from 0 to 15
  * @retval Device IN EP Interrupt register
  */
uint32_t USB_ReadDevInEPInterrupt(const USB_OTG_GlobalTypeDef *USBx, uint8_t epnum)
{
 8014ece:	b480      	push	{r7}
 8014ed0:	b087      	sub	sp, #28
 8014ed2:	af00      	add	r7, sp, #0
 8014ed4:	6078      	str	r0, [r7, #4]
 8014ed6:	460b      	mov	r3, r1
 8014ed8:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014eda:	687b      	ldr	r3, [r7, #4]
 8014edc:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg;
  uint32_t msk;
  uint32_t emp;

  msk = USBx_DEVICE->DIEPMSK;
 8014ede:	697b      	ldr	r3, [r7, #20]
 8014ee0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014ee4:	691b      	ldr	r3, [r3, #16]
 8014ee6:	613b      	str	r3, [r7, #16]
  emp = USBx_DEVICE->DIEPEMPMSK;
 8014ee8:	697b      	ldr	r3, [r7, #20]
 8014eea:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014eee:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8014ef0:	60fb      	str	r3, [r7, #12]
  msk |= ((emp >> (epnum & EP_ADDR_MSK)) & 0x1U) << 7;
 8014ef2:	78fb      	ldrb	r3, [r7, #3]
 8014ef4:	f003 030f 	and.w	r3, r3, #15
 8014ef8:	68fa      	ldr	r2, [r7, #12]
 8014efa:	fa22 f303 	lsr.w	r3, r2, r3
 8014efe:	01db      	lsls	r3, r3, #7
 8014f00:	b2db      	uxtb	r3, r3
 8014f02:	693a      	ldr	r2, [r7, #16]
 8014f04:	4313      	orrs	r3, r2
 8014f06:	613b      	str	r3, [r7, #16]
  tmpreg = USBx_INEP((uint32_t)epnum)->DIEPINT & msk;
 8014f08:	78fb      	ldrb	r3, [r7, #3]
 8014f0a:	015a      	lsls	r2, r3, #5
 8014f0c:	697b      	ldr	r3, [r7, #20]
 8014f0e:	4413      	add	r3, r2
 8014f10:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014f14:	689b      	ldr	r3, [r3, #8]
 8014f16:	693a      	ldr	r2, [r7, #16]
 8014f18:	4013      	ands	r3, r2
 8014f1a:	60bb      	str	r3, [r7, #8]

  return tmpreg;
 8014f1c:	68bb      	ldr	r3, [r7, #8]
}
 8014f1e:	4618      	mov	r0, r3
 8014f20:	371c      	adds	r7, #28
 8014f22:	46bd      	mov	sp, r7
 8014f24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f28:	4770      	bx	lr

08014f2a <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(const USB_OTG_GlobalTypeDef *USBx)
{
 8014f2a:	b480      	push	{r7}
 8014f2c:	b083      	sub	sp, #12
 8014f2e:	af00      	add	r7, sp, #0
 8014f30:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 8014f32:	687b      	ldr	r3, [r7, #4]
 8014f34:	695b      	ldr	r3, [r3, #20]
 8014f36:	f003 0301 	and.w	r3, r3, #1
}
 8014f3a:	4618      	mov	r0, r3
 8014f3c:	370c      	adds	r7, #12
 8014f3e:	46bd      	mov	sp, r7
 8014f40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f44:	4770      	bx	lr

08014f46 <USB_ActivateSetup>:
  * @brief  Activate EP0 for Setup transactions
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_ActivateSetup(const USB_OTG_GlobalTypeDef *USBx)
{
 8014f46:	b480      	push	{r7}
 8014f48:	b085      	sub	sp, #20
 8014f4a:	af00      	add	r7, sp, #0
 8014f4c:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014f4e:	687b      	ldr	r3, [r7, #4]
 8014f50:	60fb      	str	r3, [r7, #12]

  /* Set the MPS of the IN EP0 to 64 bytes */
  USBx_INEP(0U)->DIEPCTL &= ~USB_OTG_DIEPCTL_MPSIZ;
 8014f52:	68fb      	ldr	r3, [r7, #12]
 8014f54:	f503 6310 	add.w	r3, r3, #2304	@ 0x900
 8014f58:	681b      	ldr	r3, [r3, #0]
 8014f5a:	68fa      	ldr	r2, [r7, #12]
 8014f5c:	f502 6210 	add.w	r2, r2, #2304	@ 0x900
 8014f60:	f423 63ff 	bic.w	r3, r3, #2040	@ 0x7f8
 8014f64:	f023 0307 	bic.w	r3, r3, #7
 8014f68:	6013      	str	r3, [r2, #0]

  USBx_DEVICE->DCTL |= USB_OTG_DCTL_CGINAK;
 8014f6a:	68fb      	ldr	r3, [r7, #12]
 8014f6c:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8014f70:	685b      	ldr	r3, [r3, #4]
 8014f72:	68fa      	ldr	r2, [r7, #12]
 8014f74:	f502 6200 	add.w	r2, r2, #2048	@ 0x800
 8014f78:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8014f7c:	6053      	str	r3, [r2, #4]

  return HAL_OK;
 8014f7e:	2300      	movs	r3, #0
}
 8014f80:	4618      	mov	r0, r3
 8014f82:	3714      	adds	r7, #20
 8014f84:	46bd      	mov	sp, r7
 8014f86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f8a:	4770      	bx	lr

08014f8c <USB_EP0_OutStart>:
  *           1 : DMA feature used
  * @param  psetup  pointer to setup packet
  * @retval HAL status
  */
HAL_StatusTypeDef USB_EP0_OutStart(const USB_OTG_GlobalTypeDef *USBx, uint8_t dma, const uint8_t *psetup)
{
 8014f8c:	b480      	push	{r7}
 8014f8e:	b087      	sub	sp, #28
 8014f90:	af00      	add	r7, sp, #0
 8014f92:	60f8      	str	r0, [r7, #12]
 8014f94:	460b      	mov	r3, r1
 8014f96:	607a      	str	r2, [r7, #4]
 8014f98:	72fb      	strb	r3, [r7, #11]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8014f9a:	68fb      	ldr	r3, [r7, #12]
 8014f9c:	617b      	str	r3, [r7, #20]
  uint32_t gSNPSiD = *(__IO const uint32_t *)(&USBx->CID + 0x1U);
 8014f9e:	68fb      	ldr	r3, [r7, #12]
 8014fa0:	333c      	adds	r3, #60	@ 0x3c
 8014fa2:	3304      	adds	r3, #4
 8014fa4:	681b      	ldr	r3, [r3, #0]
 8014fa6:	613b      	str	r3, [r7, #16]

  if (gSNPSiD > USB_OTG_CORE_ID_300A)
 8014fa8:	693b      	ldr	r3, [r7, #16]
 8014faa:	4a26      	ldr	r2, [pc, #152]	@ (8015044 <USB_EP0_OutStart+0xb8>)
 8014fac:	4293      	cmp	r3, r2
 8014fae:	d90a      	bls.n	8014fc6 <USB_EP0_OutStart+0x3a>
  {
    if ((USBx_OUTEP(0U)->DOEPCTL & USB_OTG_DOEPCTL_EPENA) == USB_OTG_DOEPCTL_EPENA)
 8014fb0:	697b      	ldr	r3, [r7, #20]
 8014fb2:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014fb6:	681b      	ldr	r3, [r3, #0]
 8014fb8:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8014fbc:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8014fc0:	d101      	bne.n	8014fc6 <USB_EP0_OutStart+0x3a>
    {
      return HAL_OK;
 8014fc2:	2300      	movs	r3, #0
 8014fc4:	e037      	b.n	8015036 <USB_EP0_OutStart+0xaa>
    }
  }

  USBx_OUTEP(0U)->DOEPTSIZ = 0U;
 8014fc6:	697b      	ldr	r3, [r7, #20]
 8014fc8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014fcc:	461a      	mov	r2, r3
 8014fce:	2300      	movs	r3, #0
 8014fd0:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (USB_OTG_DOEPTSIZ_PKTCNT & (1U << 19));
 8014fd2:	697b      	ldr	r3, [r7, #20]
 8014fd4:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014fd8:	691b      	ldr	r3, [r3, #16]
 8014fda:	697a      	ldr	r2, [r7, #20]
 8014fdc:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014fe0:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8014fe4:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |= (3U * 8U);
 8014fe6:	697b      	ldr	r3, [r7, #20]
 8014fe8:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8014fec:	691b      	ldr	r3, [r3, #16]
 8014fee:	697a      	ldr	r2, [r7, #20]
 8014ff0:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8014ff4:	f043 0318 	orr.w	r3, r3, #24
 8014ff8:	6113      	str	r3, [r2, #16]
  USBx_OUTEP(0U)->DOEPTSIZ |=  USB_OTG_DOEPTSIZ_STUPCNT;
 8014ffa:	697b      	ldr	r3, [r7, #20]
 8014ffc:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8015000:	691b      	ldr	r3, [r3, #16]
 8015002:	697a      	ldr	r2, [r7, #20]
 8015004:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 8015008:	f043 43c0 	orr.w	r3, r3, #1610612736	@ 0x60000000
 801500c:	6113      	str	r3, [r2, #16]

  if (dma == 1U)
 801500e:	7afb      	ldrb	r3, [r7, #11]
 8015010:	2b01      	cmp	r3, #1
 8015012:	d10f      	bne.n	8015034 <USB_EP0_OutStart+0xa8>
  {
    USBx_OUTEP(0U)->DOEPDMA = (uint32_t)psetup;
 8015014:	697b      	ldr	r3, [r7, #20]
 8015016:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 801501a:	461a      	mov	r2, r3
 801501c:	687b      	ldr	r3, [r7, #4]
 801501e:	6153      	str	r3, [r2, #20]
    /* EP enable */
    USBx_OUTEP(0U)->DOEPCTL |= USB_OTG_DOEPCTL_EPENA | USB_OTG_DOEPCTL_USBAEP;
 8015020:	697b      	ldr	r3, [r7, #20]
 8015022:	f503 6330 	add.w	r3, r3, #2816	@ 0xb00
 8015026:	681b      	ldr	r3, [r3, #0]
 8015028:	697a      	ldr	r2, [r7, #20]
 801502a:	f502 6230 	add.w	r2, r2, #2816	@ 0xb00
 801502e:	f043 2380 	orr.w	r3, r3, #2147516416	@ 0x80008000
 8015032:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8015034:	2300      	movs	r3, #0
}
 8015036:	4618      	mov	r0, r3
 8015038:	371c      	adds	r7, #28
 801503a:	46bd      	mov	sp, r7
 801503c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015040:	4770      	bx	lr
 8015042:	bf00      	nop
 8015044:	4f54300a 	.word	0x4f54300a

08015048 <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8015048:	b480      	push	{r7}
 801504a:	b085      	sub	sp, #20
 801504c:	af00      	add	r7, sp, #0
 801504e:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
 8015050:	2300      	movs	r3, #0
 8015052:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    count++;
 8015054:	68fb      	ldr	r3, [r7, #12]
 8015056:	3301      	adds	r3, #1
 8015058:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 801505a:	68fb      	ldr	r3, [r7, #12]
 801505c:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 8015060:	d901      	bls.n	8015066 <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 8015062:	2303      	movs	r3, #3
 8015064:	e01b      	b.n	801509e <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8015066:	687b      	ldr	r3, [r7, #4]
 8015068:	691b      	ldr	r3, [r3, #16]
 801506a:	2b00      	cmp	r3, #0
 801506c:	daf2      	bge.n	8015054 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 801506e:	2300      	movs	r3, #0
 8015070:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8015072:	687b      	ldr	r3, [r7, #4]
 8015074:	691b      	ldr	r3, [r3, #16]
 8015076:	f043 0201 	orr.w	r2, r3, #1
 801507a:	687b      	ldr	r3, [r7, #4]
 801507c:	611a      	str	r2, [r3, #16]

  do
  {
    count++;
 801507e:	68fb      	ldr	r3, [r7, #12]
 8015080:	3301      	adds	r3, #1
 8015082:	60fb      	str	r3, [r7, #12]

    if (count > HAL_USB_TIMEOUT)
 8015084:	68fb      	ldr	r3, [r7, #12]
 8015086:	f1b3 6f70 	cmp.w	r3, #251658240	@ 0xf000000
 801508a:	d901      	bls.n	8015090 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 801508c:	2303      	movs	r3, #3
 801508e:	e006      	b.n	801509e <USB_CoreReset+0x56>
    }
  } while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8015090:	687b      	ldr	r3, [r7, #4]
 8015092:	691b      	ldr	r3, [r3, #16]
 8015094:	f003 0301 	and.w	r3, r3, #1
 8015098:	2b01      	cmp	r3, #1
 801509a:	d0f0      	beq.n	801507e <USB_CoreReset+0x36>

  return HAL_OK;
 801509c:	2300      	movs	r3, #0
}
 801509e:	4618      	mov	r0, r3
 80150a0:	3714      	adds	r7, #20
 80150a2:	46bd      	mov	sp, r7
 80150a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80150a8:	4770      	bx	lr
	...

080150ac <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
 80150ac:	b580      	push	{r7, lr}
 80150ae:	b084      	sub	sp, #16
 80150b0:	af00      	add	r7, sp, #0
 80150b2:	4603      	mov	r3, r0
 80150b4:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 80150b6:	79fb      	ldrb	r3, [r7, #7]
 80150b8:	4a08      	ldr	r2, [pc, #32]	@ (80150dc <disk_status+0x30>)
 80150ba:	009b      	lsls	r3, r3, #2
 80150bc:	4413      	add	r3, r2
 80150be:	685b      	ldr	r3, [r3, #4]
 80150c0:	685b      	ldr	r3, [r3, #4]
 80150c2:	79fa      	ldrb	r2, [r7, #7]
 80150c4:	4905      	ldr	r1, [pc, #20]	@ (80150dc <disk_status+0x30>)
 80150c6:	440a      	add	r2, r1
 80150c8:	7b12      	ldrb	r2, [r2, #12]
 80150ca:	4610      	mov	r0, r2
 80150cc:	4798      	blx	r3
 80150ce:	4603      	mov	r3, r0
 80150d0:	73fb      	strb	r3, [r7, #15]
  return stat;
 80150d2:	7bfb      	ldrb	r3, [r7, #15]
}
 80150d4:	4618      	mov	r0, r3
 80150d6:	3710      	adds	r7, #16
 80150d8:	46bd      	mov	sp, r7
 80150da:	bd80      	pop	{r7, pc}
 80150dc:	2000a80c 	.word	0x2000a80c

080150e0 <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
 80150e0:	b580      	push	{r7, lr}
 80150e2:	b084      	sub	sp, #16
 80150e4:	af00      	add	r7, sp, #0
 80150e6:	4603      	mov	r3, r0
 80150e8:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat = RES_OK;
 80150ea:	2300      	movs	r3, #0
 80150ec:	73fb      	strb	r3, [r7, #15]

  if(disk.is_initialized[pdrv] == 0)
 80150ee:	79fb      	ldrb	r3, [r7, #7]
 80150f0:	4a0d      	ldr	r2, [pc, #52]	@ (8015128 <disk_initialize+0x48>)
 80150f2:	5cd3      	ldrb	r3, [r2, r3]
 80150f4:	2b00      	cmp	r3, #0
 80150f6:	d111      	bne.n	801511c <disk_initialize+0x3c>
  {
    disk.is_initialized[pdrv] = 1;
 80150f8:	79fb      	ldrb	r3, [r7, #7]
 80150fa:	4a0b      	ldr	r2, [pc, #44]	@ (8015128 <disk_initialize+0x48>)
 80150fc:	2101      	movs	r1, #1
 80150fe:	54d1      	strb	r1, [r2, r3]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 8015100:	79fb      	ldrb	r3, [r7, #7]
 8015102:	4a09      	ldr	r2, [pc, #36]	@ (8015128 <disk_initialize+0x48>)
 8015104:	009b      	lsls	r3, r3, #2
 8015106:	4413      	add	r3, r2
 8015108:	685b      	ldr	r3, [r3, #4]
 801510a:	681b      	ldr	r3, [r3, #0]
 801510c:	79fa      	ldrb	r2, [r7, #7]
 801510e:	4906      	ldr	r1, [pc, #24]	@ (8015128 <disk_initialize+0x48>)
 8015110:	440a      	add	r2, r1
 8015112:	7b12      	ldrb	r2, [r2, #12]
 8015114:	4610      	mov	r0, r2
 8015116:	4798      	blx	r3
 8015118:	4603      	mov	r3, r0
 801511a:	73fb      	strb	r3, [r7, #15]
  }
  return stat;
 801511c:	7bfb      	ldrb	r3, [r7, #15]
}
 801511e:	4618      	mov	r0, r3
 8015120:	3710      	adds	r7, #16
 8015122:	46bd      	mov	sp, r7
 8015124:	bd80      	pop	{r7, pc}
 8015126:	bf00      	nop
 8015128:	2000a80c 	.word	0x2000a80c

0801512c <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 801512c:	b590      	push	{r4, r7, lr}
 801512e:	b087      	sub	sp, #28
 8015130:	af00      	add	r7, sp, #0
 8015132:	60b9      	str	r1, [r7, #8]
 8015134:	607a      	str	r2, [r7, #4]
 8015136:	603b      	str	r3, [r7, #0]
 8015138:	4603      	mov	r3, r0
 801513a:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 801513c:	7bfb      	ldrb	r3, [r7, #15]
 801513e:	4a0a      	ldr	r2, [pc, #40]	@ (8015168 <disk_read+0x3c>)
 8015140:	009b      	lsls	r3, r3, #2
 8015142:	4413      	add	r3, r2
 8015144:	685b      	ldr	r3, [r3, #4]
 8015146:	689c      	ldr	r4, [r3, #8]
 8015148:	7bfb      	ldrb	r3, [r7, #15]
 801514a:	4a07      	ldr	r2, [pc, #28]	@ (8015168 <disk_read+0x3c>)
 801514c:	4413      	add	r3, r2
 801514e:	7b18      	ldrb	r0, [r3, #12]
 8015150:	683b      	ldr	r3, [r7, #0]
 8015152:	687a      	ldr	r2, [r7, #4]
 8015154:	68b9      	ldr	r1, [r7, #8]
 8015156:	47a0      	blx	r4
 8015158:	4603      	mov	r3, r0
 801515a:	75fb      	strb	r3, [r7, #23]
  return res;
 801515c:	7dfb      	ldrb	r3, [r7, #23]
}
 801515e:	4618      	mov	r0, r3
 8015160:	371c      	adds	r7, #28
 8015162:	46bd      	mov	sp, r7
 8015164:	bd90      	pop	{r4, r7, pc}
 8015166:	bf00      	nop
 8015168:	2000a80c 	.word	0x2000a80c

0801516c <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 801516c:	b590      	push	{r4, r7, lr}
 801516e:	b087      	sub	sp, #28
 8015170:	af00      	add	r7, sp, #0
 8015172:	60b9      	str	r1, [r7, #8]
 8015174:	607a      	str	r2, [r7, #4]
 8015176:	603b      	str	r3, [r7, #0]
 8015178:	4603      	mov	r3, r0
 801517a:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 801517c:	7bfb      	ldrb	r3, [r7, #15]
 801517e:	4a0a      	ldr	r2, [pc, #40]	@ (80151a8 <disk_write+0x3c>)
 8015180:	009b      	lsls	r3, r3, #2
 8015182:	4413      	add	r3, r2
 8015184:	685b      	ldr	r3, [r3, #4]
 8015186:	68dc      	ldr	r4, [r3, #12]
 8015188:	7bfb      	ldrb	r3, [r7, #15]
 801518a:	4a07      	ldr	r2, [pc, #28]	@ (80151a8 <disk_write+0x3c>)
 801518c:	4413      	add	r3, r2
 801518e:	7b18      	ldrb	r0, [r3, #12]
 8015190:	683b      	ldr	r3, [r7, #0]
 8015192:	687a      	ldr	r2, [r7, #4]
 8015194:	68b9      	ldr	r1, [r7, #8]
 8015196:	47a0      	blx	r4
 8015198:	4603      	mov	r3, r0
 801519a:	75fb      	strb	r3, [r7, #23]
  return res;
 801519c:	7dfb      	ldrb	r3, [r7, #23]
}
 801519e:	4618      	mov	r0, r3
 80151a0:	371c      	adds	r7, #28
 80151a2:	46bd      	mov	sp, r7
 80151a4:	bd90      	pop	{r4, r7, pc}
 80151a6:	bf00      	nop
 80151a8:	2000a80c 	.word	0x2000a80c

080151ac <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
 80151ac:	b580      	push	{r7, lr}
 80151ae:	b084      	sub	sp, #16
 80151b0:	af00      	add	r7, sp, #0
 80151b2:	4603      	mov	r3, r0
 80151b4:	603a      	str	r2, [r7, #0]
 80151b6:	71fb      	strb	r3, [r7, #7]
 80151b8:	460b      	mov	r3, r1
 80151ba:	71bb      	strb	r3, [r7, #6]
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 80151bc:	79fb      	ldrb	r3, [r7, #7]
 80151be:	4a09      	ldr	r2, [pc, #36]	@ (80151e4 <disk_ioctl+0x38>)
 80151c0:	009b      	lsls	r3, r3, #2
 80151c2:	4413      	add	r3, r2
 80151c4:	685b      	ldr	r3, [r3, #4]
 80151c6:	691b      	ldr	r3, [r3, #16]
 80151c8:	79fa      	ldrb	r2, [r7, #7]
 80151ca:	4906      	ldr	r1, [pc, #24]	@ (80151e4 <disk_ioctl+0x38>)
 80151cc:	440a      	add	r2, r1
 80151ce:	7b10      	ldrb	r0, [r2, #12]
 80151d0:	79b9      	ldrb	r1, [r7, #6]
 80151d2:	683a      	ldr	r2, [r7, #0]
 80151d4:	4798      	blx	r3
 80151d6:	4603      	mov	r3, r0
 80151d8:	73fb      	strb	r3, [r7, #15]
  return res;
 80151da:	7bfb      	ldrb	r3, [r7, #15]
}
 80151dc:	4618      	mov	r0, r3
 80151de:	3710      	adds	r7, #16
 80151e0:	46bd      	mov	sp, r7
 80151e2:	bd80      	pop	{r7, pc}
 80151e4:	2000a80c 	.word	0x2000a80c

080151e8 <get_fattime>:
  * @brief  Gets Time from RTC
  * @param  None
  * @retval Time in DWORD
  */
__weak DWORD get_fattime (void)
{
 80151e8:	b480      	push	{r7}
 80151ea:	af00      	add	r7, sp, #0
  return 0;
 80151ec:	2300      	movs	r3, #0
}
 80151ee:	4618      	mov	r0, r3
 80151f0:	46bd      	mov	sp, r7
 80151f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80151f6:	4770      	bx	lr

080151f8 <ld_word>:
/* Load/Store multi-byte word in the FAT structure                       */
/*-----------------------------------------------------------------------*/

static
WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
 80151f8:	b480      	push	{r7}
 80151fa:	b085      	sub	sp, #20
 80151fc:	af00      	add	r7, sp, #0
 80151fe:	6078      	str	r0, [r7, #4]
	WORD rv;

	rv = ptr[1];
 8015200:	687b      	ldr	r3, [r7, #4]
 8015202:	3301      	adds	r3, #1
 8015204:	781b      	ldrb	r3, [r3, #0]
 8015206:	81fb      	strh	r3, [r7, #14]
	rv = rv << 8 | ptr[0];
 8015208:	89fb      	ldrh	r3, [r7, #14]
 801520a:	021b      	lsls	r3, r3, #8
 801520c:	b21a      	sxth	r2, r3
 801520e:	687b      	ldr	r3, [r7, #4]
 8015210:	781b      	ldrb	r3, [r3, #0]
 8015212:	b21b      	sxth	r3, r3
 8015214:	4313      	orrs	r3, r2
 8015216:	b21b      	sxth	r3, r3
 8015218:	81fb      	strh	r3, [r7, #14]
	return rv;
 801521a:	89fb      	ldrh	r3, [r7, #14]
}
 801521c:	4618      	mov	r0, r3
 801521e:	3714      	adds	r7, #20
 8015220:	46bd      	mov	sp, r7
 8015222:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015226:	4770      	bx	lr

08015228 <ld_dword>:

static
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
 8015228:	b480      	push	{r7}
 801522a:	b085      	sub	sp, #20
 801522c:	af00      	add	r7, sp, #0
 801522e:	6078      	str	r0, [r7, #4]
	DWORD rv;

	rv = ptr[3];
 8015230:	687b      	ldr	r3, [r7, #4]
 8015232:	3303      	adds	r3, #3
 8015234:	781b      	ldrb	r3, [r3, #0]
 8015236:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[2];
 8015238:	68fb      	ldr	r3, [r7, #12]
 801523a:	021b      	lsls	r3, r3, #8
 801523c:	687a      	ldr	r2, [r7, #4]
 801523e:	3202      	adds	r2, #2
 8015240:	7812      	ldrb	r2, [r2, #0]
 8015242:	4313      	orrs	r3, r2
 8015244:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[1];
 8015246:	68fb      	ldr	r3, [r7, #12]
 8015248:	021b      	lsls	r3, r3, #8
 801524a:	687a      	ldr	r2, [r7, #4]
 801524c:	3201      	adds	r2, #1
 801524e:	7812      	ldrb	r2, [r2, #0]
 8015250:	4313      	orrs	r3, r2
 8015252:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[0];
 8015254:	68fb      	ldr	r3, [r7, #12]
 8015256:	021b      	lsls	r3, r3, #8
 8015258:	687a      	ldr	r2, [r7, #4]
 801525a:	7812      	ldrb	r2, [r2, #0]
 801525c:	4313      	orrs	r3, r2
 801525e:	60fb      	str	r3, [r7, #12]
	return rv;
 8015260:	68fb      	ldr	r3, [r7, #12]
}
 8015262:	4618      	mov	r0, r3
 8015264:	3714      	adds	r7, #20
 8015266:	46bd      	mov	sp, r7
 8015268:	f85d 7b04 	ldr.w	r7, [sp], #4
 801526c:	4770      	bx	lr

0801526e <st_word>:
#endif

#if !_FS_READONLY
static
void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
 801526e:	b480      	push	{r7}
 8015270:	b083      	sub	sp, #12
 8015272:	af00      	add	r7, sp, #0
 8015274:	6078      	str	r0, [r7, #4]
 8015276:	460b      	mov	r3, r1
 8015278:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val; val >>= 8;
 801527a:	687b      	ldr	r3, [r7, #4]
 801527c:	1c5a      	adds	r2, r3, #1
 801527e:	607a      	str	r2, [r7, #4]
 8015280:	887a      	ldrh	r2, [r7, #2]
 8015282:	b2d2      	uxtb	r2, r2
 8015284:	701a      	strb	r2, [r3, #0]
 8015286:	887b      	ldrh	r3, [r7, #2]
 8015288:	0a1b      	lsrs	r3, r3, #8
 801528a:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val;
 801528c:	687b      	ldr	r3, [r7, #4]
 801528e:	1c5a      	adds	r2, r3, #1
 8015290:	607a      	str	r2, [r7, #4]
 8015292:	887a      	ldrh	r2, [r7, #2]
 8015294:	b2d2      	uxtb	r2, r2
 8015296:	701a      	strb	r2, [r3, #0]
}
 8015298:	bf00      	nop
 801529a:	370c      	adds	r7, #12
 801529c:	46bd      	mov	sp, r7
 801529e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152a2:	4770      	bx	lr

080152a4 <st_dword>:

static
void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
 80152a4:	b480      	push	{r7}
 80152a6:	b083      	sub	sp, #12
 80152a8:	af00      	add	r7, sp, #0
 80152aa:	6078      	str	r0, [r7, #4]
 80152ac:	6039      	str	r1, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 80152ae:	687b      	ldr	r3, [r7, #4]
 80152b0:	1c5a      	adds	r2, r3, #1
 80152b2:	607a      	str	r2, [r7, #4]
 80152b4:	683a      	ldr	r2, [r7, #0]
 80152b6:	b2d2      	uxtb	r2, r2
 80152b8:	701a      	strb	r2, [r3, #0]
 80152ba:	683b      	ldr	r3, [r7, #0]
 80152bc:	0a1b      	lsrs	r3, r3, #8
 80152be:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 80152c0:	687b      	ldr	r3, [r7, #4]
 80152c2:	1c5a      	adds	r2, r3, #1
 80152c4:	607a      	str	r2, [r7, #4]
 80152c6:	683a      	ldr	r2, [r7, #0]
 80152c8:	b2d2      	uxtb	r2, r2
 80152ca:	701a      	strb	r2, [r3, #0]
 80152cc:	683b      	ldr	r3, [r7, #0]
 80152ce:	0a1b      	lsrs	r3, r3, #8
 80152d0:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 80152d2:	687b      	ldr	r3, [r7, #4]
 80152d4:	1c5a      	adds	r2, r3, #1
 80152d6:	607a      	str	r2, [r7, #4]
 80152d8:	683a      	ldr	r2, [r7, #0]
 80152da:	b2d2      	uxtb	r2, r2
 80152dc:	701a      	strb	r2, [r3, #0]
 80152de:	683b      	ldr	r3, [r7, #0]
 80152e0:	0a1b      	lsrs	r3, r3, #8
 80152e2:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val;
 80152e4:	687b      	ldr	r3, [r7, #4]
 80152e6:	1c5a      	adds	r2, r3, #1
 80152e8:	607a      	str	r2, [r7, #4]
 80152ea:	683a      	ldr	r2, [r7, #0]
 80152ec:	b2d2      	uxtb	r2, r2
 80152ee:	701a      	strb	r2, [r3, #0]
}
 80152f0:	bf00      	nop
 80152f2:	370c      	adds	r7, #12
 80152f4:	46bd      	mov	sp, r7
 80152f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80152fa:	4770      	bx	lr

080152fc <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80152fc:	b480      	push	{r7}
 80152fe:	b087      	sub	sp, #28
 8015300:	af00      	add	r7, sp, #0
 8015302:	60f8      	str	r0, [r7, #12]
 8015304:	60b9      	str	r1, [r7, #8]
 8015306:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 8015308:	68fb      	ldr	r3, [r7, #12]
 801530a:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
 801530c:	68bb      	ldr	r3, [r7, #8]
 801530e:	613b      	str	r3, [r7, #16]

	if (cnt) {
 8015310:	687b      	ldr	r3, [r7, #4]
 8015312:	2b00      	cmp	r3, #0
 8015314:	d00d      	beq.n	8015332 <mem_cpy+0x36>
		do {
			*d++ = *s++;
 8015316:	693a      	ldr	r2, [r7, #16]
 8015318:	1c53      	adds	r3, r2, #1
 801531a:	613b      	str	r3, [r7, #16]
 801531c:	697b      	ldr	r3, [r7, #20]
 801531e:	1c59      	adds	r1, r3, #1
 8015320:	6179      	str	r1, [r7, #20]
 8015322:	7812      	ldrb	r2, [r2, #0]
 8015324:	701a      	strb	r2, [r3, #0]
		} while (--cnt);
 8015326:	687b      	ldr	r3, [r7, #4]
 8015328:	3b01      	subs	r3, #1
 801532a:	607b      	str	r3, [r7, #4]
 801532c:	687b      	ldr	r3, [r7, #4]
 801532e:	2b00      	cmp	r3, #0
 8015330:	d1f1      	bne.n	8015316 <mem_cpy+0x1a>
	}
}
 8015332:	bf00      	nop
 8015334:	371c      	adds	r7, #28
 8015336:	46bd      	mov	sp, r7
 8015338:	f85d 7b04 	ldr.w	r7, [sp], #4
 801533c:	4770      	bx	lr

0801533e <mem_set>:

/* Fill memory block */
static
void mem_set (void* dst, int val, UINT cnt) {
 801533e:	b480      	push	{r7}
 8015340:	b087      	sub	sp, #28
 8015342:	af00      	add	r7, sp, #0
 8015344:	60f8      	str	r0, [r7, #12]
 8015346:	60b9      	str	r1, [r7, #8]
 8015348:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
 801534a:	68fb      	ldr	r3, [r7, #12]
 801534c:	617b      	str	r3, [r7, #20]

	do {
		*d++ = (BYTE)val;
 801534e:	697b      	ldr	r3, [r7, #20]
 8015350:	1c5a      	adds	r2, r3, #1
 8015352:	617a      	str	r2, [r7, #20]
 8015354:	68ba      	ldr	r2, [r7, #8]
 8015356:	b2d2      	uxtb	r2, r2
 8015358:	701a      	strb	r2, [r3, #0]
	} while (--cnt);
 801535a:	687b      	ldr	r3, [r7, #4]
 801535c:	3b01      	subs	r3, #1
 801535e:	607b      	str	r3, [r7, #4]
 8015360:	687b      	ldr	r3, [r7, #4]
 8015362:	2b00      	cmp	r3, #0
 8015364:	d1f3      	bne.n	801534e <mem_set+0x10>
}
 8015366:	bf00      	nop
 8015368:	bf00      	nop
 801536a:	371c      	adds	r7, #28
 801536c:	46bd      	mov	sp, r7
 801536e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015372:	4770      	bx	lr

08015374 <mem_cmp>:

/* Compare memory block */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
 8015374:	b480      	push	{r7}
 8015376:	b089      	sub	sp, #36	@ 0x24
 8015378:	af00      	add	r7, sp, #0
 801537a:	60f8      	str	r0, [r7, #12]
 801537c:	60b9      	str	r1, [r7, #8]
 801537e:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 8015380:	68fb      	ldr	r3, [r7, #12]
 8015382:	61fb      	str	r3, [r7, #28]
 8015384:	68bb      	ldr	r3, [r7, #8]
 8015386:	61bb      	str	r3, [r7, #24]
	int r = 0;
 8015388:	2300      	movs	r3, #0
 801538a:	617b      	str	r3, [r7, #20]

	do {
		r = *d++ - *s++;
 801538c:	69fb      	ldr	r3, [r7, #28]
 801538e:	1c5a      	adds	r2, r3, #1
 8015390:	61fa      	str	r2, [r7, #28]
 8015392:	781b      	ldrb	r3, [r3, #0]
 8015394:	4619      	mov	r1, r3
 8015396:	69bb      	ldr	r3, [r7, #24]
 8015398:	1c5a      	adds	r2, r3, #1
 801539a:	61ba      	str	r2, [r7, #24]
 801539c:	781b      	ldrb	r3, [r3, #0]
 801539e:	1acb      	subs	r3, r1, r3
 80153a0:	617b      	str	r3, [r7, #20]
	} while (--cnt && r == 0);
 80153a2:	687b      	ldr	r3, [r7, #4]
 80153a4:	3b01      	subs	r3, #1
 80153a6:	607b      	str	r3, [r7, #4]
 80153a8:	687b      	ldr	r3, [r7, #4]
 80153aa:	2b00      	cmp	r3, #0
 80153ac:	d002      	beq.n	80153b4 <mem_cmp+0x40>
 80153ae:	697b      	ldr	r3, [r7, #20]
 80153b0:	2b00      	cmp	r3, #0
 80153b2:	d0eb      	beq.n	801538c <mem_cmp+0x18>

	return r;
 80153b4:	697b      	ldr	r3, [r7, #20]
}
 80153b6:	4618      	mov	r0, r3
 80153b8:	3724      	adds	r7, #36	@ 0x24
 80153ba:	46bd      	mov	sp, r7
 80153bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80153c0:	4770      	bx	lr

080153c2 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
 80153c2:	b480      	push	{r7}
 80153c4:	b083      	sub	sp, #12
 80153c6:	af00      	add	r7, sp, #0
 80153c8:	6078      	str	r0, [r7, #4]
 80153ca:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
 80153cc:	e002      	b.n	80153d4 <chk_chr+0x12>
 80153ce:	687b      	ldr	r3, [r7, #4]
 80153d0:	3301      	adds	r3, #1
 80153d2:	607b      	str	r3, [r7, #4]
 80153d4:	687b      	ldr	r3, [r7, #4]
 80153d6:	781b      	ldrb	r3, [r3, #0]
 80153d8:	2b00      	cmp	r3, #0
 80153da:	d005      	beq.n	80153e8 <chk_chr+0x26>
 80153dc:	687b      	ldr	r3, [r7, #4]
 80153de:	781b      	ldrb	r3, [r3, #0]
 80153e0:	461a      	mov	r2, r3
 80153e2:	683b      	ldr	r3, [r7, #0]
 80153e4:	4293      	cmp	r3, r2
 80153e6:	d1f2      	bne.n	80153ce <chk_chr+0xc>
	return *str;
 80153e8:	687b      	ldr	r3, [r7, #4]
 80153ea:	781b      	ldrb	r3, [r3, #0]
}
 80153ec:	4618      	mov	r0, r3
 80153ee:	370c      	adds	r7, #12
 80153f0:	46bd      	mov	sp, r7
 80153f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80153f6:	4770      	bx	lr

080153f8 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 80153f8:	b480      	push	{r7}
 80153fa:	b085      	sub	sp, #20
 80153fc:	af00      	add	r7, sp, #0
 80153fe:	6078      	str	r0, [r7, #4]
 8015400:	6039      	str	r1, [r7, #0]
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 8015402:	2300      	movs	r3, #0
 8015404:	60bb      	str	r3, [r7, #8]
 8015406:	68bb      	ldr	r3, [r7, #8]
 8015408:	60fb      	str	r3, [r7, #12]
 801540a:	e029      	b.n	8015460 <chk_lock+0x68>
		if (Files[i].fs) {	/* Existing entry */
 801540c:	4a27      	ldr	r2, [pc, #156]	@ (80154ac <chk_lock+0xb4>)
 801540e:	68fb      	ldr	r3, [r7, #12]
 8015410:	011b      	lsls	r3, r3, #4
 8015412:	4413      	add	r3, r2
 8015414:	681b      	ldr	r3, [r3, #0]
 8015416:	2b00      	cmp	r3, #0
 8015418:	d01d      	beq.n	8015456 <chk_lock+0x5e>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 801541a:	4a24      	ldr	r2, [pc, #144]	@ (80154ac <chk_lock+0xb4>)
 801541c:	68fb      	ldr	r3, [r7, #12]
 801541e:	011b      	lsls	r3, r3, #4
 8015420:	4413      	add	r3, r2
 8015422:	681a      	ldr	r2, [r3, #0]
 8015424:	687b      	ldr	r3, [r7, #4]
 8015426:	681b      	ldr	r3, [r3, #0]
 8015428:	429a      	cmp	r2, r3
 801542a:	d116      	bne.n	801545a <chk_lock+0x62>
				Files[i].clu == dp->obj.sclust &&
 801542c:	4a1f      	ldr	r2, [pc, #124]	@ (80154ac <chk_lock+0xb4>)
 801542e:	68fb      	ldr	r3, [r7, #12]
 8015430:	011b      	lsls	r3, r3, #4
 8015432:	4413      	add	r3, r2
 8015434:	3304      	adds	r3, #4
 8015436:	681a      	ldr	r2, [r3, #0]
 8015438:	687b      	ldr	r3, [r7, #4]
 801543a:	689b      	ldr	r3, [r3, #8]
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 801543c:	429a      	cmp	r2, r3
 801543e:	d10c      	bne.n	801545a <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 8015440:	4a1a      	ldr	r2, [pc, #104]	@ (80154ac <chk_lock+0xb4>)
 8015442:	68fb      	ldr	r3, [r7, #12]
 8015444:	011b      	lsls	r3, r3, #4
 8015446:	4413      	add	r3, r2
 8015448:	3308      	adds	r3, #8
 801544a:	681a      	ldr	r2, [r3, #0]
 801544c:	687b      	ldr	r3, [r7, #4]
 801544e:	695b      	ldr	r3, [r3, #20]
				Files[i].clu == dp->obj.sclust &&
 8015450:	429a      	cmp	r2, r3
 8015452:	d102      	bne.n	801545a <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
 8015454:	e007      	b.n	8015466 <chk_lock+0x6e>
		} else {			/* Blank entry */
			be = 1;
 8015456:	2301      	movs	r3, #1
 8015458:	60bb      	str	r3, [r7, #8]
	for (i = be = 0; i < _FS_LOCK; i++) {
 801545a:	68fb      	ldr	r3, [r7, #12]
 801545c:	3301      	adds	r3, #1
 801545e:	60fb      	str	r3, [r7, #12]
 8015460:	68fb      	ldr	r3, [r7, #12]
 8015462:	2b01      	cmp	r3, #1
 8015464:	d9d2      	bls.n	801540c <chk_lock+0x14>
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
 8015466:	68fb      	ldr	r3, [r7, #12]
 8015468:	2b02      	cmp	r3, #2
 801546a:	d109      	bne.n	8015480 <chk_lock+0x88>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 801546c:	68bb      	ldr	r3, [r7, #8]
 801546e:	2b00      	cmp	r3, #0
 8015470:	d102      	bne.n	8015478 <chk_lock+0x80>
 8015472:	683b      	ldr	r3, [r7, #0]
 8015474:	2b02      	cmp	r3, #2
 8015476:	d101      	bne.n	801547c <chk_lock+0x84>
 8015478:	2300      	movs	r3, #0
 801547a:	e010      	b.n	801549e <chk_lock+0xa6>
 801547c:	2312      	movs	r3, #18
 801547e:	e00e      	b.n	801549e <chk_lock+0xa6>
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 8015480:	683b      	ldr	r3, [r7, #0]
 8015482:	2b00      	cmp	r3, #0
 8015484:	d108      	bne.n	8015498 <chk_lock+0xa0>
 8015486:	4a09      	ldr	r2, [pc, #36]	@ (80154ac <chk_lock+0xb4>)
 8015488:	68fb      	ldr	r3, [r7, #12]
 801548a:	011b      	lsls	r3, r3, #4
 801548c:	4413      	add	r3, r2
 801548e:	330c      	adds	r3, #12
 8015490:	881b      	ldrh	r3, [r3, #0]
 8015492:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8015496:	d101      	bne.n	801549c <chk_lock+0xa4>
 8015498:	2310      	movs	r3, #16
 801549a:	e000      	b.n	801549e <chk_lock+0xa6>
 801549c:	2300      	movs	r3, #0
}
 801549e:	4618      	mov	r0, r3
 80154a0:	3714      	adds	r7, #20
 80154a2:	46bd      	mov	sp, r7
 80154a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80154a8:	4770      	bx	lr
 80154aa:	bf00      	nop
 80154ac:	2000a7ec 	.word	0x2000a7ec

080154b0 <enq_lock>:


static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
 80154b0:	b480      	push	{r7}
 80154b2:	b083      	sub	sp, #12
 80154b4:	af00      	add	r7, sp, #0
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80154b6:	2300      	movs	r3, #0
 80154b8:	607b      	str	r3, [r7, #4]
 80154ba:	e002      	b.n	80154c2 <enq_lock+0x12>
 80154bc:	687b      	ldr	r3, [r7, #4]
 80154be:	3301      	adds	r3, #1
 80154c0:	607b      	str	r3, [r7, #4]
 80154c2:	687b      	ldr	r3, [r7, #4]
 80154c4:	2b01      	cmp	r3, #1
 80154c6:	d806      	bhi.n	80154d6 <enq_lock+0x26>
 80154c8:	4a09      	ldr	r2, [pc, #36]	@ (80154f0 <enq_lock+0x40>)
 80154ca:	687b      	ldr	r3, [r7, #4]
 80154cc:	011b      	lsls	r3, r3, #4
 80154ce:	4413      	add	r3, r2
 80154d0:	681b      	ldr	r3, [r3, #0]
 80154d2:	2b00      	cmp	r3, #0
 80154d4:	d1f2      	bne.n	80154bc <enq_lock+0xc>
	return (i == _FS_LOCK) ? 0 : 1;
 80154d6:	687b      	ldr	r3, [r7, #4]
 80154d8:	2b02      	cmp	r3, #2
 80154da:	bf14      	ite	ne
 80154dc:	2301      	movne	r3, #1
 80154de:	2300      	moveq	r3, #0
 80154e0:	b2db      	uxtb	r3, r3
}
 80154e2:	4618      	mov	r0, r3
 80154e4:	370c      	adds	r7, #12
 80154e6:	46bd      	mov	sp, r7
 80154e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80154ec:	4770      	bx	lr
 80154ee:	bf00      	nop
 80154f0:	2000a7ec 	.word	0x2000a7ec

080154f4 <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 80154f4:	b480      	push	{r7}
 80154f6:	b085      	sub	sp, #20
 80154f8:	af00      	add	r7, sp, #0
 80154fa:	6078      	str	r0, [r7, #4]
 80154fc:	6039      	str	r1, [r7, #0]
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 80154fe:	2300      	movs	r3, #0
 8015500:	60fb      	str	r3, [r7, #12]
 8015502:	e01f      	b.n	8015544 <inc_lock+0x50>
		if (Files[i].fs == dp->obj.fs &&
 8015504:	4a41      	ldr	r2, [pc, #260]	@ (801560c <inc_lock+0x118>)
 8015506:	68fb      	ldr	r3, [r7, #12]
 8015508:	011b      	lsls	r3, r3, #4
 801550a:	4413      	add	r3, r2
 801550c:	681a      	ldr	r2, [r3, #0]
 801550e:	687b      	ldr	r3, [r7, #4]
 8015510:	681b      	ldr	r3, [r3, #0]
 8015512:	429a      	cmp	r2, r3
 8015514:	d113      	bne.n	801553e <inc_lock+0x4a>
			Files[i].clu == dp->obj.sclust &&
 8015516:	4a3d      	ldr	r2, [pc, #244]	@ (801560c <inc_lock+0x118>)
 8015518:	68fb      	ldr	r3, [r7, #12]
 801551a:	011b      	lsls	r3, r3, #4
 801551c:	4413      	add	r3, r2
 801551e:	3304      	adds	r3, #4
 8015520:	681a      	ldr	r2, [r3, #0]
 8015522:	687b      	ldr	r3, [r7, #4]
 8015524:	689b      	ldr	r3, [r3, #8]
		if (Files[i].fs == dp->obj.fs &&
 8015526:	429a      	cmp	r2, r3
 8015528:	d109      	bne.n	801553e <inc_lock+0x4a>
			Files[i].ofs == dp->dptr) break;
 801552a:	4a38      	ldr	r2, [pc, #224]	@ (801560c <inc_lock+0x118>)
 801552c:	68fb      	ldr	r3, [r7, #12]
 801552e:	011b      	lsls	r3, r3, #4
 8015530:	4413      	add	r3, r2
 8015532:	3308      	adds	r3, #8
 8015534:	681a      	ldr	r2, [r3, #0]
 8015536:	687b      	ldr	r3, [r7, #4]
 8015538:	695b      	ldr	r3, [r3, #20]
			Files[i].clu == dp->obj.sclust &&
 801553a:	429a      	cmp	r2, r3
 801553c:	d006      	beq.n	801554c <inc_lock+0x58>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 801553e:	68fb      	ldr	r3, [r7, #12]
 8015540:	3301      	adds	r3, #1
 8015542:	60fb      	str	r3, [r7, #12]
 8015544:	68fb      	ldr	r3, [r7, #12]
 8015546:	2b01      	cmp	r3, #1
 8015548:	d9dc      	bls.n	8015504 <inc_lock+0x10>
 801554a:	e000      	b.n	801554e <inc_lock+0x5a>
			Files[i].ofs == dp->dptr) break;
 801554c:	bf00      	nop
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
 801554e:	68fb      	ldr	r3, [r7, #12]
 8015550:	2b02      	cmp	r3, #2
 8015552:	d132      	bne.n	80155ba <inc_lock+0xc6>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 8015554:	2300      	movs	r3, #0
 8015556:	60fb      	str	r3, [r7, #12]
 8015558:	e002      	b.n	8015560 <inc_lock+0x6c>
 801555a:	68fb      	ldr	r3, [r7, #12]
 801555c:	3301      	adds	r3, #1
 801555e:	60fb      	str	r3, [r7, #12]
 8015560:	68fb      	ldr	r3, [r7, #12]
 8015562:	2b01      	cmp	r3, #1
 8015564:	d806      	bhi.n	8015574 <inc_lock+0x80>
 8015566:	4a29      	ldr	r2, [pc, #164]	@ (801560c <inc_lock+0x118>)
 8015568:	68fb      	ldr	r3, [r7, #12]
 801556a:	011b      	lsls	r3, r3, #4
 801556c:	4413      	add	r3, r2
 801556e:	681b      	ldr	r3, [r3, #0]
 8015570:	2b00      	cmp	r3, #0
 8015572:	d1f2      	bne.n	801555a <inc_lock+0x66>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8015574:	68fb      	ldr	r3, [r7, #12]
 8015576:	2b02      	cmp	r3, #2
 8015578:	d101      	bne.n	801557e <inc_lock+0x8a>
 801557a:	2300      	movs	r3, #0
 801557c:	e040      	b.n	8015600 <inc_lock+0x10c>
		Files[i].fs = dp->obj.fs;
 801557e:	687b      	ldr	r3, [r7, #4]
 8015580:	681a      	ldr	r2, [r3, #0]
 8015582:	4922      	ldr	r1, [pc, #136]	@ (801560c <inc_lock+0x118>)
 8015584:	68fb      	ldr	r3, [r7, #12]
 8015586:	011b      	lsls	r3, r3, #4
 8015588:	440b      	add	r3, r1
 801558a:	601a      	str	r2, [r3, #0]
		Files[i].clu = dp->obj.sclust;
 801558c:	687b      	ldr	r3, [r7, #4]
 801558e:	689a      	ldr	r2, [r3, #8]
 8015590:	491e      	ldr	r1, [pc, #120]	@ (801560c <inc_lock+0x118>)
 8015592:	68fb      	ldr	r3, [r7, #12]
 8015594:	011b      	lsls	r3, r3, #4
 8015596:	440b      	add	r3, r1
 8015598:	3304      	adds	r3, #4
 801559a:	601a      	str	r2, [r3, #0]
		Files[i].ofs = dp->dptr;
 801559c:	687b      	ldr	r3, [r7, #4]
 801559e:	695a      	ldr	r2, [r3, #20]
 80155a0:	491a      	ldr	r1, [pc, #104]	@ (801560c <inc_lock+0x118>)
 80155a2:	68fb      	ldr	r3, [r7, #12]
 80155a4:	011b      	lsls	r3, r3, #4
 80155a6:	440b      	add	r3, r1
 80155a8:	3308      	adds	r3, #8
 80155aa:	601a      	str	r2, [r3, #0]
		Files[i].ctr = 0;
 80155ac:	4a17      	ldr	r2, [pc, #92]	@ (801560c <inc_lock+0x118>)
 80155ae:	68fb      	ldr	r3, [r7, #12]
 80155b0:	011b      	lsls	r3, r3, #4
 80155b2:	4413      	add	r3, r2
 80155b4:	330c      	adds	r3, #12
 80155b6:	2200      	movs	r2, #0
 80155b8:	801a      	strh	r2, [r3, #0]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 80155ba:	683b      	ldr	r3, [r7, #0]
 80155bc:	2b00      	cmp	r3, #0
 80155be:	d009      	beq.n	80155d4 <inc_lock+0xe0>
 80155c0:	4a12      	ldr	r2, [pc, #72]	@ (801560c <inc_lock+0x118>)
 80155c2:	68fb      	ldr	r3, [r7, #12]
 80155c4:	011b      	lsls	r3, r3, #4
 80155c6:	4413      	add	r3, r2
 80155c8:	330c      	adds	r3, #12
 80155ca:	881b      	ldrh	r3, [r3, #0]
 80155cc:	2b00      	cmp	r3, #0
 80155ce:	d001      	beq.n	80155d4 <inc_lock+0xe0>
 80155d0:	2300      	movs	r3, #0
 80155d2:	e015      	b.n	8015600 <inc_lock+0x10c>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80155d4:	683b      	ldr	r3, [r7, #0]
 80155d6:	2b00      	cmp	r3, #0
 80155d8:	d108      	bne.n	80155ec <inc_lock+0xf8>
 80155da:	4a0c      	ldr	r2, [pc, #48]	@ (801560c <inc_lock+0x118>)
 80155dc:	68fb      	ldr	r3, [r7, #12]
 80155de:	011b      	lsls	r3, r3, #4
 80155e0:	4413      	add	r3, r2
 80155e2:	330c      	adds	r3, #12
 80155e4:	881b      	ldrh	r3, [r3, #0]
 80155e6:	3301      	adds	r3, #1
 80155e8:	b29a      	uxth	r2, r3
 80155ea:	e001      	b.n	80155f0 <inc_lock+0xfc>
 80155ec:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80155f0:	4906      	ldr	r1, [pc, #24]	@ (801560c <inc_lock+0x118>)
 80155f2:	68fb      	ldr	r3, [r7, #12]
 80155f4:	011b      	lsls	r3, r3, #4
 80155f6:	440b      	add	r3, r1
 80155f8:	330c      	adds	r3, #12
 80155fa:	801a      	strh	r2, [r3, #0]

	return i + 1;
 80155fc:	68fb      	ldr	r3, [r7, #12]
 80155fe:	3301      	adds	r3, #1
}
 8015600:	4618      	mov	r0, r3
 8015602:	3714      	adds	r7, #20
 8015604:	46bd      	mov	sp, r7
 8015606:	f85d 7b04 	ldr.w	r7, [sp], #4
 801560a:	4770      	bx	lr
 801560c:	2000a7ec 	.word	0x2000a7ec

08015610 <dec_lock>:

static
FRESULT dec_lock (	/* Decrement object open counter */
	UINT i			/* Semaphore index (1..) */
)
{
 8015610:	b480      	push	{r7}
 8015612:	b085      	sub	sp, #20
 8015614:	af00      	add	r7, sp, #0
 8015616:	6078      	str	r0, [r7, #4]
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 8015618:	687b      	ldr	r3, [r7, #4]
 801561a:	3b01      	subs	r3, #1
 801561c:	607b      	str	r3, [r7, #4]
 801561e:	687b      	ldr	r3, [r7, #4]
 8015620:	2b01      	cmp	r3, #1
 8015622:	d825      	bhi.n	8015670 <dec_lock+0x60>
		n = Files[i].ctr;
 8015624:	4a17      	ldr	r2, [pc, #92]	@ (8015684 <dec_lock+0x74>)
 8015626:	687b      	ldr	r3, [r7, #4]
 8015628:	011b      	lsls	r3, r3, #4
 801562a:	4413      	add	r3, r2
 801562c:	330c      	adds	r3, #12
 801562e:	881b      	ldrh	r3, [r3, #0]
 8015630:	81fb      	strh	r3, [r7, #14]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
 8015632:	89fb      	ldrh	r3, [r7, #14]
 8015634:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8015638:	d101      	bne.n	801563e <dec_lock+0x2e>
 801563a:	2300      	movs	r3, #0
 801563c:	81fb      	strh	r3, [r7, #14]
		if (n > 0) n--;				/* Decrement read mode open count */
 801563e:	89fb      	ldrh	r3, [r7, #14]
 8015640:	2b00      	cmp	r3, #0
 8015642:	d002      	beq.n	801564a <dec_lock+0x3a>
 8015644:	89fb      	ldrh	r3, [r7, #14]
 8015646:	3b01      	subs	r3, #1
 8015648:	81fb      	strh	r3, [r7, #14]
		Files[i].ctr = n;
 801564a:	4a0e      	ldr	r2, [pc, #56]	@ (8015684 <dec_lock+0x74>)
 801564c:	687b      	ldr	r3, [r7, #4]
 801564e:	011b      	lsls	r3, r3, #4
 8015650:	4413      	add	r3, r2
 8015652:	330c      	adds	r3, #12
 8015654:	89fa      	ldrh	r2, [r7, #14]
 8015656:	801a      	strh	r2, [r3, #0]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 8015658:	89fb      	ldrh	r3, [r7, #14]
 801565a:	2b00      	cmp	r3, #0
 801565c:	d105      	bne.n	801566a <dec_lock+0x5a>
 801565e:	4a09      	ldr	r2, [pc, #36]	@ (8015684 <dec_lock+0x74>)
 8015660:	687b      	ldr	r3, [r7, #4]
 8015662:	011b      	lsls	r3, r3, #4
 8015664:	4413      	add	r3, r2
 8015666:	2200      	movs	r2, #0
 8015668:	601a      	str	r2, [r3, #0]
		res = FR_OK;
 801566a:	2300      	movs	r3, #0
 801566c:	737b      	strb	r3, [r7, #13]
 801566e:	e001      	b.n	8015674 <dec_lock+0x64>
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 8015670:	2302      	movs	r3, #2
 8015672:	737b      	strb	r3, [r7, #13]
	}
	return res;
 8015674:	7b7b      	ldrb	r3, [r7, #13]
}
 8015676:	4618      	mov	r0, r3
 8015678:	3714      	adds	r7, #20
 801567a:	46bd      	mov	sp, r7
 801567c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015680:	4770      	bx	lr
 8015682:	bf00      	nop
 8015684:	2000a7ec 	.word	0x2000a7ec

08015688 <clear_lock>:

static
void clear_lock (	/* Clear lock entries of the volume */
	FATFS *fs
)
{
 8015688:	b480      	push	{r7}
 801568a:	b085      	sub	sp, #20
 801568c:	af00      	add	r7, sp, #0
 801568e:	6078      	str	r0, [r7, #4]
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
 8015690:	2300      	movs	r3, #0
 8015692:	60fb      	str	r3, [r7, #12]
 8015694:	e010      	b.n	80156b8 <clear_lock+0x30>
		if (Files[i].fs == fs) Files[i].fs = 0;
 8015696:	4a0d      	ldr	r2, [pc, #52]	@ (80156cc <clear_lock+0x44>)
 8015698:	68fb      	ldr	r3, [r7, #12]
 801569a:	011b      	lsls	r3, r3, #4
 801569c:	4413      	add	r3, r2
 801569e:	681b      	ldr	r3, [r3, #0]
 80156a0:	687a      	ldr	r2, [r7, #4]
 80156a2:	429a      	cmp	r2, r3
 80156a4:	d105      	bne.n	80156b2 <clear_lock+0x2a>
 80156a6:	4a09      	ldr	r2, [pc, #36]	@ (80156cc <clear_lock+0x44>)
 80156a8:	68fb      	ldr	r3, [r7, #12]
 80156aa:	011b      	lsls	r3, r3, #4
 80156ac:	4413      	add	r3, r2
 80156ae:	2200      	movs	r2, #0
 80156b0:	601a      	str	r2, [r3, #0]
	for (i = 0; i < _FS_LOCK; i++) {
 80156b2:	68fb      	ldr	r3, [r7, #12]
 80156b4:	3301      	adds	r3, #1
 80156b6:	60fb      	str	r3, [r7, #12]
 80156b8:	68fb      	ldr	r3, [r7, #12]
 80156ba:	2b01      	cmp	r3, #1
 80156bc:	d9eb      	bls.n	8015696 <clear_lock+0xe>
	}
}
 80156be:	bf00      	nop
 80156c0:	bf00      	nop
 80156c2:	3714      	adds	r7, #20
 80156c4:	46bd      	mov	sp, r7
 80156c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80156ca:	4770      	bx	lr
 80156cc:	2000a7ec 	.word	0x2000a7ec

080156d0 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs			/* File system object */
)
{
 80156d0:	b580      	push	{r7, lr}
 80156d2:	b086      	sub	sp, #24
 80156d4:	af00      	add	r7, sp, #0
 80156d6:	6078      	str	r0, [r7, #4]
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
 80156d8:	2300      	movs	r3, #0
 80156da:	73fb      	strb	r3, [r7, #15]


	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80156dc:	687b      	ldr	r3, [r7, #4]
 80156de:	78db      	ldrb	r3, [r3, #3]
 80156e0:	2b00      	cmp	r3, #0
 80156e2:	d034      	beq.n	801574e <sync_window+0x7e>
		wsect = fs->winsect;	/* Current sector number */
 80156e4:	687b      	ldr	r3, [r7, #4]
 80156e6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80156e8:	617b      	str	r3, [r7, #20]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 80156ea:	687b      	ldr	r3, [r7, #4]
 80156ec:	7858      	ldrb	r0, [r3, #1]
 80156ee:	687b      	ldr	r3, [r7, #4]
 80156f0:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 80156f4:	2301      	movs	r3, #1
 80156f6:	697a      	ldr	r2, [r7, #20]
 80156f8:	f7ff fd38 	bl	801516c <disk_write>
 80156fc:	4603      	mov	r3, r0
 80156fe:	2b00      	cmp	r3, #0
 8015700:	d002      	beq.n	8015708 <sync_window+0x38>
			res = FR_DISK_ERR;
 8015702:	2301      	movs	r3, #1
 8015704:	73fb      	strb	r3, [r7, #15]
 8015706:	e022      	b.n	801574e <sync_window+0x7e>
		} else {
			fs->wflag = 0;
 8015708:	687b      	ldr	r3, [r7, #4]
 801570a:	2200      	movs	r2, #0
 801570c:	70da      	strb	r2, [r3, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 801570e:	687b      	ldr	r3, [r7, #4]
 8015710:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8015712:	697a      	ldr	r2, [r7, #20]
 8015714:	1ad2      	subs	r2, r2, r3
 8015716:	687b      	ldr	r3, [r7, #4]
 8015718:	69db      	ldr	r3, [r3, #28]
 801571a:	429a      	cmp	r2, r3
 801571c:	d217      	bcs.n	801574e <sync_window+0x7e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 801571e:	687b      	ldr	r3, [r7, #4]
 8015720:	789b      	ldrb	r3, [r3, #2]
 8015722:	613b      	str	r3, [r7, #16]
 8015724:	e010      	b.n	8015748 <sync_window+0x78>
					wsect += fs->fsize;
 8015726:	687b      	ldr	r3, [r7, #4]
 8015728:	69db      	ldr	r3, [r3, #28]
 801572a:	697a      	ldr	r2, [r7, #20]
 801572c:	4413      	add	r3, r2
 801572e:	617b      	str	r3, [r7, #20]
					disk_write(fs->drv, fs->win, wsect, 1);
 8015730:	687b      	ldr	r3, [r7, #4]
 8015732:	7858      	ldrb	r0, [r3, #1]
 8015734:	687b      	ldr	r3, [r7, #4]
 8015736:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 801573a:	2301      	movs	r3, #1
 801573c:	697a      	ldr	r2, [r7, #20]
 801573e:	f7ff fd15 	bl	801516c <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8015742:	693b      	ldr	r3, [r7, #16]
 8015744:	3b01      	subs	r3, #1
 8015746:	613b      	str	r3, [r7, #16]
 8015748:	693b      	ldr	r3, [r7, #16]
 801574a:	2b01      	cmp	r3, #1
 801574c:	d8eb      	bhi.n	8015726 <sync_window+0x56>
				}
			}
		}
	}
	return res;
 801574e:	7bfb      	ldrb	r3, [r7, #15]
}
 8015750:	4618      	mov	r0, r3
 8015752:	3718      	adds	r7, #24
 8015754:	46bd      	mov	sp, r7
 8015756:	bd80      	pop	{r7, pc}

08015758 <move_window>:
static
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs,			/* File system object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
 8015758:	b580      	push	{r7, lr}
 801575a:	b084      	sub	sp, #16
 801575c:	af00      	add	r7, sp, #0
 801575e:	6078      	str	r0, [r7, #4]
 8015760:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_OK;
 8015762:	2300      	movs	r3, #0
 8015764:	73fb      	strb	r3, [r7, #15]


	if (sector != fs->winsect) {	/* Window offset changed? */
 8015766:	687b      	ldr	r3, [r7, #4]
 8015768:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801576a:	683a      	ldr	r2, [r7, #0]
 801576c:	429a      	cmp	r2, r3
 801576e:	d01b      	beq.n	80157a8 <move_window+0x50>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
 8015770:	6878      	ldr	r0, [r7, #4]
 8015772:	f7ff ffad 	bl	80156d0 <sync_window>
 8015776:	4603      	mov	r3, r0
 8015778:	73fb      	strb	r3, [r7, #15]
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
 801577a:	7bfb      	ldrb	r3, [r7, #15]
 801577c:	2b00      	cmp	r3, #0
 801577e:	d113      	bne.n	80157a8 <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8015780:	687b      	ldr	r3, [r7, #4]
 8015782:	7858      	ldrb	r0, [r3, #1]
 8015784:	687b      	ldr	r3, [r7, #4]
 8015786:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 801578a:	2301      	movs	r3, #1
 801578c:	683a      	ldr	r2, [r7, #0]
 801578e:	f7ff fccd 	bl	801512c <disk_read>
 8015792:	4603      	mov	r3, r0
 8015794:	2b00      	cmp	r3, #0
 8015796:	d004      	beq.n	80157a2 <move_window+0x4a>
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
 8015798:	f04f 33ff 	mov.w	r3, #4294967295
 801579c:	603b      	str	r3, [r7, #0]
				res = FR_DISK_ERR;
 801579e:	2301      	movs	r3, #1
 80157a0:	73fb      	strb	r3, [r7, #15]
			}
			fs->winsect = sector;
 80157a2:	687b      	ldr	r3, [r7, #4]
 80157a4:	683a      	ldr	r2, [r7, #0]
 80157a6:	631a      	str	r2, [r3, #48]	@ 0x30
		}
	}
	return res;
 80157a8:	7bfb      	ldrb	r3, [r7, #15]
}
 80157aa:	4618      	mov	r0, r3
 80157ac:	3710      	adds	r7, #16
 80157ae:	46bd      	mov	sp, r7
 80157b0:	bd80      	pop	{r7, pc}
	...

080157b4 <sync_fs>:

static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
 80157b4:	b580      	push	{r7, lr}
 80157b6:	b084      	sub	sp, #16
 80157b8:	af00      	add	r7, sp, #0
 80157ba:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = sync_window(fs);
 80157bc:	6878      	ldr	r0, [r7, #4]
 80157be:	f7ff ff87 	bl	80156d0 <sync_window>
 80157c2:	4603      	mov	r3, r0
 80157c4:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 80157c6:	7bfb      	ldrb	r3, [r7, #15]
 80157c8:	2b00      	cmp	r3, #0
 80157ca:	d158      	bne.n	801587e <sync_fs+0xca>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 80157cc:	687b      	ldr	r3, [r7, #4]
 80157ce:	781b      	ldrb	r3, [r3, #0]
 80157d0:	2b03      	cmp	r3, #3
 80157d2:	d148      	bne.n	8015866 <sync_fs+0xb2>
 80157d4:	687b      	ldr	r3, [r7, #4]
 80157d6:	791b      	ldrb	r3, [r3, #4]
 80157d8:	2b01      	cmp	r3, #1
 80157da:	d144      	bne.n	8015866 <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
 80157dc:	687b      	ldr	r3, [r7, #4]
 80157de:	3334      	adds	r3, #52	@ 0x34
 80157e0:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80157e4:	2100      	movs	r1, #0
 80157e6:	4618      	mov	r0, r3
 80157e8:	f7ff fda9 	bl	801533e <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);
 80157ec:	687b      	ldr	r3, [r7, #4]
 80157ee:	3334      	adds	r3, #52	@ 0x34
 80157f0:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 80157f4:	f64a 2155 	movw	r1, #43605	@ 0xaa55
 80157f8:	4618      	mov	r0, r3
 80157fa:	f7ff fd38 	bl	801526e <st_word>
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
 80157fe:	687b      	ldr	r3, [r7, #4]
 8015800:	3334      	adds	r3, #52	@ 0x34
 8015802:	4921      	ldr	r1, [pc, #132]	@ (8015888 <sync_fs+0xd4>)
 8015804:	4618      	mov	r0, r3
 8015806:	f7ff fd4d 	bl	80152a4 <st_dword>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
 801580a:	687b      	ldr	r3, [r7, #4]
 801580c:	3334      	adds	r3, #52	@ 0x34
 801580e:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 8015812:	491e      	ldr	r1, [pc, #120]	@ (801588c <sync_fs+0xd8>)
 8015814:	4618      	mov	r0, r3
 8015816:	f7ff fd45 	bl	80152a4 <st_dword>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 801581a:	687b      	ldr	r3, [r7, #4]
 801581c:	3334      	adds	r3, #52	@ 0x34
 801581e:	f503 72f4 	add.w	r2, r3, #488	@ 0x1e8
 8015822:	687b      	ldr	r3, [r7, #4]
 8015824:	695b      	ldr	r3, [r3, #20]
 8015826:	4619      	mov	r1, r3
 8015828:	4610      	mov	r0, r2
 801582a:	f7ff fd3b 	bl	80152a4 <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 801582e:	687b      	ldr	r3, [r7, #4]
 8015830:	3334      	adds	r3, #52	@ 0x34
 8015832:	f503 72f6 	add.w	r2, r3, #492	@ 0x1ec
 8015836:	687b      	ldr	r3, [r7, #4]
 8015838:	691b      	ldr	r3, [r3, #16]
 801583a:	4619      	mov	r1, r3
 801583c:	4610      	mov	r0, r2
 801583e:	f7ff fd31 	bl	80152a4 <st_dword>
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
 8015842:	687b      	ldr	r3, [r7, #4]
 8015844:	6a1b      	ldr	r3, [r3, #32]
 8015846:	1c5a      	adds	r2, r3, #1
 8015848:	687b      	ldr	r3, [r7, #4]
 801584a:	631a      	str	r2, [r3, #48]	@ 0x30
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 801584c:	687b      	ldr	r3, [r7, #4]
 801584e:	7858      	ldrb	r0, [r3, #1]
 8015850:	687b      	ldr	r3, [r7, #4]
 8015852:	f103 0134 	add.w	r1, r3, #52	@ 0x34
 8015856:	687b      	ldr	r3, [r7, #4]
 8015858:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 801585a:	2301      	movs	r3, #1
 801585c:	f7ff fc86 	bl	801516c <disk_write>
			fs->fsi_flag = 0;
 8015860:	687b      	ldr	r3, [r7, #4]
 8015862:	2200      	movs	r2, #0
 8015864:	711a      	strb	r2, [r3, #4]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 8015866:	687b      	ldr	r3, [r7, #4]
 8015868:	785b      	ldrb	r3, [r3, #1]
 801586a:	2200      	movs	r2, #0
 801586c:	2100      	movs	r1, #0
 801586e:	4618      	mov	r0, r3
 8015870:	f7ff fc9c 	bl	80151ac <disk_ioctl>
 8015874:	4603      	mov	r3, r0
 8015876:	2b00      	cmp	r3, #0
 8015878:	d001      	beq.n	801587e <sync_fs+0xca>
 801587a:	2301      	movs	r3, #1
 801587c:	73fb      	strb	r3, [r7, #15]
	}

	return res;
 801587e:	7bfb      	ldrb	r3, [r7, #15]
}
 8015880:	4618      	mov	r0, r3
 8015882:	3710      	adds	r7, #16
 8015884:	46bd      	mov	sp, r7
 8015886:	bd80      	pop	{r7, pc}
 8015888:	41615252 	.word	0x41615252
 801588c:	61417272 	.word	0x61417272

08015890 <clust2sect>:
static
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
 8015890:	b480      	push	{r7}
 8015892:	b083      	sub	sp, #12
 8015894:	af00      	add	r7, sp, #0
 8015896:	6078      	str	r0, [r7, #4]
 8015898:	6039      	str	r1, [r7, #0]
	clst -= 2;
 801589a:	683b      	ldr	r3, [r7, #0]
 801589c:	3b02      	subs	r3, #2
 801589e:	603b      	str	r3, [r7, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 80158a0:	687b      	ldr	r3, [r7, #4]
 80158a2:	699b      	ldr	r3, [r3, #24]
 80158a4:	3b02      	subs	r3, #2
 80158a6:	683a      	ldr	r2, [r7, #0]
 80158a8:	429a      	cmp	r2, r3
 80158aa:	d301      	bcc.n	80158b0 <clust2sect+0x20>
 80158ac:	2300      	movs	r3, #0
 80158ae:	e008      	b.n	80158c2 <clust2sect+0x32>
	return clst * fs->csize + fs->database;
 80158b0:	687b      	ldr	r3, [r7, #4]
 80158b2:	895b      	ldrh	r3, [r3, #10]
 80158b4:	461a      	mov	r2, r3
 80158b6:	683b      	ldr	r3, [r7, #0]
 80158b8:	fb03 f202 	mul.w	r2, r3, r2
 80158bc:	687b      	ldr	r3, [r7, #4]
 80158be:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80158c0:	4413      	add	r3, r2
}
 80158c2:	4618      	mov	r0, r3
 80158c4:	370c      	adds	r7, #12
 80158c6:	46bd      	mov	sp, r7
 80158c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80158cc:	4770      	bx	lr

080158ce <get_fat>:
static
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
	_FDID* obj,	/* Corresponding object */
	DWORD clst	/* Cluster number to get the value */
)
{
 80158ce:	b580      	push	{r7, lr}
 80158d0:	b086      	sub	sp, #24
 80158d2:	af00      	add	r7, sp, #0
 80158d4:	6078      	str	r0, [r7, #4]
 80158d6:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;
 80158d8:	687b      	ldr	r3, [r7, #4]
 80158da:	681b      	ldr	r3, [r3, #0]
 80158dc:	613b      	str	r3, [r7, #16]


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 80158de:	683b      	ldr	r3, [r7, #0]
 80158e0:	2b01      	cmp	r3, #1
 80158e2:	d904      	bls.n	80158ee <get_fat+0x20>
 80158e4:	693b      	ldr	r3, [r7, #16]
 80158e6:	699b      	ldr	r3, [r3, #24]
 80158e8:	683a      	ldr	r2, [r7, #0]
 80158ea:	429a      	cmp	r2, r3
 80158ec:	d302      	bcc.n	80158f4 <get_fat+0x26>
		val = 1;	/* Internal error */
 80158ee:	2301      	movs	r3, #1
 80158f0:	617b      	str	r3, [r7, #20]
 80158f2:	e08e      	b.n	8015a12 <get_fat+0x144>

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 80158f4:	f04f 33ff 	mov.w	r3, #4294967295
 80158f8:	617b      	str	r3, [r7, #20]

		switch (fs->fs_type) {
 80158fa:	693b      	ldr	r3, [r7, #16]
 80158fc:	781b      	ldrb	r3, [r3, #0]
 80158fe:	2b03      	cmp	r3, #3
 8015900:	d061      	beq.n	80159c6 <get_fat+0xf8>
 8015902:	2b03      	cmp	r3, #3
 8015904:	dc7b      	bgt.n	80159fe <get_fat+0x130>
 8015906:	2b01      	cmp	r3, #1
 8015908:	d002      	beq.n	8015910 <get_fat+0x42>
 801590a:	2b02      	cmp	r3, #2
 801590c:	d041      	beq.n	8015992 <get_fat+0xc4>
 801590e:	e076      	b.n	80159fe <get_fat+0x130>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
 8015910:	683b      	ldr	r3, [r7, #0]
 8015912:	60fb      	str	r3, [r7, #12]
 8015914:	68fb      	ldr	r3, [r7, #12]
 8015916:	085b      	lsrs	r3, r3, #1
 8015918:	68fa      	ldr	r2, [r7, #12]
 801591a:	4413      	add	r3, r2
 801591c:	60fb      	str	r3, [r7, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 801591e:	693b      	ldr	r3, [r7, #16]
 8015920:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8015922:	68fb      	ldr	r3, [r7, #12]
 8015924:	0a5b      	lsrs	r3, r3, #9
 8015926:	4413      	add	r3, r2
 8015928:	4619      	mov	r1, r3
 801592a:	6938      	ldr	r0, [r7, #16]
 801592c:	f7ff ff14 	bl	8015758 <move_window>
 8015930:	4603      	mov	r3, r0
 8015932:	2b00      	cmp	r3, #0
 8015934:	d166      	bne.n	8015a04 <get_fat+0x136>
			wc = fs->win[bc++ % SS(fs)];
 8015936:	68fb      	ldr	r3, [r7, #12]
 8015938:	1c5a      	adds	r2, r3, #1
 801593a:	60fa      	str	r2, [r7, #12]
 801593c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8015940:	693a      	ldr	r2, [r7, #16]
 8015942:	4413      	add	r3, r2
 8015944:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8015948:	60bb      	str	r3, [r7, #8]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 801594a:	693b      	ldr	r3, [r7, #16]
 801594c:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 801594e:	68fb      	ldr	r3, [r7, #12]
 8015950:	0a5b      	lsrs	r3, r3, #9
 8015952:	4413      	add	r3, r2
 8015954:	4619      	mov	r1, r3
 8015956:	6938      	ldr	r0, [r7, #16]
 8015958:	f7ff fefe 	bl	8015758 <move_window>
 801595c:	4603      	mov	r3, r0
 801595e:	2b00      	cmp	r3, #0
 8015960:	d152      	bne.n	8015a08 <get_fat+0x13a>
			wc |= fs->win[bc % SS(fs)] << 8;
 8015962:	68fb      	ldr	r3, [r7, #12]
 8015964:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8015968:	693a      	ldr	r2, [r7, #16]
 801596a:	4413      	add	r3, r2
 801596c:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8015970:	021b      	lsls	r3, r3, #8
 8015972:	68ba      	ldr	r2, [r7, #8]
 8015974:	4313      	orrs	r3, r2
 8015976:	60bb      	str	r3, [r7, #8]
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8015978:	683b      	ldr	r3, [r7, #0]
 801597a:	f003 0301 	and.w	r3, r3, #1
 801597e:	2b00      	cmp	r3, #0
 8015980:	d002      	beq.n	8015988 <get_fat+0xba>
 8015982:	68bb      	ldr	r3, [r7, #8]
 8015984:	091b      	lsrs	r3, r3, #4
 8015986:	e002      	b.n	801598e <get_fat+0xc0>
 8015988:	68bb      	ldr	r3, [r7, #8]
 801598a:	f3c3 030b 	ubfx	r3, r3, #0, #12
 801598e:	617b      	str	r3, [r7, #20]
			break;
 8015990:	e03f      	b.n	8015a12 <get_fat+0x144>

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8015992:	693b      	ldr	r3, [r7, #16]
 8015994:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8015996:	683b      	ldr	r3, [r7, #0]
 8015998:	0a1b      	lsrs	r3, r3, #8
 801599a:	4413      	add	r3, r2
 801599c:	4619      	mov	r1, r3
 801599e:	6938      	ldr	r0, [r7, #16]
 80159a0:	f7ff feda 	bl	8015758 <move_window>
 80159a4:	4603      	mov	r3, r0
 80159a6:	2b00      	cmp	r3, #0
 80159a8:	d130      	bne.n	8015a0c <get_fat+0x13e>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 80159aa:	693b      	ldr	r3, [r7, #16]
 80159ac:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 80159b0:	683b      	ldr	r3, [r7, #0]
 80159b2:	005b      	lsls	r3, r3, #1
 80159b4:	f403 73ff 	and.w	r3, r3, #510	@ 0x1fe
 80159b8:	4413      	add	r3, r2
 80159ba:	4618      	mov	r0, r3
 80159bc:	f7ff fc1c 	bl	80151f8 <ld_word>
 80159c0:	4603      	mov	r3, r0
 80159c2:	617b      	str	r3, [r7, #20]
			break;
 80159c4:	e025      	b.n	8015a12 <get_fat+0x144>

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 80159c6:	693b      	ldr	r3, [r7, #16]
 80159c8:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 80159ca:	683b      	ldr	r3, [r7, #0]
 80159cc:	09db      	lsrs	r3, r3, #7
 80159ce:	4413      	add	r3, r2
 80159d0:	4619      	mov	r1, r3
 80159d2:	6938      	ldr	r0, [r7, #16]
 80159d4:	f7ff fec0 	bl	8015758 <move_window>
 80159d8:	4603      	mov	r3, r0
 80159da:	2b00      	cmp	r3, #0
 80159dc:	d118      	bne.n	8015a10 <get_fat+0x142>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 80159de:	693b      	ldr	r3, [r7, #16]
 80159e0:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 80159e4:	683b      	ldr	r3, [r7, #0]
 80159e6:	009b      	lsls	r3, r3, #2
 80159e8:	f403 73fe 	and.w	r3, r3, #508	@ 0x1fc
 80159ec:	4413      	add	r3, r2
 80159ee:	4618      	mov	r0, r3
 80159f0:	f7ff fc1a 	bl	8015228 <ld_dword>
 80159f4:	4603      	mov	r3, r0
 80159f6:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 80159fa:	617b      	str	r3, [r7, #20]
			break;
 80159fc:	e009      	b.n	8015a12 <get_fat+0x144>
				}
			}
			/* go to default */
#endif
		default:
			val = 1;	/* Internal error */
 80159fe:	2301      	movs	r3, #1
 8015a00:	617b      	str	r3, [r7, #20]
 8015a02:	e006      	b.n	8015a12 <get_fat+0x144>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8015a04:	bf00      	nop
 8015a06:	e004      	b.n	8015a12 <get_fat+0x144>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8015a08:	bf00      	nop
 8015a0a:	e002      	b.n	8015a12 <get_fat+0x144>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8015a0c:	bf00      	nop
 8015a0e:	e000      	b.n	8015a12 <get_fat+0x144>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8015a10:	bf00      	nop
		}
	}

	return val;
 8015a12:	697b      	ldr	r3, [r7, #20]
}
 8015a14:	4618      	mov	r0, r3
 8015a16:	3718      	adds	r7, #24
 8015a18:	46bd      	mov	sp, r7
 8015a1a:	bd80      	pop	{r7, pc}

08015a1c <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* Corresponding file system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
 8015a1c:	b590      	push	{r4, r7, lr}
 8015a1e:	b089      	sub	sp, #36	@ 0x24
 8015a20:	af00      	add	r7, sp, #0
 8015a22:	60f8      	str	r0, [r7, #12]
 8015a24:	60b9      	str	r1, [r7, #8]
 8015a26:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;
 8015a28:	2302      	movs	r3, #2
 8015a2a:	77fb      	strb	r3, [r7, #31]

	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8015a2c:	68bb      	ldr	r3, [r7, #8]
 8015a2e:	2b01      	cmp	r3, #1
 8015a30:	f240 80d9 	bls.w	8015be6 <put_fat+0x1ca>
 8015a34:	68fb      	ldr	r3, [r7, #12]
 8015a36:	699b      	ldr	r3, [r3, #24]
 8015a38:	68ba      	ldr	r2, [r7, #8]
 8015a3a:	429a      	cmp	r2, r3
 8015a3c:	f080 80d3 	bcs.w	8015be6 <put_fat+0x1ca>
		switch (fs->fs_type) {
 8015a40:	68fb      	ldr	r3, [r7, #12]
 8015a42:	781b      	ldrb	r3, [r3, #0]
 8015a44:	2b03      	cmp	r3, #3
 8015a46:	f000 8096 	beq.w	8015b76 <put_fat+0x15a>
 8015a4a:	2b03      	cmp	r3, #3
 8015a4c:	f300 80cb 	bgt.w	8015be6 <put_fat+0x1ca>
 8015a50:	2b01      	cmp	r3, #1
 8015a52:	d002      	beq.n	8015a5a <put_fat+0x3e>
 8015a54:	2b02      	cmp	r3, #2
 8015a56:	d06e      	beq.n	8015b36 <put_fat+0x11a>
 8015a58:	e0c5      	b.n	8015be6 <put_fat+0x1ca>
		case FS_FAT12 :	/* Bitfield items */
			bc = (UINT)clst; bc += bc / 2;
 8015a5a:	68bb      	ldr	r3, [r7, #8]
 8015a5c:	61bb      	str	r3, [r7, #24]
 8015a5e:	69bb      	ldr	r3, [r7, #24]
 8015a60:	085b      	lsrs	r3, r3, #1
 8015a62:	69ba      	ldr	r2, [r7, #24]
 8015a64:	4413      	add	r3, r2
 8015a66:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8015a68:	68fb      	ldr	r3, [r7, #12]
 8015a6a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8015a6c:	69bb      	ldr	r3, [r7, #24]
 8015a6e:	0a5b      	lsrs	r3, r3, #9
 8015a70:	4413      	add	r3, r2
 8015a72:	4619      	mov	r1, r3
 8015a74:	68f8      	ldr	r0, [r7, #12]
 8015a76:	f7ff fe6f 	bl	8015758 <move_window>
 8015a7a:	4603      	mov	r3, r0
 8015a7c:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8015a7e:	7ffb      	ldrb	r3, [r7, #31]
 8015a80:	2b00      	cmp	r3, #0
 8015a82:	f040 80a9 	bne.w	8015bd8 <put_fat+0x1bc>
			p = fs->win + bc++ % SS(fs);
 8015a86:	68fb      	ldr	r3, [r7, #12]
 8015a88:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8015a8c:	69bb      	ldr	r3, [r7, #24]
 8015a8e:	1c59      	adds	r1, r3, #1
 8015a90:	61b9      	str	r1, [r7, #24]
 8015a92:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8015a96:	4413      	add	r3, r2
 8015a98:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8015a9a:	68bb      	ldr	r3, [r7, #8]
 8015a9c:	f003 0301 	and.w	r3, r3, #1
 8015aa0:	2b00      	cmp	r3, #0
 8015aa2:	d00d      	beq.n	8015ac0 <put_fat+0xa4>
 8015aa4:	697b      	ldr	r3, [r7, #20]
 8015aa6:	781b      	ldrb	r3, [r3, #0]
 8015aa8:	b25b      	sxtb	r3, r3
 8015aaa:	f003 030f 	and.w	r3, r3, #15
 8015aae:	b25a      	sxtb	r2, r3
 8015ab0:	687b      	ldr	r3, [r7, #4]
 8015ab2:	b2db      	uxtb	r3, r3
 8015ab4:	011b      	lsls	r3, r3, #4
 8015ab6:	b25b      	sxtb	r3, r3
 8015ab8:	4313      	orrs	r3, r2
 8015aba:	b25b      	sxtb	r3, r3
 8015abc:	b2db      	uxtb	r3, r3
 8015abe:	e001      	b.n	8015ac4 <put_fat+0xa8>
 8015ac0:	687b      	ldr	r3, [r7, #4]
 8015ac2:	b2db      	uxtb	r3, r3
 8015ac4:	697a      	ldr	r2, [r7, #20]
 8015ac6:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 8015ac8:	68fb      	ldr	r3, [r7, #12]
 8015aca:	2201      	movs	r2, #1
 8015acc:	70da      	strb	r2, [r3, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8015ace:	68fb      	ldr	r3, [r7, #12]
 8015ad0:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8015ad2:	69bb      	ldr	r3, [r7, #24]
 8015ad4:	0a5b      	lsrs	r3, r3, #9
 8015ad6:	4413      	add	r3, r2
 8015ad8:	4619      	mov	r1, r3
 8015ada:	68f8      	ldr	r0, [r7, #12]
 8015adc:	f7ff fe3c 	bl	8015758 <move_window>
 8015ae0:	4603      	mov	r3, r0
 8015ae2:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8015ae4:	7ffb      	ldrb	r3, [r7, #31]
 8015ae6:	2b00      	cmp	r3, #0
 8015ae8:	d178      	bne.n	8015bdc <put_fat+0x1c0>
			p = fs->win + bc % SS(fs);
 8015aea:	68fb      	ldr	r3, [r7, #12]
 8015aec:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8015af0:	69bb      	ldr	r3, [r7, #24]
 8015af2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8015af6:	4413      	add	r3, r2
 8015af8:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8015afa:	68bb      	ldr	r3, [r7, #8]
 8015afc:	f003 0301 	and.w	r3, r3, #1
 8015b00:	2b00      	cmp	r3, #0
 8015b02:	d003      	beq.n	8015b0c <put_fat+0xf0>
 8015b04:	687b      	ldr	r3, [r7, #4]
 8015b06:	091b      	lsrs	r3, r3, #4
 8015b08:	b2db      	uxtb	r3, r3
 8015b0a:	e00e      	b.n	8015b2a <put_fat+0x10e>
 8015b0c:	697b      	ldr	r3, [r7, #20]
 8015b0e:	781b      	ldrb	r3, [r3, #0]
 8015b10:	b25b      	sxtb	r3, r3
 8015b12:	f023 030f 	bic.w	r3, r3, #15
 8015b16:	b25a      	sxtb	r2, r3
 8015b18:	687b      	ldr	r3, [r7, #4]
 8015b1a:	0a1b      	lsrs	r3, r3, #8
 8015b1c:	b25b      	sxtb	r3, r3
 8015b1e:	f003 030f 	and.w	r3, r3, #15
 8015b22:	b25b      	sxtb	r3, r3
 8015b24:	4313      	orrs	r3, r2
 8015b26:	b25b      	sxtb	r3, r3
 8015b28:	b2db      	uxtb	r3, r3
 8015b2a:	697a      	ldr	r2, [r7, #20]
 8015b2c:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
 8015b2e:	68fb      	ldr	r3, [r7, #12]
 8015b30:	2201      	movs	r2, #1
 8015b32:	70da      	strb	r2, [r3, #3]
			break;
 8015b34:	e057      	b.n	8015be6 <put_fat+0x1ca>

		case FS_FAT16 :	/* WORD aligned items */
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8015b36:	68fb      	ldr	r3, [r7, #12]
 8015b38:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8015b3a:	68bb      	ldr	r3, [r7, #8]
 8015b3c:	0a1b      	lsrs	r3, r3, #8
 8015b3e:	4413      	add	r3, r2
 8015b40:	4619      	mov	r1, r3
 8015b42:	68f8      	ldr	r0, [r7, #12]
 8015b44:	f7ff fe08 	bl	8015758 <move_window>
 8015b48:	4603      	mov	r3, r0
 8015b4a:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8015b4c:	7ffb      	ldrb	r3, [r7, #31]
 8015b4e:	2b00      	cmp	r3, #0
 8015b50:	d146      	bne.n	8015be0 <put_fat+0x1c4>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 8015b52:	68fb      	ldr	r3, [r7, #12]
 8015b54:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8015b58:	68bb      	ldr	r3, [r7, #8]
 8015b5a:	005b      	lsls	r3, r3, #1
 8015b5c:	f403 73ff 	and.w	r3, r3, #510	@ 0x1fe
 8015b60:	4413      	add	r3, r2
 8015b62:	687a      	ldr	r2, [r7, #4]
 8015b64:	b292      	uxth	r2, r2
 8015b66:	4611      	mov	r1, r2
 8015b68:	4618      	mov	r0, r3
 8015b6a:	f7ff fb80 	bl	801526e <st_word>
			fs->wflag = 1;
 8015b6e:	68fb      	ldr	r3, [r7, #12]
 8015b70:	2201      	movs	r2, #1
 8015b72:	70da      	strb	r2, [r3, #3]
			break;
 8015b74:	e037      	b.n	8015be6 <put_fat+0x1ca>

		case FS_FAT32 :	/* DWORD aligned items */
#if _FS_EXFAT
		case FS_EXFAT :
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8015b76:	68fb      	ldr	r3, [r7, #12]
 8015b78:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8015b7a:	68bb      	ldr	r3, [r7, #8]
 8015b7c:	09db      	lsrs	r3, r3, #7
 8015b7e:	4413      	add	r3, r2
 8015b80:	4619      	mov	r1, r3
 8015b82:	68f8      	ldr	r0, [r7, #12]
 8015b84:	f7ff fde8 	bl	8015758 <move_window>
 8015b88:	4603      	mov	r3, r0
 8015b8a:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
 8015b8c:	7ffb      	ldrb	r3, [r7, #31]
 8015b8e:	2b00      	cmp	r3, #0
 8015b90:	d128      	bne.n	8015be4 <put_fat+0x1c8>
			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8015b92:	687b      	ldr	r3, [r7, #4]
 8015b94:	f023 4470 	bic.w	r4, r3, #4026531840	@ 0xf0000000
 8015b98:	68fb      	ldr	r3, [r7, #12]
 8015b9a:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8015b9e:	68bb      	ldr	r3, [r7, #8]
 8015ba0:	009b      	lsls	r3, r3, #2
 8015ba2:	f403 73fe 	and.w	r3, r3, #508	@ 0x1fc
 8015ba6:	4413      	add	r3, r2
 8015ba8:	4618      	mov	r0, r3
 8015baa:	f7ff fb3d 	bl	8015228 <ld_dword>
 8015bae:	4603      	mov	r3, r0
 8015bb0:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 8015bb4:	4323      	orrs	r3, r4
 8015bb6:	607b      	str	r3, [r7, #4]
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
 8015bb8:	68fb      	ldr	r3, [r7, #12]
 8015bba:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8015bbe:	68bb      	ldr	r3, [r7, #8]
 8015bc0:	009b      	lsls	r3, r3, #2
 8015bc2:	f403 73fe 	and.w	r3, r3, #508	@ 0x1fc
 8015bc6:	4413      	add	r3, r2
 8015bc8:	6879      	ldr	r1, [r7, #4]
 8015bca:	4618      	mov	r0, r3
 8015bcc:	f7ff fb6a 	bl	80152a4 <st_dword>
			fs->wflag = 1;
 8015bd0:	68fb      	ldr	r3, [r7, #12]
 8015bd2:	2201      	movs	r2, #1
 8015bd4:	70da      	strb	r2, [r3, #3]
			break;
 8015bd6:	e006      	b.n	8015be6 <put_fat+0x1ca>
			if (res != FR_OK) break;
 8015bd8:	bf00      	nop
 8015bda:	e004      	b.n	8015be6 <put_fat+0x1ca>
			if (res != FR_OK) break;
 8015bdc:	bf00      	nop
 8015bde:	e002      	b.n	8015be6 <put_fat+0x1ca>
			if (res != FR_OK) break;
 8015be0:	bf00      	nop
 8015be2:	e000      	b.n	8015be6 <put_fat+0x1ca>
			if (res != FR_OK) break;
 8015be4:	bf00      	nop
		}
	}
	return res;
 8015be6:	7ffb      	ldrb	r3, [r7, #31]
}
 8015be8:	4618      	mov	r0, r3
 8015bea:	3724      	adds	r7, #36	@ 0x24
 8015bec:	46bd      	mov	sp, r7
 8015bee:	bd90      	pop	{r4, r7, pc}

08015bf0 <remove_chain>:
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	_FDID* obj,			/* Corresponding object */
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
)
{
 8015bf0:	b580      	push	{r7, lr}
 8015bf2:	b088      	sub	sp, #32
 8015bf4:	af00      	add	r7, sp, #0
 8015bf6:	60f8      	str	r0, [r7, #12]
 8015bf8:	60b9      	str	r1, [r7, #8]
 8015bfa:	607a      	str	r2, [r7, #4]
	FRESULT res = FR_OK;
 8015bfc:	2300      	movs	r3, #0
 8015bfe:	77fb      	strb	r3, [r7, #31]
	DWORD nxt;
	FATFS *fs = obj->fs;
 8015c00:	68fb      	ldr	r3, [r7, #12]
 8015c02:	681b      	ldr	r3, [r3, #0]
 8015c04:	61bb      	str	r3, [r7, #24]
#endif
#if _USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8015c06:	68bb      	ldr	r3, [r7, #8]
 8015c08:	2b01      	cmp	r3, #1
 8015c0a:	d904      	bls.n	8015c16 <remove_chain+0x26>
 8015c0c:	69bb      	ldr	r3, [r7, #24]
 8015c0e:	699b      	ldr	r3, [r3, #24]
 8015c10:	68ba      	ldr	r2, [r7, #8]
 8015c12:	429a      	cmp	r2, r3
 8015c14:	d301      	bcc.n	8015c1a <remove_chain+0x2a>
 8015c16:	2302      	movs	r3, #2
 8015c18:	e04b      	b.n	8015cb2 <remove_chain+0xc2>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 8015c1a:	687b      	ldr	r3, [r7, #4]
 8015c1c:	2b00      	cmp	r3, #0
 8015c1e:	d00c      	beq.n	8015c3a <remove_chain+0x4a>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 8015c20:	f04f 32ff 	mov.w	r2, #4294967295
 8015c24:	6879      	ldr	r1, [r7, #4]
 8015c26:	69b8      	ldr	r0, [r7, #24]
 8015c28:	f7ff fef8 	bl	8015a1c <put_fat>
 8015c2c:	4603      	mov	r3, r0
 8015c2e:	77fb      	strb	r3, [r7, #31]
		if (res != FR_OK) return res;
 8015c30:	7ffb      	ldrb	r3, [r7, #31]
 8015c32:	2b00      	cmp	r3, #0
 8015c34:	d001      	beq.n	8015c3a <remove_chain+0x4a>
 8015c36:	7ffb      	ldrb	r3, [r7, #31]
 8015c38:	e03b      	b.n	8015cb2 <remove_chain+0xc2>
	}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
 8015c3a:	68b9      	ldr	r1, [r7, #8]
 8015c3c:	68f8      	ldr	r0, [r7, #12]
 8015c3e:	f7ff fe46 	bl	80158ce <get_fat>
 8015c42:	6178      	str	r0, [r7, #20]
		if (nxt == 0) break;				/* Empty cluster? */
 8015c44:	697b      	ldr	r3, [r7, #20]
 8015c46:	2b00      	cmp	r3, #0
 8015c48:	d031      	beq.n	8015cae <remove_chain+0xbe>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 8015c4a:	697b      	ldr	r3, [r7, #20]
 8015c4c:	2b01      	cmp	r3, #1
 8015c4e:	d101      	bne.n	8015c54 <remove_chain+0x64>
 8015c50:	2302      	movs	r3, #2
 8015c52:	e02e      	b.n	8015cb2 <remove_chain+0xc2>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 8015c54:	697b      	ldr	r3, [r7, #20]
 8015c56:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015c5a:	d101      	bne.n	8015c60 <remove_chain+0x70>
 8015c5c:	2301      	movs	r3, #1
 8015c5e:	e028      	b.n	8015cb2 <remove_chain+0xc2>
		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 8015c60:	2200      	movs	r2, #0
 8015c62:	68b9      	ldr	r1, [r7, #8]
 8015c64:	69b8      	ldr	r0, [r7, #24]
 8015c66:	f7ff fed9 	bl	8015a1c <put_fat>
 8015c6a:	4603      	mov	r3, r0
 8015c6c:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) return res;
 8015c6e:	7ffb      	ldrb	r3, [r7, #31]
 8015c70:	2b00      	cmp	r3, #0
 8015c72:	d001      	beq.n	8015c78 <remove_chain+0x88>
 8015c74:	7ffb      	ldrb	r3, [r7, #31]
 8015c76:	e01c      	b.n	8015cb2 <remove_chain+0xc2>
		}
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 8015c78:	69bb      	ldr	r3, [r7, #24]
 8015c7a:	695a      	ldr	r2, [r3, #20]
 8015c7c:	69bb      	ldr	r3, [r7, #24]
 8015c7e:	699b      	ldr	r3, [r3, #24]
 8015c80:	3b02      	subs	r3, #2
 8015c82:	429a      	cmp	r2, r3
 8015c84:	d20b      	bcs.n	8015c9e <remove_chain+0xae>
			fs->free_clst++;
 8015c86:	69bb      	ldr	r3, [r7, #24]
 8015c88:	695b      	ldr	r3, [r3, #20]
 8015c8a:	1c5a      	adds	r2, r3, #1
 8015c8c:	69bb      	ldr	r3, [r7, #24]
 8015c8e:	615a      	str	r2, [r3, #20]
			fs->fsi_flag |= 1;
 8015c90:	69bb      	ldr	r3, [r7, #24]
 8015c92:	791b      	ldrb	r3, [r3, #4]
 8015c94:	f043 0301 	orr.w	r3, r3, #1
 8015c98:	b2da      	uxtb	r2, r3
 8015c9a:	69bb      	ldr	r3, [r7, #24]
 8015c9c:	711a      	strb	r2, [r3, #4]
			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
#endif
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
 8015c9e:	697b      	ldr	r3, [r7, #20]
 8015ca0:	60bb      	str	r3, [r7, #8]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 8015ca2:	69bb      	ldr	r3, [r7, #24]
 8015ca4:	699b      	ldr	r3, [r3, #24]
 8015ca6:	68ba      	ldr	r2, [r7, #8]
 8015ca8:	429a      	cmp	r2, r3
 8015caa:	d3c6      	bcc.n	8015c3a <remove_chain+0x4a>
 8015cac:	e000      	b.n	8015cb0 <remove_chain+0xc0>
		if (nxt == 0) break;				/* Empty cluster? */
 8015cae:	bf00      	nop
				obj->stat = 2;	/* Change the object status 'contiguous' */
			}
		}
	}
#endif
	return FR_OK;
 8015cb0:	2300      	movs	r3, #0
}
 8015cb2:	4618      	mov	r0, r3
 8015cb4:	3720      	adds	r7, #32
 8015cb6:	46bd      	mov	sp, r7
 8015cb8:	bd80      	pop	{r7, pc}

08015cba <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	_FDID* obj,			/* Corresponding object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
 8015cba:	b580      	push	{r7, lr}
 8015cbc:	b088      	sub	sp, #32
 8015cbe:	af00      	add	r7, sp, #0
 8015cc0:	6078      	str	r0, [r7, #4]
 8015cc2:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;
	FATFS *fs = obj->fs;
 8015cc4:	687b      	ldr	r3, [r7, #4]
 8015cc6:	681b      	ldr	r3, [r3, #0]
 8015cc8:	613b      	str	r3, [r7, #16]


	if (clst == 0) {	/* Create a new chain */
 8015cca:	683b      	ldr	r3, [r7, #0]
 8015ccc:	2b00      	cmp	r3, #0
 8015cce:	d10d      	bne.n	8015cec <create_chain+0x32>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 8015cd0:	693b      	ldr	r3, [r7, #16]
 8015cd2:	691b      	ldr	r3, [r3, #16]
 8015cd4:	61bb      	str	r3, [r7, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8015cd6:	69bb      	ldr	r3, [r7, #24]
 8015cd8:	2b00      	cmp	r3, #0
 8015cda:	d004      	beq.n	8015ce6 <create_chain+0x2c>
 8015cdc:	693b      	ldr	r3, [r7, #16]
 8015cde:	699b      	ldr	r3, [r3, #24]
 8015ce0:	69ba      	ldr	r2, [r7, #24]
 8015ce2:	429a      	cmp	r2, r3
 8015ce4:	d31b      	bcc.n	8015d1e <create_chain+0x64>
 8015ce6:	2301      	movs	r3, #1
 8015ce8:	61bb      	str	r3, [r7, #24]
 8015cea:	e018      	b.n	8015d1e <create_chain+0x64>
	}
	else {				/* Stretch current chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8015cec:	6839      	ldr	r1, [r7, #0]
 8015cee:	6878      	ldr	r0, [r7, #4]
 8015cf0:	f7ff fded 	bl	80158ce <get_fat>
 8015cf4:	60f8      	str	r0, [r7, #12]
		if (cs < 2) return 1;				/* Invalid FAT value */
 8015cf6:	68fb      	ldr	r3, [r7, #12]
 8015cf8:	2b01      	cmp	r3, #1
 8015cfa:	d801      	bhi.n	8015d00 <create_chain+0x46>
 8015cfc:	2301      	movs	r3, #1
 8015cfe:	e070      	b.n	8015de2 <create_chain+0x128>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8015d00:	68fb      	ldr	r3, [r7, #12]
 8015d02:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015d06:	d101      	bne.n	8015d0c <create_chain+0x52>
 8015d08:	68fb      	ldr	r3, [r7, #12]
 8015d0a:	e06a      	b.n	8015de2 <create_chain+0x128>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8015d0c:	693b      	ldr	r3, [r7, #16]
 8015d0e:	699b      	ldr	r3, [r3, #24]
 8015d10:	68fa      	ldr	r2, [r7, #12]
 8015d12:	429a      	cmp	r2, r3
 8015d14:	d201      	bcs.n	8015d1a <create_chain+0x60>
 8015d16:	68fb      	ldr	r3, [r7, #12]
 8015d18:	e063      	b.n	8015de2 <create_chain+0x128>
		scl = clst;
 8015d1a:	683b      	ldr	r3, [r7, #0]
 8015d1c:	61bb      	str	r3, [r7, #24]
			}
		}
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		ncl = scl;	/* Start cluster */
 8015d1e:	69bb      	ldr	r3, [r7, #24]
 8015d20:	61fb      	str	r3, [r7, #28]
		for (;;) {
			ncl++;							/* Next cluster */
 8015d22:	69fb      	ldr	r3, [r7, #28]
 8015d24:	3301      	adds	r3, #1
 8015d26:	61fb      	str	r3, [r7, #28]
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8015d28:	693b      	ldr	r3, [r7, #16]
 8015d2a:	699b      	ldr	r3, [r3, #24]
 8015d2c:	69fa      	ldr	r2, [r7, #28]
 8015d2e:	429a      	cmp	r2, r3
 8015d30:	d307      	bcc.n	8015d42 <create_chain+0x88>
				ncl = 2;
 8015d32:	2302      	movs	r3, #2
 8015d34:	61fb      	str	r3, [r7, #28]
				if (ncl > scl) return 0;	/* No free cluster */
 8015d36:	69fa      	ldr	r2, [r7, #28]
 8015d38:	69bb      	ldr	r3, [r7, #24]
 8015d3a:	429a      	cmp	r2, r3
 8015d3c:	d901      	bls.n	8015d42 <create_chain+0x88>
 8015d3e:	2300      	movs	r3, #0
 8015d40:	e04f      	b.n	8015de2 <create_chain+0x128>
			}
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 8015d42:	69f9      	ldr	r1, [r7, #28]
 8015d44:	6878      	ldr	r0, [r7, #4]
 8015d46:	f7ff fdc2 	bl	80158ce <get_fat>
 8015d4a:	60f8      	str	r0, [r7, #12]
			if (cs == 0) break;				/* Found a free cluster */
 8015d4c:	68fb      	ldr	r3, [r7, #12]
 8015d4e:	2b00      	cmp	r3, #0
 8015d50:	d00e      	beq.n	8015d70 <create_chain+0xb6>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 8015d52:	68fb      	ldr	r3, [r7, #12]
 8015d54:	2b01      	cmp	r3, #1
 8015d56:	d003      	beq.n	8015d60 <create_chain+0xa6>
 8015d58:	68fb      	ldr	r3, [r7, #12]
 8015d5a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015d5e:	d101      	bne.n	8015d64 <create_chain+0xaa>
 8015d60:	68fb      	ldr	r3, [r7, #12]
 8015d62:	e03e      	b.n	8015de2 <create_chain+0x128>
			if (ncl == scl) return 0;		/* No free cluster */
 8015d64:	69fa      	ldr	r2, [r7, #28]
 8015d66:	69bb      	ldr	r3, [r7, #24]
 8015d68:	429a      	cmp	r2, r3
 8015d6a:	d1da      	bne.n	8015d22 <create_chain+0x68>
 8015d6c:	2300      	movs	r3, #0
 8015d6e:	e038      	b.n	8015de2 <create_chain+0x128>
			if (cs == 0) break;				/* Found a free cluster */
 8015d70:	bf00      	nop
		}
		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
 8015d72:	f04f 32ff 	mov.w	r2, #4294967295
 8015d76:	69f9      	ldr	r1, [r7, #28]
 8015d78:	6938      	ldr	r0, [r7, #16]
 8015d7a:	f7ff fe4f 	bl	8015a1c <put_fat>
 8015d7e:	4603      	mov	r3, r0
 8015d80:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK && clst != 0) {
 8015d82:	7dfb      	ldrb	r3, [r7, #23]
 8015d84:	2b00      	cmp	r3, #0
 8015d86:	d109      	bne.n	8015d9c <create_chain+0xe2>
 8015d88:	683b      	ldr	r3, [r7, #0]
 8015d8a:	2b00      	cmp	r3, #0
 8015d8c:	d006      	beq.n	8015d9c <create_chain+0xe2>
			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
 8015d8e:	69fa      	ldr	r2, [r7, #28]
 8015d90:	6839      	ldr	r1, [r7, #0]
 8015d92:	6938      	ldr	r0, [r7, #16]
 8015d94:	f7ff fe42 	bl	8015a1c <put_fat>
 8015d98:	4603      	mov	r3, r0
 8015d9a:	75fb      	strb	r3, [r7, #23]
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8015d9c:	7dfb      	ldrb	r3, [r7, #23]
 8015d9e:	2b00      	cmp	r3, #0
 8015da0:	d116      	bne.n	8015dd0 <create_chain+0x116>
		fs->last_clst = ncl;
 8015da2:	693b      	ldr	r3, [r7, #16]
 8015da4:	69fa      	ldr	r2, [r7, #28]
 8015da6:	611a      	str	r2, [r3, #16]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8015da8:	693b      	ldr	r3, [r7, #16]
 8015daa:	695a      	ldr	r2, [r3, #20]
 8015dac:	693b      	ldr	r3, [r7, #16]
 8015dae:	699b      	ldr	r3, [r3, #24]
 8015db0:	3b02      	subs	r3, #2
 8015db2:	429a      	cmp	r2, r3
 8015db4:	d804      	bhi.n	8015dc0 <create_chain+0x106>
 8015db6:	693b      	ldr	r3, [r7, #16]
 8015db8:	695b      	ldr	r3, [r3, #20]
 8015dba:	1e5a      	subs	r2, r3, #1
 8015dbc:	693b      	ldr	r3, [r7, #16]
 8015dbe:	615a      	str	r2, [r3, #20]
		fs->fsi_flag |= 1;
 8015dc0:	693b      	ldr	r3, [r7, #16]
 8015dc2:	791b      	ldrb	r3, [r3, #4]
 8015dc4:	f043 0301 	orr.w	r3, r3, #1
 8015dc8:	b2da      	uxtb	r2, r3
 8015dca:	693b      	ldr	r3, [r7, #16]
 8015dcc:	711a      	strb	r2, [r3, #4]
 8015dce:	e007      	b.n	8015de0 <create_chain+0x126>
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8015dd0:	7dfb      	ldrb	r3, [r7, #23]
 8015dd2:	2b01      	cmp	r3, #1
 8015dd4:	d102      	bne.n	8015ddc <create_chain+0x122>
 8015dd6:	f04f 33ff 	mov.w	r3, #4294967295
 8015dda:	e000      	b.n	8015dde <create_chain+0x124>
 8015ddc:	2301      	movs	r3, #1
 8015dde:	61fb      	str	r3, [r7, #28]
	}

	return ncl;		/* Return new cluster number or error status */
 8015de0:	69fb      	ldr	r3, [r7, #28]
}
 8015de2:	4618      	mov	r0, r3
 8015de4:	3720      	adds	r7, #32
 8015de6:	46bd      	mov	sp, r7
 8015de8:	bd80      	pop	{r7, pc}

08015dea <clmt_clust>:
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File offset to be converted to cluster# */
)
{
 8015dea:	b480      	push	{r7}
 8015dec:	b087      	sub	sp, #28
 8015dee:	af00      	add	r7, sp, #0
 8015df0:	6078      	str	r0, [r7, #4]
 8015df2:	6039      	str	r1, [r7, #0]
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;
 8015df4:	687b      	ldr	r3, [r7, #4]
 8015df6:	681b      	ldr	r3, [r3, #0]
 8015df8:	60fb      	str	r3, [r7, #12]


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8015dfa:	687b      	ldr	r3, [r7, #4]
 8015dfc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8015dfe:	3304      	adds	r3, #4
 8015e00:	613b      	str	r3, [r7, #16]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8015e02:	683b      	ldr	r3, [r7, #0]
 8015e04:	0a5b      	lsrs	r3, r3, #9
 8015e06:	68fa      	ldr	r2, [r7, #12]
 8015e08:	8952      	ldrh	r2, [r2, #10]
 8015e0a:	fbb3 f3f2 	udiv	r3, r3, r2
 8015e0e:	617b      	str	r3, [r7, #20]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8015e10:	693b      	ldr	r3, [r7, #16]
 8015e12:	1d1a      	adds	r2, r3, #4
 8015e14:	613a      	str	r2, [r7, #16]
 8015e16:	681b      	ldr	r3, [r3, #0]
 8015e18:	60bb      	str	r3, [r7, #8]
		if (ncl == 0) return 0;	/* End of table? (error) */
 8015e1a:	68bb      	ldr	r3, [r7, #8]
 8015e1c:	2b00      	cmp	r3, #0
 8015e1e:	d101      	bne.n	8015e24 <clmt_clust+0x3a>
 8015e20:	2300      	movs	r3, #0
 8015e22:	e010      	b.n	8015e46 <clmt_clust+0x5c>
		if (cl < ncl) break;	/* In this fragment? */
 8015e24:	697a      	ldr	r2, [r7, #20]
 8015e26:	68bb      	ldr	r3, [r7, #8]
 8015e28:	429a      	cmp	r2, r3
 8015e2a:	d307      	bcc.n	8015e3c <clmt_clust+0x52>
		cl -= ncl; tbl++;		/* Next fragment */
 8015e2c:	697a      	ldr	r2, [r7, #20]
 8015e2e:	68bb      	ldr	r3, [r7, #8]
 8015e30:	1ad3      	subs	r3, r2, r3
 8015e32:	617b      	str	r3, [r7, #20]
 8015e34:	693b      	ldr	r3, [r7, #16]
 8015e36:	3304      	adds	r3, #4
 8015e38:	613b      	str	r3, [r7, #16]
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8015e3a:	e7e9      	b.n	8015e10 <clmt_clust+0x26>
		if (cl < ncl) break;	/* In this fragment? */
 8015e3c:	bf00      	nop
	}
	return cl + *tbl;	/* Return the cluster number */
 8015e3e:	693b      	ldr	r3, [r7, #16]
 8015e40:	681a      	ldr	r2, [r3, #0]
 8015e42:	697b      	ldr	r3, [r7, #20]
 8015e44:	4413      	add	r3, r2
}
 8015e46:	4618      	mov	r0, r3
 8015e48:	371c      	adds	r7, #28
 8015e4a:	46bd      	mov	sp, r7
 8015e4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015e50:	4770      	bx	lr

08015e52 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
 8015e52:	b580      	push	{r7, lr}
 8015e54:	b086      	sub	sp, #24
 8015e56:	af00      	add	r7, sp, #0
 8015e58:	6078      	str	r0, [r7, #4]
 8015e5a:	6039      	str	r1, [r7, #0]
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
 8015e5c:	687b      	ldr	r3, [r7, #4]
 8015e5e:	681b      	ldr	r3, [r3, #0]
 8015e60:	613b      	str	r3, [r7, #16]


	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
 8015e62:	683b      	ldr	r3, [r7, #0]
 8015e64:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8015e68:	d204      	bcs.n	8015e74 <dir_sdi+0x22>
 8015e6a:	683b      	ldr	r3, [r7, #0]
 8015e6c:	f003 031f 	and.w	r3, r3, #31
 8015e70:	2b00      	cmp	r3, #0
 8015e72:	d001      	beq.n	8015e78 <dir_sdi+0x26>
		return FR_INT_ERR;
 8015e74:	2302      	movs	r3, #2
 8015e76:	e063      	b.n	8015f40 <dir_sdi+0xee>
	}
	dp->dptr = ofs;				/* Set current offset */
 8015e78:	687b      	ldr	r3, [r7, #4]
 8015e7a:	683a      	ldr	r2, [r7, #0]
 8015e7c:	615a      	str	r2, [r3, #20]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8015e7e:	687b      	ldr	r3, [r7, #4]
 8015e80:	689b      	ldr	r3, [r3, #8]
 8015e82:	617b      	str	r3, [r7, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 8015e84:	697b      	ldr	r3, [r7, #20]
 8015e86:	2b00      	cmp	r3, #0
 8015e88:	d106      	bne.n	8015e98 <dir_sdi+0x46>
 8015e8a:	693b      	ldr	r3, [r7, #16]
 8015e8c:	781b      	ldrb	r3, [r3, #0]
 8015e8e:	2b02      	cmp	r3, #2
 8015e90:	d902      	bls.n	8015e98 <dir_sdi+0x46>
		clst = fs->dirbase;
 8015e92:	693b      	ldr	r3, [r7, #16]
 8015e94:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8015e96:	617b      	str	r3, [r7, #20]
		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8015e98:	697b      	ldr	r3, [r7, #20]
 8015e9a:	2b00      	cmp	r3, #0
 8015e9c:	d10c      	bne.n	8015eb8 <dir_sdi+0x66>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 8015e9e:	683b      	ldr	r3, [r7, #0]
 8015ea0:	095b      	lsrs	r3, r3, #5
 8015ea2:	693a      	ldr	r2, [r7, #16]
 8015ea4:	8912      	ldrh	r2, [r2, #8]
 8015ea6:	4293      	cmp	r3, r2
 8015ea8:	d301      	bcc.n	8015eae <dir_sdi+0x5c>
 8015eaa:	2302      	movs	r3, #2
 8015eac:	e048      	b.n	8015f40 <dir_sdi+0xee>
		dp->sect = fs->dirbase;
 8015eae:	693b      	ldr	r3, [r7, #16]
 8015eb0:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8015eb2:	687b      	ldr	r3, [r7, #4]
 8015eb4:	61da      	str	r2, [r3, #28]
 8015eb6:	e029      	b.n	8015f0c <dir_sdi+0xba>

	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 8015eb8:	693b      	ldr	r3, [r7, #16]
 8015eba:	895b      	ldrh	r3, [r3, #10]
 8015ebc:	025b      	lsls	r3, r3, #9
 8015ebe:	60fb      	str	r3, [r7, #12]
		while (ofs >= csz) {				/* Follow cluster chain */
 8015ec0:	e019      	b.n	8015ef6 <dir_sdi+0xa4>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 8015ec2:	687b      	ldr	r3, [r7, #4]
 8015ec4:	6979      	ldr	r1, [r7, #20]
 8015ec6:	4618      	mov	r0, r3
 8015ec8:	f7ff fd01 	bl	80158ce <get_fat>
 8015ecc:	6178      	str	r0, [r7, #20]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8015ece:	697b      	ldr	r3, [r7, #20]
 8015ed0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015ed4:	d101      	bne.n	8015eda <dir_sdi+0x88>
 8015ed6:	2301      	movs	r3, #1
 8015ed8:	e032      	b.n	8015f40 <dir_sdi+0xee>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 8015eda:	697b      	ldr	r3, [r7, #20]
 8015edc:	2b01      	cmp	r3, #1
 8015ede:	d904      	bls.n	8015eea <dir_sdi+0x98>
 8015ee0:	693b      	ldr	r3, [r7, #16]
 8015ee2:	699b      	ldr	r3, [r3, #24]
 8015ee4:	697a      	ldr	r2, [r7, #20]
 8015ee6:	429a      	cmp	r2, r3
 8015ee8:	d301      	bcc.n	8015eee <dir_sdi+0x9c>
 8015eea:	2302      	movs	r3, #2
 8015eec:	e028      	b.n	8015f40 <dir_sdi+0xee>
			ofs -= csz;
 8015eee:	683a      	ldr	r2, [r7, #0]
 8015ef0:	68fb      	ldr	r3, [r7, #12]
 8015ef2:	1ad3      	subs	r3, r2, r3
 8015ef4:	603b      	str	r3, [r7, #0]
		while (ofs >= csz) {				/* Follow cluster chain */
 8015ef6:	683a      	ldr	r2, [r7, #0]
 8015ef8:	68fb      	ldr	r3, [r7, #12]
 8015efa:	429a      	cmp	r2, r3
 8015efc:	d2e1      	bcs.n	8015ec2 <dir_sdi+0x70>
		}
		dp->sect = clust2sect(fs, clst);
 8015efe:	6979      	ldr	r1, [r7, #20]
 8015f00:	6938      	ldr	r0, [r7, #16]
 8015f02:	f7ff fcc5 	bl	8015890 <clust2sect>
 8015f06:	4602      	mov	r2, r0
 8015f08:	687b      	ldr	r3, [r7, #4]
 8015f0a:	61da      	str	r2, [r3, #28]
	}
	dp->clust = clst;					/* Current cluster# */
 8015f0c:	687b      	ldr	r3, [r7, #4]
 8015f0e:	697a      	ldr	r2, [r7, #20]
 8015f10:	619a      	str	r2, [r3, #24]
	if (!dp->sect) return FR_INT_ERR;
 8015f12:	687b      	ldr	r3, [r7, #4]
 8015f14:	69db      	ldr	r3, [r3, #28]
 8015f16:	2b00      	cmp	r3, #0
 8015f18:	d101      	bne.n	8015f1e <dir_sdi+0xcc>
 8015f1a:	2302      	movs	r3, #2
 8015f1c:	e010      	b.n	8015f40 <dir_sdi+0xee>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
 8015f1e:	687b      	ldr	r3, [r7, #4]
 8015f20:	69da      	ldr	r2, [r3, #28]
 8015f22:	683b      	ldr	r3, [r7, #0]
 8015f24:	0a5b      	lsrs	r3, r3, #9
 8015f26:	441a      	add	r2, r3
 8015f28:	687b      	ldr	r3, [r7, #4]
 8015f2a:	61da      	str	r2, [r3, #28]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 8015f2c:	693b      	ldr	r3, [r7, #16]
 8015f2e:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8015f32:	683b      	ldr	r3, [r7, #0]
 8015f34:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8015f38:	441a      	add	r2, r3
 8015f3a:	687b      	ldr	r3, [r7, #4]
 8015f3c:	621a      	str	r2, [r3, #32]

	return FR_OK;
 8015f3e:	2300      	movs	r3, #0
}
 8015f40:	4618      	mov	r0, r3
 8015f42:	3718      	adds	r7, #24
 8015f44:	46bd      	mov	sp, r7
 8015f46:	bd80      	pop	{r7, pc}

08015f48 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
 8015f48:	b580      	push	{r7, lr}
 8015f4a:	b086      	sub	sp, #24
 8015f4c:	af00      	add	r7, sp, #0
 8015f4e:	6078      	str	r0, [r7, #4]
 8015f50:	6039      	str	r1, [r7, #0]
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
 8015f52:	687b      	ldr	r3, [r7, #4]
 8015f54:	681b      	ldr	r3, [r3, #0]
 8015f56:	60fb      	str	r3, [r7, #12]
#if !_FS_READONLY
	UINT n;
#endif

	ofs = dp->dptr + SZDIRE;	/* Next entry */
 8015f58:	687b      	ldr	r3, [r7, #4]
 8015f5a:	695b      	ldr	r3, [r3, #20]
 8015f5c:	3320      	adds	r3, #32
 8015f5e:	60bb      	str	r3, [r7, #8]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 8015f60:	687b      	ldr	r3, [r7, #4]
 8015f62:	69db      	ldr	r3, [r3, #28]
 8015f64:	2b00      	cmp	r3, #0
 8015f66:	d003      	beq.n	8015f70 <dir_next+0x28>
 8015f68:	68bb      	ldr	r3, [r7, #8]
 8015f6a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8015f6e:	d301      	bcc.n	8015f74 <dir_next+0x2c>
 8015f70:	2304      	movs	r3, #4
 8015f72:	e0aa      	b.n	80160ca <dir_next+0x182>

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8015f74:	68bb      	ldr	r3, [r7, #8]
 8015f76:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8015f7a:	2b00      	cmp	r3, #0
 8015f7c:	f040 8098 	bne.w	80160b0 <dir_next+0x168>
		dp->sect++;				/* Next sector */
 8015f80:	687b      	ldr	r3, [r7, #4]
 8015f82:	69db      	ldr	r3, [r3, #28]
 8015f84:	1c5a      	adds	r2, r3, #1
 8015f86:	687b      	ldr	r3, [r7, #4]
 8015f88:	61da      	str	r2, [r3, #28]

		if (!dp->clust) {		/* Static table */
 8015f8a:	687b      	ldr	r3, [r7, #4]
 8015f8c:	699b      	ldr	r3, [r3, #24]
 8015f8e:	2b00      	cmp	r3, #0
 8015f90:	d10b      	bne.n	8015faa <dir_next+0x62>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8015f92:	68bb      	ldr	r3, [r7, #8]
 8015f94:	095b      	lsrs	r3, r3, #5
 8015f96:	68fa      	ldr	r2, [r7, #12]
 8015f98:	8912      	ldrh	r2, [r2, #8]
 8015f9a:	4293      	cmp	r3, r2
 8015f9c:	f0c0 8088 	bcc.w	80160b0 <dir_next+0x168>
				dp->sect = 0; return FR_NO_FILE;
 8015fa0:	687b      	ldr	r3, [r7, #4]
 8015fa2:	2200      	movs	r2, #0
 8015fa4:	61da      	str	r2, [r3, #28]
 8015fa6:	2304      	movs	r3, #4
 8015fa8:	e08f      	b.n	80160ca <dir_next+0x182>
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8015faa:	68bb      	ldr	r3, [r7, #8]
 8015fac:	0a5b      	lsrs	r3, r3, #9
 8015fae:	68fa      	ldr	r2, [r7, #12]
 8015fb0:	8952      	ldrh	r2, [r2, #10]
 8015fb2:	3a01      	subs	r2, #1
 8015fb4:	4013      	ands	r3, r2
 8015fb6:	2b00      	cmp	r3, #0
 8015fb8:	d17a      	bne.n	80160b0 <dir_next+0x168>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8015fba:	687a      	ldr	r2, [r7, #4]
 8015fbc:	687b      	ldr	r3, [r7, #4]
 8015fbe:	699b      	ldr	r3, [r3, #24]
 8015fc0:	4619      	mov	r1, r3
 8015fc2:	4610      	mov	r0, r2
 8015fc4:	f7ff fc83 	bl	80158ce <get_fat>
 8015fc8:	6178      	str	r0, [r7, #20]
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8015fca:	697b      	ldr	r3, [r7, #20]
 8015fcc:	2b01      	cmp	r3, #1
 8015fce:	d801      	bhi.n	8015fd4 <dir_next+0x8c>
 8015fd0:	2302      	movs	r3, #2
 8015fd2:	e07a      	b.n	80160ca <dir_next+0x182>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8015fd4:	697b      	ldr	r3, [r7, #20]
 8015fd6:	f1b3 3fff 	cmp.w	r3, #4294967295
 8015fda:	d101      	bne.n	8015fe0 <dir_next+0x98>
 8015fdc:	2301      	movs	r3, #1
 8015fde:	e074      	b.n	80160ca <dir_next+0x182>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 8015fe0:	68fb      	ldr	r3, [r7, #12]
 8015fe2:	699b      	ldr	r3, [r3, #24]
 8015fe4:	697a      	ldr	r2, [r7, #20]
 8015fe6:	429a      	cmp	r2, r3
 8015fe8:	d358      	bcc.n	801609c <dir_next+0x154>
#if !_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
 8015fea:	683b      	ldr	r3, [r7, #0]
 8015fec:	2b00      	cmp	r3, #0
 8015fee:	d104      	bne.n	8015ffa <dir_next+0xb2>
						dp->sect = 0; return FR_NO_FILE;
 8015ff0:	687b      	ldr	r3, [r7, #4]
 8015ff2:	2200      	movs	r2, #0
 8015ff4:	61da      	str	r2, [r3, #28]
 8015ff6:	2304      	movs	r3, #4
 8015ff8:	e067      	b.n	80160ca <dir_next+0x182>
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 8015ffa:	687a      	ldr	r2, [r7, #4]
 8015ffc:	687b      	ldr	r3, [r7, #4]
 8015ffe:	699b      	ldr	r3, [r3, #24]
 8016000:	4619      	mov	r1, r3
 8016002:	4610      	mov	r0, r2
 8016004:	f7ff fe59 	bl	8015cba <create_chain>
 8016008:	6178      	str	r0, [r7, #20]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 801600a:	697b      	ldr	r3, [r7, #20]
 801600c:	2b00      	cmp	r3, #0
 801600e:	d101      	bne.n	8016014 <dir_next+0xcc>
 8016010:	2307      	movs	r3, #7
 8016012:	e05a      	b.n	80160ca <dir_next+0x182>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 8016014:	697b      	ldr	r3, [r7, #20]
 8016016:	2b01      	cmp	r3, #1
 8016018:	d101      	bne.n	801601e <dir_next+0xd6>
 801601a:	2302      	movs	r3, #2
 801601c:	e055      	b.n	80160ca <dir_next+0x182>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 801601e:	697b      	ldr	r3, [r7, #20]
 8016020:	f1b3 3fff 	cmp.w	r3, #4294967295
 8016024:	d101      	bne.n	801602a <dir_next+0xe2>
 8016026:	2301      	movs	r3, #1
 8016028:	e04f      	b.n	80160ca <dir_next+0x182>
					/* Clean-up the stretched table */
					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 801602a:	68f8      	ldr	r0, [r7, #12]
 801602c:	f7ff fb50 	bl	80156d0 <sync_window>
 8016030:	4603      	mov	r3, r0
 8016032:	2b00      	cmp	r3, #0
 8016034:	d001      	beq.n	801603a <dir_next+0xf2>
 8016036:	2301      	movs	r3, #1
 8016038:	e047      	b.n	80160ca <dir_next+0x182>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 801603a:	68fb      	ldr	r3, [r7, #12]
 801603c:	3334      	adds	r3, #52	@ 0x34
 801603e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8016042:	2100      	movs	r1, #0
 8016044:	4618      	mov	r0, r3
 8016046:	f7ff f97a 	bl	801533e <mem_set>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 801604a:	2300      	movs	r3, #0
 801604c:	613b      	str	r3, [r7, #16]
 801604e:	6979      	ldr	r1, [r7, #20]
 8016050:	68f8      	ldr	r0, [r7, #12]
 8016052:	f7ff fc1d 	bl	8015890 <clust2sect>
 8016056:	4602      	mov	r2, r0
 8016058:	68fb      	ldr	r3, [r7, #12]
 801605a:	631a      	str	r2, [r3, #48]	@ 0x30
 801605c:	e012      	b.n	8016084 <dir_next+0x13c>
						fs->wflag = 1;
 801605e:	68fb      	ldr	r3, [r7, #12]
 8016060:	2201      	movs	r2, #1
 8016062:	70da      	strb	r2, [r3, #3]
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 8016064:	68f8      	ldr	r0, [r7, #12]
 8016066:	f7ff fb33 	bl	80156d0 <sync_window>
 801606a:	4603      	mov	r3, r0
 801606c:	2b00      	cmp	r3, #0
 801606e:	d001      	beq.n	8016074 <dir_next+0x12c>
 8016070:	2301      	movs	r3, #1
 8016072:	e02a      	b.n	80160ca <dir_next+0x182>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8016074:	693b      	ldr	r3, [r7, #16]
 8016076:	3301      	adds	r3, #1
 8016078:	613b      	str	r3, [r7, #16]
 801607a:	68fb      	ldr	r3, [r7, #12]
 801607c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801607e:	1c5a      	adds	r2, r3, #1
 8016080:	68fb      	ldr	r3, [r7, #12]
 8016082:	631a      	str	r2, [r3, #48]	@ 0x30
 8016084:	68fb      	ldr	r3, [r7, #12]
 8016086:	895b      	ldrh	r3, [r3, #10]
 8016088:	461a      	mov	r2, r3
 801608a:	693b      	ldr	r3, [r7, #16]
 801608c:	4293      	cmp	r3, r2
 801608e:	d3e6      	bcc.n	801605e <dir_next+0x116>
					}
					fs->winsect -= n;							/* Restore window offset */
 8016090:	68fb      	ldr	r3, [r7, #12]
 8016092:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8016094:	693b      	ldr	r3, [r7, #16]
 8016096:	1ad2      	subs	r2, r2, r3
 8016098:	68fb      	ldr	r3, [r7, #12]
 801609a:	631a      	str	r2, [r3, #48]	@ 0x30
#else
					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
 801609c:	687b      	ldr	r3, [r7, #4]
 801609e:	697a      	ldr	r2, [r7, #20]
 80160a0:	619a      	str	r2, [r3, #24]
				dp->sect = clust2sect(fs, clst);
 80160a2:	6979      	ldr	r1, [r7, #20]
 80160a4:	68f8      	ldr	r0, [r7, #12]
 80160a6:	f7ff fbf3 	bl	8015890 <clust2sect>
 80160aa:	4602      	mov	r2, r0
 80160ac:	687b      	ldr	r3, [r7, #4]
 80160ae:	61da      	str	r2, [r3, #28]
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
 80160b0:	687b      	ldr	r3, [r7, #4]
 80160b2:	68ba      	ldr	r2, [r7, #8]
 80160b4:	615a      	str	r2, [r3, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80160b6:	68fb      	ldr	r3, [r7, #12]
 80160b8:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 80160bc:	68bb      	ldr	r3, [r7, #8]
 80160be:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80160c2:	441a      	add	r2, r3
 80160c4:	687b      	ldr	r3, [r7, #4]
 80160c6:	621a      	str	r2, [r3, #32]

	return FR_OK;
 80160c8:	2300      	movs	r3, #0
}
 80160ca:	4618      	mov	r0, r3
 80160cc:	3718      	adds	r7, #24
 80160ce:	46bd      	mov	sp, r7
 80160d0:	bd80      	pop	{r7, pc}

080160d2 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate */
)
{
 80160d2:	b580      	push	{r7, lr}
 80160d4:	b086      	sub	sp, #24
 80160d6:	af00      	add	r7, sp, #0
 80160d8:	6078      	str	r0, [r7, #4]
 80160da:	6039      	str	r1, [r7, #0]
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;
 80160dc:	687b      	ldr	r3, [r7, #4]
 80160de:	681b      	ldr	r3, [r3, #0]
 80160e0:	60fb      	str	r3, [r7, #12]


	res = dir_sdi(dp, 0);
 80160e2:	2100      	movs	r1, #0
 80160e4:	6878      	ldr	r0, [r7, #4]
 80160e6:	f7ff feb4 	bl	8015e52 <dir_sdi>
 80160ea:	4603      	mov	r3, r0
 80160ec:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 80160ee:	7dfb      	ldrb	r3, [r7, #23]
 80160f0:	2b00      	cmp	r3, #0
 80160f2:	d12b      	bne.n	801614c <dir_alloc+0x7a>
		n = 0;
 80160f4:	2300      	movs	r3, #0
 80160f6:	613b      	str	r3, [r7, #16]
		do {
			res = move_window(fs, dp->sect);
 80160f8:	687b      	ldr	r3, [r7, #4]
 80160fa:	69db      	ldr	r3, [r3, #28]
 80160fc:	4619      	mov	r1, r3
 80160fe:	68f8      	ldr	r0, [r7, #12]
 8016100:	f7ff fb2a 	bl	8015758 <move_window>
 8016104:	4603      	mov	r3, r0
 8016106:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 8016108:	7dfb      	ldrb	r3, [r7, #23]
 801610a:	2b00      	cmp	r3, #0
 801610c:	d11d      	bne.n	801614a <dir_alloc+0x78>
#if _FS_EXFAT
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 801610e:	687b      	ldr	r3, [r7, #4]
 8016110:	6a1b      	ldr	r3, [r3, #32]
 8016112:	781b      	ldrb	r3, [r3, #0]
 8016114:	2be5      	cmp	r3, #229	@ 0xe5
 8016116:	d004      	beq.n	8016122 <dir_alloc+0x50>
 8016118:	687b      	ldr	r3, [r7, #4]
 801611a:	6a1b      	ldr	r3, [r3, #32]
 801611c:	781b      	ldrb	r3, [r3, #0]
 801611e:	2b00      	cmp	r3, #0
 8016120:	d107      	bne.n	8016132 <dir_alloc+0x60>
#endif
				if (++n == nent) break;	/* A block of contiguous free entries is found */
 8016122:	693b      	ldr	r3, [r7, #16]
 8016124:	3301      	adds	r3, #1
 8016126:	613b      	str	r3, [r7, #16]
 8016128:	693a      	ldr	r2, [r7, #16]
 801612a:	683b      	ldr	r3, [r7, #0]
 801612c:	429a      	cmp	r2, r3
 801612e:	d102      	bne.n	8016136 <dir_alloc+0x64>
 8016130:	e00c      	b.n	801614c <dir_alloc+0x7a>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
 8016132:	2300      	movs	r3, #0
 8016134:	613b      	str	r3, [r7, #16]
			}
			res = dir_next(dp, 1);
 8016136:	2101      	movs	r1, #1
 8016138:	6878      	ldr	r0, [r7, #4]
 801613a:	f7ff ff05 	bl	8015f48 <dir_next>
 801613e:	4603      	mov	r3, r0
 8016140:	75fb      	strb	r3, [r7, #23]
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
 8016142:	7dfb      	ldrb	r3, [r7, #23]
 8016144:	2b00      	cmp	r3, #0
 8016146:	d0d7      	beq.n	80160f8 <dir_alloc+0x26>
 8016148:	e000      	b.n	801614c <dir_alloc+0x7a>
			if (res != FR_OK) break;
 801614a:	bf00      	nop
	}

	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 801614c:	7dfb      	ldrb	r3, [r7, #23]
 801614e:	2b04      	cmp	r3, #4
 8016150:	d101      	bne.n	8016156 <dir_alloc+0x84>
 8016152:	2307      	movs	r3, #7
 8016154:	75fb      	strb	r3, [r7, #23]
	return res;
 8016156:	7dfb      	ldrb	r3, [r7, #23]
}
 8016158:	4618      	mov	r0, r3
 801615a:	3718      	adds	r7, #24
 801615c:	46bd      	mov	sp, r7
 801615e:	bd80      	pop	{r7, pc}

08016160 <ld_clust>:
static
DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
	FATFS* fs,		/* Pointer to the fs object */
	const BYTE* dir	/* Pointer to the key entry */
)
{
 8016160:	b580      	push	{r7, lr}
 8016162:	b084      	sub	sp, #16
 8016164:	af00      	add	r7, sp, #0
 8016166:	6078      	str	r0, [r7, #4]
 8016168:	6039      	str	r1, [r7, #0]
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
 801616a:	683b      	ldr	r3, [r7, #0]
 801616c:	331a      	adds	r3, #26
 801616e:	4618      	mov	r0, r3
 8016170:	f7ff f842 	bl	80151f8 <ld_word>
 8016174:	4603      	mov	r3, r0
 8016176:	60fb      	str	r3, [r7, #12]
	if (fs->fs_type == FS_FAT32) {
 8016178:	687b      	ldr	r3, [r7, #4]
 801617a:	781b      	ldrb	r3, [r3, #0]
 801617c:	2b03      	cmp	r3, #3
 801617e:	d109      	bne.n	8016194 <ld_clust+0x34>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 8016180:	683b      	ldr	r3, [r7, #0]
 8016182:	3314      	adds	r3, #20
 8016184:	4618      	mov	r0, r3
 8016186:	f7ff f837 	bl	80151f8 <ld_word>
 801618a:	4603      	mov	r3, r0
 801618c:	041b      	lsls	r3, r3, #16
 801618e:	68fa      	ldr	r2, [r7, #12]
 8016190:	4313      	orrs	r3, r2
 8016192:	60fb      	str	r3, [r7, #12]
	}

	return cl;
 8016194:	68fb      	ldr	r3, [r7, #12]
}
 8016196:	4618      	mov	r0, r3
 8016198:	3710      	adds	r7, #16
 801619a:	46bd      	mov	sp, r7
 801619c:	bd80      	pop	{r7, pc}

0801619e <st_clust>:
void st_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
 801619e:	b580      	push	{r7, lr}
 80161a0:	b084      	sub	sp, #16
 80161a2:	af00      	add	r7, sp, #0
 80161a4:	60f8      	str	r0, [r7, #12]
 80161a6:	60b9      	str	r1, [r7, #8]
 80161a8:	607a      	str	r2, [r7, #4]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
 80161aa:	68bb      	ldr	r3, [r7, #8]
 80161ac:	331a      	adds	r3, #26
 80161ae:	687a      	ldr	r2, [r7, #4]
 80161b0:	b292      	uxth	r2, r2
 80161b2:	4611      	mov	r1, r2
 80161b4:	4618      	mov	r0, r3
 80161b6:	f7ff f85a 	bl	801526e <st_word>
	if (fs->fs_type == FS_FAT32) {
 80161ba:	68fb      	ldr	r3, [r7, #12]
 80161bc:	781b      	ldrb	r3, [r3, #0]
 80161be:	2b03      	cmp	r3, #3
 80161c0:	d109      	bne.n	80161d6 <st_clust+0x38>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 80161c2:	68bb      	ldr	r3, [r7, #8]
 80161c4:	f103 0214 	add.w	r2, r3, #20
 80161c8:	687b      	ldr	r3, [r7, #4]
 80161ca:	0c1b      	lsrs	r3, r3, #16
 80161cc:	b29b      	uxth	r3, r3
 80161ce:	4619      	mov	r1, r3
 80161d0:	4610      	mov	r0, r2
 80161d2:	f7ff f84c 	bl	801526e <st_word>
	}
}
 80161d6:	bf00      	nop
 80161d8:	3710      	adds	r7, #16
 80161da:	46bd      	mov	sp, r7
 80161dc:	bd80      	pop	{r7, pc}
	...

080161e0 <cmp_lfn>:
static
int cmp_lfn (				/* 1:matched, 0:not matched */
	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
)
{
 80161e0:	b590      	push	{r4, r7, lr}
 80161e2:	b087      	sub	sp, #28
 80161e4:	af00      	add	r7, sp, #0
 80161e6:	6078      	str	r0, [r7, #4]
 80161e8:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
 80161ea:	683b      	ldr	r3, [r7, #0]
 80161ec:	331a      	adds	r3, #26
 80161ee:	4618      	mov	r0, r3
 80161f0:	f7ff f802 	bl	80151f8 <ld_word>
 80161f4:	4603      	mov	r3, r0
 80161f6:	2b00      	cmp	r3, #0
 80161f8:	d001      	beq.n	80161fe <cmp_lfn+0x1e>
 80161fa:	2300      	movs	r3, #0
 80161fc:	e059      	b.n	80162b2 <cmp_lfn+0xd2>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
 80161fe:	683b      	ldr	r3, [r7, #0]
 8016200:	781b      	ldrb	r3, [r3, #0]
 8016202:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8016206:	1e5a      	subs	r2, r3, #1
 8016208:	4613      	mov	r3, r2
 801620a:	005b      	lsls	r3, r3, #1
 801620c:	4413      	add	r3, r2
 801620e:	009b      	lsls	r3, r3, #2
 8016210:	4413      	add	r3, r2
 8016212:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8016214:	2301      	movs	r3, #1
 8016216:	81fb      	strh	r3, [r7, #14]
 8016218:	2300      	movs	r3, #0
 801621a:	613b      	str	r3, [r7, #16]
 801621c:	e033      	b.n	8016286 <cmp_lfn+0xa6>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 801621e:	4a27      	ldr	r2, [pc, #156]	@ (80162bc <cmp_lfn+0xdc>)
 8016220:	693b      	ldr	r3, [r7, #16]
 8016222:	4413      	add	r3, r2
 8016224:	781b      	ldrb	r3, [r3, #0]
 8016226:	461a      	mov	r2, r3
 8016228:	683b      	ldr	r3, [r7, #0]
 801622a:	4413      	add	r3, r2
 801622c:	4618      	mov	r0, r3
 801622e:	f7fe ffe3 	bl	80151f8 <ld_word>
 8016232:	4603      	mov	r3, r0
 8016234:	81bb      	strh	r3, [r7, #12]
		if (wc) {
 8016236:	89fb      	ldrh	r3, [r7, #14]
 8016238:	2b00      	cmp	r3, #0
 801623a:	d01a      	beq.n	8016272 <cmp_lfn+0x92>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 801623c:	697b      	ldr	r3, [r7, #20]
 801623e:	2bfe      	cmp	r3, #254	@ 0xfe
 8016240:	d812      	bhi.n	8016268 <cmp_lfn+0x88>
 8016242:	89bb      	ldrh	r3, [r7, #12]
 8016244:	4618      	mov	r0, r3
 8016246:	f002 fe9d 	bl	8018f84 <ff_wtoupper>
 801624a:	4603      	mov	r3, r0
 801624c:	461c      	mov	r4, r3
 801624e:	697b      	ldr	r3, [r7, #20]
 8016250:	1c5a      	adds	r2, r3, #1
 8016252:	617a      	str	r2, [r7, #20]
 8016254:	005b      	lsls	r3, r3, #1
 8016256:	687a      	ldr	r2, [r7, #4]
 8016258:	4413      	add	r3, r2
 801625a:	881b      	ldrh	r3, [r3, #0]
 801625c:	4618      	mov	r0, r3
 801625e:	f002 fe91 	bl	8018f84 <ff_wtoupper>
 8016262:	4603      	mov	r3, r0
 8016264:	429c      	cmp	r4, r3
 8016266:	d001      	beq.n	801626c <cmp_lfn+0x8c>
				return 0;					/* Not matched */
 8016268:	2300      	movs	r3, #0
 801626a:	e022      	b.n	80162b2 <cmp_lfn+0xd2>
			}
			wc = uc;
 801626c:	89bb      	ldrh	r3, [r7, #12]
 801626e:	81fb      	strh	r3, [r7, #14]
 8016270:	e006      	b.n	8016280 <cmp_lfn+0xa0>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 8016272:	89bb      	ldrh	r3, [r7, #12]
 8016274:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8016278:	4293      	cmp	r3, r2
 801627a:	d001      	beq.n	8016280 <cmp_lfn+0xa0>
 801627c:	2300      	movs	r3, #0
 801627e:	e018      	b.n	80162b2 <cmp_lfn+0xd2>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 8016280:	693b      	ldr	r3, [r7, #16]
 8016282:	3301      	adds	r3, #1
 8016284:	613b      	str	r3, [r7, #16]
 8016286:	693b      	ldr	r3, [r7, #16]
 8016288:	2b0c      	cmp	r3, #12
 801628a:	d9c8      	bls.n	801621e <cmp_lfn+0x3e>
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
 801628c:	683b      	ldr	r3, [r7, #0]
 801628e:	781b      	ldrb	r3, [r3, #0]
 8016290:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8016294:	2b00      	cmp	r3, #0
 8016296:	d00b      	beq.n	80162b0 <cmp_lfn+0xd0>
 8016298:	89fb      	ldrh	r3, [r7, #14]
 801629a:	2b00      	cmp	r3, #0
 801629c:	d008      	beq.n	80162b0 <cmp_lfn+0xd0>
 801629e:	697b      	ldr	r3, [r7, #20]
 80162a0:	005b      	lsls	r3, r3, #1
 80162a2:	687a      	ldr	r2, [r7, #4]
 80162a4:	4413      	add	r3, r2
 80162a6:	881b      	ldrh	r3, [r3, #0]
 80162a8:	2b00      	cmp	r3, #0
 80162aa:	d001      	beq.n	80162b0 <cmp_lfn+0xd0>
 80162ac:	2300      	movs	r3, #0
 80162ae:	e000      	b.n	80162b2 <cmp_lfn+0xd2>

	return 1;		/* The part of LFN matched */
 80162b0:	2301      	movs	r3, #1
}
 80162b2:	4618      	mov	r0, r3
 80162b4:	371c      	adds	r7, #28
 80162b6:	46bd      	mov	sp, r7
 80162b8:	bd90      	pop	{r4, r7, pc}
 80162ba:	bf00      	nop
 80162bc:	0803515c 	.word	0x0803515c

080162c0 <pick_lfn>:
static
int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
	BYTE* dir			/* Pointer to the LFN entry */
)
{
 80162c0:	b580      	push	{r7, lr}
 80162c2:	b086      	sub	sp, #24
 80162c4:	af00      	add	r7, sp, #0
 80162c6:	6078      	str	r0, [r7, #4]
 80162c8:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO is 0 */
 80162ca:	683b      	ldr	r3, [r7, #0]
 80162cc:	331a      	adds	r3, #26
 80162ce:	4618      	mov	r0, r3
 80162d0:	f7fe ff92 	bl	80151f8 <ld_word>
 80162d4:	4603      	mov	r3, r0
 80162d6:	2b00      	cmp	r3, #0
 80162d8:	d001      	beq.n	80162de <pick_lfn+0x1e>
 80162da:	2300      	movs	r3, #0
 80162dc:	e04d      	b.n	801637a <pick_lfn+0xba>

	i = ((dir[LDIR_Ord] & ~LLEF) - 1) * 13;	/* Offset in the LFN buffer */
 80162de:	683b      	ldr	r3, [r7, #0]
 80162e0:	781b      	ldrb	r3, [r3, #0]
 80162e2:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80162e6:	1e5a      	subs	r2, r3, #1
 80162e8:	4613      	mov	r3, r2
 80162ea:	005b      	lsls	r3, r3, #1
 80162ec:	4413      	add	r3, r2
 80162ee:	009b      	lsls	r3, r3, #2
 80162f0:	4413      	add	r3, r2
 80162f2:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 80162f4:	2301      	movs	r3, #1
 80162f6:	81fb      	strh	r3, [r7, #14]
 80162f8:	2300      	movs	r3, #0
 80162fa:	613b      	str	r3, [r7, #16]
 80162fc:	e028      	b.n	8016350 <pick_lfn+0x90>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 80162fe:	4a21      	ldr	r2, [pc, #132]	@ (8016384 <pick_lfn+0xc4>)
 8016300:	693b      	ldr	r3, [r7, #16]
 8016302:	4413      	add	r3, r2
 8016304:	781b      	ldrb	r3, [r3, #0]
 8016306:	461a      	mov	r2, r3
 8016308:	683b      	ldr	r3, [r7, #0]
 801630a:	4413      	add	r3, r2
 801630c:	4618      	mov	r0, r3
 801630e:	f7fe ff73 	bl	80151f8 <ld_word>
 8016312:	4603      	mov	r3, r0
 8016314:	81bb      	strh	r3, [r7, #12]
		if (wc) {
 8016316:	89fb      	ldrh	r3, [r7, #14]
 8016318:	2b00      	cmp	r3, #0
 801631a:	d00f      	beq.n	801633c <pick_lfn+0x7c>
			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
 801631c:	697b      	ldr	r3, [r7, #20]
 801631e:	2bfe      	cmp	r3, #254	@ 0xfe
 8016320:	d901      	bls.n	8016326 <pick_lfn+0x66>
 8016322:	2300      	movs	r3, #0
 8016324:	e029      	b.n	801637a <pick_lfn+0xba>
			lfnbuf[i++] = wc = uc;			/* Store it */
 8016326:	89bb      	ldrh	r3, [r7, #12]
 8016328:	81fb      	strh	r3, [r7, #14]
 801632a:	697b      	ldr	r3, [r7, #20]
 801632c:	1c5a      	adds	r2, r3, #1
 801632e:	617a      	str	r2, [r7, #20]
 8016330:	005b      	lsls	r3, r3, #1
 8016332:	687a      	ldr	r2, [r7, #4]
 8016334:	4413      	add	r3, r2
 8016336:	89fa      	ldrh	r2, [r7, #14]
 8016338:	801a      	strh	r2, [r3, #0]
 801633a:	e006      	b.n	801634a <pick_lfn+0x8a>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
 801633c:	89bb      	ldrh	r3, [r7, #12]
 801633e:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8016342:	4293      	cmp	r3, r2
 8016344:	d001      	beq.n	801634a <pick_lfn+0x8a>
 8016346:	2300      	movs	r3, #0
 8016348:	e017      	b.n	801637a <pick_lfn+0xba>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 801634a:	693b      	ldr	r3, [r7, #16]
 801634c:	3301      	adds	r3, #1
 801634e:	613b      	str	r3, [r7, #16]
 8016350:	693b      	ldr	r3, [r7, #16]
 8016352:	2b0c      	cmp	r3, #12
 8016354:	d9d3      	bls.n	80162fe <pick_lfn+0x3e>
		}
	}

	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
 8016356:	683b      	ldr	r3, [r7, #0]
 8016358:	781b      	ldrb	r3, [r3, #0]
 801635a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801635e:	2b00      	cmp	r3, #0
 8016360:	d00a      	beq.n	8016378 <pick_lfn+0xb8>
		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
 8016362:	697b      	ldr	r3, [r7, #20]
 8016364:	2bfe      	cmp	r3, #254	@ 0xfe
 8016366:	d901      	bls.n	801636c <pick_lfn+0xac>
 8016368:	2300      	movs	r3, #0
 801636a:	e006      	b.n	801637a <pick_lfn+0xba>
		lfnbuf[i] = 0;
 801636c:	697b      	ldr	r3, [r7, #20]
 801636e:	005b      	lsls	r3, r3, #1
 8016370:	687a      	ldr	r2, [r7, #4]
 8016372:	4413      	add	r3, r2
 8016374:	2200      	movs	r2, #0
 8016376:	801a      	strh	r2, [r3, #0]
	}

	return 1;		/* The part of LFN is valid */
 8016378:	2301      	movs	r3, #1
}
 801637a:	4618      	mov	r0, r3
 801637c:	3718      	adds	r7, #24
 801637e:	46bd      	mov	sp, r7
 8016380:	bd80      	pop	{r7, pc}
 8016382:	bf00      	nop
 8016384:	0803515c 	.word	0x0803515c

08016388 <put_lfn>:
	const WCHAR* lfn,	/* Pointer to the LFN */
	BYTE* dir,			/* Pointer to the LFN entry to be created */
	BYTE ord,			/* LFN order (1-20) */
	BYTE sum			/* Checksum of the corresponding SFN */
)
{
 8016388:	b580      	push	{r7, lr}
 801638a:	b088      	sub	sp, #32
 801638c:	af00      	add	r7, sp, #0
 801638e:	60f8      	str	r0, [r7, #12]
 8016390:	60b9      	str	r1, [r7, #8]
 8016392:	4611      	mov	r1, r2
 8016394:	461a      	mov	r2, r3
 8016396:	460b      	mov	r3, r1
 8016398:	71fb      	strb	r3, [r7, #7]
 801639a:	4613      	mov	r3, r2
 801639c:	71bb      	strb	r3, [r7, #6]
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set checksum */
 801639e:	68bb      	ldr	r3, [r7, #8]
 80163a0:	330d      	adds	r3, #13
 80163a2:	79ba      	ldrb	r2, [r7, #6]
 80163a4:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
 80163a6:	68bb      	ldr	r3, [r7, #8]
 80163a8:	330b      	adds	r3, #11
 80163aa:	220f      	movs	r2, #15
 80163ac:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Type] = 0;
 80163ae:	68bb      	ldr	r3, [r7, #8]
 80163b0:	330c      	adds	r3, #12
 80163b2:	2200      	movs	r2, #0
 80163b4:	701a      	strb	r2, [r3, #0]
	st_word(dir + LDIR_FstClusLO, 0);
 80163b6:	68bb      	ldr	r3, [r7, #8]
 80163b8:	331a      	adds	r3, #26
 80163ba:	2100      	movs	r1, #0
 80163bc:	4618      	mov	r0, r3
 80163be:	f7fe ff56 	bl	801526e <st_word>

	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
 80163c2:	79fb      	ldrb	r3, [r7, #7]
 80163c4:	1e5a      	subs	r2, r3, #1
 80163c6:	4613      	mov	r3, r2
 80163c8:	005b      	lsls	r3, r3, #1
 80163ca:	4413      	add	r3, r2
 80163cc:	009b      	lsls	r3, r3, #2
 80163ce:	4413      	add	r3, r2
 80163d0:	61fb      	str	r3, [r7, #28]
	s = wc = 0;
 80163d2:	2300      	movs	r3, #0
 80163d4:	82fb      	strh	r3, [r7, #22]
 80163d6:	2300      	movs	r3, #0
 80163d8:	61bb      	str	r3, [r7, #24]
	do {
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
 80163da:	8afb      	ldrh	r3, [r7, #22]
 80163dc:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80163e0:	4293      	cmp	r3, r2
 80163e2:	d007      	beq.n	80163f4 <put_lfn+0x6c>
 80163e4:	69fb      	ldr	r3, [r7, #28]
 80163e6:	1c5a      	adds	r2, r3, #1
 80163e8:	61fa      	str	r2, [r7, #28]
 80163ea:	005b      	lsls	r3, r3, #1
 80163ec:	68fa      	ldr	r2, [r7, #12]
 80163ee:	4413      	add	r3, r2
 80163f0:	881b      	ldrh	r3, [r3, #0]
 80163f2:	82fb      	strh	r3, [r7, #22]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
 80163f4:	4a17      	ldr	r2, [pc, #92]	@ (8016454 <put_lfn+0xcc>)
 80163f6:	69bb      	ldr	r3, [r7, #24]
 80163f8:	4413      	add	r3, r2
 80163fa:	781b      	ldrb	r3, [r3, #0]
 80163fc:	461a      	mov	r2, r3
 80163fe:	68bb      	ldr	r3, [r7, #8]
 8016400:	4413      	add	r3, r2
 8016402:	8afa      	ldrh	r2, [r7, #22]
 8016404:	4611      	mov	r1, r2
 8016406:	4618      	mov	r0, r3
 8016408:	f7fe ff31 	bl	801526e <st_word>
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
 801640c:	8afb      	ldrh	r3, [r7, #22]
 801640e:	2b00      	cmp	r3, #0
 8016410:	d102      	bne.n	8016418 <put_lfn+0x90>
 8016412:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8016416:	82fb      	strh	r3, [r7, #22]
	} while (++s < 13);
 8016418:	69bb      	ldr	r3, [r7, #24]
 801641a:	3301      	adds	r3, #1
 801641c:	61bb      	str	r3, [r7, #24]
 801641e:	69bb      	ldr	r3, [r7, #24]
 8016420:	2b0c      	cmp	r3, #12
 8016422:	d9da      	bls.n	80163da <put_lfn+0x52>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
 8016424:	8afb      	ldrh	r3, [r7, #22]
 8016426:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 801642a:	4293      	cmp	r3, r2
 801642c:	d006      	beq.n	801643c <put_lfn+0xb4>
 801642e:	69fb      	ldr	r3, [r7, #28]
 8016430:	005b      	lsls	r3, r3, #1
 8016432:	68fa      	ldr	r2, [r7, #12]
 8016434:	4413      	add	r3, r2
 8016436:	881b      	ldrh	r3, [r3, #0]
 8016438:	2b00      	cmp	r3, #0
 801643a:	d103      	bne.n	8016444 <put_lfn+0xbc>
 801643c:	79fb      	ldrb	r3, [r7, #7]
 801643e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8016442:	71fb      	strb	r3, [r7, #7]
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
 8016444:	68bb      	ldr	r3, [r7, #8]
 8016446:	79fa      	ldrb	r2, [r7, #7]
 8016448:	701a      	strb	r2, [r3, #0]
}
 801644a:	bf00      	nop
 801644c:	3720      	adds	r7, #32
 801644e:	46bd      	mov	sp, r7
 8016450:	bd80      	pop	{r7, pc}
 8016452:	bf00      	nop
 8016454:	0803515c 	.word	0x0803515c

08016458 <gen_numname>:
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
 8016458:	b580      	push	{r7, lr}
 801645a:	b08c      	sub	sp, #48	@ 0x30
 801645c:	af00      	add	r7, sp, #0
 801645e:	60f8      	str	r0, [r7, #12]
 8016460:	60b9      	str	r1, [r7, #8]
 8016462:	607a      	str	r2, [r7, #4]
 8016464:	603b      	str	r3, [r7, #0]
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
 8016466:	220b      	movs	r2, #11
 8016468:	68b9      	ldr	r1, [r7, #8]
 801646a:	68f8      	ldr	r0, [r7, #12]
 801646c:	f7fe ff46 	bl	80152fc <mem_cpy>

	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 8016470:	683b      	ldr	r3, [r7, #0]
 8016472:	2b05      	cmp	r3, #5
 8016474:	d92b      	bls.n	80164ce <gen_numname+0x76>
		sr = seq;
 8016476:	683b      	ldr	r3, [r7, #0]
 8016478:	61fb      	str	r3, [r7, #28]
		while (*lfn) {	/* Create a CRC */
 801647a:	e022      	b.n	80164c2 <gen_numname+0x6a>
			wc = *lfn++;
 801647c:	687b      	ldr	r3, [r7, #4]
 801647e:	1c9a      	adds	r2, r3, #2
 8016480:	607a      	str	r2, [r7, #4]
 8016482:	881b      	ldrh	r3, [r3, #0]
 8016484:	847b      	strh	r3, [r7, #34]	@ 0x22
			for (i = 0; i < 16; i++) {
 8016486:	2300      	movs	r3, #0
 8016488:	62bb      	str	r3, [r7, #40]	@ 0x28
 801648a:	e017      	b.n	80164bc <gen_numname+0x64>
				sr = (sr << 1) + (wc & 1);
 801648c:	69fb      	ldr	r3, [r7, #28]
 801648e:	005a      	lsls	r2, r3, #1
 8016490:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8016492:	f003 0301 	and.w	r3, r3, #1
 8016496:	4413      	add	r3, r2
 8016498:	61fb      	str	r3, [r7, #28]
				wc >>= 1;
 801649a:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 801649c:	085b      	lsrs	r3, r3, #1
 801649e:	847b      	strh	r3, [r7, #34]	@ 0x22
				if (sr & 0x10000) sr ^= 0x11021;
 80164a0:	69fb      	ldr	r3, [r7, #28]
 80164a2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80164a6:	2b00      	cmp	r3, #0
 80164a8:	d005      	beq.n	80164b6 <gen_numname+0x5e>
 80164aa:	69fb      	ldr	r3, [r7, #28]
 80164ac:	f483 3388 	eor.w	r3, r3, #69632	@ 0x11000
 80164b0:	f083 0321 	eor.w	r3, r3, #33	@ 0x21
 80164b4:	61fb      	str	r3, [r7, #28]
			for (i = 0; i < 16; i++) {
 80164b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80164b8:	3301      	adds	r3, #1
 80164ba:	62bb      	str	r3, [r7, #40]	@ 0x28
 80164bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80164be:	2b0f      	cmp	r3, #15
 80164c0:	d9e4      	bls.n	801648c <gen_numname+0x34>
		while (*lfn) {	/* Create a CRC */
 80164c2:	687b      	ldr	r3, [r7, #4]
 80164c4:	881b      	ldrh	r3, [r3, #0]
 80164c6:	2b00      	cmp	r3, #0
 80164c8:	d1d8      	bne.n	801647c <gen_numname+0x24>
			}
		}
		seq = (UINT)sr;
 80164ca:	69fb      	ldr	r3, [r7, #28]
 80164cc:	603b      	str	r3, [r7, #0]
	}

	/* itoa (hexdecimal) */
	i = 7;
 80164ce:	2307      	movs	r3, #7
 80164d0:	62bb      	str	r3, [r7, #40]	@ 0x28
	do {
		c = (BYTE)((seq % 16) + '0');
 80164d2:	683b      	ldr	r3, [r7, #0]
 80164d4:	b2db      	uxtb	r3, r3
 80164d6:	f003 030f 	and.w	r3, r3, #15
 80164da:	b2db      	uxtb	r3, r3
 80164dc:	3330      	adds	r3, #48	@ 0x30
 80164de:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
		if (c > '9') c += 7;
 80164e2:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 80164e6:	2b39      	cmp	r3, #57	@ 0x39
 80164e8:	d904      	bls.n	80164f4 <gen_numname+0x9c>
 80164ea:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 80164ee:	3307      	adds	r3, #7
 80164f0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
		ns[i--] = c;
 80164f4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80164f6:	1e5a      	subs	r2, r3, #1
 80164f8:	62ba      	str	r2, [r7, #40]	@ 0x28
 80164fa:	3330      	adds	r3, #48	@ 0x30
 80164fc:	443b      	add	r3, r7
 80164fe:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
 8016502:	f803 2c1c 	strb.w	r2, [r3, #-28]
		seq /= 16;
 8016506:	683b      	ldr	r3, [r7, #0]
 8016508:	091b      	lsrs	r3, r3, #4
 801650a:	603b      	str	r3, [r7, #0]
	} while (seq);
 801650c:	683b      	ldr	r3, [r7, #0]
 801650e:	2b00      	cmp	r3, #0
 8016510:	d1df      	bne.n	80164d2 <gen_numname+0x7a>
	ns[i] = '~';
 8016512:	f107 0214 	add.w	r2, r7, #20
 8016516:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016518:	4413      	add	r3, r2
 801651a:	227e      	movs	r2, #126	@ 0x7e
 801651c:	701a      	strb	r2, [r3, #0]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
 801651e:	2300      	movs	r3, #0
 8016520:	627b      	str	r3, [r7, #36]	@ 0x24
 8016522:	e002      	b.n	801652a <gen_numname+0xd2>
 8016524:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016526:	3301      	adds	r3, #1
 8016528:	627b      	str	r3, [r7, #36]	@ 0x24
 801652a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 801652c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801652e:	429a      	cmp	r2, r3
 8016530:	d205      	bcs.n	801653e <gen_numname+0xe6>
 8016532:	68fa      	ldr	r2, [r7, #12]
 8016534:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016536:	4413      	add	r3, r2
 8016538:	781b      	ldrb	r3, [r3, #0]
 801653a:	2b20      	cmp	r3, #32
 801653c:	d1f2      	bne.n	8016524 <gen_numname+0xcc>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
 801653e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016540:	2b07      	cmp	r3, #7
 8016542:	d807      	bhi.n	8016554 <gen_numname+0xfc>
 8016544:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016546:	1c5a      	adds	r2, r3, #1
 8016548:	62ba      	str	r2, [r7, #40]	@ 0x28
 801654a:	3330      	adds	r3, #48	@ 0x30
 801654c:	443b      	add	r3, r7
 801654e:	f813 1c1c 	ldrb.w	r1, [r3, #-28]
 8016552:	e000      	b.n	8016556 <gen_numname+0xfe>
 8016554:	2120      	movs	r1, #32
 8016556:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016558:	1c5a      	adds	r2, r3, #1
 801655a:	627a      	str	r2, [r7, #36]	@ 0x24
 801655c:	68fa      	ldr	r2, [r7, #12]
 801655e:	4413      	add	r3, r2
 8016560:	460a      	mov	r2, r1
 8016562:	701a      	strb	r2, [r3, #0]
	} while (j < 8);
 8016564:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8016566:	2b07      	cmp	r3, #7
 8016568:	d9e9      	bls.n	801653e <gen_numname+0xe6>
}
 801656a:	bf00      	nop
 801656c:	bf00      	nop
 801656e:	3730      	adds	r7, #48	@ 0x30
 8016570:	46bd      	mov	sp, r7
 8016572:	bd80      	pop	{r7, pc}

08016574 <sum_sfn>:

static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
 8016574:	b480      	push	{r7}
 8016576:	b085      	sub	sp, #20
 8016578:	af00      	add	r7, sp, #0
 801657a:	6078      	str	r0, [r7, #4]
	BYTE sum = 0;
 801657c:	2300      	movs	r3, #0
 801657e:	73fb      	strb	r3, [r7, #15]
	UINT n = 11;
 8016580:	230b      	movs	r3, #11
 8016582:	60bb      	str	r3, [r7, #8]

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
 8016584:	7bfb      	ldrb	r3, [r7, #15]
 8016586:	b2da      	uxtb	r2, r3
 8016588:	0852      	lsrs	r2, r2, #1
 801658a:	01db      	lsls	r3, r3, #7
 801658c:	4313      	orrs	r3, r2
 801658e:	b2da      	uxtb	r2, r3
 8016590:	687b      	ldr	r3, [r7, #4]
 8016592:	1c59      	adds	r1, r3, #1
 8016594:	6079      	str	r1, [r7, #4]
 8016596:	781b      	ldrb	r3, [r3, #0]
 8016598:	4413      	add	r3, r2
 801659a:	73fb      	strb	r3, [r7, #15]
	} while (--n);
 801659c:	68bb      	ldr	r3, [r7, #8]
 801659e:	3b01      	subs	r3, #1
 80165a0:	60bb      	str	r3, [r7, #8]
 80165a2:	68bb      	ldr	r3, [r7, #8]
 80165a4:	2b00      	cmp	r3, #0
 80165a6:	d1ed      	bne.n	8016584 <sum_sfn+0x10>
	return sum;
 80165a8:	7bfb      	ldrb	r3, [r7, #15]
}
 80165aa:	4618      	mov	r0, r3
 80165ac:	3714      	adds	r7, #20
 80165ae:	46bd      	mov	sp, r7
 80165b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80165b4:	4770      	bx	lr

080165b6 <dir_read>:
static
FRESULT dir_read (
	DIR* dp,		/* Pointer to the directory object */
	int vol			/* Filtered by 0:file/directory or 1:volume label */
)
{
 80165b6:	b580      	push	{r7, lr}
 80165b8:	b086      	sub	sp, #24
 80165ba:	af00      	add	r7, sp, #0
 80165bc:	6078      	str	r0, [r7, #4]
 80165be:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_NO_FILE;
 80165c0:	2304      	movs	r3, #4
 80165c2:	75fb      	strb	r3, [r7, #23]
	FATFS *fs = dp->obj.fs;
 80165c4:	687b      	ldr	r3, [r7, #4]
 80165c6:	681b      	ldr	r3, [r3, #0]
 80165c8:	613b      	str	r3, [r7, #16]
	BYTE a, c;
#if _USE_LFN != 0
	BYTE ord = 0xFF, sum = 0xFF;
 80165ca:	23ff      	movs	r3, #255	@ 0xff
 80165cc:	757b      	strb	r3, [r7, #21]
 80165ce:	23ff      	movs	r3, #255	@ 0xff
 80165d0:	753b      	strb	r3, [r7, #20]
#endif

	while (dp->sect) {
 80165d2:	e081      	b.n	80166d8 <dir_read+0x122>
		res = move_window(fs, dp->sect);
 80165d4:	687b      	ldr	r3, [r7, #4]
 80165d6:	69db      	ldr	r3, [r3, #28]
 80165d8:	4619      	mov	r1, r3
 80165da:	6938      	ldr	r0, [r7, #16]
 80165dc:	f7ff f8bc 	bl	8015758 <move_window>
 80165e0:	4603      	mov	r3, r0
 80165e2:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 80165e4:	7dfb      	ldrb	r3, [r7, #23]
 80165e6:	2b00      	cmp	r3, #0
 80165e8:	d17c      	bne.n	80166e4 <dir_read+0x12e>
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 80165ea:	687b      	ldr	r3, [r7, #4]
 80165ec:	6a1b      	ldr	r3, [r3, #32]
 80165ee:	781b      	ldrb	r3, [r3, #0]
 80165f0:	75bb      	strb	r3, [r7, #22]
		if (c == 0) {
 80165f2:	7dbb      	ldrb	r3, [r7, #22]
 80165f4:	2b00      	cmp	r3, #0
 80165f6:	d102      	bne.n	80165fe <dir_read+0x48>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 80165f8:	2304      	movs	r3, #4
 80165fa:	75fb      	strb	r3, [r7, #23]
 80165fc:	e077      	b.n	80166ee <dir_read+0x138>
				}
			}
		} else
#endif
		{	/* On the FAT12/16/32 volume */
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 80165fe:	687b      	ldr	r3, [r7, #4]
 8016600:	6a1b      	ldr	r3, [r3, #32]
 8016602:	330b      	adds	r3, #11
 8016604:	781b      	ldrb	r3, [r3, #0]
 8016606:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801660a:	73fb      	strb	r3, [r7, #15]
 801660c:	687b      	ldr	r3, [r7, #4]
 801660e:	7bfa      	ldrb	r2, [r7, #15]
 8016610:	719a      	strb	r2, [r3, #6]
#if _USE_LFN != 0	/* LFN configuration */
			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 8016612:	7dbb      	ldrb	r3, [r7, #22]
 8016614:	2be5      	cmp	r3, #229	@ 0xe5
 8016616:	d00e      	beq.n	8016636 <dir_read+0x80>
 8016618:	7dbb      	ldrb	r3, [r7, #22]
 801661a:	2b2e      	cmp	r3, #46	@ 0x2e
 801661c:	d00b      	beq.n	8016636 <dir_read+0x80>
 801661e:	7bfb      	ldrb	r3, [r7, #15]
 8016620:	f023 0320 	bic.w	r3, r3, #32
 8016624:	2b08      	cmp	r3, #8
 8016626:	bf0c      	ite	eq
 8016628:	2301      	moveq	r3, #1
 801662a:	2300      	movne	r3, #0
 801662c:	b2db      	uxtb	r3, r3
 801662e:	461a      	mov	r2, r3
 8016630:	683b      	ldr	r3, [r7, #0]
 8016632:	4293      	cmp	r3, r2
 8016634:	d002      	beq.n	801663c <dir_read+0x86>
				ord = 0xFF;
 8016636:	23ff      	movs	r3, #255	@ 0xff
 8016638:	757b      	strb	r3, [r7, #21]
 801663a:	e044      	b.n	80166c6 <dir_read+0x110>
			} else {
				if (a == AM_LFN) {			/* An LFN entry is found */
 801663c:	7bfb      	ldrb	r3, [r7, #15]
 801663e:	2b0f      	cmp	r3, #15
 8016640:	d12f      	bne.n	80166a2 <dir_read+0xec>
					if (c & LLEF) {			/* Is it start of an LFN sequence? */
 8016642:	7dbb      	ldrb	r3, [r7, #22]
 8016644:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8016648:	2b00      	cmp	r3, #0
 801664a:	d00d      	beq.n	8016668 <dir_read+0xb2>
						sum = dp->dir[LDIR_Chksum];
 801664c:	687b      	ldr	r3, [r7, #4]
 801664e:	6a1b      	ldr	r3, [r3, #32]
 8016650:	7b5b      	ldrb	r3, [r3, #13]
 8016652:	753b      	strb	r3, [r7, #20]
						c &= (BYTE)~LLEF; ord = c;
 8016654:	7dbb      	ldrb	r3, [r7, #22]
 8016656:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 801665a:	75bb      	strb	r3, [r7, #22]
 801665c:	7dbb      	ldrb	r3, [r7, #22]
 801665e:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;
 8016660:	687b      	ldr	r3, [r7, #4]
 8016662:	695a      	ldr	r2, [r3, #20]
 8016664:	687b      	ldr	r3, [r7, #4]
 8016666:	631a      	str	r2, [r3, #48]	@ 0x30
					}
					/* Check LFN validity and capture it */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 8016668:	7dba      	ldrb	r2, [r7, #22]
 801666a:	7d7b      	ldrb	r3, [r7, #21]
 801666c:	429a      	cmp	r2, r3
 801666e:	d115      	bne.n	801669c <dir_read+0xe6>
 8016670:	687b      	ldr	r3, [r7, #4]
 8016672:	6a1b      	ldr	r3, [r3, #32]
 8016674:	330d      	adds	r3, #13
 8016676:	781b      	ldrb	r3, [r3, #0]
 8016678:	7d3a      	ldrb	r2, [r7, #20]
 801667a:	429a      	cmp	r2, r3
 801667c:	d10e      	bne.n	801669c <dir_read+0xe6>
 801667e:	693b      	ldr	r3, [r7, #16]
 8016680:	68da      	ldr	r2, [r3, #12]
 8016682:	687b      	ldr	r3, [r7, #4]
 8016684:	6a1b      	ldr	r3, [r3, #32]
 8016686:	4619      	mov	r1, r3
 8016688:	4610      	mov	r0, r2
 801668a:	f7ff fe19 	bl	80162c0 <pick_lfn>
 801668e:	4603      	mov	r3, r0
 8016690:	2b00      	cmp	r3, #0
 8016692:	d003      	beq.n	801669c <dir_read+0xe6>
 8016694:	7d7b      	ldrb	r3, [r7, #21]
 8016696:	3b01      	subs	r3, #1
 8016698:	b2db      	uxtb	r3, r3
 801669a:	e000      	b.n	801669e <dir_read+0xe8>
 801669c:	23ff      	movs	r3, #255	@ 0xff
 801669e:	757b      	strb	r3, [r7, #21]
 80166a0:	e011      	b.n	80166c6 <dir_read+0x110>
				} else {					/* An SFN entry is found */
					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 80166a2:	7d7b      	ldrb	r3, [r7, #21]
 80166a4:	2b00      	cmp	r3, #0
 80166a6:	d109      	bne.n	80166bc <dir_read+0x106>
 80166a8:	687b      	ldr	r3, [r7, #4]
 80166aa:	6a1b      	ldr	r3, [r3, #32]
 80166ac:	4618      	mov	r0, r3
 80166ae:	f7ff ff61 	bl	8016574 <sum_sfn>
 80166b2:	4603      	mov	r3, r0
 80166b4:	461a      	mov	r2, r3
 80166b6:	7d3b      	ldrb	r3, [r7, #20]
 80166b8:	4293      	cmp	r3, r2
 80166ba:	d015      	beq.n	80166e8 <dir_read+0x132>
						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
 80166bc:	687b      	ldr	r3, [r7, #4]
 80166be:	f04f 32ff 	mov.w	r2, #4294967295
 80166c2:	631a      	str	r2, [r3, #48]	@ 0x30
					}
					break;
 80166c4:	e010      	b.n	80166e8 <dir_read+0x132>
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
				break;
			}
#endif
		}
		res = dir_next(dp, 0);		/* Next entry */
 80166c6:	2100      	movs	r1, #0
 80166c8:	6878      	ldr	r0, [r7, #4]
 80166ca:	f7ff fc3d 	bl	8015f48 <dir_next>
 80166ce:	4603      	mov	r3, r0
 80166d0:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 80166d2:	7dfb      	ldrb	r3, [r7, #23]
 80166d4:	2b00      	cmp	r3, #0
 80166d6:	d109      	bne.n	80166ec <dir_read+0x136>
	while (dp->sect) {
 80166d8:	687b      	ldr	r3, [r7, #4]
 80166da:	69db      	ldr	r3, [r3, #28]
 80166dc:	2b00      	cmp	r3, #0
 80166de:	f47f af79 	bne.w	80165d4 <dir_read+0x1e>
 80166e2:	e004      	b.n	80166ee <dir_read+0x138>
		if (res != FR_OK) break;
 80166e4:	bf00      	nop
 80166e6:	e002      	b.n	80166ee <dir_read+0x138>
					break;
 80166e8:	bf00      	nop
 80166ea:	e000      	b.n	80166ee <dir_read+0x138>
		if (res != FR_OK) break;
 80166ec:	bf00      	nop
	}

	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80166ee:	7dfb      	ldrb	r3, [r7, #23]
 80166f0:	2b00      	cmp	r3, #0
 80166f2:	d002      	beq.n	80166fa <dir_read+0x144>
 80166f4:	687b      	ldr	r3, [r7, #4]
 80166f6:	2200      	movs	r2, #0
 80166f8:	61da      	str	r2, [r3, #28]
	return res;
 80166fa:	7dfb      	ldrb	r3, [r7, #23]
}
 80166fc:	4618      	mov	r0, r3
 80166fe:	3718      	adds	r7, #24
 8016700:	46bd      	mov	sp, r7
 8016702:	bd80      	pop	{r7, pc}

08016704 <dir_find>:

static
FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp			/* Pointer to the directory object with the file name */
)
{
 8016704:	b580      	push	{r7, lr}
 8016706:	b086      	sub	sp, #24
 8016708:	af00      	add	r7, sp, #0
 801670a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 801670c:	687b      	ldr	r3, [r7, #4]
 801670e:	681b      	ldr	r3, [r3, #0]
 8016710:	613b      	str	r3, [r7, #16]
	BYTE c;
#if _USE_LFN != 0
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
 8016712:	2100      	movs	r1, #0
 8016714:	6878      	ldr	r0, [r7, #4]
 8016716:	f7ff fb9c 	bl	8015e52 <dir_sdi>
 801671a:	4603      	mov	r3, r0
 801671c:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) return res;
 801671e:	7dfb      	ldrb	r3, [r7, #23]
 8016720:	2b00      	cmp	r3, #0
 8016722:	d001      	beq.n	8016728 <dir_find+0x24>
 8016724:	7dfb      	ldrb	r3, [r7, #23]
 8016726:	e0a9      	b.n	801687c <dir_find+0x178>
		return res;
	}
#endif
	/* On the FAT12/16/32 volume */
#if _USE_LFN != 0
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 8016728:	23ff      	movs	r3, #255	@ 0xff
 801672a:	753b      	strb	r3, [r7, #20]
 801672c:	7d3b      	ldrb	r3, [r7, #20]
 801672e:	757b      	strb	r3, [r7, #21]
 8016730:	687b      	ldr	r3, [r7, #4]
 8016732:	f04f 32ff 	mov.w	r2, #4294967295
 8016736:	631a      	str	r2, [r3, #48]	@ 0x30
#endif
	do {
		res = move_window(fs, dp->sect);
 8016738:	687b      	ldr	r3, [r7, #4]
 801673a:	69db      	ldr	r3, [r3, #28]
 801673c:	4619      	mov	r1, r3
 801673e:	6938      	ldr	r0, [r7, #16]
 8016740:	f7ff f80a 	bl	8015758 <move_window>
 8016744:	4603      	mov	r3, r0
 8016746:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
 8016748:	7dfb      	ldrb	r3, [r7, #23]
 801674a:	2b00      	cmp	r3, #0
 801674c:	f040 8090 	bne.w	8016870 <dir_find+0x16c>
		c = dp->dir[DIR_Name];
 8016750:	687b      	ldr	r3, [r7, #4]
 8016752:	6a1b      	ldr	r3, [r3, #32]
 8016754:	781b      	ldrb	r3, [r3, #0]
 8016756:	75bb      	strb	r3, [r7, #22]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8016758:	7dbb      	ldrb	r3, [r7, #22]
 801675a:	2b00      	cmp	r3, #0
 801675c:	d102      	bne.n	8016764 <dir_find+0x60>
 801675e:	2304      	movs	r3, #4
 8016760:	75fb      	strb	r3, [r7, #23]
 8016762:	e08a      	b.n	801687a <dir_find+0x176>
#if _USE_LFN != 0	/* LFN configuration */
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
 8016764:	687b      	ldr	r3, [r7, #4]
 8016766:	6a1b      	ldr	r3, [r3, #32]
 8016768:	330b      	adds	r3, #11
 801676a:	781b      	ldrb	r3, [r3, #0]
 801676c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8016770:	73fb      	strb	r3, [r7, #15]
 8016772:	687b      	ldr	r3, [r7, #4]
 8016774:	7bfa      	ldrb	r2, [r7, #15]
 8016776:	719a      	strb	r2, [r3, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
 8016778:	7dbb      	ldrb	r3, [r7, #22]
 801677a:	2be5      	cmp	r3, #229	@ 0xe5
 801677c:	d007      	beq.n	801678e <dir_find+0x8a>
 801677e:	7bfb      	ldrb	r3, [r7, #15]
 8016780:	f003 0308 	and.w	r3, r3, #8
 8016784:	2b00      	cmp	r3, #0
 8016786:	d009      	beq.n	801679c <dir_find+0x98>
 8016788:	7bfb      	ldrb	r3, [r7, #15]
 801678a:	2b0f      	cmp	r3, #15
 801678c:	d006      	beq.n	801679c <dir_find+0x98>
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 801678e:	23ff      	movs	r3, #255	@ 0xff
 8016790:	757b      	strb	r3, [r7, #21]
 8016792:	687b      	ldr	r3, [r7, #4]
 8016794:	f04f 32ff 	mov.w	r2, #4294967295
 8016798:	631a      	str	r2, [r3, #48]	@ 0x30
 801679a:	e05e      	b.n	801685a <dir_find+0x156>
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
 801679c:	7bfb      	ldrb	r3, [r7, #15]
 801679e:	2b0f      	cmp	r3, #15
 80167a0:	d136      	bne.n	8016810 <dir_find+0x10c>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
 80167a2:	687b      	ldr	r3, [r7, #4]
 80167a4:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 80167a8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80167ac:	2b00      	cmp	r3, #0
 80167ae:	d154      	bne.n	801685a <dir_find+0x156>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
 80167b0:	7dbb      	ldrb	r3, [r7, #22]
 80167b2:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 80167b6:	2b00      	cmp	r3, #0
 80167b8:	d00d      	beq.n	80167d6 <dir_find+0xd2>
						sum = dp->dir[LDIR_Chksum];
 80167ba:	687b      	ldr	r3, [r7, #4]
 80167bc:	6a1b      	ldr	r3, [r3, #32]
 80167be:	7b5b      	ldrb	r3, [r3, #13]
 80167c0:	753b      	strb	r3, [r7, #20]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
 80167c2:	7dbb      	ldrb	r3, [r7, #22]
 80167c4:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80167c8:	75bb      	strb	r3, [r7, #22]
 80167ca:	7dbb      	ldrb	r3, [r7, #22]
 80167cc:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
 80167ce:	687b      	ldr	r3, [r7, #4]
 80167d0:	695a      	ldr	r2, [r3, #20]
 80167d2:	687b      	ldr	r3, [r7, #4]
 80167d4:	631a      	str	r2, [r3, #48]	@ 0x30
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 80167d6:	7dba      	ldrb	r2, [r7, #22]
 80167d8:	7d7b      	ldrb	r3, [r7, #21]
 80167da:	429a      	cmp	r2, r3
 80167dc:	d115      	bne.n	801680a <dir_find+0x106>
 80167de:	687b      	ldr	r3, [r7, #4]
 80167e0:	6a1b      	ldr	r3, [r3, #32]
 80167e2:	330d      	adds	r3, #13
 80167e4:	781b      	ldrb	r3, [r3, #0]
 80167e6:	7d3a      	ldrb	r2, [r7, #20]
 80167e8:	429a      	cmp	r2, r3
 80167ea:	d10e      	bne.n	801680a <dir_find+0x106>
 80167ec:	693b      	ldr	r3, [r7, #16]
 80167ee:	68da      	ldr	r2, [r3, #12]
 80167f0:	687b      	ldr	r3, [r7, #4]
 80167f2:	6a1b      	ldr	r3, [r3, #32]
 80167f4:	4619      	mov	r1, r3
 80167f6:	4610      	mov	r0, r2
 80167f8:	f7ff fcf2 	bl	80161e0 <cmp_lfn>
 80167fc:	4603      	mov	r3, r0
 80167fe:	2b00      	cmp	r3, #0
 8016800:	d003      	beq.n	801680a <dir_find+0x106>
 8016802:	7d7b      	ldrb	r3, [r7, #21]
 8016804:	3b01      	subs	r3, #1
 8016806:	b2db      	uxtb	r3, r3
 8016808:	e000      	b.n	801680c <dir_find+0x108>
 801680a:	23ff      	movs	r3, #255	@ 0xff
 801680c:	757b      	strb	r3, [r7, #21]
 801680e:	e024      	b.n	801685a <dir_find+0x156>
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8016810:	7d7b      	ldrb	r3, [r7, #21]
 8016812:	2b00      	cmp	r3, #0
 8016814:	d109      	bne.n	801682a <dir_find+0x126>
 8016816:	687b      	ldr	r3, [r7, #4]
 8016818:	6a1b      	ldr	r3, [r3, #32]
 801681a:	4618      	mov	r0, r3
 801681c:	f7ff feaa 	bl	8016574 <sum_sfn>
 8016820:	4603      	mov	r3, r0
 8016822:	461a      	mov	r2, r3
 8016824:	7d3b      	ldrb	r3, [r7, #20]
 8016826:	4293      	cmp	r3, r2
 8016828:	d024      	beq.n	8016874 <dir_find+0x170>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 801682a:	687b      	ldr	r3, [r7, #4]
 801682c:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 8016830:	f003 0301 	and.w	r3, r3, #1
 8016834:	2b00      	cmp	r3, #0
 8016836:	d10a      	bne.n	801684e <dir_find+0x14a>
 8016838:	687b      	ldr	r3, [r7, #4]
 801683a:	6a18      	ldr	r0, [r3, #32]
 801683c:	687b      	ldr	r3, [r7, #4]
 801683e:	3324      	adds	r3, #36	@ 0x24
 8016840:	220b      	movs	r2, #11
 8016842:	4619      	mov	r1, r3
 8016844:	f7fe fd96 	bl	8015374 <mem_cmp>
 8016848:	4603      	mov	r3, r0
 801684a:	2b00      	cmp	r3, #0
 801684c:	d014      	beq.n	8016878 <dir_find+0x174>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
 801684e:	23ff      	movs	r3, #255	@ 0xff
 8016850:	757b      	strb	r3, [r7, #21]
 8016852:	687b      	ldr	r3, [r7, #4]
 8016854:	f04f 32ff 	mov.w	r2, #4294967295
 8016858:	631a      	str	r2, [r3, #48]	@ 0x30
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
#endif
		res = dir_next(dp, 0);	/* Next entry */
 801685a:	2100      	movs	r1, #0
 801685c:	6878      	ldr	r0, [r7, #4]
 801685e:	f7ff fb73 	bl	8015f48 <dir_next>
 8016862:	4603      	mov	r3, r0
 8016864:	75fb      	strb	r3, [r7, #23]
	} while (res == FR_OK);
 8016866:	7dfb      	ldrb	r3, [r7, #23]
 8016868:	2b00      	cmp	r3, #0
 801686a:	f43f af65 	beq.w	8016738 <dir_find+0x34>
 801686e:	e004      	b.n	801687a <dir_find+0x176>
		if (res != FR_OK) break;
 8016870:	bf00      	nop
 8016872:	e002      	b.n	801687a <dir_find+0x176>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
 8016874:	bf00      	nop
 8016876:	e000      	b.n	801687a <dir_find+0x176>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
 8016878:	bf00      	nop

	return res;
 801687a:	7dfb      	ldrb	r3, [r7, #23]
}
 801687c:	4618      	mov	r0, r3
 801687e:	3718      	adds	r7, #24
 8016880:	46bd      	mov	sp, r7
 8016882:	bd80      	pop	{r7, pc}

08016884 <dir_register>:

static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
 8016884:	b580      	push	{r7, lr}
 8016886:	b08c      	sub	sp, #48	@ 0x30
 8016888:	af00      	add	r7, sp, #0
 801688a:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
 801688c:	687b      	ldr	r3, [r7, #4]
 801688e:	681b      	ldr	r3, [r3, #0]
 8016890:	61fb      	str	r3, [r7, #28]
#if _USE_LFN != 0	/* LFN configuration */
	UINT n, nlen, nent;
	BYTE sn[12], sum;


	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
 8016892:	687b      	ldr	r3, [r7, #4]
 8016894:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 8016898:	f003 03a0 	and.w	r3, r3, #160	@ 0xa0
 801689c:	2b00      	cmp	r3, #0
 801689e:	d001      	beq.n	80168a4 <dir_register+0x20>
 80168a0:	2306      	movs	r3, #6
 80168a2:	e0e0      	b.n	8016a66 <dir_register+0x1e2>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
 80168a4:	2300      	movs	r3, #0
 80168a6:	627b      	str	r3, [r7, #36]	@ 0x24
 80168a8:	e002      	b.n	80168b0 <dir_register+0x2c>
 80168aa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80168ac:	3301      	adds	r3, #1
 80168ae:	627b      	str	r3, [r7, #36]	@ 0x24
 80168b0:	69fb      	ldr	r3, [r7, #28]
 80168b2:	68da      	ldr	r2, [r3, #12]
 80168b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80168b6:	005b      	lsls	r3, r3, #1
 80168b8:	4413      	add	r3, r2
 80168ba:	881b      	ldrh	r3, [r3, #0]
 80168bc:	2b00      	cmp	r3, #0
 80168be:	d1f4      	bne.n	80168aa <dir_register+0x26>
		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
		return FR_OK;
	}
#endif
	/* On the FAT12/16/32 volume */
	mem_cpy(sn, dp->fn, 12);
 80168c0:	687b      	ldr	r3, [r7, #4]
 80168c2:	f103 0124 	add.w	r1, r3, #36	@ 0x24
 80168c6:	f107 030c 	add.w	r3, r7, #12
 80168ca:	220c      	movs	r2, #12
 80168cc:	4618      	mov	r0, r3
 80168ce:	f7fe fd15 	bl	80152fc <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
 80168d2:	7dfb      	ldrb	r3, [r7, #23]
 80168d4:	f003 0301 	and.w	r3, r3, #1
 80168d8:	2b00      	cmp	r3, #0
 80168da:	d032      	beq.n	8016942 <dir_register+0xbe>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
 80168dc:	687b      	ldr	r3, [r7, #4]
 80168de:	2240      	movs	r2, #64	@ 0x40
 80168e0:	f883 202f 	strb.w	r2, [r3, #47]	@ 0x2f
		for (n = 1; n < 100; n++) {
 80168e4:	2301      	movs	r3, #1
 80168e6:	62bb      	str	r3, [r7, #40]	@ 0x28
 80168e8:	e016      	b.n	8016918 <dir_register+0x94>
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
 80168ea:	687b      	ldr	r3, [r7, #4]
 80168ec:	f103 0024 	add.w	r0, r3, #36	@ 0x24
 80168f0:	69fb      	ldr	r3, [r7, #28]
 80168f2:	68da      	ldr	r2, [r3, #12]
 80168f4:	f107 010c 	add.w	r1, r7, #12
 80168f8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80168fa:	f7ff fdad 	bl	8016458 <gen_numname>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
 80168fe:	6878      	ldr	r0, [r7, #4]
 8016900:	f7ff ff00 	bl	8016704 <dir_find>
 8016904:	4603      	mov	r3, r0
 8016906:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
			if (res != FR_OK) break;
 801690a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801690e:	2b00      	cmp	r3, #0
 8016910:	d106      	bne.n	8016920 <dir_register+0x9c>
		for (n = 1; n < 100; n++) {
 8016912:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016914:	3301      	adds	r3, #1
 8016916:	62bb      	str	r3, [r7, #40]	@ 0x28
 8016918:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801691a:	2b63      	cmp	r3, #99	@ 0x63
 801691c:	d9e5      	bls.n	80168ea <dir_register+0x66>
 801691e:	e000      	b.n	8016922 <dir_register+0x9e>
			if (res != FR_OK) break;
 8016920:	bf00      	nop
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
 8016922:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8016924:	2b64      	cmp	r3, #100	@ 0x64
 8016926:	d101      	bne.n	801692c <dir_register+0xa8>
 8016928:	2307      	movs	r3, #7
 801692a:	e09c      	b.n	8016a66 <dir_register+0x1e2>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
 801692c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8016930:	2b04      	cmp	r3, #4
 8016932:	d002      	beq.n	801693a <dir_register+0xb6>
 8016934:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8016938:	e095      	b.n	8016a66 <dir_register+0x1e2>
		dp->fn[NSFLAG] = sn[NSFLAG];
 801693a:	7dfa      	ldrb	r2, [r7, #23]
 801693c:	687b      	ldr	r3, [r7, #4]
 801693e:	f883 202f 	strb.w	r2, [r3, #47]	@ 0x2f
	}

	/* Create an SFN with/without LFNs. */
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
 8016942:	7dfb      	ldrb	r3, [r7, #23]
 8016944:	f003 0302 	and.w	r3, r3, #2
 8016948:	2b00      	cmp	r3, #0
 801694a:	d007      	beq.n	801695c <dir_register+0xd8>
 801694c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801694e:	330c      	adds	r3, #12
 8016950:	4a47      	ldr	r2, [pc, #284]	@ (8016a70 <dir_register+0x1ec>)
 8016952:	fba2 2303 	umull	r2, r3, r2, r3
 8016956:	089b      	lsrs	r3, r3, #2
 8016958:	3301      	adds	r3, #1
 801695a:	e000      	b.n	801695e <dir_register+0xda>
 801695c:	2301      	movs	r3, #1
 801695e:	623b      	str	r3, [r7, #32]
	res = dir_alloc(dp, nent);		/* Allocate entries */
 8016960:	6a39      	ldr	r1, [r7, #32]
 8016962:	6878      	ldr	r0, [r7, #4]
 8016964:	f7ff fbb5 	bl	80160d2 <dir_alloc>
 8016968:	4603      	mov	r3, r0
 801696a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
 801696e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8016972:	2b00      	cmp	r3, #0
 8016974:	d148      	bne.n	8016a08 <dir_register+0x184>
 8016976:	6a3b      	ldr	r3, [r7, #32]
 8016978:	3b01      	subs	r3, #1
 801697a:	623b      	str	r3, [r7, #32]
 801697c:	6a3b      	ldr	r3, [r7, #32]
 801697e:	2b00      	cmp	r3, #0
 8016980:	d042      	beq.n	8016a08 <dir_register+0x184>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
 8016982:	687b      	ldr	r3, [r7, #4]
 8016984:	695a      	ldr	r2, [r3, #20]
 8016986:	6a3b      	ldr	r3, [r7, #32]
 8016988:	015b      	lsls	r3, r3, #5
 801698a:	1ad3      	subs	r3, r2, r3
 801698c:	4619      	mov	r1, r3
 801698e:	6878      	ldr	r0, [r7, #4]
 8016990:	f7ff fa5f 	bl	8015e52 <dir_sdi>
 8016994:	4603      	mov	r3, r0
 8016996:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
		if (res == FR_OK) {
 801699a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 801699e:	2b00      	cmp	r3, #0
 80169a0:	d132      	bne.n	8016a08 <dir_register+0x184>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
 80169a2:	687b      	ldr	r3, [r7, #4]
 80169a4:	3324      	adds	r3, #36	@ 0x24
 80169a6:	4618      	mov	r0, r3
 80169a8:	f7ff fde4 	bl	8016574 <sum_sfn>
 80169ac:	4603      	mov	r3, r0
 80169ae:	76fb      	strb	r3, [r7, #27]
			do {					/* Store LFN entries in bottom first */
				res = move_window(fs, dp->sect);
 80169b0:	687b      	ldr	r3, [r7, #4]
 80169b2:	69db      	ldr	r3, [r3, #28]
 80169b4:	4619      	mov	r1, r3
 80169b6:	69f8      	ldr	r0, [r7, #28]
 80169b8:	f7fe fece 	bl	8015758 <move_window>
 80169bc:	4603      	mov	r3, r0
 80169be:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
				if (res != FR_OK) break;
 80169c2:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 80169c6:	2b00      	cmp	r3, #0
 80169c8:	d11d      	bne.n	8016a06 <dir_register+0x182>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
 80169ca:	69fb      	ldr	r3, [r7, #28]
 80169cc:	68d8      	ldr	r0, [r3, #12]
 80169ce:	687b      	ldr	r3, [r7, #4]
 80169d0:	6a19      	ldr	r1, [r3, #32]
 80169d2:	6a3b      	ldr	r3, [r7, #32]
 80169d4:	b2da      	uxtb	r2, r3
 80169d6:	7efb      	ldrb	r3, [r7, #27]
 80169d8:	f7ff fcd6 	bl	8016388 <put_lfn>
				fs->wflag = 1;
 80169dc:	69fb      	ldr	r3, [r7, #28]
 80169de:	2201      	movs	r2, #1
 80169e0:	70da      	strb	r2, [r3, #3]
				res = dir_next(dp, 0);	/* Next entry */
 80169e2:	2100      	movs	r1, #0
 80169e4:	6878      	ldr	r0, [r7, #4]
 80169e6:	f7ff faaf 	bl	8015f48 <dir_next>
 80169ea:	4603      	mov	r3, r0
 80169ec:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
			} while (res == FR_OK && --nent);
 80169f0:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 80169f4:	2b00      	cmp	r3, #0
 80169f6:	d107      	bne.n	8016a08 <dir_register+0x184>
 80169f8:	6a3b      	ldr	r3, [r7, #32]
 80169fa:	3b01      	subs	r3, #1
 80169fc:	623b      	str	r3, [r7, #32]
 80169fe:	6a3b      	ldr	r3, [r7, #32]
 8016a00:	2b00      	cmp	r3, #0
 8016a02:	d1d5      	bne.n	80169b0 <dir_register+0x12c>
 8016a04:	e000      	b.n	8016a08 <dir_register+0x184>
				if (res != FR_OK) break;
 8016a06:	bf00      	nop
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */

#endif

	/* Set SFN entry */
	if (res == FR_OK) {
 8016a08:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8016a0c:	2b00      	cmp	r3, #0
 8016a0e:	d128      	bne.n	8016a62 <dir_register+0x1de>
		res = move_window(fs, dp->sect);
 8016a10:	687b      	ldr	r3, [r7, #4]
 8016a12:	69db      	ldr	r3, [r3, #28]
 8016a14:	4619      	mov	r1, r3
 8016a16:	69f8      	ldr	r0, [r7, #28]
 8016a18:	f7fe fe9e 	bl	8015758 <move_window>
 8016a1c:	4603      	mov	r3, r0
 8016a1e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
		if (res == FR_OK) {
 8016a22:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8016a26:	2b00      	cmp	r3, #0
 8016a28:	d11b      	bne.n	8016a62 <dir_register+0x1de>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 8016a2a:	687b      	ldr	r3, [r7, #4]
 8016a2c:	6a1b      	ldr	r3, [r3, #32]
 8016a2e:	2220      	movs	r2, #32
 8016a30:	2100      	movs	r1, #0
 8016a32:	4618      	mov	r0, r3
 8016a34:	f7fe fc83 	bl	801533e <mem_set>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
 8016a38:	687b      	ldr	r3, [r7, #4]
 8016a3a:	6a18      	ldr	r0, [r3, #32]
 8016a3c:	687b      	ldr	r3, [r7, #4]
 8016a3e:	3324      	adds	r3, #36	@ 0x24
 8016a40:	220b      	movs	r2, #11
 8016a42:	4619      	mov	r1, r3
 8016a44:	f7fe fc5a 	bl	80152fc <mem_cpy>
#if _USE_LFN != 0
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
 8016a48:	687b      	ldr	r3, [r7, #4]
 8016a4a:	f893 202f 	ldrb.w	r2, [r3, #47]	@ 0x2f
 8016a4e:	687b      	ldr	r3, [r7, #4]
 8016a50:	6a1b      	ldr	r3, [r3, #32]
 8016a52:	330c      	adds	r3, #12
 8016a54:	f002 0218 	and.w	r2, r2, #24
 8016a58:	b2d2      	uxtb	r2, r2
 8016a5a:	701a      	strb	r2, [r3, #0]
#endif
			fs->wflag = 1;
 8016a5c:	69fb      	ldr	r3, [r7, #28]
 8016a5e:	2201      	movs	r2, #1
 8016a60:	70da      	strb	r2, [r3, #3]
		}
	}

	return res;
 8016a62:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 8016a66:	4618      	mov	r0, r3
 8016a68:	3730      	adds	r7, #48	@ 0x30
 8016a6a:	46bd      	mov	sp, r7
 8016a6c:	bd80      	pop	{r7, pc}
 8016a6e:	bf00      	nop
 8016a70:	4ec4ec4f 	.word	0x4ec4ec4f

08016a74 <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno	 	/* Pointer to the file information to be filled */
)
{
 8016a74:	b580      	push	{r7, lr}
 8016a76:	b088      	sub	sp, #32
 8016a78:	af00      	add	r7, sp, #0
 8016a7a:	6078      	str	r0, [r7, #4]
 8016a7c:	6039      	str	r1, [r7, #0]
	UINT i, j;
	TCHAR c;
	DWORD tm;
#if _USE_LFN != 0
	WCHAR w, lfv;
	FATFS *fs = dp->obj.fs;
 8016a7e:	687b      	ldr	r3, [r7, #4]
 8016a80:	681b      	ldr	r3, [r3, #0]
 8016a82:	613b      	str	r3, [r7, #16]
#endif


	fno->fname[0] = 0;		/* Invaidate file info */
 8016a84:	683b      	ldr	r3, [r7, #0]
 8016a86:	2200      	movs	r2, #0
 8016a88:	759a      	strb	r2, [r3, #22]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 8016a8a:	687b      	ldr	r3, [r7, #4]
 8016a8c:	69db      	ldr	r3, [r3, #28]
 8016a8e:	2b00      	cmp	r3, #0
 8016a90:	f000 80ca 	beq.w	8016c28 <get_fileinfo+0x1b4>
		get_xdir_info(fs->dirbuf, fno);
		return;
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
 8016a94:	687b      	ldr	r3, [r7, #4]
 8016a96:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8016a98:	f1b3 3fff 	cmp.w	r3, #4294967295
 8016a9c:	d032      	beq.n	8016b04 <get_fileinfo+0x90>
			i = j = 0;
 8016a9e:	2300      	movs	r3, #0
 8016aa0:	61bb      	str	r3, [r7, #24]
 8016aa2:	69bb      	ldr	r3, [r7, #24]
 8016aa4:	61fb      	str	r3, [r7, #28]
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 8016aa6:	e01b      	b.n	8016ae0 <get_fileinfo+0x6c>
#if !_LFN_UNICODE
				w = ff_convert(w, 0);		/* Unicode -> OEM */
 8016aa8:	89fb      	ldrh	r3, [r7, #14]
 8016aaa:	2100      	movs	r1, #0
 8016aac:	4618      	mov	r0, r3
 8016aae:	f002 fa2d 	bl	8018f0c <ff_convert>
 8016ab2:	4603      	mov	r3, r0
 8016ab4:	81fb      	strh	r3, [r7, #14]
				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
 8016ab6:	89fb      	ldrh	r3, [r7, #14]
 8016ab8:	2b00      	cmp	r3, #0
 8016aba:	d102      	bne.n	8016ac2 <get_fileinfo+0x4e>
 8016abc:	2300      	movs	r3, #0
 8016abe:	61fb      	str	r3, [r7, #28]
 8016ac0:	e01a      	b.n	8016af8 <get_fileinfo+0x84>
				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
					fno->fname[i++] = (char)(w >> 8);
				}
#endif
				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
 8016ac2:	69fb      	ldr	r3, [r7, #28]
 8016ac4:	2bfe      	cmp	r3, #254	@ 0xfe
 8016ac6:	d902      	bls.n	8016ace <get_fileinfo+0x5a>
 8016ac8:	2300      	movs	r3, #0
 8016aca:	61fb      	str	r3, [r7, #28]
 8016acc:	e014      	b.n	8016af8 <get_fileinfo+0x84>
				fno->fname[i++] = (TCHAR)w;
 8016ace:	69fb      	ldr	r3, [r7, #28]
 8016ad0:	1c5a      	adds	r2, r3, #1
 8016ad2:	61fa      	str	r2, [r7, #28]
 8016ad4:	89fa      	ldrh	r2, [r7, #14]
 8016ad6:	b2d1      	uxtb	r1, r2
 8016ad8:	683a      	ldr	r2, [r7, #0]
 8016ada:	4413      	add	r3, r2
 8016adc:	460a      	mov	r2, r1
 8016ade:	759a      	strb	r2, [r3, #22]
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
 8016ae0:	693b      	ldr	r3, [r7, #16]
 8016ae2:	68da      	ldr	r2, [r3, #12]
 8016ae4:	69bb      	ldr	r3, [r7, #24]
 8016ae6:	1c59      	adds	r1, r3, #1
 8016ae8:	61b9      	str	r1, [r7, #24]
 8016aea:	005b      	lsls	r3, r3, #1
 8016aec:	4413      	add	r3, r2
 8016aee:	881b      	ldrh	r3, [r3, #0]
 8016af0:	81fb      	strh	r3, [r7, #14]
 8016af2:	89fb      	ldrh	r3, [r7, #14]
 8016af4:	2b00      	cmp	r3, #0
 8016af6:	d1d7      	bne.n	8016aa8 <get_fileinfo+0x34>
			}
			fno->fname[i] = 0;	/* Terminate the LFN */
 8016af8:	683a      	ldr	r2, [r7, #0]
 8016afa:	69fb      	ldr	r3, [r7, #28]
 8016afc:	4413      	add	r3, r2
 8016afe:	3316      	adds	r3, #22
 8016b00:	2200      	movs	r2, #0
 8016b02:	701a      	strb	r2, [r3, #0]
		}
	}

	i = j = 0;
 8016b04:	2300      	movs	r3, #0
 8016b06:	61bb      	str	r3, [r7, #24]
 8016b08:	69bb      	ldr	r3, [r7, #24]
 8016b0a:	61fb      	str	r3, [r7, #28]
	lfv = fno->fname[i];	/* LFN is exist if non-zero */
 8016b0c:	683a      	ldr	r2, [r7, #0]
 8016b0e:	69fb      	ldr	r3, [r7, #28]
 8016b10:	4413      	add	r3, r2
 8016b12:	3316      	adds	r3, #22
 8016b14:	781b      	ldrb	r3, [r3, #0]
 8016b16:	81bb      	strh	r3, [r7, #12]
	while (i < 11) {		/* Copy name body and extension */
 8016b18:	e04d      	b.n	8016bb6 <get_fileinfo+0x142>
		c = (TCHAR)dp->dir[i++];
 8016b1a:	687b      	ldr	r3, [r7, #4]
 8016b1c:	6a1a      	ldr	r2, [r3, #32]
 8016b1e:	69fb      	ldr	r3, [r7, #28]
 8016b20:	1c59      	adds	r1, r3, #1
 8016b22:	61f9      	str	r1, [r7, #28]
 8016b24:	4413      	add	r3, r2
 8016b26:	781b      	ldrb	r3, [r3, #0]
 8016b28:	75fb      	strb	r3, [r7, #23]
		if (c == ' ') continue;				/* Skip padding spaces */
 8016b2a:	7dfb      	ldrb	r3, [r7, #23]
 8016b2c:	2b20      	cmp	r3, #32
 8016b2e:	d041      	beq.n	8016bb4 <get_fileinfo+0x140>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 8016b30:	7dfb      	ldrb	r3, [r7, #23]
 8016b32:	2b05      	cmp	r3, #5
 8016b34:	d101      	bne.n	8016b3a <get_fileinfo+0xc6>
 8016b36:	23e5      	movs	r3, #229	@ 0xe5
 8016b38:	75fb      	strb	r3, [r7, #23]
		if (i == 9) {						/* Insert a . if extension is exist */
 8016b3a:	69fb      	ldr	r3, [r7, #28]
 8016b3c:	2b09      	cmp	r3, #9
 8016b3e:	d10f      	bne.n	8016b60 <get_fileinfo+0xec>
			if (!lfv) fno->fname[j] = '.';
 8016b40:	89bb      	ldrh	r3, [r7, #12]
 8016b42:	2b00      	cmp	r3, #0
 8016b44:	d105      	bne.n	8016b52 <get_fileinfo+0xde>
 8016b46:	683a      	ldr	r2, [r7, #0]
 8016b48:	69bb      	ldr	r3, [r7, #24]
 8016b4a:	4413      	add	r3, r2
 8016b4c:	3316      	adds	r3, #22
 8016b4e:	222e      	movs	r2, #46	@ 0x2e
 8016b50:	701a      	strb	r2, [r3, #0]
			fno->altname[j++] = '.';
 8016b52:	69bb      	ldr	r3, [r7, #24]
 8016b54:	1c5a      	adds	r2, r3, #1
 8016b56:	61ba      	str	r2, [r7, #24]
 8016b58:	683a      	ldr	r2, [r7, #0]
 8016b5a:	4413      	add	r3, r2
 8016b5c:	222e      	movs	r2, #46	@ 0x2e
 8016b5e:	725a      	strb	r2, [r3, #9]
			c = c << 8 | dp->dir[i++];
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
		fno->altname[j] = c;
 8016b60:	683a      	ldr	r2, [r7, #0]
 8016b62:	69bb      	ldr	r3, [r7, #24]
 8016b64:	4413      	add	r3, r2
 8016b66:	3309      	adds	r3, #9
 8016b68:	7dfa      	ldrb	r2, [r7, #23]
 8016b6a:	701a      	strb	r2, [r3, #0]
		if (!lfv) {
 8016b6c:	89bb      	ldrh	r3, [r7, #12]
 8016b6e:	2b00      	cmp	r3, #0
 8016b70:	d11c      	bne.n	8016bac <get_fileinfo+0x138>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
 8016b72:	7dfb      	ldrb	r3, [r7, #23]
 8016b74:	2b40      	cmp	r3, #64	@ 0x40
 8016b76:	d913      	bls.n	8016ba0 <get_fileinfo+0x12c>
 8016b78:	7dfb      	ldrb	r3, [r7, #23]
 8016b7a:	2b5a      	cmp	r3, #90	@ 0x5a
 8016b7c:	d810      	bhi.n	8016ba0 <get_fileinfo+0x12c>
 8016b7e:	687b      	ldr	r3, [r7, #4]
 8016b80:	6a1b      	ldr	r3, [r3, #32]
 8016b82:	330c      	adds	r3, #12
 8016b84:	781b      	ldrb	r3, [r3, #0]
 8016b86:	461a      	mov	r2, r3
 8016b88:	69fb      	ldr	r3, [r7, #28]
 8016b8a:	2b08      	cmp	r3, #8
 8016b8c:	d901      	bls.n	8016b92 <get_fileinfo+0x11e>
 8016b8e:	2310      	movs	r3, #16
 8016b90:	e000      	b.n	8016b94 <get_fileinfo+0x120>
 8016b92:	2308      	movs	r3, #8
 8016b94:	4013      	ands	r3, r2
 8016b96:	2b00      	cmp	r3, #0
 8016b98:	d002      	beq.n	8016ba0 <get_fileinfo+0x12c>
				c += 0x20;			/* To lower */
 8016b9a:	7dfb      	ldrb	r3, [r7, #23]
 8016b9c:	3320      	adds	r3, #32
 8016b9e:	75fb      	strb	r3, [r7, #23]
			}
			fno->fname[j] = c;
 8016ba0:	683a      	ldr	r2, [r7, #0]
 8016ba2:	69bb      	ldr	r3, [r7, #24]
 8016ba4:	4413      	add	r3, r2
 8016ba6:	3316      	adds	r3, #22
 8016ba8:	7dfa      	ldrb	r2, [r7, #23]
 8016baa:	701a      	strb	r2, [r3, #0]
		}
		j++;
 8016bac:	69bb      	ldr	r3, [r7, #24]
 8016bae:	3301      	adds	r3, #1
 8016bb0:	61bb      	str	r3, [r7, #24]
 8016bb2:	e000      	b.n	8016bb6 <get_fileinfo+0x142>
		if (c == ' ') continue;				/* Skip padding spaces */
 8016bb4:	bf00      	nop
	while (i < 11) {		/* Copy name body and extension */
 8016bb6:	69fb      	ldr	r3, [r7, #28]
 8016bb8:	2b0a      	cmp	r3, #10
 8016bba:	d9ae      	bls.n	8016b1a <get_fileinfo+0xa6>
	}
	if (!lfv) {
 8016bbc:	89bb      	ldrh	r3, [r7, #12]
 8016bbe:	2b00      	cmp	r3, #0
 8016bc0:	d10d      	bne.n	8016bde <get_fileinfo+0x16a>
		fno->fname[j] = 0;
 8016bc2:	683a      	ldr	r2, [r7, #0]
 8016bc4:	69bb      	ldr	r3, [r7, #24]
 8016bc6:	4413      	add	r3, r2
 8016bc8:	3316      	adds	r3, #22
 8016bca:	2200      	movs	r2, #0
 8016bcc:	701a      	strb	r2, [r3, #0]
		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
 8016bce:	687b      	ldr	r3, [r7, #4]
 8016bd0:	6a1b      	ldr	r3, [r3, #32]
 8016bd2:	330c      	adds	r3, #12
 8016bd4:	781b      	ldrb	r3, [r3, #0]
 8016bd6:	2b00      	cmp	r3, #0
 8016bd8:	d101      	bne.n	8016bde <get_fileinfo+0x16a>
 8016bda:	2300      	movs	r3, #0
 8016bdc:	61bb      	str	r3, [r7, #24]
	}
	fno->altname[j] = 0;	/* Terminate the SFN */
 8016bde:	683a      	ldr	r2, [r7, #0]
 8016be0:	69bb      	ldr	r3, [r7, #24]
 8016be2:	4413      	add	r3, r2
 8016be4:	3309      	adds	r3, #9
 8016be6:	2200      	movs	r2, #0
 8016be8:	701a      	strb	r2, [r3, #0]
		fno->fname[j++] = c;
	}
	fno->fname[j] = 0;
#endif

	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
 8016bea:	687b      	ldr	r3, [r7, #4]
 8016bec:	6a1b      	ldr	r3, [r3, #32]
 8016bee:	7ada      	ldrb	r2, [r3, #11]
 8016bf0:	683b      	ldr	r3, [r7, #0]
 8016bf2:	721a      	strb	r2, [r3, #8]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
 8016bf4:	687b      	ldr	r3, [r7, #4]
 8016bf6:	6a1b      	ldr	r3, [r3, #32]
 8016bf8:	331c      	adds	r3, #28
 8016bfa:	4618      	mov	r0, r3
 8016bfc:	f7fe fb14 	bl	8015228 <ld_dword>
 8016c00:	4602      	mov	r2, r0
 8016c02:	683b      	ldr	r3, [r7, #0]
 8016c04:	601a      	str	r2, [r3, #0]
	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
 8016c06:	687b      	ldr	r3, [r7, #4]
 8016c08:	6a1b      	ldr	r3, [r3, #32]
 8016c0a:	3316      	adds	r3, #22
 8016c0c:	4618      	mov	r0, r3
 8016c0e:	f7fe fb0b 	bl	8015228 <ld_dword>
 8016c12:	60b8      	str	r0, [r7, #8]
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 8016c14:	68bb      	ldr	r3, [r7, #8]
 8016c16:	b29a      	uxth	r2, r3
 8016c18:	683b      	ldr	r3, [r7, #0]
 8016c1a:	80da      	strh	r2, [r3, #6]
 8016c1c:	68bb      	ldr	r3, [r7, #8]
 8016c1e:	0c1b      	lsrs	r3, r3, #16
 8016c20:	b29a      	uxth	r2, r3
 8016c22:	683b      	ldr	r3, [r7, #0]
 8016c24:	809a      	strh	r2, [r3, #4]
 8016c26:	e000      	b.n	8016c2a <get_fileinfo+0x1b6>
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 8016c28:	bf00      	nop
}
 8016c2a:	3720      	adds	r7, #32
 8016c2c:	46bd      	mov	sp, r7
 8016c2e:	bd80      	pop	{r7, pc}

08016c30 <create_name>:
static
FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
 8016c30:	b580      	push	{r7, lr}
 8016c32:	b08a      	sub	sp, #40	@ 0x28
 8016c34:	af00      	add	r7, sp, #0
 8016c36:	6078      	str	r0, [r7, #4]
 8016c38:	6039      	str	r1, [r7, #0]
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
 8016c3a:	683b      	ldr	r3, [r7, #0]
 8016c3c:	681b      	ldr	r3, [r3, #0]
 8016c3e:	613b      	str	r3, [r7, #16]
 8016c40:	687b      	ldr	r3, [r7, #4]
 8016c42:	681b      	ldr	r3, [r3, #0]
 8016c44:	68db      	ldr	r3, [r3, #12]
 8016c46:	60fb      	str	r3, [r7, #12]
 8016c48:	2300      	movs	r3, #0
 8016c4a:	617b      	str	r3, [r7, #20]
 8016c4c:	697b      	ldr	r3, [r7, #20]
 8016c4e:	61bb      	str	r3, [r7, #24]
	for (;;) {
		w = p[si++];					/* Get a character */
 8016c50:	69bb      	ldr	r3, [r7, #24]
 8016c52:	1c5a      	adds	r2, r3, #1
 8016c54:	61ba      	str	r2, [r7, #24]
 8016c56:	693a      	ldr	r2, [r7, #16]
 8016c58:	4413      	add	r3, r2
 8016c5a:	781b      	ldrb	r3, [r3, #0]
 8016c5c:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (w < ' ') break;				/* Break if end of the path name */
 8016c5e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016c60:	2b1f      	cmp	r3, #31
 8016c62:	d940      	bls.n	8016ce6 <create_name+0xb6>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
 8016c64:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016c66:	2b2f      	cmp	r3, #47	@ 0x2f
 8016c68:	d006      	beq.n	8016c78 <create_name+0x48>
 8016c6a:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016c6c:	2b5c      	cmp	r3, #92	@ 0x5c
 8016c6e:	d110      	bne.n	8016c92 <create_name+0x62>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 8016c70:	e002      	b.n	8016c78 <create_name+0x48>
 8016c72:	69bb      	ldr	r3, [r7, #24]
 8016c74:	3301      	adds	r3, #1
 8016c76:	61bb      	str	r3, [r7, #24]
 8016c78:	693a      	ldr	r2, [r7, #16]
 8016c7a:	69bb      	ldr	r3, [r7, #24]
 8016c7c:	4413      	add	r3, r2
 8016c7e:	781b      	ldrb	r3, [r3, #0]
 8016c80:	2b2f      	cmp	r3, #47	@ 0x2f
 8016c82:	d0f6      	beq.n	8016c72 <create_name+0x42>
 8016c84:	693a      	ldr	r2, [r7, #16]
 8016c86:	69bb      	ldr	r3, [r7, #24]
 8016c88:	4413      	add	r3, r2
 8016c8a:	781b      	ldrb	r3, [r3, #0]
 8016c8c:	2b5c      	cmp	r3, #92	@ 0x5c
 8016c8e:	d0f0      	beq.n	8016c72 <create_name+0x42>
			break;
 8016c90:	e02a      	b.n	8016ce8 <create_name+0xb8>
		}
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
 8016c92:	697b      	ldr	r3, [r7, #20]
 8016c94:	2bfe      	cmp	r3, #254	@ 0xfe
 8016c96:	d901      	bls.n	8016c9c <create_name+0x6c>
 8016c98:	2306      	movs	r3, #6
 8016c9a:	e17d      	b.n	8016f98 <create_name+0x368>
#if !_LFN_UNICODE
		w &= 0xFF;
 8016c9c:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016c9e:	b2db      	uxtb	r3, r3
 8016ca0:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			b = (BYTE)p[si++];			/* Get 2nd byte */
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
 8016ca2:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016ca4:	2101      	movs	r1, #1
 8016ca6:	4618      	mov	r0, r3
 8016ca8:	f002 f930 	bl	8018f0c <ff_convert>
 8016cac:	4603      	mov	r3, r0
 8016cae:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
 8016cb0:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016cb2:	2b00      	cmp	r3, #0
 8016cb4:	d101      	bne.n	8016cba <create_name+0x8a>
 8016cb6:	2306      	movs	r3, #6
 8016cb8:	e16e      	b.n	8016f98 <create_name+0x368>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
 8016cba:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016cbc:	2b7f      	cmp	r3, #127	@ 0x7f
 8016cbe:	d809      	bhi.n	8016cd4 <create_name+0xa4>
 8016cc0:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016cc2:	4619      	mov	r1, r3
 8016cc4:	488d      	ldr	r0, [pc, #564]	@ (8016efc <create_name+0x2cc>)
 8016cc6:	f7fe fb7c 	bl	80153c2 <chk_chr>
 8016cca:	4603      	mov	r3, r0
 8016ccc:	2b00      	cmp	r3, #0
 8016cce:	d001      	beq.n	8016cd4 <create_name+0xa4>
 8016cd0:	2306      	movs	r3, #6
 8016cd2:	e161      	b.n	8016f98 <create_name+0x368>
		lfn[di++] = w;					/* Store the Unicode character */
 8016cd4:	697b      	ldr	r3, [r7, #20]
 8016cd6:	1c5a      	adds	r2, r3, #1
 8016cd8:	617a      	str	r2, [r7, #20]
 8016cda:	005b      	lsls	r3, r3, #1
 8016cdc:	68fa      	ldr	r2, [r7, #12]
 8016cde:	4413      	add	r3, r2
 8016ce0:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8016ce2:	801a      	strh	r2, [r3, #0]
		w = p[si++];					/* Get a character */
 8016ce4:	e7b4      	b.n	8016c50 <create_name+0x20>
		if (w < ' ') break;				/* Break if end of the path name */
 8016ce6:	bf00      	nop
	}
	*path = &p[si];						/* Return pointer to the next segment */
 8016ce8:	693a      	ldr	r2, [r7, #16]
 8016cea:	69bb      	ldr	r3, [r7, #24]
 8016cec:	441a      	add	r2, r3
 8016cee:	683b      	ldr	r3, [r7, #0]
 8016cf0:	601a      	str	r2, [r3, #0]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8016cf2:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016cf4:	2b1f      	cmp	r3, #31
 8016cf6:	d801      	bhi.n	8016cfc <create_name+0xcc>
 8016cf8:	2304      	movs	r3, #4
 8016cfa:	e000      	b.n	8016cfe <create_name+0xce>
 8016cfc:	2300      	movs	r3, #0
 8016cfe:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8016d02:	e011      	b.n	8016d28 <create_name+0xf8>
		w = lfn[di - 1];
 8016d04:	697b      	ldr	r3, [r7, #20]
 8016d06:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 8016d0a:	3b01      	subs	r3, #1
 8016d0c:	005b      	lsls	r3, r3, #1
 8016d0e:	68fa      	ldr	r2, [r7, #12]
 8016d10:	4413      	add	r3, r2
 8016d12:	881b      	ldrh	r3, [r3, #0]
 8016d14:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (w != ' ' && w != '.') break;
 8016d16:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016d18:	2b20      	cmp	r3, #32
 8016d1a:	d002      	beq.n	8016d22 <create_name+0xf2>
 8016d1c:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016d1e:	2b2e      	cmp	r3, #46	@ 0x2e
 8016d20:	d106      	bne.n	8016d30 <create_name+0x100>
		di--;
 8016d22:	697b      	ldr	r3, [r7, #20]
 8016d24:	3b01      	subs	r3, #1
 8016d26:	617b      	str	r3, [r7, #20]
	while (di) {						/* Snip off trailing spaces and dots if exist */
 8016d28:	697b      	ldr	r3, [r7, #20]
 8016d2a:	2b00      	cmp	r3, #0
 8016d2c:	d1ea      	bne.n	8016d04 <create_name+0xd4>
 8016d2e:	e000      	b.n	8016d32 <create_name+0x102>
		if (w != ' ' && w != '.') break;
 8016d30:	bf00      	nop
	}
	lfn[di] = 0;						/* LFN is created */
 8016d32:	697b      	ldr	r3, [r7, #20]
 8016d34:	005b      	lsls	r3, r3, #1
 8016d36:	68fa      	ldr	r2, [r7, #12]
 8016d38:	4413      	add	r3, r2
 8016d3a:	2200      	movs	r2, #0
 8016d3c:	801a      	strh	r2, [r3, #0]
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
 8016d3e:	697b      	ldr	r3, [r7, #20]
 8016d40:	2b00      	cmp	r3, #0
 8016d42:	d101      	bne.n	8016d48 <create_name+0x118>
 8016d44:	2306      	movs	r3, #6
 8016d46:	e127      	b.n	8016f98 <create_name+0x368>

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
 8016d48:	687b      	ldr	r3, [r7, #4]
 8016d4a:	3324      	adds	r3, #36	@ 0x24
 8016d4c:	220b      	movs	r2, #11
 8016d4e:	2120      	movs	r1, #32
 8016d50:	4618      	mov	r0, r3
 8016d52:	f7fe faf4 	bl	801533e <mem_set>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
 8016d56:	2300      	movs	r3, #0
 8016d58:	61bb      	str	r3, [r7, #24]
 8016d5a:	e002      	b.n	8016d62 <create_name+0x132>
 8016d5c:	69bb      	ldr	r3, [r7, #24]
 8016d5e:	3301      	adds	r3, #1
 8016d60:	61bb      	str	r3, [r7, #24]
 8016d62:	69bb      	ldr	r3, [r7, #24]
 8016d64:	005b      	lsls	r3, r3, #1
 8016d66:	68fa      	ldr	r2, [r7, #12]
 8016d68:	4413      	add	r3, r2
 8016d6a:	881b      	ldrh	r3, [r3, #0]
 8016d6c:	2b20      	cmp	r3, #32
 8016d6e:	d0f5      	beq.n	8016d5c <create_name+0x12c>
 8016d70:	69bb      	ldr	r3, [r7, #24]
 8016d72:	005b      	lsls	r3, r3, #1
 8016d74:	68fa      	ldr	r2, [r7, #12]
 8016d76:	4413      	add	r3, r2
 8016d78:	881b      	ldrh	r3, [r3, #0]
 8016d7a:	2b2e      	cmp	r3, #46	@ 0x2e
 8016d7c:	d0ee      	beq.n	8016d5c <create_name+0x12c>
	if (si) cf |= NS_LOSS | NS_LFN;
 8016d7e:	69bb      	ldr	r3, [r7, #24]
 8016d80:	2b00      	cmp	r3, #0
 8016d82:	d009      	beq.n	8016d98 <create_name+0x168>
 8016d84:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016d88:	f043 0303 	orr.w	r3, r3, #3
 8016d8c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
 8016d90:	e002      	b.n	8016d98 <create_name+0x168>
 8016d92:	697b      	ldr	r3, [r7, #20]
 8016d94:	3b01      	subs	r3, #1
 8016d96:	617b      	str	r3, [r7, #20]
 8016d98:	697b      	ldr	r3, [r7, #20]
 8016d9a:	2b00      	cmp	r3, #0
 8016d9c:	d009      	beq.n	8016db2 <create_name+0x182>
 8016d9e:	697b      	ldr	r3, [r7, #20]
 8016da0:	f103 4300 	add.w	r3, r3, #2147483648	@ 0x80000000
 8016da4:	3b01      	subs	r3, #1
 8016da6:	005b      	lsls	r3, r3, #1
 8016da8:	68fa      	ldr	r2, [r7, #12]
 8016daa:	4413      	add	r3, r2
 8016dac:	881b      	ldrh	r3, [r3, #0]
 8016dae:	2b2e      	cmp	r3, #46	@ 0x2e
 8016db0:	d1ef      	bne.n	8016d92 <create_name+0x162>

	i = b = 0; ni = 8;
 8016db2:	2300      	movs	r3, #0
 8016db4:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 8016db8:	2300      	movs	r3, #0
 8016dba:	623b      	str	r3, [r7, #32]
 8016dbc:	2308      	movs	r3, #8
 8016dbe:	61fb      	str	r3, [r7, #28]
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
 8016dc0:	69bb      	ldr	r3, [r7, #24]
 8016dc2:	1c5a      	adds	r2, r3, #1
 8016dc4:	61ba      	str	r2, [r7, #24]
 8016dc6:	005b      	lsls	r3, r3, #1
 8016dc8:	68fa      	ldr	r2, [r7, #12]
 8016dca:	4413      	add	r3, r2
 8016dcc:	881b      	ldrh	r3, [r3, #0]
 8016dce:	84bb      	strh	r3, [r7, #36]	@ 0x24
		if (!w) break;					/* Break on end of the LFN */
 8016dd0:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016dd2:	2b00      	cmp	r3, #0
 8016dd4:	f000 8090 	beq.w	8016ef8 <create_name+0x2c8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
 8016dd8:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016dda:	2b20      	cmp	r3, #32
 8016ddc:	d006      	beq.n	8016dec <create_name+0x1bc>
 8016dde:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016de0:	2b2e      	cmp	r3, #46	@ 0x2e
 8016de2:	d10a      	bne.n	8016dfa <create_name+0x1ca>
 8016de4:	69ba      	ldr	r2, [r7, #24]
 8016de6:	697b      	ldr	r3, [r7, #20]
 8016de8:	429a      	cmp	r2, r3
 8016dea:	d006      	beq.n	8016dfa <create_name+0x1ca>
			cf |= NS_LOSS | NS_LFN; continue;
 8016dec:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016df0:	f043 0303 	orr.w	r3, r3, #3
 8016df4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8016df8:	e07d      	b.n	8016ef6 <create_name+0x2c6>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
 8016dfa:	6a3a      	ldr	r2, [r7, #32]
 8016dfc:	69fb      	ldr	r3, [r7, #28]
 8016dfe:	429a      	cmp	r2, r3
 8016e00:	d203      	bcs.n	8016e0a <create_name+0x1da>
 8016e02:	69ba      	ldr	r2, [r7, #24]
 8016e04:	697b      	ldr	r3, [r7, #20]
 8016e06:	429a      	cmp	r2, r3
 8016e08:	d123      	bne.n	8016e52 <create_name+0x222>
			if (ni == 11) {				/* Long extension */
 8016e0a:	69fb      	ldr	r3, [r7, #28]
 8016e0c:	2b0b      	cmp	r3, #11
 8016e0e:	d106      	bne.n	8016e1e <create_name+0x1ee>
				cf |= NS_LOSS | NS_LFN; break;
 8016e10:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016e14:	f043 0303 	orr.w	r3, r3, #3
 8016e18:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8016e1c:	e075      	b.n	8016f0a <create_name+0x2da>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
 8016e1e:	69ba      	ldr	r2, [r7, #24]
 8016e20:	697b      	ldr	r3, [r7, #20]
 8016e22:	429a      	cmp	r2, r3
 8016e24:	d005      	beq.n	8016e32 <create_name+0x202>
 8016e26:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016e2a:	f043 0303 	orr.w	r3, r3, #3
 8016e2e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			if (si > di) break;			/* No extension */
 8016e32:	69ba      	ldr	r2, [r7, #24]
 8016e34:	697b      	ldr	r3, [r7, #20]
 8016e36:	429a      	cmp	r2, r3
 8016e38:	d866      	bhi.n	8016f08 <create_name+0x2d8>
			si = di; i = 8; ni = 11;	/* Enter extension section */
 8016e3a:	697b      	ldr	r3, [r7, #20]
 8016e3c:	61bb      	str	r3, [r7, #24]
 8016e3e:	2308      	movs	r3, #8
 8016e40:	623b      	str	r3, [r7, #32]
 8016e42:	230b      	movs	r3, #11
 8016e44:	61fb      	str	r3, [r7, #28]
			b <<= 2; continue;
 8016e46:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016e4a:	009b      	lsls	r3, r3, #2
 8016e4c:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 8016e50:	e051      	b.n	8016ef6 <create_name+0x2c6>
		}

		if (w >= 0x80) {				/* Non ASCII character */
 8016e52:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016e54:	2b7f      	cmp	r3, #127	@ 0x7f
 8016e56:	d914      	bls.n	8016e82 <create_name+0x252>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
 8016e58:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016e5a:	2100      	movs	r1, #0
 8016e5c:	4618      	mov	r0, r3
 8016e5e:	f002 f855 	bl	8018f0c <ff_convert>
 8016e62:	4603      	mov	r3, r0
 8016e64:	84bb      	strh	r3, [r7, #36]	@ 0x24
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
 8016e66:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016e68:	2b00      	cmp	r3, #0
 8016e6a:	d004      	beq.n	8016e76 <create_name+0x246>
 8016e6c:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016e6e:	3b80      	subs	r3, #128	@ 0x80
 8016e70:	4a23      	ldr	r2, [pc, #140]	@ (8016f00 <create_name+0x2d0>)
 8016e72:	5cd3      	ldrb	r3, [r2, r3]
 8016e74:	84bb      	strh	r3, [r7, #36]	@ 0x24
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
 8016e76:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016e7a:	f043 0302 	orr.w	r3, r3, #2
 8016e7e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
 8016e82:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016e84:	2b00      	cmp	r3, #0
 8016e86:	d007      	beq.n	8016e98 <create_name+0x268>
 8016e88:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016e8a:	4619      	mov	r1, r3
 8016e8c:	481d      	ldr	r0, [pc, #116]	@ (8016f04 <create_name+0x2d4>)
 8016e8e:	f7fe fa98 	bl	80153c2 <chk_chr>
 8016e92:	4603      	mov	r3, r0
 8016e94:	2b00      	cmp	r3, #0
 8016e96:	d008      	beq.n	8016eaa <create_name+0x27a>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
 8016e98:	235f      	movs	r3, #95	@ 0x5f
 8016e9a:	84bb      	strh	r3, [r7, #36]	@ 0x24
 8016e9c:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016ea0:	f043 0303 	orr.w	r3, r3, #3
 8016ea4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8016ea8:	e01b      	b.n	8016ee2 <create_name+0x2b2>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
 8016eaa:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016eac:	2b40      	cmp	r3, #64	@ 0x40
 8016eae:	d909      	bls.n	8016ec4 <create_name+0x294>
 8016eb0:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016eb2:	2b5a      	cmp	r3, #90	@ 0x5a
 8016eb4:	d806      	bhi.n	8016ec4 <create_name+0x294>
					b |= 2;
 8016eb6:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016eba:	f043 0302 	orr.w	r3, r3, #2
 8016ebe:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 8016ec2:	e00e      	b.n	8016ee2 <create_name+0x2b2>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
 8016ec4:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016ec6:	2b60      	cmp	r3, #96	@ 0x60
 8016ec8:	d90b      	bls.n	8016ee2 <create_name+0x2b2>
 8016eca:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016ecc:	2b7a      	cmp	r3, #122	@ 0x7a
 8016ece:	d808      	bhi.n	8016ee2 <create_name+0x2b2>
						b |= 1; w -= 0x20;
 8016ed0:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016ed4:	f043 0301 	orr.w	r3, r3, #1
 8016ed8:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
 8016edc:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8016ede:	3b20      	subs	r3, #32
 8016ee0:	84bb      	strh	r3, [r7, #36]	@ 0x24
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
 8016ee2:	6a3b      	ldr	r3, [r7, #32]
 8016ee4:	1c5a      	adds	r2, r3, #1
 8016ee6:	623a      	str	r2, [r7, #32]
 8016ee8:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8016eea:	b2d1      	uxtb	r1, r2
 8016eec:	687a      	ldr	r2, [r7, #4]
 8016eee:	4413      	add	r3, r2
 8016ef0:	460a      	mov	r2, r1
 8016ef2:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24
		w = lfn[si++];					/* Get an LFN character */
 8016ef6:	e763      	b.n	8016dc0 <create_name+0x190>
		if (!w) break;					/* Break on end of the LFN */
 8016ef8:	bf00      	nop
 8016efa:	e006      	b.n	8016f0a <create_name+0x2da>
 8016efc:	08024f94 	.word	0x08024f94
 8016f00:	080350dc 	.word	0x080350dc
 8016f04:	08024fa0 	.word	0x08024fa0
			if (si > di) break;			/* No extension */
 8016f08:	bf00      	nop
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8016f0a:	687b      	ldr	r3, [r7, #4]
 8016f0c:	f893 3024 	ldrb.w	r3, [r3, #36]	@ 0x24
 8016f10:	2be5      	cmp	r3, #229	@ 0xe5
 8016f12:	d103      	bne.n	8016f1c <create_name+0x2ec>
 8016f14:	687b      	ldr	r3, [r7, #4]
 8016f16:	2205      	movs	r2, #5
 8016f18:	f883 2024 	strb.w	r2, [r3, #36]	@ 0x24

	if (ni == 8) b <<= 2;
 8016f1c:	69fb      	ldr	r3, [r7, #28]
 8016f1e:	2b08      	cmp	r3, #8
 8016f20:	d104      	bne.n	8016f2c <create_name+0x2fc>
 8016f22:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016f26:	009b      	lsls	r3, r3, #2
 8016f28:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
 8016f2c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016f30:	f003 030c 	and.w	r3, r3, #12
 8016f34:	2b0c      	cmp	r3, #12
 8016f36:	d005      	beq.n	8016f44 <create_name+0x314>
 8016f38:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016f3c:	f003 0303 	and.w	r3, r3, #3
 8016f40:	2b03      	cmp	r3, #3
 8016f42:	d105      	bne.n	8016f50 <create_name+0x320>
 8016f44:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016f48:	f043 0302 	orr.w	r3, r3, #2
 8016f4c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
 8016f50:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016f54:	f003 0302 	and.w	r3, r3, #2
 8016f58:	2b00      	cmp	r3, #0
 8016f5a:	d117      	bne.n	8016f8c <create_name+0x35c>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
 8016f5c:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016f60:	f003 0303 	and.w	r3, r3, #3
 8016f64:	2b01      	cmp	r3, #1
 8016f66:	d105      	bne.n	8016f74 <create_name+0x344>
 8016f68:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016f6c:	f043 0310 	orr.w	r3, r3, #16
 8016f70:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
 8016f74:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
 8016f78:	f003 030c 	and.w	r3, r3, #12
 8016f7c:	2b04      	cmp	r3, #4
 8016f7e:	d105      	bne.n	8016f8c <create_name+0x35c>
 8016f80:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8016f84:	f043 0308 	orr.w	r3, r3, #8
 8016f88:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
 8016f8c:	687b      	ldr	r3, [r7, #4]
 8016f8e:	f897 2027 	ldrb.w	r2, [r7, #39]	@ 0x27
 8016f92:	f883 202f 	strb.w	r2, [r3, #47]	@ 0x2f

	return FR_OK;
 8016f96:	2300      	movs	r3, #0
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */

	return FR_OK;
#endif /* _USE_LFN != 0 */
}
 8016f98:	4618      	mov	r0, r3
 8016f9a:	3728      	adds	r7, #40	@ 0x28
 8016f9c:	46bd      	mov	sp, r7
 8016f9e:	bd80      	pop	{r7, pc}

08016fa0 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
 8016fa0:	b580      	push	{r7, lr}
 8016fa2:	b086      	sub	sp, #24
 8016fa4:	af00      	add	r7, sp, #0
 8016fa6:	6078      	str	r0, [r7, #4]
 8016fa8:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE ns;
	_FDID *obj = &dp->obj;
 8016faa:	687b      	ldr	r3, [r7, #4]
 8016fac:	613b      	str	r3, [r7, #16]
	FATFS *fs = obj->fs;
 8016fae:	693b      	ldr	r3, [r7, #16]
 8016fb0:	681b      	ldr	r3, [r3, #0]
 8016fb2:	60fb      	str	r3, [r7, #12]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		obj->sclust = fs->cdir;				/* Start from current directory */
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 8016fb4:	e002      	b.n	8016fbc <follow_path+0x1c>
 8016fb6:	683b      	ldr	r3, [r7, #0]
 8016fb8:	3301      	adds	r3, #1
 8016fba:	603b      	str	r3, [r7, #0]
 8016fbc:	683b      	ldr	r3, [r7, #0]
 8016fbe:	781b      	ldrb	r3, [r3, #0]
 8016fc0:	2b2f      	cmp	r3, #47	@ 0x2f
 8016fc2:	d0f8      	beq.n	8016fb6 <follow_path+0x16>
 8016fc4:	683b      	ldr	r3, [r7, #0]
 8016fc6:	781b      	ldrb	r3, [r3, #0]
 8016fc8:	2b5c      	cmp	r3, #92	@ 0x5c
 8016fca:	d0f4      	beq.n	8016fb6 <follow_path+0x16>
		obj->sclust = 0;					/* Start from root directory */
 8016fcc:	693b      	ldr	r3, [r7, #16]
 8016fce:	2200      	movs	r2, #0
 8016fd0:	609a      	str	r2, [r3, #8]
		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 8016fd2:	683b      	ldr	r3, [r7, #0]
 8016fd4:	781b      	ldrb	r3, [r3, #0]
 8016fd6:	2b1f      	cmp	r3, #31
 8016fd8:	d80a      	bhi.n	8016ff0 <follow_path+0x50>
		dp->fn[NSFLAG] = NS_NONAME;
 8016fda:	687b      	ldr	r3, [r7, #4]
 8016fdc:	2280      	movs	r2, #128	@ 0x80
 8016fde:	f883 202f 	strb.w	r2, [r3, #47]	@ 0x2f
		res = dir_sdi(dp, 0);
 8016fe2:	2100      	movs	r1, #0
 8016fe4:	6878      	ldr	r0, [r7, #4]
 8016fe6:	f7fe ff34 	bl	8015e52 <dir_sdi>
 8016fea:	4603      	mov	r3, r0
 8016fec:	75fb      	strb	r3, [r7, #23]
 8016fee:	e043      	b.n	8017078 <follow_path+0xd8>

	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
 8016ff0:	463b      	mov	r3, r7
 8016ff2:	4619      	mov	r1, r3
 8016ff4:	6878      	ldr	r0, [r7, #4]
 8016ff6:	f7ff fe1b 	bl	8016c30 <create_name>
 8016ffa:	4603      	mov	r3, r0
 8016ffc:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
 8016ffe:	7dfb      	ldrb	r3, [r7, #23]
 8017000:	2b00      	cmp	r3, #0
 8017002:	d134      	bne.n	801706e <follow_path+0xce>
			res = dir_find(dp);				/* Find an object with the segment name */
 8017004:	6878      	ldr	r0, [r7, #4]
 8017006:	f7ff fb7d 	bl	8016704 <dir_find>
 801700a:	4603      	mov	r3, r0
 801700c:	75fb      	strb	r3, [r7, #23]
			ns = dp->fn[NSFLAG];
 801700e:	687b      	ldr	r3, [r7, #4]
 8017010:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 8017014:	72fb      	strb	r3, [r7, #11]
			if (res != FR_OK) {				/* Failed to find the object */
 8017016:	7dfb      	ldrb	r3, [r7, #23]
 8017018:	2b00      	cmp	r3, #0
 801701a:	d00a      	beq.n	8017032 <follow_path+0x92>
				if (res == FR_NO_FILE) {	/* Object is not found */
 801701c:	7dfb      	ldrb	r3, [r7, #23]
 801701e:	2b04      	cmp	r3, #4
 8017020:	d127      	bne.n	8017072 <follow_path+0xd2>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						dp->fn[NSFLAG] = NS_NONAME;
						res = FR_OK;
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 8017022:	7afb      	ldrb	r3, [r7, #11]
 8017024:	f003 0304 	and.w	r3, r3, #4
 8017028:	2b00      	cmp	r3, #0
 801702a:	d122      	bne.n	8017072 <follow_path+0xd2>
 801702c:	2305      	movs	r3, #5
 801702e:	75fb      	strb	r3, [r7, #23]
					}
				}
				break;
 8017030:	e01f      	b.n	8017072 <follow_path+0xd2>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8017032:	7afb      	ldrb	r3, [r7, #11]
 8017034:	f003 0304 	and.w	r3, r3, #4
 8017038:	2b00      	cmp	r3, #0
 801703a:	d11c      	bne.n	8017076 <follow_path+0xd6>
			/* Get into the sub-directory */
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 801703c:	693b      	ldr	r3, [r7, #16]
 801703e:	799b      	ldrb	r3, [r3, #6]
 8017040:	f003 0310 	and.w	r3, r3, #16
 8017044:	2b00      	cmp	r3, #0
 8017046:	d102      	bne.n	801704e <follow_path+0xae>
				res = FR_NO_PATH; break;
 8017048:	2305      	movs	r3, #5
 801704a:	75fb      	strb	r3, [r7, #23]
 801704c:	e014      	b.n	8017078 <follow_path+0xd8>
				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
			} else
#endif
			{
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 801704e:	68fb      	ldr	r3, [r7, #12]
 8017050:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 8017054:	687b      	ldr	r3, [r7, #4]
 8017056:	695b      	ldr	r3, [r3, #20]
 8017058:	f3c3 0308 	ubfx	r3, r3, #0, #9
 801705c:	4413      	add	r3, r2
 801705e:	4619      	mov	r1, r3
 8017060:	68f8      	ldr	r0, [r7, #12]
 8017062:	f7ff f87d 	bl	8016160 <ld_clust>
 8017066:	4602      	mov	r2, r0
 8017068:	693b      	ldr	r3, [r7, #16]
 801706a:	609a      	str	r2, [r3, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 801706c:	e7c0      	b.n	8016ff0 <follow_path+0x50>
			if (res != FR_OK) break;
 801706e:	bf00      	nop
 8017070:	e002      	b.n	8017078 <follow_path+0xd8>
				break;
 8017072:	bf00      	nop
 8017074:	e000      	b.n	8017078 <follow_path+0xd8>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 8017076:	bf00      	nop
			}
		}
	}

	return res;
 8017078:	7dfb      	ldrb	r3, [r7, #23]
}
 801707a:	4618      	mov	r0, r3
 801707c:	3718      	adds	r7, #24
 801707e:	46bd      	mov	sp, r7
 8017080:	bd80      	pop	{r7, pc}

08017082 <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
 8017082:	b480      	push	{r7}
 8017084:	b087      	sub	sp, #28
 8017086:	af00      	add	r7, sp, #0
 8017088:	6078      	str	r0, [r7, #4]
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
 801708a:	f04f 33ff 	mov.w	r3, #4294967295
 801708e:	613b      	str	r3, [r7, #16]
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 8017090:	687b      	ldr	r3, [r7, #4]
 8017092:	681b      	ldr	r3, [r3, #0]
 8017094:	2b00      	cmp	r3, #0
 8017096:	d031      	beq.n	80170fc <get_ldnumber+0x7a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8017098:	687b      	ldr	r3, [r7, #4]
 801709a:	681b      	ldr	r3, [r3, #0]
 801709c:	617b      	str	r3, [r7, #20]
 801709e:	e002      	b.n	80170a6 <get_ldnumber+0x24>
 80170a0:	697b      	ldr	r3, [r7, #20]
 80170a2:	3301      	adds	r3, #1
 80170a4:	617b      	str	r3, [r7, #20]
 80170a6:	697b      	ldr	r3, [r7, #20]
 80170a8:	781b      	ldrb	r3, [r3, #0]
 80170aa:	2b1f      	cmp	r3, #31
 80170ac:	d903      	bls.n	80170b6 <get_ldnumber+0x34>
 80170ae:	697b      	ldr	r3, [r7, #20]
 80170b0:	781b      	ldrb	r3, [r3, #0]
 80170b2:	2b3a      	cmp	r3, #58	@ 0x3a
 80170b4:	d1f4      	bne.n	80170a0 <get_ldnumber+0x1e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
 80170b6:	697b      	ldr	r3, [r7, #20]
 80170b8:	781b      	ldrb	r3, [r3, #0]
 80170ba:	2b3a      	cmp	r3, #58	@ 0x3a
 80170bc:	d11c      	bne.n	80170f8 <get_ldnumber+0x76>
			tp = *path;
 80170be:	687b      	ldr	r3, [r7, #4]
 80170c0:	681b      	ldr	r3, [r3, #0]
 80170c2:	60fb      	str	r3, [r7, #12]
			i = *tp++ - '0';
 80170c4:	68fb      	ldr	r3, [r7, #12]
 80170c6:	1c5a      	adds	r2, r3, #1
 80170c8:	60fa      	str	r2, [r7, #12]
 80170ca:	781b      	ldrb	r3, [r3, #0]
 80170cc:	3b30      	subs	r3, #48	@ 0x30
 80170ce:	60bb      	str	r3, [r7, #8]
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 80170d0:	68bb      	ldr	r3, [r7, #8]
 80170d2:	2b09      	cmp	r3, #9
 80170d4:	d80e      	bhi.n	80170f4 <get_ldnumber+0x72>
 80170d6:	68fa      	ldr	r2, [r7, #12]
 80170d8:	697b      	ldr	r3, [r7, #20]
 80170da:	429a      	cmp	r2, r3
 80170dc:	d10a      	bne.n	80170f4 <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 80170de:	68bb      	ldr	r3, [r7, #8]
 80170e0:	2b01      	cmp	r3, #1
 80170e2:	d807      	bhi.n	80170f4 <get_ldnumber+0x72>
					vol = (int)i;
 80170e4:	68bb      	ldr	r3, [r7, #8]
 80170e6:	613b      	str	r3, [r7, #16]
					*path = ++tt;
 80170e8:	697b      	ldr	r3, [r7, #20]
 80170ea:	3301      	adds	r3, #1
 80170ec:	617b      	str	r3, [r7, #20]
 80170ee:	687b      	ldr	r3, [r7, #4]
 80170f0:	697a      	ldr	r2, [r7, #20]
 80170f2:	601a      	str	r2, [r3, #0]
					vol = (int)i;
					*path = tt;
				}
			}
#endif
			return vol;
 80170f4:	693b      	ldr	r3, [r7, #16]
 80170f6:	e002      	b.n	80170fe <get_ldnumber+0x7c>
		}
#if _FS_RPATH != 0 && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
 80170f8:	2300      	movs	r3, #0
 80170fa:	613b      	str	r3, [r7, #16]
#endif
	}
	return vol;
 80170fc:	693b      	ldr	r3, [r7, #16]
}
 80170fe:	4618      	mov	r0, r3
 8017100:	371c      	adds	r7, #28
 8017102:	46bd      	mov	sp, r7
 8017104:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017108:	4770      	bx	lr
	...

0801710c <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
 801710c:	b580      	push	{r7, lr}
 801710e:	b082      	sub	sp, #8
 8017110:	af00      	add	r7, sp, #0
 8017112:	6078      	str	r0, [r7, #4]
 8017114:	6039      	str	r1, [r7, #0]
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8017116:	687b      	ldr	r3, [r7, #4]
 8017118:	2200      	movs	r2, #0
 801711a:	70da      	strb	r2, [r3, #3]
 801711c:	687b      	ldr	r3, [r7, #4]
 801711e:	f04f 32ff 	mov.w	r2, #4294967295
 8017122:	631a      	str	r2, [r3, #48]	@ 0x30
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 8017124:	6839      	ldr	r1, [r7, #0]
 8017126:	6878      	ldr	r0, [r7, #4]
 8017128:	f7fe fb16 	bl	8015758 <move_window>
 801712c:	4603      	mov	r3, r0
 801712e:	2b00      	cmp	r3, #0
 8017130:	d001      	beq.n	8017136 <check_fs+0x2a>
 8017132:	2304      	movs	r3, #4
 8017134:	e038      	b.n	80171a8 <check_fs+0x9c>

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8017136:	687b      	ldr	r3, [r7, #4]
 8017138:	3334      	adds	r3, #52	@ 0x34
 801713a:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 801713e:	4618      	mov	r0, r3
 8017140:	f7fe f85a 	bl	80151f8 <ld_word>
 8017144:	4603      	mov	r3, r0
 8017146:	461a      	mov	r2, r3
 8017148:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 801714c:	429a      	cmp	r2, r3
 801714e:	d001      	beq.n	8017154 <check_fs+0x48>
 8017150:	2303      	movs	r3, #3
 8017152:	e029      	b.n	80171a8 <check_fs+0x9c>

	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8017154:	687b      	ldr	r3, [r7, #4]
 8017156:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 801715a:	2be9      	cmp	r3, #233	@ 0xe9
 801715c:	d009      	beq.n	8017172 <check_fs+0x66>
 801715e:	687b      	ldr	r3, [r7, #4]
 8017160:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 8017164:	2beb      	cmp	r3, #235	@ 0xeb
 8017166:	d11e      	bne.n	80171a6 <check_fs+0x9a>
 8017168:	687b      	ldr	r3, [r7, #4]
 801716a:	f893 3036 	ldrb.w	r3, [r3, #54]	@ 0x36
 801716e:	2b90      	cmp	r3, #144	@ 0x90
 8017170:	d119      	bne.n	80171a6 <check_fs+0x9a>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8017172:	687b      	ldr	r3, [r7, #4]
 8017174:	3334      	adds	r3, #52	@ 0x34
 8017176:	3336      	adds	r3, #54	@ 0x36
 8017178:	4618      	mov	r0, r3
 801717a:	f7fe f855 	bl	8015228 <ld_dword>
 801717e:	4603      	mov	r3, r0
 8017180:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 8017184:	4a0a      	ldr	r2, [pc, #40]	@ (80171b0 <check_fs+0xa4>)
 8017186:	4293      	cmp	r3, r2
 8017188:	d101      	bne.n	801718e <check_fs+0x82>
 801718a:	2300      	movs	r3, #0
 801718c:	e00c      	b.n	80171a8 <check_fs+0x9c>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 801718e:	687b      	ldr	r3, [r7, #4]
 8017190:	3334      	adds	r3, #52	@ 0x34
 8017192:	3352      	adds	r3, #82	@ 0x52
 8017194:	4618      	mov	r0, r3
 8017196:	f7fe f847 	bl	8015228 <ld_dword>
 801719a:	4603      	mov	r3, r0
 801719c:	4a05      	ldr	r2, [pc, #20]	@ (80171b4 <check_fs+0xa8>)
 801719e:	4293      	cmp	r3, r2
 80171a0:	d101      	bne.n	80171a6 <check_fs+0x9a>
 80171a2:	2300      	movs	r3, #0
 80171a4:	e000      	b.n	80171a8 <check_fs+0x9c>
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
#endif
	return 2;
 80171a6:	2302      	movs	r3, #2
}
 80171a8:	4618      	mov	r0, r3
 80171aa:	3708      	adds	r7, #8
 80171ac:	46bd      	mov	sp, r7
 80171ae:	bd80      	pop	{r7, pc}
 80171b0:	00544146 	.word	0x00544146
 80171b4:	33544146 	.word	0x33544146

080171b8 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	BYTE mode			/* !=0: Check write protection for write access */
)
{
 80171b8:	b580      	push	{r7, lr}
 80171ba:	b096      	sub	sp, #88	@ 0x58
 80171bc:	af00      	add	r7, sp, #0
 80171be:	60f8      	str	r0, [r7, #12]
 80171c0:	60b9      	str	r1, [r7, #8]
 80171c2:	4613      	mov	r3, r2
 80171c4:	71fb      	strb	r3, [r7, #7]
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
 80171c6:	68bb      	ldr	r3, [r7, #8]
 80171c8:	2200      	movs	r2, #0
 80171ca:	601a      	str	r2, [r3, #0]
	vol = get_ldnumber(path);
 80171cc:	68f8      	ldr	r0, [r7, #12]
 80171ce:	f7ff ff58 	bl	8017082 <get_ldnumber>
 80171d2:	63f8      	str	r0, [r7, #60]	@ 0x3c
	if (vol < 0) return FR_INVALID_DRIVE;
 80171d4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80171d6:	2b00      	cmp	r3, #0
 80171d8:	da01      	bge.n	80171de <find_volume+0x26>
 80171da:	230b      	movs	r3, #11
 80171dc:	e22d      	b.n	801763a <find_volume+0x482>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
 80171de:	4aa1      	ldr	r2, [pc, #644]	@ (8017464 <find_volume+0x2ac>)
 80171e0:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80171e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80171e6:	63bb      	str	r3, [r7, #56]	@ 0x38
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 80171e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80171ea:	2b00      	cmp	r3, #0
 80171ec:	d101      	bne.n	80171f2 <find_volume+0x3a>
 80171ee:	230c      	movs	r3, #12
 80171f0:	e223      	b.n	801763a <find_volume+0x482>

	ENTER_FF(fs);						/* Lock the volume */
	*rfs = fs;							/* Return pointer to the file system object */
 80171f2:	68bb      	ldr	r3, [r7, #8]
 80171f4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80171f6:	601a      	str	r2, [r3, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 80171f8:	79fb      	ldrb	r3, [r7, #7]
 80171fa:	f023 0301 	bic.w	r3, r3, #1
 80171fe:	71fb      	strb	r3, [r7, #7]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8017200:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017202:	781b      	ldrb	r3, [r3, #0]
 8017204:	2b00      	cmp	r3, #0
 8017206:	d01a      	beq.n	801723e <find_volume+0x86>
		stat = disk_status(fs->drv);
 8017208:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801720a:	785b      	ldrb	r3, [r3, #1]
 801720c:	4618      	mov	r0, r3
 801720e:	f7fd ff4d 	bl	80150ac <disk_status>
 8017212:	4603      	mov	r3, r0
 8017214:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8017218:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 801721c:	f003 0301 	and.w	r3, r3, #1
 8017220:	2b00      	cmp	r3, #0
 8017222:	d10c      	bne.n	801723e <find_volume+0x86>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8017224:	79fb      	ldrb	r3, [r7, #7]
 8017226:	2b00      	cmp	r3, #0
 8017228:	d007      	beq.n	801723a <find_volume+0x82>
 801722a:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 801722e:	f003 0304 	and.w	r3, r3, #4
 8017232:	2b00      	cmp	r3, #0
 8017234:	d001      	beq.n	801723a <find_volume+0x82>
				return FR_WRITE_PROTECTED;
 8017236:	230a      	movs	r3, #10
 8017238:	e1ff      	b.n	801763a <find_volume+0x482>
			}
			return FR_OK;				/* The file system object is valid */
 801723a:	2300      	movs	r3, #0
 801723c:	e1fd      	b.n	801763a <find_volume+0x482>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
 801723e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017240:	2200      	movs	r2, #0
 8017242:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8017244:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8017246:	b2da      	uxtb	r2, r3
 8017248:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801724a:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 801724c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801724e:	785b      	ldrb	r3, [r3, #1]
 8017250:	4618      	mov	r0, r3
 8017252:	f7fd ff45 	bl	80150e0 <disk_initialize>
 8017256:	4603      	mov	r3, r0
 8017258:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 801725c:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8017260:	f003 0301 	and.w	r3, r3, #1
 8017264:	2b00      	cmp	r3, #0
 8017266:	d001      	beq.n	801726c <find_volume+0xb4>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8017268:	2303      	movs	r3, #3
 801726a:	e1e6      	b.n	801763a <find_volume+0x482>
	}
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 801726c:	79fb      	ldrb	r3, [r7, #7]
 801726e:	2b00      	cmp	r3, #0
 8017270:	d007      	beq.n	8017282 <find_volume+0xca>
 8017272:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8017276:	f003 0304 	and.w	r3, r3, #4
 801727a:	2b00      	cmp	r3, #0
 801727c:	d001      	beq.n	8017282 <find_volume+0xca>
		return FR_WRITE_PROTECTED;
 801727e:	230a      	movs	r3, #10
 8017280:	e1db      	b.n	801763a <find_volume+0x482>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
	bsect = 0;
 8017282:	2300      	movs	r3, #0
 8017284:	653b      	str	r3, [r7, #80]	@ 0x50
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 8017286:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 8017288:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801728a:	f7ff ff3f 	bl	801710c <check_fs>
 801728e:	4603      	mov	r3, r0
 8017290:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 8017294:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8017298:	2b02      	cmp	r3, #2
 801729a:	d149      	bne.n	8017330 <find_volume+0x178>
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 801729c:	2300      	movs	r3, #0
 801729e:	643b      	str	r3, [r7, #64]	@ 0x40
 80172a0:	e01e      	b.n	80172e0 <find_volume+0x128>
			pt = fs->win + (MBR_Table + i * SZ_PTE);
 80172a2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80172a4:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 80172a8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80172aa:	011b      	lsls	r3, r3, #4
 80172ac:	f503 73df 	add.w	r3, r3, #446	@ 0x1be
 80172b0:	4413      	add	r3, r2
 80172b2:	633b      	str	r3, [r7, #48]	@ 0x30
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 80172b4:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80172b6:	3304      	adds	r3, #4
 80172b8:	781b      	ldrb	r3, [r3, #0]
 80172ba:	2b00      	cmp	r3, #0
 80172bc:	d006      	beq.n	80172cc <find_volume+0x114>
 80172be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80172c0:	3308      	adds	r3, #8
 80172c2:	4618      	mov	r0, r3
 80172c4:	f7fd ffb0 	bl	8015228 <ld_dword>
 80172c8:	4602      	mov	r2, r0
 80172ca:	e000      	b.n	80172ce <find_volume+0x116>
 80172cc:	2200      	movs	r2, #0
 80172ce:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80172d0:	009b      	lsls	r3, r3, #2
 80172d2:	3358      	adds	r3, #88	@ 0x58
 80172d4:	443b      	add	r3, r7
 80172d6:	f843 2c44 	str.w	r2, [r3, #-68]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 80172da:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80172dc:	3301      	adds	r3, #1
 80172de:	643b      	str	r3, [r7, #64]	@ 0x40
 80172e0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80172e2:	2b03      	cmp	r3, #3
 80172e4:	d9dd      	bls.n	80172a2 <find_volume+0xea>
		}
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
 80172e6:	2300      	movs	r3, #0
 80172e8:	643b      	str	r3, [r7, #64]	@ 0x40
		if (i) i--;
 80172ea:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80172ec:	2b00      	cmp	r3, #0
 80172ee:	d002      	beq.n	80172f6 <find_volume+0x13e>
 80172f0:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80172f2:	3b01      	subs	r3, #1
 80172f4:	643b      	str	r3, [r7, #64]	@ 0x40
		do {							/* Find an FAT volume */
			bsect = br[i];
 80172f6:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80172f8:	009b      	lsls	r3, r3, #2
 80172fa:	3358      	adds	r3, #88	@ 0x58
 80172fc:	443b      	add	r3, r7
 80172fe:	f853 3c44 	ldr.w	r3, [r3, #-68]
 8017302:	653b      	str	r3, [r7, #80]	@ 0x50
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8017304:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8017306:	2b00      	cmp	r3, #0
 8017308:	d005      	beq.n	8017316 <find_volume+0x15e>
 801730a:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 801730c:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801730e:	f7ff fefd 	bl	801710c <check_fs>
 8017312:	4603      	mov	r3, r0
 8017314:	e000      	b.n	8017318 <find_volume+0x160>
 8017316:	2303      	movs	r3, #3
 8017318:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 801731c:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8017320:	2b01      	cmp	r3, #1
 8017322:	d905      	bls.n	8017330 <find_volume+0x178>
 8017324:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8017326:	3301      	adds	r3, #1
 8017328:	643b      	str	r3, [r7, #64]	@ 0x40
 801732a:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 801732c:	2b03      	cmp	r3, #3
 801732e:	d9e2      	bls.n	80172f6 <find_volume+0x13e>
	}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8017330:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8017334:	2b04      	cmp	r3, #4
 8017336:	d101      	bne.n	801733c <find_volume+0x184>
 8017338:	2301      	movs	r3, #1
 801733a:	e17e      	b.n	801763a <find_volume+0x482>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 801733c:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 8017340:	2b01      	cmp	r3, #1
 8017342:	d901      	bls.n	8017348 <find_volume+0x190>
 8017344:	230d      	movs	r3, #13
 8017346:	e178      	b.n	801763a <find_volume+0x482>
#endif
		fmt = FS_EXFAT;			/* FAT sub-type */
	} else
#endif	/* _FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8017348:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801734a:	3334      	adds	r3, #52	@ 0x34
 801734c:	330b      	adds	r3, #11
 801734e:	4618      	mov	r0, r3
 8017350:	f7fd ff52 	bl	80151f8 <ld_word>
 8017354:	4603      	mov	r3, r0
 8017356:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 801735a:	d001      	beq.n	8017360 <find_volume+0x1a8>
 801735c:	230d      	movs	r3, #13
 801735e:	e16c      	b.n	801763a <find_volume+0x482>

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
 8017360:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017362:	3334      	adds	r3, #52	@ 0x34
 8017364:	3316      	adds	r3, #22
 8017366:	4618      	mov	r0, r3
 8017368:	f7fd ff46 	bl	80151f8 <ld_word>
 801736c:	4603      	mov	r3, r0
 801736e:	64fb      	str	r3, [r7, #76]	@ 0x4c
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8017370:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017372:	2b00      	cmp	r3, #0
 8017374:	d106      	bne.n	8017384 <find_volume+0x1cc>
 8017376:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017378:	3334      	adds	r3, #52	@ 0x34
 801737a:	3324      	adds	r3, #36	@ 0x24
 801737c:	4618      	mov	r0, r3
 801737e:	f7fd ff53 	bl	8015228 <ld_dword>
 8017382:	64f8      	str	r0, [r7, #76]	@ 0x4c
		fs->fsize = fasize;
 8017384:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017386:	6cfa      	ldr	r2, [r7, #76]	@ 0x4c
 8017388:	61da      	str	r2, [r3, #28]

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 801738a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801738c:	f893 2044 	ldrb.w	r2, [r3, #68]	@ 0x44
 8017390:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017392:	709a      	strb	r2, [r3, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8017394:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017396:	789b      	ldrb	r3, [r3, #2]
 8017398:	2b01      	cmp	r3, #1
 801739a:	d005      	beq.n	80173a8 <find_volume+0x1f0>
 801739c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801739e:	789b      	ldrb	r3, [r3, #2]
 80173a0:	2b02      	cmp	r3, #2
 80173a2:	d001      	beq.n	80173a8 <find_volume+0x1f0>
 80173a4:	230d      	movs	r3, #13
 80173a6:	e148      	b.n	801763a <find_volume+0x482>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 80173a8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173aa:	789b      	ldrb	r3, [r3, #2]
 80173ac:	461a      	mov	r2, r3
 80173ae:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 80173b0:	fb02 f303 	mul.w	r3, r2, r3
 80173b4:	64fb      	str	r3, [r7, #76]	@ 0x4c

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 80173b6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173b8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80173bc:	461a      	mov	r2, r3
 80173be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173c0:	815a      	strh	r2, [r3, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 80173c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173c4:	895b      	ldrh	r3, [r3, #10]
 80173c6:	2b00      	cmp	r3, #0
 80173c8:	d008      	beq.n	80173dc <find_volume+0x224>
 80173ca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173cc:	895b      	ldrh	r3, [r3, #10]
 80173ce:	461a      	mov	r2, r3
 80173d0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173d2:	895b      	ldrh	r3, [r3, #10]
 80173d4:	3b01      	subs	r3, #1
 80173d6:	4013      	ands	r3, r2
 80173d8:	2b00      	cmp	r3, #0
 80173da:	d001      	beq.n	80173e0 <find_volume+0x228>
 80173dc:	230d      	movs	r3, #13
 80173de:	e12c      	b.n	801763a <find_volume+0x482>

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 80173e0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173e2:	3334      	adds	r3, #52	@ 0x34
 80173e4:	3311      	adds	r3, #17
 80173e6:	4618      	mov	r0, r3
 80173e8:	f7fd ff06 	bl	80151f8 <ld_word>
 80173ec:	4603      	mov	r3, r0
 80173ee:	461a      	mov	r2, r3
 80173f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173f2:	811a      	strh	r2, [r3, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 80173f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80173f6:	891b      	ldrh	r3, [r3, #8]
 80173f8:	f003 030f 	and.w	r3, r3, #15
 80173fc:	b29b      	uxth	r3, r3
 80173fe:	2b00      	cmp	r3, #0
 8017400:	d001      	beq.n	8017406 <find_volume+0x24e>
 8017402:	230d      	movs	r3, #13
 8017404:	e119      	b.n	801763a <find_volume+0x482>

		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
 8017406:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017408:	3334      	adds	r3, #52	@ 0x34
 801740a:	3313      	adds	r3, #19
 801740c:	4618      	mov	r0, r3
 801740e:	f7fd fef3 	bl	80151f8 <ld_word>
 8017412:	4603      	mov	r3, r0
 8017414:	64bb      	str	r3, [r7, #72]	@ 0x48
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8017416:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017418:	2b00      	cmp	r3, #0
 801741a:	d106      	bne.n	801742a <find_volume+0x272>
 801741c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801741e:	3334      	adds	r3, #52	@ 0x34
 8017420:	3320      	adds	r3, #32
 8017422:	4618      	mov	r0, r3
 8017424:	f7fd ff00 	bl	8015228 <ld_dword>
 8017428:	64b8      	str	r0, [r7, #72]	@ 0x48

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
 801742a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801742c:	3334      	adds	r3, #52	@ 0x34
 801742e:	330e      	adds	r3, #14
 8017430:	4618      	mov	r0, r3
 8017432:	f7fd fee1 	bl	80151f8 <ld_word>
 8017436:	4603      	mov	r3, r0
 8017438:	85fb      	strh	r3, [r7, #46]	@ 0x2e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 801743a:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 801743c:	2b00      	cmp	r3, #0
 801743e:	d101      	bne.n	8017444 <find_volume+0x28c>
 8017440:	230d      	movs	r3, #13
 8017442:	e0fa      	b.n	801763a <find_volume+0x482>

		/* Determine the FAT sub type */
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8017444:	8dfa      	ldrh	r2, [r7, #46]	@ 0x2e
 8017446:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017448:	4413      	add	r3, r2
 801744a:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801744c:	8912      	ldrh	r2, [r2, #8]
 801744e:	0912      	lsrs	r2, r2, #4
 8017450:	b292      	uxth	r2, r2
 8017452:	4413      	add	r3, r2
 8017454:	62bb      	str	r3, [r7, #40]	@ 0x28
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8017456:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8017458:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801745a:	429a      	cmp	r2, r3
 801745c:	d204      	bcs.n	8017468 <find_volume+0x2b0>
 801745e:	230d      	movs	r3, #13
 8017460:	e0eb      	b.n	801763a <find_volume+0x482>
 8017462:	bf00      	nop
 8017464:	2000a7e0 	.word	0x2000a7e0
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8017468:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 801746a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801746c:	1ad3      	subs	r3, r2, r3
 801746e:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8017470:	8952      	ldrh	r2, [r2, #10]
 8017472:	fbb3 f3f2 	udiv	r3, r3, r2
 8017476:	627b      	str	r3, [r7, #36]	@ 0x24
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8017478:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801747a:	2b00      	cmp	r3, #0
 801747c:	d101      	bne.n	8017482 <find_volume+0x2ca>
 801747e:	230d      	movs	r3, #13
 8017480:	e0db      	b.n	801763a <find_volume+0x482>
		fmt = FS_FAT32;
 8017482:	2303      	movs	r3, #3
 8017484:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8017488:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801748a:	f64f 72f5 	movw	r2, #65525	@ 0xfff5
 801748e:	4293      	cmp	r3, r2
 8017490:	d802      	bhi.n	8017498 <find_volume+0x2e0>
 8017492:	2302      	movs	r3, #2
 8017494:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8017498:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801749a:	f640 72f5 	movw	r2, #4085	@ 0xff5
 801749e:	4293      	cmp	r3, r2
 80174a0:	d802      	bhi.n	80174a8 <find_volume+0x2f0>
 80174a2:	2301      	movs	r3, #1
 80174a4:	f887 3057 	strb.w	r3, [r7, #87]	@ 0x57

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 80174a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80174aa:	1c9a      	adds	r2, r3, #2
 80174ac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174ae:	619a      	str	r2, [r3, #24]
		fs->volbase = bsect;							/* Volume start sector */
 80174b0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174b2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80174b4:	621a      	str	r2, [r3, #32]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 80174b6:	8dfa      	ldrh	r2, [r7, #46]	@ 0x2e
 80174b8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80174ba:	441a      	add	r2, r3
 80174bc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174be:	625a      	str	r2, [r3, #36]	@ 0x24
		fs->database = bsect + sysect;					/* Data start sector */
 80174c0:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80174c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80174c4:	441a      	add	r2, r3
 80174c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174c8:	62da      	str	r2, [r3, #44]	@ 0x2c
		if (fmt == FS_FAT32) {
 80174ca:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 80174ce:	2b03      	cmp	r3, #3
 80174d0:	d11e      	bne.n	8017510 <find_volume+0x358>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 80174d2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174d4:	3334      	adds	r3, #52	@ 0x34
 80174d6:	332a      	adds	r3, #42	@ 0x2a
 80174d8:	4618      	mov	r0, r3
 80174da:	f7fd fe8d 	bl	80151f8 <ld_word>
 80174de:	4603      	mov	r3, r0
 80174e0:	2b00      	cmp	r3, #0
 80174e2:	d001      	beq.n	80174e8 <find_volume+0x330>
 80174e4:	230d      	movs	r3, #13
 80174e6:	e0a8      	b.n	801763a <find_volume+0x482>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 80174e8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174ea:	891b      	ldrh	r3, [r3, #8]
 80174ec:	2b00      	cmp	r3, #0
 80174ee:	d001      	beq.n	80174f4 <find_volume+0x33c>
 80174f0:	230d      	movs	r3, #13
 80174f2:	e0a2      	b.n	801763a <find_volume+0x482>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 80174f4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80174f6:	3334      	adds	r3, #52	@ 0x34
 80174f8:	332c      	adds	r3, #44	@ 0x2c
 80174fa:	4618      	mov	r0, r3
 80174fc:	f7fd fe94 	bl	8015228 <ld_dword>
 8017500:	4602      	mov	r2, r0
 8017502:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017504:	629a      	str	r2, [r3, #40]	@ 0x28
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8017506:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017508:	699b      	ldr	r3, [r3, #24]
 801750a:	009b      	lsls	r3, r3, #2
 801750c:	647b      	str	r3, [r7, #68]	@ 0x44
 801750e:	e01f      	b.n	8017550 <find_volume+0x398>
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 8017510:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017512:	891b      	ldrh	r3, [r3, #8]
 8017514:	2b00      	cmp	r3, #0
 8017516:	d101      	bne.n	801751c <find_volume+0x364>
 8017518:	230d      	movs	r3, #13
 801751a:	e08e      	b.n	801763a <find_volume+0x482>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 801751c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801751e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8017520:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017522:	441a      	add	r2, r3
 8017524:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017526:	629a      	str	r2, [r3, #40]	@ 0x28
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8017528:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801752c:	2b02      	cmp	r3, #2
 801752e:	d103      	bne.n	8017538 <find_volume+0x380>
 8017530:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017532:	699b      	ldr	r3, [r3, #24]
 8017534:	005b      	lsls	r3, r3, #1
 8017536:	e00a      	b.n	801754e <find_volume+0x396>
 8017538:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801753a:	699a      	ldr	r2, [r3, #24]
 801753c:	4613      	mov	r3, r2
 801753e:	005b      	lsls	r3, r3, #1
 8017540:	4413      	add	r3, r2
 8017542:	085a      	lsrs	r2, r3, #1
 8017544:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017546:	699b      	ldr	r3, [r3, #24]
 8017548:	f003 0301 	and.w	r3, r3, #1
 801754c:	4413      	add	r3, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
 801754e:	647b      	str	r3, [r7, #68]	@ 0x44
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8017550:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017552:	69da      	ldr	r2, [r3, #28]
 8017554:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 8017556:	f203 13ff 	addw	r3, r3, #511	@ 0x1ff
 801755a:	0a5b      	lsrs	r3, r3, #9
 801755c:	429a      	cmp	r2, r3
 801755e:	d201      	bcs.n	8017564 <find_volume+0x3ac>
 8017560:	230d      	movs	r3, #13
 8017562:	e06a      	b.n	801763a <find_volume+0x482>

#if !_FS_READONLY
		/* Get FSINFO if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8017564:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017566:	f04f 32ff 	mov.w	r2, #4294967295
 801756a:	615a      	str	r2, [r3, #20]
 801756c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801756e:	695a      	ldr	r2, [r3, #20]
 8017570:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017572:	611a      	str	r2, [r3, #16]
		fs->fsi_flag = 0x80;
 8017574:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017576:	2280      	movs	r2, #128	@ 0x80
 8017578:	711a      	strb	r2, [r3, #4]
#if (_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
 801757a:	f897 3057 	ldrb.w	r3, [r7, #87]	@ 0x57
 801757e:	2b03      	cmp	r3, #3
 8017580:	d149      	bne.n	8017616 <find_volume+0x45e>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8017582:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017584:	3334      	adds	r3, #52	@ 0x34
 8017586:	3330      	adds	r3, #48	@ 0x30
 8017588:	4618      	mov	r0, r3
 801758a:	f7fd fe35 	bl	80151f8 <ld_word>
 801758e:	4603      	mov	r3, r0
 8017590:	2b01      	cmp	r3, #1
 8017592:	d140      	bne.n	8017616 <find_volume+0x45e>
			&& move_window(fs, bsect + 1) == FR_OK)
 8017594:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8017596:	3301      	adds	r3, #1
 8017598:	4619      	mov	r1, r3
 801759a:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 801759c:	f7fe f8dc 	bl	8015758 <move_window>
 80175a0:	4603      	mov	r3, r0
 80175a2:	2b00      	cmp	r3, #0
 80175a4:	d137      	bne.n	8017616 <find_volume+0x45e>
		{
			fs->fsi_flag = 0;
 80175a6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80175a8:	2200      	movs	r2, #0
 80175aa:	711a      	strb	r2, [r3, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 80175ac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80175ae:	3334      	adds	r3, #52	@ 0x34
 80175b0:	f503 73ff 	add.w	r3, r3, #510	@ 0x1fe
 80175b4:	4618      	mov	r0, r3
 80175b6:	f7fd fe1f 	bl	80151f8 <ld_word>
 80175ba:	4603      	mov	r3, r0
 80175bc:	461a      	mov	r2, r3
 80175be:	f64a 2355 	movw	r3, #43605	@ 0xaa55
 80175c2:	429a      	cmp	r2, r3
 80175c4:	d127      	bne.n	8017616 <find_volume+0x45e>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 80175c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80175c8:	3334      	adds	r3, #52	@ 0x34
 80175ca:	4618      	mov	r0, r3
 80175cc:	f7fd fe2c 	bl	8015228 <ld_dword>
 80175d0:	4603      	mov	r3, r0
 80175d2:	4a1c      	ldr	r2, [pc, #112]	@ (8017644 <find_volume+0x48c>)
 80175d4:	4293      	cmp	r3, r2
 80175d6:	d11e      	bne.n	8017616 <find_volume+0x45e>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 80175d8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80175da:	3334      	adds	r3, #52	@ 0x34
 80175dc:	f503 73f2 	add.w	r3, r3, #484	@ 0x1e4
 80175e0:	4618      	mov	r0, r3
 80175e2:	f7fd fe21 	bl	8015228 <ld_dword>
 80175e6:	4603      	mov	r3, r0
 80175e8:	4a17      	ldr	r2, [pc, #92]	@ (8017648 <find_volume+0x490>)
 80175ea:	4293      	cmp	r3, r2
 80175ec:	d113      	bne.n	8017616 <find_volume+0x45e>
			{
#if (_FS_NOFSINFO & 1) == 0
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 80175ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80175f0:	3334      	adds	r3, #52	@ 0x34
 80175f2:	f503 73f4 	add.w	r3, r3, #488	@ 0x1e8
 80175f6:	4618      	mov	r0, r3
 80175f8:	f7fd fe16 	bl	8015228 <ld_dword>
 80175fc:	4602      	mov	r2, r0
 80175fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017600:	615a      	str	r2, [r3, #20]
#endif
#if (_FS_NOFSINFO & 2) == 0
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8017602:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017604:	3334      	adds	r3, #52	@ 0x34
 8017606:	f503 73f6 	add.w	r3, r3, #492	@ 0x1ec
 801760a:	4618      	mov	r0, r3
 801760c:	f7fd fe0c 	bl	8015228 <ld_dword>
 8017610:	4602      	mov	r2, r0
 8017612:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017614:	611a      	str	r2, [r3, #16]
		}
#endif	/* (_FS_NOFSINFO & 3) != 3 */
#endif	/* !_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
 8017616:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017618:	f897 2057 	ldrb.w	r2, [r7, #87]	@ 0x57
 801761c:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 801761e:	4b0b      	ldr	r3, [pc, #44]	@ (801764c <find_volume+0x494>)
 8017620:	881b      	ldrh	r3, [r3, #0]
 8017622:	3301      	adds	r3, #1
 8017624:	b29a      	uxth	r2, r3
 8017626:	4b09      	ldr	r3, [pc, #36]	@ (801764c <find_volume+0x494>)
 8017628:	801a      	strh	r2, [r3, #0]
 801762a:	4b08      	ldr	r3, [pc, #32]	@ (801764c <find_volume+0x494>)
 801762c:	881a      	ldrh	r2, [r3, #0]
 801762e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8017630:	80da      	strh	r2, [r3, #6]
#endif
#if _FS_RPATH != 0
	fs->cdir = 0;			/* Initialize current directory */
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
 8017632:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 8017634:	f7fe f828 	bl	8015688 <clear_lock>
#endif
	return FR_OK;
 8017638:	2300      	movs	r3, #0
}
 801763a:	4618      	mov	r0, r3
 801763c:	3758      	adds	r7, #88	@ 0x58
 801763e:	46bd      	mov	sp, r7
 8017640:	bd80      	pop	{r7, pc}
 8017642:	bf00      	nop
 8017644:	41615252 	.word	0x41615252
 8017648:	61417272 	.word	0x61417272
 801764c:	2000a7e8 	.word	0x2000a7e8

08017650 <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
 8017650:	b580      	push	{r7, lr}
 8017652:	b084      	sub	sp, #16
 8017654:	af00      	add	r7, sp, #0
 8017656:	6078      	str	r0, [r7, #4]
 8017658:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_INVALID_OBJECT;
 801765a:	2309      	movs	r3, #9
 801765c:	73fb      	strb	r3, [r7, #15]


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
 801765e:	687b      	ldr	r3, [r7, #4]
 8017660:	2b00      	cmp	r3, #0
 8017662:	d01c      	beq.n	801769e <validate+0x4e>
 8017664:	687b      	ldr	r3, [r7, #4]
 8017666:	681b      	ldr	r3, [r3, #0]
 8017668:	2b00      	cmp	r3, #0
 801766a:	d018      	beq.n	801769e <validate+0x4e>
 801766c:	687b      	ldr	r3, [r7, #4]
 801766e:	681b      	ldr	r3, [r3, #0]
 8017670:	781b      	ldrb	r3, [r3, #0]
 8017672:	2b00      	cmp	r3, #0
 8017674:	d013      	beq.n	801769e <validate+0x4e>
 8017676:	687b      	ldr	r3, [r7, #4]
 8017678:	889a      	ldrh	r2, [r3, #4]
 801767a:	687b      	ldr	r3, [r7, #4]
 801767c:	681b      	ldr	r3, [r3, #0]
 801767e:	88db      	ldrh	r3, [r3, #6]
 8017680:	429a      	cmp	r2, r3
 8017682:	d10c      	bne.n	801769e <validate+0x4e>
			}
		} else {
			res = FR_TIMEOUT;
		}
#else
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
 8017684:	687b      	ldr	r3, [r7, #4]
 8017686:	681b      	ldr	r3, [r3, #0]
 8017688:	785b      	ldrb	r3, [r3, #1]
 801768a:	4618      	mov	r0, r3
 801768c:	f7fd fd0e 	bl	80150ac <disk_status>
 8017690:	4603      	mov	r3, r0
 8017692:	f003 0301 	and.w	r3, r3, #1
 8017696:	2b00      	cmp	r3, #0
 8017698:	d101      	bne.n	801769e <validate+0x4e>
			res = FR_OK;
 801769a:	2300      	movs	r3, #0
 801769c:	73fb      	strb	r3, [r7, #15]
		}
#endif
	}
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
 801769e:	7bfb      	ldrb	r3, [r7, #15]
 80176a0:	2b00      	cmp	r3, #0
 80176a2:	d102      	bne.n	80176aa <validate+0x5a>
 80176a4:	687b      	ldr	r3, [r7, #4]
 80176a6:	681b      	ldr	r3, [r3, #0]
 80176a8:	e000      	b.n	80176ac <validate+0x5c>
 80176aa:	2300      	movs	r3, #0
 80176ac:	683a      	ldr	r2, [r7, #0]
 80176ae:	6013      	str	r3, [r2, #0]
	return res;
 80176b0:	7bfb      	ldrb	r3, [r7, #15]
}
 80176b2:	4618      	mov	r0, r3
 80176b4:	3710      	adds	r7, #16
 80176b6:	46bd      	mov	sp, r7
 80176b8:	bd80      	pop	{r7, pc}
	...

080176bc <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 80176bc:	b580      	push	{r7, lr}
 80176be:	b088      	sub	sp, #32
 80176c0:	af00      	add	r7, sp, #0
 80176c2:	60f8      	str	r0, [r7, #12]
 80176c4:	60b9      	str	r1, [r7, #8]
 80176c6:	4613      	mov	r3, r2
 80176c8:	71fb      	strb	r3, [r7, #7]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 80176ca:	68bb      	ldr	r3, [r7, #8]
 80176cc:	613b      	str	r3, [r7, #16]


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 80176ce:	f107 0310 	add.w	r3, r7, #16
 80176d2:	4618      	mov	r0, r3
 80176d4:	f7ff fcd5 	bl	8017082 <get_ldnumber>
 80176d8:	61f8      	str	r0, [r7, #28]
	if (vol < 0) return FR_INVALID_DRIVE;
 80176da:	69fb      	ldr	r3, [r7, #28]
 80176dc:	2b00      	cmp	r3, #0
 80176de:	da01      	bge.n	80176e4 <f_mount+0x28>
 80176e0:	230b      	movs	r3, #11
 80176e2:	e02b      	b.n	801773c <f_mount+0x80>
	cfs = FatFs[vol];					/* Pointer to fs object */
 80176e4:	4a17      	ldr	r2, [pc, #92]	@ (8017744 <f_mount+0x88>)
 80176e6:	69fb      	ldr	r3, [r7, #28]
 80176e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80176ec:	61bb      	str	r3, [r7, #24]

	if (cfs) {
 80176ee:	69bb      	ldr	r3, [r7, #24]
 80176f0:	2b00      	cmp	r3, #0
 80176f2:	d005      	beq.n	8017700 <f_mount+0x44>
#if _FS_LOCK != 0
		clear_lock(cfs);
 80176f4:	69b8      	ldr	r0, [r7, #24]
 80176f6:	f7fd ffc7 	bl	8015688 <clear_lock>
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 80176fa:	69bb      	ldr	r3, [r7, #24]
 80176fc:	2200      	movs	r2, #0
 80176fe:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
 8017700:	68fb      	ldr	r3, [r7, #12]
 8017702:	2b00      	cmp	r3, #0
 8017704:	d002      	beq.n	801770c <f_mount+0x50>
		fs->fs_type = 0;				/* Clear new fs object */
 8017706:	68fb      	ldr	r3, [r7, #12]
 8017708:	2200      	movs	r2, #0
 801770a:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 801770c:	68fa      	ldr	r2, [r7, #12]
 801770e:	490d      	ldr	r1, [pc, #52]	@ (8017744 <f_mount+0x88>)
 8017710:	69fb      	ldr	r3, [r7, #28]
 8017712:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8017716:	68fb      	ldr	r3, [r7, #12]
 8017718:	2b00      	cmp	r3, #0
 801771a:	d002      	beq.n	8017722 <f_mount+0x66>
 801771c:	79fb      	ldrb	r3, [r7, #7]
 801771e:	2b01      	cmp	r3, #1
 8017720:	d001      	beq.n	8017726 <f_mount+0x6a>
 8017722:	2300      	movs	r3, #0
 8017724:	e00a      	b.n	801773c <f_mount+0x80>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 8017726:	f107 010c 	add.w	r1, r7, #12
 801772a:	f107 0308 	add.w	r3, r7, #8
 801772e:	2200      	movs	r2, #0
 8017730:	4618      	mov	r0, r3
 8017732:	f7ff fd41 	bl	80171b8 <find_volume>
 8017736:	4603      	mov	r3, r0
 8017738:	75fb      	strb	r3, [r7, #23]
	LEAVE_FF(fs, res);
 801773a:	7dfb      	ldrb	r3, [r7, #23]
}
 801773c:	4618      	mov	r0, r3
 801773e:	3720      	adds	r7, #32
 8017740:	46bd      	mov	sp, r7
 8017742:	bd80      	pop	{r7, pc}
 8017744:	2000a7e0 	.word	0x2000a7e0

08017748 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8017748:	b580      	push	{r7, lr}
 801774a:	b09a      	sub	sp, #104	@ 0x68
 801774c:	af00      	add	r7, sp, #0
 801774e:	60f8      	str	r0, [r7, #12]
 8017750:	60b9      	str	r1, [r7, #8]
 8017752:	4613      	mov	r3, r2
 8017754:	71fb      	strb	r3, [r7, #7]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 8017756:	68fb      	ldr	r3, [r7, #12]
 8017758:	2b00      	cmp	r3, #0
 801775a:	d101      	bne.n	8017760 <f_open+0x18>
 801775c:	2309      	movs	r3, #9
 801775e:	e1b9      	b.n	8017ad4 <f_open+0x38c>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 8017760:	79fb      	ldrb	r3, [r7, #7]
 8017762:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8017766:	71fb      	strb	r3, [r7, #7]
	res = find_volume(&path, &fs, mode);
 8017768:	79fa      	ldrb	r2, [r7, #7]
 801776a:	f107 0110 	add.w	r1, r7, #16
 801776e:	f107 0308 	add.w	r3, r7, #8
 8017772:	4618      	mov	r0, r3
 8017774:	f7ff fd20 	bl	80171b8 <find_volume>
 8017778:	4603      	mov	r3, r0
 801777a:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
	if (res == FR_OK) {
 801777e:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017782:	2b00      	cmp	r3, #0
 8017784:	f040 819d 	bne.w	8017ac2 <f_open+0x37a>
		dj.obj.fs = fs;
 8017788:	693b      	ldr	r3, [r7, #16]
 801778a:	617b      	str	r3, [r7, #20]
		INIT_NAMBUF(fs);
 801778c:	f44f 7000 	mov.w	r0, #512	@ 0x200
 8017790:	f001 fba5 	bl	8018ede <ff_memalloc>
 8017794:	65b8      	str	r0, [r7, #88]	@ 0x58
 8017796:	6dbb      	ldr	r3, [r7, #88]	@ 0x58
 8017798:	2b00      	cmp	r3, #0
 801779a:	d101      	bne.n	80177a0 <f_open+0x58>
 801779c:	2311      	movs	r3, #17
 801779e:	e199      	b.n	8017ad4 <f_open+0x38c>
 80177a0:	693b      	ldr	r3, [r7, #16]
 80177a2:	6dba      	ldr	r2, [r7, #88]	@ 0x58
 80177a4:	60da      	str	r2, [r3, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
 80177a6:	68ba      	ldr	r2, [r7, #8]
 80177a8:	f107 0314 	add.w	r3, r7, #20
 80177ac:	4611      	mov	r1, r2
 80177ae:	4618      	mov	r0, r3
 80177b0:	f7ff fbf6 	bl	8016fa0 <follow_path>
 80177b4:	4603      	mov	r3, r0
 80177b6:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 80177ba:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 80177be:	2b00      	cmp	r3, #0
 80177c0:	d118      	bne.n	80177f4 <f_open+0xac>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 80177c2:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 80177c6:	b25b      	sxtb	r3, r3
 80177c8:	2b00      	cmp	r3, #0
 80177ca:	da03      	bge.n	80177d4 <f_open+0x8c>
				res = FR_INVALID_NAME;
 80177cc:	2306      	movs	r3, #6
 80177ce:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 80177d2:	e00f      	b.n	80177f4 <f_open+0xac>
			}
#if _FS_LOCK != 0
			else {
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80177d4:	79fb      	ldrb	r3, [r7, #7]
 80177d6:	2b01      	cmp	r3, #1
 80177d8:	bf8c      	ite	hi
 80177da:	2301      	movhi	r3, #1
 80177dc:	2300      	movls	r3, #0
 80177de:	b2db      	uxtb	r3, r3
 80177e0:	461a      	mov	r2, r3
 80177e2:	f107 0314 	add.w	r3, r7, #20
 80177e6:	4611      	mov	r1, r2
 80177e8:	4618      	mov	r0, r3
 80177ea:	f7fd fe05 	bl	80153f8 <chk_lock>
 80177ee:	4603      	mov	r3, r0
 80177f0:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80177f4:	79fb      	ldrb	r3, [r7, #7]
 80177f6:	f003 031c 	and.w	r3, r3, #28
 80177fa:	2b00      	cmp	r3, #0
 80177fc:	d07f      	beq.n	80178fe <f_open+0x1b6>
			if (res != FR_OK) {					/* No file, create new */
 80177fe:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017802:	2b00      	cmp	r3, #0
 8017804:	d017      	beq.n	8017836 <f_open+0xee>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 8017806:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 801780a:	2b04      	cmp	r3, #4
 801780c:	d10e      	bne.n	801782c <f_open+0xe4>
#if _FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 801780e:	f7fd fe4f 	bl	80154b0 <enq_lock>
 8017812:	4603      	mov	r3, r0
 8017814:	2b00      	cmp	r3, #0
 8017816:	d006      	beq.n	8017826 <f_open+0xde>
 8017818:	f107 0314 	add.w	r3, r7, #20
 801781c:	4618      	mov	r0, r3
 801781e:	f7ff f831 	bl	8016884 <dir_register>
 8017822:	4603      	mov	r3, r0
 8017824:	e000      	b.n	8017828 <f_open+0xe0>
 8017826:	2312      	movs	r3, #18
 8017828:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
#else
					res = dir_register(&dj);
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 801782c:	79fb      	ldrb	r3, [r7, #7]
 801782e:	f043 0308 	orr.w	r3, r3, #8
 8017832:	71fb      	strb	r3, [r7, #7]
 8017834:	e010      	b.n	8017858 <f_open+0x110>
			}
			else {								/* Any object is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8017836:	7ebb      	ldrb	r3, [r7, #26]
 8017838:	f003 0311 	and.w	r3, r3, #17
 801783c:	2b00      	cmp	r3, #0
 801783e:	d003      	beq.n	8017848 <f_open+0x100>
					res = FR_DENIED;
 8017840:	2307      	movs	r3, #7
 8017842:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8017846:	e007      	b.n	8017858 <f_open+0x110>
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 8017848:	79fb      	ldrb	r3, [r7, #7]
 801784a:	f003 0304 	and.w	r3, r3, #4
 801784e:	2b00      	cmp	r3, #0
 8017850:	d002      	beq.n	8017858 <f_open+0x110>
 8017852:	2308      	movs	r3, #8
 8017854:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8017858:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 801785c:	2b00      	cmp	r3, #0
 801785e:	d168      	bne.n	8017932 <f_open+0x1ea>
 8017860:	79fb      	ldrb	r3, [r7, #7]
 8017862:	f003 0308 	and.w	r3, r3, #8
 8017866:	2b00      	cmp	r3, #0
 8017868:	d063      	beq.n	8017932 <f_open+0x1ea>
				dw = GET_FATTIME();
 801786a:	f7fd fcbd 	bl	80151e8 <get_fattime>
 801786e:	6578      	str	r0, [r7, #84]	@ 0x54
					}
				} else
#endif
				{
					/* Clean directory info */
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 8017870:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8017872:	330e      	adds	r3, #14
 8017874:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8017876:	4618      	mov	r0, r3
 8017878:	f7fd fd14 	bl	80152a4 <st_dword>
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 801787c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801787e:	3316      	adds	r3, #22
 8017880:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 8017882:	4618      	mov	r0, r3
 8017884:	f7fd fd0e 	bl	80152a4 <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8017888:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801788a:	330b      	adds	r3, #11
 801788c:	2220      	movs	r2, #32
 801788e:	701a      	strb	r2, [r3, #0]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 8017890:	693b      	ldr	r3, [r7, #16]
 8017892:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8017894:	4611      	mov	r1, r2
 8017896:	4618      	mov	r0, r3
 8017898:	f7fe fc62 	bl	8016160 <ld_clust>
 801789c:	6538      	str	r0, [r7, #80]	@ 0x50
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 801789e:	693b      	ldr	r3, [r7, #16]
 80178a0:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 80178a2:	2200      	movs	r2, #0
 80178a4:	4618      	mov	r0, r3
 80178a6:	f7fe fc7a 	bl	801619e <st_clust>
					st_dword(dj.dir + DIR_FileSize, 0);
 80178aa:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80178ac:	331c      	adds	r3, #28
 80178ae:	2100      	movs	r1, #0
 80178b0:	4618      	mov	r0, r3
 80178b2:	f7fd fcf7 	bl	80152a4 <st_dword>
					fs->wflag = 1;
 80178b6:	693b      	ldr	r3, [r7, #16]
 80178b8:	2201      	movs	r2, #1
 80178ba:	70da      	strb	r2, [r3, #3]

					if (cl) {							/* Remove the cluster chain if exist */
 80178bc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 80178be:	2b00      	cmp	r3, #0
 80178c0:	d037      	beq.n	8017932 <f_open+0x1ea>
						dw = fs->winsect;
 80178c2:	693b      	ldr	r3, [r7, #16]
 80178c4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80178c6:	657b      	str	r3, [r7, #84]	@ 0x54
						res = remove_chain(&dj.obj, cl, 0);
 80178c8:	f107 0314 	add.w	r3, r7, #20
 80178cc:	2200      	movs	r2, #0
 80178ce:	6d39      	ldr	r1, [r7, #80]	@ 0x50
 80178d0:	4618      	mov	r0, r3
 80178d2:	f7fe f98d 	bl	8015bf0 <remove_chain>
 80178d6:	4603      	mov	r3, r0
 80178d8:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
						if (res == FR_OK) {
 80178dc:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 80178e0:	2b00      	cmp	r3, #0
 80178e2:	d126      	bne.n	8017932 <f_open+0x1ea>
							res = move_window(fs, dw);
 80178e4:	693b      	ldr	r3, [r7, #16]
 80178e6:	6d79      	ldr	r1, [r7, #84]	@ 0x54
 80178e8:	4618      	mov	r0, r3
 80178ea:	f7fd ff35 	bl	8015758 <move_window>
 80178ee:	4603      	mov	r3, r0
 80178f0:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 80178f4:	693b      	ldr	r3, [r7, #16]
 80178f6:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 80178f8:	3a01      	subs	r2, #1
 80178fa:	611a      	str	r2, [r3, #16]
 80178fc:	e019      	b.n	8017932 <f_open+0x1ea>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
 80178fe:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017902:	2b00      	cmp	r3, #0
 8017904:	d115      	bne.n	8017932 <f_open+0x1ea>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 8017906:	7ebb      	ldrb	r3, [r7, #26]
 8017908:	f003 0310 	and.w	r3, r3, #16
 801790c:	2b00      	cmp	r3, #0
 801790e:	d003      	beq.n	8017918 <f_open+0x1d0>
					res = FR_NO_FILE;
 8017910:	2304      	movs	r3, #4
 8017912:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8017916:	e00c      	b.n	8017932 <f_open+0x1ea>
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 8017918:	79fb      	ldrb	r3, [r7, #7]
 801791a:	f003 0302 	and.w	r3, r3, #2
 801791e:	2b00      	cmp	r3, #0
 8017920:	d007      	beq.n	8017932 <f_open+0x1ea>
 8017922:	7ebb      	ldrb	r3, [r7, #26]
 8017924:	f003 0301 	and.w	r3, r3, #1
 8017928:	2b00      	cmp	r3, #0
 801792a:	d002      	beq.n	8017932 <f_open+0x1ea>
						res = FR_DENIED;
 801792c:	2307      	movs	r3, #7
 801792e:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
					}
				}
			}
		}
		if (res == FR_OK) {
 8017932:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017936:	2b00      	cmp	r3, #0
 8017938:	d126      	bne.n	8017988 <f_open+0x240>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 801793a:	79fb      	ldrb	r3, [r7, #7]
 801793c:	f003 0308 	and.w	r3, r3, #8
 8017940:	2b00      	cmp	r3, #0
 8017942:	d003      	beq.n	801794c <f_open+0x204>
				mode |= FA_MODIFIED;
 8017944:	79fb      	ldrb	r3, [r7, #7]
 8017946:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801794a:	71fb      	strb	r3, [r7, #7]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 801794c:	693b      	ldr	r3, [r7, #16]
 801794e:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8017950:	68fb      	ldr	r3, [r7, #12]
 8017952:	625a      	str	r2, [r3, #36]	@ 0x24
			fp->dir_ptr = dj.dir;
 8017954:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8017956:	68fb      	ldr	r3, [r7, #12]
 8017958:	629a      	str	r2, [r3, #40]	@ 0x28
#if _FS_LOCK != 0
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 801795a:	79fb      	ldrb	r3, [r7, #7]
 801795c:	2b01      	cmp	r3, #1
 801795e:	bf8c      	ite	hi
 8017960:	2301      	movhi	r3, #1
 8017962:	2300      	movls	r3, #0
 8017964:	b2db      	uxtb	r3, r3
 8017966:	461a      	mov	r2, r3
 8017968:	f107 0314 	add.w	r3, r7, #20
 801796c:	4611      	mov	r1, r2
 801796e:	4618      	mov	r0, r3
 8017970:	f7fd fdc0 	bl	80154f4 <inc_lock>
 8017974:	4602      	mov	r2, r0
 8017976:	68fb      	ldr	r3, [r7, #12]
 8017978:	611a      	str	r2, [r3, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 801797a:	68fb      	ldr	r3, [r7, #12]
 801797c:	691b      	ldr	r3, [r3, #16]
 801797e:	2b00      	cmp	r3, #0
 8017980:	d102      	bne.n	8017988 <f_open+0x240>
 8017982:	2302      	movs	r3, #2
 8017984:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
				}
			}
		}
#endif

		if (res == FR_OK) {
 8017988:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 801798c:	2b00      	cmp	r3, #0
 801798e:	f040 8095 	bne.w	8017abc <f_open+0x374>
				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8017992:	693b      	ldr	r3, [r7, #16]
 8017994:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8017996:	4611      	mov	r1, r2
 8017998:	4618      	mov	r0, r3
 801799a:	f7fe fbe1 	bl	8016160 <ld_clust>
 801799e:	4602      	mov	r2, r0
 80179a0:	68fb      	ldr	r3, [r7, #12]
 80179a2:	609a      	str	r2, [r3, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 80179a4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80179a6:	331c      	adds	r3, #28
 80179a8:	4618      	mov	r0, r3
 80179aa:	f7fd fc3d 	bl	8015228 <ld_dword>
 80179ae:	4602      	mov	r2, r0
 80179b0:	68fb      	ldr	r3, [r7, #12]
 80179b2:	60da      	str	r2, [r3, #12]
			}
#if _USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
 80179b4:	68fb      	ldr	r3, [r7, #12]
 80179b6:	2200      	movs	r2, #0
 80179b8:	62da      	str	r2, [r3, #44]	@ 0x2c
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
 80179ba:	693a      	ldr	r2, [r7, #16]
 80179bc:	68fb      	ldr	r3, [r7, #12]
 80179be:	601a      	str	r2, [r3, #0]
			fp->obj.id = fs->id;
 80179c0:	693b      	ldr	r3, [r7, #16]
 80179c2:	88da      	ldrh	r2, [r3, #6]
 80179c4:	68fb      	ldr	r3, [r7, #12]
 80179c6:	809a      	strh	r2, [r3, #4]
			fp->flag = mode;		/* Set file access mode */
 80179c8:	68fb      	ldr	r3, [r7, #12]
 80179ca:	79fa      	ldrb	r2, [r7, #7]
 80179cc:	751a      	strb	r2, [r3, #20]
			fp->err = 0;			/* Clear error flag */
 80179ce:	68fb      	ldr	r3, [r7, #12]
 80179d0:	2200      	movs	r2, #0
 80179d2:	755a      	strb	r2, [r3, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 80179d4:	68fb      	ldr	r3, [r7, #12]
 80179d6:	2200      	movs	r2, #0
 80179d8:	621a      	str	r2, [r3, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 80179da:	68fb      	ldr	r3, [r7, #12]
 80179dc:	2200      	movs	r2, #0
 80179de:	619a      	str	r2, [r3, #24]
#if !_FS_READONLY
#if !_FS_TINY
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 80179e0:	68fb      	ldr	r3, [r7, #12]
 80179e2:	3330      	adds	r3, #48	@ 0x30
 80179e4:	f44f 7200 	mov.w	r2, #512	@ 0x200
 80179e8:	2100      	movs	r1, #0
 80179ea:	4618      	mov	r0, r3
 80179ec:	f7fd fca7 	bl	801533e <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 80179f0:	79fb      	ldrb	r3, [r7, #7]
 80179f2:	f003 0320 	and.w	r3, r3, #32
 80179f6:	2b00      	cmp	r3, #0
 80179f8:	d060      	beq.n	8017abc <f_open+0x374>
 80179fa:	68fb      	ldr	r3, [r7, #12]
 80179fc:	68db      	ldr	r3, [r3, #12]
 80179fe:	2b00      	cmp	r3, #0
 8017a00:	d05c      	beq.n	8017abc <f_open+0x374>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 8017a02:	68fb      	ldr	r3, [r7, #12]
 8017a04:	68da      	ldr	r2, [r3, #12]
 8017a06:	68fb      	ldr	r3, [r7, #12]
 8017a08:	619a      	str	r2, [r3, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8017a0a:	693b      	ldr	r3, [r7, #16]
 8017a0c:	895b      	ldrh	r3, [r3, #10]
 8017a0e:	025b      	lsls	r3, r3, #9
 8017a10:	64fb      	str	r3, [r7, #76]	@ 0x4c
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 8017a12:	68fb      	ldr	r3, [r7, #12]
 8017a14:	689b      	ldr	r3, [r3, #8]
 8017a16:	663b      	str	r3, [r7, #96]	@ 0x60
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8017a18:	68fb      	ldr	r3, [r7, #12]
 8017a1a:	68db      	ldr	r3, [r3, #12]
 8017a1c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8017a1e:	e016      	b.n	8017a4e <f_open+0x306>
					clst = get_fat(&fp->obj, clst);
 8017a20:	68fb      	ldr	r3, [r7, #12]
 8017a22:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8017a24:	4618      	mov	r0, r3
 8017a26:	f7fd ff52 	bl	80158ce <get_fat>
 8017a2a:	6638      	str	r0, [r7, #96]	@ 0x60
					if (clst <= 1) res = FR_INT_ERR;
 8017a2c:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017a2e:	2b01      	cmp	r3, #1
 8017a30:	d802      	bhi.n	8017a38 <f_open+0x2f0>
 8017a32:	2302      	movs	r3, #2
 8017a34:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
 8017a38:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
 8017a3a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8017a3e:	d102      	bne.n	8017a46 <f_open+0x2fe>
 8017a40:	2301      	movs	r3, #1
 8017a42:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8017a46:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8017a48:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017a4a:	1ad3      	subs	r3, r2, r3
 8017a4c:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8017a4e:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017a52:	2b00      	cmp	r3, #0
 8017a54:	d103      	bne.n	8017a5e <f_open+0x316>
 8017a56:	6dfa      	ldr	r2, [r7, #92]	@ 0x5c
 8017a58:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 8017a5a:	429a      	cmp	r2, r3
 8017a5c:	d8e0      	bhi.n	8017a20 <f_open+0x2d8>
				}
				fp->clust = clst;
 8017a5e:	68fb      	ldr	r3, [r7, #12]
 8017a60:	6e3a      	ldr	r2, [r7, #96]	@ 0x60
 8017a62:	61da      	str	r2, [r3, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 8017a64:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017a68:	2b00      	cmp	r3, #0
 8017a6a:	d127      	bne.n	8017abc <f_open+0x374>
 8017a6c:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017a6e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8017a72:	2b00      	cmp	r3, #0
 8017a74:	d022      	beq.n	8017abc <f_open+0x374>
					if ((sc = clust2sect(fs, clst)) == 0) {
 8017a76:	693b      	ldr	r3, [r7, #16]
 8017a78:	6e39      	ldr	r1, [r7, #96]	@ 0x60
 8017a7a:	4618      	mov	r0, r3
 8017a7c:	f7fd ff08 	bl	8015890 <clust2sect>
 8017a80:	64b8      	str	r0, [r7, #72]	@ 0x48
 8017a82:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017a84:	2b00      	cmp	r3, #0
 8017a86:	d103      	bne.n	8017a90 <f_open+0x348>
						res = FR_INT_ERR;
 8017a88:	2302      	movs	r3, #2
 8017a8a:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
 8017a8e:	e015      	b.n	8017abc <f_open+0x374>
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 8017a90:	6dfb      	ldr	r3, [r7, #92]	@ 0x5c
 8017a92:	0a5a      	lsrs	r2, r3, #9
 8017a94:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8017a96:	441a      	add	r2, r3
 8017a98:	68fb      	ldr	r3, [r7, #12]
 8017a9a:	621a      	str	r2, [r3, #32]
#if !_FS_TINY
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8017a9c:	693b      	ldr	r3, [r7, #16]
 8017a9e:	7858      	ldrb	r0, [r3, #1]
 8017aa0:	68fb      	ldr	r3, [r7, #12]
 8017aa2:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8017aa6:	68fb      	ldr	r3, [r7, #12]
 8017aa8:	6a1a      	ldr	r2, [r3, #32]
 8017aaa:	2301      	movs	r3, #1
 8017aac:	f7fd fb3e 	bl	801512c <disk_read>
 8017ab0:	4603      	mov	r3, r0
 8017ab2:	2b00      	cmp	r3, #0
 8017ab4:	d002      	beq.n	8017abc <f_open+0x374>
 8017ab6:	2301      	movs	r3, #1
 8017ab8:	f887 3067 	strb.w	r3, [r7, #103]	@ 0x67
				}
			}
#endif
		}

		FREE_NAMBUF();
 8017abc:	6db8      	ldr	r0, [r7, #88]	@ 0x58
 8017abe:	f001 fa1a 	bl	8018ef6 <ff_memfree>
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 8017ac2:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
 8017ac6:	2b00      	cmp	r3, #0
 8017ac8:	d002      	beq.n	8017ad0 <f_open+0x388>
 8017aca:	68fb      	ldr	r3, [r7, #12]
 8017acc:	2200      	movs	r2, #0
 8017ace:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 8017ad0:	f897 3067 	ldrb.w	r3, [r7, #103]	@ 0x67
}
 8017ad4:	4618      	mov	r0, r3
 8017ad6:	3768      	adds	r7, #104	@ 0x68
 8017ad8:	46bd      	mov	sp, r7
 8017ada:	bd80      	pop	{r7, pc}

08017adc <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 8017adc:	b580      	push	{r7, lr}
 8017ade:	b08e      	sub	sp, #56	@ 0x38
 8017ae0:	af00      	add	r7, sp, #0
 8017ae2:	60f8      	str	r0, [r7, #12]
 8017ae4:	60b9      	str	r1, [r7, #8]
 8017ae6:	607a      	str	r2, [r7, #4]
 8017ae8:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;
 8017aea:	68bb      	ldr	r3, [r7, #8]
 8017aec:	627b      	str	r3, [r7, #36]	@ 0x24


	*br = 0;	/* Clear read byte counter */
 8017aee:	683b      	ldr	r3, [r7, #0]
 8017af0:	2200      	movs	r2, #0
 8017af2:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 8017af4:	68fb      	ldr	r3, [r7, #12]
 8017af6:	f107 0214 	add.w	r2, r7, #20
 8017afa:	4611      	mov	r1, r2
 8017afc:	4618      	mov	r0, r3
 8017afe:	f7ff fda7 	bl	8017650 <validate>
 8017b02:	4603      	mov	r3, r0
 8017b04:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8017b08:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8017b0c:	2b00      	cmp	r3, #0
 8017b0e:	d107      	bne.n	8017b20 <f_read+0x44>
 8017b10:	68fb      	ldr	r3, [r7, #12]
 8017b12:	7d5b      	ldrb	r3, [r3, #21]
 8017b14:	f887 3037 	strb.w	r3, [r7, #55]	@ 0x37
 8017b18:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8017b1c:	2b00      	cmp	r3, #0
 8017b1e:	d002      	beq.n	8017b26 <f_read+0x4a>
 8017b20:	f897 3037 	ldrb.w	r3, [r7, #55]	@ 0x37
 8017b24:	e115      	b.n	8017d52 <f_read+0x276>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 8017b26:	68fb      	ldr	r3, [r7, #12]
 8017b28:	7d1b      	ldrb	r3, [r3, #20]
 8017b2a:	f003 0301 	and.w	r3, r3, #1
 8017b2e:	2b00      	cmp	r3, #0
 8017b30:	d101      	bne.n	8017b36 <f_read+0x5a>
 8017b32:	2307      	movs	r3, #7
 8017b34:	e10d      	b.n	8017d52 <f_read+0x276>
	remain = fp->obj.objsize - fp->fptr;
 8017b36:	68fb      	ldr	r3, [r7, #12]
 8017b38:	68da      	ldr	r2, [r3, #12]
 8017b3a:	68fb      	ldr	r3, [r7, #12]
 8017b3c:	699b      	ldr	r3, [r3, #24]
 8017b3e:	1ad3      	subs	r3, r2, r3
 8017b40:	623b      	str	r3, [r7, #32]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 8017b42:	687a      	ldr	r2, [r7, #4]
 8017b44:	6a3b      	ldr	r3, [r7, #32]
 8017b46:	429a      	cmp	r2, r3
 8017b48:	f240 80fe 	bls.w	8017d48 <f_read+0x26c>
 8017b4c:	6a3b      	ldr	r3, [r7, #32]
 8017b4e:	607b      	str	r3, [r7, #4]

	for ( ;  btr;								/* Repeat until all data read */
 8017b50:	e0fa      	b.n	8017d48 <f_read+0x26c>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 8017b52:	68fb      	ldr	r3, [r7, #12]
 8017b54:	699b      	ldr	r3, [r3, #24]
 8017b56:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8017b5a:	2b00      	cmp	r3, #0
 8017b5c:	f040 80c6 	bne.w	8017cec <f_read+0x210>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 8017b60:	68fb      	ldr	r3, [r7, #12]
 8017b62:	699b      	ldr	r3, [r3, #24]
 8017b64:	0a5b      	lsrs	r3, r3, #9
 8017b66:	697a      	ldr	r2, [r7, #20]
 8017b68:	8952      	ldrh	r2, [r2, #10]
 8017b6a:	3a01      	subs	r2, #1
 8017b6c:	4013      	ands	r3, r2
 8017b6e:	61fb      	str	r3, [r7, #28]
			if (csect == 0) {					/* On the cluster boundary? */
 8017b70:	69fb      	ldr	r3, [r7, #28]
 8017b72:	2b00      	cmp	r3, #0
 8017b74:	d12f      	bne.n	8017bd6 <f_read+0xfa>
				if (fp->fptr == 0) {			/* On the top of the file? */
 8017b76:	68fb      	ldr	r3, [r7, #12]
 8017b78:	699b      	ldr	r3, [r3, #24]
 8017b7a:	2b00      	cmp	r3, #0
 8017b7c:	d103      	bne.n	8017b86 <f_read+0xaa>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 8017b7e:	68fb      	ldr	r3, [r7, #12]
 8017b80:	689b      	ldr	r3, [r3, #8]
 8017b82:	633b      	str	r3, [r7, #48]	@ 0x30
 8017b84:	e013      	b.n	8017bae <f_read+0xd2>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
 8017b86:	68fb      	ldr	r3, [r7, #12]
 8017b88:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8017b8a:	2b00      	cmp	r3, #0
 8017b8c:	d007      	beq.n	8017b9e <f_read+0xc2>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 8017b8e:	68fb      	ldr	r3, [r7, #12]
 8017b90:	699b      	ldr	r3, [r3, #24]
 8017b92:	4619      	mov	r1, r3
 8017b94:	68f8      	ldr	r0, [r7, #12]
 8017b96:	f7fe f928 	bl	8015dea <clmt_clust>
 8017b9a:	6338      	str	r0, [r7, #48]	@ 0x30
 8017b9c:	e007      	b.n	8017bae <f_read+0xd2>
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8017b9e:	68fa      	ldr	r2, [r7, #12]
 8017ba0:	68fb      	ldr	r3, [r7, #12]
 8017ba2:	69db      	ldr	r3, [r3, #28]
 8017ba4:	4619      	mov	r1, r3
 8017ba6:	4610      	mov	r0, r2
 8017ba8:	f7fd fe91 	bl	80158ce <get_fat>
 8017bac:	6338      	str	r0, [r7, #48]	@ 0x30
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 8017bae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8017bb0:	2b01      	cmp	r3, #1
 8017bb2:	d804      	bhi.n	8017bbe <f_read+0xe2>
 8017bb4:	68fb      	ldr	r3, [r7, #12]
 8017bb6:	2202      	movs	r2, #2
 8017bb8:	755a      	strb	r2, [r3, #21]
 8017bba:	2302      	movs	r3, #2
 8017bbc:	e0c9      	b.n	8017d52 <f_read+0x276>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017bbe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8017bc0:	f1b3 3fff 	cmp.w	r3, #4294967295
 8017bc4:	d104      	bne.n	8017bd0 <f_read+0xf4>
 8017bc6:	68fb      	ldr	r3, [r7, #12]
 8017bc8:	2201      	movs	r2, #1
 8017bca:	755a      	strb	r2, [r3, #21]
 8017bcc:	2301      	movs	r3, #1
 8017bce:	e0c0      	b.n	8017d52 <f_read+0x276>
				fp->clust = clst;				/* Update current cluster */
 8017bd0:	68fb      	ldr	r3, [r7, #12]
 8017bd2:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8017bd4:	61da      	str	r2, [r3, #28]
			}
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 8017bd6:	697a      	ldr	r2, [r7, #20]
 8017bd8:	68fb      	ldr	r3, [r7, #12]
 8017bda:	69db      	ldr	r3, [r3, #28]
 8017bdc:	4619      	mov	r1, r3
 8017bde:	4610      	mov	r0, r2
 8017be0:	f7fd fe56 	bl	8015890 <clust2sect>
 8017be4:	61b8      	str	r0, [r7, #24]
			if (!sect) ABORT(fs, FR_INT_ERR);
 8017be6:	69bb      	ldr	r3, [r7, #24]
 8017be8:	2b00      	cmp	r3, #0
 8017bea:	d104      	bne.n	8017bf6 <f_read+0x11a>
 8017bec:	68fb      	ldr	r3, [r7, #12]
 8017bee:	2202      	movs	r2, #2
 8017bf0:	755a      	strb	r2, [r3, #21]
 8017bf2:	2302      	movs	r3, #2
 8017bf4:	e0ad      	b.n	8017d52 <f_read+0x276>
			sect += csect;
 8017bf6:	69ba      	ldr	r2, [r7, #24]
 8017bf8:	69fb      	ldr	r3, [r7, #28]
 8017bfa:	4413      	add	r3, r2
 8017bfc:	61bb      	str	r3, [r7, #24]
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
 8017bfe:	687b      	ldr	r3, [r7, #4]
 8017c00:	0a5b      	lsrs	r3, r3, #9
 8017c02:	62bb      	str	r3, [r7, #40]	@ 0x28
			if (cc) {							/* Read maximum contiguous sectors directly */
 8017c04:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017c06:	2b00      	cmp	r3, #0
 8017c08:	d039      	beq.n	8017c7e <f_read+0x1a2>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8017c0a:	69fa      	ldr	r2, [r7, #28]
 8017c0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017c0e:	4413      	add	r3, r2
 8017c10:	697a      	ldr	r2, [r7, #20]
 8017c12:	8952      	ldrh	r2, [r2, #10]
 8017c14:	4293      	cmp	r3, r2
 8017c16:	d905      	bls.n	8017c24 <f_read+0x148>
					cc = fs->csize - csect;
 8017c18:	697b      	ldr	r3, [r7, #20]
 8017c1a:	895b      	ldrh	r3, [r3, #10]
 8017c1c:	461a      	mov	r2, r3
 8017c1e:	69fb      	ldr	r3, [r7, #28]
 8017c20:	1ad3      	subs	r3, r2, r3
 8017c22:	62bb      	str	r3, [r7, #40]	@ 0x28
				}
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017c24:	697b      	ldr	r3, [r7, #20]
 8017c26:	7858      	ldrb	r0, [r3, #1]
 8017c28:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017c2a:	69ba      	ldr	r2, [r7, #24]
 8017c2c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8017c2e:	f7fd fa7d 	bl	801512c <disk_read>
 8017c32:	4603      	mov	r3, r0
 8017c34:	2b00      	cmp	r3, #0
 8017c36:	d004      	beq.n	8017c42 <f_read+0x166>
 8017c38:	68fb      	ldr	r3, [r7, #12]
 8017c3a:	2201      	movs	r2, #1
 8017c3c:	755a      	strb	r2, [r3, #21]
 8017c3e:	2301      	movs	r3, #1
 8017c40:	e087      	b.n	8017d52 <f_read+0x276>
#if _FS_TINY
				if (fs->wflag && fs->winsect - sect < cc) {
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 8017c42:	68fb      	ldr	r3, [r7, #12]
 8017c44:	7d1b      	ldrb	r3, [r3, #20]
 8017c46:	b25b      	sxtb	r3, r3
 8017c48:	2b00      	cmp	r3, #0
 8017c4a:	da14      	bge.n	8017c76 <f_read+0x19a>
 8017c4c:	68fb      	ldr	r3, [r7, #12]
 8017c4e:	6a1a      	ldr	r2, [r3, #32]
 8017c50:	69bb      	ldr	r3, [r7, #24]
 8017c52:	1ad3      	subs	r3, r2, r3
 8017c54:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017c56:	429a      	cmp	r2, r3
 8017c58:	d90d      	bls.n	8017c76 <f_read+0x19a>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
 8017c5a:	68fb      	ldr	r3, [r7, #12]
 8017c5c:	6a1a      	ldr	r2, [r3, #32]
 8017c5e:	69bb      	ldr	r3, [r7, #24]
 8017c60:	1ad3      	subs	r3, r2, r3
 8017c62:	025b      	lsls	r3, r3, #9
 8017c64:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017c66:	18d0      	adds	r0, r2, r3
 8017c68:	68fb      	ldr	r3, [r7, #12]
 8017c6a:	3330      	adds	r3, #48	@ 0x30
 8017c6c:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8017c70:	4619      	mov	r1, r3
 8017c72:	f7fd fb43 	bl	80152fc <mem_cpy>
				}
#endif
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 8017c76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017c78:	025b      	lsls	r3, r3, #9
 8017c7a:	62fb      	str	r3, [r7, #44]	@ 0x2c
				continue;
 8017c7c:	e050      	b.n	8017d20 <f_read+0x244>
			}
#if !_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 8017c7e:	68fb      	ldr	r3, [r7, #12]
 8017c80:	6a1b      	ldr	r3, [r3, #32]
 8017c82:	69ba      	ldr	r2, [r7, #24]
 8017c84:	429a      	cmp	r2, r3
 8017c86:	d02e      	beq.n	8017ce6 <f_read+0x20a>
#if !_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8017c88:	68fb      	ldr	r3, [r7, #12]
 8017c8a:	7d1b      	ldrb	r3, [r3, #20]
 8017c8c:	b25b      	sxtb	r3, r3
 8017c8e:	2b00      	cmp	r3, #0
 8017c90:	da18      	bge.n	8017cc4 <f_read+0x1e8>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017c92:	697b      	ldr	r3, [r7, #20]
 8017c94:	7858      	ldrb	r0, [r3, #1]
 8017c96:	68fb      	ldr	r3, [r7, #12]
 8017c98:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8017c9c:	68fb      	ldr	r3, [r7, #12]
 8017c9e:	6a1a      	ldr	r2, [r3, #32]
 8017ca0:	2301      	movs	r3, #1
 8017ca2:	f7fd fa63 	bl	801516c <disk_write>
 8017ca6:	4603      	mov	r3, r0
 8017ca8:	2b00      	cmp	r3, #0
 8017caa:	d004      	beq.n	8017cb6 <f_read+0x1da>
 8017cac:	68fb      	ldr	r3, [r7, #12]
 8017cae:	2201      	movs	r2, #1
 8017cb0:	755a      	strb	r2, [r3, #21]
 8017cb2:	2301      	movs	r3, #1
 8017cb4:	e04d      	b.n	8017d52 <f_read+0x276>
					fp->flag &= (BYTE)~FA_DIRTY;
 8017cb6:	68fb      	ldr	r3, [r7, #12]
 8017cb8:	7d1b      	ldrb	r3, [r3, #20]
 8017cba:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8017cbe:	b2da      	uxtb	r2, r3
 8017cc0:	68fb      	ldr	r3, [r7, #12]
 8017cc2:	751a      	strb	r2, [r3, #20]
				}
#endif
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8017cc4:	697b      	ldr	r3, [r7, #20]
 8017cc6:	7858      	ldrb	r0, [r3, #1]
 8017cc8:	68fb      	ldr	r3, [r7, #12]
 8017cca:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8017cce:	2301      	movs	r3, #1
 8017cd0:	69ba      	ldr	r2, [r7, #24]
 8017cd2:	f7fd fa2b 	bl	801512c <disk_read>
 8017cd6:	4603      	mov	r3, r0
 8017cd8:	2b00      	cmp	r3, #0
 8017cda:	d004      	beq.n	8017ce6 <f_read+0x20a>
 8017cdc:	68fb      	ldr	r3, [r7, #12]
 8017cde:	2201      	movs	r2, #1
 8017ce0:	755a      	strb	r2, [r3, #21]
 8017ce2:	2301      	movs	r3, #1
 8017ce4:	e035      	b.n	8017d52 <f_read+0x276>
			}
#endif
			fp->sect = sect;
 8017ce6:	68fb      	ldr	r3, [r7, #12]
 8017ce8:	69ba      	ldr	r2, [r7, #24]
 8017cea:	621a      	str	r2, [r3, #32]
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8017cec:	68fb      	ldr	r3, [r7, #12]
 8017cee:	699b      	ldr	r3, [r3, #24]
 8017cf0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8017cf4:	f5c3 7300 	rsb	r3, r3, #512	@ 0x200
 8017cf8:	62fb      	str	r3, [r7, #44]	@ 0x2c
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
 8017cfa:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8017cfc:	687b      	ldr	r3, [r7, #4]
 8017cfe:	429a      	cmp	r2, r3
 8017d00:	d901      	bls.n	8017d06 <f_read+0x22a>
 8017d02:	687b      	ldr	r3, [r7, #4]
 8017d04:	62fb      	str	r3, [r7, #44]	@ 0x2c
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 8017d06:	68fb      	ldr	r3, [r7, #12]
 8017d08:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 8017d0c:	68fb      	ldr	r3, [r7, #12]
 8017d0e:	699b      	ldr	r3, [r3, #24]
 8017d10:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8017d14:	4413      	add	r3, r2
 8017d16:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8017d18:	4619      	mov	r1, r3
 8017d1a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8017d1c:	f7fd faee 	bl	80152fc <mem_cpy>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 8017d20:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017d22:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017d24:	4413      	add	r3, r2
 8017d26:	627b      	str	r3, [r7, #36]	@ 0x24
 8017d28:	68fb      	ldr	r3, [r7, #12]
 8017d2a:	699a      	ldr	r2, [r3, #24]
 8017d2c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017d2e:	441a      	add	r2, r3
 8017d30:	68fb      	ldr	r3, [r7, #12]
 8017d32:	619a      	str	r2, [r3, #24]
 8017d34:	683b      	ldr	r3, [r7, #0]
 8017d36:	681a      	ldr	r2, [r3, #0]
 8017d38:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017d3a:	441a      	add	r2, r3
 8017d3c:	683b      	ldr	r3, [r7, #0]
 8017d3e:	601a      	str	r2, [r3, #0]
 8017d40:	687a      	ldr	r2, [r7, #4]
 8017d42:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8017d44:	1ad3      	subs	r3, r2, r3
 8017d46:	607b      	str	r3, [r7, #4]
	for ( ;  btr;								/* Repeat until all data read */
 8017d48:	687b      	ldr	r3, [r7, #4]
 8017d4a:	2b00      	cmp	r3, #0
 8017d4c:	f47f af01 	bne.w	8017b52 <f_read+0x76>
#endif
	}

	LEAVE_FF(fs, FR_OK);
 8017d50:	2300      	movs	r3, #0
}
 8017d52:	4618      	mov	r0, r3
 8017d54:	3738      	adds	r7, #56	@ 0x38
 8017d56:	46bd      	mov	sp, r7
 8017d58:	bd80      	pop	{r7, pc}

08017d5a <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 8017d5a:	b580      	push	{r7, lr}
 8017d5c:	b08c      	sub	sp, #48	@ 0x30
 8017d5e:	af00      	add	r7, sp, #0
 8017d60:	60f8      	str	r0, [r7, #12]
 8017d62:	60b9      	str	r1, [r7, #8]
 8017d64:	607a      	str	r2, [r7, #4]
 8017d66:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;
 8017d68:	68bb      	ldr	r3, [r7, #8]
 8017d6a:	61fb      	str	r3, [r7, #28]


	*bw = 0;	/* Clear write byte counter */
 8017d6c:	683b      	ldr	r3, [r7, #0]
 8017d6e:	2200      	movs	r2, #0
 8017d70:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8017d72:	68fb      	ldr	r3, [r7, #12]
 8017d74:	f107 0210 	add.w	r2, r7, #16
 8017d78:	4611      	mov	r1, r2
 8017d7a:	4618      	mov	r0, r3
 8017d7c:	f7ff fc68 	bl	8017650 <validate>
 8017d80:	4603      	mov	r3, r0
 8017d82:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8017d86:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8017d8a:	2b00      	cmp	r3, #0
 8017d8c:	d107      	bne.n	8017d9e <f_write+0x44>
 8017d8e:	68fb      	ldr	r3, [r7, #12]
 8017d90:	7d5b      	ldrb	r3, [r3, #21]
 8017d92:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 8017d96:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8017d9a:	2b00      	cmp	r3, #0
 8017d9c:	d002      	beq.n	8017da4 <f_write+0x4a>
 8017d9e:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8017da2:	e14b      	b.n	801803c <f_write+0x2e2>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8017da4:	68fb      	ldr	r3, [r7, #12]
 8017da6:	7d1b      	ldrb	r3, [r3, #20]
 8017da8:	f003 0302 	and.w	r3, r3, #2
 8017dac:	2b00      	cmp	r3, #0
 8017dae:	d101      	bne.n	8017db4 <f_write+0x5a>
 8017db0:	2307      	movs	r3, #7
 8017db2:	e143      	b.n	801803c <f_write+0x2e2>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8017db4:	68fb      	ldr	r3, [r7, #12]
 8017db6:	699a      	ldr	r2, [r3, #24]
 8017db8:	687b      	ldr	r3, [r7, #4]
 8017dba:	441a      	add	r2, r3
 8017dbc:	68fb      	ldr	r3, [r7, #12]
 8017dbe:	699b      	ldr	r3, [r3, #24]
 8017dc0:	429a      	cmp	r2, r3
 8017dc2:	f080 812d 	bcs.w	8018020 <f_write+0x2c6>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 8017dc6:	68fb      	ldr	r3, [r7, #12]
 8017dc8:	699b      	ldr	r3, [r3, #24]
 8017dca:	43db      	mvns	r3, r3
 8017dcc:	607b      	str	r3, [r7, #4]
	}

	for ( ;  btw;							/* Repeat until all data written */
 8017dce:	e127      	b.n	8018020 <f_write+0x2c6>
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8017dd0:	68fb      	ldr	r3, [r7, #12]
 8017dd2:	699b      	ldr	r3, [r3, #24]
 8017dd4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8017dd8:	2b00      	cmp	r3, #0
 8017dda:	f040 80e3 	bne.w	8017fa4 <f_write+0x24a>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8017dde:	68fb      	ldr	r3, [r7, #12]
 8017de0:	699b      	ldr	r3, [r3, #24]
 8017de2:	0a5b      	lsrs	r3, r3, #9
 8017de4:	693a      	ldr	r2, [r7, #16]
 8017de6:	8952      	ldrh	r2, [r2, #10]
 8017de8:	3a01      	subs	r2, #1
 8017dea:	4013      	ands	r3, r2
 8017dec:	61bb      	str	r3, [r7, #24]
			if (csect == 0) {				/* On the cluster boundary? */
 8017dee:	69bb      	ldr	r3, [r7, #24]
 8017df0:	2b00      	cmp	r3, #0
 8017df2:	d143      	bne.n	8017e7c <f_write+0x122>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8017df4:	68fb      	ldr	r3, [r7, #12]
 8017df6:	699b      	ldr	r3, [r3, #24]
 8017df8:	2b00      	cmp	r3, #0
 8017dfa:	d10c      	bne.n	8017e16 <f_write+0xbc>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8017dfc:	68fb      	ldr	r3, [r7, #12]
 8017dfe:	689b      	ldr	r3, [r3, #8]
 8017e00:	62bb      	str	r3, [r7, #40]	@ 0x28
					if (clst == 0) {		/* If no cluster is allocated, */
 8017e02:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e04:	2b00      	cmp	r3, #0
 8017e06:	d11a      	bne.n	8017e3e <f_write+0xe4>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 8017e08:	68fb      	ldr	r3, [r7, #12]
 8017e0a:	2100      	movs	r1, #0
 8017e0c:	4618      	mov	r0, r3
 8017e0e:	f7fd ff54 	bl	8015cba <create_chain>
 8017e12:	62b8      	str	r0, [r7, #40]	@ 0x28
 8017e14:	e013      	b.n	8017e3e <f_write+0xe4>
					}
				} else {					/* On the middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
 8017e16:	68fb      	ldr	r3, [r7, #12]
 8017e18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8017e1a:	2b00      	cmp	r3, #0
 8017e1c:	d007      	beq.n	8017e2e <f_write+0xd4>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 8017e1e:	68fb      	ldr	r3, [r7, #12]
 8017e20:	699b      	ldr	r3, [r3, #24]
 8017e22:	4619      	mov	r1, r3
 8017e24:	68f8      	ldr	r0, [r7, #12]
 8017e26:	f7fd ffe0 	bl	8015dea <clmt_clust>
 8017e2a:	62b8      	str	r0, [r7, #40]	@ 0x28
 8017e2c:	e007      	b.n	8017e3e <f_write+0xe4>
					} else
#endif
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8017e2e:	68fa      	ldr	r2, [r7, #12]
 8017e30:	68fb      	ldr	r3, [r7, #12]
 8017e32:	69db      	ldr	r3, [r3, #28]
 8017e34:	4619      	mov	r1, r3
 8017e36:	4610      	mov	r0, r2
 8017e38:	f7fd ff3f 	bl	8015cba <create_chain>
 8017e3c:	62b8      	str	r0, [r7, #40]	@ 0x28
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 8017e3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e40:	2b00      	cmp	r3, #0
 8017e42:	f000 80f2 	beq.w	801802a <f_write+0x2d0>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8017e46:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e48:	2b01      	cmp	r3, #1
 8017e4a:	d104      	bne.n	8017e56 <f_write+0xfc>
 8017e4c:	68fb      	ldr	r3, [r7, #12]
 8017e4e:	2202      	movs	r2, #2
 8017e50:	755a      	strb	r2, [r3, #21]
 8017e52:	2302      	movs	r3, #2
 8017e54:	e0f2      	b.n	801803c <f_write+0x2e2>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8017e56:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8017e58:	f1b3 3fff 	cmp.w	r3, #4294967295
 8017e5c:	d104      	bne.n	8017e68 <f_write+0x10e>
 8017e5e:	68fb      	ldr	r3, [r7, #12]
 8017e60:	2201      	movs	r2, #1
 8017e62:	755a      	strb	r2, [r3, #21]
 8017e64:	2301      	movs	r3, #1
 8017e66:	e0e9      	b.n	801803c <f_write+0x2e2>
				fp->clust = clst;			/* Update current cluster */
 8017e68:	68fb      	ldr	r3, [r7, #12]
 8017e6a:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017e6c:	61da      	str	r2, [r3, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8017e6e:	68fb      	ldr	r3, [r7, #12]
 8017e70:	689b      	ldr	r3, [r3, #8]
 8017e72:	2b00      	cmp	r3, #0
 8017e74:	d102      	bne.n	8017e7c <f_write+0x122>
 8017e76:	68fb      	ldr	r3, [r7, #12]
 8017e78:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8017e7a:	609a      	str	r2, [r3, #8]
			}
#if _FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 8017e7c:	68fb      	ldr	r3, [r7, #12]
 8017e7e:	7d1b      	ldrb	r3, [r3, #20]
 8017e80:	b25b      	sxtb	r3, r3
 8017e82:	2b00      	cmp	r3, #0
 8017e84:	da18      	bge.n	8017eb8 <f_write+0x15e>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017e86:	693b      	ldr	r3, [r7, #16]
 8017e88:	7858      	ldrb	r0, [r3, #1]
 8017e8a:	68fb      	ldr	r3, [r7, #12]
 8017e8c:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8017e90:	68fb      	ldr	r3, [r7, #12]
 8017e92:	6a1a      	ldr	r2, [r3, #32]
 8017e94:	2301      	movs	r3, #1
 8017e96:	f7fd f969 	bl	801516c <disk_write>
 8017e9a:	4603      	mov	r3, r0
 8017e9c:	2b00      	cmp	r3, #0
 8017e9e:	d004      	beq.n	8017eaa <f_write+0x150>
 8017ea0:	68fb      	ldr	r3, [r7, #12]
 8017ea2:	2201      	movs	r2, #1
 8017ea4:	755a      	strb	r2, [r3, #21]
 8017ea6:	2301      	movs	r3, #1
 8017ea8:	e0c8      	b.n	801803c <f_write+0x2e2>
				fp->flag &= (BYTE)~FA_DIRTY;
 8017eaa:	68fb      	ldr	r3, [r7, #12]
 8017eac:	7d1b      	ldrb	r3, [r3, #20]
 8017eae:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8017eb2:	b2da      	uxtb	r2, r3
 8017eb4:	68fb      	ldr	r3, [r7, #12]
 8017eb6:	751a      	strb	r2, [r3, #20]
			}
#endif
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 8017eb8:	693a      	ldr	r2, [r7, #16]
 8017eba:	68fb      	ldr	r3, [r7, #12]
 8017ebc:	69db      	ldr	r3, [r3, #28]
 8017ebe:	4619      	mov	r1, r3
 8017ec0:	4610      	mov	r0, r2
 8017ec2:	f7fd fce5 	bl	8015890 <clust2sect>
 8017ec6:	6178      	str	r0, [r7, #20]
			if (!sect) ABORT(fs, FR_INT_ERR);
 8017ec8:	697b      	ldr	r3, [r7, #20]
 8017eca:	2b00      	cmp	r3, #0
 8017ecc:	d104      	bne.n	8017ed8 <f_write+0x17e>
 8017ece:	68fb      	ldr	r3, [r7, #12]
 8017ed0:	2202      	movs	r2, #2
 8017ed2:	755a      	strb	r2, [r3, #21]
 8017ed4:	2302      	movs	r3, #2
 8017ed6:	e0b1      	b.n	801803c <f_write+0x2e2>
			sect += csect;
 8017ed8:	697a      	ldr	r2, [r7, #20]
 8017eda:	69bb      	ldr	r3, [r7, #24]
 8017edc:	4413      	add	r3, r2
 8017ede:	617b      	str	r3, [r7, #20]
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
 8017ee0:	687b      	ldr	r3, [r7, #4]
 8017ee2:	0a5b      	lsrs	r3, r3, #9
 8017ee4:	623b      	str	r3, [r7, #32]
			if (cc) {						/* Write maximum contiguous sectors directly */
 8017ee6:	6a3b      	ldr	r3, [r7, #32]
 8017ee8:	2b00      	cmp	r3, #0
 8017eea:	d03c      	beq.n	8017f66 <f_write+0x20c>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8017eec:	69ba      	ldr	r2, [r7, #24]
 8017eee:	6a3b      	ldr	r3, [r7, #32]
 8017ef0:	4413      	add	r3, r2
 8017ef2:	693a      	ldr	r2, [r7, #16]
 8017ef4:	8952      	ldrh	r2, [r2, #10]
 8017ef6:	4293      	cmp	r3, r2
 8017ef8:	d905      	bls.n	8017f06 <f_write+0x1ac>
					cc = fs->csize - csect;
 8017efa:	693b      	ldr	r3, [r7, #16]
 8017efc:	895b      	ldrh	r3, [r3, #10]
 8017efe:	461a      	mov	r2, r3
 8017f00:	69bb      	ldr	r3, [r7, #24]
 8017f02:	1ad3      	subs	r3, r2, r3
 8017f04:	623b      	str	r3, [r7, #32]
				}
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8017f06:	693b      	ldr	r3, [r7, #16]
 8017f08:	7858      	ldrb	r0, [r3, #1]
 8017f0a:	6a3b      	ldr	r3, [r7, #32]
 8017f0c:	697a      	ldr	r2, [r7, #20]
 8017f0e:	69f9      	ldr	r1, [r7, #28]
 8017f10:	f7fd f92c 	bl	801516c <disk_write>
 8017f14:	4603      	mov	r3, r0
 8017f16:	2b00      	cmp	r3, #0
 8017f18:	d004      	beq.n	8017f24 <f_write+0x1ca>
 8017f1a:	68fb      	ldr	r3, [r7, #12]
 8017f1c:	2201      	movs	r2, #1
 8017f1e:	755a      	strb	r2, [r3, #21]
 8017f20:	2301      	movs	r3, #1
 8017f22:	e08b      	b.n	801803c <f_write+0x2e2>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 8017f24:	68fb      	ldr	r3, [r7, #12]
 8017f26:	6a1a      	ldr	r2, [r3, #32]
 8017f28:	697b      	ldr	r3, [r7, #20]
 8017f2a:	1ad3      	subs	r3, r2, r3
 8017f2c:	6a3a      	ldr	r2, [r7, #32]
 8017f2e:	429a      	cmp	r2, r3
 8017f30:	d915      	bls.n	8017f5e <f_write+0x204>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
 8017f32:	68fb      	ldr	r3, [r7, #12]
 8017f34:	f103 0030 	add.w	r0, r3, #48	@ 0x30
 8017f38:	68fb      	ldr	r3, [r7, #12]
 8017f3a:	6a1a      	ldr	r2, [r3, #32]
 8017f3c:	697b      	ldr	r3, [r7, #20]
 8017f3e:	1ad3      	subs	r3, r2, r3
 8017f40:	025b      	lsls	r3, r3, #9
 8017f42:	69fa      	ldr	r2, [r7, #28]
 8017f44:	4413      	add	r3, r2
 8017f46:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8017f4a:	4619      	mov	r1, r3
 8017f4c:	f7fd f9d6 	bl	80152fc <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
 8017f50:	68fb      	ldr	r3, [r7, #12]
 8017f52:	7d1b      	ldrb	r3, [r3, #20]
 8017f54:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8017f58:	b2da      	uxtb	r2, r3
 8017f5a:	68fb      	ldr	r3, [r7, #12]
 8017f5c:	751a      	strb	r2, [r3, #20]
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 8017f5e:	6a3b      	ldr	r3, [r7, #32]
 8017f60:	025b      	lsls	r3, r3, #9
 8017f62:	627b      	str	r3, [r7, #36]	@ 0x24
				continue;
 8017f64:	e03f      	b.n	8017fe6 <f_write+0x28c>
			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
				fs->winsect = sect;
			}
#else
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8017f66:	68fb      	ldr	r3, [r7, #12]
 8017f68:	6a1b      	ldr	r3, [r3, #32]
 8017f6a:	697a      	ldr	r2, [r7, #20]
 8017f6c:	429a      	cmp	r2, r3
 8017f6e:	d016      	beq.n	8017f9e <f_write+0x244>
				fp->fptr < fp->obj.objsize &&
 8017f70:	68fb      	ldr	r3, [r7, #12]
 8017f72:	699a      	ldr	r2, [r3, #24]
 8017f74:	68fb      	ldr	r3, [r7, #12]
 8017f76:	68db      	ldr	r3, [r3, #12]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 8017f78:	429a      	cmp	r2, r3
 8017f7a:	d210      	bcs.n	8017f9e <f_write+0x244>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
 8017f7c:	693b      	ldr	r3, [r7, #16]
 8017f7e:	7858      	ldrb	r0, [r3, #1]
 8017f80:	68fb      	ldr	r3, [r7, #12]
 8017f82:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8017f86:	2301      	movs	r3, #1
 8017f88:	697a      	ldr	r2, [r7, #20]
 8017f8a:	f7fd f8cf 	bl	801512c <disk_read>
 8017f8e:	4603      	mov	r3, r0
				fp->fptr < fp->obj.objsize &&
 8017f90:	2b00      	cmp	r3, #0
 8017f92:	d004      	beq.n	8017f9e <f_write+0x244>
					ABORT(fs, FR_DISK_ERR);
 8017f94:	68fb      	ldr	r3, [r7, #12]
 8017f96:	2201      	movs	r2, #1
 8017f98:	755a      	strb	r2, [r3, #21]
 8017f9a:	2301      	movs	r3, #1
 8017f9c:	e04e      	b.n	801803c <f_write+0x2e2>
			}
#endif
			fp->sect = sect;
 8017f9e:	68fb      	ldr	r3, [r7, #12]
 8017fa0:	697a      	ldr	r2, [r7, #20]
 8017fa2:	621a      	str	r2, [r3, #32]
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8017fa4:	68fb      	ldr	r3, [r7, #12]
 8017fa6:	699b      	ldr	r3, [r3, #24]
 8017fa8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8017fac:	f5c3 7300 	rsb	r3, r3, #512	@ 0x200
 8017fb0:	627b      	str	r3, [r7, #36]	@ 0x24
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
 8017fb2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017fb4:	687b      	ldr	r3, [r7, #4]
 8017fb6:	429a      	cmp	r2, r3
 8017fb8:	d901      	bls.n	8017fbe <f_write+0x264>
 8017fba:	687b      	ldr	r3, [r7, #4]
 8017fbc:	627b      	str	r3, [r7, #36]	@ 0x24
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8017fbe:	68fb      	ldr	r3, [r7, #12]
 8017fc0:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 8017fc4:	68fb      	ldr	r3, [r7, #12]
 8017fc6:	699b      	ldr	r3, [r3, #24]
 8017fc8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8017fcc:	4413      	add	r3, r2
 8017fce:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8017fd0:	69f9      	ldr	r1, [r7, #28]
 8017fd2:	4618      	mov	r0, r3
 8017fd4:	f7fd f992 	bl	80152fc <mem_cpy>
		fp->flag |= FA_DIRTY;
 8017fd8:	68fb      	ldr	r3, [r7, #12]
 8017fda:	7d1b      	ldrb	r3, [r3, #20]
 8017fdc:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 8017fe0:	b2da      	uxtb	r2, r3
 8017fe2:	68fb      	ldr	r3, [r7, #12]
 8017fe4:	751a      	strb	r2, [r3, #20]
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 8017fe6:	69fa      	ldr	r2, [r7, #28]
 8017fe8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017fea:	4413      	add	r3, r2
 8017fec:	61fb      	str	r3, [r7, #28]
 8017fee:	68fb      	ldr	r3, [r7, #12]
 8017ff0:	699a      	ldr	r2, [r3, #24]
 8017ff2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8017ff4:	441a      	add	r2, r3
 8017ff6:	68fb      	ldr	r3, [r7, #12]
 8017ff8:	619a      	str	r2, [r3, #24]
 8017ffa:	68fb      	ldr	r3, [r7, #12]
 8017ffc:	68da      	ldr	r2, [r3, #12]
 8017ffe:	68fb      	ldr	r3, [r7, #12]
 8018000:	699b      	ldr	r3, [r3, #24]
 8018002:	429a      	cmp	r2, r3
 8018004:	bf38      	it	cc
 8018006:	461a      	movcc	r2, r3
 8018008:	68fb      	ldr	r3, [r7, #12]
 801800a:	60da      	str	r2, [r3, #12]
 801800c:	683b      	ldr	r3, [r7, #0]
 801800e:	681a      	ldr	r2, [r3, #0]
 8018010:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018012:	441a      	add	r2, r3
 8018014:	683b      	ldr	r3, [r7, #0]
 8018016:	601a      	str	r2, [r3, #0]
 8018018:	687a      	ldr	r2, [r7, #4]
 801801a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801801c:	1ad3      	subs	r3, r2, r3
 801801e:	607b      	str	r3, [r7, #4]
	for ( ;  btw;							/* Repeat until all data written */
 8018020:	687b      	ldr	r3, [r7, #4]
 8018022:	2b00      	cmp	r3, #0
 8018024:	f47f aed4 	bne.w	8017dd0 <f_write+0x76>
 8018028:	e000      	b.n	801802c <f_write+0x2d2>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 801802a:	bf00      	nop
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 801802c:	68fb      	ldr	r3, [r7, #12]
 801802e:	7d1b      	ldrb	r3, [r3, #20]
 8018030:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8018034:	b2da      	uxtb	r2, r3
 8018036:	68fb      	ldr	r3, [r7, #12]
 8018038:	751a      	strb	r2, [r3, #20]

	LEAVE_FF(fs, FR_OK);
 801803a:	2300      	movs	r3, #0
}
 801803c:	4618      	mov	r0, r3
 801803e:	3730      	adds	r7, #48	@ 0x30
 8018040:	46bd      	mov	sp, r7
 8018042:	bd80      	pop	{r7, pc}

08018044 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 8018044:	b580      	push	{r7, lr}
 8018046:	b086      	sub	sp, #24
 8018048:	af00      	add	r7, sp, #0
 801804a:	6078      	str	r0, [r7, #4]
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 801804c:	687b      	ldr	r3, [r7, #4]
 801804e:	f107 0208 	add.w	r2, r7, #8
 8018052:	4611      	mov	r1, r2
 8018054:	4618      	mov	r0, r3
 8018056:	f7ff fafb 	bl	8017650 <validate>
 801805a:	4603      	mov	r3, r0
 801805c:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 801805e:	7dfb      	ldrb	r3, [r7, #23]
 8018060:	2b00      	cmp	r3, #0
 8018062:	d168      	bne.n	8018136 <f_sync+0xf2>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8018064:	687b      	ldr	r3, [r7, #4]
 8018066:	7d1b      	ldrb	r3, [r3, #20]
 8018068:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801806c:	2b00      	cmp	r3, #0
 801806e:	d062      	beq.n	8018136 <f_sync+0xf2>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 8018070:	687b      	ldr	r3, [r7, #4]
 8018072:	7d1b      	ldrb	r3, [r3, #20]
 8018074:	b25b      	sxtb	r3, r3
 8018076:	2b00      	cmp	r3, #0
 8018078:	da15      	bge.n	80180a6 <f_sync+0x62>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 801807a:	68bb      	ldr	r3, [r7, #8]
 801807c:	7858      	ldrb	r0, [r3, #1]
 801807e:	687b      	ldr	r3, [r7, #4]
 8018080:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 8018084:	687b      	ldr	r3, [r7, #4]
 8018086:	6a1a      	ldr	r2, [r3, #32]
 8018088:	2301      	movs	r3, #1
 801808a:	f7fd f86f 	bl	801516c <disk_write>
 801808e:	4603      	mov	r3, r0
 8018090:	2b00      	cmp	r3, #0
 8018092:	d001      	beq.n	8018098 <f_sync+0x54>
 8018094:	2301      	movs	r3, #1
 8018096:	e04f      	b.n	8018138 <f_sync+0xf4>
				fp->flag &= (BYTE)~FA_DIRTY;
 8018098:	687b      	ldr	r3, [r7, #4]
 801809a:	7d1b      	ldrb	r3, [r3, #20]
 801809c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80180a0:	b2da      	uxtb	r2, r3
 80180a2:	687b      	ldr	r3, [r7, #4]
 80180a4:	751a      	strb	r2, [r3, #20]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 80180a6:	f7fd f89f 	bl	80151e8 <get_fattime>
 80180aa:	6138      	str	r0, [r7, #16]
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 80180ac:	68ba      	ldr	r2, [r7, #8]
 80180ae:	687b      	ldr	r3, [r7, #4]
 80180b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80180b2:	4619      	mov	r1, r3
 80180b4:	4610      	mov	r0, r2
 80180b6:	f7fd fb4f 	bl	8015758 <move_window>
 80180ba:	4603      	mov	r3, r0
 80180bc:	75fb      	strb	r3, [r7, #23]
				if (res == FR_OK) {
 80180be:	7dfb      	ldrb	r3, [r7, #23]
 80180c0:	2b00      	cmp	r3, #0
 80180c2:	d138      	bne.n	8018136 <f_sync+0xf2>
					dir = fp->dir_ptr;
 80180c4:	687b      	ldr	r3, [r7, #4]
 80180c6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80180c8:	60fb      	str	r3, [r7, #12]
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 80180ca:	68fb      	ldr	r3, [r7, #12]
 80180cc:	330b      	adds	r3, #11
 80180ce:	781a      	ldrb	r2, [r3, #0]
 80180d0:	68fb      	ldr	r3, [r7, #12]
 80180d2:	330b      	adds	r3, #11
 80180d4:	f042 0220 	orr.w	r2, r2, #32
 80180d8:	b2d2      	uxtb	r2, r2
 80180da:	701a      	strb	r2, [r3, #0]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 80180dc:	687b      	ldr	r3, [r7, #4]
 80180de:	6818      	ldr	r0, [r3, #0]
 80180e0:	687b      	ldr	r3, [r7, #4]
 80180e2:	689b      	ldr	r3, [r3, #8]
 80180e4:	461a      	mov	r2, r3
 80180e6:	68f9      	ldr	r1, [r7, #12]
 80180e8:	f7fe f859 	bl	801619e <st_clust>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 80180ec:	68fb      	ldr	r3, [r7, #12]
 80180ee:	f103 021c 	add.w	r2, r3, #28
 80180f2:	687b      	ldr	r3, [r7, #4]
 80180f4:	68db      	ldr	r3, [r3, #12]
 80180f6:	4619      	mov	r1, r3
 80180f8:	4610      	mov	r0, r2
 80180fa:	f7fd f8d3 	bl	80152a4 <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 80180fe:	68fb      	ldr	r3, [r7, #12]
 8018100:	3316      	adds	r3, #22
 8018102:	6939      	ldr	r1, [r7, #16]
 8018104:	4618      	mov	r0, r3
 8018106:	f7fd f8cd 	bl	80152a4 <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
 801810a:	68fb      	ldr	r3, [r7, #12]
 801810c:	3312      	adds	r3, #18
 801810e:	2100      	movs	r1, #0
 8018110:	4618      	mov	r0, r3
 8018112:	f7fd f8ac 	bl	801526e <st_word>
					fs->wflag = 1;
 8018116:	68bb      	ldr	r3, [r7, #8]
 8018118:	2201      	movs	r2, #1
 801811a:	70da      	strb	r2, [r3, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 801811c:	68bb      	ldr	r3, [r7, #8]
 801811e:	4618      	mov	r0, r3
 8018120:	f7fd fb48 	bl	80157b4 <sync_fs>
 8018124:	4603      	mov	r3, r0
 8018126:	75fb      	strb	r3, [r7, #23]
					fp->flag &= (BYTE)~FA_MODIFIED;
 8018128:	687b      	ldr	r3, [r7, #4]
 801812a:	7d1b      	ldrb	r3, [r3, #20]
 801812c:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8018130:	b2da      	uxtb	r2, r3
 8018132:	687b      	ldr	r3, [r7, #4]
 8018134:	751a      	strb	r2, [r3, #20]
				}
			}
		}
	}

	LEAVE_FF(fs, res);
 8018136:	7dfb      	ldrb	r3, [r7, #23]
}
 8018138:	4618      	mov	r0, r3
 801813a:	3718      	adds	r7, #24
 801813c:	46bd      	mov	sp, r7
 801813e:	bd80      	pop	{r7, pc}

08018140 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8018140:	b580      	push	{r7, lr}
 8018142:	b084      	sub	sp, #16
 8018144:	af00      	add	r7, sp, #0
 8018146:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8018148:	6878      	ldr	r0, [r7, #4]
 801814a:	f7ff ff7b 	bl	8018044 <f_sync>
 801814e:	4603      	mov	r3, r0
 8018150:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK)
 8018152:	7bfb      	ldrb	r3, [r7, #15]
 8018154:	2b00      	cmp	r3, #0
 8018156:	d118      	bne.n	801818a <f_close+0x4a>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 8018158:	687b      	ldr	r3, [r7, #4]
 801815a:	f107 0208 	add.w	r2, r7, #8
 801815e:	4611      	mov	r1, r2
 8018160:	4618      	mov	r0, r3
 8018162:	f7ff fa75 	bl	8017650 <validate>
 8018166:	4603      	mov	r3, r0
 8018168:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
 801816a:	7bfb      	ldrb	r3, [r7, #15]
 801816c:	2b00      	cmp	r3, #0
 801816e:	d10c      	bne.n	801818a <f_close+0x4a>
#if _FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
 8018170:	687b      	ldr	r3, [r7, #4]
 8018172:	691b      	ldr	r3, [r3, #16]
 8018174:	4618      	mov	r0, r3
 8018176:	f7fd fa4b 	bl	8015610 <dec_lock>
 801817a:	4603      	mov	r3, r0
 801817c:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK)
 801817e:	7bfb      	ldrb	r3, [r7, #15]
 8018180:	2b00      	cmp	r3, #0
 8018182:	d102      	bne.n	801818a <f_close+0x4a>
#endif
			{
				fp->obj.fs = 0;			/* Invalidate file object */
 8018184:	687b      	ldr	r3, [r7, #4]
 8018186:	2200      	movs	r2, #0
 8018188:	601a      	str	r2, [r3, #0]
#if _FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
 801818a:	7bfb      	ldrb	r3, [r7, #15]
}
 801818c:	4618      	mov	r0, r3
 801818e:	3710      	adds	r7, #16
 8018190:	46bd      	mov	sp, r7
 8018192:	bd80      	pop	{r7, pc}

08018194 <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 8018194:	b580      	push	{r7, lr}
 8018196:	b090      	sub	sp, #64	@ 0x40
 8018198:	af00      	add	r7, sp, #0
 801819a:	6078      	str	r0, [r7, #4]
 801819c:	6039      	str	r1, [r7, #0]
	FSIZE_t ifptr;
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 801819e:	687b      	ldr	r3, [r7, #4]
 80181a0:	f107 0208 	add.w	r2, r7, #8
 80181a4:	4611      	mov	r1, r2
 80181a6:	4618      	mov	r0, r3
 80181a8:	f7ff fa52 	bl	8017650 <validate>
 80181ac:	4603      	mov	r3, r0
 80181ae:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
	if (res == FR_OK) res = (FRESULT)fp->err;
 80181b2:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 80181b6:	2b00      	cmp	r3, #0
 80181b8:	d103      	bne.n	80181c2 <f_lseek+0x2e>
 80181ba:	687b      	ldr	r3, [r7, #4]
 80181bc:	7d5b      	ldrb	r3, [r3, #21]
 80181be:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
#if _FS_EXFAT && !_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
 80181c2:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 80181c6:	2b00      	cmp	r3, #0
 80181c8:	d002      	beq.n	80181d0 <f_lseek+0x3c>
 80181ca:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
 80181ce:	e1e6      	b.n	801859e <f_lseek+0x40a>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
 80181d0:	687b      	ldr	r3, [r7, #4]
 80181d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80181d4:	2b00      	cmp	r3, #0
 80181d6:	f000 80d1 	beq.w	801837c <f_lseek+0x1e8>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 80181da:	683b      	ldr	r3, [r7, #0]
 80181dc:	f1b3 3fff 	cmp.w	r3, #4294967295
 80181e0:	d15a      	bne.n	8018298 <f_lseek+0x104>
			tbl = fp->cltbl;
 80181e2:	687b      	ldr	r3, [r7, #4]
 80181e4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80181e6:	627b      	str	r3, [r7, #36]	@ 0x24
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 80181e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80181ea:	1d1a      	adds	r2, r3, #4
 80181ec:	627a      	str	r2, [r7, #36]	@ 0x24
 80181ee:	681b      	ldr	r3, [r3, #0]
 80181f0:	617b      	str	r3, [r7, #20]
 80181f2:	2302      	movs	r3, #2
 80181f4:	62bb      	str	r3, [r7, #40]	@ 0x28
			cl = fp->obj.sclust;		/* Origin of the chain */
 80181f6:	687b      	ldr	r3, [r7, #4]
 80181f8:	689b      	ldr	r3, [r3, #8]
 80181fa:	633b      	str	r3, [r7, #48]	@ 0x30
			if (cl) {
 80181fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80181fe:	2b00      	cmp	r3, #0
 8018200:	d03a      	beq.n	8018278 <f_lseek+0xe4>
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8018202:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018204:	613b      	str	r3, [r7, #16]
 8018206:	2300      	movs	r3, #0
 8018208:	62fb      	str	r3, [r7, #44]	@ 0x2c
 801820a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801820c:	3302      	adds	r3, #2
 801820e:	62bb      	str	r3, [r7, #40]	@ 0x28
					do {
						pcl = cl; ncl++;
 8018210:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018212:	60fb      	str	r3, [r7, #12]
 8018214:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018216:	3301      	adds	r3, #1
 8018218:	62fb      	str	r3, [r7, #44]	@ 0x2c
						cl = get_fat(&fp->obj, cl);
 801821a:	687b      	ldr	r3, [r7, #4]
 801821c:	6b39      	ldr	r1, [r7, #48]	@ 0x30
 801821e:	4618      	mov	r0, r3
 8018220:	f7fd fb55 	bl	80158ce <get_fat>
 8018224:	6338      	str	r0, [r7, #48]	@ 0x30
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8018226:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018228:	2b01      	cmp	r3, #1
 801822a:	d804      	bhi.n	8018236 <f_lseek+0xa2>
 801822c:	687b      	ldr	r3, [r7, #4]
 801822e:	2202      	movs	r2, #2
 8018230:	755a      	strb	r2, [r3, #21]
 8018232:	2302      	movs	r3, #2
 8018234:	e1b3      	b.n	801859e <f_lseek+0x40a>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8018236:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018238:	f1b3 3fff 	cmp.w	r3, #4294967295
 801823c:	d104      	bne.n	8018248 <f_lseek+0xb4>
 801823e:	687b      	ldr	r3, [r7, #4]
 8018240:	2201      	movs	r2, #1
 8018242:	755a      	strb	r2, [r3, #21]
 8018244:	2301      	movs	r3, #1
 8018246:	e1aa      	b.n	801859e <f_lseek+0x40a>
					} while (cl == pcl + 1);
 8018248:	68fb      	ldr	r3, [r7, #12]
 801824a:	3301      	adds	r3, #1
 801824c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 801824e:	429a      	cmp	r2, r3
 8018250:	d0de      	beq.n	8018210 <f_lseek+0x7c>
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8018252:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018254:	697b      	ldr	r3, [r7, #20]
 8018256:	429a      	cmp	r2, r3
 8018258:	d809      	bhi.n	801826e <f_lseek+0xda>
						*tbl++ = ncl; *tbl++ = tcl;
 801825a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801825c:	1d1a      	adds	r2, r3, #4
 801825e:	627a      	str	r2, [r7, #36]	@ 0x24
 8018260:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 8018262:	601a      	str	r2, [r3, #0]
 8018264:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8018266:	1d1a      	adds	r2, r3, #4
 8018268:	627a      	str	r2, [r7, #36]	@ 0x24
 801826a:	693a      	ldr	r2, [r7, #16]
 801826c:	601a      	str	r2, [r3, #0]
					}
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 801826e:	68bb      	ldr	r3, [r7, #8]
 8018270:	699b      	ldr	r3, [r3, #24]
 8018272:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 8018274:	429a      	cmp	r2, r3
 8018276:	d3c4      	bcc.n	8018202 <f_lseek+0x6e>
			}
			*fp->cltbl = ulen;	/* Number of items used */
 8018278:	687b      	ldr	r3, [r7, #4]
 801827a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801827c:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 801827e:	601a      	str	r2, [r3, #0]
			if (ulen <= tlen) {
 8018280:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8018282:	697b      	ldr	r3, [r7, #20]
 8018284:	429a      	cmp	r2, r3
 8018286:	d803      	bhi.n	8018290 <f_lseek+0xfc>
				*tbl = 0;		/* Terminate table */
 8018288:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 801828a:	2200      	movs	r2, #0
 801828c:	601a      	str	r2, [r3, #0]
 801828e:	e184      	b.n	801859a <f_lseek+0x406>
			} else {
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 8018290:	2311      	movs	r3, #17
 8018292:	f887 303f 	strb.w	r3, [r7, #63]	@ 0x3f
 8018296:	e180      	b.n	801859a <f_lseek+0x406>
			}
		} else {						/* Fast seek */
			if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;	/* Clip offset at the file size */
 8018298:	687b      	ldr	r3, [r7, #4]
 801829a:	68db      	ldr	r3, [r3, #12]
 801829c:	683a      	ldr	r2, [r7, #0]
 801829e:	429a      	cmp	r2, r3
 80182a0:	d902      	bls.n	80182a8 <f_lseek+0x114>
 80182a2:	687b      	ldr	r3, [r7, #4]
 80182a4:	68db      	ldr	r3, [r3, #12]
 80182a6:	603b      	str	r3, [r7, #0]
			fp->fptr = ofs;				/* Set file pointer */
 80182a8:	687b      	ldr	r3, [r7, #4]
 80182aa:	683a      	ldr	r2, [r7, #0]
 80182ac:	619a      	str	r2, [r3, #24]
			if (ofs) {
 80182ae:	683b      	ldr	r3, [r7, #0]
 80182b0:	2b00      	cmp	r3, #0
 80182b2:	f000 8172 	beq.w	801859a <f_lseek+0x406>
				fp->clust = clmt_clust(fp, ofs - 1);
 80182b6:	683b      	ldr	r3, [r7, #0]
 80182b8:	3b01      	subs	r3, #1
 80182ba:	4619      	mov	r1, r3
 80182bc:	6878      	ldr	r0, [r7, #4]
 80182be:	f7fd fd94 	bl	8015dea <clmt_clust>
 80182c2:	4602      	mov	r2, r0
 80182c4:	687b      	ldr	r3, [r7, #4]
 80182c6:	61da      	str	r2, [r3, #28]
				dsc = clust2sect(fs, fp->clust);
 80182c8:	68ba      	ldr	r2, [r7, #8]
 80182ca:	687b      	ldr	r3, [r7, #4]
 80182cc:	69db      	ldr	r3, [r3, #28]
 80182ce:	4619      	mov	r1, r3
 80182d0:	4610      	mov	r0, r2
 80182d2:	f7fd fadd 	bl	8015890 <clust2sect>
 80182d6:	61b8      	str	r0, [r7, #24]
				if (!dsc) ABORT(fs, FR_INT_ERR);
 80182d8:	69bb      	ldr	r3, [r7, #24]
 80182da:	2b00      	cmp	r3, #0
 80182dc:	d104      	bne.n	80182e8 <f_lseek+0x154>
 80182de:	687b      	ldr	r3, [r7, #4]
 80182e0:	2202      	movs	r2, #2
 80182e2:	755a      	strb	r2, [r3, #21]
 80182e4:	2302      	movs	r3, #2
 80182e6:	e15a      	b.n	801859e <f_lseek+0x40a>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 80182e8:	683b      	ldr	r3, [r7, #0]
 80182ea:	3b01      	subs	r3, #1
 80182ec:	0a5b      	lsrs	r3, r3, #9
 80182ee:	68ba      	ldr	r2, [r7, #8]
 80182f0:	8952      	ldrh	r2, [r2, #10]
 80182f2:	3a01      	subs	r2, #1
 80182f4:	4013      	ands	r3, r2
 80182f6:	69ba      	ldr	r2, [r7, #24]
 80182f8:	4413      	add	r3, r2
 80182fa:	61bb      	str	r3, [r7, #24]
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 80182fc:	687b      	ldr	r3, [r7, #4]
 80182fe:	699b      	ldr	r3, [r3, #24]
 8018300:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8018304:	2b00      	cmp	r3, #0
 8018306:	f000 8148 	beq.w	801859a <f_lseek+0x406>
 801830a:	687b      	ldr	r3, [r7, #4]
 801830c:	6a1b      	ldr	r3, [r3, #32]
 801830e:	69ba      	ldr	r2, [r7, #24]
 8018310:	429a      	cmp	r2, r3
 8018312:	f000 8142 	beq.w	801859a <f_lseek+0x406>
#if !_FS_TINY
#if !_FS_READONLY
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8018316:	687b      	ldr	r3, [r7, #4]
 8018318:	7d1b      	ldrb	r3, [r3, #20]
 801831a:	b25b      	sxtb	r3, r3
 801831c:	2b00      	cmp	r3, #0
 801831e:	da18      	bge.n	8018352 <f_lseek+0x1be>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8018320:	68bb      	ldr	r3, [r7, #8]
 8018322:	7858      	ldrb	r0, [r3, #1]
 8018324:	687b      	ldr	r3, [r7, #4]
 8018326:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 801832a:	687b      	ldr	r3, [r7, #4]
 801832c:	6a1a      	ldr	r2, [r3, #32]
 801832e:	2301      	movs	r3, #1
 8018330:	f7fc ff1c 	bl	801516c <disk_write>
 8018334:	4603      	mov	r3, r0
 8018336:	2b00      	cmp	r3, #0
 8018338:	d004      	beq.n	8018344 <f_lseek+0x1b0>
 801833a:	687b      	ldr	r3, [r7, #4]
 801833c:	2201      	movs	r2, #1
 801833e:	755a      	strb	r2, [r3, #21]
 8018340:	2301      	movs	r3, #1
 8018342:	e12c      	b.n	801859e <f_lseek+0x40a>
						fp->flag &= (BYTE)~FA_DIRTY;
 8018344:	687b      	ldr	r3, [r7, #4]
 8018346:	7d1b      	ldrb	r3, [r3, #20]
 8018348:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801834c:	b2da      	uxtb	r2, r3
 801834e:	687b      	ldr	r3, [r7, #4]
 8018350:	751a      	strb	r2, [r3, #20]
					}
#endif
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 8018352:	68bb      	ldr	r3, [r7, #8]
 8018354:	7858      	ldrb	r0, [r3, #1]
 8018356:	687b      	ldr	r3, [r7, #4]
 8018358:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 801835c:	2301      	movs	r3, #1
 801835e:	69ba      	ldr	r2, [r7, #24]
 8018360:	f7fc fee4 	bl	801512c <disk_read>
 8018364:	4603      	mov	r3, r0
 8018366:	2b00      	cmp	r3, #0
 8018368:	d004      	beq.n	8018374 <f_lseek+0x1e0>
 801836a:	687b      	ldr	r3, [r7, #4]
 801836c:	2201      	movs	r2, #1
 801836e:	755a      	strb	r2, [r3, #21]
 8018370:	2301      	movs	r3, #1
 8018372:	e114      	b.n	801859e <f_lseek+0x40a>
#endif
					fp->sect = dsc;
 8018374:	687b      	ldr	r3, [r7, #4]
 8018376:	69ba      	ldr	r2, [r7, #24]
 8018378:	621a      	str	r2, [r3, #32]
 801837a:	e10e      	b.n	801859a <f_lseek+0x406>
	/* Normal Seek */
	{
#if _FS_EXFAT
		if (fs->fs_type != FS_EXFAT && ofs >= 0x100000000) ofs = 0xFFFFFFFF;	/* Clip at 4GiB-1 if at FATxx */
#endif
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 801837c:	687b      	ldr	r3, [r7, #4]
 801837e:	68db      	ldr	r3, [r3, #12]
 8018380:	683a      	ldr	r2, [r7, #0]
 8018382:	429a      	cmp	r2, r3
 8018384:	d908      	bls.n	8018398 <f_lseek+0x204>
 8018386:	687b      	ldr	r3, [r7, #4]
 8018388:	7d1b      	ldrb	r3, [r3, #20]
 801838a:	f003 0302 	and.w	r3, r3, #2
 801838e:	2b00      	cmp	r3, #0
 8018390:	d102      	bne.n	8018398 <f_lseek+0x204>
			ofs = fp->obj.objsize;
 8018392:	687b      	ldr	r3, [r7, #4]
 8018394:	68db      	ldr	r3, [r3, #12]
 8018396:	603b      	str	r3, [r7, #0]
		}
		ifptr = fp->fptr;
 8018398:	687b      	ldr	r3, [r7, #4]
 801839a:	699b      	ldr	r3, [r3, #24]
 801839c:	623b      	str	r3, [r7, #32]
		fp->fptr = nsect = 0;
 801839e:	2300      	movs	r3, #0
 80183a0:	637b      	str	r3, [r7, #52]	@ 0x34
 80183a2:	687b      	ldr	r3, [r7, #4]
 80183a4:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80183a6:	619a      	str	r2, [r3, #24]
		if (ofs) {
 80183a8:	683b      	ldr	r3, [r7, #0]
 80183aa:	2b00      	cmp	r3, #0
 80183ac:	f000 80a7 	beq.w	80184fe <f_lseek+0x36a>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 80183b0:	68bb      	ldr	r3, [r7, #8]
 80183b2:	895b      	ldrh	r3, [r3, #10]
 80183b4:	025b      	lsls	r3, r3, #9
 80183b6:	61fb      	str	r3, [r7, #28]
			if (ifptr > 0 &&
 80183b8:	6a3b      	ldr	r3, [r7, #32]
 80183ba:	2b00      	cmp	r3, #0
 80183bc:	d01b      	beq.n	80183f6 <f_lseek+0x262>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 80183be:	683b      	ldr	r3, [r7, #0]
 80183c0:	1e5a      	subs	r2, r3, #1
 80183c2:	69fb      	ldr	r3, [r7, #28]
 80183c4:	fbb2 f2f3 	udiv	r2, r2, r3
 80183c8:	6a3b      	ldr	r3, [r7, #32]
 80183ca:	1e59      	subs	r1, r3, #1
 80183cc:	69fb      	ldr	r3, [r7, #28]
 80183ce:	fbb1 f3f3 	udiv	r3, r1, r3
			if (ifptr > 0 &&
 80183d2:	429a      	cmp	r2, r3
 80183d4:	d30f      	bcc.n	80183f6 <f_lseek+0x262>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 80183d6:	6a3b      	ldr	r3, [r7, #32]
 80183d8:	1e5a      	subs	r2, r3, #1
 80183da:	69fb      	ldr	r3, [r7, #28]
 80183dc:	425b      	negs	r3, r3
 80183de:	401a      	ands	r2, r3
 80183e0:	687b      	ldr	r3, [r7, #4]
 80183e2:	619a      	str	r2, [r3, #24]
				ofs -= fp->fptr;
 80183e4:	687b      	ldr	r3, [r7, #4]
 80183e6:	699b      	ldr	r3, [r3, #24]
 80183e8:	683a      	ldr	r2, [r7, #0]
 80183ea:	1ad3      	subs	r3, r2, r3
 80183ec:	603b      	str	r3, [r7, #0]
				clst = fp->clust;
 80183ee:	687b      	ldr	r3, [r7, #4]
 80183f0:	69db      	ldr	r3, [r3, #28]
 80183f2:	63bb      	str	r3, [r7, #56]	@ 0x38
 80183f4:	e022      	b.n	801843c <f_lseek+0x2a8>
			} else {									/* When seek to back cluster, */
				clst = fp->obj.sclust;					/* start from the first cluster */
 80183f6:	687b      	ldr	r3, [r7, #4]
 80183f8:	689b      	ldr	r3, [r3, #8]
 80183fa:	63bb      	str	r3, [r7, #56]	@ 0x38
#if !_FS_READONLY
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 80183fc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 80183fe:	2b00      	cmp	r3, #0
 8018400:	d119      	bne.n	8018436 <f_lseek+0x2a2>
					clst = create_chain(&fp->obj, 0);
 8018402:	687b      	ldr	r3, [r7, #4]
 8018404:	2100      	movs	r1, #0
 8018406:	4618      	mov	r0, r3
 8018408:	f7fd fc57 	bl	8015cba <create_chain>
 801840c:	63b8      	str	r0, [r7, #56]	@ 0x38
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 801840e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018410:	2b01      	cmp	r3, #1
 8018412:	d104      	bne.n	801841e <f_lseek+0x28a>
 8018414:	687b      	ldr	r3, [r7, #4]
 8018416:	2202      	movs	r2, #2
 8018418:	755a      	strb	r2, [r3, #21]
 801841a:	2302      	movs	r3, #2
 801841c:	e0bf      	b.n	801859e <f_lseek+0x40a>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 801841e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018420:	f1b3 3fff 	cmp.w	r3, #4294967295
 8018424:	d104      	bne.n	8018430 <f_lseek+0x29c>
 8018426:	687b      	ldr	r3, [r7, #4]
 8018428:	2201      	movs	r2, #1
 801842a:	755a      	strb	r2, [r3, #21]
 801842c:	2301      	movs	r3, #1
 801842e:	e0b6      	b.n	801859e <f_lseek+0x40a>
					fp->obj.sclust = clst;
 8018430:	687b      	ldr	r3, [r7, #4]
 8018432:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8018434:	609a      	str	r2, [r3, #8]
				}
#endif
				fp->clust = clst;
 8018436:	687b      	ldr	r3, [r7, #4]
 8018438:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 801843a:	61da      	str	r2, [r3, #28]
			}
			if (clst != 0) {
 801843c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801843e:	2b00      	cmp	r3, #0
 8018440:	d05d      	beq.n	80184fe <f_lseek+0x36a>
				while (ofs > bcs) {						/* Cluster following loop */
 8018442:	e03a      	b.n	80184ba <f_lseek+0x326>
					ofs -= bcs; fp->fptr += bcs;
 8018444:	683a      	ldr	r2, [r7, #0]
 8018446:	69fb      	ldr	r3, [r7, #28]
 8018448:	1ad3      	subs	r3, r2, r3
 801844a:	603b      	str	r3, [r7, #0]
 801844c:	687b      	ldr	r3, [r7, #4]
 801844e:	699a      	ldr	r2, [r3, #24]
 8018450:	69fb      	ldr	r3, [r7, #28]
 8018452:	441a      	add	r2, r3
 8018454:	687b      	ldr	r3, [r7, #4]
 8018456:	619a      	str	r2, [r3, #24]
#if !_FS_READONLY
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8018458:	687b      	ldr	r3, [r7, #4]
 801845a:	7d1b      	ldrb	r3, [r3, #20]
 801845c:	f003 0302 	and.w	r3, r3, #2
 8018460:	2b00      	cmp	r3, #0
 8018462:	d00b      	beq.n	801847c <f_lseek+0x2e8>
						if (_FS_EXFAT && fp->fptr > fp->obj.objsize) {	/* No FAT chain object needs correct objsize to generate FAT value */
							fp->obj.objsize = fp->fptr;
							fp->flag |= FA_MODIFIED;
						}
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8018464:	687b      	ldr	r3, [r7, #4]
 8018466:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8018468:	4618      	mov	r0, r3
 801846a:	f7fd fc26 	bl	8015cba <create_chain>
 801846e:	63b8      	str	r0, [r7, #56]	@ 0x38
						if (clst == 0) {				/* Clip file size in case of disk full */
 8018470:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018472:	2b00      	cmp	r3, #0
 8018474:	d108      	bne.n	8018488 <f_lseek+0x2f4>
							ofs = 0; break;
 8018476:	2300      	movs	r3, #0
 8018478:	603b      	str	r3, [r7, #0]
 801847a:	e022      	b.n	80184c2 <f_lseek+0x32e>
						}
					} else
#endif
					{
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 801847c:	687b      	ldr	r3, [r7, #4]
 801847e:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 8018480:	4618      	mov	r0, r3
 8018482:	f7fd fa24 	bl	80158ce <get_fat>
 8018486:	63b8      	str	r0, [r7, #56]	@ 0x38
					}
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8018488:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801848a:	f1b3 3fff 	cmp.w	r3, #4294967295
 801848e:	d104      	bne.n	801849a <f_lseek+0x306>
 8018490:	687b      	ldr	r3, [r7, #4]
 8018492:	2201      	movs	r2, #1
 8018494:	755a      	strb	r2, [r3, #21]
 8018496:	2301      	movs	r3, #1
 8018498:	e081      	b.n	801859e <f_lseek+0x40a>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 801849a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 801849c:	2b01      	cmp	r3, #1
 801849e:	d904      	bls.n	80184aa <f_lseek+0x316>
 80184a0:	68bb      	ldr	r3, [r7, #8]
 80184a2:	699b      	ldr	r3, [r3, #24]
 80184a4:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80184a6:	429a      	cmp	r2, r3
 80184a8:	d304      	bcc.n	80184b4 <f_lseek+0x320>
 80184aa:	687b      	ldr	r3, [r7, #4]
 80184ac:	2202      	movs	r2, #2
 80184ae:	755a      	strb	r2, [r3, #21]
 80184b0:	2302      	movs	r3, #2
 80184b2:	e074      	b.n	801859e <f_lseek+0x40a>
					fp->clust = clst;
 80184b4:	687b      	ldr	r3, [r7, #4]
 80184b6:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 80184b8:	61da      	str	r2, [r3, #28]
				while (ofs > bcs) {						/* Cluster following loop */
 80184ba:	683a      	ldr	r2, [r7, #0]
 80184bc:	69fb      	ldr	r3, [r7, #28]
 80184be:	429a      	cmp	r2, r3
 80184c0:	d8c0      	bhi.n	8018444 <f_lseek+0x2b0>
				}
				fp->fptr += ofs;
 80184c2:	687b      	ldr	r3, [r7, #4]
 80184c4:	699a      	ldr	r2, [r3, #24]
 80184c6:	683b      	ldr	r3, [r7, #0]
 80184c8:	441a      	add	r2, r3
 80184ca:	687b      	ldr	r3, [r7, #4]
 80184cc:	619a      	str	r2, [r3, #24]
				if (ofs % SS(fs)) {
 80184ce:	683b      	ldr	r3, [r7, #0]
 80184d0:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80184d4:	2b00      	cmp	r3, #0
 80184d6:	d012      	beq.n	80184fe <f_lseek+0x36a>
					nsect = clust2sect(fs, clst);	/* Current sector */
 80184d8:	68bb      	ldr	r3, [r7, #8]
 80184da:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
 80184dc:	4618      	mov	r0, r3
 80184de:	f7fd f9d7 	bl	8015890 <clust2sect>
 80184e2:	6378      	str	r0, [r7, #52]	@ 0x34
					if (!nsect) ABORT(fs, FR_INT_ERR);
 80184e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80184e6:	2b00      	cmp	r3, #0
 80184e8:	d104      	bne.n	80184f4 <f_lseek+0x360>
 80184ea:	687b      	ldr	r3, [r7, #4]
 80184ec:	2202      	movs	r2, #2
 80184ee:	755a      	strb	r2, [r3, #21]
 80184f0:	2302      	movs	r3, #2
 80184f2:	e054      	b.n	801859e <f_lseek+0x40a>
					nsect += (DWORD)(ofs / SS(fs));
 80184f4:	683b      	ldr	r3, [r7, #0]
 80184f6:	0a5b      	lsrs	r3, r3, #9
 80184f8:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 80184fa:	4413      	add	r3, r2
 80184fc:	637b      	str	r3, [r7, #52]	@ 0x34
				}
			}
		}
		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
 80184fe:	687b      	ldr	r3, [r7, #4]
 8018500:	699a      	ldr	r2, [r3, #24]
 8018502:	687b      	ldr	r3, [r7, #4]
 8018504:	68db      	ldr	r3, [r3, #12]
 8018506:	429a      	cmp	r2, r3
 8018508:	d90a      	bls.n	8018520 <f_lseek+0x38c>
			fp->obj.objsize = fp->fptr;
 801850a:	687b      	ldr	r3, [r7, #4]
 801850c:	699a      	ldr	r2, [r3, #24]
 801850e:	687b      	ldr	r3, [r7, #4]
 8018510:	60da      	str	r2, [r3, #12]
			fp->flag |= FA_MODIFIED;
 8018512:	687b      	ldr	r3, [r7, #4]
 8018514:	7d1b      	ldrb	r3, [r3, #20]
 8018516:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801851a:	b2da      	uxtb	r2, r3
 801851c:	687b      	ldr	r3, [r7, #4]
 801851e:	751a      	strb	r2, [r3, #20]
		}
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8018520:	687b      	ldr	r3, [r7, #4]
 8018522:	699b      	ldr	r3, [r3, #24]
 8018524:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8018528:	2b00      	cmp	r3, #0
 801852a:	d036      	beq.n	801859a <f_lseek+0x406>
 801852c:	687b      	ldr	r3, [r7, #4]
 801852e:	6a1b      	ldr	r3, [r3, #32]
 8018530:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018532:	429a      	cmp	r2, r3
 8018534:	d031      	beq.n	801859a <f_lseek+0x406>
#if !_FS_TINY
#if !_FS_READONLY
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 8018536:	687b      	ldr	r3, [r7, #4]
 8018538:	7d1b      	ldrb	r3, [r3, #20]
 801853a:	b25b      	sxtb	r3, r3
 801853c:	2b00      	cmp	r3, #0
 801853e:	da18      	bge.n	8018572 <f_lseek+0x3de>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8018540:	68bb      	ldr	r3, [r7, #8]
 8018542:	7858      	ldrb	r0, [r3, #1]
 8018544:	687b      	ldr	r3, [r7, #4]
 8018546:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 801854a:	687b      	ldr	r3, [r7, #4]
 801854c:	6a1a      	ldr	r2, [r3, #32]
 801854e:	2301      	movs	r3, #1
 8018550:	f7fc fe0c 	bl	801516c <disk_write>
 8018554:	4603      	mov	r3, r0
 8018556:	2b00      	cmp	r3, #0
 8018558:	d004      	beq.n	8018564 <f_lseek+0x3d0>
 801855a:	687b      	ldr	r3, [r7, #4]
 801855c:	2201      	movs	r2, #1
 801855e:	755a      	strb	r2, [r3, #21]
 8018560:	2301      	movs	r3, #1
 8018562:	e01c      	b.n	801859e <f_lseek+0x40a>
				fp->flag &= (BYTE)~FA_DIRTY;
 8018564:	687b      	ldr	r3, [r7, #4]
 8018566:	7d1b      	ldrb	r3, [r3, #20]
 8018568:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801856c:	b2da      	uxtb	r2, r3
 801856e:	687b      	ldr	r3, [r7, #4]
 8018570:	751a      	strb	r2, [r3, #20]
			}
#endif
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8018572:	68bb      	ldr	r3, [r7, #8]
 8018574:	7858      	ldrb	r0, [r3, #1]
 8018576:	687b      	ldr	r3, [r7, #4]
 8018578:	f103 0130 	add.w	r1, r3, #48	@ 0x30
 801857c:	2301      	movs	r3, #1
 801857e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018580:	f7fc fdd4 	bl	801512c <disk_read>
 8018584:	4603      	mov	r3, r0
 8018586:	2b00      	cmp	r3, #0
 8018588:	d004      	beq.n	8018594 <f_lseek+0x400>
 801858a:	687b      	ldr	r3, [r7, #4]
 801858c:	2201      	movs	r2, #1
 801858e:	755a      	strb	r2, [r3, #21]
 8018590:	2301      	movs	r3, #1
 8018592:	e004      	b.n	801859e <f_lseek+0x40a>
#endif
			fp->sect = nsect;
 8018594:	687b      	ldr	r3, [r7, #4]
 8018596:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8018598:	621a      	str	r2, [r3, #32]
		}
	}

	LEAVE_FF(fs, res);
 801859a:	f897 303f 	ldrb.w	r3, [r7, #63]	@ 0x3f
}
 801859e:	4618      	mov	r0, r3
 80185a0:	3740      	adds	r7, #64	@ 0x40
 80185a2:	46bd      	mov	sp, r7
 80185a4:	bd80      	pop	{r7, pc}

080185a6 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 80185a6:	b580      	push	{r7, lr}
 80185a8:	b086      	sub	sp, #24
 80185aa:	af00      	add	r7, sp, #0
 80185ac:	6078      	str	r0, [r7, #4]
 80185ae:	6039      	str	r1, [r7, #0]
	FATFS *fs;
	_FDID *obj;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 80185b0:	687b      	ldr	r3, [r7, #4]
 80185b2:	2b00      	cmp	r3, #0
 80185b4:	d101      	bne.n	80185ba <f_opendir+0x14>
 80185b6:	2309      	movs	r3, #9
 80185b8:	e074      	b.n	80186a4 <f_opendir+0xfe>

	/* Get logical drive */
	obj = &dp->obj;
 80185ba:	687b      	ldr	r3, [r7, #4]
 80185bc:	613b      	str	r3, [r7, #16]
	res = find_volume(&path, &fs, 0);
 80185be:	f107 0108 	add.w	r1, r7, #8
 80185c2:	463b      	mov	r3, r7
 80185c4:	2200      	movs	r2, #0
 80185c6:	4618      	mov	r0, r3
 80185c8:	f7fe fdf6 	bl	80171b8 <find_volume>
 80185cc:	4603      	mov	r3, r0
 80185ce:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 80185d0:	7dfb      	ldrb	r3, [r7, #23]
 80185d2:	2b00      	cmp	r3, #0
 80185d4:	d15f      	bne.n	8018696 <f_opendir+0xf0>
		obj->fs = fs;
 80185d6:	68ba      	ldr	r2, [r7, #8]
 80185d8:	693b      	ldr	r3, [r7, #16]
 80185da:	601a      	str	r2, [r3, #0]
		INIT_NAMBUF(fs);
 80185dc:	f44f 7000 	mov.w	r0, #512	@ 0x200
 80185e0:	f000 fc7d 	bl	8018ede <ff_memalloc>
 80185e4:	60f8      	str	r0, [r7, #12]
 80185e6:	68fb      	ldr	r3, [r7, #12]
 80185e8:	2b00      	cmp	r3, #0
 80185ea:	d101      	bne.n	80185f0 <f_opendir+0x4a>
 80185ec:	2311      	movs	r3, #17
 80185ee:	e059      	b.n	80186a4 <f_opendir+0xfe>
 80185f0:	68bb      	ldr	r3, [r7, #8]
 80185f2:	68fa      	ldr	r2, [r7, #12]
 80185f4:	60da      	str	r2, [r3, #12]
		res = follow_path(dp, path);			/* Follow the path to the directory */
 80185f6:	683b      	ldr	r3, [r7, #0]
 80185f8:	4619      	mov	r1, r3
 80185fa:	6878      	ldr	r0, [r7, #4]
 80185fc:	f7fe fcd0 	bl	8016fa0 <follow_path>
 8018600:	4603      	mov	r3, r0
 8018602:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK) {						/* Follow completed */
 8018604:	7dfb      	ldrb	r3, [r7, #23]
 8018606:	2b00      	cmp	r3, #0
 8018608:	d13d      	bne.n	8018686 <f_opendir+0xe0>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 801860a:	687b      	ldr	r3, [r7, #4]
 801860c:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
 8018610:	b25b      	sxtb	r3, r3
 8018612:	2b00      	cmp	r3, #0
 8018614:	db12      	blt.n	801863c <f_opendir+0x96>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 8018616:	693b      	ldr	r3, [r7, #16]
 8018618:	799b      	ldrb	r3, [r3, #6]
 801861a:	f003 0310 	and.w	r3, r3, #16
 801861e:	2b00      	cmp	r3, #0
 8018620:	d00a      	beq.n	8018638 <f_opendir+0x92>
						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
					} else
#endif
					{
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8018622:	68ba      	ldr	r2, [r7, #8]
 8018624:	687b      	ldr	r3, [r7, #4]
 8018626:	6a1b      	ldr	r3, [r3, #32]
 8018628:	4619      	mov	r1, r3
 801862a:	4610      	mov	r0, r2
 801862c:	f7fd fd98 	bl	8016160 <ld_clust>
 8018630:	4602      	mov	r2, r0
 8018632:	693b      	ldr	r3, [r7, #16]
 8018634:	609a      	str	r2, [r3, #8]
 8018636:	e001      	b.n	801863c <f_opendir+0x96>
					}
				} else {						/* This object is a file */
					res = FR_NO_PATH;
 8018638:	2305      	movs	r3, #5
 801863a:	75fb      	strb	r3, [r7, #23]
				}
			}
			if (res == FR_OK) {
 801863c:	7dfb      	ldrb	r3, [r7, #23]
 801863e:	2b00      	cmp	r3, #0
 8018640:	d121      	bne.n	8018686 <f_opendir+0xe0>
				obj->id = fs->id;
 8018642:	68bb      	ldr	r3, [r7, #8]
 8018644:	88da      	ldrh	r2, [r3, #6]
 8018646:	693b      	ldr	r3, [r7, #16]
 8018648:	809a      	strh	r2, [r3, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 801864a:	2100      	movs	r1, #0
 801864c:	6878      	ldr	r0, [r7, #4]
 801864e:	f7fd fc00 	bl	8015e52 <dir_sdi>
 8018652:	4603      	mov	r3, r0
 8018654:	75fb      	strb	r3, [r7, #23]
#if _FS_LOCK != 0
				if (res == FR_OK) {
 8018656:	7dfb      	ldrb	r3, [r7, #23]
 8018658:	2b00      	cmp	r3, #0
 801865a:	d114      	bne.n	8018686 <f_opendir+0xe0>
					if (obj->sclust) {
 801865c:	693b      	ldr	r3, [r7, #16]
 801865e:	689b      	ldr	r3, [r3, #8]
 8018660:	2b00      	cmp	r3, #0
 8018662:	d00d      	beq.n	8018680 <f_opendir+0xda>
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 8018664:	2100      	movs	r1, #0
 8018666:	6878      	ldr	r0, [r7, #4]
 8018668:	f7fc ff44 	bl	80154f4 <inc_lock>
 801866c:	4602      	mov	r2, r0
 801866e:	693b      	ldr	r3, [r7, #16]
 8018670:	611a      	str	r2, [r3, #16]
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 8018672:	693b      	ldr	r3, [r7, #16]
 8018674:	691b      	ldr	r3, [r3, #16]
 8018676:	2b00      	cmp	r3, #0
 8018678:	d105      	bne.n	8018686 <f_opendir+0xe0>
 801867a:	2312      	movs	r3, #18
 801867c:	75fb      	strb	r3, [r7, #23]
 801867e:	e002      	b.n	8018686 <f_opendir+0xe0>
					} else {
						obj->lockid = 0;	/* Root directory need not to be locked */
 8018680:	693b      	ldr	r3, [r7, #16]
 8018682:	2200      	movs	r2, #0
 8018684:	611a      	str	r2, [r3, #16]
					}
				}
#endif
			}
		}
		FREE_NAMBUF();
 8018686:	68f8      	ldr	r0, [r7, #12]
 8018688:	f000 fc35 	bl	8018ef6 <ff_memfree>
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 801868c:	7dfb      	ldrb	r3, [r7, #23]
 801868e:	2b04      	cmp	r3, #4
 8018690:	d101      	bne.n	8018696 <f_opendir+0xf0>
 8018692:	2305      	movs	r3, #5
 8018694:	75fb      	strb	r3, [r7, #23]
	}
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 8018696:	7dfb      	ldrb	r3, [r7, #23]
 8018698:	2b00      	cmp	r3, #0
 801869a:	d002      	beq.n	80186a2 <f_opendir+0xfc>
 801869c:	693b      	ldr	r3, [r7, #16]
 801869e:	2200      	movs	r2, #0
 80186a0:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
 80186a2:	7dfb      	ldrb	r3, [r7, #23]
}
 80186a4:	4618      	mov	r0, r3
 80186a6:	3718      	adds	r7, #24
 80186a8:	46bd      	mov	sp, r7
 80186aa:	bd80      	pop	{r7, pc}

080186ac <f_closedir>:
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 80186ac:	b580      	push	{r7, lr}
 80186ae:	b084      	sub	sp, #16
 80186b0:	af00      	add	r7, sp, #0
 80186b2:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;


	res = validate(&dp->obj, &fs);			/* Check validity of the file object */
 80186b4:	687b      	ldr	r3, [r7, #4]
 80186b6:	f107 0208 	add.w	r2, r7, #8
 80186ba:	4611      	mov	r1, r2
 80186bc:	4618      	mov	r0, r3
 80186be:	f7fe ffc7 	bl	8017650 <validate>
 80186c2:	4603      	mov	r3, r0
 80186c4:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
 80186c6:	7bfb      	ldrb	r3, [r7, #15]
 80186c8:	2b00      	cmp	r3, #0
 80186ca:	d110      	bne.n	80186ee <f_closedir+0x42>
#if _FS_LOCK != 0
		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
 80186cc:	687b      	ldr	r3, [r7, #4]
 80186ce:	691b      	ldr	r3, [r3, #16]
 80186d0:	2b00      	cmp	r3, #0
 80186d2:	d006      	beq.n	80186e2 <f_closedir+0x36>
			res = dec_lock(dp->obj.lockid);
 80186d4:	687b      	ldr	r3, [r7, #4]
 80186d6:	691b      	ldr	r3, [r3, #16]
 80186d8:	4618      	mov	r0, r3
 80186da:	f7fc ff99 	bl	8015610 <dec_lock>
 80186de:	4603      	mov	r3, r0
 80186e0:	73fb      	strb	r3, [r7, #15]
		}
		if (res == FR_OK)
 80186e2:	7bfb      	ldrb	r3, [r7, #15]
 80186e4:	2b00      	cmp	r3, #0
 80186e6:	d102      	bne.n	80186ee <f_closedir+0x42>
#endif
		{
			dp->obj.fs = 0;			/* Invalidate directory object */
 80186e8:	687b      	ldr	r3, [r7, #4]
 80186ea:	2200      	movs	r2, #0
 80186ec:	601a      	str	r2, [r3, #0]
		}
#if _FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
 80186ee:	7bfb      	ldrb	r3, [r7, #15]
}
 80186f0:	4618      	mov	r0, r3
 80186f2:	3710      	adds	r7, #16
 80186f4:	46bd      	mov	sp, r7
 80186f6:	bd80      	pop	{r7, pc}

080186f8 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 80186f8:	b580      	push	{r7, lr}
 80186fa:	b086      	sub	sp, #24
 80186fc:	af00      	add	r7, sp, #0
 80186fe:	6078      	str	r0, [r7, #4]
 8018700:	6039      	str	r1, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8018702:	687b      	ldr	r3, [r7, #4]
 8018704:	f107 020c 	add.w	r2, r7, #12
 8018708:	4611      	mov	r1, r2
 801870a:	4618      	mov	r0, r3
 801870c:	f7fe ffa0 	bl	8017650 <validate>
 8018710:	4603      	mov	r3, r0
 8018712:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
 8018714:	7dfb      	ldrb	r3, [r7, #23]
 8018716:	2b00      	cmp	r3, #0
 8018718:	d136      	bne.n	8018788 <f_readdir+0x90>
		if (!fno) {
 801871a:	683b      	ldr	r3, [r7, #0]
 801871c:	2b00      	cmp	r3, #0
 801871e:	d106      	bne.n	801872e <f_readdir+0x36>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8018720:	2100      	movs	r1, #0
 8018722:	6878      	ldr	r0, [r7, #4]
 8018724:	f7fd fb95 	bl	8015e52 <dir_sdi>
 8018728:	4603      	mov	r3, r0
 801872a:	75fb      	strb	r3, [r7, #23]
 801872c:	e02c      	b.n	8018788 <f_readdir+0x90>
		} else {
			INIT_NAMBUF(fs);
 801872e:	f44f 7000 	mov.w	r0, #512	@ 0x200
 8018732:	f000 fbd4 	bl	8018ede <ff_memalloc>
 8018736:	6138      	str	r0, [r7, #16]
 8018738:	693b      	ldr	r3, [r7, #16]
 801873a:	2b00      	cmp	r3, #0
 801873c:	d101      	bne.n	8018742 <f_readdir+0x4a>
 801873e:	2311      	movs	r3, #17
 8018740:	e023      	b.n	801878a <f_readdir+0x92>
 8018742:	68fb      	ldr	r3, [r7, #12]
 8018744:	693a      	ldr	r2, [r7, #16]
 8018746:	60da      	str	r2, [r3, #12]
			res = dir_read(dp, 0);			/* Read an item */
 8018748:	2100      	movs	r1, #0
 801874a:	6878      	ldr	r0, [r7, #4]
 801874c:	f7fd ff33 	bl	80165b6 <dir_read>
 8018750:	4603      	mov	r3, r0
 8018752:	75fb      	strb	r3, [r7, #23]
			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 8018754:	7dfb      	ldrb	r3, [r7, #23]
 8018756:	2b04      	cmp	r3, #4
 8018758:	d101      	bne.n	801875e <f_readdir+0x66>
 801875a:	2300      	movs	r3, #0
 801875c:	75fb      	strb	r3, [r7, #23]
			if (res == FR_OK) {				/* A valid entry is found */
 801875e:	7dfb      	ldrb	r3, [r7, #23]
 8018760:	2b00      	cmp	r3, #0
 8018762:	d10e      	bne.n	8018782 <f_readdir+0x8a>
				get_fileinfo(dp, fno);		/* Get the object information */
 8018764:	6839      	ldr	r1, [r7, #0]
 8018766:	6878      	ldr	r0, [r7, #4]
 8018768:	f7fe f984 	bl	8016a74 <get_fileinfo>
				res = dir_next(dp, 0);		/* Increment index for next */
 801876c:	2100      	movs	r1, #0
 801876e:	6878      	ldr	r0, [r7, #4]
 8018770:	f7fd fbea 	bl	8015f48 <dir_next>
 8018774:	4603      	mov	r3, r0
 8018776:	75fb      	strb	r3, [r7, #23]
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 8018778:	7dfb      	ldrb	r3, [r7, #23]
 801877a:	2b04      	cmp	r3, #4
 801877c:	d101      	bne.n	8018782 <f_readdir+0x8a>
 801877e:	2300      	movs	r3, #0
 8018780:	75fb      	strb	r3, [r7, #23]
			}
			FREE_NAMBUF();
 8018782:	6938      	ldr	r0, [r7, #16]
 8018784:	f000 fbb7 	bl	8018ef6 <ff_memfree>
		}
	}
	LEAVE_FF(fs, res);
 8018788:	7dfb      	ldrb	r3, [r7, #23]
}
 801878a:	4618      	mov	r0, r3
 801878c:	3718      	adds	r7, #24
 801878e:	46bd      	mov	sp, r7
 8018790:	bd80      	pop	{r7, pc}

08018792 <f_getfree>:
FRESULT f_getfree (
	const TCHAR* path,	/* Path name of the logical drive number */
	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
)
{
 8018792:	b580      	push	{r7, lr}
 8018794:	b092      	sub	sp, #72	@ 0x48
 8018796:	af00      	add	r7, sp, #0
 8018798:	60f8      	str	r0, [r7, #12]
 801879a:	60b9      	str	r1, [r7, #8]
 801879c:	607a      	str	r2, [r7, #4]
	BYTE *p;
	_FDID obj;


	/* Get logical drive */
	res = find_volume(&path, &fs, 0);
 801879e:	f107 0128 	add.w	r1, r7, #40	@ 0x28
 80187a2:	f107 030c 	add.w	r3, r7, #12
 80187a6:	2200      	movs	r2, #0
 80187a8:	4618      	mov	r0, r3
 80187aa:	f7fe fd05 	bl	80171b8 <find_volume>
 80187ae:	4603      	mov	r3, r0
 80187b0:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
	if (res == FR_OK) {
 80187b4:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 80187b8:	2b00      	cmp	r3, #0
 80187ba:	f040 8099 	bne.w	80188f0 <f_getfree+0x15e>
		*fatfs = fs;				/* Return ptr to the fs object */
 80187be:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 80187c0:	687b      	ldr	r3, [r7, #4]
 80187c2:	601a      	str	r2, [r3, #0]
		/* If free_clst is valid, return it without full cluster scan */
		if (fs->free_clst <= fs->n_fatent - 2) {
 80187c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80187c6:	695a      	ldr	r2, [r3, #20]
 80187c8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80187ca:	699b      	ldr	r3, [r3, #24]
 80187cc:	3b02      	subs	r3, #2
 80187ce:	429a      	cmp	r2, r3
 80187d0:	d804      	bhi.n	80187dc <f_getfree+0x4a>
			*nclst = fs->free_clst;
 80187d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80187d4:	695a      	ldr	r2, [r3, #20]
 80187d6:	68bb      	ldr	r3, [r7, #8]
 80187d8:	601a      	str	r2, [r3, #0]
 80187da:	e089      	b.n	80188f0 <f_getfree+0x15e>
		} else {
			/* Get number of free clusters */
			nfree = 0;
 80187dc:	2300      	movs	r3, #0
 80187de:	643b      	str	r3, [r7, #64]	@ 0x40
			if (fs->fs_type == FS_FAT12) {	/* FAT12: Sector unalighed FAT entries */
 80187e0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80187e2:	781b      	ldrb	r3, [r3, #0]
 80187e4:	2b01      	cmp	r3, #1
 80187e6:	d128      	bne.n	801883a <f_getfree+0xa8>
				clst = 2; obj.fs = fs;
 80187e8:	2302      	movs	r3, #2
 80187ea:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80187ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80187ee:	617b      	str	r3, [r7, #20]
				do {
					stat = get_fat(&obj, clst);
 80187f0:	f107 0314 	add.w	r3, r7, #20
 80187f4:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 80187f6:	4618      	mov	r0, r3
 80187f8:	f7fd f869 	bl	80158ce <get_fat>
 80187fc:	62f8      	str	r0, [r7, #44]	@ 0x2c
					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
 80187fe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018800:	f1b3 3fff 	cmp.w	r3, #4294967295
 8018804:	d103      	bne.n	801880e <f_getfree+0x7c>
 8018806:	2301      	movs	r3, #1
 8018808:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 801880c:	e063      	b.n	80188d6 <f_getfree+0x144>
					if (stat == 1) { res = FR_INT_ERR; break; }
 801880e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8018810:	2b01      	cmp	r3, #1
 8018812:	d103      	bne.n	801881c <f_getfree+0x8a>
 8018814:	2302      	movs	r3, #2
 8018816:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
 801881a:	e05c      	b.n	80188d6 <f_getfree+0x144>
					if (stat == 0) nfree++;
 801881c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 801881e:	2b00      	cmp	r3, #0
 8018820:	d102      	bne.n	8018828 <f_getfree+0x96>
 8018822:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018824:	3301      	adds	r3, #1
 8018826:	643b      	str	r3, [r7, #64]	@ 0x40
				} while (++clst < fs->n_fatent);
 8018828:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 801882a:	3301      	adds	r3, #1
 801882c:	63fb      	str	r3, [r7, #60]	@ 0x3c
 801882e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018830:	699b      	ldr	r3, [r3, #24]
 8018832:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 8018834:	429a      	cmp	r2, r3
 8018836:	d3db      	bcc.n	80187f0 <f_getfree+0x5e>
 8018838:	e04d      	b.n	80188d6 <f_getfree+0x144>
						i = (i + 1) % SS(fs);
					} while (clst);
				} else
#endif
				{	/* FAT16/32: Sector alighed FAT entries */
					clst = fs->n_fatent; sect = fs->fatbase;
 801883a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801883c:	699b      	ldr	r3, [r3, #24]
 801883e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8018840:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018842:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8018844:	63bb      	str	r3, [r7, #56]	@ 0x38
					i = 0; p = 0;
 8018846:	2300      	movs	r3, #0
 8018848:	637b      	str	r3, [r7, #52]	@ 0x34
 801884a:	2300      	movs	r3, #0
 801884c:	633b      	str	r3, [r7, #48]	@ 0x30
					do {
						if (i == 0) {
 801884e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8018850:	2b00      	cmp	r3, #0
 8018852:	d113      	bne.n	801887c <f_getfree+0xea>
							res = move_window(fs, sect++);
 8018854:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8018856:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8018858:	1c5a      	adds	r2, r3, #1
 801885a:	63ba      	str	r2, [r7, #56]	@ 0x38
 801885c:	4619      	mov	r1, r3
 801885e:	f7fc ff7b 	bl	8015758 <move_window>
 8018862:	4603      	mov	r3, r0
 8018864:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
							if (res != FR_OK) break;
 8018868:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
 801886c:	2b00      	cmp	r3, #0
 801886e:	d131      	bne.n	80188d4 <f_getfree+0x142>
							p = fs->win;
 8018870:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8018872:	3334      	adds	r3, #52	@ 0x34
 8018874:	633b      	str	r3, [r7, #48]	@ 0x30
							i = SS(fs);
 8018876:	f44f 7300 	mov.w	r3, #512	@ 0x200
 801887a:	637b      	str	r3, [r7, #52]	@ 0x34
						}
						if (fs->fs_type == FS_FAT16) {
 801887c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 801887e:	781b      	ldrb	r3, [r3, #0]
 8018880:	2b02      	cmp	r3, #2
 8018882:	d10f      	bne.n	80188a4 <f_getfree+0x112>
							if (ld_word(p) == 0) nfree++;
 8018884:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 8018886:	f7fc fcb7 	bl	80151f8 <ld_word>
 801888a:	4603      	mov	r3, r0
 801888c:	2b00      	cmp	r3, #0
 801888e:	d102      	bne.n	8018896 <f_getfree+0x104>
 8018890:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 8018892:	3301      	adds	r3, #1
 8018894:	643b      	str	r3, [r7, #64]	@ 0x40
							p += 2; i -= 2;
 8018896:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8018898:	3302      	adds	r3, #2
 801889a:	633b      	str	r3, [r7, #48]	@ 0x30
 801889c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 801889e:	3b02      	subs	r3, #2
 80188a0:	637b      	str	r3, [r7, #52]	@ 0x34
 80188a2:	e010      	b.n	80188c6 <f_getfree+0x134>
						} else {
							if ((ld_dword(p) & 0x0FFFFFFF) == 0) nfree++;
 80188a4:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 80188a6:	f7fc fcbf 	bl	8015228 <ld_dword>
 80188aa:	4603      	mov	r3, r0
 80188ac:	f023 4370 	bic.w	r3, r3, #4026531840	@ 0xf0000000
 80188b0:	2b00      	cmp	r3, #0
 80188b2:	d102      	bne.n	80188ba <f_getfree+0x128>
 80188b4:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 80188b6:	3301      	adds	r3, #1
 80188b8:	643b      	str	r3, [r7, #64]	@ 0x40
							p += 4; i -= 4;
 80188ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80188bc:	3304      	adds	r3, #4
 80188be:	633b      	str	r3, [r7, #48]	@ 0x30
 80188c0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80188c2:	3b04      	subs	r3, #4
 80188c4:	637b      	str	r3, [r7, #52]	@ 0x34
						}
					} while (--clst);
 80188c6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80188c8:	3b01      	subs	r3, #1
 80188ca:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80188cc:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 80188ce:	2b00      	cmp	r3, #0
 80188d0:	d1bd      	bne.n	801884e <f_getfree+0xbc>
 80188d2:	e000      	b.n	80188d6 <f_getfree+0x144>
							if (res != FR_OK) break;
 80188d4:	bf00      	nop
				}
			}
			*nclst = nfree;			/* Return the free clusters */
 80188d6:	68bb      	ldr	r3, [r7, #8]
 80188d8:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80188da:	601a      	str	r2, [r3, #0]
			fs->free_clst = nfree;	/* Now free_clst is valid */
 80188dc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188de:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 80188e0:	615a      	str	r2, [r3, #20]
			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
 80188e2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188e4:	791a      	ldrb	r2, [r3, #4]
 80188e6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80188e8:	f042 0201 	orr.w	r2, r2, #1
 80188ec:	b2d2      	uxtb	r2, r2
 80188ee:	711a      	strb	r2, [r3, #4]
		}
	}

	LEAVE_FF(fs, res);
 80188f0:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
}
 80188f4:	4618      	mov	r0, r3
 80188f6:	3748      	adds	r7, #72	@ 0x48
 80188f8:	46bd      	mov	sp, r7
 80188fa:	bd80      	pop	{r7, pc}

080188fc <putc_bfd>:
static
void putc_bfd (		/* Buffered write with code conversion */
	putbuff* pb,
	TCHAR c
)
{
 80188fc:	b580      	push	{r7, lr}
 80188fe:	b084      	sub	sp, #16
 8018900:	af00      	add	r7, sp, #0
 8018902:	6078      	str	r0, [r7, #4]
 8018904:	460b      	mov	r3, r1
 8018906:	70fb      	strb	r3, [r7, #3]
	UINT bw;
	int i;


	if (_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
 8018908:	78fb      	ldrb	r3, [r7, #3]
 801890a:	2b0a      	cmp	r3, #10
 801890c:	d103      	bne.n	8018916 <putc_bfd+0x1a>
		putc_bfd(pb, '\r');
 801890e:	210d      	movs	r1, #13
 8018910:	6878      	ldr	r0, [r7, #4]
 8018912:	f7ff fff3 	bl	80188fc <putc_bfd>
	}

	i = pb->idx;		/* Write index of pb->buf[] */
 8018916:	687b      	ldr	r3, [r7, #4]
 8018918:	685b      	ldr	r3, [r3, #4]
 801891a:	60fb      	str	r3, [r7, #12]
	if (i < 0) return;
 801891c:	68fb      	ldr	r3, [r7, #12]
 801891e:	2b00      	cmp	r3, #0
 8018920:	db25      	blt.n	801896e <putc_bfd+0x72>
	if (c >= 0x100)
		pb->buf[i++] = (BYTE)(c >> 8);
	pb->buf[i++] = (BYTE)c;
#endif
#else							/* Write a character without conversion */
	pb->buf[i++] = (BYTE)c;
 8018922:	68fb      	ldr	r3, [r7, #12]
 8018924:	1c5a      	adds	r2, r3, #1
 8018926:	60fa      	str	r2, [r7, #12]
 8018928:	687a      	ldr	r2, [r7, #4]
 801892a:	4413      	add	r3, r2
 801892c:	78fa      	ldrb	r2, [r7, #3]
 801892e:	731a      	strb	r2, [r3, #12]
#endif

	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
 8018930:	68fb      	ldr	r3, [r7, #12]
 8018932:	2b3c      	cmp	r3, #60	@ 0x3c
 8018934:	dd12      	ble.n	801895c <putc_bfd+0x60>
		f_write(pb->fp, pb->buf, (UINT)i, &bw);
 8018936:	687b      	ldr	r3, [r7, #4]
 8018938:	6818      	ldr	r0, [r3, #0]
 801893a:	687b      	ldr	r3, [r7, #4]
 801893c:	f103 010c 	add.w	r1, r3, #12
 8018940:	68fa      	ldr	r2, [r7, #12]
 8018942:	f107 0308 	add.w	r3, r7, #8
 8018946:	f7ff fa08 	bl	8017d5a <f_write>
		i = (bw == (UINT)i) ? 0 : -1;
 801894a:	68ba      	ldr	r2, [r7, #8]
 801894c:	68fb      	ldr	r3, [r7, #12]
 801894e:	429a      	cmp	r2, r3
 8018950:	d101      	bne.n	8018956 <putc_bfd+0x5a>
 8018952:	2300      	movs	r3, #0
 8018954:	e001      	b.n	801895a <putc_bfd+0x5e>
 8018956:	f04f 33ff 	mov.w	r3, #4294967295
 801895a:	60fb      	str	r3, [r7, #12]
	}
	pb->idx = i;
 801895c:	687b      	ldr	r3, [r7, #4]
 801895e:	68fa      	ldr	r2, [r7, #12]
 8018960:	605a      	str	r2, [r3, #4]
	pb->nchr++;
 8018962:	687b      	ldr	r3, [r7, #4]
 8018964:	689b      	ldr	r3, [r3, #8]
 8018966:	1c5a      	adds	r2, r3, #1
 8018968:	687b      	ldr	r3, [r7, #4]
 801896a:	609a      	str	r2, [r3, #8]
 801896c:	e000      	b.n	8018970 <putc_bfd+0x74>
	if (i < 0) return;
 801896e:	bf00      	nop
}
 8018970:	3710      	adds	r7, #16
 8018972:	46bd      	mov	sp, r7
 8018974:	bd80      	pop	{r7, pc}

08018976 <putc_flush>:

static
int putc_flush (		/* Flush left characters in the buffer */
	putbuff* pb
)
{
 8018976:	b580      	push	{r7, lr}
 8018978:	b084      	sub	sp, #16
 801897a:	af00      	add	r7, sp, #0
 801897c:	6078      	str	r0, [r7, #4]
	UINT nw;

	if (   pb->idx >= 0	/* Flush buffered characters to the file */
 801897e:	687b      	ldr	r3, [r7, #4]
 8018980:	685b      	ldr	r3, [r3, #4]
 8018982:	2b00      	cmp	r3, #0
 8018984:	db16      	blt.n	80189b4 <putc_flush+0x3e>
		&& f_write(pb->fp, pb->buf, (UINT)pb->idx, &nw) == FR_OK
 8018986:	687b      	ldr	r3, [r7, #4]
 8018988:	6818      	ldr	r0, [r3, #0]
 801898a:	687b      	ldr	r3, [r7, #4]
 801898c:	f103 010c 	add.w	r1, r3, #12
 8018990:	687b      	ldr	r3, [r7, #4]
 8018992:	685b      	ldr	r3, [r3, #4]
 8018994:	461a      	mov	r2, r3
 8018996:	f107 030c 	add.w	r3, r7, #12
 801899a:	f7ff f9de 	bl	8017d5a <f_write>
 801899e:	4603      	mov	r3, r0
 80189a0:	2b00      	cmp	r3, #0
 80189a2:	d107      	bne.n	80189b4 <putc_flush+0x3e>
		&& (UINT)pb->idx == nw) return pb->nchr;
 80189a4:	687b      	ldr	r3, [r7, #4]
 80189a6:	685b      	ldr	r3, [r3, #4]
 80189a8:	68fa      	ldr	r2, [r7, #12]
 80189aa:	4293      	cmp	r3, r2
 80189ac:	d102      	bne.n	80189b4 <putc_flush+0x3e>
 80189ae:	687b      	ldr	r3, [r7, #4]
 80189b0:	689b      	ldr	r3, [r3, #8]
 80189b2:	e001      	b.n	80189b8 <putc_flush+0x42>
	return EOF;
 80189b4:	f04f 33ff 	mov.w	r3, #4294967295
}
 80189b8:	4618      	mov	r0, r3
 80189ba:	3710      	adds	r7, #16
 80189bc:	46bd      	mov	sp, r7
 80189be:	bd80      	pop	{r7, pc}

080189c0 <putc_init>:
static
void putc_init (		/* Initialize write buffer */
	putbuff* pb,
	FIL* fp
)
{
 80189c0:	b480      	push	{r7}
 80189c2:	b083      	sub	sp, #12
 80189c4:	af00      	add	r7, sp, #0
 80189c6:	6078      	str	r0, [r7, #4]
 80189c8:	6039      	str	r1, [r7, #0]
	pb->fp = fp;
 80189ca:	687b      	ldr	r3, [r7, #4]
 80189cc:	683a      	ldr	r2, [r7, #0]
 80189ce:	601a      	str	r2, [r3, #0]
	pb->nchr = pb->idx = 0;
 80189d0:	687b      	ldr	r3, [r7, #4]
 80189d2:	2200      	movs	r2, #0
 80189d4:	605a      	str	r2, [r3, #4]
 80189d6:	687b      	ldr	r3, [r7, #4]
 80189d8:	685a      	ldr	r2, [r3, #4]
 80189da:	687b      	ldr	r3, [r7, #4]
 80189dc:	609a      	str	r2, [r3, #8]
}
 80189de:	bf00      	nop
 80189e0:	370c      	adds	r7, #12
 80189e2:	46bd      	mov	sp, r7
 80189e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80189e8:	4770      	bx	lr
	...

080189ec <f_printf>:
int f_printf (
	FIL* fp,			/* Pointer to the file object */
	const TCHAR* fmt,	/* Pointer to the format string */
	...					/* Optional arguments... */
)
{
 80189ec:	b40e      	push	{r1, r2, r3}
 80189ee:	b580      	push	{r7, lr}
 80189f0:	b0a7      	sub	sp, #156	@ 0x9c
 80189f2:	af00      	add	r7, sp, #0
 80189f4:	6078      	str	r0, [r7, #4]
	UINT i, j, w;
	DWORD v;
	TCHAR c, d, str[32], *p;


	putc_init(&pb, fp);
 80189f6:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 80189fa:	6879      	ldr	r1, [r7, #4]
 80189fc:	4618      	mov	r0, r3
 80189fe:	f7ff ffdf 	bl	80189c0 <putc_init>

	va_start(arp, fmt);
 8018a02:	f107 03a8 	add.w	r3, r7, #168	@ 0xa8
 8018a06:	67bb      	str	r3, [r7, #120]	@ 0x78

	for (;;) {
		c = *fmt++;
 8018a08:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8018a0c:	1c5a      	adds	r2, r3, #1
 8018a0e:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8018a12:	781b      	ldrb	r3, [r3, #0]
 8018a14:	f887 3083 	strb.w	r3, [r7, #131]	@ 0x83
		if (c == 0) break;			/* End of string */
 8018a18:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018a1c:	2b00      	cmp	r3, #0
 8018a1e:	f000 81f2 	beq.w	8018e06 <f_printf+0x41a>
		if (c != '%') {				/* Non escape character */
 8018a22:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018a26:	2b25      	cmp	r3, #37	@ 0x25
 8018a28:	d008      	beq.n	8018a3c <f_printf+0x50>
			putc_bfd(&pb, c);
 8018a2a:	f897 2083 	ldrb.w	r2, [r7, #131]	@ 0x83
 8018a2e:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018a32:	4611      	mov	r1, r2
 8018a34:	4618      	mov	r0, r3
 8018a36:	f7ff ff61 	bl	80188fc <putc_bfd>
			continue;
 8018a3a:	e1e3      	b.n	8018e04 <f_printf+0x418>
		}
		w = f = 0;
 8018a3c:	2300      	movs	r3, #0
 8018a3e:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
 8018a42:	2300      	movs	r3, #0
 8018a44:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
		c = *fmt++;
 8018a48:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8018a4c:	1c5a      	adds	r2, r3, #1
 8018a4e:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8018a52:	781b      	ldrb	r3, [r3, #0]
 8018a54:	f887 3083 	strb.w	r3, [r7, #131]	@ 0x83
		if (c == '0') {				/* Flag: '0' padding */
 8018a58:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018a5c:	2b30      	cmp	r3, #48	@ 0x30
 8018a5e:	d10b      	bne.n	8018a78 <f_printf+0x8c>
			f = 1; c = *fmt++;
 8018a60:	2301      	movs	r3, #1
 8018a62:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
 8018a66:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8018a6a:	1c5a      	adds	r2, r3, #1
 8018a6c:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8018a70:	781b      	ldrb	r3, [r3, #0]
 8018a72:	f887 3083 	strb.w	r3, [r7, #131]	@ 0x83
 8018a76:	e024      	b.n	8018ac2 <f_printf+0xd6>
		} else {
			if (c == '-') {			/* Flag: left justified */
 8018a78:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018a7c:	2b2d      	cmp	r3, #45	@ 0x2d
 8018a7e:	d120      	bne.n	8018ac2 <f_printf+0xd6>
				f = 2; c = *fmt++;
 8018a80:	2302      	movs	r3, #2
 8018a82:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
 8018a86:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8018a8a:	1c5a      	adds	r2, r3, #1
 8018a8c:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8018a90:	781b      	ldrb	r3, [r3, #0]
 8018a92:	f887 3083 	strb.w	r3, [r7, #131]	@ 0x83
			}
		}
		while (IsDigit(c)) {		/* Precision */
 8018a96:	e014      	b.n	8018ac2 <f_printf+0xd6>
			w = w * 10 + c - '0';
 8018a98:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8018a9c:	4613      	mov	r3, r2
 8018a9e:	009b      	lsls	r3, r3, #2
 8018aa0:	4413      	add	r3, r2
 8018aa2:	005b      	lsls	r3, r3, #1
 8018aa4:	461a      	mov	r2, r3
 8018aa6:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018aaa:	4413      	add	r3, r2
 8018aac:	3b30      	subs	r3, #48	@ 0x30
 8018aae:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
			c = *fmt++;
 8018ab2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8018ab6:	1c5a      	adds	r2, r3, #1
 8018ab8:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8018abc:	781b      	ldrb	r3, [r3, #0]
 8018abe:	f887 3083 	strb.w	r3, [r7, #131]	@ 0x83
		while (IsDigit(c)) {		/* Precision */
 8018ac2:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018ac6:	2b2f      	cmp	r3, #47	@ 0x2f
 8018ac8:	d903      	bls.n	8018ad2 <f_printf+0xe6>
 8018aca:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018ace:	2b39      	cmp	r3, #57	@ 0x39
 8018ad0:	d9e2      	bls.n	8018a98 <f_printf+0xac>
		}
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
 8018ad2:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018ad6:	2b6c      	cmp	r3, #108	@ 0x6c
 8018ad8:	d003      	beq.n	8018ae2 <f_printf+0xf6>
 8018ada:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018ade:	2b4c      	cmp	r3, #76	@ 0x4c
 8018ae0:	d10d      	bne.n	8018afe <f_printf+0x112>
			f |= 4; c = *fmt++;
 8018ae2:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 8018ae6:	f043 0304 	orr.w	r3, r3, #4
 8018aea:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
 8018aee:	f8d7 30a4 	ldr.w	r3, [r7, #164]	@ 0xa4
 8018af2:	1c5a      	adds	r2, r3, #1
 8018af4:	f8c7 20a4 	str.w	r2, [r7, #164]	@ 0xa4
 8018af8:	781b      	ldrb	r3, [r3, #0]
 8018afa:	f887 3083 	strb.w	r3, [r7, #131]	@ 0x83
		}
		if (!c) break;
 8018afe:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018b02:	2b00      	cmp	r3, #0
 8018b04:	f000 8181 	beq.w	8018e0a <f_printf+0x41e>
		d = c;
 8018b08:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018b0c:	f887 3082 	strb.w	r3, [r7, #130]	@ 0x82
		if (IsLower(d)) d -= 0x20;
 8018b10:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018b14:	2b60      	cmp	r3, #96	@ 0x60
 8018b16:	d908      	bls.n	8018b2a <f_printf+0x13e>
 8018b18:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018b1c:	2b7a      	cmp	r3, #122	@ 0x7a
 8018b1e:	d804      	bhi.n	8018b2a <f_printf+0x13e>
 8018b20:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018b24:	3b20      	subs	r3, #32
 8018b26:	f887 3082 	strb.w	r3, [r7, #130]	@ 0x82
		switch (d) {				/* Type is... */
 8018b2a:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018b2e:	3b42      	subs	r3, #66	@ 0x42
 8018b30:	2b16      	cmp	r3, #22
 8018b32:	f200 8098 	bhi.w	8018c66 <f_printf+0x27a>
 8018b36:	a201      	add	r2, pc, #4	@ (adr r2, 8018b3c <f_printf+0x150>)
 8018b38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018b3c:	08018c47 	.word	0x08018c47
 8018b40:	08018c2f 	.word	0x08018c2f
 8018b44:	08018c57 	.word	0x08018c57
 8018b48:	08018c67 	.word	0x08018c67
 8018b4c:	08018c67 	.word	0x08018c67
 8018b50:	08018c67 	.word	0x08018c67
 8018b54:	08018c67 	.word	0x08018c67
 8018b58:	08018c67 	.word	0x08018c67
 8018b5c:	08018c67 	.word	0x08018c67
 8018b60:	08018c67 	.word	0x08018c67
 8018b64:	08018c67 	.word	0x08018c67
 8018b68:	08018c67 	.word	0x08018c67
 8018b6c:	08018c67 	.word	0x08018c67
 8018b70:	08018c4f 	.word	0x08018c4f
 8018b74:	08018c67 	.word	0x08018c67
 8018b78:	08018c67 	.word	0x08018c67
 8018b7c:	08018c67 	.word	0x08018c67
 8018b80:	08018b99 	.word	0x08018b99
 8018b84:	08018c67 	.word	0x08018c67
 8018b88:	08018c57 	.word	0x08018c57
 8018b8c:	08018c67 	.word	0x08018c67
 8018b90:	08018c67 	.word	0x08018c67
 8018b94:	08018c5f 	.word	0x08018c5f
		case 'S' :					/* String */
			p = va_arg(arp, TCHAR*);
 8018b98:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8018b9a:	1d1a      	adds	r2, r3, #4
 8018b9c:	67ba      	str	r2, [r7, #120]	@ 0x78
 8018b9e:	681b      	ldr	r3, [r3, #0]
 8018ba0:	67fb      	str	r3, [r7, #124]	@ 0x7c
			for (j = 0; p[j]; j++) ;
 8018ba2:	2300      	movs	r3, #0
 8018ba4:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8018ba8:	e004      	b.n	8018bb4 <f_printf+0x1c8>
 8018baa:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8018bae:	3301      	adds	r3, #1
 8018bb0:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8018bb4:	6ffa      	ldr	r2, [r7, #124]	@ 0x7c
 8018bb6:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8018bba:	4413      	add	r3, r2
 8018bbc:	781b      	ldrb	r3, [r3, #0]
 8018bbe:	2b00      	cmp	r3, #0
 8018bc0:	d1f3      	bne.n	8018baa <f_printf+0x1be>
			if (!(f & 2)) {
 8018bc2:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 8018bc6:	f003 0302 	and.w	r3, r3, #2
 8018bca:	2b00      	cmp	r3, #0
 8018bcc:	d11a      	bne.n	8018c04 <f_printf+0x218>
				while (j++ < w) putc_bfd(&pb, ' ');
 8018bce:	e005      	b.n	8018bdc <f_printf+0x1f0>
 8018bd0:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018bd4:	2120      	movs	r1, #32
 8018bd6:	4618      	mov	r0, r3
 8018bd8:	f7ff fe90 	bl	80188fc <putc_bfd>
 8018bdc:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8018be0:	1c5a      	adds	r2, r3, #1
 8018be2:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 8018be6:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8018bea:	429a      	cmp	r2, r3
 8018bec:	d8f0      	bhi.n	8018bd0 <f_printf+0x1e4>
			}
			while (*p) putc_bfd(&pb, *p++);
 8018bee:	e009      	b.n	8018c04 <f_printf+0x218>
 8018bf0:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8018bf2:	1c5a      	adds	r2, r3, #1
 8018bf4:	67fa      	str	r2, [r7, #124]	@ 0x7c
 8018bf6:	781a      	ldrb	r2, [r3, #0]
 8018bf8:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018bfc:	4611      	mov	r1, r2
 8018bfe:	4618      	mov	r0, r3
 8018c00:	f7ff fe7c 	bl	80188fc <putc_bfd>
 8018c04:	6ffb      	ldr	r3, [r7, #124]	@ 0x7c
 8018c06:	781b      	ldrb	r3, [r3, #0]
 8018c08:	2b00      	cmp	r3, #0
 8018c0a:	d1f1      	bne.n	8018bf0 <f_printf+0x204>
			while (j++ < w) putc_bfd(&pb, ' ');
 8018c0c:	e005      	b.n	8018c1a <f_printf+0x22e>
 8018c0e:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018c12:	2120      	movs	r1, #32
 8018c14:	4618      	mov	r0, r3
 8018c16:	f7ff fe71 	bl	80188fc <putc_bfd>
 8018c1a:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8018c1e:	1c5a      	adds	r2, r3, #1
 8018c20:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 8018c24:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8018c28:	429a      	cmp	r2, r3
 8018c2a:	d8f0      	bhi.n	8018c0e <f_printf+0x222>
			continue;
 8018c2c:	e0ea      	b.n	8018e04 <f_printf+0x418>

		case 'C' :					/* Character */
			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
 8018c2e:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8018c30:	1d1a      	adds	r2, r3, #4
 8018c32:	67ba      	str	r2, [r7, #120]	@ 0x78
 8018c34:	681b      	ldr	r3, [r3, #0]
 8018c36:	b2da      	uxtb	r2, r3
 8018c38:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018c3c:	4611      	mov	r1, r2
 8018c3e:	4618      	mov	r0, r3
 8018c40:	f7ff fe5c 	bl	80188fc <putc_bfd>
 8018c44:	e0de      	b.n	8018e04 <f_printf+0x418>

		case 'B' :					/* Binary */
			r = 2; break;
 8018c46:	2302      	movs	r3, #2
 8018c48:	f887 3096 	strb.w	r3, [r7, #150]	@ 0x96
 8018c4c:	e014      	b.n	8018c78 <f_printf+0x28c>

		case 'O' :					/* Octal */
			r = 8; break;
 8018c4e:	2308      	movs	r3, #8
 8018c50:	f887 3096 	strb.w	r3, [r7, #150]	@ 0x96
 8018c54:	e010      	b.n	8018c78 <f_printf+0x28c>

		case 'D' :					/* Signed decimal */
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
 8018c56:	230a      	movs	r3, #10
 8018c58:	f887 3096 	strb.w	r3, [r7, #150]	@ 0x96
 8018c5c:	e00c      	b.n	8018c78 <f_printf+0x28c>

		case 'X' :					/* Hexdecimal */
			r = 16; break;
 8018c5e:	2310      	movs	r3, #16
 8018c60:	f887 3096 	strb.w	r3, [r7, #150]	@ 0x96
 8018c64:	e008      	b.n	8018c78 <f_printf+0x28c>

		default:					/* Unknown type (pass-through) */
			putc_bfd(&pb, c); continue;
 8018c66:	f897 2083 	ldrb.w	r2, [r7, #131]	@ 0x83
 8018c6a:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018c6e:	4611      	mov	r1, r2
 8018c70:	4618      	mov	r0, r3
 8018c72:	f7ff fe43 	bl	80188fc <putc_bfd>
 8018c76:	e0c5      	b.n	8018e04 <f_printf+0x418>
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
 8018c78:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 8018c7c:	f003 0304 	and.w	r3, r3, #4
 8018c80:	2b00      	cmp	r3, #0
 8018c82:	d004      	beq.n	8018c8e <f_printf+0x2a2>
 8018c84:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8018c86:	1d1a      	adds	r2, r3, #4
 8018c88:	67ba      	str	r2, [r7, #120]	@ 0x78
 8018c8a:	681b      	ldr	r3, [r3, #0]
 8018c8c:	e00c      	b.n	8018ca8 <f_printf+0x2bc>
 8018c8e:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018c92:	2b44      	cmp	r3, #68	@ 0x44
 8018c94:	d104      	bne.n	8018ca0 <f_printf+0x2b4>
 8018c96:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8018c98:	1d1a      	adds	r2, r3, #4
 8018c9a:	67ba      	str	r2, [r7, #120]	@ 0x78
 8018c9c:	681b      	ldr	r3, [r3, #0]
 8018c9e:	e003      	b.n	8018ca8 <f_printf+0x2bc>
 8018ca0:	6fbb      	ldr	r3, [r7, #120]	@ 0x78
 8018ca2:	1d1a      	adds	r2, r3, #4
 8018ca4:	67ba      	str	r2, [r7, #120]	@ 0x78
 8018ca6:	681b      	ldr	r3, [r3, #0]
 8018ca8:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
		if (d == 'D' && (v & 0x80000000)) {
 8018cac:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018cb0:	2b44      	cmp	r3, #68	@ 0x44
 8018cb2:	d10e      	bne.n	8018cd2 <f_printf+0x2e6>
 8018cb4:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8018cb8:	2b00      	cmp	r3, #0
 8018cba:	da0a      	bge.n	8018cd2 <f_printf+0x2e6>
			v = 0 - v;
 8018cbc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8018cc0:	425b      	negs	r3, r3
 8018cc2:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
			f |= 8;
 8018cc6:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 8018cca:	f043 0308 	orr.w	r3, r3, #8
 8018cce:	f887 3097 	strb.w	r3, [r7, #151]	@ 0x97
		}
		i = 0;
 8018cd2:	2300      	movs	r3, #0
 8018cd4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
		do {
			d = (TCHAR)(v % r); v /= r;
 8018cd8:	f897 2096 	ldrb.w	r2, [r7, #150]	@ 0x96
 8018cdc:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8018ce0:	fbb3 f1f2 	udiv	r1, r3, r2
 8018ce4:	fb01 f202 	mul.w	r2, r1, r2
 8018ce8:	1a9b      	subs	r3, r3, r2
 8018cea:	f887 3082 	strb.w	r3, [r7, #130]	@ 0x82
 8018cee:	f897 3096 	ldrb.w	r3, [r7, #150]	@ 0x96
 8018cf2:	f8d7 2084 	ldr.w	r2, [r7, #132]	@ 0x84
 8018cf6:	fbb2 f3f3 	udiv	r3, r2, r3
 8018cfa:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8018cfe:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018d02:	2b09      	cmp	r3, #9
 8018d04:	d90b      	bls.n	8018d1e <f_printf+0x332>
 8018d06:	f897 3083 	ldrb.w	r3, [r7, #131]	@ 0x83
 8018d0a:	2b78      	cmp	r3, #120	@ 0x78
 8018d0c:	d101      	bne.n	8018d12 <f_printf+0x326>
 8018d0e:	2227      	movs	r2, #39	@ 0x27
 8018d10:	e000      	b.n	8018d14 <f_printf+0x328>
 8018d12:	2207      	movs	r2, #7
 8018d14:	f897 3082 	ldrb.w	r3, [r7, #130]	@ 0x82
 8018d18:	4413      	add	r3, r2
 8018d1a:	f887 3082 	strb.w	r3, [r7, #130]	@ 0x82
			str[i++] = d + '0';
 8018d1e:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8018d22:	1c5a      	adds	r2, r3, #1
 8018d24:	f8c7 2090 	str.w	r2, [r7, #144]	@ 0x90
 8018d28:	f897 2082 	ldrb.w	r2, [r7, #130]	@ 0x82
 8018d2c:	3230      	adds	r2, #48	@ 0x30
 8018d2e:	b2d2      	uxtb	r2, r2
 8018d30:	3398      	adds	r3, #152	@ 0x98
 8018d32:	443b      	add	r3, r7
 8018d34:	f803 2c8c 	strb.w	r2, [r3, #-140]
		} while (v && i < sizeof str / sizeof str[0]);
 8018d38:	f8d7 3084 	ldr.w	r3, [r7, #132]	@ 0x84
 8018d3c:	2b00      	cmp	r3, #0
 8018d3e:	d003      	beq.n	8018d48 <f_printf+0x35c>
 8018d40:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8018d44:	2b1f      	cmp	r3, #31
 8018d46:	d9c7      	bls.n	8018cd8 <f_printf+0x2ec>
		if (f & 8) str[i++] = '-';
 8018d48:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 8018d4c:	f003 0308 	and.w	r3, r3, #8
 8018d50:	2b00      	cmp	r3, #0
 8018d52:	d009      	beq.n	8018d68 <f_printf+0x37c>
 8018d54:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8018d58:	1c5a      	adds	r2, r3, #1
 8018d5a:	f8c7 2090 	str.w	r2, [r7, #144]	@ 0x90
 8018d5e:	3398      	adds	r3, #152	@ 0x98
 8018d60:	443b      	add	r3, r7
 8018d62:	222d      	movs	r2, #45	@ 0x2d
 8018d64:	f803 2c8c 	strb.w	r2, [r3, #-140]
		j = i; d = (f & 1) ? '0' : ' ';
 8018d68:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8018d6c:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 8018d70:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 8018d74:	f003 0301 	and.w	r3, r3, #1
 8018d78:	2b00      	cmp	r3, #0
 8018d7a:	d001      	beq.n	8018d80 <f_printf+0x394>
 8018d7c:	2330      	movs	r3, #48	@ 0x30
 8018d7e:	e000      	b.n	8018d82 <f_printf+0x396>
 8018d80:	2320      	movs	r3, #32
 8018d82:	f887 3082 	strb.w	r3, [r7, #130]	@ 0x82
		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
 8018d86:	e007      	b.n	8018d98 <f_printf+0x3ac>
 8018d88:	f897 2082 	ldrb.w	r2, [r7, #130]	@ 0x82
 8018d8c:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018d90:	4611      	mov	r1, r2
 8018d92:	4618      	mov	r0, r3
 8018d94:	f7ff fdb2 	bl	80188fc <putc_bfd>
 8018d98:	f897 3097 	ldrb.w	r3, [r7, #151]	@ 0x97
 8018d9c:	f003 0302 	and.w	r3, r3, #2
 8018da0:	2b00      	cmp	r3, #0
 8018da2:	d108      	bne.n	8018db6 <f_printf+0x3ca>
 8018da4:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8018da8:	1c5a      	adds	r2, r3, #1
 8018daa:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 8018dae:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8018db2:	429a      	cmp	r2, r3
 8018db4:	d8e8      	bhi.n	8018d88 <f_printf+0x39c>
		do {
			putc_bfd(&pb, str[--i]);
 8018db6:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8018dba:	3b01      	subs	r3, #1
 8018dbc:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 8018dc0:	f107 020c 	add.w	r2, r7, #12
 8018dc4:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8018dc8:	4413      	add	r3, r2
 8018dca:	781a      	ldrb	r2, [r3, #0]
 8018dcc:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018dd0:	4611      	mov	r1, r2
 8018dd2:	4618      	mov	r0, r3
 8018dd4:	f7ff fd92 	bl	80188fc <putc_bfd>
		} while (i);
 8018dd8:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8018ddc:	2b00      	cmp	r3, #0
 8018dde:	d1ea      	bne.n	8018db6 <f_printf+0x3ca>
		while (j++ < w) putc_bfd(&pb, d);
 8018de0:	e007      	b.n	8018df2 <f_printf+0x406>
 8018de2:	f897 2082 	ldrb.w	r2, [r7, #130]	@ 0x82
 8018de6:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018dea:	4611      	mov	r1, r2
 8018dec:	4618      	mov	r0, r3
 8018dee:	f7ff fd85 	bl	80188fc <putc_bfd>
 8018df2:	f8d7 308c 	ldr.w	r3, [r7, #140]	@ 0x8c
 8018df6:	1c5a      	adds	r2, r3, #1
 8018df8:	f8c7 208c 	str.w	r2, [r7, #140]	@ 0x8c
 8018dfc:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
 8018e00:	429a      	cmp	r2, r3
 8018e02:	d8ee      	bhi.n	8018de2 <f_printf+0x3f6>
		c = *fmt++;
 8018e04:	e600      	b.n	8018a08 <f_printf+0x1c>
		if (c == 0) break;			/* End of string */
 8018e06:	bf00      	nop
 8018e08:	e000      	b.n	8018e0c <f_printf+0x420>
		if (!c) break;
 8018e0a:	bf00      	nop
	}

	va_end(arp);

	return putc_flush(&pb);
 8018e0c:	f107 032c 	add.w	r3, r7, #44	@ 0x2c
 8018e10:	4618      	mov	r0, r3
 8018e12:	f7ff fdb0 	bl	8018976 <putc_flush>
 8018e16:	4603      	mov	r3, r0
}
 8018e18:	4618      	mov	r0, r3
 8018e1a:	379c      	adds	r7, #156	@ 0x9c
 8018e1c:	46bd      	mov	sp, r7
 8018e1e:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8018e22:	b003      	add	sp, #12
 8018e24:	4770      	bx	lr
 8018e26:	bf00      	nop

08018e28 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the parameter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 8018e28:	b480      	push	{r7}
 8018e2a:	b087      	sub	sp, #28
 8018e2c:	af00      	add	r7, sp, #0
 8018e2e:	60f8      	str	r0, [r7, #12]
 8018e30:	60b9      	str	r1, [r7, #8]
 8018e32:	4613      	mov	r3, r2
 8018e34:	71fb      	strb	r3, [r7, #7]
  uint8_t ret = 1;
 8018e36:	2301      	movs	r3, #1
 8018e38:	75fb      	strb	r3, [r7, #23]
  uint8_t DiskNum = 0;
 8018e3a:	2300      	movs	r3, #0
 8018e3c:	75bb      	strb	r3, [r7, #22]

  if(disk.nbr < _VOLUMES)
 8018e3e:	4b1f      	ldr	r3, [pc, #124]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e40:	7b9b      	ldrb	r3, [r3, #14]
 8018e42:	b2db      	uxtb	r3, r3
 8018e44:	2b01      	cmp	r3, #1
 8018e46:	d831      	bhi.n	8018eac <FATFS_LinkDriverEx+0x84>
  {
    disk.is_initialized[disk.nbr] = 0;
 8018e48:	4b1c      	ldr	r3, [pc, #112]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e4a:	7b9b      	ldrb	r3, [r3, #14]
 8018e4c:	b2db      	uxtb	r3, r3
 8018e4e:	461a      	mov	r2, r3
 8018e50:	4b1a      	ldr	r3, [pc, #104]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e52:	2100      	movs	r1, #0
 8018e54:	5499      	strb	r1, [r3, r2]
    disk.drv[disk.nbr] = drv;
 8018e56:	4b19      	ldr	r3, [pc, #100]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e58:	7b9b      	ldrb	r3, [r3, #14]
 8018e5a:	b2db      	uxtb	r3, r3
 8018e5c:	4a17      	ldr	r2, [pc, #92]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e5e:	009b      	lsls	r3, r3, #2
 8018e60:	4413      	add	r3, r2
 8018e62:	68fa      	ldr	r2, [r7, #12]
 8018e64:	605a      	str	r2, [r3, #4]
    disk.lun[disk.nbr] = lun;
 8018e66:	4b15      	ldr	r3, [pc, #84]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e68:	7b9b      	ldrb	r3, [r3, #14]
 8018e6a:	b2db      	uxtb	r3, r3
 8018e6c:	461a      	mov	r2, r3
 8018e6e:	4b13      	ldr	r3, [pc, #76]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e70:	4413      	add	r3, r2
 8018e72:	79fa      	ldrb	r2, [r7, #7]
 8018e74:	731a      	strb	r2, [r3, #12]
    DiskNum = disk.nbr++;
 8018e76:	4b11      	ldr	r3, [pc, #68]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e78:	7b9b      	ldrb	r3, [r3, #14]
 8018e7a:	b2db      	uxtb	r3, r3
 8018e7c:	1c5a      	adds	r2, r3, #1
 8018e7e:	b2d1      	uxtb	r1, r2
 8018e80:	4a0e      	ldr	r2, [pc, #56]	@ (8018ebc <FATFS_LinkDriverEx+0x94>)
 8018e82:	7391      	strb	r1, [r2, #14]
 8018e84:	75bb      	strb	r3, [r7, #22]
    path[0] = DiskNum + '0';
 8018e86:	7dbb      	ldrb	r3, [r7, #22]
 8018e88:	3330      	adds	r3, #48	@ 0x30
 8018e8a:	b2da      	uxtb	r2, r3
 8018e8c:	68bb      	ldr	r3, [r7, #8]
 8018e8e:	701a      	strb	r2, [r3, #0]
    path[1] = ':';
 8018e90:	68bb      	ldr	r3, [r7, #8]
 8018e92:	3301      	adds	r3, #1
 8018e94:	223a      	movs	r2, #58	@ 0x3a
 8018e96:	701a      	strb	r2, [r3, #0]
    path[2] = '/';
 8018e98:	68bb      	ldr	r3, [r7, #8]
 8018e9a:	3302      	adds	r3, #2
 8018e9c:	222f      	movs	r2, #47	@ 0x2f
 8018e9e:	701a      	strb	r2, [r3, #0]
    path[3] = 0;
 8018ea0:	68bb      	ldr	r3, [r7, #8]
 8018ea2:	3303      	adds	r3, #3
 8018ea4:	2200      	movs	r2, #0
 8018ea6:	701a      	strb	r2, [r3, #0]
    ret = 0;
 8018ea8:	2300      	movs	r3, #0
 8018eaa:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
 8018eac:	7dfb      	ldrb	r3, [r7, #23]
}
 8018eae:	4618      	mov	r0, r3
 8018eb0:	371c      	adds	r7, #28
 8018eb2:	46bd      	mov	sp, r7
 8018eb4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018eb8:	4770      	bx	lr
 8018eba:	bf00      	nop
 8018ebc:	2000a80c 	.word	0x2000a80c

08018ec0 <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
 8018ec0:	b580      	push	{r7, lr}
 8018ec2:	b082      	sub	sp, #8
 8018ec4:	af00      	add	r7, sp, #0
 8018ec6:	6078      	str	r0, [r7, #4]
 8018ec8:	6039      	str	r1, [r7, #0]
  return FATFS_LinkDriverEx(drv, path, 0);
 8018eca:	2200      	movs	r2, #0
 8018ecc:	6839      	ldr	r1, [r7, #0]
 8018ece:	6878      	ldr	r0, [r7, #4]
 8018ed0:	f7ff ffaa 	bl	8018e28 <FATFS_LinkDriverEx>
 8018ed4:	4603      	mov	r3, r0
}
 8018ed6:	4618      	mov	r0, r3
 8018ed8:	3708      	adds	r7, #8
 8018eda:	46bd      	mov	sp, r7
 8018edc:	bd80      	pop	{r7, pc}

08018ede <ff_memalloc>:
*/

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
 8018ede:	b580      	push	{r7, lr}
 8018ee0:	b082      	sub	sp, #8
 8018ee2:	af00      	add	r7, sp, #0
 8018ee4:	6078      	str	r0, [r7, #4]
	return ff_malloc(msize);	/* Allocate a new memory block with POSIX API */
 8018ee6:	6878      	ldr	r0, [r7, #4]
 8018ee8:	f007 ff26 	bl	8020d38 <malloc>
 8018eec:	4603      	mov	r3, r0
}
 8018eee:	4618      	mov	r0, r3
 8018ef0:	3708      	adds	r7, #8
 8018ef2:	46bd      	mov	sp, r7
 8018ef4:	bd80      	pop	{r7, pc}

08018ef6 <ff_memfree>:
/*------------------------------------------------------------------------*/

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
 8018ef6:	b580      	push	{r7, lr}
 8018ef8:	b082      	sub	sp, #8
 8018efa:	af00      	add	r7, sp, #0
 8018efc:	6078      	str	r0, [r7, #4]
	ff_free(mblock);	/* Discard the memory block with POSIX API */
 8018efe:	6878      	ldr	r0, [r7, #4]
 8018f00:	f007 ff22 	bl	8020d48 <free>
}
 8018f04:	bf00      	nop
 8018f06:	3708      	adds	r7, #8
 8018f08:	46bd      	mov	sp, r7
 8018f0a:	bd80      	pop	{r7, pc}

08018f0c <ff_convert>:

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	chr,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEM code, 1: OEM code to Unicode */
)
{
 8018f0c:	b480      	push	{r7}
 8018f0e:	b085      	sub	sp, #20
 8018f10:	af00      	add	r7, sp, #0
 8018f12:	4603      	mov	r3, r0
 8018f14:	6039      	str	r1, [r7, #0]
 8018f16:	80fb      	strh	r3, [r7, #6]
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
 8018f18:	88fb      	ldrh	r3, [r7, #6]
 8018f1a:	2b7f      	cmp	r3, #127	@ 0x7f
 8018f1c:	d802      	bhi.n	8018f24 <ff_convert+0x18>
		c = chr;
 8018f1e:	88fb      	ldrh	r3, [r7, #6]
 8018f20:	81fb      	strh	r3, [r7, #14]
 8018f22:	e025      	b.n	8018f70 <ff_convert+0x64>

	} else {
		if (dir) {		/* OEM code to Unicode */
 8018f24:	683b      	ldr	r3, [r7, #0]
 8018f26:	2b00      	cmp	r3, #0
 8018f28:	d00b      	beq.n	8018f42 <ff_convert+0x36>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
 8018f2a:	88fb      	ldrh	r3, [r7, #6]
 8018f2c:	2bff      	cmp	r3, #255	@ 0xff
 8018f2e:	d805      	bhi.n	8018f3c <ff_convert+0x30>
 8018f30:	88fb      	ldrh	r3, [r7, #6]
 8018f32:	3b80      	subs	r3, #128	@ 0x80
 8018f34:	4a12      	ldr	r2, [pc, #72]	@ (8018f80 <ff_convert+0x74>)
 8018f36:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8018f3a:	e000      	b.n	8018f3e <ff_convert+0x32>
 8018f3c:	2300      	movs	r3, #0
 8018f3e:	81fb      	strh	r3, [r7, #14]
 8018f40:	e016      	b.n	8018f70 <ff_convert+0x64>

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
 8018f42:	2300      	movs	r3, #0
 8018f44:	81fb      	strh	r3, [r7, #14]
 8018f46:	e009      	b.n	8018f5c <ff_convert+0x50>
				if (chr == Tbl[c]) break;
 8018f48:	89fb      	ldrh	r3, [r7, #14]
 8018f4a:	4a0d      	ldr	r2, [pc, #52]	@ (8018f80 <ff_convert+0x74>)
 8018f4c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8018f50:	88fa      	ldrh	r2, [r7, #6]
 8018f52:	429a      	cmp	r2, r3
 8018f54:	d006      	beq.n	8018f64 <ff_convert+0x58>
			for (c = 0; c < 0x80; c++) {
 8018f56:	89fb      	ldrh	r3, [r7, #14]
 8018f58:	3301      	adds	r3, #1
 8018f5a:	81fb      	strh	r3, [r7, #14]
 8018f5c:	89fb      	ldrh	r3, [r7, #14]
 8018f5e:	2b7f      	cmp	r3, #127	@ 0x7f
 8018f60:	d9f2      	bls.n	8018f48 <ff_convert+0x3c>
 8018f62:	e000      	b.n	8018f66 <ff_convert+0x5a>
				if (chr == Tbl[c]) break;
 8018f64:	bf00      	nop
			}
			c = (c + 0x80) & 0xFF;
 8018f66:	89fb      	ldrh	r3, [r7, #14]
 8018f68:	3380      	adds	r3, #128	@ 0x80
 8018f6a:	b29b      	uxth	r3, r3
 8018f6c:	b2db      	uxtb	r3, r3
 8018f6e:	81fb      	strh	r3, [r7, #14]
		}
	}

	return c;
 8018f70:	89fb      	ldrh	r3, [r7, #14]
}
 8018f72:	4618      	mov	r0, r3
 8018f74:	3714      	adds	r7, #20
 8018f76:	46bd      	mov	sp, r7
 8018f78:	f85d 7b04 	ldr.w	r7, [sp], #4
 8018f7c:	4770      	bx	lr
 8018f7e:	bf00      	nop
 8018f80:	0803516c 	.word	0x0803516c

08018f84 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
)
{
 8018f84:	b480      	push	{r7}
 8018f86:	b087      	sub	sp, #28
 8018f88:	af00      	add	r7, sp, #0
 8018f8a:	4603      	mov	r3, r0
 8018f8c:	80fb      	strh	r3, [r7, #6]
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
 8018f8e:	88fb      	ldrh	r3, [r7, #6]
 8018f90:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8018f94:	d201      	bcs.n	8018f9a <ff_wtoupper+0x16>
 8018f96:	4b3e      	ldr	r3, [pc, #248]	@ (8019090 <ff_wtoupper+0x10c>)
 8018f98:	e000      	b.n	8018f9c <ff_wtoupper+0x18>
 8018f9a:	4b3e      	ldr	r3, [pc, #248]	@ (8019094 <ff_wtoupper+0x110>)
 8018f9c:	617b      	str	r3, [r7, #20]
	for (;;) {
		bc = *p++;								/* Get block base */
 8018f9e:	697b      	ldr	r3, [r7, #20]
 8018fa0:	1c9a      	adds	r2, r3, #2
 8018fa2:	617a      	str	r2, [r7, #20]
 8018fa4:	881b      	ldrh	r3, [r3, #0]
 8018fa6:	827b      	strh	r3, [r7, #18]
		if (!bc || chr < bc) break;
 8018fa8:	8a7b      	ldrh	r3, [r7, #18]
 8018faa:	2b00      	cmp	r3, #0
 8018fac:	d068      	beq.n	8019080 <ff_wtoupper+0xfc>
 8018fae:	88fa      	ldrh	r2, [r7, #6]
 8018fb0:	8a7b      	ldrh	r3, [r7, #18]
 8018fb2:	429a      	cmp	r2, r3
 8018fb4:	d364      	bcc.n	8019080 <ff_wtoupper+0xfc>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 8018fb6:	697b      	ldr	r3, [r7, #20]
 8018fb8:	1c9a      	adds	r2, r3, #2
 8018fba:	617a      	str	r2, [r7, #20]
 8018fbc:	881b      	ldrh	r3, [r3, #0]
 8018fbe:	823b      	strh	r3, [r7, #16]
 8018fc0:	8a3b      	ldrh	r3, [r7, #16]
 8018fc2:	0a1b      	lsrs	r3, r3, #8
 8018fc4:	81fb      	strh	r3, [r7, #14]
 8018fc6:	8a3b      	ldrh	r3, [r7, #16]
 8018fc8:	b2db      	uxtb	r3, r3
 8018fca:	823b      	strh	r3, [r7, #16]
		if (chr < bc + nc) {	/* In the block? */
 8018fcc:	88fa      	ldrh	r2, [r7, #6]
 8018fce:	8a79      	ldrh	r1, [r7, #18]
 8018fd0:	8a3b      	ldrh	r3, [r7, #16]
 8018fd2:	440b      	add	r3, r1
 8018fd4:	429a      	cmp	r2, r3
 8018fd6:	da49      	bge.n	801906c <ff_wtoupper+0xe8>
			switch (cmd) {
 8018fd8:	89fb      	ldrh	r3, [r7, #14]
 8018fda:	2b08      	cmp	r3, #8
 8018fdc:	d84f      	bhi.n	801907e <ff_wtoupper+0xfa>
 8018fde:	a201      	add	r2, pc, #4	@ (adr r2, 8018fe4 <ff_wtoupper+0x60>)
 8018fe0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8018fe4:	08019009 	.word	0x08019009
 8018fe8:	0801901b 	.word	0x0801901b
 8018fec:	08019031 	.word	0x08019031
 8018ff0:	08019039 	.word	0x08019039
 8018ff4:	08019041 	.word	0x08019041
 8018ff8:	08019049 	.word	0x08019049
 8018ffc:	08019051 	.word	0x08019051
 8019000:	08019059 	.word	0x08019059
 8019004:	08019061 	.word	0x08019061
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
 8019008:	88fa      	ldrh	r2, [r7, #6]
 801900a:	8a7b      	ldrh	r3, [r7, #18]
 801900c:	1ad3      	subs	r3, r2, r3
 801900e:	005b      	lsls	r3, r3, #1
 8019010:	697a      	ldr	r2, [r7, #20]
 8019012:	4413      	add	r3, r2
 8019014:	881b      	ldrh	r3, [r3, #0]
 8019016:	80fb      	strh	r3, [r7, #6]
 8019018:	e027      	b.n	801906a <ff_wtoupper+0xe6>
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
 801901a:	88fa      	ldrh	r2, [r7, #6]
 801901c:	8a7b      	ldrh	r3, [r7, #18]
 801901e:	1ad3      	subs	r3, r2, r3
 8019020:	b29b      	uxth	r3, r3
 8019022:	f003 0301 	and.w	r3, r3, #1
 8019026:	b29b      	uxth	r3, r3
 8019028:	88fa      	ldrh	r2, [r7, #6]
 801902a:	1ad3      	subs	r3, r2, r3
 801902c:	80fb      	strh	r3, [r7, #6]
 801902e:	e01c      	b.n	801906a <ff_wtoupper+0xe6>
			case 2: chr -= 16; break;				/* Shift -16 */
 8019030:	88fb      	ldrh	r3, [r7, #6]
 8019032:	3b10      	subs	r3, #16
 8019034:	80fb      	strh	r3, [r7, #6]
 8019036:	e018      	b.n	801906a <ff_wtoupper+0xe6>
			case 3:	chr -= 32; break;				/* Shift -32 */
 8019038:	88fb      	ldrh	r3, [r7, #6]
 801903a:	3b20      	subs	r3, #32
 801903c:	80fb      	strh	r3, [r7, #6]
 801903e:	e014      	b.n	801906a <ff_wtoupper+0xe6>
			case 4:	chr -= 48; break;				/* Shift -48 */
 8019040:	88fb      	ldrh	r3, [r7, #6]
 8019042:	3b30      	subs	r3, #48	@ 0x30
 8019044:	80fb      	strh	r3, [r7, #6]
 8019046:	e010      	b.n	801906a <ff_wtoupper+0xe6>
			case 5:	chr -= 26; break;				/* Shift -26 */
 8019048:	88fb      	ldrh	r3, [r7, #6]
 801904a:	3b1a      	subs	r3, #26
 801904c:	80fb      	strh	r3, [r7, #6]
 801904e:	e00c      	b.n	801906a <ff_wtoupper+0xe6>
			case 6:	chr += 8; break;				/* Shift +8 */
 8019050:	88fb      	ldrh	r3, [r7, #6]
 8019052:	3308      	adds	r3, #8
 8019054:	80fb      	strh	r3, [r7, #6]
 8019056:	e008      	b.n	801906a <ff_wtoupper+0xe6>
			case 7: chr -= 80; break;				/* Shift -80 */
 8019058:	88fb      	ldrh	r3, [r7, #6]
 801905a:	3b50      	subs	r3, #80	@ 0x50
 801905c:	80fb      	strh	r3, [r7, #6]
 801905e:	e004      	b.n	801906a <ff_wtoupper+0xe6>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
 8019060:	88fb      	ldrh	r3, [r7, #6]
 8019062:	f5a3 53e3 	sub.w	r3, r3, #7264	@ 0x1c60
 8019066:	80fb      	strh	r3, [r7, #6]
 8019068:	bf00      	nop
			}
			break;
 801906a:	e008      	b.n	801907e <ff_wtoupper+0xfa>
		}
		if (!cmd) p += nc;
 801906c:	89fb      	ldrh	r3, [r7, #14]
 801906e:	2b00      	cmp	r3, #0
 8019070:	d195      	bne.n	8018f9e <ff_wtoupper+0x1a>
 8019072:	8a3b      	ldrh	r3, [r7, #16]
 8019074:	005b      	lsls	r3, r3, #1
 8019076:	697a      	ldr	r2, [r7, #20]
 8019078:	4413      	add	r3, r2
 801907a:	617b      	str	r3, [r7, #20]
		bc = *p++;								/* Get block base */
 801907c:	e78f      	b.n	8018f9e <ff_wtoupper+0x1a>
			break;
 801907e:	bf00      	nop
	}

	return chr;
 8019080:	88fb      	ldrh	r3, [r7, #6]
}
 8019082:	4618      	mov	r0, r3
 8019084:	371c      	adds	r7, #28
 8019086:	46bd      	mov	sp, r7
 8019088:	f85d 7b04 	ldr.w	r7, [sp], #4
 801908c:	4770      	bx	lr
 801908e:	bf00      	nop
 8019090:	0803526c 	.word	0x0803526c
 8019094:	08035460 	.word	0x08035460

08019098 <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 8019098:	b580      	push	{r7, lr}
 801909a:	af00      	add	r7, sp, #0

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 801909c:	f000 f996 	bl	80193cc <xTaskGetSchedulerState>
 80190a0:	4603      	mov	r3, r0
 80190a2:	2b01      	cmp	r3, #1
 80190a4:	d001      	beq.n	80190aa <osSystickHandler+0x12>
  {
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
 80190a6:	f000 f9ff 	bl	80194a8 <xPortSysTickHandler>
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 80190aa:	bf00      	nop
 80190ac:	bd80      	pop	{r7, pc}

080190ae <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80190ae:	b480      	push	{r7}
 80190b0:	b085      	sub	sp, #20
 80190b2:	af00      	add	r7, sp, #0
 80190b4:	6078      	str	r0, [r7, #4]
 80190b6:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 80190b8:	687b      	ldr	r3, [r7, #4]
 80190ba:	685b      	ldr	r3, [r3, #4]
 80190bc:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80190be:	683b      	ldr	r3, [r7, #0]
 80190c0:	68fa      	ldr	r2, [r7, #12]
 80190c2:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80190c4:	68fb      	ldr	r3, [r7, #12]
 80190c6:	689a      	ldr	r2, [r3, #8]
 80190c8:	683b      	ldr	r3, [r7, #0]
 80190ca:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80190cc:	68fb      	ldr	r3, [r7, #12]
 80190ce:	689b      	ldr	r3, [r3, #8]
 80190d0:	683a      	ldr	r2, [r7, #0]
 80190d2:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80190d4:	68fb      	ldr	r3, [r7, #12]
 80190d6:	683a      	ldr	r2, [r7, #0]
 80190d8:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80190da:	683b      	ldr	r3, [r7, #0]
 80190dc:	687a      	ldr	r2, [r7, #4]
 80190de:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 80190e0:	687b      	ldr	r3, [r7, #4]
 80190e2:	681b      	ldr	r3, [r3, #0]
 80190e4:	1c5a      	adds	r2, r3, #1
 80190e6:	687b      	ldr	r3, [r7, #4]
 80190e8:	601a      	str	r2, [r3, #0]
}
 80190ea:	bf00      	nop
 80190ec:	3714      	adds	r7, #20
 80190ee:	46bd      	mov	sp, r7
 80190f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80190f4:	4770      	bx	lr

080190f6 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 80190f6:	b480      	push	{r7}
 80190f8:	b085      	sub	sp, #20
 80190fa:	af00      	add	r7, sp, #0
 80190fc:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 80190fe:	687b      	ldr	r3, [r7, #4]
 8019100:	691b      	ldr	r3, [r3, #16]
 8019102:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8019104:	687b      	ldr	r3, [r7, #4]
 8019106:	685b      	ldr	r3, [r3, #4]
 8019108:	687a      	ldr	r2, [r7, #4]
 801910a:	6892      	ldr	r2, [r2, #8]
 801910c:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 801910e:	687b      	ldr	r3, [r7, #4]
 8019110:	689b      	ldr	r3, [r3, #8]
 8019112:	687a      	ldr	r2, [r7, #4]
 8019114:	6852      	ldr	r2, [r2, #4]
 8019116:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8019118:	68fb      	ldr	r3, [r7, #12]
 801911a:	685b      	ldr	r3, [r3, #4]
 801911c:	687a      	ldr	r2, [r7, #4]
 801911e:	429a      	cmp	r2, r3
 8019120:	d103      	bne.n	801912a <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8019122:	687b      	ldr	r3, [r7, #4]
 8019124:	689a      	ldr	r2, [r3, #8]
 8019126:	68fb      	ldr	r3, [r7, #12]
 8019128:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 801912a:	687b      	ldr	r3, [r7, #4]
 801912c:	2200      	movs	r2, #0
 801912e:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8019130:	68fb      	ldr	r3, [r7, #12]
 8019132:	681b      	ldr	r3, [r3, #0]
 8019134:	1e5a      	subs	r2, r3, #1
 8019136:	68fb      	ldr	r3, [r7, #12]
 8019138:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 801913a:	68fb      	ldr	r3, [r7, #12]
 801913c:	681b      	ldr	r3, [r3, #0]
}
 801913e:	4618      	mov	r0, r3
 8019140:	3714      	adds	r7, #20
 8019142:	46bd      	mov	sp, r7
 8019144:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019148:	4770      	bx	lr
	...

0801914c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 801914c:	b580      	push	{r7, lr}
 801914e:	b086      	sub	sp, #24
 8019150:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8019152:	2300      	movs	r3, #0
 8019154:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8019156:	4b51      	ldr	r3, [pc, #324]	@ (801929c <xTaskIncrementTick+0x150>)
 8019158:	681b      	ldr	r3, [r3, #0]
 801915a:	2b00      	cmp	r3, #0
 801915c:	f040 808e 	bne.w	801927c <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8019160:	4b4f      	ldr	r3, [pc, #316]	@ (80192a0 <xTaskIncrementTick+0x154>)
 8019162:	681b      	ldr	r3, [r3, #0]
 8019164:	3301      	adds	r3, #1
 8019166:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8019168:	4a4d      	ldr	r2, [pc, #308]	@ (80192a0 <xTaskIncrementTick+0x154>)
 801916a:	693b      	ldr	r3, [r7, #16]
 801916c:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 801916e:	693b      	ldr	r3, [r7, #16]
 8019170:	2b00      	cmp	r3, #0
 8019172:	d121      	bne.n	80191b8 <xTaskIncrementTick+0x6c>
		{
			taskSWITCH_DELAYED_LISTS();
 8019174:	4b4b      	ldr	r3, [pc, #300]	@ (80192a4 <xTaskIncrementTick+0x158>)
 8019176:	681b      	ldr	r3, [r3, #0]
 8019178:	681b      	ldr	r3, [r3, #0]
 801917a:	2b00      	cmp	r3, #0
 801917c:	d00b      	beq.n	8019196 <xTaskIncrementTick+0x4a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 801917e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8019182:	f383 8811 	msr	BASEPRI, r3
 8019186:	f3bf 8f6f 	isb	sy
 801918a:	f3bf 8f4f 	dsb	sy
 801918e:	603b      	str	r3, [r7, #0]
		"	msr basepri, %0											\n" \
		"	isb														\n" \
		"	dsb														\n" \
		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);
}
 8019190:	bf00      	nop
 8019192:	bf00      	nop
 8019194:	e7fd      	b.n	8019192 <xTaskIncrementTick+0x46>
 8019196:	4b43      	ldr	r3, [pc, #268]	@ (80192a4 <xTaskIncrementTick+0x158>)
 8019198:	681b      	ldr	r3, [r3, #0]
 801919a:	60fb      	str	r3, [r7, #12]
 801919c:	4b42      	ldr	r3, [pc, #264]	@ (80192a8 <xTaskIncrementTick+0x15c>)
 801919e:	681b      	ldr	r3, [r3, #0]
 80191a0:	4a40      	ldr	r2, [pc, #256]	@ (80192a4 <xTaskIncrementTick+0x158>)
 80191a2:	6013      	str	r3, [r2, #0]
 80191a4:	4a40      	ldr	r2, [pc, #256]	@ (80192a8 <xTaskIncrementTick+0x15c>)
 80191a6:	68fb      	ldr	r3, [r7, #12]
 80191a8:	6013      	str	r3, [r2, #0]
 80191aa:	4b40      	ldr	r3, [pc, #256]	@ (80192ac <xTaskIncrementTick+0x160>)
 80191ac:	681b      	ldr	r3, [r3, #0]
 80191ae:	3301      	adds	r3, #1
 80191b0:	4a3e      	ldr	r2, [pc, #248]	@ (80192ac <xTaskIncrementTick+0x160>)
 80191b2:	6013      	str	r3, [r2, #0]
 80191b4:	f000 f8e4 	bl	8019380 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 80191b8:	4b3d      	ldr	r3, [pc, #244]	@ (80192b0 <xTaskIncrementTick+0x164>)
 80191ba:	681b      	ldr	r3, [r3, #0]
 80191bc:	693a      	ldr	r2, [r7, #16]
 80191be:	429a      	cmp	r2, r3
 80191c0:	d34d      	bcc.n	801925e <xTaskIncrementTick+0x112>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80191c2:	4b38      	ldr	r3, [pc, #224]	@ (80192a4 <xTaskIncrementTick+0x158>)
 80191c4:	681b      	ldr	r3, [r3, #0]
 80191c6:	681b      	ldr	r3, [r3, #0]
 80191c8:	2b00      	cmp	r3, #0
 80191ca:	d101      	bne.n	80191d0 <xTaskIncrementTick+0x84>
 80191cc:	2301      	movs	r3, #1
 80191ce:	e000      	b.n	80191d2 <xTaskIncrementTick+0x86>
 80191d0:	2300      	movs	r3, #0
 80191d2:	2b00      	cmp	r3, #0
 80191d4:	d004      	beq.n	80191e0 <xTaskIncrementTick+0x94>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80191d6:	4b36      	ldr	r3, [pc, #216]	@ (80192b0 <xTaskIncrementTick+0x164>)
 80191d8:	f04f 32ff 	mov.w	r2, #4294967295
 80191dc:	601a      	str	r2, [r3, #0]
					break;
 80191de:	e03e      	b.n	801925e <xTaskIncrementTick+0x112>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80191e0:	4b30      	ldr	r3, [pc, #192]	@ (80192a4 <xTaskIncrementTick+0x158>)
 80191e2:	681b      	ldr	r3, [r3, #0]
 80191e4:	68db      	ldr	r3, [r3, #12]
 80191e6:	68db      	ldr	r3, [r3, #12]
 80191e8:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80191ea:	68bb      	ldr	r3, [r7, #8]
 80191ec:	685b      	ldr	r3, [r3, #4]
 80191ee:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 80191f0:	693a      	ldr	r2, [r7, #16]
 80191f2:	687b      	ldr	r3, [r7, #4]
 80191f4:	429a      	cmp	r2, r3
 80191f6:	d203      	bcs.n	8019200 <xTaskIncrementTick+0xb4>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 80191f8:	4a2d      	ldr	r2, [pc, #180]	@ (80192b0 <xTaskIncrementTick+0x164>)
 80191fa:	687b      	ldr	r3, [r7, #4]
 80191fc:	6013      	str	r3, [r2, #0]
						break;
 80191fe:	e02e      	b.n	801925e <xTaskIncrementTick+0x112>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8019200:	68bb      	ldr	r3, [r7, #8]
 8019202:	3304      	adds	r3, #4
 8019204:	4618      	mov	r0, r3
 8019206:	f7ff ff76 	bl	80190f6 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 801920a:	68bb      	ldr	r3, [r7, #8]
 801920c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801920e:	2b00      	cmp	r3, #0
 8019210:	d004      	beq.n	801921c <xTaskIncrementTick+0xd0>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8019212:	68bb      	ldr	r3, [r7, #8]
 8019214:	3318      	adds	r3, #24
 8019216:	4618      	mov	r0, r3
 8019218:	f7ff ff6d 	bl	80190f6 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 801921c:	68bb      	ldr	r3, [r7, #8]
 801921e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8019220:	2201      	movs	r2, #1
 8019222:	409a      	lsls	r2, r3
 8019224:	4b23      	ldr	r3, [pc, #140]	@ (80192b4 <xTaskIncrementTick+0x168>)
 8019226:	681b      	ldr	r3, [r3, #0]
 8019228:	4313      	orrs	r3, r2
 801922a:	4a22      	ldr	r2, [pc, #136]	@ (80192b4 <xTaskIncrementTick+0x168>)
 801922c:	6013      	str	r3, [r2, #0]
 801922e:	68bb      	ldr	r3, [r7, #8]
 8019230:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8019232:	4613      	mov	r3, r2
 8019234:	009b      	lsls	r3, r3, #2
 8019236:	4413      	add	r3, r2
 8019238:	009b      	lsls	r3, r3, #2
 801923a:	4a1f      	ldr	r2, [pc, #124]	@ (80192b8 <xTaskIncrementTick+0x16c>)
 801923c:	441a      	add	r2, r3
 801923e:	68bb      	ldr	r3, [r7, #8]
 8019240:	3304      	adds	r3, #4
 8019242:	4619      	mov	r1, r3
 8019244:	4610      	mov	r0, r2
 8019246:	f7ff ff32 	bl	80190ae <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 801924a:	68bb      	ldr	r3, [r7, #8]
 801924c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 801924e:	4b1b      	ldr	r3, [pc, #108]	@ (80192bc <xTaskIncrementTick+0x170>)
 8019250:	681b      	ldr	r3, [r3, #0]
 8019252:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8019254:	429a      	cmp	r2, r3
 8019256:	d3b4      	bcc.n	80191c2 <xTaskIncrementTick+0x76>
						{
							xSwitchRequired = pdTRUE;
 8019258:	2301      	movs	r3, #1
 801925a:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801925c:	e7b1      	b.n	80191c2 <xTaskIncrementTick+0x76>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 801925e:	4b17      	ldr	r3, [pc, #92]	@ (80192bc <xTaskIncrementTick+0x170>)
 8019260:	681b      	ldr	r3, [r3, #0]
 8019262:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 8019264:	4914      	ldr	r1, [pc, #80]	@ (80192b8 <xTaskIncrementTick+0x16c>)
 8019266:	4613      	mov	r3, r2
 8019268:	009b      	lsls	r3, r3, #2
 801926a:	4413      	add	r3, r2
 801926c:	009b      	lsls	r3, r3, #2
 801926e:	440b      	add	r3, r1
 8019270:	681b      	ldr	r3, [r3, #0]
 8019272:	2b01      	cmp	r3, #1
 8019274:	d907      	bls.n	8019286 <xTaskIncrementTick+0x13a>
			{
				xSwitchRequired = pdTRUE;
 8019276:	2301      	movs	r3, #1
 8019278:	617b      	str	r3, [r7, #20]
 801927a:	e004      	b.n	8019286 <xTaskIncrementTick+0x13a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 801927c:	4b10      	ldr	r3, [pc, #64]	@ (80192c0 <xTaskIncrementTick+0x174>)
 801927e:	681b      	ldr	r3, [r3, #0]
 8019280:	3301      	adds	r3, #1
 8019282:	4a0f      	ldr	r2, [pc, #60]	@ (80192c0 <xTaskIncrementTick+0x174>)
 8019284:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8019286:	4b0f      	ldr	r3, [pc, #60]	@ (80192c4 <xTaskIncrementTick+0x178>)
 8019288:	681b      	ldr	r3, [r3, #0]
 801928a:	2b00      	cmp	r3, #0
 801928c:	d001      	beq.n	8019292 <xTaskIncrementTick+0x146>
		{
			xSwitchRequired = pdTRUE;
 801928e:	2301      	movs	r3, #1
 8019290:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 8019292:	697b      	ldr	r3, [r7, #20]
}
 8019294:	4618      	mov	r0, r3
 8019296:	3718      	adds	r7, #24
 8019298:	46bd      	mov	sp, r7
 801929a:	bd80      	pop	{r7, pc}
 801929c:	2000a8d0 	.word	0x2000a8d0
 80192a0:	2000a8b4 	.word	0x2000a8b4
 80192a4:	2000a8ac 	.word	0x2000a8ac
 80192a8:	2000a8b0 	.word	0x2000a8b0
 80192ac:	2000a8c8 	.word	0x2000a8c8
 80192b0:	2000a8cc 	.word	0x2000a8cc
 80192b4:	2000a8b8 	.word	0x2000a8b8
 80192b8:	2000a820 	.word	0x2000a820
 80192bc:	2000a81c 	.word	0x2000a81c
 80192c0:	2000a8c0 	.word	0x2000a8c0
 80192c4:	2000a8c4 	.word	0x2000a8c4

080192c8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80192c8:	b480      	push	{r7}
 80192ca:	b087      	sub	sp, #28
 80192cc:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80192ce:	4b27      	ldr	r3, [pc, #156]	@ (801936c <vTaskSwitchContext+0xa4>)
 80192d0:	681b      	ldr	r3, [r3, #0]
 80192d2:	2b00      	cmp	r3, #0
 80192d4:	d003      	beq.n	80192de <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 80192d6:	4b26      	ldr	r3, [pc, #152]	@ (8019370 <vTaskSwitchContext+0xa8>)
 80192d8:	2201      	movs	r2, #1
 80192da:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 80192dc:	e040      	b.n	8019360 <vTaskSwitchContext+0x98>
		xYieldPending = pdFALSE;
 80192de:	4b24      	ldr	r3, [pc, #144]	@ (8019370 <vTaskSwitchContext+0xa8>)
 80192e0:	2200      	movs	r2, #0
 80192e2:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80192e4:	4b23      	ldr	r3, [pc, #140]	@ (8019374 <vTaskSwitchContext+0xac>)
 80192e6:	681b      	ldr	r3, [r3, #0]
 80192e8:	60fb      	str	r3, [r7, #12]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 80192ea:	68fb      	ldr	r3, [r7, #12]
 80192ec:	fab3 f383 	clz	r3, r3
 80192f0:	72fb      	strb	r3, [r7, #11]
		return ucReturn;
 80192f2:	7afb      	ldrb	r3, [r7, #11]
 80192f4:	f1c3 031f 	rsb	r3, r3, #31
 80192f8:	617b      	str	r3, [r7, #20]
 80192fa:	491f      	ldr	r1, [pc, #124]	@ (8019378 <vTaskSwitchContext+0xb0>)
 80192fc:	697a      	ldr	r2, [r7, #20]
 80192fe:	4613      	mov	r3, r2
 8019300:	009b      	lsls	r3, r3, #2
 8019302:	4413      	add	r3, r2
 8019304:	009b      	lsls	r3, r3, #2
 8019306:	440b      	add	r3, r1
 8019308:	681b      	ldr	r3, [r3, #0]
 801930a:	2b00      	cmp	r3, #0
 801930c:	d10b      	bne.n	8019326 <vTaskSwitchContext+0x5e>
	__asm volatile
 801930e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8019312:	f383 8811 	msr	BASEPRI, r3
 8019316:	f3bf 8f6f 	isb	sy
 801931a:	f3bf 8f4f 	dsb	sy
 801931e:	607b      	str	r3, [r7, #4]
}
 8019320:	bf00      	nop
 8019322:	bf00      	nop
 8019324:	e7fd      	b.n	8019322 <vTaskSwitchContext+0x5a>
 8019326:	697a      	ldr	r2, [r7, #20]
 8019328:	4613      	mov	r3, r2
 801932a:	009b      	lsls	r3, r3, #2
 801932c:	4413      	add	r3, r2
 801932e:	009b      	lsls	r3, r3, #2
 8019330:	4a11      	ldr	r2, [pc, #68]	@ (8019378 <vTaskSwitchContext+0xb0>)
 8019332:	4413      	add	r3, r2
 8019334:	613b      	str	r3, [r7, #16]
 8019336:	693b      	ldr	r3, [r7, #16]
 8019338:	685b      	ldr	r3, [r3, #4]
 801933a:	685a      	ldr	r2, [r3, #4]
 801933c:	693b      	ldr	r3, [r7, #16]
 801933e:	605a      	str	r2, [r3, #4]
 8019340:	693b      	ldr	r3, [r7, #16]
 8019342:	685a      	ldr	r2, [r3, #4]
 8019344:	693b      	ldr	r3, [r7, #16]
 8019346:	3308      	adds	r3, #8
 8019348:	429a      	cmp	r2, r3
 801934a:	d104      	bne.n	8019356 <vTaskSwitchContext+0x8e>
 801934c:	693b      	ldr	r3, [r7, #16]
 801934e:	685b      	ldr	r3, [r3, #4]
 8019350:	685a      	ldr	r2, [r3, #4]
 8019352:	693b      	ldr	r3, [r7, #16]
 8019354:	605a      	str	r2, [r3, #4]
 8019356:	693b      	ldr	r3, [r7, #16]
 8019358:	685b      	ldr	r3, [r3, #4]
 801935a:	68db      	ldr	r3, [r3, #12]
 801935c:	4a07      	ldr	r2, [pc, #28]	@ (801937c <vTaskSwitchContext+0xb4>)
 801935e:	6013      	str	r3, [r2, #0]
}
 8019360:	bf00      	nop
 8019362:	371c      	adds	r7, #28
 8019364:	46bd      	mov	sp, r7
 8019366:	f85d 7b04 	ldr.w	r7, [sp], #4
 801936a:	4770      	bx	lr
 801936c:	2000a8d0 	.word	0x2000a8d0
 8019370:	2000a8c4 	.word	0x2000a8c4
 8019374:	2000a8b8 	.word	0x2000a8b8
 8019378:	2000a820 	.word	0x2000a820
 801937c:	2000a81c 	.word	0x2000a81c

08019380 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 8019380:	b480      	push	{r7}
 8019382:	b083      	sub	sp, #12
 8019384:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8019386:	4b0f      	ldr	r3, [pc, #60]	@ (80193c4 <prvResetNextTaskUnblockTime+0x44>)
 8019388:	681b      	ldr	r3, [r3, #0]
 801938a:	681b      	ldr	r3, [r3, #0]
 801938c:	2b00      	cmp	r3, #0
 801938e:	d101      	bne.n	8019394 <prvResetNextTaskUnblockTime+0x14>
 8019390:	2301      	movs	r3, #1
 8019392:	e000      	b.n	8019396 <prvResetNextTaskUnblockTime+0x16>
 8019394:	2300      	movs	r3, #0
 8019396:	2b00      	cmp	r3, #0
 8019398:	d004      	beq.n	80193a4 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 801939a:	4b0b      	ldr	r3, [pc, #44]	@ (80193c8 <prvResetNextTaskUnblockTime+0x48>)
 801939c:	f04f 32ff 	mov.w	r2, #4294967295
 80193a0:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 80193a2:	e008      	b.n	80193b6 <prvResetNextTaskUnblockTime+0x36>
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80193a4:	4b07      	ldr	r3, [pc, #28]	@ (80193c4 <prvResetNextTaskUnblockTime+0x44>)
 80193a6:	681b      	ldr	r3, [r3, #0]
 80193a8:	68db      	ldr	r3, [r3, #12]
 80193aa:	68db      	ldr	r3, [r3, #12]
 80193ac:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80193ae:	687b      	ldr	r3, [r7, #4]
 80193b0:	685b      	ldr	r3, [r3, #4]
 80193b2:	4a05      	ldr	r2, [pc, #20]	@ (80193c8 <prvResetNextTaskUnblockTime+0x48>)
 80193b4:	6013      	str	r3, [r2, #0]
}
 80193b6:	bf00      	nop
 80193b8:	370c      	adds	r7, #12
 80193ba:	46bd      	mov	sp, r7
 80193bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80193c0:	4770      	bx	lr
 80193c2:	bf00      	nop
 80193c4:	2000a8ac 	.word	0x2000a8ac
 80193c8:	2000a8cc 	.word	0x2000a8cc

080193cc <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 80193cc:	b480      	push	{r7}
 80193ce:	b083      	sub	sp, #12
 80193d0:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 80193d2:	4b0b      	ldr	r3, [pc, #44]	@ (8019400 <xTaskGetSchedulerState+0x34>)
 80193d4:	681b      	ldr	r3, [r3, #0]
 80193d6:	2b00      	cmp	r3, #0
 80193d8:	d102      	bne.n	80193e0 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 80193da:	2301      	movs	r3, #1
 80193dc:	607b      	str	r3, [r7, #4]
 80193de:	e008      	b.n	80193f2 <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80193e0:	4b08      	ldr	r3, [pc, #32]	@ (8019404 <xTaskGetSchedulerState+0x38>)
 80193e2:	681b      	ldr	r3, [r3, #0]
 80193e4:	2b00      	cmp	r3, #0
 80193e6:	d102      	bne.n	80193ee <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 80193e8:	2302      	movs	r3, #2
 80193ea:	607b      	str	r3, [r7, #4]
 80193ec:	e001      	b.n	80193f2 <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 80193ee:	2300      	movs	r3, #0
 80193f0:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 80193f2:	687b      	ldr	r3, [r7, #4]
	}
 80193f4:	4618      	mov	r0, r3
 80193f6:	370c      	adds	r7, #12
 80193f8:	46bd      	mov	sp, r7
 80193fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80193fe:	4770      	bx	lr
 8019400:	2000a8bc 	.word	0x2000a8bc
 8019404:	2000a8d0 	.word	0x2000a8d0
	...

08019410 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8019410:	4b07      	ldr	r3, [pc, #28]	@ (8019430 <pxCurrentTCBConst2>)
 8019412:	6819      	ldr	r1, [r3, #0]
 8019414:	6808      	ldr	r0, [r1, #0]
 8019416:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801941a:	f380 8809 	msr	PSP, r0
 801941e:	f3bf 8f6f 	isb	sy
 8019422:	f04f 0000 	mov.w	r0, #0
 8019426:	f380 8811 	msr	BASEPRI, r0
 801942a:	4770      	bx	lr
 801942c:	f3af 8000 	nop.w

08019430 <pxCurrentTCBConst2>:
 8019430:	2000a81c 	.word	0x2000a81c
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 8019434:	bf00      	nop
 8019436:	bf00      	nop
	...

08019440 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8019440:	f3ef 8009 	mrs	r0, PSP
 8019444:	f3bf 8f6f 	isb	sy
 8019448:	4b15      	ldr	r3, [pc, #84]	@ (80194a0 <pxCurrentTCBConst>)
 801944a:	681a      	ldr	r2, [r3, #0]
 801944c:	f01e 0f10 	tst.w	lr, #16
 8019450:	bf08      	it	eq
 8019452:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8019456:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801945a:	6010      	str	r0, [r2, #0]
 801945c:	e92d 0009 	stmdb	sp!, {r0, r3}
 8019460:	f04f 0050 	mov.w	r0, #80	@ 0x50
 8019464:	f380 8811 	msr	BASEPRI, r0
 8019468:	f3bf 8f4f 	dsb	sy
 801946c:	f3bf 8f6f 	isb	sy
 8019470:	f7ff ff2a 	bl	80192c8 <vTaskSwitchContext>
 8019474:	f04f 0000 	mov.w	r0, #0
 8019478:	f380 8811 	msr	BASEPRI, r0
 801947c:	bc09      	pop	{r0, r3}
 801947e:	6819      	ldr	r1, [r3, #0]
 8019480:	6808      	ldr	r0, [r1, #0]
 8019482:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019486:	f01e 0f10 	tst.w	lr, #16
 801948a:	bf08      	it	eq
 801948c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8019490:	f380 8809 	msr	PSP, r0
 8019494:	f3bf 8f6f 	isb	sy
 8019498:	4770      	bx	lr
 801949a:	bf00      	nop
 801949c:	f3af 8000 	nop.w

080194a0 <pxCurrentTCBConst>:
 80194a0:	2000a81c 	.word	0x2000a81c
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 80194a4:	bf00      	nop
 80194a6:	bf00      	nop

080194a8 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80194a8:	b580      	push	{r7, lr}
 80194aa:	b082      	sub	sp, #8
 80194ac:	af00      	add	r7, sp, #0
	__asm volatile
 80194ae:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80194b2:	f383 8811 	msr	BASEPRI, r3
 80194b6:	f3bf 8f6f 	isb	sy
 80194ba:	f3bf 8f4f 	dsb	sy
 80194be:	607b      	str	r3, [r7, #4]
}
 80194c0:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80194c2:	f7ff fe43 	bl	801914c <xTaskIncrementTick>
 80194c6:	4603      	mov	r3, r0
 80194c8:	2b00      	cmp	r3, #0
 80194ca:	d003      	beq.n	80194d4 <xPortSysTickHandler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80194cc:	4b06      	ldr	r3, [pc, #24]	@ (80194e8 <xPortSysTickHandler+0x40>)
 80194ce:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80194d2:	601a      	str	r2, [r3, #0]
 80194d4:	2300      	movs	r3, #0
 80194d6:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80194d8:	683b      	ldr	r3, [r7, #0]
 80194da:	f383 8811 	msr	BASEPRI, r3
	(
		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
	);
}
 80194de:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
 80194e0:	bf00      	nop
 80194e2:	3708      	adds	r7, #8
 80194e4:	46bd      	mov	sp, r7
 80194e6:	bd80      	pop	{r7, pc}
 80194e8:	e000ed04 	.word	0xe000ed04

080194ec <USBD_CDC_Init>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_Init(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80194ec:	b580      	push	{r7, lr}
 80194ee:	b084      	sub	sp, #16
 80194f0:	af00      	add	r7, sp, #0
 80194f2:	6078      	str	r0, [r7, #4]
 80194f4:	460b      	mov	r3, r1
 80194f6:	70fb      	strb	r3, [r7, #3]
  UNUSED(cfgidx);
  USBD_CDC_HandleTypeDef *hcdc;

  hcdc = (USBD_CDC_HandleTypeDef *)USBD_malloc(sizeof(USBD_CDC_HandleTypeDef));
 80194f8:	f44f 7007 	mov.w	r0, #540	@ 0x21c
 80194fc:	f002 fcf6 	bl	801beec <USBD_static_malloc>
 8019500:	60f8      	str	r0, [r7, #12]

  if (hcdc == NULL)
 8019502:	68fb      	ldr	r3, [r7, #12]
 8019504:	2b00      	cmp	r3, #0
 8019506:	d109      	bne.n	801951c <USBD_CDC_Init+0x30>
  {
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 8019508:	687b      	ldr	r3, [r7, #4]
 801950a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801950e:	687b      	ldr	r3, [r7, #4]
 8019510:	32b0      	adds	r2, #176	@ 0xb0
 8019512:	2100      	movs	r1, #0
 8019514:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    return (uint8_t)USBD_EMEM;
 8019518:	2302      	movs	r3, #2
 801951a:	e0d4      	b.n	80196c6 <USBD_CDC_Init+0x1da>
  }

  (void)USBD_memset(hcdc, 0, sizeof(USBD_CDC_HandleTypeDef));
 801951c:	f44f 7207 	mov.w	r2, #540	@ 0x21c
 8019520:	2100      	movs	r1, #0
 8019522:	68f8      	ldr	r0, [r7, #12]
 8019524:	f008 fdee 	bl	8022104 <memset>

  pdev->pClassDataCmsit[pdev->classId] = (void *)hcdc;
 8019528:	687b      	ldr	r3, [r7, #4]
 801952a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801952e:	687b      	ldr	r3, [r7, #4]
 8019530:	32b0      	adds	r2, #176	@ 0xb0
 8019532:	68f9      	ldr	r1, [r7, #12]
 8019534:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  pdev->pClassData = pdev->pClassDataCmsit[pdev->classId];
 8019538:	687b      	ldr	r3, [r7, #4]
 801953a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801953e:	687b      	ldr	r3, [r7, #4]
 8019540:	32b0      	adds	r2, #176	@ 0xb0
 8019542:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8019546:	687b      	ldr	r3, [r7, #4]
 8019548:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 801954c:	687b      	ldr	r3, [r7, #4]
 801954e:	7c1b      	ldrb	r3, [r3, #16]
 8019550:	2b00      	cmp	r3, #0
 8019552:	d138      	bne.n	80195c6 <USBD_CDC_Init+0xda>
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 8019554:	4b5e      	ldr	r3, [pc, #376]	@ (80196d0 <USBD_CDC_Init+0x1e4>)
 8019556:	7819      	ldrb	r1, [r3, #0]
 8019558:	f44f 7300 	mov.w	r3, #512	@ 0x200
 801955c:	2202      	movs	r2, #2
 801955e:	6878      	ldr	r0, [r7, #4]
 8019560:	f002 fba1 	bl	801bca6 <USBD_LL_OpenEP>
                         CDC_DATA_HS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 8019564:	4b5a      	ldr	r3, [pc, #360]	@ (80196d0 <USBD_CDC_Init+0x1e4>)
 8019566:	781b      	ldrb	r3, [r3, #0]
 8019568:	f003 020f 	and.w	r2, r3, #15
 801956c:	6879      	ldr	r1, [r7, #4]
 801956e:	4613      	mov	r3, r2
 8019570:	009b      	lsls	r3, r3, #2
 8019572:	4413      	add	r3, r2
 8019574:	009b      	lsls	r3, r3, #2
 8019576:	440b      	add	r3, r1
 8019578:	3324      	adds	r3, #36	@ 0x24
 801957a:	2201      	movs	r2, #1
 801957c:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 801957e:	4b55      	ldr	r3, [pc, #340]	@ (80196d4 <USBD_CDC_Init+0x1e8>)
 8019580:	7819      	ldrb	r1, [r3, #0]
 8019582:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8019586:	2202      	movs	r2, #2
 8019588:	6878      	ldr	r0, [r7, #4]
 801958a:	f002 fb8c 	bl	801bca6 <USBD_LL_OpenEP>
                         CDC_DATA_HS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 801958e:	4b51      	ldr	r3, [pc, #324]	@ (80196d4 <USBD_CDC_Init+0x1e8>)
 8019590:	781b      	ldrb	r3, [r3, #0]
 8019592:	f003 020f 	and.w	r2, r3, #15
 8019596:	6879      	ldr	r1, [r7, #4]
 8019598:	4613      	mov	r3, r2
 801959a:	009b      	lsls	r3, r3, #2
 801959c:	4413      	add	r3, r2
 801959e:	009b      	lsls	r3, r3, #2
 80195a0:	440b      	add	r3, r1
 80195a2:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 80195a6:	2201      	movs	r2, #1
 80195a8:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CDC CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_HS_BINTERVAL;
 80195aa:	4b4b      	ldr	r3, [pc, #300]	@ (80196d8 <USBD_CDC_Init+0x1ec>)
 80195ac:	781b      	ldrb	r3, [r3, #0]
 80195ae:	f003 020f 	and.w	r2, r3, #15
 80195b2:	6879      	ldr	r1, [r7, #4]
 80195b4:	4613      	mov	r3, r2
 80195b6:	009b      	lsls	r3, r3, #2
 80195b8:	4413      	add	r3, r2
 80195ba:	009b      	lsls	r3, r3, #2
 80195bc:	440b      	add	r3, r1
 80195be:	3326      	adds	r3, #38	@ 0x26
 80195c0:	2210      	movs	r2, #16
 80195c2:	801a      	strh	r2, [r3, #0]
 80195c4:	e035      	b.n	8019632 <USBD_CDC_Init+0x146>
  }
  else
  {
    /* Open EP IN */
    (void)USBD_LL_OpenEP(pdev, CDCInEpAdd, USBD_EP_TYPE_BULK,
 80195c6:	4b42      	ldr	r3, [pc, #264]	@ (80196d0 <USBD_CDC_Init+0x1e4>)
 80195c8:	7819      	ldrb	r1, [r3, #0]
 80195ca:	2340      	movs	r3, #64	@ 0x40
 80195cc:	2202      	movs	r2, #2
 80195ce:	6878      	ldr	r0, [r7, #4]
 80195d0:	f002 fb69 	bl	801bca6 <USBD_LL_OpenEP>
                         CDC_DATA_FS_IN_PACKET_SIZE);

    pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 1U;
 80195d4:	4b3e      	ldr	r3, [pc, #248]	@ (80196d0 <USBD_CDC_Init+0x1e4>)
 80195d6:	781b      	ldrb	r3, [r3, #0]
 80195d8:	f003 020f 	and.w	r2, r3, #15
 80195dc:	6879      	ldr	r1, [r7, #4]
 80195de:	4613      	mov	r3, r2
 80195e0:	009b      	lsls	r3, r3, #2
 80195e2:	4413      	add	r3, r2
 80195e4:	009b      	lsls	r3, r3, #2
 80195e6:	440b      	add	r3, r1
 80195e8:	3324      	adds	r3, #36	@ 0x24
 80195ea:	2201      	movs	r2, #1
 80195ec:	801a      	strh	r2, [r3, #0]

    /* Open EP OUT */
    (void)USBD_LL_OpenEP(pdev, CDCOutEpAdd, USBD_EP_TYPE_BULK,
 80195ee:	4b39      	ldr	r3, [pc, #228]	@ (80196d4 <USBD_CDC_Init+0x1e8>)
 80195f0:	7819      	ldrb	r1, [r3, #0]
 80195f2:	2340      	movs	r3, #64	@ 0x40
 80195f4:	2202      	movs	r2, #2
 80195f6:	6878      	ldr	r0, [r7, #4]
 80195f8:	f002 fb55 	bl	801bca6 <USBD_LL_OpenEP>
                         CDC_DATA_FS_OUT_PACKET_SIZE);

    pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 1U;
 80195fc:	4b35      	ldr	r3, [pc, #212]	@ (80196d4 <USBD_CDC_Init+0x1e8>)
 80195fe:	781b      	ldrb	r3, [r3, #0]
 8019600:	f003 020f 	and.w	r2, r3, #15
 8019604:	6879      	ldr	r1, [r7, #4]
 8019606:	4613      	mov	r3, r2
 8019608:	009b      	lsls	r3, r3, #2
 801960a:	4413      	add	r3, r2
 801960c:	009b      	lsls	r3, r3, #2
 801960e:	440b      	add	r3, r1
 8019610:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8019614:	2201      	movs	r2, #1
 8019616:	801a      	strh	r2, [r3, #0]

    /* Set bInterval for CMD Endpoint */
    pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = CDC_FS_BINTERVAL;
 8019618:	4b2f      	ldr	r3, [pc, #188]	@ (80196d8 <USBD_CDC_Init+0x1ec>)
 801961a:	781b      	ldrb	r3, [r3, #0]
 801961c:	f003 020f 	and.w	r2, r3, #15
 8019620:	6879      	ldr	r1, [r7, #4]
 8019622:	4613      	mov	r3, r2
 8019624:	009b      	lsls	r3, r3, #2
 8019626:	4413      	add	r3, r2
 8019628:	009b      	lsls	r3, r3, #2
 801962a:	440b      	add	r3, r1
 801962c:	3326      	adds	r3, #38	@ 0x26
 801962e:	2210      	movs	r2, #16
 8019630:	801a      	strh	r2, [r3, #0]
  }

  /* Open Command IN EP */
  (void)USBD_LL_OpenEP(pdev, CDCCmdEpAdd, USBD_EP_TYPE_INTR, CDC_CMD_PACKET_SIZE);
 8019632:	4b29      	ldr	r3, [pc, #164]	@ (80196d8 <USBD_CDC_Init+0x1ec>)
 8019634:	7819      	ldrb	r1, [r3, #0]
 8019636:	2308      	movs	r3, #8
 8019638:	2203      	movs	r2, #3
 801963a:	6878      	ldr	r0, [r7, #4]
 801963c:	f002 fb33 	bl	801bca6 <USBD_LL_OpenEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 1U;
 8019640:	4b25      	ldr	r3, [pc, #148]	@ (80196d8 <USBD_CDC_Init+0x1ec>)
 8019642:	781b      	ldrb	r3, [r3, #0]
 8019644:	f003 020f 	and.w	r2, r3, #15
 8019648:	6879      	ldr	r1, [r7, #4]
 801964a:	4613      	mov	r3, r2
 801964c:	009b      	lsls	r3, r3, #2
 801964e:	4413      	add	r3, r2
 8019650:	009b      	lsls	r3, r3, #2
 8019652:	440b      	add	r3, r1
 8019654:	3324      	adds	r3, #36	@ 0x24
 8019656:	2201      	movs	r2, #1
 8019658:	801a      	strh	r2, [r3, #0]

  hcdc->RxBuffer = NULL;
 801965a:	68fb      	ldr	r3, [r7, #12]
 801965c:	2200      	movs	r2, #0
 801965e:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  /* Init  physical Interface components */
  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Init();
 8019662:	687b      	ldr	r3, [r7, #4]
 8019664:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8019668:	687a      	ldr	r2, [r7, #4]
 801966a:	33b0      	adds	r3, #176	@ 0xb0
 801966c:	009b      	lsls	r3, r3, #2
 801966e:	4413      	add	r3, r2
 8019670:	685b      	ldr	r3, [r3, #4]
 8019672:	681b      	ldr	r3, [r3, #0]
 8019674:	4798      	blx	r3

  /* Init Xfer states */
  hcdc->TxState = 0U;
 8019676:	68fb      	ldr	r3, [r7, #12]
 8019678:	2200      	movs	r2, #0
 801967a:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214
  hcdc->RxState = 0U;
 801967e:	68fb      	ldr	r3, [r7, #12]
 8019680:	2200      	movs	r2, #0
 8019682:	f8c3 2218 	str.w	r2, [r3, #536]	@ 0x218

  if (hcdc->RxBuffer == NULL)
 8019686:	68fb      	ldr	r3, [r7, #12]
 8019688:	f8d3 3204 	ldr.w	r3, [r3, #516]	@ 0x204
 801968c:	2b00      	cmp	r3, #0
 801968e:	d101      	bne.n	8019694 <USBD_CDC_Init+0x1a8>
  {
    return (uint8_t)USBD_EMEM;
 8019690:	2302      	movs	r3, #2
 8019692:	e018      	b.n	80196c6 <USBD_CDC_Init+0x1da>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8019694:	687b      	ldr	r3, [r7, #4]
 8019696:	7c1b      	ldrb	r3, [r3, #16]
 8019698:	2b00      	cmp	r3, #0
 801969a:	d10a      	bne.n	80196b2 <USBD_CDC_Init+0x1c6>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 801969c:	4b0d      	ldr	r3, [pc, #52]	@ (80196d4 <USBD_CDC_Init+0x1e8>)
 801969e:	7819      	ldrb	r1, [r3, #0]
 80196a0:	68fb      	ldr	r3, [r7, #12]
 80196a2:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 80196a6:	f44f 7300 	mov.w	r3, #512	@ 0x200
 80196aa:	6878      	ldr	r0, [r7, #4]
 80196ac:	f002 fbea 	bl	801be84 <USBD_LL_PrepareReceive>
 80196b0:	e008      	b.n	80196c4 <USBD_CDC_Init+0x1d8>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 80196b2:	4b08      	ldr	r3, [pc, #32]	@ (80196d4 <USBD_CDC_Init+0x1e8>)
 80196b4:	7819      	ldrb	r1, [r3, #0]
 80196b6:	68fb      	ldr	r3, [r7, #12]
 80196b8:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 80196bc:	2340      	movs	r3, #64	@ 0x40
 80196be:	6878      	ldr	r0, [r7, #4]
 80196c0:	f002 fbe0 	bl	801be84 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 80196c4:	2300      	movs	r3, #0
}
 80196c6:	4618      	mov	r0, r3
 80196c8:	3710      	adds	r7, #16
 80196ca:	46bd      	mov	sp, r7
 80196cc:	bd80      	pop	{r7, pc}
 80196ce:	bf00      	nop
 80196d0:	20000133 	.word	0x20000133
 80196d4:	20000134 	.word	0x20000134
 80196d8:	20000135 	.word	0x20000135

080196dc <USBD_CDC_DeInit>:
  * @param  pdev: device instance
  * @param  cfgidx: Configuration index
  * @retval status
  */
static uint8_t USBD_CDC_DeInit(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 80196dc:	b580      	push	{r7, lr}
 80196de:	b082      	sub	sp, #8
 80196e0:	af00      	add	r7, sp, #0
 80196e2:	6078      	str	r0, [r7, #4]
 80196e4:	460b      	mov	r3, r1
 80196e6:	70fb      	strb	r3, [r7, #3]
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
  CDCCmdEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_INTR, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  /* Close EP IN */
  (void)USBD_LL_CloseEP(pdev, CDCInEpAdd);
 80196e8:	4b3a      	ldr	r3, [pc, #232]	@ (80197d4 <USBD_CDC_DeInit+0xf8>)
 80196ea:	781b      	ldrb	r3, [r3, #0]
 80196ec:	4619      	mov	r1, r3
 80196ee:	6878      	ldr	r0, [r7, #4]
 80196f0:	f002 faff 	bl	801bcf2 <USBD_LL_CloseEP>
  pdev->ep_in[CDCInEpAdd & 0xFU].is_used = 0U;
 80196f4:	4b37      	ldr	r3, [pc, #220]	@ (80197d4 <USBD_CDC_DeInit+0xf8>)
 80196f6:	781b      	ldrb	r3, [r3, #0]
 80196f8:	f003 020f 	and.w	r2, r3, #15
 80196fc:	6879      	ldr	r1, [r7, #4]
 80196fe:	4613      	mov	r3, r2
 8019700:	009b      	lsls	r3, r3, #2
 8019702:	4413      	add	r3, r2
 8019704:	009b      	lsls	r3, r3, #2
 8019706:	440b      	add	r3, r1
 8019708:	3324      	adds	r3, #36	@ 0x24
 801970a:	2200      	movs	r2, #0
 801970c:	801a      	strh	r2, [r3, #0]

  /* Close EP OUT */
  (void)USBD_LL_CloseEP(pdev, CDCOutEpAdd);
 801970e:	4b32      	ldr	r3, [pc, #200]	@ (80197d8 <USBD_CDC_DeInit+0xfc>)
 8019710:	781b      	ldrb	r3, [r3, #0]
 8019712:	4619      	mov	r1, r3
 8019714:	6878      	ldr	r0, [r7, #4]
 8019716:	f002 faec 	bl	801bcf2 <USBD_LL_CloseEP>
  pdev->ep_out[CDCOutEpAdd & 0xFU].is_used = 0U;
 801971a:	4b2f      	ldr	r3, [pc, #188]	@ (80197d8 <USBD_CDC_DeInit+0xfc>)
 801971c:	781b      	ldrb	r3, [r3, #0]
 801971e:	f003 020f 	and.w	r2, r3, #15
 8019722:	6879      	ldr	r1, [r7, #4]
 8019724:	4613      	mov	r3, r2
 8019726:	009b      	lsls	r3, r3, #2
 8019728:	4413      	add	r3, r2
 801972a:	009b      	lsls	r3, r3, #2
 801972c:	440b      	add	r3, r1
 801972e:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 8019732:	2200      	movs	r2, #0
 8019734:	801a      	strh	r2, [r3, #0]

  /* Close Command IN EP */
  (void)USBD_LL_CloseEP(pdev, CDCCmdEpAdd);
 8019736:	4b29      	ldr	r3, [pc, #164]	@ (80197dc <USBD_CDC_DeInit+0x100>)
 8019738:	781b      	ldrb	r3, [r3, #0]
 801973a:	4619      	mov	r1, r3
 801973c:	6878      	ldr	r0, [r7, #4]
 801973e:	f002 fad8 	bl	801bcf2 <USBD_LL_CloseEP>
  pdev->ep_in[CDCCmdEpAdd & 0xFU].is_used = 0U;
 8019742:	4b26      	ldr	r3, [pc, #152]	@ (80197dc <USBD_CDC_DeInit+0x100>)
 8019744:	781b      	ldrb	r3, [r3, #0]
 8019746:	f003 020f 	and.w	r2, r3, #15
 801974a:	6879      	ldr	r1, [r7, #4]
 801974c:	4613      	mov	r3, r2
 801974e:	009b      	lsls	r3, r3, #2
 8019750:	4413      	add	r3, r2
 8019752:	009b      	lsls	r3, r3, #2
 8019754:	440b      	add	r3, r1
 8019756:	3324      	adds	r3, #36	@ 0x24
 8019758:	2200      	movs	r2, #0
 801975a:	801a      	strh	r2, [r3, #0]
  pdev->ep_in[CDCCmdEpAdd & 0xFU].bInterval = 0U;
 801975c:	4b1f      	ldr	r3, [pc, #124]	@ (80197dc <USBD_CDC_DeInit+0x100>)
 801975e:	781b      	ldrb	r3, [r3, #0]
 8019760:	f003 020f 	and.w	r2, r3, #15
 8019764:	6879      	ldr	r1, [r7, #4]
 8019766:	4613      	mov	r3, r2
 8019768:	009b      	lsls	r3, r3, #2
 801976a:	4413      	add	r3, r2
 801976c:	009b      	lsls	r3, r3, #2
 801976e:	440b      	add	r3, r1
 8019770:	3326      	adds	r3, #38	@ 0x26
 8019772:	2200      	movs	r2, #0
 8019774:	801a      	strh	r2, [r3, #0]

  /* DeInit  physical Interface components */
  if (pdev->pClassDataCmsit[pdev->classId] != NULL)
 8019776:	687b      	ldr	r3, [r7, #4]
 8019778:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801977c:	687b      	ldr	r3, [r7, #4]
 801977e:	32b0      	adds	r2, #176	@ 0xb0
 8019780:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019784:	2b00      	cmp	r3, #0
 8019786:	d01f      	beq.n	80197c8 <USBD_CDC_DeInit+0xec>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->DeInit();
 8019788:	687b      	ldr	r3, [r7, #4]
 801978a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 801978e:	687a      	ldr	r2, [r7, #4]
 8019790:	33b0      	adds	r3, #176	@ 0xb0
 8019792:	009b      	lsls	r3, r3, #2
 8019794:	4413      	add	r3, r2
 8019796:	685b      	ldr	r3, [r3, #4]
 8019798:	685b      	ldr	r3, [r3, #4]
 801979a:	4798      	blx	r3
    (void)USBD_free(pdev->pClassDataCmsit[pdev->classId]);
 801979c:	687b      	ldr	r3, [r7, #4]
 801979e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80197a2:	687b      	ldr	r3, [r7, #4]
 80197a4:	32b0      	adds	r2, #176	@ 0xb0
 80197a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80197aa:	4618      	mov	r0, r3
 80197ac:	f002 fbac 	bl	801bf08 <USBD_static_free>
    pdev->pClassDataCmsit[pdev->classId] = NULL;
 80197b0:	687b      	ldr	r3, [r7, #4]
 80197b2:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80197b6:	687b      	ldr	r3, [r7, #4]
 80197b8:	32b0      	adds	r2, #176	@ 0xb0
 80197ba:	2100      	movs	r1, #0
 80197bc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pdev->pClassData = NULL;
 80197c0:	687b      	ldr	r3, [r7, #4]
 80197c2:	2200      	movs	r2, #0
 80197c4:	f8c3 22bc 	str.w	r2, [r3, #700]	@ 0x2bc
  }

  return (uint8_t)USBD_OK;
 80197c8:	2300      	movs	r3, #0
}
 80197ca:	4618      	mov	r0, r3
 80197cc:	3708      	adds	r7, #8
 80197ce:	46bd      	mov	sp, r7
 80197d0:	bd80      	pop	{r7, pc}
 80197d2:	bf00      	nop
 80197d4:	20000133 	.word	0x20000133
 80197d8:	20000134 	.word	0x20000134
 80197dc:	20000135 	.word	0x20000135

080197e0 <USBD_CDC_Setup>:
  * @param  req: usb requests
  * @retval status
  */
static uint8_t USBD_CDC_Setup(USBD_HandleTypeDef *pdev,
                              USBD_SetupReqTypedef *req)
{
 80197e0:	b580      	push	{r7, lr}
 80197e2:	b086      	sub	sp, #24
 80197e4:	af00      	add	r7, sp, #0
 80197e6:	6078      	str	r0, [r7, #4]
 80197e8:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 80197ea:	687b      	ldr	r3, [r7, #4]
 80197ec:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80197f0:	687b      	ldr	r3, [r7, #4]
 80197f2:	32b0      	adds	r2, #176	@ 0xb0
 80197f4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80197f8:	613b      	str	r3, [r7, #16]
  uint16_t len;
  uint8_t ifalt = 0U;
 80197fa:	2300      	movs	r3, #0
 80197fc:	737b      	strb	r3, [r7, #13]
  uint16_t status_info = 0U;
 80197fe:	2300      	movs	r3, #0
 8019800:	817b      	strh	r3, [r7, #10]
  USBD_StatusTypeDef ret = USBD_OK;
 8019802:	2300      	movs	r3, #0
 8019804:	75fb      	strb	r3, [r7, #23]

  if (hcdc == NULL)
 8019806:	693b      	ldr	r3, [r7, #16]
 8019808:	2b00      	cmp	r3, #0
 801980a:	d101      	bne.n	8019810 <USBD_CDC_Setup+0x30>
  {
    return (uint8_t)USBD_FAIL;
 801980c:	2303      	movs	r3, #3
 801980e:	e0bf      	b.n	8019990 <USBD_CDC_Setup+0x1b0>
  }

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8019810:	683b      	ldr	r3, [r7, #0]
 8019812:	781b      	ldrb	r3, [r3, #0]
 8019814:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 8019818:	2b00      	cmp	r3, #0
 801981a:	d050      	beq.n	80198be <USBD_CDC_Setup+0xde>
 801981c:	2b20      	cmp	r3, #32
 801981e:	f040 80af 	bne.w	8019980 <USBD_CDC_Setup+0x1a0>
  {
    case USB_REQ_TYPE_CLASS:
      if (req->wLength != 0U)
 8019822:	683b      	ldr	r3, [r7, #0]
 8019824:	88db      	ldrh	r3, [r3, #6]
 8019826:	2b00      	cmp	r3, #0
 8019828:	d03a      	beq.n	80198a0 <USBD_CDC_Setup+0xc0>
      {
        if ((req->bmRequest & 0x80U) != 0U)
 801982a:	683b      	ldr	r3, [r7, #0]
 801982c:	781b      	ldrb	r3, [r3, #0]
 801982e:	b25b      	sxtb	r3, r3
 8019830:	2b00      	cmp	r3, #0
 8019832:	da1b      	bge.n	801986c <USBD_CDC_Setup+0x8c>
        {
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 8019834:	687b      	ldr	r3, [r7, #4]
 8019836:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 801983a:	687a      	ldr	r2, [r7, #4]
 801983c:	33b0      	adds	r3, #176	@ 0xb0
 801983e:	009b      	lsls	r3, r3, #2
 8019840:	4413      	add	r3, r2
 8019842:	685b      	ldr	r3, [r3, #4]
 8019844:	689b      	ldr	r3, [r3, #8]
 8019846:	683a      	ldr	r2, [r7, #0]
 8019848:	7850      	ldrb	r0, [r2, #1]
                                                                           (uint8_t *)hcdc->data,
 801984a:	6939      	ldr	r1, [r7, #16]
          ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 801984c:	683a      	ldr	r2, [r7, #0]
 801984e:	88d2      	ldrh	r2, [r2, #6]
 8019850:	4798      	blx	r3
                                                                           req->wLength);

          len = MIN(CDC_REQ_MAX_DATA_SIZE, req->wLength);
 8019852:	683b      	ldr	r3, [r7, #0]
 8019854:	88db      	ldrh	r3, [r3, #6]
 8019856:	2b07      	cmp	r3, #7
 8019858:	bf28      	it	cs
 801985a:	2307      	movcs	r3, #7
 801985c:	81fb      	strh	r3, [r7, #14]
          (void)USBD_CtlSendData(pdev, (uint8_t *)hcdc->data, len);
 801985e:	693b      	ldr	r3, [r7, #16]
 8019860:	89fa      	ldrh	r2, [r7, #14]
 8019862:	4619      	mov	r1, r3
 8019864:	6878      	ldr	r0, [r7, #4]
 8019866:	f001 fd87 	bl	801b378 <USBD_CtlSendData>
      else
      {
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
                                                                         (uint8_t *)req, 0U);
      }
      break;
 801986a:	e090      	b.n	801998e <USBD_CDC_Setup+0x1ae>
          hcdc->CmdOpCode = req->bRequest;
 801986c:	683b      	ldr	r3, [r7, #0]
 801986e:	785a      	ldrb	r2, [r3, #1]
 8019870:	693b      	ldr	r3, [r7, #16]
 8019872:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
          hcdc->CmdLength = (uint8_t)MIN(req->wLength, USB_MAX_EP0_SIZE);
 8019876:	683b      	ldr	r3, [r7, #0]
 8019878:	88db      	ldrh	r3, [r3, #6]
 801987a:	2b3f      	cmp	r3, #63	@ 0x3f
 801987c:	d803      	bhi.n	8019886 <USBD_CDC_Setup+0xa6>
 801987e:	683b      	ldr	r3, [r7, #0]
 8019880:	88db      	ldrh	r3, [r3, #6]
 8019882:	b2da      	uxtb	r2, r3
 8019884:	e000      	b.n	8019888 <USBD_CDC_Setup+0xa8>
 8019886:	2240      	movs	r2, #64	@ 0x40
 8019888:	693b      	ldr	r3, [r7, #16]
 801988a:	f883 2201 	strb.w	r2, [r3, #513]	@ 0x201
          (void)USBD_CtlPrepareRx(pdev, (uint8_t *)hcdc->data, hcdc->CmdLength);
 801988e:	6939      	ldr	r1, [r7, #16]
 8019890:	693b      	ldr	r3, [r7, #16]
 8019892:	f893 3201 	ldrb.w	r3, [r3, #513]	@ 0x201
 8019896:	461a      	mov	r2, r3
 8019898:	6878      	ldr	r0, [r7, #4]
 801989a:	f001 fd99 	bl	801b3d0 <USBD_CtlPrepareRx>
      break;
 801989e:	e076      	b.n	801998e <USBD_CDC_Setup+0x1ae>
        ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(req->bRequest,
 80198a0:	687b      	ldr	r3, [r7, #4]
 80198a2:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 80198a6:	687a      	ldr	r2, [r7, #4]
 80198a8:	33b0      	adds	r3, #176	@ 0xb0
 80198aa:	009b      	lsls	r3, r3, #2
 80198ac:	4413      	add	r3, r2
 80198ae:	685b      	ldr	r3, [r3, #4]
 80198b0:	689b      	ldr	r3, [r3, #8]
 80198b2:	683a      	ldr	r2, [r7, #0]
 80198b4:	7850      	ldrb	r0, [r2, #1]
 80198b6:	2200      	movs	r2, #0
 80198b8:	6839      	ldr	r1, [r7, #0]
 80198ba:	4798      	blx	r3
      break;
 80198bc:	e067      	b.n	801998e <USBD_CDC_Setup+0x1ae>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 80198be:	683b      	ldr	r3, [r7, #0]
 80198c0:	785b      	ldrb	r3, [r3, #1]
 80198c2:	2b0b      	cmp	r3, #11
 80198c4:	d851      	bhi.n	801996a <USBD_CDC_Setup+0x18a>
 80198c6:	a201      	add	r2, pc, #4	@ (adr r2, 80198cc <USBD_CDC_Setup+0xec>)
 80198c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80198cc:	080198fd 	.word	0x080198fd
 80198d0:	08019979 	.word	0x08019979
 80198d4:	0801996b 	.word	0x0801996b
 80198d8:	0801996b 	.word	0x0801996b
 80198dc:	0801996b 	.word	0x0801996b
 80198e0:	0801996b 	.word	0x0801996b
 80198e4:	0801996b 	.word	0x0801996b
 80198e8:	0801996b 	.word	0x0801996b
 80198ec:	0801996b 	.word	0x0801996b
 80198f0:	0801996b 	.word	0x0801996b
 80198f4:	08019927 	.word	0x08019927
 80198f8:	08019951 	.word	0x08019951
      {
        case USB_REQ_GET_STATUS:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 80198fc:	687b      	ldr	r3, [r7, #4]
 80198fe:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8019902:	b2db      	uxtb	r3, r3
 8019904:	2b03      	cmp	r3, #3
 8019906:	d107      	bne.n	8019918 <USBD_CDC_Setup+0x138>
          {
            (void)USBD_CtlSendData(pdev, (uint8_t *)&status_info, 2U);
 8019908:	f107 030a 	add.w	r3, r7, #10
 801990c:	2202      	movs	r2, #2
 801990e:	4619      	mov	r1, r3
 8019910:	6878      	ldr	r0, [r7, #4]
 8019912:	f001 fd31 	bl	801b378 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8019916:	e032      	b.n	801997e <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8019918:	6839      	ldr	r1, [r7, #0]
 801991a:	6878      	ldr	r0, [r7, #4]
 801991c:	f001 fcbb 	bl	801b296 <USBD_CtlError>
            ret = USBD_FAIL;
 8019920:	2303      	movs	r3, #3
 8019922:	75fb      	strb	r3, [r7, #23]
          break;
 8019924:	e02b      	b.n	801997e <USBD_CDC_Setup+0x19e>

        case USB_REQ_GET_INTERFACE:
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 8019926:	687b      	ldr	r3, [r7, #4]
 8019928:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801992c:	b2db      	uxtb	r3, r3
 801992e:	2b03      	cmp	r3, #3
 8019930:	d107      	bne.n	8019942 <USBD_CDC_Setup+0x162>
          {
            (void)USBD_CtlSendData(pdev, &ifalt, 1U);
 8019932:	f107 030d 	add.w	r3, r7, #13
 8019936:	2201      	movs	r2, #1
 8019938:	4619      	mov	r1, r3
 801993a:	6878      	ldr	r0, [r7, #4]
 801993c:	f001 fd1c 	bl	801b378 <USBD_CtlSendData>
          else
          {
            USBD_CtlError(pdev, req);
            ret = USBD_FAIL;
          }
          break;
 8019940:	e01d      	b.n	801997e <USBD_CDC_Setup+0x19e>
            USBD_CtlError(pdev, req);
 8019942:	6839      	ldr	r1, [r7, #0]
 8019944:	6878      	ldr	r0, [r7, #4]
 8019946:	f001 fca6 	bl	801b296 <USBD_CtlError>
            ret = USBD_FAIL;
 801994a:	2303      	movs	r3, #3
 801994c:	75fb      	strb	r3, [r7, #23]
          break;
 801994e:	e016      	b.n	801997e <USBD_CDC_Setup+0x19e>

        case USB_REQ_SET_INTERFACE:
          if (pdev->dev_state != USBD_STATE_CONFIGURED)
 8019950:	687b      	ldr	r3, [r7, #4]
 8019952:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 8019956:	b2db      	uxtb	r3, r3
 8019958:	2b03      	cmp	r3, #3
 801995a:	d00f      	beq.n	801997c <USBD_CDC_Setup+0x19c>
          {
            USBD_CtlError(pdev, req);
 801995c:	6839      	ldr	r1, [r7, #0]
 801995e:	6878      	ldr	r0, [r7, #4]
 8019960:	f001 fc99 	bl	801b296 <USBD_CtlError>
            ret = USBD_FAIL;
 8019964:	2303      	movs	r3, #3
 8019966:	75fb      	strb	r3, [r7, #23]
          }
          break;
 8019968:	e008      	b.n	801997c <USBD_CDC_Setup+0x19c>

        case USB_REQ_CLEAR_FEATURE:
          break;

        default:
          USBD_CtlError(pdev, req);
 801996a:	6839      	ldr	r1, [r7, #0]
 801996c:	6878      	ldr	r0, [r7, #4]
 801996e:	f001 fc92 	bl	801b296 <USBD_CtlError>
          ret = USBD_FAIL;
 8019972:	2303      	movs	r3, #3
 8019974:	75fb      	strb	r3, [r7, #23]
          break;
 8019976:	e002      	b.n	801997e <USBD_CDC_Setup+0x19e>
          break;
 8019978:	bf00      	nop
 801997a:	e008      	b.n	801998e <USBD_CDC_Setup+0x1ae>
          break;
 801997c:	bf00      	nop
      }
      break;
 801997e:	e006      	b.n	801998e <USBD_CDC_Setup+0x1ae>

    default:
      USBD_CtlError(pdev, req);
 8019980:	6839      	ldr	r1, [r7, #0]
 8019982:	6878      	ldr	r0, [r7, #4]
 8019984:	f001 fc87 	bl	801b296 <USBD_CtlError>
      ret = USBD_FAIL;
 8019988:	2303      	movs	r3, #3
 801998a:	75fb      	strb	r3, [r7, #23]
      break;
 801998c:	bf00      	nop
  }

  return (uint8_t)ret;
 801998e:	7dfb      	ldrb	r3, [r7, #23]
}
 8019990:	4618      	mov	r0, r3
 8019992:	3718      	adds	r7, #24
 8019994:	46bd      	mov	sp, r7
 8019996:	bd80      	pop	{r7, pc}

08019998 <USBD_CDC_DataIn>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataIn(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8019998:	b580      	push	{r7, lr}
 801999a:	b084      	sub	sp, #16
 801999c:	af00      	add	r7, sp, #0
 801999e:	6078      	str	r0, [r7, #4]
 80199a0:	460b      	mov	r3, r1
 80199a2:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc;
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef *)pdev->pData;
 80199a4:	687b      	ldr	r3, [r7, #4]
 80199a6:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 80199aa:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 80199ac:	687b      	ldr	r3, [r7, #4]
 80199ae:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80199b2:	687b      	ldr	r3, [r7, #4]
 80199b4:	32b0      	adds	r2, #176	@ 0xb0
 80199b6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80199ba:	2b00      	cmp	r3, #0
 80199bc:	d101      	bne.n	80199c2 <USBD_CDC_DataIn+0x2a>
  {
    return (uint8_t)USBD_FAIL;
 80199be:	2303      	movs	r3, #3
 80199c0:	e065      	b.n	8019a8e <USBD_CDC_DataIn+0xf6>
  }

  hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 80199c2:	687b      	ldr	r3, [r7, #4]
 80199c4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 80199c8:	687b      	ldr	r3, [r7, #4]
 80199ca:	32b0      	adds	r2, #176	@ 0xb0
 80199cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80199d0:	60bb      	str	r3, [r7, #8]

  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 80199d2:	78fb      	ldrb	r3, [r7, #3]
 80199d4:	f003 020f 	and.w	r2, r3, #15
 80199d8:	6879      	ldr	r1, [r7, #4]
 80199da:	4613      	mov	r3, r2
 80199dc:	009b      	lsls	r3, r3, #2
 80199de:	4413      	add	r3, r2
 80199e0:	009b      	lsls	r3, r3, #2
 80199e2:	440b      	add	r3, r1
 80199e4:	3318      	adds	r3, #24
 80199e6:	681b      	ldr	r3, [r3, #0]
 80199e8:	2b00      	cmp	r3, #0
 80199ea:	d02f      	beq.n	8019a4c <USBD_CDC_DataIn+0xb4>
      ((pdev->ep_in[epnum & 0xFU].total_length % hpcd->IN_ep[epnum & 0xFU].maxpacket) == 0U))
 80199ec:	78fb      	ldrb	r3, [r7, #3]
 80199ee:	f003 020f 	and.w	r2, r3, #15
 80199f2:	6879      	ldr	r1, [r7, #4]
 80199f4:	4613      	mov	r3, r2
 80199f6:	009b      	lsls	r3, r3, #2
 80199f8:	4413      	add	r3, r2
 80199fa:	009b      	lsls	r3, r3, #2
 80199fc:	440b      	add	r3, r1
 80199fe:	3318      	adds	r3, #24
 8019a00:	681a      	ldr	r2, [r3, #0]
 8019a02:	78fb      	ldrb	r3, [r7, #3]
 8019a04:	f003 010f 	and.w	r1, r3, #15
 8019a08:	68f8      	ldr	r0, [r7, #12]
 8019a0a:	460b      	mov	r3, r1
 8019a0c:	00db      	lsls	r3, r3, #3
 8019a0e:	440b      	add	r3, r1
 8019a10:	009b      	lsls	r3, r3, #2
 8019a12:	4403      	add	r3, r0
 8019a14:	331c      	adds	r3, #28
 8019a16:	681b      	ldr	r3, [r3, #0]
 8019a18:	fbb2 f1f3 	udiv	r1, r2, r3
 8019a1c:	fb01 f303 	mul.w	r3, r1, r3
 8019a20:	1ad3      	subs	r3, r2, r3
  if ((pdev->ep_in[epnum & 0xFU].total_length > 0U) &&
 8019a22:	2b00      	cmp	r3, #0
 8019a24:	d112      	bne.n	8019a4c <USBD_CDC_DataIn+0xb4>
  {
    /* Update the packet total length */
    pdev->ep_in[epnum & 0xFU].total_length = 0U;
 8019a26:	78fb      	ldrb	r3, [r7, #3]
 8019a28:	f003 020f 	and.w	r2, r3, #15
 8019a2c:	6879      	ldr	r1, [r7, #4]
 8019a2e:	4613      	mov	r3, r2
 8019a30:	009b      	lsls	r3, r3, #2
 8019a32:	4413      	add	r3, r2
 8019a34:	009b      	lsls	r3, r3, #2
 8019a36:	440b      	add	r3, r1
 8019a38:	3318      	adds	r3, #24
 8019a3a:	2200      	movs	r2, #0
 8019a3c:	601a      	str	r2, [r3, #0]

    /* Send ZLP */
    (void)USBD_LL_Transmit(pdev, epnum, NULL, 0U);
 8019a3e:	78f9      	ldrb	r1, [r7, #3]
 8019a40:	2300      	movs	r3, #0
 8019a42:	2200      	movs	r2, #0
 8019a44:	6878      	ldr	r0, [r7, #4]
 8019a46:	f002 f9fc 	bl	801be42 <USBD_LL_Transmit>
 8019a4a:	e01f      	b.n	8019a8c <USBD_CDC_DataIn+0xf4>
  }
  else
  {
    hcdc->TxState = 0U;
 8019a4c:	68bb      	ldr	r3, [r7, #8]
 8019a4e:	2200      	movs	r2, #0
 8019a50:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    if (((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt != NULL)
 8019a54:	687b      	ldr	r3, [r7, #4]
 8019a56:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8019a5a:	687a      	ldr	r2, [r7, #4]
 8019a5c:	33b0      	adds	r3, #176	@ 0xb0
 8019a5e:	009b      	lsls	r3, r3, #2
 8019a60:	4413      	add	r3, r2
 8019a62:	685b      	ldr	r3, [r3, #4]
 8019a64:	691b      	ldr	r3, [r3, #16]
 8019a66:	2b00      	cmp	r3, #0
 8019a68:	d010      	beq.n	8019a8c <USBD_CDC_DataIn+0xf4>
    {
      ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->TransmitCplt(hcdc->TxBuffer, &hcdc->TxLength, epnum);
 8019a6a:	687b      	ldr	r3, [r7, #4]
 8019a6c:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8019a70:	687a      	ldr	r2, [r7, #4]
 8019a72:	33b0      	adds	r3, #176	@ 0xb0
 8019a74:	009b      	lsls	r3, r3, #2
 8019a76:	4413      	add	r3, r2
 8019a78:	685b      	ldr	r3, [r3, #4]
 8019a7a:	691b      	ldr	r3, [r3, #16]
 8019a7c:	68ba      	ldr	r2, [r7, #8]
 8019a7e:	f8d2 0208 	ldr.w	r0, [r2, #520]	@ 0x208
 8019a82:	68ba      	ldr	r2, [r7, #8]
 8019a84:	f502 7104 	add.w	r1, r2, #528	@ 0x210
 8019a88:	78fa      	ldrb	r2, [r7, #3]
 8019a8a:	4798      	blx	r3
    }
  }

  return (uint8_t)USBD_OK;
 8019a8c:	2300      	movs	r3, #0
}
 8019a8e:	4618      	mov	r0, r3
 8019a90:	3710      	adds	r7, #16
 8019a92:	46bd      	mov	sp, r7
 8019a94:	bd80      	pop	{r7, pc}

08019a96 <USBD_CDC_DataOut>:
  * @param  pdev: device instance
  * @param  epnum: endpoint number
  * @retval status
  */
static uint8_t USBD_CDC_DataOut(USBD_HandleTypeDef *pdev, uint8_t epnum)
{
 8019a96:	b580      	push	{r7, lr}
 8019a98:	b084      	sub	sp, #16
 8019a9a:	af00      	add	r7, sp, #0
 8019a9c:	6078      	str	r0, [r7, #4]
 8019a9e:	460b      	mov	r3, r1
 8019aa0:	70fb      	strb	r3, [r7, #3]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8019aa2:	687b      	ldr	r3, [r7, #4]
 8019aa4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019aa8:	687b      	ldr	r3, [r7, #4]
 8019aaa:	32b0      	adds	r2, #176	@ 0xb0
 8019aac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019ab0:	60fb      	str	r3, [r7, #12]

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8019ab2:	687b      	ldr	r3, [r7, #4]
 8019ab4:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019ab8:	687b      	ldr	r3, [r7, #4]
 8019aba:	32b0      	adds	r2, #176	@ 0xb0
 8019abc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019ac0:	2b00      	cmp	r3, #0
 8019ac2:	d101      	bne.n	8019ac8 <USBD_CDC_DataOut+0x32>
  {
    return (uint8_t)USBD_FAIL;
 8019ac4:	2303      	movs	r3, #3
 8019ac6:	e01a      	b.n	8019afe <USBD_CDC_DataOut+0x68>
  }

  /* Get the received data length */
  hcdc->RxLength = USBD_LL_GetRxDataSize(pdev, epnum);
 8019ac8:	78fb      	ldrb	r3, [r7, #3]
 8019aca:	4619      	mov	r1, r3
 8019acc:	6878      	ldr	r0, [r7, #4]
 8019ace:	f002 f9fa 	bl	801bec6 <USBD_LL_GetRxDataSize>
 8019ad2:	4602      	mov	r2, r0
 8019ad4:	68fb      	ldr	r3, [r7, #12]
 8019ad6:	f8c3 220c 	str.w	r2, [r3, #524]	@ 0x20c

  /* USB data will be immediately processed, this allow next USB traffic being
  NAKed till the end of the application Xfer */

  ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Receive(hcdc->RxBuffer, &hcdc->RxLength);
 8019ada:	687b      	ldr	r3, [r7, #4]
 8019adc:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8019ae0:	687a      	ldr	r2, [r7, #4]
 8019ae2:	33b0      	adds	r3, #176	@ 0xb0
 8019ae4:	009b      	lsls	r3, r3, #2
 8019ae6:	4413      	add	r3, r2
 8019ae8:	685b      	ldr	r3, [r3, #4]
 8019aea:	68db      	ldr	r3, [r3, #12]
 8019aec:	68fa      	ldr	r2, [r7, #12]
 8019aee:	f8d2 0204 	ldr.w	r0, [r2, #516]	@ 0x204
 8019af2:	68fa      	ldr	r2, [r7, #12]
 8019af4:	f502 7203 	add.w	r2, r2, #524	@ 0x20c
 8019af8:	4611      	mov	r1, r2
 8019afa:	4798      	blx	r3

  return (uint8_t)USBD_OK;
 8019afc:	2300      	movs	r3, #0
}
 8019afe:	4618      	mov	r0, r3
 8019b00:	3710      	adds	r7, #16
 8019b02:	46bd      	mov	sp, r7
 8019b04:	bd80      	pop	{r7, pc}

08019b06 <USBD_CDC_EP0_RxReady>:
  *         Handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t USBD_CDC_EP0_RxReady(USBD_HandleTypeDef *pdev)
{
 8019b06:	b580      	push	{r7, lr}
 8019b08:	b084      	sub	sp, #16
 8019b0a:	af00      	add	r7, sp, #0
 8019b0c:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8019b0e:	687b      	ldr	r3, [r7, #4]
 8019b10:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019b14:	687b      	ldr	r3, [r7, #4]
 8019b16:	32b0      	adds	r2, #176	@ 0xb0
 8019b18:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019b1c:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8019b1e:	68fb      	ldr	r3, [r7, #12]
 8019b20:	2b00      	cmp	r3, #0
 8019b22:	d101      	bne.n	8019b28 <USBD_CDC_EP0_RxReady+0x22>
  {
    return (uint8_t)USBD_FAIL;
 8019b24:	2303      	movs	r3, #3
 8019b26:	e024      	b.n	8019b72 <USBD_CDC_EP0_RxReady+0x6c>
  }

  if ((pdev->pUserData[pdev->classId] != NULL) && (hcdc->CmdOpCode != 0xFFU))
 8019b28:	687b      	ldr	r3, [r7, #4]
 8019b2a:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8019b2e:	687a      	ldr	r2, [r7, #4]
 8019b30:	33b0      	adds	r3, #176	@ 0xb0
 8019b32:	009b      	lsls	r3, r3, #2
 8019b34:	4413      	add	r3, r2
 8019b36:	685b      	ldr	r3, [r3, #4]
 8019b38:	2b00      	cmp	r3, #0
 8019b3a:	d019      	beq.n	8019b70 <USBD_CDC_EP0_RxReady+0x6a>
 8019b3c:	68fb      	ldr	r3, [r7, #12]
 8019b3e:	f893 3200 	ldrb.w	r3, [r3, #512]	@ 0x200
 8019b42:	2bff      	cmp	r3, #255	@ 0xff
 8019b44:	d014      	beq.n	8019b70 <USBD_CDC_EP0_RxReady+0x6a>
  {
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8019b46:	687b      	ldr	r3, [r7, #4]
 8019b48:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8019b4c:	687a      	ldr	r2, [r7, #4]
 8019b4e:	33b0      	adds	r3, #176	@ 0xb0
 8019b50:	009b      	lsls	r3, r3, #2
 8019b52:	4413      	add	r3, r2
 8019b54:	685b      	ldr	r3, [r3, #4]
 8019b56:	689b      	ldr	r3, [r3, #8]
 8019b58:	68fa      	ldr	r2, [r7, #12]
 8019b5a:	f892 0200 	ldrb.w	r0, [r2, #512]	@ 0x200
                                                                     (uint8_t *)hcdc->data,
 8019b5e:	68f9      	ldr	r1, [r7, #12]
                                                                     (uint16_t)hcdc->CmdLength);
 8019b60:	68fa      	ldr	r2, [r7, #12]
 8019b62:	f892 2201 	ldrb.w	r2, [r2, #513]	@ 0x201
    ((USBD_CDC_ItfTypeDef *)pdev->pUserData[pdev->classId])->Control(hcdc->CmdOpCode,
 8019b66:	4798      	blx	r3
    hcdc->CmdOpCode = 0xFFU;
 8019b68:	68fb      	ldr	r3, [r7, #12]
 8019b6a:	22ff      	movs	r2, #255	@ 0xff
 8019b6c:	f883 2200 	strb.w	r2, [r3, #512]	@ 0x200
  }

  return (uint8_t)USBD_OK;
 8019b70:	2300      	movs	r3, #0
}
 8019b72:	4618      	mov	r0, r3
 8019b74:	3710      	adds	r7, #16
 8019b76:	46bd      	mov	sp, r7
 8019b78:	bd80      	pop	{r7, pc}
	...

08019b7c <USBD_CDC_GetFSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetFSCfgDesc(uint16_t *length)
{
 8019b7c:	b580      	push	{r7, lr}
 8019b7e:	b086      	sub	sp, #24
 8019b80:	af00      	add	r7, sp, #0
 8019b82:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8019b84:	2182      	movs	r1, #130	@ 0x82
 8019b86:	4818      	ldr	r0, [pc, #96]	@ (8019be8 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8019b88:	f000 fd4f 	bl	801a62a <USBD_GetEpDesc>
 8019b8c:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8019b8e:	2101      	movs	r1, #1
 8019b90:	4815      	ldr	r0, [pc, #84]	@ (8019be8 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8019b92:	f000 fd4a 	bl	801a62a <USBD_GetEpDesc>
 8019b96:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8019b98:	2181      	movs	r1, #129	@ 0x81
 8019b9a:	4813      	ldr	r0, [pc, #76]	@ (8019be8 <USBD_CDC_GetFSCfgDesc+0x6c>)
 8019b9c:	f000 fd45 	bl	801a62a <USBD_GetEpDesc>
 8019ba0:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8019ba2:	697b      	ldr	r3, [r7, #20]
 8019ba4:	2b00      	cmp	r3, #0
 8019ba6:	d002      	beq.n	8019bae <USBD_CDC_GetFSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8019ba8:	697b      	ldr	r3, [r7, #20]
 8019baa:	2210      	movs	r2, #16
 8019bac:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8019bae:	693b      	ldr	r3, [r7, #16]
 8019bb0:	2b00      	cmp	r3, #0
 8019bb2:	d006      	beq.n	8019bc2 <USBD_CDC_GetFSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8019bb4:	693b      	ldr	r3, [r7, #16]
 8019bb6:	2200      	movs	r2, #0
 8019bb8:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8019bbc:	711a      	strb	r2, [r3, #4]
 8019bbe:	2200      	movs	r2, #0
 8019bc0:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8019bc2:	68fb      	ldr	r3, [r7, #12]
 8019bc4:	2b00      	cmp	r3, #0
 8019bc6:	d006      	beq.n	8019bd6 <USBD_CDC_GetFSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8019bc8:	68fb      	ldr	r3, [r7, #12]
 8019bca:	2200      	movs	r2, #0
 8019bcc:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8019bd0:	711a      	strb	r2, [r3, #4]
 8019bd2:	2200      	movs	r2, #0
 8019bd4:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8019bd6:	687b      	ldr	r3, [r7, #4]
 8019bd8:	2243      	movs	r2, #67	@ 0x43
 8019bda:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8019bdc:	4b02      	ldr	r3, [pc, #8]	@ (8019be8 <USBD_CDC_GetFSCfgDesc+0x6c>)
}
 8019bde:	4618      	mov	r0, r3
 8019be0:	3718      	adds	r7, #24
 8019be2:	46bd      	mov	sp, r7
 8019be4:	bd80      	pop	{r7, pc}
 8019be6:	bf00      	nop
 8019be8:	200000f0 	.word	0x200000f0

08019bec <USBD_CDC_GetHSCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetHSCfgDesc(uint16_t *length)
{
 8019bec:	b580      	push	{r7, lr}
 8019bee:	b086      	sub	sp, #24
 8019bf0:	af00      	add	r7, sp, #0
 8019bf2:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8019bf4:	2182      	movs	r1, #130	@ 0x82
 8019bf6:	4818      	ldr	r0, [pc, #96]	@ (8019c58 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8019bf8:	f000 fd17 	bl	801a62a <USBD_GetEpDesc>
 8019bfc:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8019bfe:	2101      	movs	r1, #1
 8019c00:	4815      	ldr	r0, [pc, #84]	@ (8019c58 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8019c02:	f000 fd12 	bl	801a62a <USBD_GetEpDesc>
 8019c06:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8019c08:	2181      	movs	r1, #129	@ 0x81
 8019c0a:	4813      	ldr	r0, [pc, #76]	@ (8019c58 <USBD_CDC_GetHSCfgDesc+0x6c>)
 8019c0c:	f000 fd0d 	bl	801a62a <USBD_GetEpDesc>
 8019c10:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8019c12:	697b      	ldr	r3, [r7, #20]
 8019c14:	2b00      	cmp	r3, #0
 8019c16:	d002      	beq.n	8019c1e <USBD_CDC_GetHSCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_HS_BINTERVAL;
 8019c18:	697b      	ldr	r3, [r7, #20]
 8019c1a:	2210      	movs	r2, #16
 8019c1c:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8019c1e:	693b      	ldr	r3, [r7, #16]
 8019c20:	2b00      	cmp	r3, #0
 8019c22:	d006      	beq.n	8019c32 <USBD_CDC_GetHSCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8019c24:	693b      	ldr	r3, [r7, #16]
 8019c26:	2200      	movs	r2, #0
 8019c28:	711a      	strb	r2, [r3, #4]
 8019c2a:	2200      	movs	r2, #0
 8019c2c:	f042 0202 	orr.w	r2, r2, #2
 8019c30:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8019c32:	68fb      	ldr	r3, [r7, #12]
 8019c34:	2b00      	cmp	r3, #0
 8019c36:	d006      	beq.n	8019c46 <USBD_CDC_GetHSCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_HS_MAX_PACKET_SIZE;
 8019c38:	68fb      	ldr	r3, [r7, #12]
 8019c3a:	2200      	movs	r2, #0
 8019c3c:	711a      	strb	r2, [r3, #4]
 8019c3e:	2200      	movs	r2, #0
 8019c40:	f042 0202 	orr.w	r2, r2, #2
 8019c44:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8019c46:	687b      	ldr	r3, [r7, #4]
 8019c48:	2243      	movs	r2, #67	@ 0x43
 8019c4a:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8019c4c:	4b02      	ldr	r3, [pc, #8]	@ (8019c58 <USBD_CDC_GetHSCfgDesc+0x6c>)
}
 8019c4e:	4618      	mov	r0, r3
 8019c50:	3718      	adds	r7, #24
 8019c52:	46bd      	mov	sp, r7
 8019c54:	bd80      	pop	{r7, pc}
 8019c56:	bf00      	nop
 8019c58:	200000f0 	.word	0x200000f0

08019c5c <USBD_CDC_GetOtherSpeedCfgDesc>:
  *         Return configuration descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t *USBD_CDC_GetOtherSpeedCfgDesc(uint16_t *length)
{
 8019c5c:	b580      	push	{r7, lr}
 8019c5e:	b086      	sub	sp, #24
 8019c60:	af00      	add	r7, sp, #0
 8019c62:	6078      	str	r0, [r7, #4]
  USBD_EpDescTypeDef *pEpCmdDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_CMD_EP);
 8019c64:	2182      	movs	r1, #130	@ 0x82
 8019c66:	4818      	ldr	r0, [pc, #96]	@ (8019cc8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8019c68:	f000 fcdf 	bl	801a62a <USBD_GetEpDesc>
 8019c6c:	6178      	str	r0, [r7, #20]
  USBD_EpDescTypeDef *pEpOutDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_OUT_EP);
 8019c6e:	2101      	movs	r1, #1
 8019c70:	4815      	ldr	r0, [pc, #84]	@ (8019cc8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8019c72:	f000 fcda 	bl	801a62a <USBD_GetEpDesc>
 8019c76:	6138      	str	r0, [r7, #16]
  USBD_EpDescTypeDef *pEpInDesc = USBD_GetEpDesc(USBD_CDC_CfgDesc, CDC_IN_EP);
 8019c78:	2181      	movs	r1, #129	@ 0x81
 8019c7a:	4813      	ldr	r0, [pc, #76]	@ (8019cc8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
 8019c7c:	f000 fcd5 	bl	801a62a <USBD_GetEpDesc>
 8019c80:	60f8      	str	r0, [r7, #12]

  if (pEpCmdDesc != NULL)
 8019c82:	697b      	ldr	r3, [r7, #20]
 8019c84:	2b00      	cmp	r3, #0
 8019c86:	d002      	beq.n	8019c8e <USBD_CDC_GetOtherSpeedCfgDesc+0x32>
  {
    pEpCmdDesc->bInterval = CDC_FS_BINTERVAL;
 8019c88:	697b      	ldr	r3, [r7, #20]
 8019c8a:	2210      	movs	r2, #16
 8019c8c:	719a      	strb	r2, [r3, #6]
  }

  if (pEpOutDesc != NULL)
 8019c8e:	693b      	ldr	r3, [r7, #16]
 8019c90:	2b00      	cmp	r3, #0
 8019c92:	d006      	beq.n	8019ca2 <USBD_CDC_GetOtherSpeedCfgDesc+0x46>
  {
    pEpOutDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8019c94:	693b      	ldr	r3, [r7, #16]
 8019c96:	2200      	movs	r2, #0
 8019c98:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8019c9c:	711a      	strb	r2, [r3, #4]
 8019c9e:	2200      	movs	r2, #0
 8019ca0:	715a      	strb	r2, [r3, #5]
  }

  if (pEpInDesc != NULL)
 8019ca2:	68fb      	ldr	r3, [r7, #12]
 8019ca4:	2b00      	cmp	r3, #0
 8019ca6:	d006      	beq.n	8019cb6 <USBD_CDC_GetOtherSpeedCfgDesc+0x5a>
  {
    pEpInDesc->wMaxPacketSize = CDC_DATA_FS_MAX_PACKET_SIZE;
 8019ca8:	68fb      	ldr	r3, [r7, #12]
 8019caa:	2200      	movs	r2, #0
 8019cac:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8019cb0:	711a      	strb	r2, [r3, #4]
 8019cb2:	2200      	movs	r2, #0
 8019cb4:	715a      	strb	r2, [r3, #5]
  }

  *length = (uint16_t)sizeof(USBD_CDC_CfgDesc);
 8019cb6:	687b      	ldr	r3, [r7, #4]
 8019cb8:	2243      	movs	r2, #67	@ 0x43
 8019cba:	801a      	strh	r2, [r3, #0]
  return USBD_CDC_CfgDesc;
 8019cbc:	4b02      	ldr	r3, [pc, #8]	@ (8019cc8 <USBD_CDC_GetOtherSpeedCfgDesc+0x6c>)
}
 8019cbe:	4618      	mov	r0, r3
 8019cc0:	3718      	adds	r7, #24
 8019cc2:	46bd      	mov	sp, r7
 8019cc4:	bd80      	pop	{r7, pc}
 8019cc6:	bf00      	nop
 8019cc8:	200000f0 	.word	0x200000f0

08019ccc <USBD_CDC_GetDeviceQualifierDescriptor>:
  *         return Device Qualifier descriptor
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
uint8_t *USBD_CDC_GetDeviceQualifierDescriptor(uint16_t *length)
{
 8019ccc:	b480      	push	{r7}
 8019cce:	b083      	sub	sp, #12
 8019cd0:	af00      	add	r7, sp, #0
 8019cd2:	6078      	str	r0, [r7, #4]
  *length = (uint16_t)sizeof(USBD_CDC_DeviceQualifierDesc);
 8019cd4:	687b      	ldr	r3, [r7, #4]
 8019cd6:	220a      	movs	r2, #10
 8019cd8:	801a      	strh	r2, [r3, #0]

  return USBD_CDC_DeviceQualifierDesc;
 8019cda:	4b03      	ldr	r3, [pc, #12]	@ (8019ce8 <USBD_CDC_GetDeviceQualifierDescriptor+0x1c>)
}
 8019cdc:	4618      	mov	r0, r3
 8019cde:	370c      	adds	r7, #12
 8019ce0:	46bd      	mov	sp, r7
 8019ce2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019ce6:	4770      	bx	lr
 8019ce8:	200000ac 	.word	0x200000ac

08019cec <USBD_CDC_RegisterInterface>:
  * @param  fops: CD  Interface callback
  * @retval status
  */
uint8_t USBD_CDC_RegisterInterface(USBD_HandleTypeDef *pdev,
                                   USBD_CDC_ItfTypeDef *fops)
{
 8019cec:	b480      	push	{r7}
 8019cee:	b083      	sub	sp, #12
 8019cf0:	af00      	add	r7, sp, #0
 8019cf2:	6078      	str	r0, [r7, #4]
 8019cf4:	6039      	str	r1, [r7, #0]
  if (fops == NULL)
 8019cf6:	683b      	ldr	r3, [r7, #0]
 8019cf8:	2b00      	cmp	r3, #0
 8019cfa:	d101      	bne.n	8019d00 <USBD_CDC_RegisterInterface+0x14>
  {
    return (uint8_t)USBD_FAIL;
 8019cfc:	2303      	movs	r3, #3
 8019cfe:	e009      	b.n	8019d14 <USBD_CDC_RegisterInterface+0x28>
  }

  pdev->pUserData[pdev->classId] = fops;
 8019d00:	687b      	ldr	r3, [r7, #4]
 8019d02:	f8d3 32d4 	ldr.w	r3, [r3, #724]	@ 0x2d4
 8019d06:	687a      	ldr	r2, [r7, #4]
 8019d08:	33b0      	adds	r3, #176	@ 0xb0
 8019d0a:	009b      	lsls	r3, r3, #2
 8019d0c:	4413      	add	r3, r2
 8019d0e:	683a      	ldr	r2, [r7, #0]
 8019d10:	605a      	str	r2, [r3, #4]

  return (uint8_t)USBD_OK;
 8019d12:	2300      	movs	r3, #0
}
 8019d14:	4618      	mov	r0, r3
 8019d16:	370c      	adds	r7, #12
 8019d18:	46bd      	mov	sp, r7
 8019d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019d1e:	4770      	bx	lr

08019d20 <USBD_CDC_SetTxBuffer>:
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_SetTxBuffer(USBD_HandleTypeDef *pdev,
                             uint8_t *pbuff, uint32_t length)
{
 8019d20:	b480      	push	{r7}
 8019d22:	b087      	sub	sp, #28
 8019d24:	af00      	add	r7, sp, #0
 8019d26:	60f8      	str	r0, [r7, #12]
 8019d28:	60b9      	str	r1, [r7, #8]
 8019d2a:	607a      	str	r2, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8019d2c:	68fb      	ldr	r3, [r7, #12]
 8019d2e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019d32:	68fb      	ldr	r3, [r7, #12]
 8019d34:	32b0      	adds	r2, #176	@ 0xb0
 8019d36:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019d3a:	617b      	str	r3, [r7, #20]
#endif /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 8019d3c:	697b      	ldr	r3, [r7, #20]
 8019d3e:	2b00      	cmp	r3, #0
 8019d40:	d101      	bne.n	8019d46 <USBD_CDC_SetTxBuffer+0x26>
  {
    return (uint8_t)USBD_FAIL;
 8019d42:	2303      	movs	r3, #3
 8019d44:	e008      	b.n	8019d58 <USBD_CDC_SetTxBuffer+0x38>
  }

  hcdc->TxBuffer = pbuff;
 8019d46:	697b      	ldr	r3, [r7, #20]
 8019d48:	68ba      	ldr	r2, [r7, #8]
 8019d4a:	f8c3 2208 	str.w	r2, [r3, #520]	@ 0x208
  hcdc->TxLength = length;
 8019d4e:	697b      	ldr	r3, [r7, #20]
 8019d50:	687a      	ldr	r2, [r7, #4]
 8019d52:	f8c3 2210 	str.w	r2, [r3, #528]	@ 0x210

  return (uint8_t)USBD_OK;
 8019d56:	2300      	movs	r3, #0
}
 8019d58:	4618      	mov	r0, r3
 8019d5a:	371c      	adds	r7, #28
 8019d5c:	46bd      	mov	sp, r7
 8019d5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019d62:	4770      	bx	lr

08019d64 <USBD_CDC_SetRxBuffer>:
  * @param  pdev: device instance
  * @param  pbuff: Rx Buffer
  * @retval status
  */
uint8_t USBD_CDC_SetRxBuffer(USBD_HandleTypeDef *pdev, uint8_t *pbuff)
{
 8019d64:	b480      	push	{r7}
 8019d66:	b085      	sub	sp, #20
 8019d68:	af00      	add	r7, sp, #0
 8019d6a:	6078      	str	r0, [r7, #4]
 8019d6c:	6039      	str	r1, [r7, #0]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8019d6e:	687b      	ldr	r3, [r7, #4]
 8019d70:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019d74:	687b      	ldr	r3, [r7, #4]
 8019d76:	32b0      	adds	r2, #176	@ 0xb0
 8019d78:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019d7c:	60fb      	str	r3, [r7, #12]

  if (hcdc == NULL)
 8019d7e:	68fb      	ldr	r3, [r7, #12]
 8019d80:	2b00      	cmp	r3, #0
 8019d82:	d101      	bne.n	8019d88 <USBD_CDC_SetRxBuffer+0x24>
  {
    return (uint8_t)USBD_FAIL;
 8019d84:	2303      	movs	r3, #3
 8019d86:	e004      	b.n	8019d92 <USBD_CDC_SetRxBuffer+0x2e>
  }

  hcdc->RxBuffer = pbuff;
 8019d88:	68fb      	ldr	r3, [r7, #12]
 8019d8a:	683a      	ldr	r2, [r7, #0]
 8019d8c:	f8c3 2204 	str.w	r2, [r3, #516]	@ 0x204

  return (uint8_t)USBD_OK;
 8019d90:	2300      	movs	r3, #0
}
 8019d92:	4618      	mov	r0, r3
 8019d94:	3714      	adds	r7, #20
 8019d96:	46bd      	mov	sp, r7
 8019d98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019d9c:	4770      	bx	lr
	...

08019da0 <USBD_CDC_TransmitPacket>:
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev, uint8_t ClassId)
{
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[ClassId];
#else
uint8_t USBD_CDC_TransmitPacket(USBD_HandleTypeDef *pdev)
{
 8019da0:	b580      	push	{r7, lr}
 8019da2:	b084      	sub	sp, #16
 8019da4:	af00      	add	r7, sp, #0
 8019da6:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8019da8:	687b      	ldr	r3, [r7, #4]
 8019daa:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019dae:	687b      	ldr	r3, [r7, #4]
 8019db0:	32b0      	adds	r2, #176	@ 0xb0
 8019db2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019db6:	60bb      	str	r3, [r7, #8]
#endif  /* USE_USBD_COMPOSITE */

  USBD_StatusTypeDef ret = USBD_BUSY;
 8019db8:	2301      	movs	r3, #1
 8019dba:	73fb      	strb	r3, [r7, #15]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCInEpAdd  = USBD_CoreGetEPAdd(pdev, USBD_EP_IN, USBD_EP_TYPE_BULK, ClassId);
#endif  /* USE_USBD_COMPOSITE */

  if (hcdc == NULL)
 8019dbc:	68bb      	ldr	r3, [r7, #8]
 8019dbe:	2b00      	cmp	r3, #0
 8019dc0:	d101      	bne.n	8019dc6 <USBD_CDC_TransmitPacket+0x26>
  {
    return (uint8_t)USBD_FAIL;
 8019dc2:	2303      	movs	r3, #3
 8019dc4:	e025      	b.n	8019e12 <USBD_CDC_TransmitPacket+0x72>
  }

  if (hcdc->TxState == 0U)
 8019dc6:	68bb      	ldr	r3, [r7, #8]
 8019dc8:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 8019dcc:	2b00      	cmp	r3, #0
 8019dce:	d11f      	bne.n	8019e10 <USBD_CDC_TransmitPacket+0x70>
  {
    /* Tx Transfer in progress */
    hcdc->TxState = 1U;
 8019dd0:	68bb      	ldr	r3, [r7, #8]
 8019dd2:	2201      	movs	r2, #1
 8019dd4:	f8c3 2214 	str.w	r2, [r3, #532]	@ 0x214

    /* Update the packet total length */
    pdev->ep_in[CDCInEpAdd & 0xFU].total_length = hcdc->TxLength;
 8019dd8:	4b10      	ldr	r3, [pc, #64]	@ (8019e1c <USBD_CDC_TransmitPacket+0x7c>)
 8019dda:	781b      	ldrb	r3, [r3, #0]
 8019ddc:	f003 020f 	and.w	r2, r3, #15
 8019de0:	68bb      	ldr	r3, [r7, #8]
 8019de2:	f8d3 1210 	ldr.w	r1, [r3, #528]	@ 0x210
 8019de6:	6878      	ldr	r0, [r7, #4]
 8019de8:	4613      	mov	r3, r2
 8019dea:	009b      	lsls	r3, r3, #2
 8019dec:	4413      	add	r3, r2
 8019dee:	009b      	lsls	r3, r3, #2
 8019df0:	4403      	add	r3, r0
 8019df2:	3318      	adds	r3, #24
 8019df4:	6019      	str	r1, [r3, #0]

    /* Transmit next packet */
    (void)USBD_LL_Transmit(pdev, CDCInEpAdd, hcdc->TxBuffer, hcdc->TxLength);
 8019df6:	4b09      	ldr	r3, [pc, #36]	@ (8019e1c <USBD_CDC_TransmitPacket+0x7c>)
 8019df8:	7819      	ldrb	r1, [r3, #0]
 8019dfa:	68bb      	ldr	r3, [r7, #8]
 8019dfc:	f8d3 2208 	ldr.w	r2, [r3, #520]	@ 0x208
 8019e00:	68bb      	ldr	r3, [r7, #8]
 8019e02:	f8d3 3210 	ldr.w	r3, [r3, #528]	@ 0x210
 8019e06:	6878      	ldr	r0, [r7, #4]
 8019e08:	f002 f81b 	bl	801be42 <USBD_LL_Transmit>

    ret = USBD_OK;
 8019e0c:	2300      	movs	r3, #0
 8019e0e:	73fb      	strb	r3, [r7, #15]
  }

  return (uint8_t)ret;
 8019e10:	7bfb      	ldrb	r3, [r7, #15]
}
 8019e12:	4618      	mov	r0, r3
 8019e14:	3710      	adds	r7, #16
 8019e16:	46bd      	mov	sp, r7
 8019e18:	bd80      	pop	{r7, pc}
 8019e1a:	bf00      	nop
 8019e1c:	20000133 	.word	0x20000133

08019e20 <USBD_CDC_ReceivePacket>:
  *         prepare OUT Endpoint for reception
  * @param  pdev: device instance
  * @retval status
  */
uint8_t USBD_CDC_ReceivePacket(USBD_HandleTypeDef *pdev)
{
 8019e20:	b580      	push	{r7, lr}
 8019e22:	b084      	sub	sp, #16
 8019e24:	af00      	add	r7, sp, #0
 8019e26:	6078      	str	r0, [r7, #4]
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef *)pdev->pClassDataCmsit[pdev->classId];
 8019e28:	687b      	ldr	r3, [r7, #4]
 8019e2a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019e2e:	687b      	ldr	r3, [r7, #4]
 8019e30:	32b0      	adds	r2, #176	@ 0xb0
 8019e32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019e36:	60fb      	str	r3, [r7, #12]
#ifdef USE_USBD_COMPOSITE
  /* Get the Endpoints addresses allocated for this class instance */
  CDCOutEpAdd = USBD_CoreGetEPAdd(pdev, USBD_EP_OUT, USBD_EP_TYPE_BULK, (uint8_t)pdev->classId);
#endif /* USE_USBD_COMPOSITE */

  if (pdev->pClassDataCmsit[pdev->classId] == NULL)
 8019e38:	687b      	ldr	r3, [r7, #4]
 8019e3a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019e3e:	687b      	ldr	r3, [r7, #4]
 8019e40:	32b0      	adds	r2, #176	@ 0xb0
 8019e42:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019e46:	2b00      	cmp	r3, #0
 8019e48:	d101      	bne.n	8019e4e <USBD_CDC_ReceivePacket+0x2e>
  {
    return (uint8_t)USBD_FAIL;
 8019e4a:	2303      	movs	r3, #3
 8019e4c:	e018      	b.n	8019e80 <USBD_CDC_ReceivePacket+0x60>
  }

  if (pdev->dev_speed == USBD_SPEED_HIGH)
 8019e4e:	687b      	ldr	r3, [r7, #4]
 8019e50:	7c1b      	ldrb	r3, [r3, #16]
 8019e52:	2b00      	cmp	r3, #0
 8019e54:	d10a      	bne.n	8019e6c <USBD_CDC_ReceivePacket+0x4c>
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8019e56:	4b0c      	ldr	r3, [pc, #48]	@ (8019e88 <USBD_CDC_ReceivePacket+0x68>)
 8019e58:	7819      	ldrb	r1, [r3, #0]
 8019e5a:	68fb      	ldr	r3, [r7, #12]
 8019e5c:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8019e60:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8019e64:	6878      	ldr	r0, [r7, #4]
 8019e66:	f002 f80d 	bl	801be84 <USBD_LL_PrepareReceive>
 8019e6a:	e008      	b.n	8019e7e <USBD_CDC_ReceivePacket+0x5e>
                                 CDC_DATA_HS_OUT_PACKET_SIZE);
  }
  else
  {
    /* Prepare Out endpoint to receive next packet */
    (void)USBD_LL_PrepareReceive(pdev, CDCOutEpAdd, hcdc->RxBuffer,
 8019e6c:	4b06      	ldr	r3, [pc, #24]	@ (8019e88 <USBD_CDC_ReceivePacket+0x68>)
 8019e6e:	7819      	ldrb	r1, [r3, #0]
 8019e70:	68fb      	ldr	r3, [r7, #12]
 8019e72:	f8d3 2204 	ldr.w	r2, [r3, #516]	@ 0x204
 8019e76:	2340      	movs	r3, #64	@ 0x40
 8019e78:	6878      	ldr	r0, [r7, #4]
 8019e7a:	f002 f803 	bl	801be84 <USBD_LL_PrepareReceive>
                                 CDC_DATA_FS_OUT_PACKET_SIZE);
  }

  return (uint8_t)USBD_OK;
 8019e7e:	2300      	movs	r3, #0
}
 8019e80:	4618      	mov	r0, r3
 8019e82:	3710      	adds	r7, #16
 8019e84:	46bd      	mov	sp, r7
 8019e86:	bd80      	pop	{r7, pc}
 8019e88:	20000134 	.word	0x20000134

08019e8c <USBD_Init>:
  * @param  id: Low level core index
  * @retval None
  */
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev,
                             USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 8019e8c:	b580      	push	{r7, lr}
 8019e8e:	b086      	sub	sp, #24
 8019e90:	af00      	add	r7, sp, #0
 8019e92:	60f8      	str	r0, [r7, #12]
 8019e94:	60b9      	str	r1, [r7, #8]
 8019e96:	4613      	mov	r3, r2
 8019e98:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef ret;

  /* Check whether the USB Host handle is valid */
  if (pdev == NULL)
 8019e9a:	68fb      	ldr	r3, [r7, #12]
 8019e9c:	2b00      	cmp	r3, #0
 8019e9e:	d101      	bne.n	8019ea4 <USBD_Init+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Device handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 8019ea0:	2303      	movs	r3, #3
 8019ea2:	e01f      	b.n	8019ee4 <USBD_Init+0x58>
    pdev->NumClasses = 0;
    pdev->classId = 0;
  }
#else
  /* Unlink previous class*/
  pdev->pClass[0] = NULL;
 8019ea4:	68fb      	ldr	r3, [r7, #12]
 8019ea6:	2200      	movs	r2, #0
 8019ea8:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  pdev->pUserData[0] = NULL;
 8019eac:	68fb      	ldr	r3, [r7, #12]
 8019eae:	2200      	movs	r2, #0
 8019eb0:	f8c3 22c4 	str.w	r2, [r3, #708]	@ 0x2c4
#endif /* USE_USBD_COMPOSITE */

  pdev->pConfDesc = NULL;
 8019eb4:	68fb      	ldr	r3, [r7, #12]
 8019eb6:	2200      	movs	r2, #0
 8019eb8:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0

  /* Assign USBD Descriptors */
  if (pdesc != NULL)
 8019ebc:	68bb      	ldr	r3, [r7, #8]
 8019ebe:	2b00      	cmp	r3, #0
 8019ec0:	d003      	beq.n	8019eca <USBD_Init+0x3e>
  {
    pdev->pDesc = pdesc;
 8019ec2:	68fb      	ldr	r3, [r7, #12]
 8019ec4:	68ba      	ldr	r2, [r7, #8]
 8019ec6:	f8c3 22b4 	str.w	r2, [r3, #692]	@ 0x2b4
  }

  /* Set Device initial State */
  pdev->dev_state = USBD_STATE_DEFAULT;
 8019eca:	68fb      	ldr	r3, [r7, #12]
 8019ecc:	2201      	movs	r2, #1
 8019ece:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->id = id;
 8019ed2:	68fb      	ldr	r3, [r7, #12]
 8019ed4:	79fa      	ldrb	r2, [r7, #7]
 8019ed6:	701a      	strb	r2, [r3, #0]

  /* Initialize low level driver */
  ret = USBD_LL_Init(pdev);
 8019ed8:	68f8      	ldr	r0, [r7, #12]
 8019eda:	f001 fe7d 	bl	801bbd8 <USBD_LL_Init>
 8019ede:	4603      	mov	r3, r0
 8019ee0:	75fb      	strb	r3, [r7, #23]

  return ret;
 8019ee2:	7dfb      	ldrb	r3, [r7, #23]
}
 8019ee4:	4618      	mov	r0, r3
 8019ee6:	3718      	adds	r7, #24
 8019ee8:	46bd      	mov	sp, r7
 8019eea:	bd80      	pop	{r7, pc}

08019eec <USBD_RegisterClass>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
 8019eec:	b580      	push	{r7, lr}
 8019eee:	b084      	sub	sp, #16
 8019ef0:	af00      	add	r7, sp, #0
 8019ef2:	6078      	str	r0, [r7, #4]
 8019ef4:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 8019ef6:	2300      	movs	r3, #0
 8019ef8:	81fb      	strh	r3, [r7, #14]

  if (pclass == NULL)
 8019efa:	683b      	ldr	r3, [r7, #0]
 8019efc:	2b00      	cmp	r3, #0
 8019efe:	d101      	bne.n	8019f04 <USBD_RegisterClass+0x18>
  {
#if (USBD_DEBUG_LEVEL > 1U)
    USBD_ErrLog("Invalid Class handle");
#endif /* (USBD_DEBUG_LEVEL > 1U) */
    return USBD_FAIL;
 8019f00:	2303      	movs	r3, #3
 8019f02:	e025      	b.n	8019f50 <USBD_RegisterClass+0x64>
  }

  /* link the class to the USB Device handle */
  pdev->pClass[0] = pclass;
 8019f04:	687b      	ldr	r3, [r7, #4]
 8019f06:	683a      	ldr	r2, [r7, #0]
 8019f08:	f8c3 22b8 	str.w	r2, [r3, #696]	@ 0x2b8
  if (pdev->pClass[pdev->classId]->GetHSConfigDescriptor != NULL)
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetHSConfigDescriptor(&len);
  }
#else /* Default USE_USB_FS */
  if (pdev->pClass[pdev->classId]->GetFSConfigDescriptor != NULL)
 8019f0c:	687b      	ldr	r3, [r7, #4]
 8019f0e:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019f12:	687b      	ldr	r3, [r7, #4]
 8019f14:	32ae      	adds	r2, #174	@ 0xae
 8019f16:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019f1a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8019f1c:	2b00      	cmp	r3, #0
 8019f1e:	d00f      	beq.n	8019f40 <USBD_RegisterClass+0x54>
  {
    pdev->pConfDesc = (void *)pdev->pClass[pdev->classId]->GetFSConfigDescriptor(&len);
 8019f20:	687b      	ldr	r3, [r7, #4]
 8019f22:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 8019f26:	687b      	ldr	r3, [r7, #4]
 8019f28:	32ae      	adds	r2, #174	@ 0xae
 8019f2a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019f2e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8019f30:	f107 020e 	add.w	r2, r7, #14
 8019f34:	4610      	mov	r0, r2
 8019f36:	4798      	blx	r3
 8019f38:	4602      	mov	r2, r0
 8019f3a:	687b      	ldr	r3, [r7, #4]
 8019f3c:	f8c3 22d0 	str.w	r2, [r3, #720]	@ 0x2d0
  }
#endif /* USE_USB_FS */

  /* Increment the NumClasses */
  pdev->NumClasses ++;
 8019f40:	687b      	ldr	r3, [r7, #4]
 8019f42:	f8d3 32d8 	ldr.w	r3, [r3, #728]	@ 0x2d8
 8019f46:	1c5a      	adds	r2, r3, #1
 8019f48:	687b      	ldr	r3, [r7, #4]
 8019f4a:	f8c3 22d8 	str.w	r2, [r3, #728]	@ 0x2d8

  return USBD_OK;
 8019f4e:	2300      	movs	r3, #0
}
 8019f50:	4618      	mov	r0, r3
 8019f52:	3710      	adds	r7, #16
 8019f54:	46bd      	mov	sp, r7
 8019f56:	bd80      	pop	{r7, pc}

08019f58 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_Start(USBD_HandleTypeDef *pdev)
{
 8019f58:	b580      	push	{r7, lr}
 8019f5a:	b082      	sub	sp, #8
 8019f5c:	af00      	add	r7, sp, #0
 8019f5e:	6078      	str	r0, [r7, #4]
#ifdef USE_USBD_COMPOSITE
  pdev->classId = 0U;
#endif /* USE_USBD_COMPOSITE */

  /* Start the low level driver  */
  return USBD_LL_Start(pdev);
 8019f60:	6878      	ldr	r0, [r7, #4]
 8019f62:	f001 fe85 	bl	801bc70 <USBD_LL_Start>
 8019f66:	4603      	mov	r3, r0
}
 8019f68:	4618      	mov	r0, r3
 8019f6a:	3708      	adds	r7, #8
 8019f6c:	46bd      	mov	sp, r7
 8019f6e:	bd80      	pop	{r7, pc}

08019f70 <USBD_RunTestMode>:
  *         Launch test mode process
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_RunTestMode(USBD_HandleTypeDef *pdev)
{
 8019f70:	b480      	push	{r7}
 8019f72:	b083      	sub	sp, #12
 8019f74:	af00      	add	r7, sp, #0
 8019f76:	6078      	str	r0, [r7, #4]
  return ret;
#else
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 8019f78:	2300      	movs	r3, #0
#endif /* USBD_HS_TESTMODE_ENABLE */
}
 8019f7a:	4618      	mov	r0, r3
 8019f7c:	370c      	adds	r7, #12
 8019f7e:	46bd      	mov	sp, r7
 8019f80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019f84:	4770      	bx	lr

08019f86 <USBD_SetClassConfig>:
  * @param  cfgidx: configuration index
  * @retval status
  */

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8019f86:	b580      	push	{r7, lr}
 8019f88:	b084      	sub	sp, #16
 8019f8a:	af00      	add	r7, sp, #0
 8019f8c:	6078      	str	r0, [r7, #4]
 8019f8e:	460b      	mov	r3, r1
 8019f90:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 8019f92:	2300      	movs	r3, #0
 8019f94:	73fb      	strb	r3, [r7, #15]
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 8019f96:	687b      	ldr	r3, [r7, #4]
 8019f98:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8019f9c:	2b00      	cmp	r3, #0
 8019f9e:	d009      	beq.n	8019fb4 <USBD_SetClassConfig+0x2e>
  {
    /* Set configuration and Start the Class */
    ret = (USBD_StatusTypeDef)pdev->pClass[0]->Init(pdev, cfgidx);
 8019fa0:	687b      	ldr	r3, [r7, #4]
 8019fa2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8019fa6:	681b      	ldr	r3, [r3, #0]
 8019fa8:	78fa      	ldrb	r2, [r7, #3]
 8019faa:	4611      	mov	r1, r2
 8019fac:	6878      	ldr	r0, [r7, #4]
 8019fae:	4798      	blx	r3
 8019fb0:	4603      	mov	r3, r0
 8019fb2:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 8019fb4:	7bfb      	ldrb	r3, [r7, #15]
}
 8019fb6:	4618      	mov	r0, r3
 8019fb8:	3710      	adds	r7, #16
 8019fba:	46bd      	mov	sp, r7
 8019fbc:	bd80      	pop	{r7, pc}

08019fbe <USBD_ClrClassConfig>:
  * @param  pdev: device instance
  * @param  cfgidx: configuration index
  * @retval status: USBD_StatusTypeDef
  */
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef *pdev, uint8_t cfgidx)
{
 8019fbe:	b580      	push	{r7, lr}
 8019fc0:	b084      	sub	sp, #16
 8019fc2:	af00      	add	r7, sp, #0
 8019fc4:	6078      	str	r0, [r7, #4]
 8019fc6:	460b      	mov	r3, r1
 8019fc8:	70fb      	strb	r3, [r7, #3]
  USBD_StatusTypeDef ret = USBD_OK;
 8019fca:	2300      	movs	r3, #0
 8019fcc:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#else
  /* Clear configuration  and De-initialize the Class process */
  if (pdev->pClass[0]->DeInit(pdev, cfgidx) != 0U)
 8019fce:	687b      	ldr	r3, [r7, #4]
 8019fd0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 8019fd4:	685b      	ldr	r3, [r3, #4]
 8019fd6:	78fa      	ldrb	r2, [r7, #3]
 8019fd8:	4611      	mov	r1, r2
 8019fda:	6878      	ldr	r0, [r7, #4]
 8019fdc:	4798      	blx	r3
 8019fde:	4603      	mov	r3, r0
 8019fe0:	2b00      	cmp	r3, #0
 8019fe2:	d001      	beq.n	8019fe8 <USBD_ClrClassConfig+0x2a>
  {
    ret = USBD_FAIL;
 8019fe4:	2303      	movs	r3, #3
 8019fe6:	73fb      	strb	r3, [r7, #15]
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 8019fe8:	7bfb      	ldrb	r3, [r7, #15]
}
 8019fea:	4618      	mov	r0, r3
 8019fec:	3710      	adds	r7, #16
 8019fee:	46bd      	mov	sp, r7
 8019ff0:	bd80      	pop	{r7, pc}

08019ff2 <USBD_LL_SetupStage>:
  *         Handle the setup stage
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 8019ff2:	b580      	push	{r7, lr}
 8019ff4:	b084      	sub	sp, #16
 8019ff6:	af00      	add	r7, sp, #0
 8019ff8:	6078      	str	r0, [r7, #4]
 8019ffa:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret;

  USBD_ParseSetupRequest(&pdev->request, psetup);
 8019ffc:	687b      	ldr	r3, [r7, #4]
 8019ffe:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 801a002:	6839      	ldr	r1, [r7, #0]
 801a004:	4618      	mov	r0, r3
 801a006:	f001 f90c 	bl	801b222 <USBD_ParseSetupRequest>

  pdev->ep0_state = USBD_EP0_SETUP;
 801a00a:	687b      	ldr	r3, [r7, #4]
 801a00c:	2201      	movs	r2, #1
 801a00e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  pdev->ep0_data_len = pdev->request.wLength;
 801a012:	687b      	ldr	r3, [r7, #4]
 801a014:	f8b3 32b0 	ldrh.w	r3, [r3, #688]	@ 0x2b0
 801a018:	461a      	mov	r2, r3
 801a01a:	687b      	ldr	r3, [r7, #4]
 801a01c:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

  switch (pdev->request.bmRequest & 0x1FU)
 801a020:	687b      	ldr	r3, [r7, #4]
 801a022:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 801a026:	f003 031f 	and.w	r3, r3, #31
 801a02a:	2b02      	cmp	r3, #2
 801a02c:	d01a      	beq.n	801a064 <USBD_LL_SetupStage+0x72>
 801a02e:	2b02      	cmp	r3, #2
 801a030:	d822      	bhi.n	801a078 <USBD_LL_SetupStage+0x86>
 801a032:	2b00      	cmp	r3, #0
 801a034:	d002      	beq.n	801a03c <USBD_LL_SetupStage+0x4a>
 801a036:	2b01      	cmp	r3, #1
 801a038:	d00a      	beq.n	801a050 <USBD_LL_SetupStage+0x5e>
 801a03a:	e01d      	b.n	801a078 <USBD_LL_SetupStage+0x86>
  {
    case USB_REQ_RECIPIENT_DEVICE:
      ret = USBD_StdDevReq(pdev, &pdev->request);
 801a03c:	687b      	ldr	r3, [r7, #4]
 801a03e:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 801a042:	4619      	mov	r1, r3
 801a044:	6878      	ldr	r0, [r7, #4]
 801a046:	f000 fb63 	bl	801a710 <USBD_StdDevReq>
 801a04a:	4603      	mov	r3, r0
 801a04c:	73fb      	strb	r3, [r7, #15]
      break;
 801a04e:	e020      	b.n	801a092 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_INTERFACE:
      ret = USBD_StdItfReq(pdev, &pdev->request);
 801a050:	687b      	ldr	r3, [r7, #4]
 801a052:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 801a056:	4619      	mov	r1, r3
 801a058:	6878      	ldr	r0, [r7, #4]
 801a05a:	f000 fbcb 	bl	801a7f4 <USBD_StdItfReq>
 801a05e:	4603      	mov	r3, r0
 801a060:	73fb      	strb	r3, [r7, #15]
      break;
 801a062:	e016      	b.n	801a092 <USBD_LL_SetupStage+0xa0>

    case USB_REQ_RECIPIENT_ENDPOINT:
      ret = USBD_StdEPReq(pdev, &pdev->request);
 801a064:	687b      	ldr	r3, [r7, #4]
 801a066:	f203 23aa 	addw	r3, r3, #682	@ 0x2aa
 801a06a:	4619      	mov	r1, r3
 801a06c:	6878      	ldr	r0, [r7, #4]
 801a06e:	f000 fc2d 	bl	801a8cc <USBD_StdEPReq>
 801a072:	4603      	mov	r3, r0
 801a074:	73fb      	strb	r3, [r7, #15]
      break;
 801a076:	e00c      	b.n	801a092 <USBD_LL_SetupStage+0xa0>

    default:
      ret = USBD_LL_StallEP(pdev, (pdev->request.bmRequest & 0x80U));
 801a078:	687b      	ldr	r3, [r7, #4]
 801a07a:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 801a07e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 801a082:	b2db      	uxtb	r3, r3
 801a084:	4619      	mov	r1, r3
 801a086:	6878      	ldr	r0, [r7, #4]
 801a088:	f001 fe52 	bl	801bd30 <USBD_LL_StallEP>
 801a08c:	4603      	mov	r3, r0
 801a08e:	73fb      	strb	r3, [r7, #15]
      break;
 801a090:	bf00      	nop
  }

  return ret;
 801a092:	7bfb      	ldrb	r3, [r7, #15]
}
 801a094:	4618      	mov	r0, r3
 801a096:	3710      	adds	r7, #16
 801a098:	46bd      	mov	sp, r7
 801a09a:	bd80      	pop	{r7, pc}

0801a09c <USBD_LL_DataOutStage>:
  * @param  pdata: data pointer
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev,
                                        uint8_t epnum, uint8_t *pdata)
{
 801a09c:	b580      	push	{r7, lr}
 801a09e:	b086      	sub	sp, #24
 801a0a0:	af00      	add	r7, sp, #0
 801a0a2:	60f8      	str	r0, [r7, #12]
 801a0a4:	460b      	mov	r3, r1
 801a0a6:	607a      	str	r2, [r7, #4]
 801a0a8:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret = USBD_OK;
 801a0aa:	2300      	movs	r3, #0
 801a0ac:	75fb      	strb	r3, [r7, #23]
  uint8_t idx;

  if (epnum == 0U)
 801a0ae:	7afb      	ldrb	r3, [r7, #11]
 801a0b0:	2b00      	cmp	r3, #0
 801a0b2:	d16e      	bne.n	801a192 <USBD_LL_DataOutStage+0xf6>
  {
    pep = &pdev->ep_out[0];
 801a0b4:	68fb      	ldr	r3, [r7, #12]
 801a0b6:	f503 73aa 	add.w	r3, r3, #340	@ 0x154
 801a0ba:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_OUT)
 801a0bc:	68fb      	ldr	r3, [r7, #12]
 801a0be:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 801a0c2:	2b03      	cmp	r3, #3
 801a0c4:	f040 8098 	bne.w	801a1f8 <USBD_LL_DataOutStage+0x15c>
    {
      if (pep->rem_length > pep->maxpacket)
 801a0c8:	693b      	ldr	r3, [r7, #16]
 801a0ca:	689a      	ldr	r2, [r3, #8]
 801a0cc:	693b      	ldr	r3, [r7, #16]
 801a0ce:	68db      	ldr	r3, [r3, #12]
 801a0d0:	429a      	cmp	r2, r3
 801a0d2:	d913      	bls.n	801a0fc <USBD_LL_DataOutStage+0x60>
      {
        pep->rem_length -= pep->maxpacket;
 801a0d4:	693b      	ldr	r3, [r7, #16]
 801a0d6:	689a      	ldr	r2, [r3, #8]
 801a0d8:	693b      	ldr	r3, [r7, #16]
 801a0da:	68db      	ldr	r3, [r3, #12]
 801a0dc:	1ad2      	subs	r2, r2, r3
 801a0de:	693b      	ldr	r3, [r7, #16]
 801a0e0:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueRx(pdev, pdata, MIN(pep->rem_length, pep->maxpacket));
 801a0e2:	693b      	ldr	r3, [r7, #16]
 801a0e4:	68da      	ldr	r2, [r3, #12]
 801a0e6:	693b      	ldr	r3, [r7, #16]
 801a0e8:	689b      	ldr	r3, [r3, #8]
 801a0ea:	4293      	cmp	r3, r2
 801a0ec:	bf28      	it	cs
 801a0ee:	4613      	movcs	r3, r2
 801a0f0:	461a      	mov	r2, r3
 801a0f2:	6879      	ldr	r1, [r7, #4]
 801a0f4:	68f8      	ldr	r0, [r7, #12]
 801a0f6:	f001 f988 	bl	801b40a <USBD_CtlContinueRx>
 801a0fa:	e07d      	b.n	801a1f8 <USBD_LL_DataOutStage+0x15c>
      }
      else
      {
        /* Find the class ID relative to the current request */
        switch (pdev->request.bmRequest & 0x1FU)
 801a0fc:	68fb      	ldr	r3, [r7, #12]
 801a0fe:	f893 32aa 	ldrb.w	r3, [r3, #682]	@ 0x2aa
 801a102:	f003 031f 	and.w	r3, r3, #31
 801a106:	2b02      	cmp	r3, #2
 801a108:	d014      	beq.n	801a134 <USBD_LL_DataOutStage+0x98>
 801a10a:	2b02      	cmp	r3, #2
 801a10c:	d81d      	bhi.n	801a14a <USBD_LL_DataOutStage+0xae>
 801a10e:	2b00      	cmp	r3, #0
 801a110:	d002      	beq.n	801a118 <USBD_LL_DataOutStage+0x7c>
 801a112:	2b01      	cmp	r3, #1
 801a114:	d003      	beq.n	801a11e <USBD_LL_DataOutStage+0x82>
 801a116:	e018      	b.n	801a14a <USBD_LL_DataOutStage+0xae>
        {
          case USB_REQ_RECIPIENT_DEVICE:
            /* Device requests must be managed by the first instantiated class
               (or duplicated by all classes for simplicity) */
            idx = 0U;
 801a118:	2300      	movs	r3, #0
 801a11a:	75bb      	strb	r3, [r7, #22]
            break;
 801a11c:	e018      	b.n	801a150 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_INTERFACE:
            idx = USBD_CoreFindIF(pdev, LOBYTE(pdev->request.wIndex));
 801a11e:	68fb      	ldr	r3, [r7, #12]
 801a120:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 801a124:	b2db      	uxtb	r3, r3
 801a126:	4619      	mov	r1, r3
 801a128:	68f8      	ldr	r0, [r7, #12]
 801a12a:	f000 fa64 	bl	801a5f6 <USBD_CoreFindIF>
 801a12e:	4603      	mov	r3, r0
 801a130:	75bb      	strb	r3, [r7, #22]
            break;
 801a132:	e00d      	b.n	801a150 <USBD_LL_DataOutStage+0xb4>

          case USB_REQ_RECIPIENT_ENDPOINT:
            idx = USBD_CoreFindEP(pdev, LOBYTE(pdev->request.wIndex));
 801a134:	68fb      	ldr	r3, [r7, #12]
 801a136:	f8b3 32ae 	ldrh.w	r3, [r3, #686]	@ 0x2ae
 801a13a:	b2db      	uxtb	r3, r3
 801a13c:	4619      	mov	r1, r3
 801a13e:	68f8      	ldr	r0, [r7, #12]
 801a140:	f000 fa66 	bl	801a610 <USBD_CoreFindEP>
 801a144:	4603      	mov	r3, r0
 801a146:	75bb      	strb	r3, [r7, #22]
            break;
 801a148:	e002      	b.n	801a150 <USBD_LL_DataOutStage+0xb4>

          default:
            /* Back to the first class in case of doubt */
            idx = 0U;
 801a14a:	2300      	movs	r3, #0
 801a14c:	75bb      	strb	r3, [r7, #22]
            break;
 801a14e:	bf00      	nop
        }

        if (idx < USBD_MAX_SUPPORTED_CLASS)
 801a150:	7dbb      	ldrb	r3, [r7, #22]
 801a152:	2b00      	cmp	r3, #0
 801a154:	d119      	bne.n	801a18a <USBD_LL_DataOutStage+0xee>
        {
          /* Setup the class ID and route the request to the relative class function */
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801a156:	68fb      	ldr	r3, [r7, #12]
 801a158:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a15c:	b2db      	uxtb	r3, r3
 801a15e:	2b03      	cmp	r3, #3
 801a160:	d113      	bne.n	801a18a <USBD_LL_DataOutStage+0xee>
          {
            if (pdev->pClass[idx]->EP0_RxReady != NULL)
 801a162:	7dba      	ldrb	r2, [r7, #22]
 801a164:	68fb      	ldr	r3, [r7, #12]
 801a166:	32ae      	adds	r2, #174	@ 0xae
 801a168:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a16c:	691b      	ldr	r3, [r3, #16]
 801a16e:	2b00      	cmp	r3, #0
 801a170:	d00b      	beq.n	801a18a <USBD_LL_DataOutStage+0xee>
            {
              pdev->classId = idx;
 801a172:	7dba      	ldrb	r2, [r7, #22]
 801a174:	68fb      	ldr	r3, [r7, #12]
 801a176:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[idx]->EP0_RxReady(pdev);
 801a17a:	7dba      	ldrb	r2, [r7, #22]
 801a17c:	68fb      	ldr	r3, [r7, #12]
 801a17e:	32ae      	adds	r2, #174	@ 0xae
 801a180:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a184:	691b      	ldr	r3, [r3, #16]
 801a186:	68f8      	ldr	r0, [r7, #12]
 801a188:	4798      	blx	r3
            }
          }
        }

        (void)USBD_CtlSendStatus(pdev);
 801a18a:	68f8      	ldr	r0, [r7, #12]
 801a18c:	f001 f94e 	bl	801b42c <USBD_CtlSendStatus>
 801a190:	e032      	b.n	801a1f8 <USBD_LL_DataOutStage+0x15c>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, (epnum & 0x7FU));
 801a192:	7afb      	ldrb	r3, [r7, #11]
 801a194:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801a198:	b2db      	uxtb	r3, r3
 801a19a:	4619      	mov	r1, r3
 801a19c:	68f8      	ldr	r0, [r7, #12]
 801a19e:	f000 fa37 	bl	801a610 <USBD_CoreFindEP>
 801a1a2:	4603      	mov	r3, r0
 801a1a4:	75bb      	strb	r3, [r7, #22]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801a1a6:	7dbb      	ldrb	r3, [r7, #22]
 801a1a8:	2bff      	cmp	r3, #255	@ 0xff
 801a1aa:	d025      	beq.n	801a1f8 <USBD_LL_DataOutStage+0x15c>
 801a1ac:	7dbb      	ldrb	r3, [r7, #22]
 801a1ae:	2b00      	cmp	r3, #0
 801a1b0:	d122      	bne.n	801a1f8 <USBD_LL_DataOutStage+0x15c>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801a1b2:	68fb      	ldr	r3, [r7, #12]
 801a1b4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a1b8:	b2db      	uxtb	r3, r3
 801a1ba:	2b03      	cmp	r3, #3
 801a1bc:	d117      	bne.n	801a1ee <USBD_LL_DataOutStage+0x152>
      {
        if (pdev->pClass[idx]->DataOut != NULL)
 801a1be:	7dba      	ldrb	r2, [r7, #22]
 801a1c0:	68fb      	ldr	r3, [r7, #12]
 801a1c2:	32ae      	adds	r2, #174	@ 0xae
 801a1c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a1c8:	699b      	ldr	r3, [r3, #24]
 801a1ca:	2b00      	cmp	r3, #0
 801a1cc:	d00f      	beq.n	801a1ee <USBD_LL_DataOutStage+0x152>
        {
          pdev->classId = idx;
 801a1ce:	7dba      	ldrb	r2, [r7, #22]
 801a1d0:	68fb      	ldr	r3, [r7, #12]
 801a1d2:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataOut(pdev, epnum);
 801a1d6:	7dba      	ldrb	r2, [r7, #22]
 801a1d8:	68fb      	ldr	r3, [r7, #12]
 801a1da:	32ae      	adds	r2, #174	@ 0xae
 801a1dc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a1e0:	699b      	ldr	r3, [r3, #24]
 801a1e2:	7afa      	ldrb	r2, [r7, #11]
 801a1e4:	4611      	mov	r1, r2
 801a1e6:	68f8      	ldr	r0, [r7, #12]
 801a1e8:	4798      	blx	r3
 801a1ea:	4603      	mov	r3, r0
 801a1ec:	75fb      	strb	r3, [r7, #23]
        }
      }
      if (ret != USBD_OK)
 801a1ee:	7dfb      	ldrb	r3, [r7, #23]
 801a1f0:	2b00      	cmp	r3, #0
 801a1f2:	d001      	beq.n	801a1f8 <USBD_LL_DataOutStage+0x15c>
      {
        return ret;
 801a1f4:	7dfb      	ldrb	r3, [r7, #23]
 801a1f6:	e000      	b.n	801a1fa <USBD_LL_DataOutStage+0x15e>
      }
    }
  }

  return USBD_OK;
 801a1f8:	2300      	movs	r3, #0
}
 801a1fa:	4618      	mov	r0, r3
 801a1fc:	3718      	adds	r7, #24
 801a1fe:	46bd      	mov	sp, r7
 801a200:	bd80      	pop	{r7, pc}

0801a202 <USBD_LL_DataInStage>:
  * @param  epnum: endpoint index
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev,
                                       uint8_t epnum, uint8_t *pdata)
{
 801a202:	b580      	push	{r7, lr}
 801a204:	b086      	sub	sp, #24
 801a206:	af00      	add	r7, sp, #0
 801a208:	60f8      	str	r0, [r7, #12]
 801a20a:	460b      	mov	r3, r1
 801a20c:	607a      	str	r2, [r7, #4]
 801a20e:	72fb      	strb	r3, [r7, #11]
  USBD_EndpointTypeDef *pep;
  USBD_StatusTypeDef ret;
  uint8_t idx;

  if (epnum == 0U)
 801a210:	7afb      	ldrb	r3, [r7, #11]
 801a212:	2b00      	cmp	r3, #0
 801a214:	d16f      	bne.n	801a2f6 <USBD_LL_DataInStage+0xf4>
  {
    pep = &pdev->ep_in[0];
 801a216:	68fb      	ldr	r3, [r7, #12]
 801a218:	3314      	adds	r3, #20
 801a21a:	613b      	str	r3, [r7, #16]

    if (pdev->ep0_state == USBD_EP0_DATA_IN)
 801a21c:	68fb      	ldr	r3, [r7, #12]
 801a21e:	f8d3 3294 	ldr.w	r3, [r3, #660]	@ 0x294
 801a222:	2b02      	cmp	r3, #2
 801a224:	d15a      	bne.n	801a2dc <USBD_LL_DataInStage+0xda>
    {
      if (pep->rem_length > pep->maxpacket)
 801a226:	693b      	ldr	r3, [r7, #16]
 801a228:	689a      	ldr	r2, [r3, #8]
 801a22a:	693b      	ldr	r3, [r7, #16]
 801a22c:	68db      	ldr	r3, [r3, #12]
 801a22e:	429a      	cmp	r2, r3
 801a230:	d914      	bls.n	801a25c <USBD_LL_DataInStage+0x5a>
      {
        pep->rem_length -= pep->maxpacket;
 801a232:	693b      	ldr	r3, [r7, #16]
 801a234:	689a      	ldr	r2, [r3, #8]
 801a236:	693b      	ldr	r3, [r7, #16]
 801a238:	68db      	ldr	r3, [r3, #12]
 801a23a:	1ad2      	subs	r2, r2, r3
 801a23c:	693b      	ldr	r3, [r7, #16]
 801a23e:	609a      	str	r2, [r3, #8]

        (void)USBD_CtlContinueSendData(pdev, pdata, pep->rem_length);
 801a240:	693b      	ldr	r3, [r7, #16]
 801a242:	689b      	ldr	r3, [r3, #8]
 801a244:	461a      	mov	r2, r3
 801a246:	6879      	ldr	r1, [r7, #4]
 801a248:	68f8      	ldr	r0, [r7, #12]
 801a24a:	f001 f8b0 	bl	801b3ae <USBD_CtlContinueSendData>

        /* Prepare endpoint for premature end of transfer */
        (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801a24e:	2300      	movs	r3, #0
 801a250:	2200      	movs	r2, #0
 801a252:	2100      	movs	r1, #0
 801a254:	68f8      	ldr	r0, [r7, #12]
 801a256:	f001 fe15 	bl	801be84 <USBD_LL_PrepareReceive>
 801a25a:	e03f      	b.n	801a2dc <USBD_LL_DataInStage+0xda>
      }
      else
      {
        /* last packet is MPS multiple, so send ZLP packet */
        if ((pep->maxpacket == pep->rem_length) &&
 801a25c:	693b      	ldr	r3, [r7, #16]
 801a25e:	68da      	ldr	r2, [r3, #12]
 801a260:	693b      	ldr	r3, [r7, #16]
 801a262:	689b      	ldr	r3, [r3, #8]
 801a264:	429a      	cmp	r2, r3
 801a266:	d11c      	bne.n	801a2a2 <USBD_LL_DataInStage+0xa0>
            (pep->total_length >= pep->maxpacket) &&
 801a268:	693b      	ldr	r3, [r7, #16]
 801a26a:	685a      	ldr	r2, [r3, #4]
 801a26c:	693b      	ldr	r3, [r7, #16]
 801a26e:	68db      	ldr	r3, [r3, #12]
        if ((pep->maxpacket == pep->rem_length) &&
 801a270:	429a      	cmp	r2, r3
 801a272:	d316      	bcc.n	801a2a2 <USBD_LL_DataInStage+0xa0>
            (pep->total_length < pdev->ep0_data_len))
 801a274:	693b      	ldr	r3, [r7, #16]
 801a276:	685a      	ldr	r2, [r3, #4]
 801a278:	68fb      	ldr	r3, [r7, #12]
 801a27a:	f8d3 3298 	ldr.w	r3, [r3, #664]	@ 0x298
            (pep->total_length >= pep->maxpacket) &&
 801a27e:	429a      	cmp	r2, r3
 801a280:	d20f      	bcs.n	801a2a2 <USBD_LL_DataInStage+0xa0>
        {
          (void)USBD_CtlContinueSendData(pdev, NULL, 0U);
 801a282:	2200      	movs	r2, #0
 801a284:	2100      	movs	r1, #0
 801a286:	68f8      	ldr	r0, [r7, #12]
 801a288:	f001 f891 	bl	801b3ae <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0U;
 801a28c:	68fb      	ldr	r3, [r7, #12]
 801a28e:	2200      	movs	r2, #0
 801a290:	f8c3 2298 	str.w	r2, [r3, #664]	@ 0x298

          /* Prepare endpoint for premature end of transfer */
          (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801a294:	2300      	movs	r3, #0
 801a296:	2200      	movs	r2, #0
 801a298:	2100      	movs	r1, #0
 801a29a:	68f8      	ldr	r0, [r7, #12]
 801a29c:	f001 fdf2 	bl	801be84 <USBD_LL_PrepareReceive>
 801a2a0:	e01c      	b.n	801a2dc <USBD_LL_DataInStage+0xda>
        }
        else
        {
          if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801a2a2:	68fb      	ldr	r3, [r7, #12]
 801a2a4:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a2a8:	b2db      	uxtb	r3, r3
 801a2aa:	2b03      	cmp	r3, #3
 801a2ac:	d10f      	bne.n	801a2ce <USBD_LL_DataInStage+0xcc>
          {
            if (pdev->pClass[0]->EP0_TxSent != NULL)
 801a2ae:	68fb      	ldr	r3, [r7, #12]
 801a2b0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a2b4:	68db      	ldr	r3, [r3, #12]
 801a2b6:	2b00      	cmp	r3, #0
 801a2b8:	d009      	beq.n	801a2ce <USBD_LL_DataInStage+0xcc>
            {
              pdev->classId = 0U;
 801a2ba:	68fb      	ldr	r3, [r7, #12]
 801a2bc:	2200      	movs	r2, #0
 801a2be:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
              pdev->pClass[0]->EP0_TxSent(pdev);
 801a2c2:	68fb      	ldr	r3, [r7, #12]
 801a2c4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a2c8:	68db      	ldr	r3, [r3, #12]
 801a2ca:	68f8      	ldr	r0, [r7, #12]
 801a2cc:	4798      	blx	r3
            }
          }
          (void)USBD_LL_StallEP(pdev, 0x80U);
 801a2ce:	2180      	movs	r1, #128	@ 0x80
 801a2d0:	68f8      	ldr	r0, [r7, #12]
 801a2d2:	f001 fd2d 	bl	801bd30 <USBD_LL_StallEP>
          (void)USBD_CtlReceiveStatus(pdev);
 801a2d6:	68f8      	ldr	r0, [r7, #12]
 801a2d8:	f001 f8bb 	bl	801b452 <USBD_CtlReceiveStatus>
        }
      }
    }

    if (pdev->dev_test_mode != 0U)
 801a2dc:	68fb      	ldr	r3, [r7, #12]
 801a2de:	f893 32a0 	ldrb.w	r3, [r3, #672]	@ 0x2a0
 801a2e2:	2b00      	cmp	r3, #0
 801a2e4:	d03a      	beq.n	801a35c <USBD_LL_DataInStage+0x15a>
    {
      (void)USBD_RunTestMode(pdev);
 801a2e6:	68f8      	ldr	r0, [r7, #12]
 801a2e8:	f7ff fe42 	bl	8019f70 <USBD_RunTestMode>
      pdev->dev_test_mode = 0U;
 801a2ec:	68fb      	ldr	r3, [r7, #12]
 801a2ee:	2200      	movs	r2, #0
 801a2f0:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
 801a2f4:	e032      	b.n	801a35c <USBD_LL_DataInStage+0x15a>
    }
  }
  else
  {
    /* Get the class index relative to this interface */
    idx = USBD_CoreFindEP(pdev, ((uint8_t)epnum | 0x80U));
 801a2f6:	7afb      	ldrb	r3, [r7, #11]
 801a2f8:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 801a2fc:	b2db      	uxtb	r3, r3
 801a2fe:	4619      	mov	r1, r3
 801a300:	68f8      	ldr	r0, [r7, #12]
 801a302:	f000 f985 	bl	801a610 <USBD_CoreFindEP>
 801a306:	4603      	mov	r3, r0
 801a308:	75fb      	strb	r3, [r7, #23]

    if (((uint16_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801a30a:	7dfb      	ldrb	r3, [r7, #23]
 801a30c:	2bff      	cmp	r3, #255	@ 0xff
 801a30e:	d025      	beq.n	801a35c <USBD_LL_DataInStage+0x15a>
 801a310:	7dfb      	ldrb	r3, [r7, #23]
 801a312:	2b00      	cmp	r3, #0
 801a314:	d122      	bne.n	801a35c <USBD_LL_DataInStage+0x15a>
    {
      /* Call the class data out function to manage the request */
      if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801a316:	68fb      	ldr	r3, [r7, #12]
 801a318:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a31c:	b2db      	uxtb	r3, r3
 801a31e:	2b03      	cmp	r3, #3
 801a320:	d11c      	bne.n	801a35c <USBD_LL_DataInStage+0x15a>
      {
        if (pdev->pClass[idx]->DataIn != NULL)
 801a322:	7dfa      	ldrb	r2, [r7, #23]
 801a324:	68fb      	ldr	r3, [r7, #12]
 801a326:	32ae      	adds	r2, #174	@ 0xae
 801a328:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a32c:	695b      	ldr	r3, [r3, #20]
 801a32e:	2b00      	cmp	r3, #0
 801a330:	d014      	beq.n	801a35c <USBD_LL_DataInStage+0x15a>
        {
          pdev->classId = idx;
 801a332:	7dfa      	ldrb	r2, [r7, #23]
 801a334:	68fb      	ldr	r3, [r7, #12]
 801a336:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->DataIn(pdev, epnum);
 801a33a:	7dfa      	ldrb	r2, [r7, #23]
 801a33c:	68fb      	ldr	r3, [r7, #12]
 801a33e:	32ae      	adds	r2, #174	@ 0xae
 801a340:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a344:	695b      	ldr	r3, [r3, #20]
 801a346:	7afa      	ldrb	r2, [r7, #11]
 801a348:	4611      	mov	r1, r2
 801a34a:	68f8      	ldr	r0, [r7, #12]
 801a34c:	4798      	blx	r3
 801a34e:	4603      	mov	r3, r0
 801a350:	75bb      	strb	r3, [r7, #22]

          if (ret != USBD_OK)
 801a352:	7dbb      	ldrb	r3, [r7, #22]
 801a354:	2b00      	cmp	r3, #0
 801a356:	d001      	beq.n	801a35c <USBD_LL_DataInStage+0x15a>
          {
            return ret;
 801a358:	7dbb      	ldrb	r3, [r7, #22]
 801a35a:	e000      	b.n	801a35e <USBD_LL_DataInStage+0x15c>
        }
      }
    }
  }

  return USBD_OK;
 801a35c:	2300      	movs	r3, #0
}
 801a35e:	4618      	mov	r0, r3
 801a360:	3718      	adds	r7, #24
 801a362:	46bd      	mov	sp, r7
 801a364:	bd80      	pop	{r7, pc}

0801a366 <USBD_LL_Reset>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef *pdev)
{
 801a366:	b580      	push	{r7, lr}
 801a368:	b084      	sub	sp, #16
 801a36a:	af00      	add	r7, sp, #0
 801a36c:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef ret = USBD_OK;
 801a36e:	2300      	movs	r3, #0
 801a370:	73fb      	strb	r3, [r7, #15]

  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801a372:	687b      	ldr	r3, [r7, #4]
 801a374:	2201      	movs	r2, #1
 801a376:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  pdev->ep0_state = USBD_EP0_IDLE;
 801a37a:	687b      	ldr	r3, [r7, #4]
 801a37c:	2200      	movs	r2, #0
 801a37e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->dev_config = 0U;
 801a382:	687b      	ldr	r3, [r7, #4]
 801a384:	2200      	movs	r2, #0
 801a386:	605a      	str	r2, [r3, #4]
  pdev->dev_remote_wakeup = 0U;
 801a388:	687b      	ldr	r3, [r7, #4]
 801a38a:	2200      	movs	r2, #0
 801a38c:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
  pdev->dev_test_mode = 0U;
 801a390:	687b      	ldr	r3, [r7, #4]
 801a392:	2200      	movs	r2, #0
 801a394:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
      }
    }
  }
#else

  if (pdev->pClass[0] != NULL)
 801a398:	687b      	ldr	r3, [r7, #4]
 801a39a:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a39e:	2b00      	cmp	r3, #0
 801a3a0:	d014      	beq.n	801a3cc <USBD_LL_Reset+0x66>
  {
    if (pdev->pClass[0]->DeInit != NULL)
 801a3a2:	687b      	ldr	r3, [r7, #4]
 801a3a4:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a3a8:	685b      	ldr	r3, [r3, #4]
 801a3aa:	2b00      	cmp	r3, #0
 801a3ac:	d00e      	beq.n	801a3cc <USBD_LL_Reset+0x66>
    {
      if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != USBD_OK)
 801a3ae:	687b      	ldr	r3, [r7, #4]
 801a3b0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a3b4:	685b      	ldr	r3, [r3, #4]
 801a3b6:	687a      	ldr	r2, [r7, #4]
 801a3b8:	6852      	ldr	r2, [r2, #4]
 801a3ba:	b2d2      	uxtb	r2, r2
 801a3bc:	4611      	mov	r1, r2
 801a3be:	6878      	ldr	r0, [r7, #4]
 801a3c0:	4798      	blx	r3
 801a3c2:	4603      	mov	r3, r0
 801a3c4:	2b00      	cmp	r3, #0
 801a3c6:	d001      	beq.n	801a3cc <USBD_LL_Reset+0x66>
      {
        ret = USBD_FAIL;
 801a3c8:	2303      	movs	r3, #3
 801a3ca:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  /* Open EP0 OUT */
  (void)USBD_LL_OpenEP(pdev, 0x00U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801a3cc:	2340      	movs	r3, #64	@ 0x40
 801a3ce:	2200      	movs	r2, #0
 801a3d0:	2100      	movs	r1, #0
 801a3d2:	6878      	ldr	r0, [r7, #4]
 801a3d4:	f001 fc67 	bl	801bca6 <USBD_LL_OpenEP>
  pdev->ep_out[0x00U & 0xFU].is_used = 1U;
 801a3d8:	687b      	ldr	r3, [r7, #4]
 801a3da:	2201      	movs	r2, #1
 801a3dc:	f8a3 2164 	strh.w	r2, [r3, #356]	@ 0x164

  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 801a3e0:	687b      	ldr	r3, [r7, #4]
 801a3e2:	2240      	movs	r2, #64	@ 0x40
 801a3e4:	f8c3 2160 	str.w	r2, [r3, #352]	@ 0x160

  /* Open EP0 IN */
  (void)USBD_LL_OpenEP(pdev, 0x80U, USBD_EP_TYPE_CTRL, USB_MAX_EP0_SIZE);
 801a3e8:	2340      	movs	r3, #64	@ 0x40
 801a3ea:	2200      	movs	r2, #0
 801a3ec:	2180      	movs	r1, #128	@ 0x80
 801a3ee:	6878      	ldr	r0, [r7, #4]
 801a3f0:	f001 fc59 	bl	801bca6 <USBD_LL_OpenEP>
  pdev->ep_in[0x80U & 0xFU].is_used = 1U;
 801a3f4:	687b      	ldr	r3, [r7, #4]
 801a3f6:	2201      	movs	r2, #1
 801a3f8:	849a      	strh	r2, [r3, #36]	@ 0x24

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 801a3fa:	687b      	ldr	r3, [r7, #4]
 801a3fc:	2240      	movs	r2, #64	@ 0x40
 801a3fe:	621a      	str	r2, [r3, #32]

  return ret;
 801a400:	7bfb      	ldrb	r3, [r7, #15]
}
 801a402:	4618      	mov	r0, r3
 801a404:	3710      	adds	r7, #16
 801a406:	46bd      	mov	sp, r7
 801a408:	bd80      	pop	{r7, pc}

0801a40a <USBD_LL_SetSpeed>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef *pdev,
                                    USBD_SpeedTypeDef speed)
{
 801a40a:	b480      	push	{r7}
 801a40c:	b083      	sub	sp, #12
 801a40e:	af00      	add	r7, sp, #0
 801a410:	6078      	str	r0, [r7, #4]
 801a412:	460b      	mov	r3, r1
 801a414:	70fb      	strb	r3, [r7, #3]
  pdev->dev_speed = speed;
 801a416:	687b      	ldr	r3, [r7, #4]
 801a418:	78fa      	ldrb	r2, [r7, #3]
 801a41a:	741a      	strb	r2, [r3, #16]

  return USBD_OK;
 801a41c:	2300      	movs	r3, #0
}
 801a41e:	4618      	mov	r0, r3
 801a420:	370c      	adds	r7, #12
 801a422:	46bd      	mov	sp, r7
 801a424:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a428:	4770      	bx	lr

0801a42a <USBD_LL_Suspend>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef *pdev)
{
 801a42a:	b480      	push	{r7}
 801a42c:	b083      	sub	sp, #12
 801a42e:	af00      	add	r7, sp, #0
 801a430:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state != USBD_STATE_SUSPENDED)
 801a432:	687b      	ldr	r3, [r7, #4]
 801a434:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a438:	b2db      	uxtb	r3, r3
 801a43a:	2b04      	cmp	r3, #4
 801a43c:	d006      	beq.n	801a44c <USBD_LL_Suspend+0x22>
  {
    pdev->dev_old_state = pdev->dev_state;
 801a43e:	687b      	ldr	r3, [r7, #4]
 801a440:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a444:	b2da      	uxtb	r2, r3
 801a446:	687b      	ldr	r3, [r7, #4]
 801a448:	f883 229d 	strb.w	r2, [r3, #669]	@ 0x29d
  }

  pdev->dev_state = USBD_STATE_SUSPENDED;
 801a44c:	687b      	ldr	r3, [r7, #4]
 801a44e:	2204      	movs	r2, #4
 801a450:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c

  return USBD_OK;
 801a454:	2300      	movs	r3, #0
}
 801a456:	4618      	mov	r0, r3
 801a458:	370c      	adds	r7, #12
 801a45a:	46bd      	mov	sp, r7
 801a45c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a460:	4770      	bx	lr

0801a462 <USBD_LL_Resume>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef *pdev)
{
 801a462:	b480      	push	{r7}
 801a464:	b083      	sub	sp, #12
 801a466:	af00      	add	r7, sp, #0
 801a468:	6078      	str	r0, [r7, #4]
  if (pdev->dev_state == USBD_STATE_SUSPENDED)
 801a46a:	687b      	ldr	r3, [r7, #4]
 801a46c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a470:	b2db      	uxtb	r3, r3
 801a472:	2b04      	cmp	r3, #4
 801a474:	d106      	bne.n	801a484 <USBD_LL_Resume+0x22>
  {
    pdev->dev_state = pdev->dev_old_state;
 801a476:	687b      	ldr	r3, [r7, #4]
 801a478:	f893 329d 	ldrb.w	r3, [r3, #669]	@ 0x29d
 801a47c:	b2da      	uxtb	r2, r3
 801a47e:	687b      	ldr	r3, [r7, #4]
 801a480:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
  }

  return USBD_OK;
 801a484:	2300      	movs	r3, #0
}
 801a486:	4618      	mov	r0, r3
 801a488:	370c      	adds	r7, #12
 801a48a:	46bd      	mov	sp, r7
 801a48c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a490:	4770      	bx	lr

0801a492 <USBD_LL_SOF>:
  * @param  pdev: device instance
  * @retval status
  */

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef *pdev)
{
 801a492:	b580      	push	{r7, lr}
 801a494:	b082      	sub	sp, #8
 801a496:	af00      	add	r7, sp, #0
 801a498:	6078      	str	r0, [r7, #4]
  /* The SOF event can be distributed for all classes that support it */
  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801a49a:	687b      	ldr	r3, [r7, #4]
 801a49c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a4a0:	b2db      	uxtb	r3, r3
 801a4a2:	2b03      	cmp	r3, #3
 801a4a4:	d110      	bne.n	801a4c8 <USBD_LL_SOF+0x36>
          }
        }
      }
    }
#else
    if (pdev->pClass[0] != NULL)
 801a4a6:	687b      	ldr	r3, [r7, #4]
 801a4a8:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a4ac:	2b00      	cmp	r3, #0
 801a4ae:	d00b      	beq.n	801a4c8 <USBD_LL_SOF+0x36>
    {
      if (pdev->pClass[0]->SOF != NULL)
 801a4b0:	687b      	ldr	r3, [r7, #4]
 801a4b2:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a4b6:	69db      	ldr	r3, [r3, #28]
 801a4b8:	2b00      	cmp	r3, #0
 801a4ba:	d005      	beq.n	801a4c8 <USBD_LL_SOF+0x36>
      {
        (void)pdev->pClass[0]->SOF(pdev);
 801a4bc:	687b      	ldr	r3, [r7, #4]
 801a4be:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a4c2:	69db      	ldr	r3, [r3, #28]
 801a4c4:	6878      	ldr	r0, [r7, #4]
 801a4c6:	4798      	blx	r3
      }
    }
#endif /* USE_USBD_COMPOSITE */
  }

  return USBD_OK;
 801a4c8:	2300      	movs	r3, #0
}
 801a4ca:	4618      	mov	r0, r3
 801a4cc:	3708      	adds	r7, #8
 801a4ce:	46bd      	mov	sp, r7
 801a4d0:	bd80      	pop	{r7, pc}

0801a4d2 <USBD_LL_IsoINIncomplete>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef *pdev,
                                           uint8_t epnum)
{
 801a4d2:	b580      	push	{r7, lr}
 801a4d4:	b082      	sub	sp, #8
 801a4d6:	af00      	add	r7, sp, #0
 801a4d8:	6078      	str	r0, [r7, #4]
 801a4da:	460b      	mov	r3, r1
 801a4dc:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 801a4de:	687b      	ldr	r3, [r7, #4]
 801a4e0:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801a4e4:	687b      	ldr	r3, [r7, #4]
 801a4e6:	32ae      	adds	r2, #174	@ 0xae
 801a4e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a4ec:	2b00      	cmp	r3, #0
 801a4ee:	d101      	bne.n	801a4f4 <USBD_LL_IsoINIncomplete+0x22>
  {
    return USBD_FAIL;
 801a4f0:	2303      	movs	r3, #3
 801a4f2:	e01c      	b.n	801a52e <USBD_LL_IsoINIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801a4f4:	687b      	ldr	r3, [r7, #4]
 801a4f6:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a4fa:	b2db      	uxtb	r3, r3
 801a4fc:	2b03      	cmp	r3, #3
 801a4fe:	d115      	bne.n	801a52c <USBD_LL_IsoINIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoINIncomplete != NULL)
 801a500:	687b      	ldr	r3, [r7, #4]
 801a502:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801a506:	687b      	ldr	r3, [r7, #4]
 801a508:	32ae      	adds	r2, #174	@ 0xae
 801a50a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a50e:	6a1b      	ldr	r3, [r3, #32]
 801a510:	2b00      	cmp	r3, #0
 801a512:	d00b      	beq.n	801a52c <USBD_LL_IsoINIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoINIncomplete(pdev, epnum);
 801a514:	687b      	ldr	r3, [r7, #4]
 801a516:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801a51a:	687b      	ldr	r3, [r7, #4]
 801a51c:	32ae      	adds	r2, #174	@ 0xae
 801a51e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a522:	6a1b      	ldr	r3, [r3, #32]
 801a524:	78fa      	ldrb	r2, [r7, #3]
 801a526:	4611      	mov	r1, r2
 801a528:	6878      	ldr	r0, [r7, #4]
 801a52a:	4798      	blx	r3
    }
  }

  return USBD_OK;
 801a52c:	2300      	movs	r3, #0
}
 801a52e:	4618      	mov	r0, r3
 801a530:	3708      	adds	r7, #8
 801a532:	46bd      	mov	sp, r7
 801a534:	bd80      	pop	{r7, pc}

0801a536 <USBD_LL_IsoOUTIncomplete>:
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef *pdev,
                                            uint8_t epnum)
{
 801a536:	b580      	push	{r7, lr}
 801a538:	b082      	sub	sp, #8
 801a53a:	af00      	add	r7, sp, #0
 801a53c:	6078      	str	r0, [r7, #4]
 801a53e:	460b      	mov	r3, r1
 801a540:	70fb      	strb	r3, [r7, #3]
  if (pdev->pClass[pdev->classId] == NULL)
 801a542:	687b      	ldr	r3, [r7, #4]
 801a544:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801a548:	687b      	ldr	r3, [r7, #4]
 801a54a:	32ae      	adds	r2, #174	@ 0xae
 801a54c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a550:	2b00      	cmp	r3, #0
 801a552:	d101      	bne.n	801a558 <USBD_LL_IsoOUTIncomplete+0x22>
  {
    return USBD_FAIL;
 801a554:	2303      	movs	r3, #3
 801a556:	e01c      	b.n	801a592 <USBD_LL_IsoOUTIncomplete+0x5c>
  }

  if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801a558:	687b      	ldr	r3, [r7, #4]
 801a55a:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a55e:	b2db      	uxtb	r3, r3
 801a560:	2b03      	cmp	r3, #3
 801a562:	d115      	bne.n	801a590 <USBD_LL_IsoOUTIncomplete+0x5a>
  {
    if (pdev->pClass[pdev->classId]->IsoOUTIncomplete != NULL)
 801a564:	687b      	ldr	r3, [r7, #4]
 801a566:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801a56a:	687b      	ldr	r3, [r7, #4]
 801a56c:	32ae      	adds	r2, #174	@ 0xae
 801a56e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a572:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a574:	2b00      	cmp	r3, #0
 801a576:	d00b      	beq.n	801a590 <USBD_LL_IsoOUTIncomplete+0x5a>
    {
      (void)pdev->pClass[pdev->classId]->IsoOUTIncomplete(pdev, epnum);
 801a578:	687b      	ldr	r3, [r7, #4]
 801a57a:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801a57e:	687b      	ldr	r3, [r7, #4]
 801a580:	32ae      	adds	r2, #174	@ 0xae
 801a582:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a586:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a588:	78fa      	ldrb	r2, [r7, #3]
 801a58a:	4611      	mov	r1, r2
 801a58c:	6878      	ldr	r0, [r7, #4]
 801a58e:	4798      	blx	r3
    }
  }

  return USBD_OK;
 801a590:	2300      	movs	r3, #0
}
 801a592:	4618      	mov	r0, r3
 801a594:	3708      	adds	r7, #8
 801a596:	46bd      	mov	sp, r7
 801a598:	bd80      	pop	{r7, pc}

0801a59a <USBD_LL_DevConnected>:
  *         Handle device connection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef *pdev)
{
 801a59a:	b480      	push	{r7}
 801a59c:	b083      	sub	sp, #12
 801a59e:	af00      	add	r7, sp, #0
 801a5a0:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument compilation warning */
  UNUSED(pdev);

  return USBD_OK;
 801a5a2:	2300      	movs	r3, #0
}
 801a5a4:	4618      	mov	r0, r3
 801a5a6:	370c      	adds	r7, #12
 801a5a8:	46bd      	mov	sp, r7
 801a5aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a5ae:	4770      	bx	lr

0801a5b0 <USBD_LL_DevDisconnected>:
  *         Handle device disconnection event
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef *pdev)
{
 801a5b0:	b580      	push	{r7, lr}
 801a5b2:	b084      	sub	sp, #16
 801a5b4:	af00      	add	r7, sp, #0
 801a5b6:	6078      	str	r0, [r7, #4]
  USBD_StatusTypeDef   ret = USBD_OK;
 801a5b8:	2300      	movs	r3, #0
 801a5ba:	73fb      	strb	r3, [r7, #15]

  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
 801a5bc:	687b      	ldr	r3, [r7, #4]
 801a5be:	2201      	movs	r2, #1
 801a5c0:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        }
      }
    }
  }
#else
  if (pdev->pClass[0] != NULL)
 801a5c4:	687b      	ldr	r3, [r7, #4]
 801a5c6:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a5ca:	2b00      	cmp	r3, #0
 801a5cc:	d00e      	beq.n	801a5ec <USBD_LL_DevDisconnected+0x3c>
  {
    if (pdev->pClass[0]->DeInit(pdev, (uint8_t)pdev->dev_config) != 0U)
 801a5ce:	687b      	ldr	r3, [r7, #4]
 801a5d0:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801a5d4:	685b      	ldr	r3, [r3, #4]
 801a5d6:	687a      	ldr	r2, [r7, #4]
 801a5d8:	6852      	ldr	r2, [r2, #4]
 801a5da:	b2d2      	uxtb	r2, r2
 801a5dc:	4611      	mov	r1, r2
 801a5de:	6878      	ldr	r0, [r7, #4]
 801a5e0:	4798      	blx	r3
 801a5e2:	4603      	mov	r3, r0
 801a5e4:	2b00      	cmp	r3, #0
 801a5e6:	d001      	beq.n	801a5ec <USBD_LL_DevDisconnected+0x3c>
    {
      ret = USBD_FAIL;
 801a5e8:	2303      	movs	r3, #3
 801a5ea:	73fb      	strb	r3, [r7, #15]
    }
  }
#endif /* USE_USBD_COMPOSITE */

  return ret;
 801a5ec:	7bfb      	ldrb	r3, [r7, #15]
}
 801a5ee:	4618      	mov	r0, r3
 801a5f0:	3710      	adds	r7, #16
 801a5f2:	46bd      	mov	sp, r7
 801a5f4:	bd80      	pop	{r7, pc}

0801a5f6 <USBD_CoreFindIF>:
  * @param  pdev: device instance
  * @param  index : selected interface number
  * @retval index of the class using the selected interface number. OxFF if no class found.
  */
uint8_t USBD_CoreFindIF(USBD_HandleTypeDef *pdev, uint8_t index)
{
 801a5f6:	b480      	push	{r7}
 801a5f8:	b083      	sub	sp, #12
 801a5fa:	af00      	add	r7, sp, #0
 801a5fc:	6078      	str	r0, [r7, #4]
 801a5fe:	460b      	mov	r3, r1
 801a600:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 801a602:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 801a604:	4618      	mov	r0, r3
 801a606:	370c      	adds	r7, #12
 801a608:	46bd      	mov	sp, r7
 801a60a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a60e:	4770      	bx	lr

0801a610 <USBD_CoreFindEP>:
  * @param  pdev: device instance
  * @param  index : selected endpoint number
  * @retval index of the class using the selected endpoint number. 0xFF if no class found.
  */
uint8_t USBD_CoreFindEP(USBD_HandleTypeDef *pdev, uint8_t index)
{
 801a610:	b480      	push	{r7}
 801a612:	b083      	sub	sp, #12
 801a614:	af00      	add	r7, sp, #0
 801a616:	6078      	str	r0, [r7, #4]
 801a618:	460b      	mov	r3, r1
 801a61a:	70fb      	strb	r3, [r7, #3]
  return 0xFFU;
#else
  UNUSED(pdev);
  UNUSED(index);

  return 0x00U;
 801a61c:	2300      	movs	r3, #0
#endif /* USE_USBD_COMPOSITE */
}
 801a61e:	4618      	mov	r0, r3
 801a620:	370c      	adds	r7, #12
 801a622:	46bd      	mov	sp, r7
 801a624:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a628:	4770      	bx	lr

0801a62a <USBD_GetEpDesc>:
  * @param  pConfDesc:  pointer to Bos descriptor
  * @param  EpAddr:  endpoint address
  * @retval pointer to video endpoint descriptor
  */
void *USBD_GetEpDesc(uint8_t *pConfDesc, uint8_t EpAddr)
{
 801a62a:	b580      	push	{r7, lr}
 801a62c:	b086      	sub	sp, #24
 801a62e:	af00      	add	r7, sp, #0
 801a630:	6078      	str	r0, [r7, #4]
 801a632:	460b      	mov	r3, r1
 801a634:	70fb      	strb	r3, [r7, #3]
  USBD_DescHeaderTypeDef *pdesc = (USBD_DescHeaderTypeDef *)(void *)pConfDesc;
 801a636:	687b      	ldr	r3, [r7, #4]
 801a638:	617b      	str	r3, [r7, #20]
  USBD_ConfigDescTypeDef *desc = (USBD_ConfigDescTypeDef *)(void *)pConfDesc;
 801a63a:	687b      	ldr	r3, [r7, #4]
 801a63c:	60fb      	str	r3, [r7, #12]
  USBD_EpDescTypeDef *pEpDesc = NULL;
 801a63e:	2300      	movs	r3, #0
 801a640:	613b      	str	r3, [r7, #16]
  uint16_t ptr;

  if (desc->wTotalLength > desc->bLength)
 801a642:	68fb      	ldr	r3, [r7, #12]
 801a644:	885b      	ldrh	r3, [r3, #2]
 801a646:	b29b      	uxth	r3, r3
 801a648:	68fa      	ldr	r2, [r7, #12]
 801a64a:	7812      	ldrb	r2, [r2, #0]
 801a64c:	4293      	cmp	r3, r2
 801a64e:	d91f      	bls.n	801a690 <USBD_GetEpDesc+0x66>
  {
    ptr = desc->bLength;
 801a650:	68fb      	ldr	r3, [r7, #12]
 801a652:	781b      	ldrb	r3, [r3, #0]
 801a654:	817b      	strh	r3, [r7, #10]

    while (ptr < desc->wTotalLength)
 801a656:	e013      	b.n	801a680 <USBD_GetEpDesc+0x56>
    {
      pdesc = USBD_GetNextDesc((uint8_t *)pdesc, &ptr);
 801a658:	f107 030a 	add.w	r3, r7, #10
 801a65c:	4619      	mov	r1, r3
 801a65e:	6978      	ldr	r0, [r7, #20]
 801a660:	f000 f81b 	bl	801a69a <USBD_GetNextDesc>
 801a664:	6178      	str	r0, [r7, #20]

      if (pdesc->bDescriptorType == USB_DESC_TYPE_ENDPOINT)
 801a666:	697b      	ldr	r3, [r7, #20]
 801a668:	785b      	ldrb	r3, [r3, #1]
 801a66a:	2b05      	cmp	r3, #5
 801a66c:	d108      	bne.n	801a680 <USBD_GetEpDesc+0x56>
      {
        pEpDesc = (USBD_EpDescTypeDef *)(void *)pdesc;
 801a66e:	697b      	ldr	r3, [r7, #20]
 801a670:	613b      	str	r3, [r7, #16]

        if (pEpDesc->bEndpointAddress == EpAddr)
 801a672:	693b      	ldr	r3, [r7, #16]
 801a674:	789b      	ldrb	r3, [r3, #2]
 801a676:	78fa      	ldrb	r2, [r7, #3]
 801a678:	429a      	cmp	r2, r3
 801a67a:	d008      	beq.n	801a68e <USBD_GetEpDesc+0x64>
        {
          break;
        }
        else
        {
          pEpDesc = NULL;
 801a67c:	2300      	movs	r3, #0
 801a67e:	613b      	str	r3, [r7, #16]
    while (ptr < desc->wTotalLength)
 801a680:	68fb      	ldr	r3, [r7, #12]
 801a682:	885b      	ldrh	r3, [r3, #2]
 801a684:	b29a      	uxth	r2, r3
 801a686:	897b      	ldrh	r3, [r7, #10]
 801a688:	429a      	cmp	r2, r3
 801a68a:	d8e5      	bhi.n	801a658 <USBD_GetEpDesc+0x2e>
 801a68c:	e000      	b.n	801a690 <USBD_GetEpDesc+0x66>
          break;
 801a68e:	bf00      	nop
        }
      }
    }
  }

  return (void *)pEpDesc;
 801a690:	693b      	ldr	r3, [r7, #16]
}
 801a692:	4618      	mov	r0, r3
 801a694:	3718      	adds	r7, #24
 801a696:	46bd      	mov	sp, r7
 801a698:	bd80      	pop	{r7, pc}

0801a69a <USBD_GetNextDesc>:
  * @param  buf: Buffer where the descriptor is available
  * @param  ptr: data pointer inside the descriptor
  * @retval next header
  */
USBD_DescHeaderTypeDef *USBD_GetNextDesc(uint8_t *pbuf, uint16_t *ptr)
{
 801a69a:	b480      	push	{r7}
 801a69c:	b085      	sub	sp, #20
 801a69e:	af00      	add	r7, sp, #0
 801a6a0:	6078      	str	r0, [r7, #4]
 801a6a2:	6039      	str	r1, [r7, #0]
  USBD_DescHeaderTypeDef *pnext = (USBD_DescHeaderTypeDef *)(void *)pbuf;
 801a6a4:	687b      	ldr	r3, [r7, #4]
 801a6a6:	60fb      	str	r3, [r7, #12]

  *ptr += pnext->bLength;
 801a6a8:	683b      	ldr	r3, [r7, #0]
 801a6aa:	881b      	ldrh	r3, [r3, #0]
 801a6ac:	68fa      	ldr	r2, [r7, #12]
 801a6ae:	7812      	ldrb	r2, [r2, #0]
 801a6b0:	4413      	add	r3, r2
 801a6b2:	b29a      	uxth	r2, r3
 801a6b4:	683b      	ldr	r3, [r7, #0]
 801a6b6:	801a      	strh	r2, [r3, #0]
  pnext = (USBD_DescHeaderTypeDef *)(void *)(pbuf + pnext->bLength);
 801a6b8:	68fb      	ldr	r3, [r7, #12]
 801a6ba:	781b      	ldrb	r3, [r3, #0]
 801a6bc:	461a      	mov	r2, r3
 801a6be:	687b      	ldr	r3, [r7, #4]
 801a6c0:	4413      	add	r3, r2
 801a6c2:	60fb      	str	r3, [r7, #12]

  return (pnext);
 801a6c4:	68fb      	ldr	r3, [r7, #12]
}
 801a6c6:	4618      	mov	r0, r3
 801a6c8:	3714      	adds	r7, #20
 801a6ca:	46bd      	mov	sp, r7
 801a6cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a6d0:	4770      	bx	lr

0801a6d2 <SWAPBYTE>:

/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */
__STATIC_INLINE uint16_t SWAPBYTE(uint8_t *addr)
{
 801a6d2:	b480      	push	{r7}
 801a6d4:	b087      	sub	sp, #28
 801a6d6:	af00      	add	r7, sp, #0
 801a6d8:	6078      	str	r0, [r7, #4]
  uint16_t _SwapVal;
  uint16_t _Byte1;
  uint16_t _Byte2;
  uint8_t *_pbuff = addr;
 801a6da:	687b      	ldr	r3, [r7, #4]
 801a6dc:	617b      	str	r3, [r7, #20]

  _Byte1 = *(uint8_t *)_pbuff;
 801a6de:	697b      	ldr	r3, [r7, #20]
 801a6e0:	781b      	ldrb	r3, [r3, #0]
 801a6e2:	827b      	strh	r3, [r7, #18]
  _pbuff++;
 801a6e4:	697b      	ldr	r3, [r7, #20]
 801a6e6:	3301      	adds	r3, #1
 801a6e8:	617b      	str	r3, [r7, #20]
  _Byte2 = *(uint8_t *)_pbuff;
 801a6ea:	697b      	ldr	r3, [r7, #20]
 801a6ec:	781b      	ldrb	r3, [r3, #0]
 801a6ee:	823b      	strh	r3, [r7, #16]

  _SwapVal = (_Byte2 << 8) | _Byte1;
 801a6f0:	8a3b      	ldrh	r3, [r7, #16]
 801a6f2:	021b      	lsls	r3, r3, #8
 801a6f4:	b21a      	sxth	r2, r3
 801a6f6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a6fa:	4313      	orrs	r3, r2
 801a6fc:	b21b      	sxth	r3, r3
 801a6fe:	81fb      	strh	r3, [r7, #14]

  return _SwapVal;
 801a700:	89fb      	ldrh	r3, [r7, #14]
}
 801a702:	4618      	mov	r0, r3
 801a704:	371c      	adds	r7, #28
 801a706:	46bd      	mov	sp, r7
 801a708:	f85d 7b04 	ldr.w	r7, [sp], #4
 801a70c:	4770      	bx	lr
	...

0801a710 <USBD_StdDevReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdDevReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801a710:	b580      	push	{r7, lr}
 801a712:	b084      	sub	sp, #16
 801a714:	af00      	add	r7, sp, #0
 801a716:	6078      	str	r0, [r7, #4]
 801a718:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 801a71a:	2300      	movs	r3, #0
 801a71c:	73fb      	strb	r3, [r7, #15]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801a71e:	683b      	ldr	r3, [r7, #0]
 801a720:	781b      	ldrb	r3, [r3, #0]
 801a722:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 801a726:	2b40      	cmp	r3, #64	@ 0x40
 801a728:	d005      	beq.n	801a736 <USBD_StdDevReq+0x26>
 801a72a:	2b40      	cmp	r3, #64	@ 0x40
 801a72c:	d857      	bhi.n	801a7de <USBD_StdDevReq+0xce>
 801a72e:	2b00      	cmp	r3, #0
 801a730:	d00f      	beq.n	801a752 <USBD_StdDevReq+0x42>
 801a732:	2b20      	cmp	r3, #32
 801a734:	d153      	bne.n	801a7de <USBD_StdDevReq+0xce>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      ret = (USBD_StatusTypeDef)pdev->pClass[pdev->classId]->Setup(pdev, req);
 801a736:	687b      	ldr	r3, [r7, #4]
 801a738:	f8d3 22d4 	ldr.w	r2, [r3, #724]	@ 0x2d4
 801a73c:	687b      	ldr	r3, [r7, #4]
 801a73e:	32ae      	adds	r2, #174	@ 0xae
 801a740:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a744:	689b      	ldr	r3, [r3, #8]
 801a746:	6839      	ldr	r1, [r7, #0]
 801a748:	6878      	ldr	r0, [r7, #4]
 801a74a:	4798      	blx	r3
 801a74c:	4603      	mov	r3, r0
 801a74e:	73fb      	strb	r3, [r7, #15]
      break;
 801a750:	e04a      	b.n	801a7e8 <USBD_StdDevReq+0xd8>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 801a752:	683b      	ldr	r3, [r7, #0]
 801a754:	785b      	ldrb	r3, [r3, #1]
 801a756:	2b09      	cmp	r3, #9
 801a758:	d83b      	bhi.n	801a7d2 <USBD_StdDevReq+0xc2>
 801a75a:	a201      	add	r2, pc, #4	@ (adr r2, 801a760 <USBD_StdDevReq+0x50>)
 801a75c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a760:	0801a7b5 	.word	0x0801a7b5
 801a764:	0801a7c9 	.word	0x0801a7c9
 801a768:	0801a7d3 	.word	0x0801a7d3
 801a76c:	0801a7bf 	.word	0x0801a7bf
 801a770:	0801a7d3 	.word	0x0801a7d3
 801a774:	0801a793 	.word	0x0801a793
 801a778:	0801a789 	.word	0x0801a789
 801a77c:	0801a7d3 	.word	0x0801a7d3
 801a780:	0801a7ab 	.word	0x0801a7ab
 801a784:	0801a79d 	.word	0x0801a79d
      {
        case USB_REQ_GET_DESCRIPTOR:
          USBD_GetDescriptor(pdev, req);
 801a788:	6839      	ldr	r1, [r7, #0]
 801a78a:	6878      	ldr	r0, [r7, #4]
 801a78c:	f000 fa3c 	bl	801ac08 <USBD_GetDescriptor>
          break;
 801a790:	e024      	b.n	801a7dc <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_ADDRESS:
          USBD_SetAddress(pdev, req);
 801a792:	6839      	ldr	r1, [r7, #0]
 801a794:	6878      	ldr	r0, [r7, #4]
 801a796:	f000 fba1 	bl	801aedc <USBD_SetAddress>
          break;
 801a79a:	e01f      	b.n	801a7dc <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_CONFIGURATION:
          ret = USBD_SetConfig(pdev, req);
 801a79c:	6839      	ldr	r1, [r7, #0]
 801a79e:	6878      	ldr	r0, [r7, #4]
 801a7a0:	f000 fbe0 	bl	801af64 <USBD_SetConfig>
 801a7a4:	4603      	mov	r3, r0
 801a7a6:	73fb      	strb	r3, [r7, #15]
          break;
 801a7a8:	e018      	b.n	801a7dc <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_CONFIGURATION:
          USBD_GetConfig(pdev, req);
 801a7aa:	6839      	ldr	r1, [r7, #0]
 801a7ac:	6878      	ldr	r0, [r7, #4]
 801a7ae:	f000 fc83 	bl	801b0b8 <USBD_GetConfig>
          break;
 801a7b2:	e013      	b.n	801a7dc <USBD_StdDevReq+0xcc>

        case USB_REQ_GET_STATUS:
          USBD_GetStatus(pdev, req);
 801a7b4:	6839      	ldr	r1, [r7, #0]
 801a7b6:	6878      	ldr	r0, [r7, #4]
 801a7b8:	f000 fcb4 	bl	801b124 <USBD_GetStatus>
          break;
 801a7bc:	e00e      	b.n	801a7dc <USBD_StdDevReq+0xcc>

        case USB_REQ_SET_FEATURE:
          USBD_SetFeature(pdev, req);
 801a7be:	6839      	ldr	r1, [r7, #0]
 801a7c0:	6878      	ldr	r0, [r7, #4]
 801a7c2:	f000 fce3 	bl	801b18c <USBD_SetFeature>
          break;
 801a7c6:	e009      	b.n	801a7dc <USBD_StdDevReq+0xcc>

        case USB_REQ_CLEAR_FEATURE:
          USBD_ClrFeature(pdev, req);
 801a7c8:	6839      	ldr	r1, [r7, #0]
 801a7ca:	6878      	ldr	r0, [r7, #4]
 801a7cc:	f000 fd07 	bl	801b1de <USBD_ClrFeature>
          break;
 801a7d0:	e004      	b.n	801a7dc <USBD_StdDevReq+0xcc>

        default:
          USBD_CtlError(pdev, req);
 801a7d2:	6839      	ldr	r1, [r7, #0]
 801a7d4:	6878      	ldr	r0, [r7, #4]
 801a7d6:	f000 fd5e 	bl	801b296 <USBD_CtlError>
          break;
 801a7da:	bf00      	nop
      }
      break;
 801a7dc:	e004      	b.n	801a7e8 <USBD_StdDevReq+0xd8>

    default:
      USBD_CtlError(pdev, req);
 801a7de:	6839      	ldr	r1, [r7, #0]
 801a7e0:	6878      	ldr	r0, [r7, #4]
 801a7e2:	f000 fd58 	bl	801b296 <USBD_CtlError>
      break;
 801a7e6:	bf00      	nop
  }

  return ret;
 801a7e8:	7bfb      	ldrb	r3, [r7, #15]
}
 801a7ea:	4618      	mov	r0, r3
 801a7ec:	3710      	adds	r7, #16
 801a7ee:	46bd      	mov	sp, r7
 801a7f0:	bd80      	pop	{r7, pc}
 801a7f2:	bf00      	nop

0801a7f4 <USBD_StdItfReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdItfReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801a7f4:	b580      	push	{r7, lr}
 801a7f6:	b084      	sub	sp, #16
 801a7f8:	af00      	add	r7, sp, #0
 801a7fa:	6078      	str	r0, [r7, #4]
 801a7fc:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 801a7fe:	2300      	movs	r3, #0
 801a800:	73fb      	strb	r3, [r7, #15]
  uint8_t idx;

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801a802:	683b      	ldr	r3, [r7, #0]
 801a804:	781b      	ldrb	r3, [r3, #0]
 801a806:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 801a80a:	2b40      	cmp	r3, #64	@ 0x40
 801a80c:	d005      	beq.n	801a81a <USBD_StdItfReq+0x26>
 801a80e:	2b40      	cmp	r3, #64	@ 0x40
 801a810:	d852      	bhi.n	801a8b8 <USBD_StdItfReq+0xc4>
 801a812:	2b00      	cmp	r3, #0
 801a814:	d001      	beq.n	801a81a <USBD_StdItfReq+0x26>
 801a816:	2b20      	cmp	r3, #32
 801a818:	d14e      	bne.n	801a8b8 <USBD_StdItfReq+0xc4>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
    case USB_REQ_TYPE_STANDARD:
      switch (pdev->dev_state)
 801a81a:	687b      	ldr	r3, [r7, #4]
 801a81c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a820:	b2db      	uxtb	r3, r3
 801a822:	3b01      	subs	r3, #1
 801a824:	2b02      	cmp	r3, #2
 801a826:	d840      	bhi.n	801a8aa <USBD_StdItfReq+0xb6>
      {
        case USBD_STATE_DEFAULT:
        case USBD_STATE_ADDRESSED:
        case USBD_STATE_CONFIGURED:

          if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES)
 801a828:	683b      	ldr	r3, [r7, #0]
 801a82a:	889b      	ldrh	r3, [r3, #4]
 801a82c:	b2db      	uxtb	r3, r3
 801a82e:	2b01      	cmp	r3, #1
 801a830:	d836      	bhi.n	801a8a0 <USBD_StdItfReq+0xac>
          {
            /* Get the class index relative to this interface */
            idx = USBD_CoreFindIF(pdev, LOBYTE(req->wIndex));
 801a832:	683b      	ldr	r3, [r7, #0]
 801a834:	889b      	ldrh	r3, [r3, #4]
 801a836:	b2db      	uxtb	r3, r3
 801a838:	4619      	mov	r1, r3
 801a83a:	6878      	ldr	r0, [r7, #4]
 801a83c:	f7ff fedb 	bl	801a5f6 <USBD_CoreFindIF>
 801a840:	4603      	mov	r3, r0
 801a842:	73bb      	strb	r3, [r7, #14]
            if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801a844:	7bbb      	ldrb	r3, [r7, #14]
 801a846:	2bff      	cmp	r3, #255	@ 0xff
 801a848:	d01d      	beq.n	801a886 <USBD_StdItfReq+0x92>
 801a84a:	7bbb      	ldrb	r3, [r7, #14]
 801a84c:	2b00      	cmp	r3, #0
 801a84e:	d11a      	bne.n	801a886 <USBD_StdItfReq+0x92>
            {
              /* Call the class data out function to manage the request */
              if (pdev->pClass[idx]->Setup != NULL)
 801a850:	7bba      	ldrb	r2, [r7, #14]
 801a852:	687b      	ldr	r3, [r7, #4]
 801a854:	32ae      	adds	r2, #174	@ 0xae
 801a856:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a85a:	689b      	ldr	r3, [r3, #8]
 801a85c:	2b00      	cmp	r3, #0
 801a85e:	d00f      	beq.n	801a880 <USBD_StdItfReq+0x8c>
              {
                pdev->classId = idx;
 801a860:	7bba      	ldrb	r2, [r7, #14]
 801a862:	687b      	ldr	r3, [r7, #4]
 801a864:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 801a868:	7bba      	ldrb	r2, [r7, #14]
 801a86a:	687b      	ldr	r3, [r7, #4]
 801a86c:	32ae      	adds	r2, #174	@ 0xae
 801a86e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a872:	689b      	ldr	r3, [r3, #8]
 801a874:	6839      	ldr	r1, [r7, #0]
 801a876:	6878      	ldr	r0, [r7, #4]
 801a878:	4798      	blx	r3
 801a87a:	4603      	mov	r3, r0
 801a87c:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 801a87e:	e004      	b.n	801a88a <USBD_StdItfReq+0x96>
              }
              else
              {
                /* should never reach this condition */
                ret = USBD_FAIL;
 801a880:	2303      	movs	r3, #3
 801a882:	73fb      	strb	r3, [r7, #15]
              if (pdev->pClass[idx]->Setup != NULL)
 801a884:	e001      	b.n	801a88a <USBD_StdItfReq+0x96>
              }
            }
            else
            {
              /* No relative interface found */
              ret = USBD_FAIL;
 801a886:	2303      	movs	r3, #3
 801a888:	73fb      	strb	r3, [r7, #15]
            }

            if ((req->wLength == 0U) && (ret == USBD_OK))
 801a88a:	683b      	ldr	r3, [r7, #0]
 801a88c:	88db      	ldrh	r3, [r3, #6]
 801a88e:	2b00      	cmp	r3, #0
 801a890:	d110      	bne.n	801a8b4 <USBD_StdItfReq+0xc0>
 801a892:	7bfb      	ldrb	r3, [r7, #15]
 801a894:	2b00      	cmp	r3, #0
 801a896:	d10d      	bne.n	801a8b4 <USBD_StdItfReq+0xc0>
            {
              (void)USBD_CtlSendStatus(pdev);
 801a898:	6878      	ldr	r0, [r7, #4]
 801a89a:	f000 fdc7 	bl	801b42c <USBD_CtlSendStatus>
          }
          else
          {
            USBD_CtlError(pdev, req);
          }
          break;
 801a89e:	e009      	b.n	801a8b4 <USBD_StdItfReq+0xc0>
            USBD_CtlError(pdev, req);
 801a8a0:	6839      	ldr	r1, [r7, #0]
 801a8a2:	6878      	ldr	r0, [r7, #4]
 801a8a4:	f000 fcf7 	bl	801b296 <USBD_CtlError>
          break;
 801a8a8:	e004      	b.n	801a8b4 <USBD_StdItfReq+0xc0>

        default:
          USBD_CtlError(pdev, req);
 801a8aa:	6839      	ldr	r1, [r7, #0]
 801a8ac:	6878      	ldr	r0, [r7, #4]
 801a8ae:	f000 fcf2 	bl	801b296 <USBD_CtlError>
          break;
 801a8b2:	e000      	b.n	801a8b6 <USBD_StdItfReq+0xc2>
          break;
 801a8b4:	bf00      	nop
      }
      break;
 801a8b6:	e004      	b.n	801a8c2 <USBD_StdItfReq+0xce>

    default:
      USBD_CtlError(pdev, req);
 801a8b8:	6839      	ldr	r1, [r7, #0]
 801a8ba:	6878      	ldr	r0, [r7, #4]
 801a8bc:	f000 fceb 	bl	801b296 <USBD_CtlError>
      break;
 801a8c0:	bf00      	nop
  }

  return ret;
 801a8c2:	7bfb      	ldrb	r3, [r7, #15]
}
 801a8c4:	4618      	mov	r0, r3
 801a8c6:	3710      	adds	r7, #16
 801a8c8:	46bd      	mov	sp, r7
 801a8ca:	bd80      	pop	{r7, pc}

0801a8cc <USBD_StdEPReq>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
USBD_StatusTypeDef USBD_StdEPReq(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801a8cc:	b580      	push	{r7, lr}
 801a8ce:	b084      	sub	sp, #16
 801a8d0:	af00      	add	r7, sp, #0
 801a8d2:	6078      	str	r0, [r7, #4]
 801a8d4:	6039      	str	r1, [r7, #0]
  USBD_EndpointTypeDef *pep;
  uint8_t ep_addr;
  uint8_t idx;
  USBD_StatusTypeDef ret = USBD_OK;
 801a8d6:	2300      	movs	r3, #0
 801a8d8:	73fb      	strb	r3, [r7, #15]

  ep_addr = LOBYTE(req->wIndex);
 801a8da:	683b      	ldr	r3, [r7, #0]
 801a8dc:	889b      	ldrh	r3, [r3, #4]
 801a8de:	73bb      	strb	r3, [r7, #14]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 801a8e0:	683b      	ldr	r3, [r7, #0]
 801a8e2:	781b      	ldrb	r3, [r3, #0]
 801a8e4:	f003 0360 	and.w	r3, r3, #96	@ 0x60
 801a8e8:	2b40      	cmp	r3, #64	@ 0x40
 801a8ea:	d007      	beq.n	801a8fc <USBD_StdEPReq+0x30>
 801a8ec:	2b40      	cmp	r3, #64	@ 0x40
 801a8ee:	f200 817f 	bhi.w	801abf0 <USBD_StdEPReq+0x324>
 801a8f2:	2b00      	cmp	r3, #0
 801a8f4:	d02a      	beq.n	801a94c <USBD_StdEPReq+0x80>
 801a8f6:	2b20      	cmp	r3, #32
 801a8f8:	f040 817a 	bne.w	801abf0 <USBD_StdEPReq+0x324>
  {
    case USB_REQ_TYPE_CLASS:
    case USB_REQ_TYPE_VENDOR:
      /* Get the class index relative to this endpoint */
      idx = USBD_CoreFindEP(pdev, ep_addr);
 801a8fc:	7bbb      	ldrb	r3, [r7, #14]
 801a8fe:	4619      	mov	r1, r3
 801a900:	6878      	ldr	r0, [r7, #4]
 801a902:	f7ff fe85 	bl	801a610 <USBD_CoreFindEP>
 801a906:	4603      	mov	r3, r0
 801a908:	737b      	strb	r3, [r7, #13]
      if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801a90a:	7b7b      	ldrb	r3, [r7, #13]
 801a90c:	2bff      	cmp	r3, #255	@ 0xff
 801a90e:	f000 8174 	beq.w	801abfa <USBD_StdEPReq+0x32e>
 801a912:	7b7b      	ldrb	r3, [r7, #13]
 801a914:	2b00      	cmp	r3, #0
 801a916:	f040 8170 	bne.w	801abfa <USBD_StdEPReq+0x32e>
      {
        pdev->classId = idx;
 801a91a:	7b7a      	ldrb	r2, [r7, #13]
 801a91c:	687b      	ldr	r3, [r7, #4]
 801a91e:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
        /* Call the class data out function to manage the request */
        if (pdev->pClass[idx]->Setup != NULL)
 801a922:	7b7a      	ldrb	r2, [r7, #13]
 801a924:	687b      	ldr	r3, [r7, #4]
 801a926:	32ae      	adds	r2, #174	@ 0xae
 801a928:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a92c:	689b      	ldr	r3, [r3, #8]
 801a92e:	2b00      	cmp	r3, #0
 801a930:	f000 8163 	beq.w	801abfa <USBD_StdEPReq+0x32e>
        {
          ret = (USBD_StatusTypeDef)pdev->pClass[idx]->Setup(pdev, req);
 801a934:	7b7a      	ldrb	r2, [r7, #13]
 801a936:	687b      	ldr	r3, [r7, #4]
 801a938:	32ae      	adds	r2, #174	@ 0xae
 801a93a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a93e:	689b      	ldr	r3, [r3, #8]
 801a940:	6839      	ldr	r1, [r7, #0]
 801a942:	6878      	ldr	r0, [r7, #4]
 801a944:	4798      	blx	r3
 801a946:	4603      	mov	r3, r0
 801a948:	73fb      	strb	r3, [r7, #15]
        }
      }
      break;
 801a94a:	e156      	b.n	801abfa <USBD_StdEPReq+0x32e>

    case USB_REQ_TYPE_STANDARD:
      switch (req->bRequest)
 801a94c:	683b      	ldr	r3, [r7, #0]
 801a94e:	785b      	ldrb	r3, [r3, #1]
 801a950:	2b03      	cmp	r3, #3
 801a952:	d008      	beq.n	801a966 <USBD_StdEPReq+0x9a>
 801a954:	2b03      	cmp	r3, #3
 801a956:	f300 8145 	bgt.w	801abe4 <USBD_StdEPReq+0x318>
 801a95a:	2b00      	cmp	r3, #0
 801a95c:	f000 809b 	beq.w	801aa96 <USBD_StdEPReq+0x1ca>
 801a960:	2b01      	cmp	r3, #1
 801a962:	d03c      	beq.n	801a9de <USBD_StdEPReq+0x112>
 801a964:	e13e      	b.n	801abe4 <USBD_StdEPReq+0x318>
      {
        case USB_REQ_SET_FEATURE:
          switch (pdev->dev_state)
 801a966:	687b      	ldr	r3, [r7, #4]
 801a968:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a96c:	b2db      	uxtb	r3, r3
 801a96e:	2b02      	cmp	r3, #2
 801a970:	d002      	beq.n	801a978 <USBD_StdEPReq+0xac>
 801a972:	2b03      	cmp	r3, #3
 801a974:	d016      	beq.n	801a9a4 <USBD_StdEPReq+0xd8>
 801a976:	e02c      	b.n	801a9d2 <USBD_StdEPReq+0x106>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801a978:	7bbb      	ldrb	r3, [r7, #14]
 801a97a:	2b00      	cmp	r3, #0
 801a97c:	d00d      	beq.n	801a99a <USBD_StdEPReq+0xce>
 801a97e:	7bbb      	ldrb	r3, [r7, #14]
 801a980:	2b80      	cmp	r3, #128	@ 0x80
 801a982:	d00a      	beq.n	801a99a <USBD_StdEPReq+0xce>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 801a984:	7bbb      	ldrb	r3, [r7, #14]
 801a986:	4619      	mov	r1, r3
 801a988:	6878      	ldr	r0, [r7, #4]
 801a98a:	f001 f9d1 	bl	801bd30 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 801a98e:	2180      	movs	r1, #128	@ 0x80
 801a990:	6878      	ldr	r0, [r7, #4]
 801a992:	f001 f9cd 	bl	801bd30 <USBD_LL_StallEP>
 801a996:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 801a998:	e020      	b.n	801a9dc <USBD_StdEPReq+0x110>
                USBD_CtlError(pdev, req);
 801a99a:	6839      	ldr	r1, [r7, #0]
 801a99c:	6878      	ldr	r0, [r7, #4]
 801a99e:	f000 fc7a 	bl	801b296 <USBD_CtlError>
              break;
 801a9a2:	e01b      	b.n	801a9dc <USBD_StdEPReq+0x110>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 801a9a4:	683b      	ldr	r3, [r7, #0]
 801a9a6:	885b      	ldrh	r3, [r3, #2]
 801a9a8:	2b00      	cmp	r3, #0
 801a9aa:	d10e      	bne.n	801a9ca <USBD_StdEPReq+0xfe>
              {
                if ((ep_addr != 0x00U) && (ep_addr != 0x80U) && (req->wLength == 0x00U))
 801a9ac:	7bbb      	ldrb	r3, [r7, #14]
 801a9ae:	2b00      	cmp	r3, #0
 801a9b0:	d00b      	beq.n	801a9ca <USBD_StdEPReq+0xfe>
 801a9b2:	7bbb      	ldrb	r3, [r7, #14]
 801a9b4:	2b80      	cmp	r3, #128	@ 0x80
 801a9b6:	d008      	beq.n	801a9ca <USBD_StdEPReq+0xfe>
 801a9b8:	683b      	ldr	r3, [r7, #0]
 801a9ba:	88db      	ldrh	r3, [r3, #6]
 801a9bc:	2b00      	cmp	r3, #0
 801a9be:	d104      	bne.n	801a9ca <USBD_StdEPReq+0xfe>
                {
                  (void)USBD_LL_StallEP(pdev, ep_addr);
 801a9c0:	7bbb      	ldrb	r3, [r7, #14]
 801a9c2:	4619      	mov	r1, r3
 801a9c4:	6878      	ldr	r0, [r7, #4]
 801a9c6:	f001 f9b3 	bl	801bd30 <USBD_LL_StallEP>
                }
              }
              (void)USBD_CtlSendStatus(pdev);
 801a9ca:	6878      	ldr	r0, [r7, #4]
 801a9cc:	f000 fd2e 	bl	801b42c <USBD_CtlSendStatus>

              break;
 801a9d0:	e004      	b.n	801a9dc <USBD_StdEPReq+0x110>

            default:
              USBD_CtlError(pdev, req);
 801a9d2:	6839      	ldr	r1, [r7, #0]
 801a9d4:	6878      	ldr	r0, [r7, #4]
 801a9d6:	f000 fc5e 	bl	801b296 <USBD_CtlError>
              break;
 801a9da:	bf00      	nop
          }
          break;
 801a9dc:	e107      	b.n	801abee <USBD_StdEPReq+0x322>

        case USB_REQ_CLEAR_FEATURE:

          switch (pdev->dev_state)
 801a9de:	687b      	ldr	r3, [r7, #4]
 801a9e0:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801a9e4:	b2db      	uxtb	r3, r3
 801a9e6:	2b02      	cmp	r3, #2
 801a9e8:	d002      	beq.n	801a9f0 <USBD_StdEPReq+0x124>
 801a9ea:	2b03      	cmp	r3, #3
 801a9ec:	d016      	beq.n	801aa1c <USBD_StdEPReq+0x150>
 801a9ee:	e04b      	b.n	801aa88 <USBD_StdEPReq+0x1bc>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801a9f0:	7bbb      	ldrb	r3, [r7, #14]
 801a9f2:	2b00      	cmp	r3, #0
 801a9f4:	d00d      	beq.n	801aa12 <USBD_StdEPReq+0x146>
 801a9f6:	7bbb      	ldrb	r3, [r7, #14]
 801a9f8:	2b80      	cmp	r3, #128	@ 0x80
 801a9fa:	d00a      	beq.n	801aa12 <USBD_StdEPReq+0x146>
              {
                (void)USBD_LL_StallEP(pdev, ep_addr);
 801a9fc:	7bbb      	ldrb	r3, [r7, #14]
 801a9fe:	4619      	mov	r1, r3
 801aa00:	6878      	ldr	r0, [r7, #4]
 801aa02:	f001 f995 	bl	801bd30 <USBD_LL_StallEP>
                (void)USBD_LL_StallEP(pdev, 0x80U);
 801aa06:	2180      	movs	r1, #128	@ 0x80
 801aa08:	6878      	ldr	r0, [r7, #4]
 801aa0a:	f001 f991 	bl	801bd30 <USBD_LL_StallEP>
 801aa0e:	bf00      	nop
              }
              else
              {
                USBD_CtlError(pdev, req);
              }
              break;
 801aa10:	e040      	b.n	801aa94 <USBD_StdEPReq+0x1c8>
                USBD_CtlError(pdev, req);
 801aa12:	6839      	ldr	r1, [r7, #0]
 801aa14:	6878      	ldr	r0, [r7, #4]
 801aa16:	f000 fc3e 	bl	801b296 <USBD_CtlError>
              break;
 801aa1a:	e03b      	b.n	801aa94 <USBD_StdEPReq+0x1c8>

            case USBD_STATE_CONFIGURED:
              if (req->wValue == USB_FEATURE_EP_HALT)
 801aa1c:	683b      	ldr	r3, [r7, #0]
 801aa1e:	885b      	ldrh	r3, [r3, #2]
 801aa20:	2b00      	cmp	r3, #0
 801aa22:	d136      	bne.n	801aa92 <USBD_StdEPReq+0x1c6>
              {
                if ((ep_addr & 0x7FU) != 0x00U)
 801aa24:	7bbb      	ldrb	r3, [r7, #14]
 801aa26:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801aa2a:	2b00      	cmp	r3, #0
 801aa2c:	d004      	beq.n	801aa38 <USBD_StdEPReq+0x16c>
                {
                  (void)USBD_LL_ClearStallEP(pdev, ep_addr);
 801aa2e:	7bbb      	ldrb	r3, [r7, #14]
 801aa30:	4619      	mov	r1, r3
 801aa32:	6878      	ldr	r0, [r7, #4]
 801aa34:	f001 f99b 	bl	801bd6e <USBD_LL_ClearStallEP>
                }
                (void)USBD_CtlSendStatus(pdev);
 801aa38:	6878      	ldr	r0, [r7, #4]
 801aa3a:	f000 fcf7 	bl	801b42c <USBD_CtlSendStatus>

                /* Get the class index relative to this interface */
                idx = USBD_CoreFindEP(pdev, ep_addr);
 801aa3e:	7bbb      	ldrb	r3, [r7, #14]
 801aa40:	4619      	mov	r1, r3
 801aa42:	6878      	ldr	r0, [r7, #4]
 801aa44:	f7ff fde4 	bl	801a610 <USBD_CoreFindEP>
 801aa48:	4603      	mov	r3, r0
 801aa4a:	737b      	strb	r3, [r7, #13]
                if (((uint8_t)idx != 0xFFU) && (idx < USBD_MAX_SUPPORTED_CLASS))
 801aa4c:	7b7b      	ldrb	r3, [r7, #13]
 801aa4e:	2bff      	cmp	r3, #255	@ 0xff
 801aa50:	d01f      	beq.n	801aa92 <USBD_StdEPReq+0x1c6>
 801aa52:	7b7b      	ldrb	r3, [r7, #13]
 801aa54:	2b00      	cmp	r3, #0
 801aa56:	d11c      	bne.n	801aa92 <USBD_StdEPReq+0x1c6>
                {
                  pdev->classId = idx;
 801aa58:	7b7a      	ldrb	r2, [r7, #13]
 801aa5a:	687b      	ldr	r3, [r7, #4]
 801aa5c:	f8c3 22d4 	str.w	r2, [r3, #724]	@ 0x2d4
                  /* Call the class data out function to manage the request */
                  if (pdev->pClass[idx]->Setup != NULL)
 801aa60:	7b7a      	ldrb	r2, [r7, #13]
 801aa62:	687b      	ldr	r3, [r7, #4]
 801aa64:	32ae      	adds	r2, #174	@ 0xae
 801aa66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801aa6a:	689b      	ldr	r3, [r3, #8]
 801aa6c:	2b00      	cmp	r3, #0
 801aa6e:	d010      	beq.n	801aa92 <USBD_StdEPReq+0x1c6>
                  {
                    ret = (USBD_StatusTypeDef)(pdev->pClass[idx]->Setup(pdev, req));
 801aa70:	7b7a      	ldrb	r2, [r7, #13]
 801aa72:	687b      	ldr	r3, [r7, #4]
 801aa74:	32ae      	adds	r2, #174	@ 0xae
 801aa76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801aa7a:	689b      	ldr	r3, [r3, #8]
 801aa7c:	6839      	ldr	r1, [r7, #0]
 801aa7e:	6878      	ldr	r0, [r7, #4]
 801aa80:	4798      	blx	r3
 801aa82:	4603      	mov	r3, r0
 801aa84:	73fb      	strb	r3, [r7, #15]
                  }
                }
              }
              break;
 801aa86:	e004      	b.n	801aa92 <USBD_StdEPReq+0x1c6>

            default:
              USBD_CtlError(pdev, req);
 801aa88:	6839      	ldr	r1, [r7, #0]
 801aa8a:	6878      	ldr	r0, [r7, #4]
 801aa8c:	f000 fc03 	bl	801b296 <USBD_CtlError>
              break;
 801aa90:	e000      	b.n	801aa94 <USBD_StdEPReq+0x1c8>
              break;
 801aa92:	bf00      	nop
          }
          break;
 801aa94:	e0ab      	b.n	801abee <USBD_StdEPReq+0x322>

        case USB_REQ_GET_STATUS:
          switch (pdev->dev_state)
 801aa96:	687b      	ldr	r3, [r7, #4]
 801aa98:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801aa9c:	b2db      	uxtb	r3, r3
 801aa9e:	2b02      	cmp	r3, #2
 801aaa0:	d002      	beq.n	801aaa8 <USBD_StdEPReq+0x1dc>
 801aaa2:	2b03      	cmp	r3, #3
 801aaa4:	d032      	beq.n	801ab0c <USBD_StdEPReq+0x240>
 801aaa6:	e097      	b.n	801abd8 <USBD_StdEPReq+0x30c>
          {
            case USBD_STATE_ADDRESSED:
              if ((ep_addr != 0x00U) && (ep_addr != 0x80U))
 801aaa8:	7bbb      	ldrb	r3, [r7, #14]
 801aaaa:	2b00      	cmp	r3, #0
 801aaac:	d007      	beq.n	801aabe <USBD_StdEPReq+0x1f2>
 801aaae:	7bbb      	ldrb	r3, [r7, #14]
 801aab0:	2b80      	cmp	r3, #128	@ 0x80
 801aab2:	d004      	beq.n	801aabe <USBD_StdEPReq+0x1f2>
              {
                USBD_CtlError(pdev, req);
 801aab4:	6839      	ldr	r1, [r7, #0]
 801aab6:	6878      	ldr	r0, [r7, #4]
 801aab8:	f000 fbed 	bl	801b296 <USBD_CtlError>
                break;
 801aabc:	e091      	b.n	801abe2 <USBD_StdEPReq+0x316>
              }
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801aabe:	f997 300e 	ldrsb.w	r3, [r7, #14]
 801aac2:	2b00      	cmp	r3, #0
 801aac4:	da0b      	bge.n	801aade <USBD_StdEPReq+0x212>
 801aac6:	7bbb      	ldrb	r3, [r7, #14]
 801aac8:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 801aacc:	4613      	mov	r3, r2
 801aace:	009b      	lsls	r3, r3, #2
 801aad0:	4413      	add	r3, r2
 801aad2:	009b      	lsls	r3, r3, #2
 801aad4:	3310      	adds	r3, #16
 801aad6:	687a      	ldr	r2, [r7, #4]
 801aad8:	4413      	add	r3, r2
 801aada:	3304      	adds	r3, #4
 801aadc:	e00b      	b.n	801aaf6 <USBD_StdEPReq+0x22a>
                    &pdev->ep_out[ep_addr & 0x7FU];
 801aade:	7bbb      	ldrb	r3, [r7, #14]
 801aae0:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801aae4:	4613      	mov	r3, r2
 801aae6:	009b      	lsls	r3, r3, #2
 801aae8:	4413      	add	r3, r2
 801aaea:	009b      	lsls	r3, r3, #2
 801aaec:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 801aaf0:	687a      	ldr	r2, [r7, #4]
 801aaf2:	4413      	add	r3, r2
 801aaf4:	3304      	adds	r3, #4
 801aaf6:	60bb      	str	r3, [r7, #8]

              pep->status = 0x0000U;
 801aaf8:	68bb      	ldr	r3, [r7, #8]
 801aafa:	2200      	movs	r2, #0
 801aafc:	601a      	str	r2, [r3, #0]

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 801aafe:	68bb      	ldr	r3, [r7, #8]
 801ab00:	2202      	movs	r2, #2
 801ab02:	4619      	mov	r1, r3
 801ab04:	6878      	ldr	r0, [r7, #4]
 801ab06:	f000 fc37 	bl	801b378 <USBD_CtlSendData>
              break;
 801ab0a:	e06a      	b.n	801abe2 <USBD_StdEPReq+0x316>

            case USBD_STATE_CONFIGURED:
              if ((ep_addr & 0x80U) == 0x80U)
 801ab0c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 801ab10:	2b00      	cmp	r3, #0
 801ab12:	da11      	bge.n	801ab38 <USBD_StdEPReq+0x26c>
              {
                if (pdev->ep_in[ep_addr & 0xFU].is_used == 0U)
 801ab14:	7bbb      	ldrb	r3, [r7, #14]
 801ab16:	f003 020f 	and.w	r2, r3, #15
 801ab1a:	6879      	ldr	r1, [r7, #4]
 801ab1c:	4613      	mov	r3, r2
 801ab1e:	009b      	lsls	r3, r3, #2
 801ab20:	4413      	add	r3, r2
 801ab22:	009b      	lsls	r3, r3, #2
 801ab24:	440b      	add	r3, r1
 801ab26:	3324      	adds	r3, #36	@ 0x24
 801ab28:	881b      	ldrh	r3, [r3, #0]
 801ab2a:	2b00      	cmp	r3, #0
 801ab2c:	d117      	bne.n	801ab5e <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 801ab2e:	6839      	ldr	r1, [r7, #0]
 801ab30:	6878      	ldr	r0, [r7, #4]
 801ab32:	f000 fbb0 	bl	801b296 <USBD_CtlError>
                  break;
 801ab36:	e054      	b.n	801abe2 <USBD_StdEPReq+0x316>
                }
              }
              else
              {
                if (pdev->ep_out[ep_addr & 0xFU].is_used == 0U)
 801ab38:	7bbb      	ldrb	r3, [r7, #14]
 801ab3a:	f003 020f 	and.w	r2, r3, #15
 801ab3e:	6879      	ldr	r1, [r7, #4]
 801ab40:	4613      	mov	r3, r2
 801ab42:	009b      	lsls	r3, r3, #2
 801ab44:	4413      	add	r3, r2
 801ab46:	009b      	lsls	r3, r3, #2
 801ab48:	440b      	add	r3, r1
 801ab4a:	f503 73b2 	add.w	r3, r3, #356	@ 0x164
 801ab4e:	881b      	ldrh	r3, [r3, #0]
 801ab50:	2b00      	cmp	r3, #0
 801ab52:	d104      	bne.n	801ab5e <USBD_StdEPReq+0x292>
                {
                  USBD_CtlError(pdev, req);
 801ab54:	6839      	ldr	r1, [r7, #0]
 801ab56:	6878      	ldr	r0, [r7, #4]
 801ab58:	f000 fb9d 	bl	801b296 <USBD_CtlError>
                  break;
 801ab5c:	e041      	b.n	801abe2 <USBD_StdEPReq+0x316>
                }
              }

              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801ab5e:	f997 300e 	ldrsb.w	r3, [r7, #14]
 801ab62:	2b00      	cmp	r3, #0
 801ab64:	da0b      	bge.n	801ab7e <USBD_StdEPReq+0x2b2>
 801ab66:	7bbb      	ldrb	r3, [r7, #14]
 801ab68:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 801ab6c:	4613      	mov	r3, r2
 801ab6e:	009b      	lsls	r3, r3, #2
 801ab70:	4413      	add	r3, r2
 801ab72:	009b      	lsls	r3, r3, #2
 801ab74:	3310      	adds	r3, #16
 801ab76:	687a      	ldr	r2, [r7, #4]
 801ab78:	4413      	add	r3, r2
 801ab7a:	3304      	adds	r3, #4
 801ab7c:	e00b      	b.n	801ab96 <USBD_StdEPReq+0x2ca>
                    &pdev->ep_out[ep_addr & 0x7FU];
 801ab7e:	7bbb      	ldrb	r3, [r7, #14]
 801ab80:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
              pep = ((ep_addr & 0x80U) == 0x80U) ? &pdev->ep_in[ep_addr & 0x7FU] : \
 801ab84:	4613      	mov	r3, r2
 801ab86:	009b      	lsls	r3, r3, #2
 801ab88:	4413      	add	r3, r2
 801ab8a:	009b      	lsls	r3, r3, #2
 801ab8c:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
 801ab90:	687a      	ldr	r2, [r7, #4]
 801ab92:	4413      	add	r3, r2
 801ab94:	3304      	adds	r3, #4
 801ab96:	60bb      	str	r3, [r7, #8]

              if ((ep_addr == 0x00U) || (ep_addr == 0x80U))
 801ab98:	7bbb      	ldrb	r3, [r7, #14]
 801ab9a:	2b00      	cmp	r3, #0
 801ab9c:	d002      	beq.n	801aba4 <USBD_StdEPReq+0x2d8>
 801ab9e:	7bbb      	ldrb	r3, [r7, #14]
 801aba0:	2b80      	cmp	r3, #128	@ 0x80
 801aba2:	d103      	bne.n	801abac <USBD_StdEPReq+0x2e0>
              {
                pep->status = 0x0000U;
 801aba4:	68bb      	ldr	r3, [r7, #8]
 801aba6:	2200      	movs	r2, #0
 801aba8:	601a      	str	r2, [r3, #0]
 801abaa:	e00e      	b.n	801abca <USBD_StdEPReq+0x2fe>
              }
              else if (USBD_LL_IsStallEP(pdev, ep_addr) != 0U)
 801abac:	7bbb      	ldrb	r3, [r7, #14]
 801abae:	4619      	mov	r1, r3
 801abb0:	6878      	ldr	r0, [r7, #4]
 801abb2:	f001 f8fb 	bl	801bdac <USBD_LL_IsStallEP>
 801abb6:	4603      	mov	r3, r0
 801abb8:	2b00      	cmp	r3, #0
 801abba:	d003      	beq.n	801abc4 <USBD_StdEPReq+0x2f8>
              {
                pep->status = 0x0001U;
 801abbc:	68bb      	ldr	r3, [r7, #8]
 801abbe:	2201      	movs	r2, #1
 801abc0:	601a      	str	r2, [r3, #0]
 801abc2:	e002      	b.n	801abca <USBD_StdEPReq+0x2fe>
              }
              else
              {
                pep->status = 0x0000U;
 801abc4:	68bb      	ldr	r3, [r7, #8]
 801abc6:	2200      	movs	r2, #0
 801abc8:	601a      	str	r2, [r3, #0]
              }

              (void)USBD_CtlSendData(pdev, (uint8_t *)&pep->status, 2U);
 801abca:	68bb      	ldr	r3, [r7, #8]
 801abcc:	2202      	movs	r2, #2
 801abce:	4619      	mov	r1, r3
 801abd0:	6878      	ldr	r0, [r7, #4]
 801abd2:	f000 fbd1 	bl	801b378 <USBD_CtlSendData>
              break;
 801abd6:	e004      	b.n	801abe2 <USBD_StdEPReq+0x316>

            default:
              USBD_CtlError(pdev, req);
 801abd8:	6839      	ldr	r1, [r7, #0]
 801abda:	6878      	ldr	r0, [r7, #4]
 801abdc:	f000 fb5b 	bl	801b296 <USBD_CtlError>
              break;
 801abe0:	bf00      	nop
          }
          break;
 801abe2:	e004      	b.n	801abee <USBD_StdEPReq+0x322>

        default:
          USBD_CtlError(pdev, req);
 801abe4:	6839      	ldr	r1, [r7, #0]
 801abe6:	6878      	ldr	r0, [r7, #4]
 801abe8:	f000 fb55 	bl	801b296 <USBD_CtlError>
          break;
 801abec:	bf00      	nop
      }
      break;
 801abee:	e005      	b.n	801abfc <USBD_StdEPReq+0x330>

    default:
      USBD_CtlError(pdev, req);
 801abf0:	6839      	ldr	r1, [r7, #0]
 801abf2:	6878      	ldr	r0, [r7, #4]
 801abf4:	f000 fb4f 	bl	801b296 <USBD_CtlError>
      break;
 801abf8:	e000      	b.n	801abfc <USBD_StdEPReq+0x330>
      break;
 801abfa:	bf00      	nop
  }

  return ret;
 801abfc:	7bfb      	ldrb	r3, [r7, #15]
}
 801abfe:	4618      	mov	r0, r3
 801ac00:	3710      	adds	r7, #16
 801ac02:	46bd      	mov	sp, r7
 801ac04:	bd80      	pop	{r7, pc}
	...

0801ac08 <USBD_GetDescriptor>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801ac08:	b580      	push	{r7, lr}
 801ac0a:	b084      	sub	sp, #16
 801ac0c:	af00      	add	r7, sp, #0
 801ac0e:	6078      	str	r0, [r7, #4]
 801ac10:	6039      	str	r1, [r7, #0]
  uint16_t len = 0U;
 801ac12:	2300      	movs	r3, #0
 801ac14:	813b      	strh	r3, [r7, #8]
  uint8_t *pbuf = NULL;
 801ac16:	2300      	movs	r3, #0
 801ac18:	60fb      	str	r3, [r7, #12]
  uint8_t err = 0U;
 801ac1a:	2300      	movs	r3, #0
 801ac1c:	72fb      	strb	r3, [r7, #11]

  switch (req->wValue >> 8)
 801ac1e:	683b      	ldr	r3, [r7, #0]
 801ac20:	885b      	ldrh	r3, [r3, #2]
 801ac22:	0a1b      	lsrs	r3, r3, #8
 801ac24:	b29b      	uxth	r3, r3
 801ac26:	3b01      	subs	r3, #1
 801ac28:	2b06      	cmp	r3, #6
 801ac2a:	f200 8128 	bhi.w	801ae7e <USBD_GetDescriptor+0x276>
 801ac2e:	a201      	add	r2, pc, #4	@ (adr r2, 801ac34 <USBD_GetDescriptor+0x2c>)
 801ac30:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801ac34:	0801ac51 	.word	0x0801ac51
 801ac38:	0801ac69 	.word	0x0801ac69
 801ac3c:	0801aca9 	.word	0x0801aca9
 801ac40:	0801ae7f 	.word	0x0801ae7f
 801ac44:	0801ae7f 	.word	0x0801ae7f
 801ac48:	0801ae1f 	.word	0x0801ae1f
 801ac4c:	0801ae4b 	.word	0x0801ae4b
        err++;
      }
      break;
#endif /* (USBD_LPM_ENABLED == 1U) || (USBD_CLASS_BOS_ENABLED == 1U) */
    case USB_DESC_TYPE_DEVICE:
      pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 801ac50:	687b      	ldr	r3, [r7, #4]
 801ac52:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ac56:	681b      	ldr	r3, [r3, #0]
 801ac58:	687a      	ldr	r2, [r7, #4]
 801ac5a:	7c12      	ldrb	r2, [r2, #16]
 801ac5c:	f107 0108 	add.w	r1, r7, #8
 801ac60:	4610      	mov	r0, r2
 801ac62:	4798      	blx	r3
 801ac64:	60f8      	str	r0, [r7, #12]
      break;
 801ac66:	e112      	b.n	801ae8e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 801ac68:	687b      	ldr	r3, [r7, #4]
 801ac6a:	7c1b      	ldrb	r3, [r3, #16]
 801ac6c:	2b00      	cmp	r3, #0
 801ac6e:	d10d      	bne.n	801ac8c <USBD_GetDescriptor+0x84>
          pbuf = (uint8_t *)USBD_CMPSIT.GetHSConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetHSConfigDescriptor(&len);
 801ac70:	687b      	ldr	r3, [r7, #4]
 801ac72:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801ac76:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801ac78:	f107 0208 	add.w	r2, r7, #8
 801ac7c:	4610      	mov	r0, r2
 801ac7e:	4798      	blx	r3
 801ac80:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801ac82:	68fb      	ldr	r3, [r7, #12]
 801ac84:	3301      	adds	r3, #1
 801ac86:	2202      	movs	r2, #2
 801ac88:	701a      	strb	r2, [r3, #0]
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
        }
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
      }
      break;
 801ac8a:	e100      	b.n	801ae8e <USBD_GetDescriptor+0x286>
          pbuf = (uint8_t *)pdev->pClass[0]->GetFSConfigDescriptor(&len);
 801ac8c:	687b      	ldr	r3, [r7, #4]
 801ac8e:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801ac92:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801ac94:	f107 0208 	add.w	r2, r7, #8
 801ac98:	4610      	mov	r0, r2
 801ac9a:	4798      	blx	r3
 801ac9c:	60f8      	str	r0, [r7, #12]
        pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 801ac9e:	68fb      	ldr	r3, [r7, #12]
 801aca0:	3301      	adds	r3, #1
 801aca2:	2202      	movs	r2, #2
 801aca4:	701a      	strb	r2, [r3, #0]
      break;
 801aca6:	e0f2      	b.n	801ae8e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_STRING:
      switch ((uint8_t)(req->wValue))
 801aca8:	683b      	ldr	r3, [r7, #0]
 801acaa:	885b      	ldrh	r3, [r3, #2]
 801acac:	b2db      	uxtb	r3, r3
 801acae:	2b05      	cmp	r3, #5
 801acb0:	f200 80ac 	bhi.w	801ae0c <USBD_GetDescriptor+0x204>
 801acb4:	a201      	add	r2, pc, #4	@ (adr r2, 801acbc <USBD_GetDescriptor+0xb4>)
 801acb6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801acba:	bf00      	nop
 801acbc:	0801acd5 	.word	0x0801acd5
 801acc0:	0801ad09 	.word	0x0801ad09
 801acc4:	0801ad3d 	.word	0x0801ad3d
 801acc8:	0801ad71 	.word	0x0801ad71
 801accc:	0801ada5 	.word	0x0801ada5
 801acd0:	0801add9 	.word	0x0801add9
      {
        case USBD_IDX_LANGID_STR:
          if (pdev->pDesc->GetLangIDStrDescriptor != NULL)
 801acd4:	687b      	ldr	r3, [r7, #4]
 801acd6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801acda:	685b      	ldr	r3, [r3, #4]
 801acdc:	2b00      	cmp	r3, #0
 801acde:	d00b      	beq.n	801acf8 <USBD_GetDescriptor+0xf0>
          {
            pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);
 801ace0:	687b      	ldr	r3, [r7, #4]
 801ace2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ace6:	685b      	ldr	r3, [r3, #4]
 801ace8:	687a      	ldr	r2, [r7, #4]
 801acea:	7c12      	ldrb	r2, [r2, #16]
 801acec:	f107 0108 	add.w	r1, r7, #8
 801acf0:	4610      	mov	r0, r2
 801acf2:	4798      	blx	r3
 801acf4:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801acf6:	e091      	b.n	801ae1c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 801acf8:	6839      	ldr	r1, [r7, #0]
 801acfa:	6878      	ldr	r0, [r7, #4]
 801acfc:	f000 facb 	bl	801b296 <USBD_CtlError>
            err++;
 801ad00:	7afb      	ldrb	r3, [r7, #11]
 801ad02:	3301      	adds	r3, #1
 801ad04:	72fb      	strb	r3, [r7, #11]
          break;
 801ad06:	e089      	b.n	801ae1c <USBD_GetDescriptor+0x214>

        case USBD_IDX_MFC_STR:
          if (pdev->pDesc->GetManufacturerStrDescriptor != NULL)
 801ad08:	687b      	ldr	r3, [r7, #4]
 801ad0a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ad0e:	689b      	ldr	r3, [r3, #8]
 801ad10:	2b00      	cmp	r3, #0
 801ad12:	d00b      	beq.n	801ad2c <USBD_GetDescriptor+0x124>
          {
            pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 801ad14:	687b      	ldr	r3, [r7, #4]
 801ad16:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ad1a:	689b      	ldr	r3, [r3, #8]
 801ad1c:	687a      	ldr	r2, [r7, #4]
 801ad1e:	7c12      	ldrb	r2, [r2, #16]
 801ad20:	f107 0108 	add.w	r1, r7, #8
 801ad24:	4610      	mov	r0, r2
 801ad26:	4798      	blx	r3
 801ad28:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801ad2a:	e077      	b.n	801ae1c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 801ad2c:	6839      	ldr	r1, [r7, #0]
 801ad2e:	6878      	ldr	r0, [r7, #4]
 801ad30:	f000 fab1 	bl	801b296 <USBD_CtlError>
            err++;
 801ad34:	7afb      	ldrb	r3, [r7, #11]
 801ad36:	3301      	adds	r3, #1
 801ad38:	72fb      	strb	r3, [r7, #11]
          break;
 801ad3a:	e06f      	b.n	801ae1c <USBD_GetDescriptor+0x214>

        case USBD_IDX_PRODUCT_STR:
          if (pdev->pDesc->GetProductStrDescriptor != NULL)
 801ad3c:	687b      	ldr	r3, [r7, #4]
 801ad3e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ad42:	68db      	ldr	r3, [r3, #12]
 801ad44:	2b00      	cmp	r3, #0
 801ad46:	d00b      	beq.n	801ad60 <USBD_GetDescriptor+0x158>
          {
            pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 801ad48:	687b      	ldr	r3, [r7, #4]
 801ad4a:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ad4e:	68db      	ldr	r3, [r3, #12]
 801ad50:	687a      	ldr	r2, [r7, #4]
 801ad52:	7c12      	ldrb	r2, [r2, #16]
 801ad54:	f107 0108 	add.w	r1, r7, #8
 801ad58:	4610      	mov	r0, r2
 801ad5a:	4798      	blx	r3
 801ad5c:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801ad5e:	e05d      	b.n	801ae1c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 801ad60:	6839      	ldr	r1, [r7, #0]
 801ad62:	6878      	ldr	r0, [r7, #4]
 801ad64:	f000 fa97 	bl	801b296 <USBD_CtlError>
            err++;
 801ad68:	7afb      	ldrb	r3, [r7, #11]
 801ad6a:	3301      	adds	r3, #1
 801ad6c:	72fb      	strb	r3, [r7, #11]
          break;
 801ad6e:	e055      	b.n	801ae1c <USBD_GetDescriptor+0x214>

        case USBD_IDX_SERIAL_STR:
          if (pdev->pDesc->GetSerialStrDescriptor != NULL)
 801ad70:	687b      	ldr	r3, [r7, #4]
 801ad72:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ad76:	691b      	ldr	r3, [r3, #16]
 801ad78:	2b00      	cmp	r3, #0
 801ad7a:	d00b      	beq.n	801ad94 <USBD_GetDescriptor+0x18c>
          {
            pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 801ad7c:	687b      	ldr	r3, [r7, #4]
 801ad7e:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801ad82:	691b      	ldr	r3, [r3, #16]
 801ad84:	687a      	ldr	r2, [r7, #4]
 801ad86:	7c12      	ldrb	r2, [r2, #16]
 801ad88:	f107 0108 	add.w	r1, r7, #8
 801ad8c:	4610      	mov	r0, r2
 801ad8e:	4798      	blx	r3
 801ad90:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801ad92:	e043      	b.n	801ae1c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 801ad94:	6839      	ldr	r1, [r7, #0]
 801ad96:	6878      	ldr	r0, [r7, #4]
 801ad98:	f000 fa7d 	bl	801b296 <USBD_CtlError>
            err++;
 801ad9c:	7afb      	ldrb	r3, [r7, #11]
 801ad9e:	3301      	adds	r3, #1
 801ada0:	72fb      	strb	r3, [r7, #11]
          break;
 801ada2:	e03b      	b.n	801ae1c <USBD_GetDescriptor+0x214>

        case USBD_IDX_CONFIG_STR:
          if (pdev->pDesc->GetConfigurationStrDescriptor != NULL)
 801ada4:	687b      	ldr	r3, [r7, #4]
 801ada6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801adaa:	695b      	ldr	r3, [r3, #20]
 801adac:	2b00      	cmp	r3, #0
 801adae:	d00b      	beq.n	801adc8 <USBD_GetDescriptor+0x1c0>
          {
            pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 801adb0:	687b      	ldr	r3, [r7, #4]
 801adb2:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801adb6:	695b      	ldr	r3, [r3, #20]
 801adb8:	687a      	ldr	r2, [r7, #4]
 801adba:	7c12      	ldrb	r2, [r2, #16]
 801adbc:	f107 0108 	add.w	r1, r7, #8
 801adc0:	4610      	mov	r0, r2
 801adc2:	4798      	blx	r3
 801adc4:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801adc6:	e029      	b.n	801ae1c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 801adc8:	6839      	ldr	r1, [r7, #0]
 801adca:	6878      	ldr	r0, [r7, #4]
 801adcc:	f000 fa63 	bl	801b296 <USBD_CtlError>
            err++;
 801add0:	7afb      	ldrb	r3, [r7, #11]
 801add2:	3301      	adds	r3, #1
 801add4:	72fb      	strb	r3, [r7, #11]
          break;
 801add6:	e021      	b.n	801ae1c <USBD_GetDescriptor+0x214>

        case USBD_IDX_INTERFACE_STR:
          if (pdev->pDesc->GetInterfaceStrDescriptor != NULL)
 801add8:	687b      	ldr	r3, [r7, #4]
 801adda:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801adde:	699b      	ldr	r3, [r3, #24]
 801ade0:	2b00      	cmp	r3, #0
 801ade2:	d00b      	beq.n	801adfc <USBD_GetDescriptor+0x1f4>
          {
            pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 801ade4:	687b      	ldr	r3, [r7, #4]
 801ade6:	f8d3 32b4 	ldr.w	r3, [r3, #692]	@ 0x2b4
 801adea:	699b      	ldr	r3, [r3, #24]
 801adec:	687a      	ldr	r2, [r7, #4]
 801adee:	7c12      	ldrb	r2, [r2, #16]
 801adf0:	f107 0108 	add.w	r1, r7, #8
 801adf4:	4610      	mov	r0, r2
 801adf6:	4798      	blx	r3
 801adf8:	60f8      	str	r0, [r7, #12]
          else
          {
            USBD_CtlError(pdev, req);
            err++;
          }
          break;
 801adfa:	e00f      	b.n	801ae1c <USBD_GetDescriptor+0x214>
            USBD_CtlError(pdev, req);
 801adfc:	6839      	ldr	r1, [r7, #0]
 801adfe:	6878      	ldr	r0, [r7, #4]
 801ae00:	f000 fa49 	bl	801b296 <USBD_CtlError>
            err++;
 801ae04:	7afb      	ldrb	r3, [r7, #11]
 801ae06:	3301      	adds	r3, #1
 801ae08:	72fb      	strb	r3, [r7, #11]
          break;
 801ae0a:	e007      	b.n	801ae1c <USBD_GetDescriptor+0x214>
            err++;
          }
#endif /* USBD_SUPPORT_USER_STRING_DESC  */

#if ((USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U))
          USBD_CtlError(pdev, req);
 801ae0c:	6839      	ldr	r1, [r7, #0]
 801ae0e:	6878      	ldr	r0, [r7, #4]
 801ae10:	f000 fa41 	bl	801b296 <USBD_CtlError>
          err++;
 801ae14:	7afb      	ldrb	r3, [r7, #11]
 801ae16:	3301      	adds	r3, #1
 801ae18:	72fb      	strb	r3, [r7, #11]
#endif /* (USBD_CLASS_USER_STRING_DESC == 0U) && (USBD_SUPPORT_USER_STRING_DESC == 0U) */
          break;
 801ae1a:	bf00      	nop
      }
      break;
 801ae1c:	e037      	b.n	801ae8e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_DEVICE_QUALIFIER:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 801ae1e:	687b      	ldr	r3, [r7, #4]
 801ae20:	7c1b      	ldrb	r3, [r3, #16]
 801ae22:	2b00      	cmp	r3, #0
 801ae24:	d109      	bne.n	801ae3a <USBD_GetDescriptor+0x232>
          pbuf = (uint8_t *)USBD_CMPSIT.GetDeviceQualifierDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetDeviceQualifierDescriptor(&len);
 801ae26:	687b      	ldr	r3, [r7, #4]
 801ae28:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801ae2c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801ae2e:	f107 0208 	add.w	r2, r7, #8
 801ae32:	4610      	mov	r0, r2
 801ae34:	4798      	blx	r3
 801ae36:	60f8      	str	r0, [r7, #12]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 801ae38:	e029      	b.n	801ae8e <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 801ae3a:	6839      	ldr	r1, [r7, #0]
 801ae3c:	6878      	ldr	r0, [r7, #4]
 801ae3e:	f000 fa2a 	bl	801b296 <USBD_CtlError>
        err++;
 801ae42:	7afb      	ldrb	r3, [r7, #11]
 801ae44:	3301      	adds	r3, #1
 801ae46:	72fb      	strb	r3, [r7, #11]
      break;
 801ae48:	e021      	b.n	801ae8e <USBD_GetDescriptor+0x286>

    case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
      if (pdev->dev_speed == USBD_SPEED_HIGH)
 801ae4a:	687b      	ldr	r3, [r7, #4]
 801ae4c:	7c1b      	ldrb	r3, [r3, #16]
 801ae4e:	2b00      	cmp	r3, #0
 801ae50:	d10d      	bne.n	801ae6e <USBD_GetDescriptor+0x266>
          pbuf = (uint8_t *)USBD_CMPSIT.GetOtherSpeedConfigDescriptor(&len);
        }
        else
#endif /* USE_USBD_COMPOSITE */
        {
          pbuf = (uint8_t *)pdev->pClass[0]->GetOtherSpeedConfigDescriptor(&len);
 801ae52:	687b      	ldr	r3, [r7, #4]
 801ae54:	f8d3 32b8 	ldr.w	r3, [r3, #696]	@ 0x2b8
 801ae58:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801ae5a:	f107 0208 	add.w	r2, r7, #8
 801ae5e:	4610      	mov	r0, r2
 801ae60:	4798      	blx	r3
 801ae62:	60f8      	str	r0, [r7, #12]
        }
        pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 801ae64:	68fb      	ldr	r3, [r7, #12]
 801ae66:	3301      	adds	r3, #1
 801ae68:	2207      	movs	r2, #7
 801ae6a:	701a      	strb	r2, [r3, #0]
      else
      {
        USBD_CtlError(pdev, req);
        err++;
      }
      break;
 801ae6c:	e00f      	b.n	801ae8e <USBD_GetDescriptor+0x286>
        USBD_CtlError(pdev, req);
 801ae6e:	6839      	ldr	r1, [r7, #0]
 801ae70:	6878      	ldr	r0, [r7, #4]
 801ae72:	f000 fa10 	bl	801b296 <USBD_CtlError>
        err++;
 801ae76:	7afb      	ldrb	r3, [r7, #11]
 801ae78:	3301      	adds	r3, #1
 801ae7a:	72fb      	strb	r3, [r7, #11]
      break;
 801ae7c:	e007      	b.n	801ae8e <USBD_GetDescriptor+0x286>

    default:
      USBD_CtlError(pdev, req);
 801ae7e:	6839      	ldr	r1, [r7, #0]
 801ae80:	6878      	ldr	r0, [r7, #4]
 801ae82:	f000 fa08 	bl	801b296 <USBD_CtlError>
      err++;
 801ae86:	7afb      	ldrb	r3, [r7, #11]
 801ae88:	3301      	adds	r3, #1
 801ae8a:	72fb      	strb	r3, [r7, #11]
      break;
 801ae8c:	bf00      	nop
  }

  if (err != 0U)
 801ae8e:	7afb      	ldrb	r3, [r7, #11]
 801ae90:	2b00      	cmp	r3, #0
 801ae92:	d11e      	bne.n	801aed2 <USBD_GetDescriptor+0x2ca>
  {
    return;
  }

  if (req->wLength != 0U)
 801ae94:	683b      	ldr	r3, [r7, #0]
 801ae96:	88db      	ldrh	r3, [r3, #6]
 801ae98:	2b00      	cmp	r3, #0
 801ae9a:	d016      	beq.n	801aeca <USBD_GetDescriptor+0x2c2>
  {
    if (len != 0U)
 801ae9c:	893b      	ldrh	r3, [r7, #8]
 801ae9e:	2b00      	cmp	r3, #0
 801aea0:	d00e      	beq.n	801aec0 <USBD_GetDescriptor+0x2b8>
    {
      len = MIN(len, req->wLength);
 801aea2:	683b      	ldr	r3, [r7, #0]
 801aea4:	88da      	ldrh	r2, [r3, #6]
 801aea6:	893b      	ldrh	r3, [r7, #8]
 801aea8:	4293      	cmp	r3, r2
 801aeaa:	bf28      	it	cs
 801aeac:	4613      	movcs	r3, r2
 801aeae:	b29b      	uxth	r3, r3
 801aeb0:	813b      	strh	r3, [r7, #8]
      (void)USBD_CtlSendData(pdev, pbuf, len);
 801aeb2:	893b      	ldrh	r3, [r7, #8]
 801aeb4:	461a      	mov	r2, r3
 801aeb6:	68f9      	ldr	r1, [r7, #12]
 801aeb8:	6878      	ldr	r0, [r7, #4]
 801aeba:	f000 fa5d 	bl	801b378 <USBD_CtlSendData>
 801aebe:	e009      	b.n	801aed4 <USBD_GetDescriptor+0x2cc>
    }
    else
    {
      USBD_CtlError(pdev, req);
 801aec0:	6839      	ldr	r1, [r7, #0]
 801aec2:	6878      	ldr	r0, [r7, #4]
 801aec4:	f000 f9e7 	bl	801b296 <USBD_CtlError>
 801aec8:	e004      	b.n	801aed4 <USBD_GetDescriptor+0x2cc>
    }
  }
  else
  {
    (void)USBD_CtlSendStatus(pdev);
 801aeca:	6878      	ldr	r0, [r7, #4]
 801aecc:	f000 faae 	bl	801b42c <USBD_CtlSendStatus>
 801aed0:	e000      	b.n	801aed4 <USBD_GetDescriptor+0x2cc>
    return;
 801aed2:	bf00      	nop
  }
}
 801aed4:	3710      	adds	r7, #16
 801aed6:	46bd      	mov	sp, r7
 801aed8:	bd80      	pop	{r7, pc}
 801aeda:	bf00      	nop

0801aedc <USBD_SetAddress>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_SetAddress(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801aedc:	b580      	push	{r7, lr}
 801aede:	b084      	sub	sp, #16
 801aee0:	af00      	add	r7, sp, #0
 801aee2:	6078      	str	r0, [r7, #4]
 801aee4:	6039      	str	r1, [r7, #0]
  uint8_t  dev_addr;

  if ((req->wIndex == 0U) && (req->wLength == 0U) && (req->wValue < 128U))
 801aee6:	683b      	ldr	r3, [r7, #0]
 801aee8:	889b      	ldrh	r3, [r3, #4]
 801aeea:	2b00      	cmp	r3, #0
 801aeec:	d131      	bne.n	801af52 <USBD_SetAddress+0x76>
 801aeee:	683b      	ldr	r3, [r7, #0]
 801aef0:	88db      	ldrh	r3, [r3, #6]
 801aef2:	2b00      	cmp	r3, #0
 801aef4:	d12d      	bne.n	801af52 <USBD_SetAddress+0x76>
 801aef6:	683b      	ldr	r3, [r7, #0]
 801aef8:	885b      	ldrh	r3, [r3, #2]
 801aefa:	2b7f      	cmp	r3, #127	@ 0x7f
 801aefc:	d829      	bhi.n	801af52 <USBD_SetAddress+0x76>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7FU;
 801aefe:	683b      	ldr	r3, [r7, #0]
 801af00:	885b      	ldrh	r3, [r3, #2]
 801af02:	b2db      	uxtb	r3, r3
 801af04:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 801af08:	73fb      	strb	r3, [r7, #15]

    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801af0a:	687b      	ldr	r3, [r7, #4]
 801af0c:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801af10:	b2db      	uxtb	r3, r3
 801af12:	2b03      	cmp	r3, #3
 801af14:	d104      	bne.n	801af20 <USBD_SetAddress+0x44>
    {
      USBD_CtlError(pdev, req);
 801af16:	6839      	ldr	r1, [r7, #0]
 801af18:	6878      	ldr	r0, [r7, #4]
 801af1a:	f000 f9bc 	bl	801b296 <USBD_CtlError>
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801af1e:	e01d      	b.n	801af5c <USBD_SetAddress+0x80>
    }
    else
    {
      pdev->dev_address = dev_addr;
 801af20:	687b      	ldr	r3, [r7, #4]
 801af22:	7bfa      	ldrb	r2, [r7, #15]
 801af24:	f883 229e 	strb.w	r2, [r3, #670]	@ 0x29e
      (void)USBD_LL_SetUSBAddress(pdev, dev_addr);
 801af28:	7bfb      	ldrb	r3, [r7, #15]
 801af2a:	4619      	mov	r1, r3
 801af2c:	6878      	ldr	r0, [r7, #4]
 801af2e:	f000 ff69 	bl	801be04 <USBD_LL_SetUSBAddress>
      (void)USBD_CtlSendStatus(pdev);
 801af32:	6878      	ldr	r0, [r7, #4]
 801af34:	f000 fa7a 	bl	801b42c <USBD_CtlSendStatus>

      if (dev_addr != 0U)
 801af38:	7bfb      	ldrb	r3, [r7, #15]
 801af3a:	2b00      	cmp	r3, #0
 801af3c:	d004      	beq.n	801af48 <USBD_SetAddress+0x6c>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 801af3e:	687b      	ldr	r3, [r7, #4]
 801af40:	2202      	movs	r2, #2
 801af42:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801af46:	e009      	b.n	801af5c <USBD_SetAddress+0x80>
      }
      else
      {
        pdev->dev_state = USBD_STATE_DEFAULT;
 801af48:	687b      	ldr	r3, [r7, #4]
 801af4a:	2201      	movs	r2, #1
 801af4c:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
    if (pdev->dev_state == USBD_STATE_CONFIGURED)
 801af50:	e004      	b.n	801af5c <USBD_SetAddress+0x80>
      }
    }
  }
  else
  {
    USBD_CtlError(pdev, req);
 801af52:	6839      	ldr	r1, [r7, #0]
 801af54:	6878      	ldr	r0, [r7, #4]
 801af56:	f000 f99e 	bl	801b296 <USBD_CtlError>
  }
}
 801af5a:	bf00      	nop
 801af5c:	bf00      	nop
 801af5e:	3710      	adds	r7, #16
 801af60:	46bd      	mov	sp, r7
 801af62:	bd80      	pop	{r7, pc}

0801af64 <USBD_SetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static USBD_StatusTypeDef USBD_SetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801af64:	b580      	push	{r7, lr}
 801af66:	b084      	sub	sp, #16
 801af68:	af00      	add	r7, sp, #0
 801af6a:	6078      	str	r0, [r7, #4]
 801af6c:	6039      	str	r1, [r7, #0]
  USBD_StatusTypeDef ret = USBD_OK;
 801af6e:	2300      	movs	r3, #0
 801af70:	73fb      	strb	r3, [r7, #15]
  static uint8_t cfgidx;

  cfgidx = (uint8_t)(req->wValue);
 801af72:	683b      	ldr	r3, [r7, #0]
 801af74:	885b      	ldrh	r3, [r3, #2]
 801af76:	b2da      	uxtb	r2, r3
 801af78:	4b4e      	ldr	r3, [pc, #312]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801af7a:	701a      	strb	r2, [r3, #0]

  if (cfgidx > USBD_MAX_NUM_CONFIGURATION)
 801af7c:	4b4d      	ldr	r3, [pc, #308]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801af7e:	781b      	ldrb	r3, [r3, #0]
 801af80:	2b01      	cmp	r3, #1
 801af82:	d905      	bls.n	801af90 <USBD_SetConfig+0x2c>
  {
    USBD_CtlError(pdev, req);
 801af84:	6839      	ldr	r1, [r7, #0]
 801af86:	6878      	ldr	r0, [r7, #4]
 801af88:	f000 f985 	bl	801b296 <USBD_CtlError>
    return USBD_FAIL;
 801af8c:	2303      	movs	r3, #3
 801af8e:	e08c      	b.n	801b0aa <USBD_SetConfig+0x146>
  }

  switch (pdev->dev_state)
 801af90:	687b      	ldr	r3, [r7, #4]
 801af92:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801af96:	b2db      	uxtb	r3, r3
 801af98:	2b02      	cmp	r3, #2
 801af9a:	d002      	beq.n	801afa2 <USBD_SetConfig+0x3e>
 801af9c:	2b03      	cmp	r3, #3
 801af9e:	d029      	beq.n	801aff4 <USBD_SetConfig+0x90>
 801afa0:	e075      	b.n	801b08e <USBD_SetConfig+0x12a>
  {
    case USBD_STATE_ADDRESSED:
      if (cfgidx != 0U)
 801afa2:	4b44      	ldr	r3, [pc, #272]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801afa4:	781b      	ldrb	r3, [r3, #0]
 801afa6:	2b00      	cmp	r3, #0
 801afa8:	d020      	beq.n	801afec <USBD_SetConfig+0x88>
      {
        pdev->dev_config = cfgidx;
 801afaa:	4b42      	ldr	r3, [pc, #264]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801afac:	781b      	ldrb	r3, [r3, #0]
 801afae:	461a      	mov	r2, r3
 801afb0:	687b      	ldr	r3, [r7, #4]
 801afb2:	605a      	str	r2, [r3, #4]

        ret = USBD_SetClassConfig(pdev, cfgidx);
 801afb4:	4b3f      	ldr	r3, [pc, #252]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801afb6:	781b      	ldrb	r3, [r3, #0]
 801afb8:	4619      	mov	r1, r3
 801afba:	6878      	ldr	r0, [r7, #4]
 801afbc:	f7fe ffe3 	bl	8019f86 <USBD_SetClassConfig>
 801afc0:	4603      	mov	r3, r0
 801afc2:	73fb      	strb	r3, [r7, #15]

        if (ret != USBD_OK)
 801afc4:	7bfb      	ldrb	r3, [r7, #15]
 801afc6:	2b00      	cmp	r3, #0
 801afc8:	d008      	beq.n	801afdc <USBD_SetConfig+0x78>
        {
          USBD_CtlError(pdev, req);
 801afca:	6839      	ldr	r1, [r7, #0]
 801afcc:	6878      	ldr	r0, [r7, #4]
 801afce:	f000 f962 	bl	801b296 <USBD_CtlError>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 801afd2:	687b      	ldr	r3, [r7, #4]
 801afd4:	2202      	movs	r2, #2
 801afd6:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 801afda:	e065      	b.n	801b0a8 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 801afdc:	6878      	ldr	r0, [r7, #4]
 801afde:	f000 fa25 	bl	801b42c <USBD_CtlSendStatus>
          pdev->dev_state = USBD_STATE_CONFIGURED;
 801afe2:	687b      	ldr	r3, [r7, #4]
 801afe4:	2203      	movs	r2, #3
 801afe6:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 801afea:	e05d      	b.n	801b0a8 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 801afec:	6878      	ldr	r0, [r7, #4]
 801afee:	f000 fa1d 	bl	801b42c <USBD_CtlSendStatus>
      break;
 801aff2:	e059      	b.n	801b0a8 <USBD_SetConfig+0x144>

    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0U)
 801aff4:	4b2f      	ldr	r3, [pc, #188]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801aff6:	781b      	ldrb	r3, [r3, #0]
 801aff8:	2b00      	cmp	r3, #0
 801affa:	d112      	bne.n	801b022 <USBD_SetConfig+0xbe>
      {
        pdev->dev_state = USBD_STATE_ADDRESSED;
 801affc:	687b      	ldr	r3, [r7, #4]
 801affe:	2202      	movs	r2, #2
 801b000:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
        pdev->dev_config = cfgidx;
 801b004:	4b2b      	ldr	r3, [pc, #172]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801b006:	781b      	ldrb	r3, [r3, #0]
 801b008:	461a      	mov	r2, r3
 801b00a:	687b      	ldr	r3, [r7, #4]
 801b00c:	605a      	str	r2, [r3, #4]
        (void)USBD_ClrClassConfig(pdev, cfgidx);
 801b00e:	4b29      	ldr	r3, [pc, #164]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801b010:	781b      	ldrb	r3, [r3, #0]
 801b012:	4619      	mov	r1, r3
 801b014:	6878      	ldr	r0, [r7, #4]
 801b016:	f7fe ffd2 	bl	8019fbe <USBD_ClrClassConfig>
        (void)USBD_CtlSendStatus(pdev);
 801b01a:	6878      	ldr	r0, [r7, #4]
 801b01c:	f000 fa06 	bl	801b42c <USBD_CtlSendStatus>
      }
      else
      {
        (void)USBD_CtlSendStatus(pdev);
      }
      break;
 801b020:	e042      	b.n	801b0a8 <USBD_SetConfig+0x144>
      else if (cfgidx != pdev->dev_config)
 801b022:	4b24      	ldr	r3, [pc, #144]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801b024:	781b      	ldrb	r3, [r3, #0]
 801b026:	461a      	mov	r2, r3
 801b028:	687b      	ldr	r3, [r7, #4]
 801b02a:	685b      	ldr	r3, [r3, #4]
 801b02c:	429a      	cmp	r2, r3
 801b02e:	d02a      	beq.n	801b086 <USBD_SetConfig+0x122>
        (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 801b030:	687b      	ldr	r3, [r7, #4]
 801b032:	685b      	ldr	r3, [r3, #4]
 801b034:	b2db      	uxtb	r3, r3
 801b036:	4619      	mov	r1, r3
 801b038:	6878      	ldr	r0, [r7, #4]
 801b03a:	f7fe ffc0 	bl	8019fbe <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 801b03e:	4b1d      	ldr	r3, [pc, #116]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801b040:	781b      	ldrb	r3, [r3, #0]
 801b042:	461a      	mov	r2, r3
 801b044:	687b      	ldr	r3, [r7, #4]
 801b046:	605a      	str	r2, [r3, #4]
        ret = USBD_SetClassConfig(pdev, cfgidx);
 801b048:	4b1a      	ldr	r3, [pc, #104]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801b04a:	781b      	ldrb	r3, [r3, #0]
 801b04c:	4619      	mov	r1, r3
 801b04e:	6878      	ldr	r0, [r7, #4]
 801b050:	f7fe ff99 	bl	8019f86 <USBD_SetClassConfig>
 801b054:	4603      	mov	r3, r0
 801b056:	73fb      	strb	r3, [r7, #15]
        if (ret != USBD_OK)
 801b058:	7bfb      	ldrb	r3, [r7, #15]
 801b05a:	2b00      	cmp	r3, #0
 801b05c:	d00f      	beq.n	801b07e <USBD_SetConfig+0x11a>
          USBD_CtlError(pdev, req);
 801b05e:	6839      	ldr	r1, [r7, #0]
 801b060:	6878      	ldr	r0, [r7, #4]
 801b062:	f000 f918 	bl	801b296 <USBD_CtlError>
          (void)USBD_ClrClassConfig(pdev, (uint8_t)pdev->dev_config);
 801b066:	687b      	ldr	r3, [r7, #4]
 801b068:	685b      	ldr	r3, [r3, #4]
 801b06a:	b2db      	uxtb	r3, r3
 801b06c:	4619      	mov	r1, r3
 801b06e:	6878      	ldr	r0, [r7, #4]
 801b070:	f7fe ffa5 	bl	8019fbe <USBD_ClrClassConfig>
          pdev->dev_state = USBD_STATE_ADDRESSED;
 801b074:	687b      	ldr	r3, [r7, #4]
 801b076:	2202      	movs	r2, #2
 801b078:	f883 229c 	strb.w	r2, [r3, #668]	@ 0x29c
      break;
 801b07c:	e014      	b.n	801b0a8 <USBD_SetConfig+0x144>
          (void)USBD_CtlSendStatus(pdev);
 801b07e:	6878      	ldr	r0, [r7, #4]
 801b080:	f000 f9d4 	bl	801b42c <USBD_CtlSendStatus>
      break;
 801b084:	e010      	b.n	801b0a8 <USBD_SetConfig+0x144>
        (void)USBD_CtlSendStatus(pdev);
 801b086:	6878      	ldr	r0, [r7, #4]
 801b088:	f000 f9d0 	bl	801b42c <USBD_CtlSendStatus>
      break;
 801b08c:	e00c      	b.n	801b0a8 <USBD_SetConfig+0x144>

    default:
      USBD_CtlError(pdev, req);
 801b08e:	6839      	ldr	r1, [r7, #0]
 801b090:	6878      	ldr	r0, [r7, #4]
 801b092:	f000 f900 	bl	801b296 <USBD_CtlError>
      (void)USBD_ClrClassConfig(pdev, cfgidx);
 801b096:	4b07      	ldr	r3, [pc, #28]	@ (801b0b4 <USBD_SetConfig+0x150>)
 801b098:	781b      	ldrb	r3, [r3, #0]
 801b09a:	4619      	mov	r1, r3
 801b09c:	6878      	ldr	r0, [r7, #4]
 801b09e:	f7fe ff8e 	bl	8019fbe <USBD_ClrClassConfig>
      ret = USBD_FAIL;
 801b0a2:	2303      	movs	r3, #3
 801b0a4:	73fb      	strb	r3, [r7, #15]
      break;
 801b0a6:	bf00      	nop
  }

  return ret;
 801b0a8:	7bfb      	ldrb	r3, [r7, #15]
}
 801b0aa:	4618      	mov	r0, r3
 801b0ac:	3710      	adds	r7, #16
 801b0ae:	46bd      	mov	sp, r7
 801b0b0:	bd80      	pop	{r7, pc}
 801b0b2:	bf00      	nop
 801b0b4:	2000a8d4 	.word	0x2000a8d4

0801b0b8 <USBD_GetConfig>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetConfig(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801b0b8:	b580      	push	{r7, lr}
 801b0ba:	b082      	sub	sp, #8
 801b0bc:	af00      	add	r7, sp, #0
 801b0be:	6078      	str	r0, [r7, #4]
 801b0c0:	6039      	str	r1, [r7, #0]
  if (req->wLength != 1U)
 801b0c2:	683b      	ldr	r3, [r7, #0]
 801b0c4:	88db      	ldrh	r3, [r3, #6]
 801b0c6:	2b01      	cmp	r3, #1
 801b0c8:	d004      	beq.n	801b0d4 <USBD_GetConfig+0x1c>
  {
    USBD_CtlError(pdev, req);
 801b0ca:	6839      	ldr	r1, [r7, #0]
 801b0cc:	6878      	ldr	r0, [r7, #4]
 801b0ce:	f000 f8e2 	bl	801b296 <USBD_CtlError>
      default:
        USBD_CtlError(pdev, req);
        break;
    }
  }
}
 801b0d2:	e023      	b.n	801b11c <USBD_GetConfig+0x64>
    switch (pdev->dev_state)
 801b0d4:	687b      	ldr	r3, [r7, #4]
 801b0d6:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801b0da:	b2db      	uxtb	r3, r3
 801b0dc:	2b02      	cmp	r3, #2
 801b0de:	dc02      	bgt.n	801b0e6 <USBD_GetConfig+0x2e>
 801b0e0:	2b00      	cmp	r3, #0
 801b0e2:	dc03      	bgt.n	801b0ec <USBD_GetConfig+0x34>
 801b0e4:	e015      	b.n	801b112 <USBD_GetConfig+0x5a>
 801b0e6:	2b03      	cmp	r3, #3
 801b0e8:	d00b      	beq.n	801b102 <USBD_GetConfig+0x4a>
 801b0ea:	e012      	b.n	801b112 <USBD_GetConfig+0x5a>
        pdev->dev_default_config = 0U;
 801b0ec:	687b      	ldr	r3, [r7, #4]
 801b0ee:	2200      	movs	r2, #0
 801b0f0:	609a      	str	r2, [r3, #8]
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_default_config, 1U);
 801b0f2:	687b      	ldr	r3, [r7, #4]
 801b0f4:	3308      	adds	r3, #8
 801b0f6:	2201      	movs	r2, #1
 801b0f8:	4619      	mov	r1, r3
 801b0fa:	6878      	ldr	r0, [r7, #4]
 801b0fc:	f000 f93c 	bl	801b378 <USBD_CtlSendData>
        break;
 801b100:	e00c      	b.n	801b11c <USBD_GetConfig+0x64>
        (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config, 1U);
 801b102:	687b      	ldr	r3, [r7, #4]
 801b104:	3304      	adds	r3, #4
 801b106:	2201      	movs	r2, #1
 801b108:	4619      	mov	r1, r3
 801b10a:	6878      	ldr	r0, [r7, #4]
 801b10c:	f000 f934 	bl	801b378 <USBD_CtlSendData>
        break;
 801b110:	e004      	b.n	801b11c <USBD_GetConfig+0x64>
        USBD_CtlError(pdev, req);
 801b112:	6839      	ldr	r1, [r7, #0]
 801b114:	6878      	ldr	r0, [r7, #4]
 801b116:	f000 f8be 	bl	801b296 <USBD_CtlError>
        break;
 801b11a:	bf00      	nop
}
 801b11c:	bf00      	nop
 801b11e:	3708      	adds	r7, #8
 801b120:	46bd      	mov	sp, r7
 801b122:	bd80      	pop	{r7, pc}

0801b124 <USBD_GetStatus>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_GetStatus(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801b124:	b580      	push	{r7, lr}
 801b126:	b082      	sub	sp, #8
 801b128:	af00      	add	r7, sp, #0
 801b12a:	6078      	str	r0, [r7, #4]
 801b12c:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 801b12e:	687b      	ldr	r3, [r7, #4]
 801b130:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801b134:	b2db      	uxtb	r3, r3
 801b136:	3b01      	subs	r3, #1
 801b138:	2b02      	cmp	r3, #2
 801b13a:	d81e      	bhi.n	801b17a <USBD_GetStatus+0x56>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wLength != 0x2U)
 801b13c:	683b      	ldr	r3, [r7, #0]
 801b13e:	88db      	ldrh	r3, [r3, #6]
 801b140:	2b02      	cmp	r3, #2
 801b142:	d004      	beq.n	801b14e <USBD_GetStatus+0x2a>
      {
        USBD_CtlError(pdev, req);
 801b144:	6839      	ldr	r1, [r7, #0]
 801b146:	6878      	ldr	r0, [r7, #4]
 801b148:	f000 f8a5 	bl	801b296 <USBD_CtlError>
        break;
 801b14c:	e01a      	b.n	801b184 <USBD_GetStatus+0x60>
      }

#if (USBD_SELF_POWERED == 1U)
      pdev->dev_config_status = USB_CONFIG_SELF_POWERED;
 801b14e:	687b      	ldr	r3, [r7, #4]
 801b150:	2201      	movs	r2, #1
 801b152:	60da      	str	r2, [r3, #12]
#else
      pdev->dev_config_status = 0U;
#endif /* USBD_SELF_POWERED */

      if (pdev->dev_remote_wakeup != 0U)
 801b154:	687b      	ldr	r3, [r7, #4]
 801b156:	f8d3 32a4 	ldr.w	r3, [r3, #676]	@ 0x2a4
 801b15a:	2b00      	cmp	r3, #0
 801b15c:	d005      	beq.n	801b16a <USBD_GetStatus+0x46>
      {
        pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;
 801b15e:	687b      	ldr	r3, [r7, #4]
 801b160:	68db      	ldr	r3, [r3, #12]
 801b162:	f043 0202 	orr.w	r2, r3, #2
 801b166:	687b      	ldr	r3, [r7, #4]
 801b168:	60da      	str	r2, [r3, #12]
      }

      (void)USBD_CtlSendData(pdev, (uint8_t *)&pdev->dev_config_status, 2U);
 801b16a:	687b      	ldr	r3, [r7, #4]
 801b16c:	330c      	adds	r3, #12
 801b16e:	2202      	movs	r2, #2
 801b170:	4619      	mov	r1, r3
 801b172:	6878      	ldr	r0, [r7, #4]
 801b174:	f000 f900 	bl	801b378 <USBD_CtlSendData>
      break;
 801b178:	e004      	b.n	801b184 <USBD_GetStatus+0x60>

    default:
      USBD_CtlError(pdev, req);
 801b17a:	6839      	ldr	r1, [r7, #0]
 801b17c:	6878      	ldr	r0, [r7, #4]
 801b17e:	f000 f88a 	bl	801b296 <USBD_CtlError>
      break;
 801b182:	bf00      	nop
  }
}
 801b184:	bf00      	nop
 801b186:	3708      	adds	r7, #8
 801b188:	46bd      	mov	sp, r7
 801b18a:	bd80      	pop	{r7, pc}

0801b18c <USBD_SetFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_SetFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801b18c:	b580      	push	{r7, lr}
 801b18e:	b082      	sub	sp, #8
 801b190:	af00      	add	r7, sp, #0
 801b192:	6078      	str	r0, [r7, #4]
 801b194:	6039      	str	r1, [r7, #0]
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801b196:	683b      	ldr	r3, [r7, #0]
 801b198:	885b      	ldrh	r3, [r3, #2]
 801b19a:	2b01      	cmp	r3, #1
 801b19c:	d107      	bne.n	801b1ae <USBD_SetFeature+0x22>
  {
    pdev->dev_remote_wakeup = 1U;
 801b19e:	687b      	ldr	r3, [r7, #4]
 801b1a0:	2201      	movs	r2, #1
 801b1a2:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
    (void)USBD_CtlSendStatus(pdev);
 801b1a6:	6878      	ldr	r0, [r7, #4]
 801b1a8:	f000 f940 	bl	801b42c <USBD_CtlSendStatus>
  }
  else
  {
    USBD_CtlError(pdev, req);
  }
}
 801b1ac:	e013      	b.n	801b1d6 <USBD_SetFeature+0x4a>
  else if (req->wValue == USB_FEATURE_TEST_MODE)
 801b1ae:	683b      	ldr	r3, [r7, #0]
 801b1b0:	885b      	ldrh	r3, [r3, #2]
 801b1b2:	2b02      	cmp	r3, #2
 801b1b4:	d10b      	bne.n	801b1ce <USBD_SetFeature+0x42>
    pdev->dev_test_mode = (uint8_t)(req->wIndex >> 8);
 801b1b6:	683b      	ldr	r3, [r7, #0]
 801b1b8:	889b      	ldrh	r3, [r3, #4]
 801b1ba:	0a1b      	lsrs	r3, r3, #8
 801b1bc:	b29b      	uxth	r3, r3
 801b1be:	b2da      	uxtb	r2, r3
 801b1c0:	687b      	ldr	r3, [r7, #4]
 801b1c2:	f883 22a0 	strb.w	r2, [r3, #672]	@ 0x2a0
    (void)USBD_CtlSendStatus(pdev);
 801b1c6:	6878      	ldr	r0, [r7, #4]
 801b1c8:	f000 f930 	bl	801b42c <USBD_CtlSendStatus>
}
 801b1cc:	e003      	b.n	801b1d6 <USBD_SetFeature+0x4a>
    USBD_CtlError(pdev, req);
 801b1ce:	6839      	ldr	r1, [r7, #0]
 801b1d0:	6878      	ldr	r0, [r7, #4]
 801b1d2:	f000 f860 	bl	801b296 <USBD_CtlError>
}
 801b1d6:	bf00      	nop
 801b1d8:	3708      	adds	r7, #8
 801b1da:	46bd      	mov	sp, r7
 801b1dc:	bd80      	pop	{r7, pc}

0801b1de <USBD_ClrFeature>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval status
  */
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801b1de:	b580      	push	{r7, lr}
 801b1e0:	b082      	sub	sp, #8
 801b1e2:	af00      	add	r7, sp, #0
 801b1e4:	6078      	str	r0, [r7, #4]
 801b1e6:	6039      	str	r1, [r7, #0]
  switch (pdev->dev_state)
 801b1e8:	687b      	ldr	r3, [r7, #4]
 801b1ea:	f893 329c 	ldrb.w	r3, [r3, #668]	@ 0x29c
 801b1ee:	b2db      	uxtb	r3, r3
 801b1f0:	3b01      	subs	r3, #1
 801b1f2:	2b02      	cmp	r3, #2
 801b1f4:	d80b      	bhi.n	801b20e <USBD_ClrFeature+0x30>
  {
    case USBD_STATE_DEFAULT:
    case USBD_STATE_ADDRESSED:
    case USBD_STATE_CONFIGURED:
      if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 801b1f6:	683b      	ldr	r3, [r7, #0]
 801b1f8:	885b      	ldrh	r3, [r3, #2]
 801b1fa:	2b01      	cmp	r3, #1
 801b1fc:	d10c      	bne.n	801b218 <USBD_ClrFeature+0x3a>
      {
        pdev->dev_remote_wakeup = 0U;
 801b1fe:	687b      	ldr	r3, [r7, #4]
 801b200:	2200      	movs	r2, #0
 801b202:	f8c3 22a4 	str.w	r2, [r3, #676]	@ 0x2a4
        (void)USBD_CtlSendStatus(pdev);
 801b206:	6878      	ldr	r0, [r7, #4]
 801b208:	f000 f910 	bl	801b42c <USBD_CtlSendStatus>
      }
      break;
 801b20c:	e004      	b.n	801b218 <USBD_ClrFeature+0x3a>

    default:
      USBD_CtlError(pdev, req);
 801b20e:	6839      	ldr	r1, [r7, #0]
 801b210:	6878      	ldr	r0, [r7, #4]
 801b212:	f000 f840 	bl	801b296 <USBD_CtlError>
      break;
 801b216:	e000      	b.n	801b21a <USBD_ClrFeature+0x3c>
      break;
 801b218:	bf00      	nop
  }
}
 801b21a:	bf00      	nop
 801b21c:	3708      	adds	r7, #8
 801b21e:	46bd      	mov	sp, r7
 801b220:	bd80      	pop	{r7, pc}

0801b222 <USBD_ParseSetupRequest>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
 801b222:	b580      	push	{r7, lr}
 801b224:	b084      	sub	sp, #16
 801b226:	af00      	add	r7, sp, #0
 801b228:	6078      	str	r0, [r7, #4]
 801b22a:	6039      	str	r1, [r7, #0]
  uint8_t *pbuff = pdata;
 801b22c:	683b      	ldr	r3, [r7, #0]
 801b22e:	60fb      	str	r3, [r7, #12]

  req->bmRequest = *(uint8_t *)(pbuff);
 801b230:	68fb      	ldr	r3, [r7, #12]
 801b232:	781a      	ldrb	r2, [r3, #0]
 801b234:	687b      	ldr	r3, [r7, #4]
 801b236:	701a      	strb	r2, [r3, #0]

  pbuff++;
 801b238:	68fb      	ldr	r3, [r7, #12]
 801b23a:	3301      	adds	r3, #1
 801b23c:	60fb      	str	r3, [r7, #12]
  req->bRequest = *(uint8_t *)(pbuff);
 801b23e:	68fb      	ldr	r3, [r7, #12]
 801b240:	781a      	ldrb	r2, [r3, #0]
 801b242:	687b      	ldr	r3, [r7, #4]
 801b244:	705a      	strb	r2, [r3, #1]

  pbuff++;
 801b246:	68fb      	ldr	r3, [r7, #12]
 801b248:	3301      	adds	r3, #1
 801b24a:	60fb      	str	r3, [r7, #12]
  req->wValue = SWAPBYTE(pbuff);
 801b24c:	68f8      	ldr	r0, [r7, #12]
 801b24e:	f7ff fa40 	bl	801a6d2 <SWAPBYTE>
 801b252:	4603      	mov	r3, r0
 801b254:	461a      	mov	r2, r3
 801b256:	687b      	ldr	r3, [r7, #4]
 801b258:	805a      	strh	r2, [r3, #2]

  pbuff++;
 801b25a:	68fb      	ldr	r3, [r7, #12]
 801b25c:	3301      	adds	r3, #1
 801b25e:	60fb      	str	r3, [r7, #12]
  pbuff++;
 801b260:	68fb      	ldr	r3, [r7, #12]
 801b262:	3301      	adds	r3, #1
 801b264:	60fb      	str	r3, [r7, #12]
  req->wIndex = SWAPBYTE(pbuff);
 801b266:	68f8      	ldr	r0, [r7, #12]
 801b268:	f7ff fa33 	bl	801a6d2 <SWAPBYTE>
 801b26c:	4603      	mov	r3, r0
 801b26e:	461a      	mov	r2, r3
 801b270:	687b      	ldr	r3, [r7, #4]
 801b272:	809a      	strh	r2, [r3, #4]

  pbuff++;
 801b274:	68fb      	ldr	r3, [r7, #12]
 801b276:	3301      	adds	r3, #1
 801b278:	60fb      	str	r3, [r7, #12]
  pbuff++;
 801b27a:	68fb      	ldr	r3, [r7, #12]
 801b27c:	3301      	adds	r3, #1
 801b27e:	60fb      	str	r3, [r7, #12]
  req->wLength = SWAPBYTE(pbuff);
 801b280:	68f8      	ldr	r0, [r7, #12]
 801b282:	f7ff fa26 	bl	801a6d2 <SWAPBYTE>
 801b286:	4603      	mov	r3, r0
 801b288:	461a      	mov	r2, r3
 801b28a:	687b      	ldr	r3, [r7, #4]
 801b28c:	80da      	strh	r2, [r3, #6]
}
 801b28e:	bf00      	nop
 801b290:	3710      	adds	r7, #16
 801b292:	46bd      	mov	sp, r7
 801b294:	bd80      	pop	{r7, pc}

0801b296 <USBD_CtlError>:
  * @param  pdev: device instance
  * @param  req: usb request
  * @retval None
  */
void USBD_CtlError(USBD_HandleTypeDef *pdev, USBD_SetupReqTypedef *req)
{
 801b296:	b580      	push	{r7, lr}
 801b298:	b082      	sub	sp, #8
 801b29a:	af00      	add	r7, sp, #0
 801b29c:	6078      	str	r0, [r7, #4]
 801b29e:	6039      	str	r1, [r7, #0]
  UNUSED(req);

  (void)USBD_LL_StallEP(pdev, 0x80U);
 801b2a0:	2180      	movs	r1, #128	@ 0x80
 801b2a2:	6878      	ldr	r0, [r7, #4]
 801b2a4:	f000 fd44 	bl	801bd30 <USBD_LL_StallEP>
  (void)USBD_LL_StallEP(pdev, 0U);
 801b2a8:	2100      	movs	r1, #0
 801b2aa:	6878      	ldr	r0, [r7, #4]
 801b2ac:	f000 fd40 	bl	801bd30 <USBD_LL_StallEP>
}
 801b2b0:	bf00      	nop
 801b2b2:	3708      	adds	r7, #8
 801b2b4:	46bd      	mov	sp, r7
 801b2b6:	bd80      	pop	{r7, pc}

0801b2b8 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 801b2b8:	b580      	push	{r7, lr}
 801b2ba:	b086      	sub	sp, #24
 801b2bc:	af00      	add	r7, sp, #0
 801b2be:	60f8      	str	r0, [r7, #12]
 801b2c0:	60b9      	str	r1, [r7, #8]
 801b2c2:	607a      	str	r2, [r7, #4]
  uint8_t idx = 0U;
 801b2c4:	2300      	movs	r3, #0
 801b2c6:	75fb      	strb	r3, [r7, #23]
  uint8_t *pdesc;

  if (desc == NULL)
 801b2c8:	68fb      	ldr	r3, [r7, #12]
 801b2ca:	2b00      	cmp	r3, #0
 801b2cc:	d036      	beq.n	801b33c <USBD_GetString+0x84>
  {
    return;
  }

  pdesc = desc;
 801b2ce:	68fb      	ldr	r3, [r7, #12]
 801b2d0:	613b      	str	r3, [r7, #16]
  *len = ((uint16_t)USBD_GetLen(pdesc) * 2U) + 2U;
 801b2d2:	6938      	ldr	r0, [r7, #16]
 801b2d4:	f000 f836 	bl	801b344 <USBD_GetLen>
 801b2d8:	4603      	mov	r3, r0
 801b2da:	3301      	adds	r3, #1
 801b2dc:	b29b      	uxth	r3, r3
 801b2de:	005b      	lsls	r3, r3, #1
 801b2e0:	b29a      	uxth	r2, r3
 801b2e2:	687b      	ldr	r3, [r7, #4]
 801b2e4:	801a      	strh	r2, [r3, #0]

  unicode[idx] = *(uint8_t *)len;
 801b2e6:	7dfb      	ldrb	r3, [r7, #23]
 801b2e8:	68ba      	ldr	r2, [r7, #8]
 801b2ea:	4413      	add	r3, r2
 801b2ec:	687a      	ldr	r2, [r7, #4]
 801b2ee:	7812      	ldrb	r2, [r2, #0]
 801b2f0:	701a      	strb	r2, [r3, #0]
  idx++;
 801b2f2:	7dfb      	ldrb	r3, [r7, #23]
 801b2f4:	3301      	adds	r3, #1
 801b2f6:	75fb      	strb	r3, [r7, #23]
  unicode[idx] = USB_DESC_TYPE_STRING;
 801b2f8:	7dfb      	ldrb	r3, [r7, #23]
 801b2fa:	68ba      	ldr	r2, [r7, #8]
 801b2fc:	4413      	add	r3, r2
 801b2fe:	2203      	movs	r2, #3
 801b300:	701a      	strb	r2, [r3, #0]
  idx++;
 801b302:	7dfb      	ldrb	r3, [r7, #23]
 801b304:	3301      	adds	r3, #1
 801b306:	75fb      	strb	r3, [r7, #23]

  while (*pdesc != (uint8_t)'\0')
 801b308:	e013      	b.n	801b332 <USBD_GetString+0x7a>
  {
    unicode[idx] = *pdesc;
 801b30a:	7dfb      	ldrb	r3, [r7, #23]
 801b30c:	68ba      	ldr	r2, [r7, #8]
 801b30e:	4413      	add	r3, r2
 801b310:	693a      	ldr	r2, [r7, #16]
 801b312:	7812      	ldrb	r2, [r2, #0]
 801b314:	701a      	strb	r2, [r3, #0]
    pdesc++;
 801b316:	693b      	ldr	r3, [r7, #16]
 801b318:	3301      	adds	r3, #1
 801b31a:	613b      	str	r3, [r7, #16]
    idx++;
 801b31c:	7dfb      	ldrb	r3, [r7, #23]
 801b31e:	3301      	adds	r3, #1
 801b320:	75fb      	strb	r3, [r7, #23]

    unicode[idx] = 0U;
 801b322:	7dfb      	ldrb	r3, [r7, #23]
 801b324:	68ba      	ldr	r2, [r7, #8]
 801b326:	4413      	add	r3, r2
 801b328:	2200      	movs	r2, #0
 801b32a:	701a      	strb	r2, [r3, #0]
    idx++;
 801b32c:	7dfb      	ldrb	r3, [r7, #23]
 801b32e:	3301      	adds	r3, #1
 801b330:	75fb      	strb	r3, [r7, #23]
  while (*pdesc != (uint8_t)'\0')
 801b332:	693b      	ldr	r3, [r7, #16]
 801b334:	781b      	ldrb	r3, [r3, #0]
 801b336:	2b00      	cmp	r3, #0
 801b338:	d1e7      	bne.n	801b30a <USBD_GetString+0x52>
 801b33a:	e000      	b.n	801b33e <USBD_GetString+0x86>
    return;
 801b33c:	bf00      	nop
  }
}
 801b33e:	3718      	adds	r7, #24
 801b340:	46bd      	mov	sp, r7
 801b342:	bd80      	pop	{r7, pc}

0801b344 <USBD_GetLen>:
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
 801b344:	b480      	push	{r7}
 801b346:	b085      	sub	sp, #20
 801b348:	af00      	add	r7, sp, #0
 801b34a:	6078      	str	r0, [r7, #4]
  uint8_t  len = 0U;
 801b34c:	2300      	movs	r3, #0
 801b34e:	73fb      	strb	r3, [r7, #15]
  uint8_t *pbuff = buf;
 801b350:	687b      	ldr	r3, [r7, #4]
 801b352:	60bb      	str	r3, [r7, #8]

  while (*pbuff != (uint8_t)'\0')
 801b354:	e005      	b.n	801b362 <USBD_GetLen+0x1e>
  {
    len++;
 801b356:	7bfb      	ldrb	r3, [r7, #15]
 801b358:	3301      	adds	r3, #1
 801b35a:	73fb      	strb	r3, [r7, #15]
    pbuff++;
 801b35c:	68bb      	ldr	r3, [r7, #8]
 801b35e:	3301      	adds	r3, #1
 801b360:	60bb      	str	r3, [r7, #8]
  while (*pbuff != (uint8_t)'\0')
 801b362:	68bb      	ldr	r3, [r7, #8]
 801b364:	781b      	ldrb	r3, [r3, #0]
 801b366:	2b00      	cmp	r3, #0
 801b368:	d1f5      	bne.n	801b356 <USBD_GetLen+0x12>
  }

  return len;
 801b36a:	7bfb      	ldrb	r3, [r7, #15]
}
 801b36c:	4618      	mov	r0, r3
 801b36e:	3714      	adds	r7, #20
 801b370:	46bd      	mov	sp, r7
 801b372:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b376:	4770      	bx	lr

0801b378 <USBD_CtlSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendData(USBD_HandleTypeDef *pdev,
                                    uint8_t *pbuf, uint32_t len)
{
 801b378:	b580      	push	{r7, lr}
 801b37a:	b084      	sub	sp, #16
 801b37c:	af00      	add	r7, sp, #0
 801b37e:	60f8      	str	r0, [r7, #12]
 801b380:	60b9      	str	r1, [r7, #8]
 801b382:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_IN;
 801b384:	68fb      	ldr	r3, [r7, #12]
 801b386:	2202      	movs	r2, #2
 801b388:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_in[0].total_length = len;
 801b38c:	68fb      	ldr	r3, [r7, #12]
 801b38e:	687a      	ldr	r2, [r7, #4]
 801b390:	619a      	str	r2, [r3, #24]

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_in[0].rem_length = 0U;
#else
  pdev->ep_in[0].rem_length = len;
 801b392:	68fb      	ldr	r3, [r7, #12]
 801b394:	687a      	ldr	r2, [r7, #4]
 801b396:	61da      	str	r2, [r3, #28]
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 801b398:	687b      	ldr	r3, [r7, #4]
 801b39a:	68ba      	ldr	r2, [r7, #8]
 801b39c:	2100      	movs	r1, #0
 801b39e:	68f8      	ldr	r0, [r7, #12]
 801b3a0:	f000 fd4f 	bl	801be42 <USBD_LL_Transmit>

  return USBD_OK;
 801b3a4:	2300      	movs	r3, #0
}
 801b3a6:	4618      	mov	r0, r3
 801b3a8:	3710      	adds	r7, #16
 801b3aa:	46bd      	mov	sp, r7
 801b3ac:	bd80      	pop	{r7, pc}

0801b3ae <USBD_CtlContinueSendData>:
  * @param  len: length of data to be sent
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueSendData(USBD_HandleTypeDef *pdev,
                                            uint8_t *pbuf, uint32_t len)
{
 801b3ae:	b580      	push	{r7, lr}
 801b3b0:	b084      	sub	sp, #16
 801b3b2:	af00      	add	r7, sp, #0
 801b3b4:	60f8      	str	r0, [r7, #12]
 801b3b6:	60b9      	str	r1, [r7, #8]
 801b3b8:	607a      	str	r2, [r7, #4]
  /* Start the next transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, pbuf, len);
 801b3ba:	687b      	ldr	r3, [r7, #4]
 801b3bc:	68ba      	ldr	r2, [r7, #8]
 801b3be:	2100      	movs	r1, #0
 801b3c0:	68f8      	ldr	r0, [r7, #12]
 801b3c2:	f000 fd3e 	bl	801be42 <USBD_LL_Transmit>

  return USBD_OK;
 801b3c6:	2300      	movs	r3, #0
}
 801b3c8:	4618      	mov	r0, r3
 801b3ca:	3710      	adds	r7, #16
 801b3cc:	46bd      	mov	sp, r7
 801b3ce:	bd80      	pop	{r7, pc}

0801b3d0 <USBD_CtlPrepareRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlPrepareRx(USBD_HandleTypeDef *pdev,
                                     uint8_t *pbuf, uint32_t len)
{
 801b3d0:	b580      	push	{r7, lr}
 801b3d2:	b084      	sub	sp, #16
 801b3d4:	af00      	add	r7, sp, #0
 801b3d6:	60f8      	str	r0, [r7, #12]
 801b3d8:	60b9      	str	r1, [r7, #8]
 801b3da:	607a      	str	r2, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT;
 801b3dc:	68fb      	ldr	r3, [r7, #12]
 801b3de:	2203      	movs	r2, #3
 801b3e0:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294
  pdev->ep_out[0].total_length = len;
 801b3e4:	68fb      	ldr	r3, [r7, #12]
 801b3e6:	687a      	ldr	r2, [r7, #4]
 801b3e8:	f8c3 2158 	str.w	r2, [r3, #344]	@ 0x158

#ifdef USBD_AVOID_PACKET_SPLIT_MPS
  pdev->ep_out[0].rem_length = 0U;
#else
  pdev->ep_out[0].rem_length = len;
 801b3ec:	68fb      	ldr	r3, [r7, #12]
 801b3ee:	687a      	ldr	r2, [r7, #4]
 801b3f0:	f8c3 215c 	str.w	r2, [r3, #348]	@ 0x15c
#endif /* USBD_AVOID_PACKET_SPLIT_MPS */

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801b3f4:	687b      	ldr	r3, [r7, #4]
 801b3f6:	68ba      	ldr	r2, [r7, #8]
 801b3f8:	2100      	movs	r1, #0
 801b3fa:	68f8      	ldr	r0, [r7, #12]
 801b3fc:	f000 fd42 	bl	801be84 <USBD_LL_PrepareReceive>

  return USBD_OK;
 801b400:	2300      	movs	r3, #0
}
 801b402:	4618      	mov	r0, r3
 801b404:	3710      	adds	r7, #16
 801b406:	46bd      	mov	sp, r7
 801b408:	bd80      	pop	{r7, pc}

0801b40a <USBD_CtlContinueRx>:
  * @param  len: length of data to be received
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlContinueRx(USBD_HandleTypeDef *pdev,
                                      uint8_t *pbuf, uint32_t len)
{
 801b40a:	b580      	push	{r7, lr}
 801b40c:	b084      	sub	sp, #16
 801b40e:	af00      	add	r7, sp, #0
 801b410:	60f8      	str	r0, [r7, #12]
 801b412:	60b9      	str	r1, [r7, #8]
 801b414:	607a      	str	r2, [r7, #4]
  (void)USBD_LL_PrepareReceive(pdev, 0U, pbuf, len);
 801b416:	687b      	ldr	r3, [r7, #4]
 801b418:	68ba      	ldr	r2, [r7, #8]
 801b41a:	2100      	movs	r1, #0
 801b41c:	68f8      	ldr	r0, [r7, #12]
 801b41e:	f000 fd31 	bl	801be84 <USBD_LL_PrepareReceive>

  return USBD_OK;
 801b422:	2300      	movs	r3, #0
}
 801b424:	4618      	mov	r0, r3
 801b426:	3710      	adds	r7, #16
 801b428:	46bd      	mov	sp, r7
 801b42a:	bd80      	pop	{r7, pc}

0801b42c <USBD_CtlSendStatus>:
  *         send zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlSendStatus(USBD_HandleTypeDef *pdev)
{
 801b42c:	b580      	push	{r7, lr}
 801b42e:	b082      	sub	sp, #8
 801b430:	af00      	add	r7, sp, #0
 801b432:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 801b434:	687b      	ldr	r3, [r7, #4]
 801b436:	2204      	movs	r2, #4
 801b438:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_Transmit(pdev, 0x00U, NULL, 0U);
 801b43c:	2300      	movs	r3, #0
 801b43e:	2200      	movs	r2, #0
 801b440:	2100      	movs	r1, #0
 801b442:	6878      	ldr	r0, [r7, #4]
 801b444:	f000 fcfd 	bl	801be42 <USBD_LL_Transmit>

  return USBD_OK;
 801b448:	2300      	movs	r3, #0
}
 801b44a:	4618      	mov	r0, r3
 801b44c:	3708      	adds	r7, #8
 801b44e:	46bd      	mov	sp, r7
 801b450:	bd80      	pop	{r7, pc}

0801b452 <USBD_CtlReceiveStatus>:
  *         receive zero lzngth packet on the ctl pipe
  * @param  pdev: device instance
  * @retval status
  */
USBD_StatusTypeDef USBD_CtlReceiveStatus(USBD_HandleTypeDef *pdev)
{
 801b452:	b580      	push	{r7, lr}
 801b454:	b082      	sub	sp, #8
 801b456:	af00      	add	r7, sp, #0
 801b458:	6078      	str	r0, [r7, #4]
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT;
 801b45a:	687b      	ldr	r3, [r7, #4]
 801b45c:	2205      	movs	r2, #5
 801b45e:	f8c3 2294 	str.w	r2, [r3, #660]	@ 0x294

  /* Start the transfer */
  (void)USBD_LL_PrepareReceive(pdev, 0U, NULL, 0U);
 801b462:	2300      	movs	r3, #0
 801b464:	2200      	movs	r2, #0
 801b466:	2100      	movs	r1, #0
 801b468:	6878      	ldr	r0, [r7, #4]
 801b46a:	f000 fd0b 	bl	801be84 <USBD_LL_PrepareReceive>

  return USBD_OK;
 801b46e:	2300      	movs	r3, #0
}
 801b470:	4618      	mov	r0, r3
 801b472:	3708      	adds	r7, #8
 801b474:	46bd      	mov	sp, r7
 801b476:	bd80      	pop	{r7, pc}

0801b478 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 801b478:	b580      	push	{r7, lr}
 801b47a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */

  /* USER CODE END USB_DEVICE_Init_PreTreatment */

  /* Init Device Library, add supported class and start the library. */
  if (USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS) != USBD_OK)
 801b47c:	2200      	movs	r2, #0
 801b47e:	4912      	ldr	r1, [pc, #72]	@ (801b4c8 <MX_USB_DEVICE_Init+0x50>)
 801b480:	4812      	ldr	r0, [pc, #72]	@ (801b4cc <MX_USB_DEVICE_Init+0x54>)
 801b482:	f7fe fd03 	bl	8019e8c <USBD_Init>
 801b486:	4603      	mov	r3, r0
 801b488:	2b00      	cmp	r3, #0
 801b48a:	d001      	beq.n	801b490 <MX_USB_DEVICE_Init+0x18>
  {
    Error_Handler();
 801b48c:	f7e6 f92a 	bl	80016e4 <Error_Handler>
  }
  if (USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC) != USBD_OK)
 801b490:	490f      	ldr	r1, [pc, #60]	@ (801b4d0 <MX_USB_DEVICE_Init+0x58>)
 801b492:	480e      	ldr	r0, [pc, #56]	@ (801b4cc <MX_USB_DEVICE_Init+0x54>)
 801b494:	f7fe fd2a 	bl	8019eec <USBD_RegisterClass>
 801b498:	4603      	mov	r3, r0
 801b49a:	2b00      	cmp	r3, #0
 801b49c:	d001      	beq.n	801b4a2 <MX_USB_DEVICE_Init+0x2a>
  {
    Error_Handler();
 801b49e:	f7e6 f921 	bl	80016e4 <Error_Handler>
  }
  if (USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS) != USBD_OK)
 801b4a2:	490c      	ldr	r1, [pc, #48]	@ (801b4d4 <MX_USB_DEVICE_Init+0x5c>)
 801b4a4:	4809      	ldr	r0, [pc, #36]	@ (801b4cc <MX_USB_DEVICE_Init+0x54>)
 801b4a6:	f7fe fc21 	bl	8019cec <USBD_CDC_RegisterInterface>
 801b4aa:	4603      	mov	r3, r0
 801b4ac:	2b00      	cmp	r3, #0
 801b4ae:	d001      	beq.n	801b4b4 <MX_USB_DEVICE_Init+0x3c>
  {
    Error_Handler();
 801b4b0:	f7e6 f918 	bl	80016e4 <Error_Handler>
  }
  if (USBD_Start(&hUsbDeviceFS) != USBD_OK)
 801b4b4:	4805      	ldr	r0, [pc, #20]	@ (801b4cc <MX_USB_DEVICE_Init+0x54>)
 801b4b6:	f7fe fd4f 	bl	8019f58 <USBD_Start>
 801b4ba:	4603      	mov	r3, r0
 801b4bc:	2b00      	cmp	r3, #0
 801b4be:	d001      	beq.n	801b4c4 <MX_USB_DEVICE_Init+0x4c>
  {
    Error_Handler();
 801b4c0:	f7e6 f910 	bl	80016e4 <Error_Handler>
  }

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */

  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 801b4c4:	bf00      	nop
 801b4c6:	bd80      	pop	{r7, pc}
 801b4c8:	20000154 	.word	0x20000154
 801b4cc:	2000a8d8 	.word	0x2000a8d8
 801b4d0:	200000b8 	.word	0x200000b8
 801b4d4:	20000140 	.word	0x20000140

0801b4d8 <CDC_Init_FS>:
/**
  * @brief  Initializes the CDC media low layer over the FS USB IP
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Init_FS(void)
{
 801b4d8:	b580      	push	{r7, lr}
 801b4da:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 3 */
  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
 801b4dc:	2200      	movs	r2, #0
 801b4de:	4905      	ldr	r1, [pc, #20]	@ (801b4f4 <CDC_Init_FS+0x1c>)
 801b4e0:	4805      	ldr	r0, [pc, #20]	@ (801b4f8 <CDC_Init_FS+0x20>)
 801b4e2:	f7fe fc1d 	bl	8019d20 <USBD_CDC_SetTxBuffer>
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
 801b4e6:	4905      	ldr	r1, [pc, #20]	@ (801b4fc <CDC_Init_FS+0x24>)
 801b4e8:	4803      	ldr	r0, [pc, #12]	@ (801b4f8 <CDC_Init_FS+0x20>)
 801b4ea:	f7fe fc3b 	bl	8019d64 <USBD_CDC_SetRxBuffer>
  return (USBD_OK);
 801b4ee:	2300      	movs	r3, #0
  /* USER CODE END 3 */
}
 801b4f0:	4618      	mov	r0, r3
 801b4f2:	bd80      	pop	{r7, pc}
 801b4f4:	2000b3b4 	.word	0x2000b3b4
 801b4f8:	2000a8d8 	.word	0x2000a8d8
 801b4fc:	2000abb4 	.word	0x2000abb4

0801b500 <CDC_DeInit_FS>:
/**
  * @brief  DeInitializes the CDC media low layer
  * @retval USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_DeInit_FS(void)
{
 801b500:	b480      	push	{r7}
 801b502:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 4 */
  return (USBD_OK);
 801b504:	2300      	movs	r3, #0
  /* USER CODE END 4 */
}
 801b506:	4618      	mov	r0, r3
 801b508:	46bd      	mov	sp, r7
 801b50a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b50e:	4770      	bx	lr

0801b510 <CDC_Control_FS>:
  * @param  pbuf: Buffer containing command data (request parameters)
  * @param  length: Number of data to be sent (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)
{
 801b510:	b480      	push	{r7}
 801b512:	b083      	sub	sp, #12
 801b514:	af00      	add	r7, sp, #0
 801b516:	4603      	mov	r3, r0
 801b518:	6039      	str	r1, [r7, #0]
 801b51a:	71fb      	strb	r3, [r7, #7]
 801b51c:	4613      	mov	r3, r2
 801b51e:	80bb      	strh	r3, [r7, #4]
  /* USER CODE BEGIN 5 */
  switch(cmd)
 801b520:	79fb      	ldrb	r3, [r7, #7]
 801b522:	2b23      	cmp	r3, #35	@ 0x23
 801b524:	f200 80a3 	bhi.w	801b66e <CDC_Control_FS+0x15e>
 801b528:	a201      	add	r2, pc, #4	@ (adr r2, 801b530 <CDC_Control_FS+0x20>)
 801b52a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801b52e:	bf00      	nop
 801b530:	0801b66f 	.word	0x0801b66f
 801b534:	0801b66f 	.word	0x0801b66f
 801b538:	0801b66f 	.word	0x0801b66f
 801b53c:	0801b66f 	.word	0x0801b66f
 801b540:	0801b66f 	.word	0x0801b66f
 801b544:	0801b66f 	.word	0x0801b66f
 801b548:	0801b66f 	.word	0x0801b66f
 801b54c:	0801b66f 	.word	0x0801b66f
 801b550:	0801b66f 	.word	0x0801b66f
 801b554:	0801b66f 	.word	0x0801b66f
 801b558:	0801b66f 	.word	0x0801b66f
 801b55c:	0801b66f 	.word	0x0801b66f
 801b560:	0801b66f 	.word	0x0801b66f
 801b564:	0801b66f 	.word	0x0801b66f
 801b568:	0801b66f 	.word	0x0801b66f
 801b56c:	0801b66f 	.word	0x0801b66f
 801b570:	0801b66f 	.word	0x0801b66f
 801b574:	0801b66f 	.word	0x0801b66f
 801b578:	0801b66f 	.word	0x0801b66f
 801b57c:	0801b66f 	.word	0x0801b66f
 801b580:	0801b66f 	.word	0x0801b66f
 801b584:	0801b66f 	.word	0x0801b66f
 801b588:	0801b66f 	.word	0x0801b66f
 801b58c:	0801b66f 	.word	0x0801b66f
 801b590:	0801b66f 	.word	0x0801b66f
 801b594:	0801b66f 	.word	0x0801b66f
 801b598:	0801b66f 	.word	0x0801b66f
 801b59c:	0801b66f 	.word	0x0801b66f
 801b5a0:	0801b66f 	.word	0x0801b66f
 801b5a4:	0801b66f 	.word	0x0801b66f
 801b5a8:	0801b66f 	.word	0x0801b66f
 801b5ac:	0801b66f 	.word	0x0801b66f
 801b5b0:	0801b5c1 	.word	0x0801b5c1
 801b5b4:	0801b61b 	.word	0x0801b61b
 801b5b8:	0801b66f 	.word	0x0801b66f
 801b5bc:	0801b66f 	.word	0x0801b66f
  /*                                        3 - Mark                             */
  /*                                        4 - Space                            */
  /* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          */
  /*******************************************************************************/
    case CDC_SET_LINE_CODING:
    	Linecoding.bitrate = (uint32_t)(pbuf[0]);
 801b5c0:	683b      	ldr	r3, [r7, #0]
 801b5c2:	781b      	ldrb	r3, [r3, #0]
 801b5c4:	461a      	mov	r2, r3
 801b5c6:	4b2e      	ldr	r3, [pc, #184]	@ (801b680 <CDC_Control_FS+0x170>)
 801b5c8:	601a      	str	r2, [r3, #0]
    	Linecoding.bitrate |= (uint32_t)(pbuf[1]<<8);
 801b5ca:	4b2d      	ldr	r3, [pc, #180]	@ (801b680 <CDC_Control_FS+0x170>)
 801b5cc:	681a      	ldr	r2, [r3, #0]
 801b5ce:	683b      	ldr	r3, [r7, #0]
 801b5d0:	3301      	adds	r3, #1
 801b5d2:	781b      	ldrb	r3, [r3, #0]
 801b5d4:	021b      	lsls	r3, r3, #8
 801b5d6:	4313      	orrs	r3, r2
 801b5d8:	4a29      	ldr	r2, [pc, #164]	@ (801b680 <CDC_Control_FS+0x170>)
 801b5da:	6013      	str	r3, [r2, #0]
    	Linecoding.bitrate |= (uint32_t)(pbuf[2]<<16);
 801b5dc:	4b28      	ldr	r3, [pc, #160]	@ (801b680 <CDC_Control_FS+0x170>)
 801b5de:	681a      	ldr	r2, [r3, #0]
 801b5e0:	683b      	ldr	r3, [r7, #0]
 801b5e2:	3302      	adds	r3, #2
 801b5e4:	781b      	ldrb	r3, [r3, #0]
 801b5e6:	041b      	lsls	r3, r3, #16
 801b5e8:	4313      	orrs	r3, r2
 801b5ea:	4a25      	ldr	r2, [pc, #148]	@ (801b680 <CDC_Control_FS+0x170>)
 801b5ec:	6013      	str	r3, [r2, #0]
    	Linecoding.bitrate |= (uint32_t)(pbuf[3]<<24);
 801b5ee:	4b24      	ldr	r3, [pc, #144]	@ (801b680 <CDC_Control_FS+0x170>)
 801b5f0:	681a      	ldr	r2, [r3, #0]
 801b5f2:	683b      	ldr	r3, [r7, #0]
 801b5f4:	3303      	adds	r3, #3
 801b5f6:	781b      	ldrb	r3, [r3, #0]
 801b5f8:	061b      	lsls	r3, r3, #24
 801b5fa:	4313      	orrs	r3, r2
 801b5fc:	4a20      	ldr	r2, [pc, #128]	@ (801b680 <CDC_Control_FS+0x170>)
 801b5fe:	6013      	str	r3, [r2, #0]
    	Linecoding.format = pbuf[4];
 801b600:	683b      	ldr	r3, [r7, #0]
 801b602:	791a      	ldrb	r2, [r3, #4]
 801b604:	4b1e      	ldr	r3, [pc, #120]	@ (801b680 <CDC_Control_FS+0x170>)
 801b606:	711a      	strb	r2, [r3, #4]
    	Linecoding.paritytype = pbuf[5];
 801b608:	683b      	ldr	r3, [r7, #0]
 801b60a:	795a      	ldrb	r2, [r3, #5]
 801b60c:	4b1c      	ldr	r3, [pc, #112]	@ (801b680 <CDC_Control_FS+0x170>)
 801b60e:	715a      	strb	r2, [r3, #5]
    	Linecoding.datatype = pbuf[6];
 801b610:	683b      	ldr	r3, [r7, #0]
 801b612:	799a      	ldrb	r2, [r3, #6]
 801b614:	4b1a      	ldr	r3, [pc, #104]	@ (801b680 <CDC_Control_FS+0x170>)
 801b616:	719a      	strb	r2, [r3, #6]
    break;
 801b618:	e02a      	b.n	801b670 <CDC_Control_FS+0x160>

    case CDC_GET_LINE_CODING:
      pbuf[0] = (uint8_t)(Linecoding.bitrate);
 801b61a:	4b19      	ldr	r3, [pc, #100]	@ (801b680 <CDC_Control_FS+0x170>)
 801b61c:	681b      	ldr	r3, [r3, #0]
 801b61e:	b2da      	uxtb	r2, r3
 801b620:	683b      	ldr	r3, [r7, #0]
 801b622:	701a      	strb	r2, [r3, #0]
      pbuf[1] = (uint8_t)(Linecoding.bitrate>>8);
 801b624:	4b16      	ldr	r3, [pc, #88]	@ (801b680 <CDC_Control_FS+0x170>)
 801b626:	681b      	ldr	r3, [r3, #0]
 801b628:	0a1a      	lsrs	r2, r3, #8
 801b62a:	683b      	ldr	r3, [r7, #0]
 801b62c:	3301      	adds	r3, #1
 801b62e:	b2d2      	uxtb	r2, r2
 801b630:	701a      	strb	r2, [r3, #0]
      pbuf[2] = (uint8_t)(Linecoding.bitrate>>16);
 801b632:	4b13      	ldr	r3, [pc, #76]	@ (801b680 <CDC_Control_FS+0x170>)
 801b634:	681b      	ldr	r3, [r3, #0]
 801b636:	0c1a      	lsrs	r2, r3, #16
 801b638:	683b      	ldr	r3, [r7, #0]
 801b63a:	3302      	adds	r3, #2
 801b63c:	b2d2      	uxtb	r2, r2
 801b63e:	701a      	strb	r2, [r3, #0]
      pbuf[3] = (uint8_t)(Linecoding.bitrate>>24);
 801b640:	4b0f      	ldr	r3, [pc, #60]	@ (801b680 <CDC_Control_FS+0x170>)
 801b642:	681b      	ldr	r3, [r3, #0]
 801b644:	0e1a      	lsrs	r2, r3, #24
 801b646:	683b      	ldr	r3, [r7, #0]
 801b648:	3303      	adds	r3, #3
 801b64a:	b2d2      	uxtb	r2, r2
 801b64c:	701a      	strb	r2, [r3, #0]
      pbuf[4] = Linecoding.format;
 801b64e:	683b      	ldr	r3, [r7, #0]
 801b650:	3304      	adds	r3, #4
 801b652:	4a0b      	ldr	r2, [pc, #44]	@ (801b680 <CDC_Control_FS+0x170>)
 801b654:	7912      	ldrb	r2, [r2, #4]
 801b656:	701a      	strb	r2, [r3, #0]
      pbuf[5] = Linecoding.paritytype;
 801b658:	683b      	ldr	r3, [r7, #0]
 801b65a:	3305      	adds	r3, #5
 801b65c:	4a08      	ldr	r2, [pc, #32]	@ (801b680 <CDC_Control_FS+0x170>)
 801b65e:	7952      	ldrb	r2, [r2, #5]
 801b660:	701a      	strb	r2, [r3, #0]
      pbuf[6] = Linecoding.datatype;
 801b662:	683b      	ldr	r3, [r7, #0]
 801b664:	3306      	adds	r3, #6
 801b666:	4a06      	ldr	r2, [pc, #24]	@ (801b680 <CDC_Control_FS+0x170>)
 801b668:	7992      	ldrb	r2, [r2, #6]
 801b66a:	701a      	strb	r2, [r3, #0]
    break;
 801b66c:	e000      	b.n	801b670 <CDC_Control_FS+0x160>
    case CDC_SEND_BREAK:

    break;

  default:
    break;
 801b66e:	bf00      	nop
  }

  return (USBD_OK);
 801b670:	2300      	movs	r3, #0
  /* USER CODE END 5 */
}
 801b672:	4618      	mov	r0, r3
 801b674:	370c      	adds	r7, #12
 801b676:	46bd      	mov	sp, r7
 801b678:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b67c:	4770      	bx	lr
 801b67e:	bf00      	nop
 801b680:	20000138 	.word	0x20000138

0801b684 <CDC_Receive_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
 801b684:	b580      	push	{r7, lr}
 801b686:	b084      	sub	sp, #16
 801b688:	af00      	add	r7, sp, #0
 801b68a:	6078      	str	r0, [r7, #4]
 801b68c:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN 6 */
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);
 801b68e:	6879      	ldr	r1, [r7, #4]
 801b690:	480e      	ldr	r0, [pc, #56]	@ (801b6cc <CDC_Receive_FS+0x48>)
 801b692:	f7fe fb67 	bl	8019d64 <USBD_CDC_SetRxBuffer>
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
 801b696:	480d      	ldr	r0, [pc, #52]	@ (801b6cc <CDC_Receive_FS+0x48>)
 801b698:	f7fe fbc2 	bl	8019e20 <USBD_CDC_ReceivePacket>

  for(int i=0; i<*Len; i++)
 801b69c:	2300      	movs	r3, #0
 801b69e:	60fb      	str	r3, [r7, #12]
 801b6a0:	e009      	b.n	801b6b6 <CDC_Receive_FS+0x32>
  {
  	cdcDataIn(Buf[i]);
 801b6a2:	68fb      	ldr	r3, [r7, #12]
 801b6a4:	687a      	ldr	r2, [r7, #4]
 801b6a6:	4413      	add	r3, r2
 801b6a8:	781b      	ldrb	r3, [r3, #0]
 801b6aa:	4618      	mov	r0, r3
 801b6ac:	f7e7 f86e 	bl	800278c <cdcDataIn>
  for(int i=0; i<*Len; i++)
 801b6b0:	68fb      	ldr	r3, [r7, #12]
 801b6b2:	3301      	adds	r3, #1
 801b6b4:	60fb      	str	r3, [r7, #12]
 801b6b6:	683b      	ldr	r3, [r7, #0]
 801b6b8:	681a      	ldr	r2, [r3, #0]
 801b6ba:	68fb      	ldr	r3, [r7, #12]
 801b6bc:	429a      	cmp	r2, r3
 801b6be:	d8f0      	bhi.n	801b6a2 <CDC_Receive_FS+0x1e>
  }

  return (USBD_OK);
 801b6c0:	2300      	movs	r3, #0
  /* USER CODE END 6 */
}
 801b6c2:	4618      	mov	r0, r3
 801b6c4:	3710      	adds	r7, #16
 801b6c6:	46bd      	mov	sp, r7
 801b6c8:	bd80      	pop	{r7, pc}
 801b6ca:	bf00      	nop
 801b6cc:	2000a8d8 	.word	0x2000a8d8

0801b6d0 <CDC_Transmit_FS>:
  * @param  Buf: Buffer of data to be sent
  * @param  Len: Number of data to be sent (in bytes)
  * @retval USBD_OK if all operations are OK else USBD_FAIL or USBD_BUSY
  */
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
 801b6d0:	b580      	push	{r7, lr}
 801b6d2:	b084      	sub	sp, #16
 801b6d4:	af00      	add	r7, sp, #0
 801b6d6:	6078      	str	r0, [r7, #4]
 801b6d8:	460b      	mov	r3, r1
 801b6da:	807b      	strh	r3, [r7, #2]
  uint8_t result = USBD_OK;
 801b6dc:	2300      	movs	r3, #0
 801b6de:	73fb      	strb	r3, [r7, #15]
  /* USER CODE BEGIN 7 */
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
 801b6e0:	4b0d      	ldr	r3, [pc, #52]	@ (801b718 <CDC_Transmit_FS+0x48>)
 801b6e2:	f8d3 32bc 	ldr.w	r3, [r3, #700]	@ 0x2bc
 801b6e6:	60bb      	str	r3, [r7, #8]
  if (hcdc->TxState != 0){
 801b6e8:	68bb      	ldr	r3, [r7, #8]
 801b6ea:	f8d3 3214 	ldr.w	r3, [r3, #532]	@ 0x214
 801b6ee:	2b00      	cmp	r3, #0
 801b6f0:	d001      	beq.n	801b6f6 <CDC_Transmit_FS+0x26>
    return USBD_BUSY;
 801b6f2:	2301      	movs	r3, #1
 801b6f4:	e00b      	b.n	801b70e <CDC_Transmit_FS+0x3e>
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
 801b6f6:	887b      	ldrh	r3, [r7, #2]
 801b6f8:	461a      	mov	r2, r3
 801b6fa:	6879      	ldr	r1, [r7, #4]
 801b6fc:	4806      	ldr	r0, [pc, #24]	@ (801b718 <CDC_Transmit_FS+0x48>)
 801b6fe:	f7fe fb0f 	bl	8019d20 <USBD_CDC_SetTxBuffer>
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
 801b702:	4805      	ldr	r0, [pc, #20]	@ (801b718 <CDC_Transmit_FS+0x48>)
 801b704:	f7fe fb4c 	bl	8019da0 <USBD_CDC_TransmitPacket>
 801b708:	4603      	mov	r3, r0
 801b70a:	73fb      	strb	r3, [r7, #15]
  /* USER CODE END 7 */
  return result;
 801b70c:	7bfb      	ldrb	r3, [r7, #15]
}
 801b70e:	4618      	mov	r0, r3
 801b710:	3710      	adds	r7, #16
 801b712:	46bd      	mov	sp, r7
 801b714:	bd80      	pop	{r7, pc}
 801b716:	bf00      	nop
 801b718:	2000a8d8 	.word	0x2000a8d8

0801b71c <CDC_TransmitCplt_FS>:
  * @param  Buf: Buffer of data to be received
  * @param  Len: Number of data received (in bytes)
  * @retval Result of the operation: USBD_OK if all operations are OK else USBD_FAIL
  */
static int8_t CDC_TransmitCplt_FS(uint8_t *Buf, uint32_t *Len, uint8_t epnum)
{
 801b71c:	b480      	push	{r7}
 801b71e:	b087      	sub	sp, #28
 801b720:	af00      	add	r7, sp, #0
 801b722:	60f8      	str	r0, [r7, #12]
 801b724:	60b9      	str	r1, [r7, #8]
 801b726:	4613      	mov	r3, r2
 801b728:	71fb      	strb	r3, [r7, #7]
  uint8_t result = USBD_OK;
 801b72a:	2300      	movs	r3, #0
 801b72c:	75fb      	strb	r3, [r7, #23]
  /* USER CODE BEGIN 13 */
  UNUSED(Buf);
  UNUSED(Len);
  UNUSED(epnum);
  /* USER CODE END 13 */
  return result;
 801b72e:	f997 3017 	ldrsb.w	r3, [r7, #23]
}
 801b732:	4618      	mov	r0, r3
 801b734:	371c      	adds	r7, #28
 801b736:	46bd      	mov	sp, r7
 801b738:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b73c:	4770      	bx	lr
	...

0801b740 <USBD_FS_DeviceDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801b740:	b480      	push	{r7}
 801b742:	b083      	sub	sp, #12
 801b744:	af00      	add	r7, sp, #0
 801b746:	4603      	mov	r3, r0
 801b748:	6039      	str	r1, [r7, #0]
 801b74a:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_FS_DeviceDesc);
 801b74c:	683b      	ldr	r3, [r7, #0]
 801b74e:	2212      	movs	r2, #18
 801b750:	801a      	strh	r2, [r3, #0]
  return USBD_FS_DeviceDesc;
 801b752:	4b03      	ldr	r3, [pc, #12]	@ (801b760 <USBD_FS_DeviceDescriptor+0x20>)
}
 801b754:	4618      	mov	r0, r3
 801b756:	370c      	adds	r7, #12
 801b758:	46bd      	mov	sp, r7
 801b75a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b75e:	4770      	bx	lr
 801b760:	20000170 	.word	0x20000170

0801b764 <USBD_FS_LangIDStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801b764:	b480      	push	{r7}
 801b766:	b083      	sub	sp, #12
 801b768:	af00      	add	r7, sp, #0
 801b76a:	4603      	mov	r3, r0
 801b76c:	6039      	str	r1, [r7, #0]
 801b76e:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);
 801b770:	683b      	ldr	r3, [r7, #0]
 801b772:	2204      	movs	r2, #4
 801b774:	801a      	strh	r2, [r3, #0]
  return USBD_LangIDDesc;
 801b776:	4b03      	ldr	r3, [pc, #12]	@ (801b784 <USBD_FS_LangIDStrDescriptor+0x20>)
}
 801b778:	4618      	mov	r0, r3
 801b77a:	370c      	adds	r7, #12
 801b77c:	46bd      	mov	sp, r7
 801b77e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b782:	4770      	bx	lr
 801b784:	20000184 	.word	0x20000184

0801b788 <USBD_FS_ProductStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801b788:	b580      	push	{r7, lr}
 801b78a:	b082      	sub	sp, #8
 801b78c:	af00      	add	r7, sp, #0
 801b78e:	4603      	mov	r3, r0
 801b790:	6039      	str	r1, [r7, #0]
 801b792:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 801b794:	79fb      	ldrb	r3, [r7, #7]
 801b796:	2b00      	cmp	r3, #0
 801b798:	d105      	bne.n	801b7a6 <USBD_FS_ProductStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 801b79a:	683a      	ldr	r2, [r7, #0]
 801b79c:	4907      	ldr	r1, [pc, #28]	@ (801b7bc <USBD_FS_ProductStrDescriptor+0x34>)
 801b79e:	4808      	ldr	r0, [pc, #32]	@ (801b7c0 <USBD_FS_ProductStrDescriptor+0x38>)
 801b7a0:	f7ff fd8a 	bl	801b2b8 <USBD_GetString>
 801b7a4:	e004      	b.n	801b7b0 <USBD_FS_ProductStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 801b7a6:	683a      	ldr	r2, [r7, #0]
 801b7a8:	4904      	ldr	r1, [pc, #16]	@ (801b7bc <USBD_FS_ProductStrDescriptor+0x34>)
 801b7aa:	4805      	ldr	r0, [pc, #20]	@ (801b7c0 <USBD_FS_ProductStrDescriptor+0x38>)
 801b7ac:	f7ff fd84 	bl	801b2b8 <USBD_GetString>
  }
  return USBD_StrDesc;
 801b7b0:	4b02      	ldr	r3, [pc, #8]	@ (801b7bc <USBD_FS_ProductStrDescriptor+0x34>)
}
 801b7b2:	4618      	mov	r0, r3
 801b7b4:	3708      	adds	r7, #8
 801b7b6:	46bd      	mov	sp, r7
 801b7b8:	bd80      	pop	{r7, pc}
 801b7ba:	bf00      	nop
 801b7bc:	2000bbb4 	.word	0x2000bbb4
 801b7c0:	08024fdc 	.word	0x08024fdc

0801b7c4 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801b7c4:	b580      	push	{r7, lr}
 801b7c6:	b082      	sub	sp, #8
 801b7c8:	af00      	add	r7, sp, #0
 801b7ca:	4603      	mov	r3, r0
 801b7cc:	6039      	str	r1, [r7, #0]
 801b7ce:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 801b7d0:	683a      	ldr	r2, [r7, #0]
 801b7d2:	4904      	ldr	r1, [pc, #16]	@ (801b7e4 <USBD_FS_ManufacturerStrDescriptor+0x20>)
 801b7d4:	4804      	ldr	r0, [pc, #16]	@ (801b7e8 <USBD_FS_ManufacturerStrDescriptor+0x24>)
 801b7d6:	f7ff fd6f 	bl	801b2b8 <USBD_GetString>
  return USBD_StrDesc;
 801b7da:	4b02      	ldr	r3, [pc, #8]	@ (801b7e4 <USBD_FS_ManufacturerStrDescriptor+0x20>)
}
 801b7dc:	4618      	mov	r0, r3
 801b7de:	3708      	adds	r7, #8
 801b7e0:	46bd      	mov	sp, r7
 801b7e2:	bd80      	pop	{r7, pc}
 801b7e4:	2000bbb4 	.word	0x2000bbb4
 801b7e8:	08024ff4 	.word	0x08024ff4

0801b7ec <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801b7ec:	b580      	push	{r7, lr}
 801b7ee:	b082      	sub	sp, #8
 801b7f0:	af00      	add	r7, sp, #0
 801b7f2:	4603      	mov	r3, r0
 801b7f4:	6039      	str	r1, [r7, #0]
 801b7f6:	71fb      	strb	r3, [r7, #7]
  UNUSED(speed);
  *length = USB_SIZ_STRING_SERIAL;
 801b7f8:	683b      	ldr	r3, [r7, #0]
 801b7fa:	221a      	movs	r2, #26
 801b7fc:	801a      	strh	r2, [r3, #0]

  /* Update the serial number string descriptor with the data from the unique
   * ID */
  Get_SerialNum();
 801b7fe:	f000 f843 	bl	801b888 <Get_SerialNum>
  /* USER CODE BEGIN USBD_FS_SerialStrDescriptor */

  /* USER CODE END USBD_FS_SerialStrDescriptor */
  return (uint8_t *) USBD_StringSerial;
 801b802:	4b02      	ldr	r3, [pc, #8]	@ (801b80c <USBD_FS_SerialStrDescriptor+0x20>)
}
 801b804:	4618      	mov	r0, r3
 801b806:	3708      	adds	r7, #8
 801b808:	46bd      	mov	sp, r7
 801b80a:	bd80      	pop	{r7, pc}
 801b80c:	20000188 	.word	0x20000188

0801b810 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801b810:	b580      	push	{r7, lr}
 801b812:	b082      	sub	sp, #8
 801b814:	af00      	add	r7, sp, #0
 801b816:	4603      	mov	r3, r0
 801b818:	6039      	str	r1, [r7, #0]
 801b81a:	71fb      	strb	r3, [r7, #7]
  if(speed == USBD_SPEED_HIGH)
 801b81c:	79fb      	ldrb	r3, [r7, #7]
 801b81e:	2b00      	cmp	r3, #0
 801b820:	d105      	bne.n	801b82e <USBD_FS_ConfigStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 801b822:	683a      	ldr	r2, [r7, #0]
 801b824:	4907      	ldr	r1, [pc, #28]	@ (801b844 <USBD_FS_ConfigStrDescriptor+0x34>)
 801b826:	4808      	ldr	r0, [pc, #32]	@ (801b848 <USBD_FS_ConfigStrDescriptor+0x38>)
 801b828:	f7ff fd46 	bl	801b2b8 <USBD_GetString>
 801b82c:	e004      	b.n	801b838 <USBD_FS_ConfigStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 801b82e:	683a      	ldr	r2, [r7, #0]
 801b830:	4904      	ldr	r1, [pc, #16]	@ (801b844 <USBD_FS_ConfigStrDescriptor+0x34>)
 801b832:	4805      	ldr	r0, [pc, #20]	@ (801b848 <USBD_FS_ConfigStrDescriptor+0x38>)
 801b834:	f7ff fd40 	bl	801b2b8 <USBD_GetString>
  }
  return USBD_StrDesc;
 801b838:	4b02      	ldr	r3, [pc, #8]	@ (801b844 <USBD_FS_ConfigStrDescriptor+0x34>)
}
 801b83a:	4618      	mov	r0, r3
 801b83c:	3708      	adds	r7, #8
 801b83e:	46bd      	mov	sp, r7
 801b840:	bd80      	pop	{r7, pc}
 801b842:	bf00      	nop
 801b844:	2000bbb4 	.word	0x2000bbb4
 801b848:	08025008 	.word	0x08025008

0801b84c <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 801b84c:	b580      	push	{r7, lr}
 801b84e:	b082      	sub	sp, #8
 801b850:	af00      	add	r7, sp, #0
 801b852:	4603      	mov	r3, r0
 801b854:	6039      	str	r1, [r7, #0]
 801b856:	71fb      	strb	r3, [r7, #7]
  if(speed == 0)
 801b858:	79fb      	ldrb	r3, [r7, #7]
 801b85a:	2b00      	cmp	r3, #0
 801b85c:	d105      	bne.n	801b86a <USBD_FS_InterfaceStrDescriptor+0x1e>
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 801b85e:	683a      	ldr	r2, [r7, #0]
 801b860:	4907      	ldr	r1, [pc, #28]	@ (801b880 <USBD_FS_InterfaceStrDescriptor+0x34>)
 801b862:	4808      	ldr	r0, [pc, #32]	@ (801b884 <USBD_FS_InterfaceStrDescriptor+0x38>)
 801b864:	f7ff fd28 	bl	801b2b8 <USBD_GetString>
 801b868:	e004      	b.n	801b874 <USBD_FS_InterfaceStrDescriptor+0x28>
  }
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 801b86a:	683a      	ldr	r2, [r7, #0]
 801b86c:	4904      	ldr	r1, [pc, #16]	@ (801b880 <USBD_FS_InterfaceStrDescriptor+0x34>)
 801b86e:	4805      	ldr	r0, [pc, #20]	@ (801b884 <USBD_FS_InterfaceStrDescriptor+0x38>)
 801b870:	f7ff fd22 	bl	801b2b8 <USBD_GetString>
  }
  return USBD_StrDesc;
 801b874:	4b02      	ldr	r3, [pc, #8]	@ (801b880 <USBD_FS_InterfaceStrDescriptor+0x34>)
}
 801b876:	4618      	mov	r0, r3
 801b878:	3708      	adds	r7, #8
 801b87a:	46bd      	mov	sp, r7
 801b87c:	bd80      	pop	{r7, pc}
 801b87e:	bf00      	nop
 801b880:	2000bbb4 	.word	0x2000bbb4
 801b884:	08025014 	.word	0x08025014

0801b888 <Get_SerialNum>:
  * @brief  Create the serial number string descriptor
  * @param  None
  * @retval None
  */
static void Get_SerialNum(void)
{
 801b888:	b580      	push	{r7, lr}
 801b88a:	b084      	sub	sp, #16
 801b88c:	af00      	add	r7, sp, #0
  uint32_t deviceserial0;
  uint32_t deviceserial1;
  uint32_t deviceserial2;

  deviceserial0 = *(uint32_t *) DEVICE_ID1;
 801b88e:	4b0f      	ldr	r3, [pc, #60]	@ (801b8cc <Get_SerialNum+0x44>)
 801b890:	681b      	ldr	r3, [r3, #0]
 801b892:	60fb      	str	r3, [r7, #12]
  deviceserial1 = *(uint32_t *) DEVICE_ID2;
 801b894:	4b0e      	ldr	r3, [pc, #56]	@ (801b8d0 <Get_SerialNum+0x48>)
 801b896:	681b      	ldr	r3, [r3, #0]
 801b898:	60bb      	str	r3, [r7, #8]
  deviceserial2 = *(uint32_t *) DEVICE_ID3;
 801b89a:	4b0e      	ldr	r3, [pc, #56]	@ (801b8d4 <Get_SerialNum+0x4c>)
 801b89c:	681b      	ldr	r3, [r3, #0]
 801b89e:	607b      	str	r3, [r7, #4]

  deviceserial0 += deviceserial2;
 801b8a0:	68fa      	ldr	r2, [r7, #12]
 801b8a2:	687b      	ldr	r3, [r7, #4]
 801b8a4:	4413      	add	r3, r2
 801b8a6:	60fb      	str	r3, [r7, #12]

  if (deviceserial0 != 0)
 801b8a8:	68fb      	ldr	r3, [r7, #12]
 801b8aa:	2b00      	cmp	r3, #0
 801b8ac:	d009      	beq.n	801b8c2 <Get_SerialNum+0x3a>
  {
    IntToUnicode(deviceserial0, &USBD_StringSerial[2], 8);
 801b8ae:	2208      	movs	r2, #8
 801b8b0:	4909      	ldr	r1, [pc, #36]	@ (801b8d8 <Get_SerialNum+0x50>)
 801b8b2:	68f8      	ldr	r0, [r7, #12]
 801b8b4:	f000 f814 	bl	801b8e0 <IntToUnicode>
    IntToUnicode(deviceserial1, &USBD_StringSerial[18], 4);
 801b8b8:	2204      	movs	r2, #4
 801b8ba:	4908      	ldr	r1, [pc, #32]	@ (801b8dc <Get_SerialNum+0x54>)
 801b8bc:	68b8      	ldr	r0, [r7, #8]
 801b8be:	f000 f80f 	bl	801b8e0 <IntToUnicode>
  }
}
 801b8c2:	bf00      	nop
 801b8c4:	3710      	adds	r7, #16
 801b8c6:	46bd      	mov	sp, r7
 801b8c8:	bd80      	pop	{r7, pc}
 801b8ca:	bf00      	nop
 801b8cc:	1fff7a10 	.word	0x1fff7a10
 801b8d0:	1fff7a14 	.word	0x1fff7a14
 801b8d4:	1fff7a18 	.word	0x1fff7a18
 801b8d8:	2000018a 	.word	0x2000018a
 801b8dc:	2000019a 	.word	0x2000019a

0801b8e0 <IntToUnicode>:
  * @param  pbuf: pointer to the buffer
  * @param  len: buffer length
  * @retval None
  */
static void IntToUnicode(uint32_t value, uint8_t * pbuf, uint8_t len)
{
 801b8e0:	b480      	push	{r7}
 801b8e2:	b087      	sub	sp, #28
 801b8e4:	af00      	add	r7, sp, #0
 801b8e6:	60f8      	str	r0, [r7, #12]
 801b8e8:	60b9      	str	r1, [r7, #8]
 801b8ea:	4613      	mov	r3, r2
 801b8ec:	71fb      	strb	r3, [r7, #7]
  uint8_t idx = 0;
 801b8ee:	2300      	movs	r3, #0
 801b8f0:	75fb      	strb	r3, [r7, #23]

  for (idx = 0; idx < len; idx++)
 801b8f2:	2300      	movs	r3, #0
 801b8f4:	75fb      	strb	r3, [r7, #23]
 801b8f6:	e027      	b.n	801b948 <IntToUnicode+0x68>
  {
    if (((value >> 28)) < 0xA)
 801b8f8:	68fb      	ldr	r3, [r7, #12]
 801b8fa:	0f1b      	lsrs	r3, r3, #28
 801b8fc:	2b09      	cmp	r3, #9
 801b8fe:	d80b      	bhi.n	801b918 <IntToUnicode+0x38>
    {
      pbuf[2 * idx] = (value >> 28) + '0';
 801b900:	68fb      	ldr	r3, [r7, #12]
 801b902:	0f1b      	lsrs	r3, r3, #28
 801b904:	b2da      	uxtb	r2, r3
 801b906:	7dfb      	ldrb	r3, [r7, #23]
 801b908:	005b      	lsls	r3, r3, #1
 801b90a:	4619      	mov	r1, r3
 801b90c:	68bb      	ldr	r3, [r7, #8]
 801b90e:	440b      	add	r3, r1
 801b910:	3230      	adds	r2, #48	@ 0x30
 801b912:	b2d2      	uxtb	r2, r2
 801b914:	701a      	strb	r2, [r3, #0]
 801b916:	e00a      	b.n	801b92e <IntToUnicode+0x4e>
    }
    else
    {
      pbuf[2 * idx] = (value >> 28) + 'A' - 10;
 801b918:	68fb      	ldr	r3, [r7, #12]
 801b91a:	0f1b      	lsrs	r3, r3, #28
 801b91c:	b2da      	uxtb	r2, r3
 801b91e:	7dfb      	ldrb	r3, [r7, #23]
 801b920:	005b      	lsls	r3, r3, #1
 801b922:	4619      	mov	r1, r3
 801b924:	68bb      	ldr	r3, [r7, #8]
 801b926:	440b      	add	r3, r1
 801b928:	3237      	adds	r2, #55	@ 0x37
 801b92a:	b2d2      	uxtb	r2, r2
 801b92c:	701a      	strb	r2, [r3, #0]
    }

    value = value << 4;
 801b92e:	68fb      	ldr	r3, [r7, #12]
 801b930:	011b      	lsls	r3, r3, #4
 801b932:	60fb      	str	r3, [r7, #12]

    pbuf[2 * idx + 1] = 0;
 801b934:	7dfb      	ldrb	r3, [r7, #23]
 801b936:	005b      	lsls	r3, r3, #1
 801b938:	3301      	adds	r3, #1
 801b93a:	68ba      	ldr	r2, [r7, #8]
 801b93c:	4413      	add	r3, r2
 801b93e:	2200      	movs	r2, #0
 801b940:	701a      	strb	r2, [r3, #0]
  for (idx = 0; idx < len; idx++)
 801b942:	7dfb      	ldrb	r3, [r7, #23]
 801b944:	3301      	adds	r3, #1
 801b946:	75fb      	strb	r3, [r7, #23]
 801b948:	7dfa      	ldrb	r2, [r7, #23]
 801b94a:	79fb      	ldrb	r3, [r7, #7]
 801b94c:	429a      	cmp	r2, r3
 801b94e:	d3d3      	bcc.n	801b8f8 <IntToUnicode+0x18>
  }
}
 801b950:	bf00      	nop
 801b952:	bf00      	nop
 801b954:	371c      	adds	r7, #28
 801b956:	46bd      	mov	sp, r7
 801b958:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b95c:	4770      	bx	lr
	...

0801b960 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 801b960:	b580      	push	{r7, lr}
 801b962:	b08a      	sub	sp, #40	@ 0x28
 801b964:	af00      	add	r7, sp, #0
 801b966:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801b968:	f107 0314 	add.w	r3, r7, #20
 801b96c:	2200      	movs	r2, #0
 801b96e:	601a      	str	r2, [r3, #0]
 801b970:	605a      	str	r2, [r3, #4]
 801b972:	609a      	str	r2, [r3, #8]
 801b974:	60da      	str	r2, [r3, #12]
 801b976:	611a      	str	r2, [r3, #16]
  if(pcdHandle->Instance==USB_OTG_FS)
 801b978:	687b      	ldr	r3, [r7, #4]
 801b97a:	681b      	ldr	r3, [r3, #0]
 801b97c:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 801b980:	d13a      	bne.n	801b9f8 <HAL_PCD_MspInit+0x98>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */

    __HAL_RCC_GPIOA_CLK_ENABLE();
 801b982:	2300      	movs	r3, #0
 801b984:	613b      	str	r3, [r7, #16]
 801b986:	4b1e      	ldr	r3, [pc, #120]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b988:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801b98a:	4a1d      	ldr	r2, [pc, #116]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b98c:	f043 0301 	orr.w	r3, r3, #1
 801b990:	6313      	str	r3, [r2, #48]	@ 0x30
 801b992:	4b1b      	ldr	r3, [pc, #108]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b994:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801b996:	f003 0301 	and.w	r3, r3, #1
 801b99a:	613b      	str	r3, [r7, #16]
 801b99c:	693b      	ldr	r3, [r7, #16]
    /**USB_OTG_FS GPIO Configuration
    PA11     ------> USB_OTG_FS_DM
    PA12     ------> USB_OTG_FS_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 801b99e:	f44f 53c0 	mov.w	r3, #6144	@ 0x1800
 801b9a2:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801b9a4:	2302      	movs	r3, #2
 801b9a6:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801b9a8:	2300      	movs	r3, #0
 801b9aa:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 801b9ac:	2303      	movs	r3, #3
 801b9ae:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 801b9b0:	230a      	movs	r3, #10
 801b9b2:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801b9b4:	f107 0314 	add.w	r3, r7, #20
 801b9b8:	4619      	mov	r1, r3
 801b9ba:	4812      	ldr	r0, [pc, #72]	@ (801ba04 <HAL_PCD_MspInit+0xa4>)
 801b9bc:	f7ee fa38 	bl	8009e30 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 801b9c0:	4b0f      	ldr	r3, [pc, #60]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b9c2:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801b9c4:	4a0e      	ldr	r2, [pc, #56]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b9c6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801b9ca:	6353      	str	r3, [r2, #52]	@ 0x34
 801b9cc:	2300      	movs	r3, #0
 801b9ce:	60fb      	str	r3, [r7, #12]
 801b9d0:	4b0b      	ldr	r3, [pc, #44]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b9d2:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801b9d4:	4a0a      	ldr	r2, [pc, #40]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b9d6:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 801b9da:	6453      	str	r3, [r2, #68]	@ 0x44
 801b9dc:	4b08      	ldr	r3, [pc, #32]	@ (801ba00 <HAL_PCD_MspInit+0xa0>)
 801b9de:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 801b9e0:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 801b9e4:	60fb      	str	r3, [r7, #12]
 801b9e6:	68fb      	ldr	r3, [r7, #12]

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 6, 0);
 801b9e8:	2200      	movs	r2, #0
 801b9ea:	2106      	movs	r1, #6
 801b9ec:	2043      	movs	r0, #67	@ 0x43
 801b9ee:	f7ed fa78 	bl	8008ee2 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 801b9f2:	2043      	movs	r0, #67	@ 0x43
 801b9f4:	f7ed fa91 	bl	8008f1a <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 801b9f8:	bf00      	nop
 801b9fa:	3728      	adds	r7, #40	@ 0x28
 801b9fc:	46bd      	mov	sp, r7
 801b9fe:	bd80      	pop	{r7, pc}
 801ba00:	40023800 	.word	0x40023800
 801ba04:	40020000 	.word	0x40020000

0801ba08 <HAL_PCD_SetupStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801ba08:	b580      	push	{r7, lr}
 801ba0a:	b082      	sub	sp, #8
 801ba0c:	af00      	add	r7, sp, #0
 801ba0e:	6078      	str	r0, [r7, #4]
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 801ba10:	687b      	ldr	r3, [r7, #4]
 801ba12:	f8d3 24e0 	ldr.w	r2, [r3, #1248]	@ 0x4e0
 801ba16:	687b      	ldr	r3, [r7, #4]
 801ba18:	f203 439c 	addw	r3, r3, #1180	@ 0x49c
 801ba1c:	4619      	mov	r1, r3
 801ba1e:	4610      	mov	r0, r2
 801ba20:	f7fe fae7 	bl	8019ff2 <USBD_LL_SetupStage>
}
 801ba24:	bf00      	nop
 801ba26:	3708      	adds	r7, #8
 801ba28:	46bd      	mov	sp, r7
 801ba2a:	bd80      	pop	{r7, pc}

0801ba2c <HAL_PCD_DataOutStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801ba2c:	b580      	push	{r7, lr}
 801ba2e:	b082      	sub	sp, #8
 801ba30:	af00      	add	r7, sp, #0
 801ba32:	6078      	str	r0, [r7, #4]
 801ba34:	460b      	mov	r3, r1
 801ba36:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 801ba38:	687b      	ldr	r3, [r7, #4]
 801ba3a:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 801ba3e:	78fa      	ldrb	r2, [r7, #3]
 801ba40:	6879      	ldr	r1, [r7, #4]
 801ba42:	4613      	mov	r3, r2
 801ba44:	00db      	lsls	r3, r3, #3
 801ba46:	4413      	add	r3, r2
 801ba48:	009b      	lsls	r3, r3, #2
 801ba4a:	440b      	add	r3, r1
 801ba4c:	f503 7318 	add.w	r3, r3, #608	@ 0x260
 801ba50:	681a      	ldr	r2, [r3, #0]
 801ba52:	78fb      	ldrb	r3, [r7, #3]
 801ba54:	4619      	mov	r1, r3
 801ba56:	f7fe fb21 	bl	801a09c <USBD_LL_DataOutStage>
}
 801ba5a:	bf00      	nop
 801ba5c:	3708      	adds	r7, #8
 801ba5e:	46bd      	mov	sp, r7
 801ba60:	bd80      	pop	{r7, pc}

0801ba62 <HAL_PCD_DataInStageCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801ba62:	b580      	push	{r7, lr}
 801ba64:	b082      	sub	sp, #8
 801ba66:	af00      	add	r7, sp, #0
 801ba68:	6078      	str	r0, [r7, #4]
 801ba6a:	460b      	mov	r3, r1
 801ba6c:	70fb      	strb	r3, [r7, #3]
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 801ba6e:	687b      	ldr	r3, [r7, #4]
 801ba70:	f8d3 04e0 	ldr.w	r0, [r3, #1248]	@ 0x4e0
 801ba74:	78fa      	ldrb	r2, [r7, #3]
 801ba76:	6879      	ldr	r1, [r7, #4]
 801ba78:	4613      	mov	r3, r2
 801ba7a:	00db      	lsls	r3, r3, #3
 801ba7c:	4413      	add	r3, r2
 801ba7e:	009b      	lsls	r3, r3, #2
 801ba80:	440b      	add	r3, r1
 801ba82:	3320      	adds	r3, #32
 801ba84:	681a      	ldr	r2, [r3, #0]
 801ba86:	78fb      	ldrb	r3, [r7, #3]
 801ba88:	4619      	mov	r1, r3
 801ba8a:	f7fe fbba 	bl	801a202 <USBD_LL_DataInStage>
}
 801ba8e:	bf00      	nop
 801ba90:	3708      	adds	r7, #8
 801ba92:	46bd      	mov	sp, r7
 801ba94:	bd80      	pop	{r7, pc}

0801ba96 <HAL_PCD_SOFCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801ba96:	b580      	push	{r7, lr}
 801ba98:	b082      	sub	sp, #8
 801ba9a:	af00      	add	r7, sp, #0
 801ba9c:	6078      	str	r0, [r7, #4]
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 801ba9e:	687b      	ldr	r3, [r7, #4]
 801baa0:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801baa4:	4618      	mov	r0, r3
 801baa6:	f7fe fcf4 	bl	801a492 <USBD_LL_SOF>
}
 801baaa:	bf00      	nop
 801baac:	3708      	adds	r7, #8
 801baae:	46bd      	mov	sp, r7
 801bab0:	bd80      	pop	{r7, pc}

0801bab2 <HAL_PCD_ResetCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801bab2:	b580      	push	{r7, lr}
 801bab4:	b084      	sub	sp, #16
 801bab6:	af00      	add	r7, sp, #0
 801bab8:	6078      	str	r0, [r7, #4]
   USBD_SpeedTypeDef speed = USBD_SPEED_FULL;
 801baba:	2301      	movs	r3, #1
 801babc:	73fb      	strb	r3, [r7, #15]

  if ( hpcd->Init.speed != PCD_SPEED_FULL)
 801babe:	687b      	ldr	r3, [r7, #4]
 801bac0:	79db      	ldrb	r3, [r3, #7]
 801bac2:	2b02      	cmp	r3, #2
 801bac4:	d001      	beq.n	801baca <HAL_PCD_ResetCallback+0x18>
  {
    Error_Handler();
 801bac6:	f7e5 fe0d 	bl	80016e4 <Error_Handler>
  }
    /* Set Speed. */
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 801baca:	687b      	ldr	r3, [r7, #4]
 801bacc:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bad0:	7bfa      	ldrb	r2, [r7, #15]
 801bad2:	4611      	mov	r1, r2
 801bad4:	4618      	mov	r0, r3
 801bad6:	f7fe fc98 	bl	801a40a <USBD_LL_SetSpeed>

  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 801bada:	687b      	ldr	r3, [r7, #4]
 801badc:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bae0:	4618      	mov	r0, r3
 801bae2:	f7fe fc40 	bl	801a366 <USBD_LL_Reset>
}
 801bae6:	bf00      	nop
 801bae8:	3710      	adds	r7, #16
 801baea:	46bd      	mov	sp, r7
 801baec:	bd80      	pop	{r7, pc}
	...

0801baf0 <HAL_PCD_SuspendCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801baf0:	b580      	push	{r7, lr}
 801baf2:	b082      	sub	sp, #8
 801baf4:	af00      	add	r7, sp, #0
 801baf6:	6078      	str	r0, [r7, #4]
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 801baf8:	687b      	ldr	r3, [r7, #4]
 801bafa:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bafe:	4618      	mov	r0, r3
 801bb00:	f7fe fc93 	bl	801a42a <USBD_LL_Suspend>
  __HAL_PCD_GATE_PHYCLOCK(hpcd);
 801bb04:	687b      	ldr	r3, [r7, #4]
 801bb06:	681b      	ldr	r3, [r3, #0]
 801bb08:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 801bb0c:	681b      	ldr	r3, [r3, #0]
 801bb0e:	687a      	ldr	r2, [r7, #4]
 801bb10:	6812      	ldr	r2, [r2, #0]
 801bb12:	f502 6260 	add.w	r2, r2, #3584	@ 0xe00
 801bb16:	f043 0301 	orr.w	r3, r3, #1
 801bb1a:	6013      	str	r3, [r2, #0]
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 801bb1c:	687b      	ldr	r3, [r7, #4]
 801bb1e:	7adb      	ldrb	r3, [r3, #11]
 801bb20:	2b00      	cmp	r3, #0
 801bb22:	d005      	beq.n	801bb30 <HAL_PCD_SuspendCallback+0x40>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 801bb24:	4b04      	ldr	r3, [pc, #16]	@ (801bb38 <HAL_PCD_SuspendCallback+0x48>)
 801bb26:	691b      	ldr	r3, [r3, #16]
 801bb28:	4a03      	ldr	r2, [pc, #12]	@ (801bb38 <HAL_PCD_SuspendCallback+0x48>)
 801bb2a:	f043 0306 	orr.w	r3, r3, #6
 801bb2e:	6113      	str	r3, [r2, #16]
  }
  /* USER CODE END 2 */
}
 801bb30:	bf00      	nop
 801bb32:	3708      	adds	r7, #8
 801bb34:	46bd      	mov	sp, r7
 801bb36:	bd80      	pop	{r7, pc}
 801bb38:	e000ed00 	.word	0xe000ed00

0801bb3c <HAL_PCD_ResumeCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801bb3c:	b580      	push	{r7, lr}
 801bb3e:	b082      	sub	sp, #8
 801bb40:	af00      	add	r7, sp, #0
 801bb42:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 801bb44:	687b      	ldr	r3, [r7, #4]
 801bb46:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bb4a:	4618      	mov	r0, r3
 801bb4c:	f7fe fc89 	bl	801a462 <USBD_LL_Resume>
}
 801bb50:	bf00      	nop
 801bb52:	3708      	adds	r7, #8
 801bb54:	46bd      	mov	sp, r7
 801bb56:	bd80      	pop	{r7, pc}

0801bb58 <HAL_PCD_ISOOUTIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801bb58:	b580      	push	{r7, lr}
 801bb5a:	b082      	sub	sp, #8
 801bb5c:	af00      	add	r7, sp, #0
 801bb5e:	6078      	str	r0, [r7, #4]
 801bb60:	460b      	mov	r3, r1
 801bb62:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoOUTIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 801bb64:	687b      	ldr	r3, [r7, #4]
 801bb66:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bb6a:	78fa      	ldrb	r2, [r7, #3]
 801bb6c:	4611      	mov	r1, r2
 801bb6e:	4618      	mov	r0, r3
 801bb70:	f7fe fce1 	bl	801a536 <USBD_LL_IsoOUTIncomplete>
}
 801bb74:	bf00      	nop
 801bb76:	3708      	adds	r7, #8
 801bb78:	46bd      	mov	sp, r7
 801bb7a:	bd80      	pop	{r7, pc}

0801bb7c <HAL_PCD_ISOINIncompleteCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#else
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801bb7c:	b580      	push	{r7, lr}
 801bb7e:	b082      	sub	sp, #8
 801bb80:	af00      	add	r7, sp, #0
 801bb82:	6078      	str	r0, [r7, #4]
 801bb84:	460b      	mov	r3, r1
 801bb86:	70fb      	strb	r3, [r7, #3]
  USBD_LL_IsoINIncomplete((USBD_HandleTypeDef*)hpcd->pData, epnum);
 801bb88:	687b      	ldr	r3, [r7, #4]
 801bb8a:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bb8e:	78fa      	ldrb	r2, [r7, #3]
 801bb90:	4611      	mov	r1, r2
 801bb92:	4618      	mov	r0, r3
 801bb94:	f7fe fc9d 	bl	801a4d2 <USBD_LL_IsoINIncomplete>
}
 801bb98:	bf00      	nop
 801bb9a:	3708      	adds	r7, #8
 801bb9c:	46bd      	mov	sp, r7
 801bb9e:	bd80      	pop	{r7, pc}

0801bba0 <HAL_PCD_ConnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801bba0:	b580      	push	{r7, lr}
 801bba2:	b082      	sub	sp, #8
 801bba4:	af00      	add	r7, sp, #0
 801bba6:	6078      	str	r0, [r7, #4]
  USBD_LL_DevConnected((USBD_HandleTypeDef*)hpcd->pData);
 801bba8:	687b      	ldr	r3, [r7, #4]
 801bbaa:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bbae:	4618      	mov	r0, r3
 801bbb0:	f7fe fcf3 	bl	801a59a <USBD_LL_DevConnected>
}
 801bbb4:	bf00      	nop
 801bbb6:	3708      	adds	r7, #8
 801bbb8:	46bd      	mov	sp, r7
 801bbba:	bd80      	pop	{r7, pc}

0801bbbc <HAL_PCD_DisconnectCallback>:
#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)
static void PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#else
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd)
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
{
 801bbbc:	b580      	push	{r7, lr}
 801bbbe:	b082      	sub	sp, #8
 801bbc0:	af00      	add	r7, sp, #0
 801bbc2:	6078      	str	r0, [r7, #4]
  USBD_LL_DevDisconnected((USBD_HandleTypeDef*)hpcd->pData);
 801bbc4:	687b      	ldr	r3, [r7, #4]
 801bbc6:	f8d3 34e0 	ldr.w	r3, [r3, #1248]	@ 0x4e0
 801bbca:	4618      	mov	r0, r3
 801bbcc:	f7fe fcf0 	bl	801a5b0 <USBD_LL_DevDisconnected>
}
 801bbd0:	bf00      	nop
 801bbd2:	3708      	adds	r7, #8
 801bbd4:	46bd      	mov	sp, r7
 801bbd6:	bd80      	pop	{r7, pc}

0801bbd8 <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 801bbd8:	b580      	push	{r7, lr}
 801bbda:	b082      	sub	sp, #8
 801bbdc:	af00      	add	r7, sp, #0
 801bbde:	6078      	str	r0, [r7, #4]
  /* Init USB Ip. */
  if (pdev->id == DEVICE_FS) {
 801bbe0:	687b      	ldr	r3, [r7, #4]
 801bbe2:	781b      	ldrb	r3, [r3, #0]
 801bbe4:	2b00      	cmp	r3, #0
 801bbe6:	d13c      	bne.n	801bc62 <USBD_LL_Init+0x8a>
  /* Link the driver to the stack. */
  hpcd_USB_OTG_FS.pData = pdev;
 801bbe8:	4a20      	ldr	r2, [pc, #128]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bbea:	687b      	ldr	r3, [r7, #4]
 801bbec:	f8c2 34e0 	str.w	r3, [r2, #1248]	@ 0x4e0
  pdev->pData = &hpcd_USB_OTG_FS;
 801bbf0:	687b      	ldr	r3, [r7, #4]
 801bbf2:	4a1e      	ldr	r2, [pc, #120]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bbf4:	f8c3 22c8 	str.w	r2, [r3, #712]	@ 0x2c8

  hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
 801bbf8:	4b1c      	ldr	r3, [pc, #112]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bbfa:	f04f 42a0 	mov.w	r2, #1342177280	@ 0x50000000
 801bbfe:	601a      	str	r2, [r3, #0]
  hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
 801bc00:	4b1a      	ldr	r3, [pc, #104]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc02:	2204      	movs	r2, #4
 801bc04:	711a      	strb	r2, [r3, #4]
  hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
 801bc06:	4b19      	ldr	r3, [pc, #100]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc08:	2202      	movs	r2, #2
 801bc0a:	71da      	strb	r2, [r3, #7]
  hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 801bc0c:	4b17      	ldr	r3, [pc, #92]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc0e:	2200      	movs	r2, #0
 801bc10:	719a      	strb	r2, [r3, #6]
  hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 801bc12:	4b16      	ldr	r3, [pc, #88]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc14:	2202      	movs	r2, #2
 801bc16:	725a      	strb	r2, [r3, #9]
  hpcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 801bc18:	4b14      	ldr	r3, [pc, #80]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc1a:	2200      	movs	r2, #0
 801bc1c:	729a      	strb	r2, [r3, #10]
  hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
 801bc1e:	4b13      	ldr	r3, [pc, #76]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc20:	2200      	movs	r2, #0
 801bc22:	72da      	strb	r2, [r3, #11]
  hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
 801bc24:	4b11      	ldr	r3, [pc, #68]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc26:	2200      	movs	r2, #0
 801bc28:	731a      	strb	r2, [r3, #12]
  hpcd_USB_OTG_FS.Init.vbus_sensing_enable = DISABLE;
 801bc2a:	4b10      	ldr	r3, [pc, #64]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc2c:	2200      	movs	r2, #0
 801bc2e:	739a      	strb	r2, [r3, #14]
  hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
 801bc30:	4b0e      	ldr	r3, [pc, #56]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc32:	2200      	movs	r2, #0
 801bc34:	73da      	strb	r2, [r3, #15]
  if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
 801bc36:	480d      	ldr	r0, [pc, #52]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc38:	f7f2 f826 	bl	800dc88 <HAL_PCD_Init>
 801bc3c:	4603      	mov	r3, r0
 801bc3e:	2b00      	cmp	r3, #0
 801bc40:	d001      	beq.n	801bc46 <USBD_LL_Init+0x6e>
  {
    Error_Handler( );
 801bc42:	f7e5 fd4f 	bl	80016e4 <Error_Handler>
  HAL_PCD_RegisterDataOutStageCallback(&hpcd_USB_OTG_FS, PCD_DataOutStageCallback);
  HAL_PCD_RegisterDataInStageCallback(&hpcd_USB_OTG_FS, PCD_DataInStageCallback);
  HAL_PCD_RegisterIsoOutIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOOUTIncompleteCallback);
  HAL_PCD_RegisterIsoInIncpltCallback(&hpcd_USB_OTG_FS, PCD_ISOINIncompleteCallback);
#endif /* USE_HAL_PCD_REGISTER_CALLBACKS */
  HAL_PCDEx_SetRxFiFo(&hpcd_USB_OTG_FS, 0x80);
 801bc46:	2180      	movs	r1, #128	@ 0x80
 801bc48:	4808      	ldr	r0, [pc, #32]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc4a:	f7f3 fa50 	bl	800f0ee <HAL_PCDEx_SetRxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 0, 0x40);
 801bc4e:	2240      	movs	r2, #64	@ 0x40
 801bc50:	2100      	movs	r1, #0
 801bc52:	4806      	ldr	r0, [pc, #24]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc54:	f7f3 fa04 	bl	800f060 <HAL_PCDEx_SetTxFiFo>
  HAL_PCDEx_SetTxFiFo(&hpcd_USB_OTG_FS, 1, 0x80);
 801bc58:	2280      	movs	r2, #128	@ 0x80
 801bc5a:	2101      	movs	r1, #1
 801bc5c:	4803      	ldr	r0, [pc, #12]	@ (801bc6c <USBD_LL_Init+0x94>)
 801bc5e:	f7f3 f9ff 	bl	800f060 <HAL_PCDEx_SetTxFiFo>
  }
  return USBD_OK;
 801bc62:	2300      	movs	r3, #0
}
 801bc64:	4618      	mov	r0, r3
 801bc66:	3708      	adds	r7, #8
 801bc68:	46bd      	mov	sp, r7
 801bc6a:	bd80      	pop	{r7, pc}
 801bc6c:	2000bdb4 	.word	0x2000bdb4

0801bc70 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 801bc70:	b580      	push	{r7, lr}
 801bc72:	b084      	sub	sp, #16
 801bc74:	af00      	add	r7, sp, #0
 801bc76:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801bc78:	2300      	movs	r3, #0
 801bc7a:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801bc7c:	2300      	movs	r3, #0
 801bc7e:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_Start(pdev->pData);
 801bc80:	687b      	ldr	r3, [r7, #4]
 801bc82:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 801bc86:	4618      	mov	r0, r3
 801bc88:	f7f2 f90d 	bl	800dea6 <HAL_PCD_Start>
 801bc8c:	4603      	mov	r3, r0
 801bc8e:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801bc90:	7bfb      	ldrb	r3, [r7, #15]
 801bc92:	4618      	mov	r0, r3
 801bc94:	f000 f942 	bl	801bf1c <USBD_Get_USB_Status>
 801bc98:	4603      	mov	r3, r0
 801bc9a:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 801bc9c:	7bbb      	ldrb	r3, [r7, #14]
}
 801bc9e:	4618      	mov	r0, r3
 801bca0:	3710      	adds	r7, #16
 801bca2:	46bd      	mov	sp, r7
 801bca4:	bd80      	pop	{r7, pc}

0801bca6 <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 801bca6:	b580      	push	{r7, lr}
 801bca8:	b084      	sub	sp, #16
 801bcaa:	af00      	add	r7, sp, #0
 801bcac:	6078      	str	r0, [r7, #4]
 801bcae:	4608      	mov	r0, r1
 801bcb0:	4611      	mov	r1, r2
 801bcb2:	461a      	mov	r2, r3
 801bcb4:	4603      	mov	r3, r0
 801bcb6:	70fb      	strb	r3, [r7, #3]
 801bcb8:	460b      	mov	r3, r1
 801bcba:	70bb      	strb	r3, [r7, #2]
 801bcbc:	4613      	mov	r3, r2
 801bcbe:	803b      	strh	r3, [r7, #0]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801bcc0:	2300      	movs	r3, #0
 801bcc2:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801bcc4:	2300      	movs	r3, #0
 801bcc6:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 801bcc8:	687b      	ldr	r3, [r7, #4]
 801bcca:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 801bcce:	78bb      	ldrb	r3, [r7, #2]
 801bcd0:	883a      	ldrh	r2, [r7, #0]
 801bcd2:	78f9      	ldrb	r1, [r7, #3]
 801bcd4:	f7f2 fde1 	bl	800e89a <HAL_PCD_EP_Open>
 801bcd8:	4603      	mov	r3, r0
 801bcda:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801bcdc:	7bfb      	ldrb	r3, [r7, #15]
 801bcde:	4618      	mov	r0, r3
 801bce0:	f000 f91c 	bl	801bf1c <USBD_Get_USB_Status>
 801bce4:	4603      	mov	r3, r0
 801bce6:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 801bce8:	7bbb      	ldrb	r3, [r7, #14]
}
 801bcea:	4618      	mov	r0, r3
 801bcec:	3710      	adds	r7, #16
 801bcee:	46bd      	mov	sp, r7
 801bcf0:	bd80      	pop	{r7, pc}

0801bcf2 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 801bcf2:	b580      	push	{r7, lr}
 801bcf4:	b084      	sub	sp, #16
 801bcf6:	af00      	add	r7, sp, #0
 801bcf8:	6078      	str	r0, [r7, #4]
 801bcfa:	460b      	mov	r3, r1
 801bcfc:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801bcfe:	2300      	movs	r3, #0
 801bd00:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801bd02:	2300      	movs	r3, #0
 801bd04:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 801bd06:	687b      	ldr	r3, [r7, #4]
 801bd08:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 801bd0c:	78fa      	ldrb	r2, [r7, #3]
 801bd0e:	4611      	mov	r1, r2
 801bd10:	4618      	mov	r0, r3
 801bd12:	f7f2 fe2a 	bl	800e96a <HAL_PCD_EP_Close>
 801bd16:	4603      	mov	r3, r0
 801bd18:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801bd1a:	7bfb      	ldrb	r3, [r7, #15]
 801bd1c:	4618      	mov	r0, r3
 801bd1e:	f000 f8fd 	bl	801bf1c <USBD_Get_USB_Status>
 801bd22:	4603      	mov	r3, r0
 801bd24:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 801bd26:	7bbb      	ldrb	r3, [r7, #14]
}
 801bd28:	4618      	mov	r0, r3
 801bd2a:	3710      	adds	r7, #16
 801bd2c:	46bd      	mov	sp, r7
 801bd2e:	bd80      	pop	{r7, pc}

0801bd30 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 801bd30:	b580      	push	{r7, lr}
 801bd32:	b084      	sub	sp, #16
 801bd34:	af00      	add	r7, sp, #0
 801bd36:	6078      	str	r0, [r7, #4]
 801bd38:	460b      	mov	r3, r1
 801bd3a:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801bd3c:	2300      	movs	r3, #0
 801bd3e:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801bd40:	2300      	movs	r3, #0
 801bd42:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 801bd44:	687b      	ldr	r3, [r7, #4]
 801bd46:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 801bd4a:	78fa      	ldrb	r2, [r7, #3]
 801bd4c:	4611      	mov	r1, r2
 801bd4e:	4618      	mov	r0, r3
 801bd50:	f7f2 fee2 	bl	800eb18 <HAL_PCD_EP_SetStall>
 801bd54:	4603      	mov	r3, r0
 801bd56:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801bd58:	7bfb      	ldrb	r3, [r7, #15]
 801bd5a:	4618      	mov	r0, r3
 801bd5c:	f000 f8de 	bl	801bf1c <USBD_Get_USB_Status>
 801bd60:	4603      	mov	r3, r0
 801bd62:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 801bd64:	7bbb      	ldrb	r3, [r7, #14]
}
 801bd66:	4618      	mov	r0, r3
 801bd68:	3710      	adds	r7, #16
 801bd6a:	46bd      	mov	sp, r7
 801bd6c:	bd80      	pop	{r7, pc}

0801bd6e <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 801bd6e:	b580      	push	{r7, lr}
 801bd70:	b084      	sub	sp, #16
 801bd72:	af00      	add	r7, sp, #0
 801bd74:	6078      	str	r0, [r7, #4]
 801bd76:	460b      	mov	r3, r1
 801bd78:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801bd7a:	2300      	movs	r3, #0
 801bd7c:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801bd7e:	2300      	movs	r3, #0
 801bd80:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);
 801bd82:	687b      	ldr	r3, [r7, #4]
 801bd84:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 801bd88:	78fa      	ldrb	r2, [r7, #3]
 801bd8a:	4611      	mov	r1, r2
 801bd8c:	4618      	mov	r0, r3
 801bd8e:	f7f2 ff26 	bl	800ebde <HAL_PCD_EP_ClrStall>
 801bd92:	4603      	mov	r3, r0
 801bd94:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801bd96:	7bfb      	ldrb	r3, [r7, #15]
 801bd98:	4618      	mov	r0, r3
 801bd9a:	f000 f8bf 	bl	801bf1c <USBD_Get_USB_Status>
 801bd9e:	4603      	mov	r3, r0
 801bda0:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 801bda2:	7bbb      	ldrb	r3, [r7, #14]
}
 801bda4:	4618      	mov	r0, r3
 801bda6:	3710      	adds	r7, #16
 801bda8:	46bd      	mov	sp, r7
 801bdaa:	bd80      	pop	{r7, pc}

0801bdac <USBD_LL_IsStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 801bdac:	b480      	push	{r7}
 801bdae:	b085      	sub	sp, #20
 801bdb0:	af00      	add	r7, sp, #0
 801bdb2:	6078      	str	r0, [r7, #4]
 801bdb4:	460b      	mov	r3, r1
 801bdb6:	70fb      	strb	r3, [r7, #3]
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 801bdb8:	687b      	ldr	r3, [r7, #4]
 801bdba:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 801bdbe:	60fb      	str	r3, [r7, #12]

  if((ep_addr & 0x80) == 0x80)
 801bdc0:	f997 3003 	ldrsb.w	r3, [r7, #3]
 801bdc4:	2b00      	cmp	r3, #0
 801bdc6:	da0b      	bge.n	801bde0 <USBD_LL_IsStallEP+0x34>
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall;
 801bdc8:	78fb      	ldrb	r3, [r7, #3]
 801bdca:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 801bdce:	68f9      	ldr	r1, [r7, #12]
 801bdd0:	4613      	mov	r3, r2
 801bdd2:	00db      	lsls	r3, r3, #3
 801bdd4:	4413      	add	r3, r2
 801bdd6:	009b      	lsls	r3, r3, #2
 801bdd8:	440b      	add	r3, r1
 801bdda:	3316      	adds	r3, #22
 801bddc:	781b      	ldrb	r3, [r3, #0]
 801bdde:	e00b      	b.n	801bdf8 <USBD_LL_IsStallEP+0x4c>
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall;
 801bde0:	78fb      	ldrb	r3, [r7, #3]
 801bde2:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 801bde6:	68f9      	ldr	r1, [r7, #12]
 801bde8:	4613      	mov	r3, r2
 801bdea:	00db      	lsls	r3, r3, #3
 801bdec:	4413      	add	r3, r2
 801bdee:	009b      	lsls	r3, r3, #2
 801bdf0:	440b      	add	r3, r1
 801bdf2:	f203 2356 	addw	r3, r3, #598	@ 0x256
 801bdf6:	781b      	ldrb	r3, [r3, #0]
  }
}
 801bdf8:	4618      	mov	r0, r3
 801bdfa:	3714      	adds	r7, #20
 801bdfc:	46bd      	mov	sp, r7
 801bdfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 801be02:	4770      	bx	lr

0801be04 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 801be04:	b580      	push	{r7, lr}
 801be06:	b084      	sub	sp, #16
 801be08:	af00      	add	r7, sp, #0
 801be0a:	6078      	str	r0, [r7, #4]
 801be0c:	460b      	mov	r3, r1
 801be0e:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801be10:	2300      	movs	r3, #0
 801be12:	73fb      	strb	r3, [r7, #15]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801be14:	2300      	movs	r3, #0
 801be16:	73bb      	strb	r3, [r7, #14]

  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 801be18:	687b      	ldr	r3, [r7, #4]
 801be1a:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 801be1e:	78fa      	ldrb	r2, [r7, #3]
 801be20:	4611      	mov	r1, r2
 801be22:	4618      	mov	r0, r3
 801be24:	f7f2 fd15 	bl	800e852 <HAL_PCD_SetAddress>
 801be28:	4603      	mov	r3, r0
 801be2a:	73fb      	strb	r3, [r7, #15]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801be2c:	7bfb      	ldrb	r3, [r7, #15]
 801be2e:	4618      	mov	r0, r3
 801be30:	f000 f874 	bl	801bf1c <USBD_Get_USB_Status>
 801be34:	4603      	mov	r3, r0
 801be36:	73bb      	strb	r3, [r7, #14]

  return usb_status;
 801be38:	7bbb      	ldrb	r3, [r7, #14]
}
 801be3a:	4618      	mov	r0, r3
 801be3c:	3710      	adds	r7, #16
 801be3e:	46bd      	mov	sp, r7
 801be40:	bd80      	pop	{r7, pc}

0801be42 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 801be42:	b580      	push	{r7, lr}
 801be44:	b086      	sub	sp, #24
 801be46:	af00      	add	r7, sp, #0
 801be48:	60f8      	str	r0, [r7, #12]
 801be4a:	607a      	str	r2, [r7, #4]
 801be4c:	603b      	str	r3, [r7, #0]
 801be4e:	460b      	mov	r3, r1
 801be50:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801be52:	2300      	movs	r3, #0
 801be54:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801be56:	2300      	movs	r3, #0
 801be58:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 801be5a:	68fb      	ldr	r3, [r7, #12]
 801be5c:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 801be60:	7af9      	ldrb	r1, [r7, #11]
 801be62:	683b      	ldr	r3, [r7, #0]
 801be64:	687a      	ldr	r2, [r7, #4]
 801be66:	f7f2 fe1d 	bl	800eaa4 <HAL_PCD_EP_Transmit>
 801be6a:	4603      	mov	r3, r0
 801be6c:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801be6e:	7dfb      	ldrb	r3, [r7, #23]
 801be70:	4618      	mov	r0, r3
 801be72:	f000 f853 	bl	801bf1c <USBD_Get_USB_Status>
 801be76:	4603      	mov	r3, r0
 801be78:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 801be7a:	7dbb      	ldrb	r3, [r7, #22]
}
 801be7c:	4618      	mov	r0, r3
 801be7e:	3718      	adds	r7, #24
 801be80:	46bd      	mov	sp, r7
 801be82:	bd80      	pop	{r7, pc}

0801be84 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint32_t size)
{
 801be84:	b580      	push	{r7, lr}
 801be86:	b086      	sub	sp, #24
 801be88:	af00      	add	r7, sp, #0
 801be8a:	60f8      	str	r0, [r7, #12]
 801be8c:	607a      	str	r2, [r7, #4]
 801be8e:	603b      	str	r3, [r7, #0]
 801be90:	460b      	mov	r3, r1
 801be92:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef hal_status = HAL_OK;
 801be94:	2300      	movs	r3, #0
 801be96:	75fb      	strb	r3, [r7, #23]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801be98:	2300      	movs	r3, #0
 801be9a:	75bb      	strb	r3, [r7, #22]

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 801be9c:	68fb      	ldr	r3, [r7, #12]
 801be9e:	f8d3 02c8 	ldr.w	r0, [r3, #712]	@ 0x2c8
 801bea2:	7af9      	ldrb	r1, [r7, #11]
 801bea4:	683b      	ldr	r3, [r7, #0]
 801bea6:	687a      	ldr	r2, [r7, #4]
 801bea8:	f7f2 fda9 	bl	800e9fe <HAL_PCD_EP_Receive>
 801beac:	4603      	mov	r3, r0
 801beae:	75fb      	strb	r3, [r7, #23]

  usb_status =  USBD_Get_USB_Status(hal_status);
 801beb0:	7dfb      	ldrb	r3, [r7, #23]
 801beb2:	4618      	mov	r0, r3
 801beb4:	f000 f832 	bl	801bf1c <USBD_Get_USB_Status>
 801beb8:	4603      	mov	r3, r0
 801beba:	75bb      	strb	r3, [r7, #22]

  return usb_status;
 801bebc:	7dbb      	ldrb	r3, [r7, #22]
}
 801bebe:	4618      	mov	r0, r3
 801bec0:	3718      	adds	r7, #24
 801bec2:	46bd      	mov	sp, r7
 801bec4:	bd80      	pop	{r7, pc}

0801bec6 <USBD_LL_GetRxDataSize>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval Received Data Size
  */
uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 801bec6:	b580      	push	{r7, lr}
 801bec8:	b082      	sub	sp, #8
 801beca:	af00      	add	r7, sp, #0
 801becc:	6078      	str	r0, [r7, #4]
 801bece:	460b      	mov	r3, r1
 801bed0:	70fb      	strb	r3, [r7, #3]
  return HAL_PCD_EP_GetRxCount((PCD_HandleTypeDef*) pdev->pData, ep_addr);
 801bed2:	687b      	ldr	r3, [r7, #4]
 801bed4:	f8d3 32c8 	ldr.w	r3, [r3, #712]	@ 0x2c8
 801bed8:	78fa      	ldrb	r2, [r7, #3]
 801beda:	4611      	mov	r1, r2
 801bedc:	4618      	mov	r0, r3
 801bede:	f7f2 fdc9 	bl	800ea74 <HAL_PCD_EP_GetRxCount>
 801bee2:	4603      	mov	r3, r0
}
 801bee4:	4618      	mov	r0, r3
 801bee6:	3708      	adds	r7, #8
 801bee8:	46bd      	mov	sp, r7
 801beea:	bd80      	pop	{r7, pc}

0801beec <USBD_static_malloc>:
  * @brief  Static single allocation.
  * @param  size: Size of allocated memory
  * @retval None
  */
void *USBD_static_malloc(uint32_t size)
{
 801beec:	b480      	push	{r7}
 801beee:	b083      	sub	sp, #12
 801bef0:	af00      	add	r7, sp, #0
 801bef2:	6078      	str	r0, [r7, #4]
  static uint32_t mem[(sizeof(USBD_CDC_HandleTypeDef)/4)+1];/* On 32-bit boundary */
  return mem;
 801bef4:	4b03      	ldr	r3, [pc, #12]	@ (801bf04 <USBD_static_malloc+0x18>)
}
 801bef6:	4618      	mov	r0, r3
 801bef8:	370c      	adds	r7, #12
 801befa:	46bd      	mov	sp, r7
 801befc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf00:	4770      	bx	lr
 801bf02:	bf00      	nop
 801bf04:	2000c298 	.word	0x2000c298

0801bf08 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 801bf08:	b480      	push	{r7}
 801bf0a:	b083      	sub	sp, #12
 801bf0c:	af00      	add	r7, sp, #0
 801bf0e:	6078      	str	r0, [r7, #4]

}
 801bf10:	bf00      	nop
 801bf12:	370c      	adds	r7, #12
 801bf14:	46bd      	mov	sp, r7
 801bf16:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf1a:	4770      	bx	lr

0801bf1c <USBD_Get_USB_Status>:
  * @brief  Returns the USB status depending on the HAL status:
  * @param  hal_status: HAL status
  * @retval USB status
  */
USBD_StatusTypeDef USBD_Get_USB_Status(HAL_StatusTypeDef hal_status)
{
 801bf1c:	b480      	push	{r7}
 801bf1e:	b085      	sub	sp, #20
 801bf20:	af00      	add	r7, sp, #0
 801bf22:	4603      	mov	r3, r0
 801bf24:	71fb      	strb	r3, [r7, #7]
  USBD_StatusTypeDef usb_status = USBD_OK;
 801bf26:	2300      	movs	r3, #0
 801bf28:	73fb      	strb	r3, [r7, #15]

  switch (hal_status)
 801bf2a:	79fb      	ldrb	r3, [r7, #7]
 801bf2c:	2b03      	cmp	r3, #3
 801bf2e:	d817      	bhi.n	801bf60 <USBD_Get_USB_Status+0x44>
 801bf30:	a201      	add	r2, pc, #4	@ (adr r2, 801bf38 <USBD_Get_USB_Status+0x1c>)
 801bf32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bf36:	bf00      	nop
 801bf38:	0801bf49 	.word	0x0801bf49
 801bf3c:	0801bf4f 	.word	0x0801bf4f
 801bf40:	0801bf55 	.word	0x0801bf55
 801bf44:	0801bf5b 	.word	0x0801bf5b
  {
    case HAL_OK :
      usb_status = USBD_OK;
 801bf48:	2300      	movs	r3, #0
 801bf4a:	73fb      	strb	r3, [r7, #15]
    break;
 801bf4c:	e00b      	b.n	801bf66 <USBD_Get_USB_Status+0x4a>
    case HAL_ERROR :
      usb_status = USBD_FAIL;
 801bf4e:	2303      	movs	r3, #3
 801bf50:	73fb      	strb	r3, [r7, #15]
    break;
 801bf52:	e008      	b.n	801bf66 <USBD_Get_USB_Status+0x4a>
    case HAL_BUSY :
      usb_status = USBD_BUSY;
 801bf54:	2301      	movs	r3, #1
 801bf56:	73fb      	strb	r3, [r7, #15]
    break;
 801bf58:	e005      	b.n	801bf66 <USBD_Get_USB_Status+0x4a>
    case HAL_TIMEOUT :
      usb_status = USBD_FAIL;
 801bf5a:	2303      	movs	r3, #3
 801bf5c:	73fb      	strb	r3, [r7, #15]
    break;
 801bf5e:	e002      	b.n	801bf66 <USBD_Get_USB_Status+0x4a>
    default :
      usb_status = USBD_FAIL;
 801bf60:	2303      	movs	r3, #3
 801bf62:	73fb      	strb	r3, [r7, #15]
    break;
 801bf64:	bf00      	nop
  }
  return usb_status;
 801bf66:	7bfb      	ldrb	r3, [r7, #15]
}
 801bf68:	4618      	mov	r0, r3
 801bf6a:	3714      	adds	r7, #20
 801bf6c:	46bd      	mov	sp, r7
 801bf6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf72:	4770      	bx	lr

0801bf74 <xmp3_SetBitstreamPointer>:
 **************************************************************************************/
void SetBitstreamPointer(BitStreamInfo *bsi, int nBytes, unsigned char *buf)
{
	/* init bitstream */
	bsi->bytePtr = buf;
	bsi->iCache = 0;		/* 4-byte unsigned int */
 801bf74:	2300      	movs	r3, #0
 801bf76:	e9c0 2300 	strd	r2, r3, [r0]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
	bsi->nBytes = nBytes;
 801bf7a:	e9c0 3102 	strd	r3, r1, [r0, #8]
}
 801bf7e:	4770      	bx	lr

0801bf80 <xmp3_GetBits>:
 *              if nBits = 0, returns 0 (useful for scalefactor unpacking)
 *
 * TODO:        optimize for ARM
 **************************************************************************************/
unsigned int GetBits(BitStreamInfo *bsi, int nBits)
{
 801bf80:	4603      	mov	r3, r0
	unsigned int data, lowBits;

	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 801bf82:	6842      	ldr	r2, [r0, #4]
	nBits &= 0x1f;							/* nBits mod 32 to avoid unpredictable results like >> by negative amount */
 801bf84:	f001 011f 	and.w	r1, r1, #31
{
 801bf88:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 801bf8c:	f1c1 001f 	rsb	r0, r1, #31
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
	bsi->iCache <<= nBits;					/* left-justify cache */
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 801bf90:	689c      	ldr	r4, [r3, #8]
	data = bsi->iCache >> (31 - nBits);		/* unsigned >> so zero-extend */
 801bf92:	fa22 f000 	lsr.w	r0, r2, r0
	bsi->iCache <<= nBits;					/* left-justify cache */
 801bf96:	408a      	lsls	r2, r1
 801bf98:	605a      	str	r2, [r3, #4]
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 801bf9a:	1a62      	subs	r2, r4, r1

	/* if we cross an int boundary, refill the cache */
	if (bsi->cachedBits < 0) {
 801bf9c:	2a00      	cmp	r2, #0
	data >>= 1;								/* do as >> 31, >> 1 so that nBits = 0 works okay (returns 0) */
 801bf9e:	ea4f 0050 	mov.w	r0, r0, lsr #1
	bsi->cachedBits -= nBits;				/* how many bits have we drawn from the cache so far */
 801bfa2:	609a      	str	r2, [r3, #8]
	if (bsi->cachedBits < 0) {
 801bfa4:	db01      	blt.n	801bfaa <xmp3_GetBits+0x2a>
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
		bsi->iCache <<= lowBits;			/* left-justify cache */
	}

	return data;
}
 801bfa6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int nBytes = bsi->nBytes;
 801bfaa:	68df      	ldr	r7, [r3, #12]
	if (nBytes >= 4) {
 801bfac:	2f03      	cmp	r7, #3
		lowBits = -bsi->cachedBits;
 801bfae:	eba1 0104 	sub.w	r1, r1, r4
	if (nBytes >= 4) {
 801bfb2:	f102 0620 	add.w	r6, r2, #32
 801bfb6:	dc1f      	bgt.n	801bff8 <xmp3_GetBits+0x78>
		bsi->iCache = 0;
 801bfb8:	2400      	movs	r4, #0
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 801bfba:	f1c7 0503 	rsb	r5, r7, #3
		bsi->iCache = 0;
 801bfbe:	605c      	str	r4, [r3, #4]
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 801bfc0:	ea4f 08c5 	mov.w	r8, r5, lsl #3
		while (nBytes--) {
 801bfc4:	2f00      	cmp	r7, #0
 801bfc6:	d038      	beq.n	801c03a <xmp3_GetBits+0xba>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 801bfc8:	681d      	ldr	r5, [r3, #0]
 801bfca:	eb05 0e07 	add.w	lr, r5, r7
			bsi->iCache |= (*bsi->bytePtr++);
 801bfce:	3501      	adds	r5, #1
 801bfd0:	601d      	str	r5, [r3, #0]
 801bfd2:	f815 cc01 	ldrb.w	ip, [r5, #-1]
 801bfd6:	ea4c 0404 	orr.w	r4, ip, r4
			bsi->iCache <<= 8;
 801bfda:	0224      	lsls	r4, r4, #8
		while (nBytes--) {
 801bfdc:	4575      	cmp	r5, lr
			bsi->iCache <<= 8;
 801bfde:	605c      	str	r4, [r3, #4]
		while (nBytes--) {
 801bfe0:	d1f5      	bne.n	801bfce <xmp3_GetBits+0x4e>
		bsi->iCache <<= ((3 - bsi->nBytes)*8);
 801bfe2:	fa04 f408 	lsl.w	r4, r4, r8
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 801bfe6:	fa24 f606 	lsr.w	r6, r4, r6
 801bfea:	4330      	orrs	r0, r6
		bsi->iCache <<= lowBits;			/* left-justify cache */
 801bfec:	fa04 f101 	lsl.w	r1, r4, r1
		bsi->nBytes = 0;
 801bff0:	eb02 06c7 	add.w	r6, r2, r7, lsl #3
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 801bff4:	2700      	movs	r7, #0
 801bff6:	e01b      	b.n	801c030 <xmp3_GetBits+0xb0>
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 801bff8:	681c      	ldr	r4, [r3, #0]
 801bffa:	4625      	mov	r5, r4
 801bffc:	1c62      	adds	r2, r4, #1
 801bffe:	601a      	str	r2, [r3, #0]
 801c000:	f815 2b02 	ldrb.w	r2, [r5], #2
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 801c004:	601d      	str	r5, [r3, #0]
		bsi->iCache  = (*bsi->bytePtr++) << 24;
 801c006:	0612      	lsls	r2, r2, #24
 801c008:	605a      	str	r2, [r3, #4]
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 801c00a:	7865      	ldrb	r5, [r4, #1]
 801c00c:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 801c010:	1ce5      	adds	r5, r4, #3
		bsi->iCache |= (*bsi->bytePtr++) << 16;
 801c012:	605a      	str	r2, [r3, #4]
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 801c014:	601d      	str	r5, [r3, #0]
 801c016:	78a5      	ldrb	r5, [r4, #2]
 801c018:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
		bsi->iCache |= (*bsi->bytePtr++);
 801c01c:	1d25      	adds	r5, r4, #4
		bsi->iCache |= (*bsi->bytePtr++) <<  8;
 801c01e:	605a      	str	r2, [r3, #4]
		bsi->iCache |= (*bsi->bytePtr++);
 801c020:	601d      	str	r5, [r3, #0]
 801c022:	78e4      	ldrb	r4, [r4, #3]
 801c024:	4322      	orrs	r2, r4
		bsi->iCache <<= lowBits;			/* left-justify cache */
 801c026:	fa02 f101 	lsl.w	r1, r2, r1
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 801c02a:	40f2      	lsrs	r2, r6
		bsi->nBytes -= 4;
 801c02c:	3f04      	subs	r7, #4
		data |= bsi->iCache >> (32 - lowBits);		/* get the low-order bits */
 801c02e:	4310      	orrs	r0, r2
		bsi->cachedBits -= lowBits;			/* how many bits have we drawn from the cache so far */
 801c030:	e9c3 6702 	strd	r6, r7, [r3, #8]
		bsi->iCache <<= lowBits;			/* left-justify cache */
 801c034:	6059      	str	r1, [r3, #4]
}
 801c036:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		while (nBytes--) {
 801c03a:	4639      	mov	r1, r7
 801c03c:	e7d8      	b.n	801bff0 <xmp3_GetBits+0x70>
 801c03e:	bf00      	nop

0801c040 <xmp3_CalcBitsUsed>:
 * Outputs:     none
 *
 * Return:      number of bits read from bitstream, as offset from startBuf:startOffset
 **************************************************************************************/
int CalcBitsUsed(BitStreamInfo *bsi, unsigned char *startBuf, int startOffset)
{
 801c040:	b410      	push	{r4}
	int bitsUsed;

	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 801c042:	6804      	ldr	r4, [r0, #0]
	bitsUsed -= bsi->cachedBits;
 801c044:	6883      	ldr	r3, [r0, #8]
	bitsUsed  = (bsi->bytePtr - startBuf) * 8;
 801c046:	1a61      	subs	r1, r4, r1
	bitsUsed -= bsi->cachedBits;
 801c048:	ebc3 03c1 	rsb	r3, r3, r1, lsl #3
	bitsUsed -= startOffset;

	return bitsUsed;
}
 801c04c:	1a98      	subs	r0, r3, r2
 801c04e:	f85d 4b04 	ldr.w	r4, [sp], #4
 801c052:	4770      	bx	lr

0801c054 <xmp3_CheckPadBit>:
int CheckPadBit(MP3DecInfo *mp3DecInfo)
{
	FrameHeader *fh;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS)
 801c054:	b130      	cbz	r0, 801c064 <xmp3_CheckPadBit+0x10>
 801c056:	6803      	ldr	r3, [r0, #0]
 801c058:	b123      	cbz	r3, 801c064 <xmp3_CheckPadBit+0x10>
		return -1;

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	return (fh->paddingBit ? 1 : 0);
 801c05a:	6958      	ldr	r0, [r3, #20]
 801c05c:	3800      	subs	r0, #0
 801c05e:	bf18      	it	ne
 801c060:	2001      	movne	r0, #1
 801c062:	4770      	bx	lr
		return -1;
 801c064:	f04f 30ff 	mov.w	r0, #4294967295
}
 801c068:	4770      	bx	lr
 801c06a:	bf00      	nop

0801c06c <xmp3_UnpackFrameHeader>:

	int verIdx;
	FrameHeader *fh;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 801c06c:	2800      	cmp	r0, #0
 801c06e:	f000 80d9 	beq.w	801c224 <xmp3_UnpackFrameHeader+0x1b8>
 801c072:	6803      	ldr	r3, [r0, #0]
 801c074:	2b00      	cmp	r3, #0
 801c076:	f000 80d5 	beq.w	801c224 <xmp3_UnpackFrameHeader+0x1b8>
 801c07a:	780a      	ldrb	r2, [r1, #0]
 801c07c:	2aff      	cmp	r2, #255	@ 0xff
 801c07e:	f040 80d1 	bne.w	801c224 <xmp3_UnpackFrameHeader+0x1b8>
{
 801c082:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || (buf[0] & SYNCWORDH) != SYNCWORDH || (buf[1] & SYNCWORDL) != SYNCWORDL)
 801c086:	784c      	ldrb	r4, [r1, #1]
 801c088:	f004 02e0 	and.w	r2, r4, #224	@ 0xe0
 801c08c:	2ae0      	cmp	r2, #224	@ 0xe0
 801c08e:	f040 80c6 	bne.w	801c21e <xmp3_UnpackFrameHeader+0x1b2>
		return -1;

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));

	/* read header fields - use bitmasks instead of GetBits() for speed, since format never varies */
	verIdx =         (buf[1] >> 3) & 0x03;
 801c092:	08e2      	lsrs	r2, r4, #3
	fh->ver =        (MPEGVersion)( verIdx == 0 ? MPEG25 : ((verIdx & 0x01) ? MPEG1 : MPEG2) );
 801c094:	f014 0f18 	tst.w	r4, #24
 801c098:	bf1a      	itte	ne
 801c09a:	43d2      	mvnne	r2, r2
 801c09c:	f002 0201 	andne.w	r2, r2, #1
 801c0a0:	2202      	moveq	r2, #2
 801c0a2:	701a      	strb	r2, [r3, #0]
	fh->layer = 4 - ((buf[1] >> 1) & 0x03);     /* easy mapping of index to layer number, 4 = error */
 801c0a4:	f891 c001 	ldrb.w	ip, [r1, #1]
 801c0a8:	f3cc 0c41 	ubfx	ip, ip, #1, #2
 801c0ac:	f1cc 0904 	rsb	r9, ip, #4
 801c0b0:	f8c3 9004 	str.w	r9, [r3, #4]
	fh->crc =   1 - ((buf[1] >> 0) & 0x01);
 801c0b4:	784d      	ldrb	r5, [r1, #1]
 801c0b6:	43ed      	mvns	r5, r5
 801c0b8:	f005 0501 	and.w	r5, r5, #1
 801c0bc:	609d      	str	r5, [r3, #8]
	fh->brIdx =      (buf[2] >> 4) & 0x0f;
 801c0be:	788f      	ldrb	r7, [r1, #2]
 801c0c0:	093f      	lsrs	r7, r7, #4
 801c0c2:	60df      	str	r7, [r3, #12]
	fh->srIdx =      (buf[2] >> 2) & 0x03;
 801c0c4:	788c      	ldrb	r4, [r1, #2]
 801c0c6:	f3c4 0481 	ubfx	r4, r4, #2, #2
 801c0ca:	611c      	str	r4, [r3, #16]
	fh->paddingBit = (buf[2] >> 1) & 0x01;
 801c0cc:	788e      	ldrb	r6, [r1, #2]
 801c0ce:	f3c6 0640 	ubfx	r6, r6, #1, #1
 801c0d2:	615e      	str	r6, [r3, #20]
	fh->privateBit = (buf[2] >> 0) & 0x01;
 801c0d4:	f891 e002 	ldrb.w	lr, [r1, #2]
 801c0d8:	f00e 0e01 	and.w	lr, lr, #1
 801c0dc:	f8c3 e018 	str.w	lr, [r3, #24]
	fh->sMode =      (StereoMode)((buf[3] >> 6) & 0x03);      /* maps to correct enum (see definition) */    
 801c0e0:	f891 e003 	ldrb.w	lr, [r1, #3]
 801c0e4:	ea4f 1e9e 	mov.w	lr, lr, lsr #6
 801c0e8:	f883 e01c 	strb.w	lr, [r3, #28]
	fh->modeExt =    (buf[3] >> 4) & 0x03;
 801c0ec:	f891 8003 	ldrb.w	r8, [r1, #3]
 801c0f0:	f3c8 1801 	ubfx	r8, r8, #4, #2
 801c0f4:	f8c3 8020 	str.w	r8, [r3, #32]
	fh->copyFlag =   (buf[3] >> 3) & 0x01;
 801c0f8:	f891 8003 	ldrb.w	r8, [r1, #3]
 801c0fc:	f3c8 08c0 	ubfx	r8, r8, #3, #1
 801c100:	f8c3 8024 	str.w	r8, [r3, #36]	@ 0x24
	fh->origFlag =   (buf[3] >> 2) & 0x01;
 801c104:	f891 8003 	ldrb.w	r8, [r1, #3]
 801c108:	f3c8 0880 	ubfx	r8, r8, #2, #1
 801c10c:	f8c3 8028 	str.w	r8, [r3, #40]	@ 0x28
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 801c110:	f891 8003 	ldrb.w	r8, [r1, #3]

	/* check parameters to avoid indexing tables with bad values */
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 801c114:	2c03      	cmp	r4, #3
	fh->emphasis =   (buf[3] >> 0) & 0x03;
 801c116:	f008 0803 	and.w	r8, r8, #3
 801c11a:	f8c3 802c 	str.w	r8, [r3, #44]	@ 0x2c
	if (fh->srIdx == 3 || fh->layer == 4 || fh->brIdx == 15)
 801c11e:	d07e      	beq.n	801c21e <xmp3_UnpackFrameHeader+0x1b2>
 801c120:	f1b9 0f04 	cmp.w	r9, #4
 801c124:	d07b      	beq.n	801c21e <xmp3_UnpackFrameHeader+0x1b2>
 801c126:	2f0f      	cmp	r7, #15
 801c128:	d079      	beq.n	801c21e <xmp3_UnpackFrameHeader+0x1b2>
		return -1;

	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 801c12a:	f04f 0bde 	mov.w	fp, #222	@ 0xde
 801c12e:	f8df a108 	ldr.w	sl, [pc, #264]	@ 801c238 <xmp3_UnpackFrameHeader+0x1cc>
 801c132:	fb0b fb02 	mul.w	fp, fp, r2
 801c136:	f04f 084a 	mov.w	r8, #74	@ 0x4a
 801c13a:	fb18 b804 	smlabb	r8, r8, r4, fp
 801c13e:	44d0      	add	r8, sl
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 801c140:	f1be 0f01 	cmp.w	lr, #1
	fh->sfBand = &sfBandTable[fh->ver][fh->srIdx];	/* for readability (we reference sfBandTable many times in decoder) */
 801c144:	f8c3 8034 	str.w	r8, [r3, #52]	@ 0x34
	if (fh->sMode != Joint)		/* just to be safe (dequant, stproc check fh->modeExt) */
 801c148:	d009      	beq.n	801c15e <xmp3_UnpackFrameHeader+0xf2>
		fh->modeExt = 0;
 801c14a:	f04f 0800 	mov.w	r8, #0

	/* init user-accessible data */
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 801c14e:	f1be 0f03 	cmp.w	lr, #3
		fh->modeExt = 0;
 801c152:	f8c3 8020 	str.w	r8, [r3, #32]
	mp3DecInfo->nChans = (fh->sMode == Mono ? 1 : 2);
 801c156:	d102      	bne.n	801c15e <xmp3_UnpackFrameHeader+0xf2>
 801c158:	f04f 0801 	mov.w	r8, #1
 801c15c:	e001      	b.n	801c162 <xmp3_UnpackFrameHeader+0xf6>
 801c15e:	f04f 0802 	mov.w	r8, #2
 801c162:	f8c0 87bc 	str.w	r8, [r0, #1980]	@ 0x7bc
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 801c166:	eb02 0842 	add.w	r8, r2, r2, lsl #1
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 801c16a:	2a00      	cmp	r2, #0
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
	mp3DecInfo->layer = fh->layer;
 801c16c:	f8c0 97d0 	str.w	r9, [r0, #2000]	@ 0x7d0
	mp3DecInfo->version = fh->ver;
 801c170:	f880 27d4 	strb.w	r2, [r0, #2004]	@ 0x7d4
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 801c174:	eb08 0904 	add.w	r9, r8, r4
 801c178:	ea4f 0a42 	mov.w	sl, r2, lsl #1
 801c17c:	4a2b      	ldr	r2, [pc, #172]	@ (801c22c <xmp3_UnpackFrameHeader+0x1c0>)
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 801c17e:	f1cc 0c03 	rsb	ip, ip, #3
	mp3DecInfo->samprate = samplerateTab[fh->ver][fh->srIdx];
 801c182:	f852 2029 	ldr.w	r2, [r2, r9, lsl #2]
 801c186:	f8c0 27c0 	str.w	r2, [r0, #1984]	@ 0x7c0
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 801c18a:	eb08 090c 	add.w	r9, r8, ip
 801c18e:	4a28      	ldr	r2, [pc, #160]	@ (801c230 <xmp3_UnpackFrameHeader+0x1c4>)
 801c190:	f932 9019 	ldrsh.w	r9, [r2, r9, lsl #1]
	mp3DecInfo->nGrans = (fh->ver == MPEG1 ? NGRANS_MPEG1 : NGRANS_MPEG2);
 801c194:	bf0c      	ite	eq
 801c196:	2202      	moveq	r2, #2
 801c198:	2201      	movne	r2, #1
 801c19a:	f8c0 27c4 	str.w	r2, [r0, #1988]	@ 0x7c4
	mp3DecInfo->nGranSamps = ((int)samplesPerFrameTab[fh->ver][fh->layer - 1]) / mp3DecInfo->nGrans;
 801c19e:	fb99 f2f2 	sdiv	r2, r9, r2
 801c1a2:	f8c0 27c8 	str.w	r2, [r0, #1992]	@ 0x7c8
	/* get bitrate and nSlots from table, unless brIdx == 0 (free mode) in which case caller must figure it out himself
	 * question - do we want to overwrite mp3DecInfo->bitrate with 0 each time if it's free mode, and
	 *  copy the pre-calculated actual free bitrate into it in mp3dec.c (according to the spec, 
	 *  this shouldn't be necessary, since it should be either all frames free or none free)
	 */
	if (fh->brIdx) {
 801c1a6:	b367      	cbz	r7, 801c202 <xmp3_UnpackFrameHeader+0x196>
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 801c1a8:	ebc8 1808 	rsb	r8, r8, r8, lsl #4
 801c1ac:	ebcc 1c0c 	rsb	ip, ip, ip, lsl #4
	
		/* nSlots = total frame bytes (from table) - sideInfo bytes - header - CRC (if present) + pad (if present) */
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c1b0:	ebc4 1404 	rsb	r4, r4, r4, lsl #4
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 801c1b4:	44c4      	add	ip, r8
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c1b6:	4444      	add	r4, r8
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 801c1b8:	44bc      	add	ip, r7
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c1ba:	443c      	add	r4, r7
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 801c1bc:	4f1d      	ldr	r7, [pc, #116]	@ (801c234 <xmp3_UnpackFrameHeader+0x1c8>)
 801c1be:	f937 701c 	ldrsh.w	r7, [r7, ip, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c1c2:	f8df c078 	ldr.w	ip, [pc, #120]	@ 801c23c <xmp3_UnpackFrameHeader+0x1d0>
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 801c1c6:	f1be 0f03 	cmp.w	lr, #3
 801c1ca:	bf0c      	ite	eq
 801c1cc:	4652      	moveq	r2, sl
 801c1ce:	f10a 0201 	addne.w	r2, sl, #1
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c1d2:	f93c 4014 	ldrsh.w	r4, [ip, r4, lsl #1]
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 801c1d6:	f8df c068 	ldr.w	ip, [pc, #104]	@ 801c240 <xmp3_UnpackFrameHeader+0x1d4>
 801c1da:	f93c 2012 	ldrsh.w	r2, [ip, r2, lsl #1]
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c1de:	1aa2      	subs	r2, r4, r2
		mp3DecInfo->bitrate = ((int)bitrateTab[fh->ver][fh->layer - 1][fh->brIdx]) * 1000;
 801c1e0:	ebc7 1447 	rsb	r4, r7, r7, lsl #5
 801c1e4:	eb07 0784 	add.w	r7, r7, r4, lsl #2
 801c1e8:	00ff      	lsls	r7, r7, #3
 801c1ea:	f8c0 77b8 	str.w	r7, [r0, #1976]	@ 0x7b8
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 801c1ee:	b98d      	cbnz	r5, 801c214 <xmp3_UnpackFrameHeader+0x1a8>
			(int)sideBytesTab[fh->ver][(fh->sMode == Mono ? 0 : 1)] - 
 801c1f0:	3a04      	subs	r2, #4
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 801c1f2:	4432      	add	r2, r6
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c1f4:	f8c0 27cc 	str.w	r2, [r0, #1996]	@ 0x7cc
	/* load crc word, if enabled, and return length of frame header (in bytes) */
	if (fh->crc) {
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
		return 6;
	} else {
		fh->CRCWord = 0;
 801c1f8:	2200      	movs	r2, #0
 801c1fa:	631a      	str	r2, [r3, #48]	@ 0x30
		return 4;
 801c1fc:	2004      	movs	r0, #4
	}
}
 801c1fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (fh->crc) {
 801c202:	2d00      	cmp	r5, #0
 801c204:	d0f8      	beq.n	801c1f8 <xmp3_UnpackFrameHeader+0x18c>
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 801c206:	888a      	ldrh	r2, [r1, #4]
 801c208:	ba52      	rev16	r2, r2
 801c20a:	b292      	uxth	r2, r2
		return 6;
 801c20c:	2006      	movs	r0, #6
		fh->CRCWord = ((int)buf[4] << 8 | (int)buf[5] << 0);
 801c20e:	631a      	str	r2, [r3, #48]	@ 0x30
}
 801c210:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			4 - (fh->crc ? 2 : 0) + (fh->paddingBit ? 1 : 0);
 801c214:	3a06      	subs	r2, #6
 801c216:	4432      	add	r2, r6
		mp3DecInfo->nSlots = (int)slotTab[fh->ver][fh->srIdx][fh->brIdx] - 
 801c218:	f8c0 27cc 	str.w	r2, [r0, #1996]	@ 0x7cc
	if (fh->crc) {
 801c21c:	e7f3      	b.n	801c206 <xmp3_UnpackFrameHeader+0x19a>
		return -1;
 801c21e:	f04f 30ff 	mov.w	r0, #4294967295
 801c222:	e7f5      	b.n	801c210 <xmp3_UnpackFrameHeader+0x1a4>
 801c224:	f04f 30ff 	mov.w	r0, #4294967295
}
 801c228:	4770      	bx	lr
 801c22a:	bf00      	nop
 801c22c:	08038050 	.word	0x08038050
 801c230:	08037f2c 	.word	0x08037f2c
 801c234:	08037f40 	.word	0x08037f40
 801c238:	08037b74 	.word	0x08037b74
 801c23c:	08037e10 	.word	0x08037e10
 801c240:	08037f20 	.word	0x08037f20

0801c244 <xmp3_UnpackSideInfo>:
 *
 * Return:      length (in bytes) of side info data
 *              -1 if null input pointers
 **************************************************************************************/
int UnpackSideInfo(MP3DecInfo *mp3DecInfo, unsigned char *buf)
{
 801c244:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c248:	b08b      	sub	sp, #44	@ 0x2c
	FrameHeader *fh;
	SideInfo *si;
	SideInfoSub *sis;

	/* validate pointers and sync word */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS)
 801c24a:	2800      	cmp	r0, #0
 801c24c:	f000 8133 	beq.w	801c4b6 <xmp3_UnpackSideInfo+0x272>
 801c250:	6803      	ldr	r3, [r0, #0]
 801c252:	4604      	mov	r4, r0
 801c254:	2b00      	cmp	r3, #0
 801c256:	f000 812e 	beq.w	801c4b6 <xmp3_UnpackSideInfo+0x272>
 801c25a:	6846      	ldr	r6, [r0, #4]
 801c25c:	2e00      	cmp	r6, #0
 801c25e:	f000 812a 	beq.w	801c4b6 <xmp3_UnpackSideInfo+0x272>

	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));

	bsi = &bitStreamInfo;
	if (fh->ver == MPEG1) {
 801c262:	f893 8000 	ldrb.w	r8, [r3]
		/* MPEG 1 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 801c266:	7f1b      	ldrb	r3, [r3, #28]
	if (fh->ver == MPEG1) {
 801c268:	f1b8 0f00 	cmp.w	r8, #0
 801c26c:	f000 80a4 	beq.w	801c3b8 <xmp3_UnpackSideInfo+0x174>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
			for (bd = 0; bd < MAX_SCFBD; bd++)
				si->scfsi[ch][bd] = GetBits(bsi, 1);
	} else {
		/* MPEG 2, MPEG 2.5 */
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 801c270:	2b03      	cmp	r3, #3
 801c272:	f000 8111 	beq.w	801c498 <xmp3_UnpackSideInfo+0x254>
	bsi->iCache = 0;		/* 4-byte unsigned int */
 801c276:	2300      	movs	r3, #0
		SetBitstreamPointer(bsi, nBytes, buf);
		si->mainDataBegin = GetBits(bsi, 8);
 801c278:	ad06      	add	r5, sp, #24
	bsi->iCache = 0;		/* 4-byte unsigned int */
 801c27a:	e9cd 1306 	strd	r1, r3, [sp, #24]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c27e:	2200      	movs	r2, #0
 801c280:	2311      	movs	r3, #17
		si->mainDataBegin = GetBits(bsi, 8);
 801c282:	2108      	movs	r1, #8
 801c284:	4628      	mov	r0, r5
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c286:	e9cd 2308 	strd	r2, r3, [sp, #32]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 801c28a:	2711      	movs	r7, #17
		si->mainDataBegin = GetBits(bsi, 8);
 801c28c:	f7ff fe78 	bl	801bf80 <xmp3_GetBits>
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 801c290:	2102      	movs	r1, #2
		si->mainDataBegin = GetBits(bsi, 8);
 801c292:	6030      	str	r0, [r6, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 801c294:	4628      	mov	r0, r5
 801c296:	f7ff fe73 	bl	801bf80 <xmp3_GetBits>
 801c29a:	6070      	str	r0, [r6, #4]
	}

	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 801c29c:	f8d4 17c4 	ldr.w	r1, [r4, #1988]	@ 0x7c4
 801c2a0:	2900      	cmp	r1, #0
 801c2a2:	f340 8082 	ble.w	801c3aa <xmp3_UnpackSideInfo+0x166>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801c2a6:	f8d4 b7bc 	ldr.w	fp, [r4, #1980]	@ 0x7bc
 801c2aa:	f1bb 0f00 	cmp.w	fp, #0
 801c2ae:	dd7c      	ble.n	801c3aa <xmp3_UnpackSideInfo+0x166>
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 801c2b0:	e9cd 1602 	strd	r1, r6, [sp, #8]
 801c2b4:	f1b8 0f00 	cmp.w	r8, #0
 801c2b8:	f04f 0a00 	mov.w	sl, #0
 801c2bc:	e9cd 7404 	strd	r7, r4, [sp, #16]
 801c2c0:	4653      	mov	r3, sl
 801c2c2:	bf0c      	ite	eq
 801c2c4:	f04f 0904 	moveq.w	r9, #4
 801c2c8:	f04f 0909 	movne.w	r9, #9
 801c2cc:	46b2      	mov	sl, r6
 801c2ce:	4644      	mov	r4, r8
 801c2d0:	4656      	mov	r6, sl
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801c2d2:	2700      	movs	r7, #0
 801c2d4:	9301      	str	r3, [sp, #4]
			sis = &si->sis[gr][ch];						/* side info subblock for this granule, channel */

			sis->part23Length =    GetBits(bsi, 12);
 801c2d6:	210c      	movs	r1, #12
 801c2d8:	4628      	mov	r0, r5
 801c2da:	f7ff fe51 	bl	801bf80 <xmp3_GetBits>
			sis->nBigvals =        GetBits(bsi, 9);
 801c2de:	2109      	movs	r1, #9
			sis->part23Length =    GetBits(bsi, 12);
 801c2e0:	62b0      	str	r0, [r6, #40]	@ 0x28
			sis->nBigvals =        GetBits(bsi, 9);
 801c2e2:	4628      	mov	r0, r5
 801c2e4:	f7ff fe4c 	bl	801bf80 <xmp3_GetBits>
			sis->globalGain =      GetBits(bsi, 8);
 801c2e8:	2108      	movs	r1, #8
			sis->nBigvals =        GetBits(bsi, 9);
 801c2ea:	62f0      	str	r0, [r6, #44]	@ 0x2c
			sis->globalGain =      GetBits(bsi, 8);
 801c2ec:	4628      	mov	r0, r5
 801c2ee:	f7ff fe47 	bl	801bf80 <xmp3_GetBits>
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 801c2f2:	4649      	mov	r1, r9
			sis->globalGain =      GetBits(bsi, 8);
 801c2f4:	6330      	str	r0, [r6, #48]	@ 0x30
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 801c2f6:	4628      	mov	r0, r5
 801c2f8:	f7ff fe42 	bl	801bf80 <xmp3_GetBits>
			sis->winSwitchFlag =   GetBits(bsi, 1);
 801c2fc:	2101      	movs	r1, #1
			sis->sfCompress =      GetBits(bsi, (fh->ver == MPEG1 ? 4 : 9));
 801c2fe:	6370      	str	r0, [r6, #52]	@ 0x34
			sis->winSwitchFlag =   GetBits(bsi, 1);
 801c300:	4628      	mov	r0, r5
 801c302:	f7ff fe3d 	bl	801bf80 <xmp3_GetBits>
 801c306:	63b0      	str	r0, [r6, #56]	@ 0x38

			if(sis->winSwitchFlag) {
 801c308:	2800      	cmp	r0, #0
 801c30a:	f000 8087 	beq.w	801c41c <xmp3_UnpackSideInfo+0x1d8>
				/* this is a start, stop, short, or mixed block */
				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
 801c30e:	2102      	movs	r1, #2
 801c310:	4628      	mov	r0, r5
 801c312:	f7ff fe35 	bl	801bf80 <xmp3_GetBits>
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 801c316:	2101      	movs	r1, #1
				sis->blockType =       GetBits(bsi, 2);		/* 0 = normal, 1 = start, 2 = short, 3 = stop */
 801c318:	63f0      	str	r0, [r6, #60]	@ 0x3c
 801c31a:	9000      	str	r0, [sp, #0]
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 801c31c:	4628      	mov	r0, r5
 801c31e:	f7ff fe2f 	bl	801bf80 <xmp3_GetBits>
				sis->tableSelect[0] =  GetBits(bsi, 5);
 801c322:	2105      	movs	r1, #5
				sis->mixedBlock =      GetBits(bsi, 1);		/* 0 = not mixed, 1 = mixed */
 801c324:	6430      	str	r0, [r6, #64]	@ 0x40
 801c326:	4680      	mov	r8, r0
				sis->tableSelect[0] =  GetBits(bsi, 5);
 801c328:	4628      	mov	r0, r5
 801c32a:	f7ff fe29 	bl	801bf80 <xmp3_GetBits>
				sis->tableSelect[1] =  GetBits(bsi, 5);
 801c32e:	2105      	movs	r1, #5
				sis->tableSelect[0] =  GetBits(bsi, 5);
 801c330:	6470      	str	r0, [r6, #68]	@ 0x44
				sis->tableSelect[1] =  GetBits(bsi, 5);
 801c332:	4628      	mov	r0, r5
 801c334:	f7ff fe24 	bl	801bf80 <xmp3_GetBits>
				sis->tableSelect[2] =  0;					/* unused */
 801c338:	2100      	movs	r1, #0
				sis->tableSelect[1] =  GetBits(bsi, 5);
 801c33a:	64b0      	str	r0, [r6, #72]	@ 0x48
				sis->tableSelect[2] =  0;					/* unused */
 801c33c:	64f1      	str	r1, [r6, #76]	@ 0x4c
				sis->subBlockGain[0] = GetBits(bsi, 3);
 801c33e:	4628      	mov	r0, r5
 801c340:	2103      	movs	r1, #3
 801c342:	f7ff fe1d 	bl	801bf80 <xmp3_GetBits>
				sis->subBlockGain[1] = GetBits(bsi, 3);
 801c346:	2103      	movs	r1, #3
				sis->subBlockGain[0] = GetBits(bsi, 3);
 801c348:	6530      	str	r0, [r6, #80]	@ 0x50
				sis->subBlockGain[1] = GetBits(bsi, 3);
 801c34a:	4628      	mov	r0, r5
 801c34c:	f7ff fe18 	bl	801bf80 <xmp3_GetBits>
				sis->subBlockGain[2] = GetBits(bsi, 3);
 801c350:	2103      	movs	r1, #3
				sis->subBlockGain[1] = GetBits(bsi, 3);
 801c352:	6570      	str	r0, [r6, #84]	@ 0x54
				sis->subBlockGain[2] = GetBits(bsi, 3);
 801c354:	4628      	mov	r0, r5
 801c356:	f7ff fe13 	bl	801bf80 <xmp3_GetBits>

				/* TODO - check logic */
				if (sis->blockType == 0) {
 801c35a:	9b00      	ldr	r3, [sp, #0]
				sis->subBlockGain[2] = GetBits(bsi, 3);
 801c35c:	65b0      	str	r0, [r6, #88]	@ 0x58
				if (sis->blockType == 0) {
 801c35e:	2b00      	cmp	r3, #0
 801c360:	d17e      	bne.n	801c460 <xmp3_UnpackSideInfo+0x21c>
					sis->region0Count = 8;
				} else {
					/* start, stop, or short-mixed */
					sis->region0Count = 7;
				}
				sis->region1Count = 20 - sis->region0Count;
 801c362:	6df0      	ldr	r0, [r6, #92]	@ 0x5c
					sis->sfCompress = 0;
 801c364:	6373      	str	r3, [r6, #52]	@ 0x34
					sis->part23Length = 0;
 801c366:	e9c6 330a 	strd	r3, r3, [r6, #40]	@ 0x28
				sis->region1Count = 20 - sis->region0Count;
 801c36a:	f1c0 0014 	rsb	r0, r0, #20
 801c36e:	6630      	str	r0, [r6, #96]	@ 0x60
				sis->tableSelect[1] =  GetBits(bsi, 5);
				sis->tableSelect[2] =  GetBits(bsi, 5);
				sis->region0Count =    GetBits(bsi, 4);
				sis->region1Count =    GetBits(bsi, 3);
			}
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 801c370:	2c00      	cmp	r4, #0
 801c372:	d070      	beq.n	801c456 <xmp3_UnpackSideInfo+0x212>
 801c374:	2000      	movs	r0, #0
 801c376:	6670      	str	r0, [r6, #100]	@ 0x64
			sis->sfactScale =        GetBits(bsi, 1);
 801c378:	2101      	movs	r1, #1
 801c37a:	4628      	mov	r0, r5
 801c37c:	f7ff fe00 	bl	801bf80 <xmp3_GetBits>
			sis->count1TableSelect = GetBits(bsi, 1);
 801c380:	2101      	movs	r1, #1
			sis->sfactScale =        GetBits(bsi, 1);
 801c382:	66b0      	str	r0, [r6, #104]	@ 0x68
			sis->count1TableSelect = GetBits(bsi, 1);
 801c384:	4628      	mov	r0, r5
 801c386:	f7ff fdfb 	bl	801bf80 <xmp3_GetBits>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801c38a:	3701      	adds	r7, #1
 801c38c:	455f      	cmp	r7, fp
			sis->count1TableSelect = GetBits(bsi, 1);
 801c38e:	66f0      	str	r0, [r6, #108]	@ 0x6c
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801c390:	f106 0648 	add.w	r6, r6, #72	@ 0x48
 801c394:	d19f      	bne.n	801c2d6 <xmp3_UnpackSideInfo+0x92>
	for(gr =0; gr < mp3DecInfo->nGrans; gr++) {
 801c396:	9b01      	ldr	r3, [sp, #4]
 801c398:	9a02      	ldr	r2, [sp, #8]
 801c39a:	3301      	adds	r3, #1
 801c39c:	429a      	cmp	r2, r3
 801c39e:	f10a 0a90 	add.w	sl, sl, #144	@ 0x90
 801c3a2:	d195      	bne.n	801c2d0 <xmp3_UnpackSideInfo+0x8c>
 801c3a4:	e9dd 6703 	ldrd	r6, r7, [sp, #12]
 801c3a8:	9c05      	ldr	r4, [sp, #20]
		}
	}
	mp3DecInfo->mainDataBegin = si->mainDataBegin;	/* needed by main decode loop */
 801c3aa:	6833      	ldr	r3, [r6, #0]
 801c3ac:	f8c4 37d8 	str.w	r3, [r4, #2008]	@ 0x7d8

	ASSERT(nBytes == CalcBitsUsed(bsi, buf, 0) >> 3);

	return nBytes;	
}
 801c3b0:	4638      	mov	r0, r7
 801c3b2:	b00b      	add	sp, #44	@ 0x2c
 801c3b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 801c3b8:	2b03      	cmp	r3, #3
 801c3ba:	d05e      	beq.n	801c47a <xmp3_UnpackSideInfo+0x236>
		si->mainDataBegin = GetBits(bsi, 9);
 801c3bc:	ad06      	add	r5, sp, #24
	bsi->bytePtr = buf;
 801c3be:	9106      	str	r1, [sp, #24]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c3c0:	2200      	movs	r2, #0
 801c3c2:	2320      	movs	r3, #32
		si->mainDataBegin = GetBits(bsi, 9);
 801c3c4:	2109      	movs	r1, #9
 801c3c6:	4628      	mov	r0, r5
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c3c8:	e9cd 2308 	strd	r2, r3, [sp, #32]
	bsi->iCache = 0;		/* 4-byte unsigned int */
 801c3cc:	f8cd 801c 	str.w	r8, [sp, #28]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 801c3d0:	2720      	movs	r7, #32
		si->mainDataBegin = GetBits(bsi, 9);
 801c3d2:	f7ff fdd5 	bl	801bf80 <xmp3_GetBits>
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 801c3d6:	2103      	movs	r1, #3
		si->mainDataBegin = GetBits(bsi, 9);
 801c3d8:	6030      	str	r0, [r6, #0]
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 801c3da:	4628      	mov	r0, r5
 801c3dc:	f7ff fdd0 	bl	801bf80 <xmp3_GetBits>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 801c3e0:	f8d4 37bc 	ldr.w	r3, [r4, #1980]	@ 0x7bc
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 801c3e4:	6070      	str	r0, [r6, #4]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 801c3e6:	2b00      	cmp	r3, #0
 801c3e8:	f77f af58 	ble.w	801c29c <xmp3_UnpackSideInfo+0x58>
 801c3ec:	f106 0a14 	add.w	sl, r6, #20
 801c3f0:	f04f 0b00 	mov.w	fp, #0
 801c3f4:	4699      	mov	r9, r3
 801c3f6:	9400      	str	r4, [sp, #0]
			for (bd = 0; bd < MAX_SCFBD; bd++)
 801c3f8:	f1aa 0410 	sub.w	r4, sl, #16
				si->scfsi[ch][bd] = GetBits(bsi, 1);
 801c3fc:	2101      	movs	r1, #1
 801c3fe:	4628      	mov	r0, r5
 801c400:	f7ff fdbe 	bl	801bf80 <xmp3_GetBits>
 801c404:	f844 0f04 	str.w	r0, [r4, #4]!
			for (bd = 0; bd < MAX_SCFBD; bd++)
 801c408:	4554      	cmp	r4, sl
 801c40a:	d1f7      	bne.n	801c3fc <xmp3_UnpackSideInfo+0x1b8>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 801c40c:	f10b 0b01 	add.w	fp, fp, #1
 801c410:	45cb      	cmp	fp, r9
 801c412:	f10a 0a10 	add.w	sl, sl, #16
 801c416:	d1ef      	bne.n	801c3f8 <xmp3_UnpackSideInfo+0x1b4>
 801c418:	9c00      	ldr	r4, [sp, #0]
 801c41a:	e73f      	b.n	801c29c <xmp3_UnpackSideInfo+0x58>
				sis->blockType = 0;
 801c41c:	e9c6 000f 	strd	r0, r0, [r6, #60]	@ 0x3c
				sis->tableSelect[0] =  GetBits(bsi, 5);
 801c420:	2105      	movs	r1, #5
 801c422:	4628      	mov	r0, r5
 801c424:	f7ff fdac 	bl	801bf80 <xmp3_GetBits>
				sis->tableSelect[1] =  GetBits(bsi, 5);
 801c428:	2105      	movs	r1, #5
				sis->tableSelect[0] =  GetBits(bsi, 5);
 801c42a:	6470      	str	r0, [r6, #68]	@ 0x44
				sis->tableSelect[1] =  GetBits(bsi, 5);
 801c42c:	4628      	mov	r0, r5
 801c42e:	f7ff fda7 	bl	801bf80 <xmp3_GetBits>
				sis->tableSelect[2] =  GetBits(bsi, 5);
 801c432:	2105      	movs	r1, #5
				sis->tableSelect[1] =  GetBits(bsi, 5);
 801c434:	64b0      	str	r0, [r6, #72]	@ 0x48
				sis->tableSelect[2] =  GetBits(bsi, 5);
 801c436:	4628      	mov	r0, r5
 801c438:	f7ff fda2 	bl	801bf80 <xmp3_GetBits>
				sis->region0Count =    GetBits(bsi, 4);
 801c43c:	2104      	movs	r1, #4
				sis->tableSelect[2] =  GetBits(bsi, 5);
 801c43e:	64f0      	str	r0, [r6, #76]	@ 0x4c
				sis->region0Count =    GetBits(bsi, 4);
 801c440:	4628      	mov	r0, r5
 801c442:	f7ff fd9d 	bl	801bf80 <xmp3_GetBits>
				sis->region1Count =    GetBits(bsi, 3);
 801c446:	2103      	movs	r1, #3
				sis->region0Count =    GetBits(bsi, 4);
 801c448:	65f0      	str	r0, [r6, #92]	@ 0x5c
				sis->region1Count =    GetBits(bsi, 3);
 801c44a:	4628      	mov	r0, r5
 801c44c:	f7ff fd98 	bl	801bf80 <xmp3_GetBits>
				sis->region1Count = 20 - sis->region0Count;
 801c450:	6630      	str	r0, [r6, #96]	@ 0x60
			sis->preFlag =           (fh->ver == MPEG1 ? GetBits(bsi, 1) : 0);
 801c452:	2c00      	cmp	r4, #0
 801c454:	d18e      	bne.n	801c374 <xmp3_UnpackSideInfo+0x130>
 801c456:	2101      	movs	r1, #1
 801c458:	4628      	mov	r0, r5
 801c45a:	f7ff fd91 	bl	801bf80 <xmp3_GetBits>
 801c45e:	e78a      	b.n	801c376 <xmp3_UnpackSideInfo+0x132>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 801c460:	2b02      	cmp	r3, #2
 801c462:	d003      	beq.n	801c46c <xmp3_UnpackSideInfo+0x228>
					sis->region0Count = 7;
 801c464:	2307      	movs	r3, #7
 801c466:	65f3      	str	r3, [r6, #92]	@ 0x5c
 801c468:	200d      	movs	r0, #13
				sis->region1Count = 20 - sis->region0Count;
 801c46a:	e780      	b.n	801c36e <xmp3_UnpackSideInfo+0x12a>
				} else if (sis->blockType == 2 && sis->mixedBlock == 0) {
 801c46c:	f1b8 0f00 	cmp.w	r8, #0
 801c470:	d1f8      	bne.n	801c464 <xmp3_UnpackSideInfo+0x220>
					sis->region0Count = 8;
 801c472:	2308      	movs	r3, #8
 801c474:	65f3      	str	r3, [r6, #92]	@ 0x5c
 801c476:	200c      	movs	r0, #12
 801c478:	e779      	b.n	801c36e <xmp3_UnpackSideInfo+0x12a>
		si->mainDataBegin = GetBits(bsi, 9);
 801c47a:	ad06      	add	r5, sp, #24
	bsi->bytePtr = buf;
 801c47c:	9106      	str	r1, [sp, #24]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c47e:	2200      	movs	r2, #0
 801c480:	2311      	movs	r3, #17
		si->mainDataBegin = GetBits(bsi, 9);
 801c482:	2109      	movs	r1, #9
 801c484:	4628      	mov	r0, r5
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c486:	e9cd 2308 	strd	r2, r3, [sp, #32]
	bsi->iCache = 0;		/* 4-byte unsigned int */
 801c48a:	f8cd 801c 	str.w	r8, [sp, #28]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG1_MONO : SIBYTES_MPEG1_STEREO);
 801c48e:	2711      	movs	r7, #17
		si->mainDataBegin = GetBits(bsi, 9);
 801c490:	f7ff fd76 	bl	801bf80 <xmp3_GetBits>
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 5 : 3));
 801c494:	2105      	movs	r1, #5
 801c496:	e79f      	b.n	801c3d8 <xmp3_UnpackSideInfo+0x194>
	bsi->iCache = 0;		/* 4-byte unsigned int */
 801c498:	2300      	movs	r3, #0
		si->mainDataBegin = GetBits(bsi, 8);
 801c49a:	ad06      	add	r5, sp, #24
	bsi->iCache = 0;		/* 4-byte unsigned int */
 801c49c:	e9cd 1306 	strd	r1, r3, [sp, #24]
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c4a0:	2200      	movs	r2, #0
 801c4a2:	2309      	movs	r3, #9
		si->mainDataBegin = GetBits(bsi, 8);
 801c4a4:	2108      	movs	r1, #8
 801c4a6:	4628      	mov	r0, r5
	bsi->cachedBits = 0;	/* i.e. zero bits in cache */
 801c4a8:	e9cd 2308 	strd	r2, r3, [sp, #32]
		nBytes = (fh->sMode == Mono ? SIBYTES_MPEG2_MONO : SIBYTES_MPEG2_STEREO);
 801c4ac:	2709      	movs	r7, #9
		si->mainDataBegin = GetBits(bsi, 8);
 801c4ae:	f7ff fd67 	bl	801bf80 <xmp3_GetBits>
		si->privateBits =   GetBits(bsi, (fh->sMode == Mono ? 1 : 2));
 801c4b2:	2101      	movs	r1, #1
 801c4b4:	e6ed      	b.n	801c292 <xmp3_UnpackSideInfo+0x4e>
		return -1;
 801c4b6:	f04f 37ff 	mov.w	r7, #4294967295
 801c4ba:	e779      	b.n	801c3b0 <xmp3_UnpackSideInfo+0x16c>

0801c4bc <xmp3_AllocateBuffers>:
 *
 * Notes:       if one or more mallocs fail, function frees any buffers already
 *                allocated before returning
 **************************************************************************************/
MP3DecInfo *AllocateBuffers(void)
{
 801c4bc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		cbuf[i] = 0;
 801c4c0:	4c22      	ldr	r4, [pc, #136]	@ (801c54c <xmp3_AllocateBuffers+0x90>)
 801c4c2:	f8df b098 	ldr.w	fp, [pc, #152]	@ 801c55c <xmp3_AllocateBuffers+0xa0>
 801c4c6:	f8df a098 	ldr.w	sl, [pc, #152]	@ 801c560 <xmp3_AllocateBuffers+0xa4>
 801c4ca:	f8df 9098 	ldr.w	r9, [pc, #152]	@ 801c564 <xmp3_AllocateBuffers+0xa8>
 801c4ce:	f8df 8098 	ldr.w	r8, [pc, #152]	@ 801c568 <xmp3_AllocateBuffers+0xac>
 801c4d2:	4f1f      	ldr	r7, [pc, #124]	@ (801c550 <xmp3_AllocateBuffers+0x94>)
 801c4d4:	4e1f      	ldr	r6, [pc, #124]	@ (801c554 <xmp3_AllocateBuffers+0x98>)
 801c4d6:	4d20      	ldr	r5, [pc, #128]	@ (801c558 <xmp3_AllocateBuffers+0x9c>)
 801c4d8:	f44f 62fe 	mov.w	r2, #2032	@ 0x7f0
 801c4dc:	2100      	movs	r1, #0
 801c4de:	4620      	mov	r0, r4
 801c4e0:	f005 fe10 	bl	8022104 <memset>
 801c4e4:	2238      	movs	r2, #56	@ 0x38
 801c4e6:	2100      	movs	r1, #0
 801c4e8:	4658      	mov	r0, fp
 801c4ea:	f005 fe0b 	bl	8022104 <memset>
 801c4ee:	f44f 72a4 	mov.w	r2, #328	@ 0x148
 801c4f2:	2100      	movs	r1, #0
 801c4f4:	4650      	mov	r0, sl
 801c4f6:	f005 fe05 	bl	8022104 <memset>
 801c4fa:	f44f 728e 	mov.w	r2, #284	@ 0x11c
 801c4fe:	2100      	movs	r1, #0
 801c500:	4648      	mov	r0, r9
 801c502:	f005 fdff 	bl	8022104 <memset>
 801c506:	f241 2210 	movw	r2, #4624	@ 0x1210
 801c50a:	2100      	movs	r1, #0
 801c50c:	4640      	mov	r0, r8
 801c50e:	f005 fdf9 	bl	8022104 <memset>
 801c512:	f44f 7252 	mov.w	r2, #840	@ 0x348
 801c516:	2100      	movs	r1, #0
 801c518:	4638      	mov	r0, r7
 801c51a:	f005 fdf3 	bl	8022104 <memset>
 801c51e:	f44f 52d9 	mov.w	r2, #6944	@ 0x1b20
 801c522:	2100      	movs	r1, #0
 801c524:	4630      	mov	r0, r6
 801c526:	f005 fded 	bl	8022104 <memset>
 801c52a:	f242 2204 	movw	r2, #8708	@ 0x2204
 801c52e:	2100      	movs	r1, #0
 801c530:	4628      	mov	r0, r5
 801c532:	f005 fde7 	bl	8022104 <memset>
	ClearBuffer(sbi, sizeof(SubbandInfo));

#endif

	mp3DecInfo->FrameHeaderPS =     (void *)fh;
	mp3DecInfo->SideInfoPS =        (void *)si;
 801c536:	e9c4 ba00 	strd	fp, sl, [r4]
	mp3DecInfo->ScaleFactorInfoPS = (void *)sfi;
	mp3DecInfo->HuffmanInfoPS =     (void *)hi;
 801c53a:	e9c4 9802 	strd	r9, r8, [r4, #8]
	mp3DecInfo->DequantInfoPS =     (void *)di;
	mp3DecInfo->IMDCTInfoPS =       (void *)mi;
 801c53e:	e9c4 7604 	strd	r7, r6, [r4, #16]
	mp3DecInfo->SubbandInfoPS =     (void *)sbi;
 801c542:	61a5      	str	r5, [r4, #24]
	DV_DEBUG_USART_Trace( COPY_DEBUG_BUFFER );
#endif
#endif

	return mp3DecInfo;
}
 801c544:	4620      	mov	r0, r4
 801c546:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c54a:	bf00      	nop
 801c54c:	200119d0 	.word	0x200119d0
 801c550:	200101dc 	.word	0x200101dc
 801c554:	2000e6bc 	.word	0x2000e6bc
 801c558:	2000c4b8 	.word	0x2000c4b8
 801c55c:	20011998 	.word	0x20011998
 801c560:	20011850 	.word	0x20011850
 801c564:	20011734 	.word	0x20011734
 801c568:	20010524 	.word	0x20010524

0801c56c <xmp3_FDCT32>:
 *              possibly interleave stereo (cut # of coef loads in half - may not have
 *                enough registers)
 **************************************************************************************/
// about 1ms faster in RAM
/*__attribute__ ((section (".data")))*/ void FDCT32(int *buf, int *dest, int offset, int oddBlock, int gb)
{
 801c56c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801c570:	b087      	sub	sp, #28
 801c572:	4688      	mov	r8, r1
 801c574:	9c10      	ldr	r4, [sp, #64]	@ 0x40
	/* scaling - ensure at least 6 guard bits for DCT 
	 * (in practice this is already true 99% of time, so this code is
	 *  almost never triggered)
	 */
	es = 0;
	if (gb < 6) {
 801c576:	2c05      	cmp	r4, #5
{
 801c578:	4617      	mov	r7, r2
 801c57a:	461e      	mov	r6, r3
	if (gb < 6) {
 801c57c:	f300 830e 	bgt.w	801cb9c <xmp3_FDCT32+0x630>
		es = 6 - gb;
 801c580:	f1c4 0b06 	rsb	fp, r4, #6
		for (i = 0; i < 32; i++)
 801c584:	1f03      	subs	r3, r0, #4
 801c586:	f100 017c 	add.w	r1, r0, #124	@ 0x7c
			buf[i] >>= es;
 801c58a:	f853 2f04 	ldr.w	r2, [r3, #4]!
 801c58e:	fa42 f20b 	asr.w	r2, r2, fp
		for (i = 0; i < 32; i++)
 801c592:	4299      	cmp	r1, r3
			buf[i] >>= es;
 801c594:	601a      	str	r2, [r3, #0]
		for (i = 0; i < 32; i++)
 801c596:	d1f8      	bne.n	801c58a <xmp3_FDCT32+0x1e>
	}

	/* first pass */    
	D32FP(0, 1, 5, 1);
 801c598:	6fc1      	ldr	r1, [r0, #124]	@ 0x7c
 801c59a:	6802      	ldr	r2, [r0, #0]
 801c59c:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 801c59e:	6c05      	ldr	r5, [r0, #64]	@ 0x40
 801c5a0:	1a53      	subs	r3, r2, r1
 801c5a2:	440a      	add	r2, r1
	 * For inline assembly, x and y are not assumed to be R0, R1 so it shouldn't matter
	 *   which one is returned. (If this were a function call, returning y (R1) would
	 *   require an extra "mov r0, r1")
     */
    int zlow;
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801c5a4:	49cc      	ldr	r1, [pc, #816]	@ (801c8d8 <xmp3_FDCT32+0x36c>)
 801c5a6:	fb81 c303 	smull	ip, r3, r1, r3
 801c5aa:	1b61      	subs	r1, r4, r5
 801c5ac:	005b      	lsls	r3, r3, #1
 801c5ae:	442c      	add	r4, r5
 801c5b0:	4dca      	ldr	r5, [pc, #808]	@ (801c8dc <xmp3_FDCT32+0x370>)
 801c5b2:	fb85 c101 	smull	ip, r1, r5, r1
 801c5b6:	1915      	adds	r5, r2, r4
 801c5b8:	0149      	lsls	r1, r1, #5
 801c5ba:	1b12      	subs	r2, r2, r4
 801c5bc:	6005      	str	r5, [r0, #0]
 801c5be:	4cc8      	ldr	r4, [pc, #800]	@ (801c8e0 <xmp3_FDCT32+0x374>)
 801c5c0:	fb84 5202 	smull	r5, r2, r4, r2
 801c5c4:	0052      	lsls	r2, r2, #1
 801c5c6:	63c2      	str	r2, [r0, #60]	@ 0x3c
 801c5c8:	185a      	adds	r2, r3, r1
 801c5ca:	6402      	str	r2, [r0, #64]	@ 0x40
 801c5cc:	1a5b      	subs	r3, r3, r1
 801c5ce:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(1, 1, 3, 1);
 801c5d2:	6f81      	ldr	r1, [r0, #120]	@ 0x78
 801c5d4:	6842      	ldr	r2, [r0, #4]
 801c5d6:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 801c5d8:	6c45      	ldr	r5, [r0, #68]	@ 0x44
	D32FP(0, 1, 5, 1);
 801c5da:	005b      	lsls	r3, r3, #1
 801c5dc:	67c3      	str	r3, [r0, #124]	@ 0x7c
	D32FP(1, 1, 3, 1);
 801c5de:	1a53      	subs	r3, r2, r1
 801c5e0:	440a      	add	r2, r1
 801c5e2:	49c0      	ldr	r1, [pc, #768]	@ (801c8e4 <xmp3_FDCT32+0x378>)
 801c5e4:	fb81 c303 	smull	ip, r3, r1, r3
 801c5e8:	1b61      	subs	r1, r4, r5
 801c5ea:	005b      	lsls	r3, r3, #1
 801c5ec:	442c      	add	r4, r5
 801c5ee:	4dbe      	ldr	r5, [pc, #760]	@ (801c8e8 <xmp3_FDCT32+0x37c>)
 801c5f0:	fb85 c101 	smull	ip, r1, r5, r1
 801c5f4:	1915      	adds	r5, r2, r4
 801c5f6:	00c9      	lsls	r1, r1, #3
 801c5f8:	1b12      	subs	r2, r2, r4
 801c5fa:	6045      	str	r5, [r0, #4]
 801c5fc:	4cbb      	ldr	r4, [pc, #748]	@ (801c8ec <xmp3_FDCT32+0x380>)
 801c5fe:	fb84 5202 	smull	r5, r2, r4, r2
 801c602:	0052      	lsls	r2, r2, #1
 801c604:	6382      	str	r2, [r0, #56]	@ 0x38
 801c606:	185a      	adds	r2, r3, r1
 801c608:	6442      	str	r2, [r0, #68]	@ 0x44
 801c60a:	1a5b      	subs	r3, r3, r1
 801c60c:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(2, 1, 3, 1);
 801c610:	6f41      	ldr	r1, [r0, #116]	@ 0x74
 801c612:	6882      	ldr	r2, [r0, #8]
 801c614:	6b44      	ldr	r4, [r0, #52]	@ 0x34
 801c616:	6c85      	ldr	r5, [r0, #72]	@ 0x48
	D32FP(1, 1, 3, 1);
 801c618:	005b      	lsls	r3, r3, #1
 801c61a:	6783      	str	r3, [r0, #120]	@ 0x78
	D32FP(2, 1, 3, 1);
 801c61c:	1a53      	subs	r3, r2, r1
 801c61e:	440a      	add	r2, r1
 801c620:	49b3      	ldr	r1, [pc, #716]	@ (801c8f0 <xmp3_FDCT32+0x384>)
 801c622:	fb81 c303 	smull	ip, r3, r1, r3
 801c626:	1b61      	subs	r1, r4, r5
 801c628:	005b      	lsls	r3, r3, #1
 801c62a:	442c      	add	r4, r5
 801c62c:	4db1      	ldr	r5, [pc, #708]	@ (801c8f4 <xmp3_FDCT32+0x388>)
 801c62e:	fb85 c101 	smull	ip, r1, r5, r1
 801c632:	1915      	adds	r5, r2, r4
 801c634:	00c9      	lsls	r1, r1, #3
 801c636:	1b12      	subs	r2, r2, r4
 801c638:	6085      	str	r5, [r0, #8]
 801c63a:	4caf      	ldr	r4, [pc, #700]	@ (801c8f8 <xmp3_FDCT32+0x38c>)
 801c63c:	fb84 5202 	smull	r5, r2, r4, r2
 801c640:	0052      	lsls	r2, r2, #1
 801c642:	6342      	str	r2, [r0, #52]	@ 0x34
 801c644:	185a      	adds	r2, r3, r1
 801c646:	6482      	str	r2, [r0, #72]	@ 0x48
 801c648:	1a5b      	subs	r3, r3, r1
 801c64a:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(3, 1, 2, 1);
 801c64e:	6f01      	ldr	r1, [r0, #112]	@ 0x70
 801c650:	68c2      	ldr	r2, [r0, #12]
 801c652:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 801c654:	6cc5      	ldr	r5, [r0, #76]	@ 0x4c
	D32FP(2, 1, 3, 1);
 801c656:	005b      	lsls	r3, r3, #1
 801c658:	6743      	str	r3, [r0, #116]	@ 0x74
	D32FP(3, 1, 2, 1);
 801c65a:	1a53      	subs	r3, r2, r1
 801c65c:	440a      	add	r2, r1
 801c65e:	49a7      	ldr	r1, [pc, #668]	@ (801c8fc <xmp3_FDCT32+0x390>)
 801c660:	fb81 c303 	smull	ip, r3, r1, r3
 801c664:	1b61      	subs	r1, r4, r5
 801c666:	005b      	lsls	r3, r3, #1
 801c668:	442c      	add	r4, r5
 801c66a:	4da5      	ldr	r5, [pc, #660]	@ (801c900 <xmp3_FDCT32+0x394>)
 801c66c:	fb85 c101 	smull	ip, r1, r5, r1
 801c670:	1915      	adds	r5, r2, r4
 801c672:	0089      	lsls	r1, r1, #2
 801c674:	1b12      	subs	r2, r2, r4
 801c676:	60c5      	str	r5, [r0, #12]
 801c678:	4ca2      	ldr	r4, [pc, #648]	@ (801c904 <xmp3_FDCT32+0x398>)
 801c67a:	fb84 5202 	smull	r5, r2, r4, r2
 801c67e:	0052      	lsls	r2, r2, #1
 801c680:	6302      	str	r2, [r0, #48]	@ 0x30
 801c682:	185a      	adds	r2, r3, r1
 801c684:	64c2      	str	r2, [r0, #76]	@ 0x4c
 801c686:	1a5b      	subs	r3, r3, r1
 801c688:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(4, 1, 2, 1);
 801c68c:	6ec1      	ldr	r1, [r0, #108]	@ 0x6c
 801c68e:	6902      	ldr	r2, [r0, #16]
 801c690:	6ac4      	ldr	r4, [r0, #44]	@ 0x2c
 801c692:	6d05      	ldr	r5, [r0, #80]	@ 0x50
	D32FP(3, 1, 2, 1);
 801c694:	005b      	lsls	r3, r3, #1
 801c696:	6703      	str	r3, [r0, #112]	@ 0x70
	D32FP(4, 1, 2, 1);
 801c698:	1a53      	subs	r3, r2, r1
 801c69a:	440a      	add	r2, r1
 801c69c:	499a      	ldr	r1, [pc, #616]	@ (801c908 <xmp3_FDCT32+0x39c>)
 801c69e:	fb81 c303 	smull	ip, r3, r1, r3
 801c6a2:	1b61      	subs	r1, r4, r5
 801c6a4:	005b      	lsls	r3, r3, #1
 801c6a6:	442c      	add	r4, r5
 801c6a8:	4d98      	ldr	r5, [pc, #608]	@ (801c90c <xmp3_FDCT32+0x3a0>)
 801c6aa:	fb85 c101 	smull	ip, r1, r5, r1
 801c6ae:	1915      	adds	r5, r2, r4
 801c6b0:	0089      	lsls	r1, r1, #2
 801c6b2:	1b12      	subs	r2, r2, r4
 801c6b4:	6105      	str	r5, [r0, #16]
 801c6b6:	4c96      	ldr	r4, [pc, #600]	@ (801c910 <xmp3_FDCT32+0x3a4>)
 801c6b8:	fb84 5202 	smull	r5, r2, r4, r2
 801c6bc:	0052      	lsls	r2, r2, #1
 801c6be:	62c2      	str	r2, [r0, #44]	@ 0x2c
 801c6c0:	185a      	adds	r2, r3, r1
 801c6c2:	6502      	str	r2, [r0, #80]	@ 0x50
 801c6c4:	1a5b      	subs	r3, r3, r1
 801c6c6:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(5, 1, 1, 2);
 801c6ca:	6e81      	ldr	r1, [r0, #104]	@ 0x68
 801c6cc:	6942      	ldr	r2, [r0, #20]
 801c6ce:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 801c6d0:	6d45      	ldr	r5, [r0, #84]	@ 0x54
	D32FP(4, 1, 2, 1);
 801c6d2:	005b      	lsls	r3, r3, #1
 801c6d4:	66c3      	str	r3, [r0, #108]	@ 0x6c
	D32FP(5, 1, 1, 2);
 801c6d6:	1a53      	subs	r3, r2, r1
 801c6d8:	440a      	add	r2, r1
 801c6da:	498e      	ldr	r1, [pc, #568]	@ (801c914 <xmp3_FDCT32+0x3a8>)
 801c6dc:	fb81 c303 	smull	ip, r3, r1, r3
 801c6e0:	1b61      	subs	r1, r4, r5
 801c6e2:	005b      	lsls	r3, r3, #1
 801c6e4:	442c      	add	r4, r5
 801c6e6:	4d8c      	ldr	r5, [pc, #560]	@ (801c918 <xmp3_FDCT32+0x3ac>)
 801c6e8:	fb85 c101 	smull	ip, r1, r5, r1
 801c6ec:	1915      	adds	r5, r2, r4
 801c6ee:	0049      	lsls	r1, r1, #1
 801c6f0:	1b12      	subs	r2, r2, r4
 801c6f2:	6145      	str	r5, [r0, #20]
 801c6f4:	4c89      	ldr	r4, [pc, #548]	@ (801c91c <xmp3_FDCT32+0x3b0>)
 801c6f6:	fb84 5202 	smull	r5, r2, r4, r2
 801c6fa:	0092      	lsls	r2, r2, #2
 801c6fc:	6282      	str	r2, [r0, #40]	@ 0x28
 801c6fe:	185a      	adds	r2, r3, r1
 801c700:	6542      	str	r2, [r0, #84]	@ 0x54
 801c702:	1a5b      	subs	r3, r3, r1
 801c704:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(6, 1, 1, 2);
 801c708:	6e41      	ldr	r1, [r0, #100]	@ 0x64
 801c70a:	6982      	ldr	r2, [r0, #24]
 801c70c:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 801c70e:	6d85      	ldr	r5, [r0, #88]	@ 0x58
	D32FP(5, 1, 1, 2);
 801c710:	009b      	lsls	r3, r3, #2
 801c712:	6683      	str	r3, [r0, #104]	@ 0x68
	D32FP(6, 1, 1, 2);
 801c714:	1a53      	subs	r3, r2, r1
 801c716:	440a      	add	r2, r1
 801c718:	4981      	ldr	r1, [pc, #516]	@ (801c920 <xmp3_FDCT32+0x3b4>)
 801c71a:	fb81 c303 	smull	ip, r3, r1, r3
 801c71e:	1b61      	subs	r1, r4, r5
 801c720:	005b      	lsls	r3, r3, #1
 801c722:	442c      	add	r4, r5
 801c724:	4d7f      	ldr	r5, [pc, #508]	@ (801c924 <xmp3_FDCT32+0x3b8>)
 801c726:	fb85 c101 	smull	ip, r1, r5, r1
 801c72a:	1915      	adds	r5, r2, r4
 801c72c:	0049      	lsls	r1, r1, #1
 801c72e:	1b12      	subs	r2, r2, r4
 801c730:	6185      	str	r5, [r0, #24]
 801c732:	4c7d      	ldr	r4, [pc, #500]	@ (801c928 <xmp3_FDCT32+0x3bc>)
 801c734:	fb84 5202 	smull	r5, r2, r4, r2
 801c738:	0092      	lsls	r2, r2, #2
 801c73a:	6242      	str	r2, [r0, #36]	@ 0x24
 801c73c:	185a      	adds	r2, r3, r1
 801c73e:	6582      	str	r2, [r0, #88]	@ 0x58
 801c740:	1a5b      	subs	r3, r3, r1
 801c742:	fb84 2303 	smull	r2, r3, r4, r3
	D32FP(7, 1, 1, 4);
 801c746:	6e01      	ldr	r1, [r0, #96]	@ 0x60
 801c748:	69c2      	ldr	r2, [r0, #28]
 801c74a:	6a04      	ldr	r4, [r0, #32]
 801c74c:	6dc5      	ldr	r5, [r0, #92]	@ 0x5c
	D32FP(6, 1, 1, 2);
 801c74e:	009b      	lsls	r3, r3, #2
 801c750:	6643      	str	r3, [r0, #100]	@ 0x64
	D32FP(7, 1, 1, 4);
 801c752:	1a53      	subs	r3, r2, r1
 801c754:	440a      	add	r2, r1
 801c756:	4975      	ldr	r1, [pc, #468]	@ (801c92c <xmp3_FDCT32+0x3c0>)
 801c758:	fb81 c303 	smull	ip, r3, r1, r3
 801c75c:	1b61      	subs	r1, r4, r5
 801c75e:	005b      	lsls	r3, r3, #1
 801c760:	442c      	add	r4, r5
 801c762:	4d73      	ldr	r5, [pc, #460]	@ (801c930 <xmp3_FDCT32+0x3c4>)
 801c764:	fb85 c101 	smull	ip, r1, r5, r1
 801c768:	1915      	adds	r5, r2, r4
 801c76a:	0049      	lsls	r1, r1, #1
 801c76c:	1b12      	subs	r2, r2, r4
 801c76e:	61c5      	str	r5, [r0, #28]
 801c770:	4c70      	ldr	r4, [pc, #448]	@ (801c934 <xmp3_FDCT32+0x3c8>)
 801c772:	fb84 5202 	smull	r5, r2, r4, r2
 801c776:	0112      	lsls	r2, r2, #4
 801c778:	6202      	str	r2, [r0, #32]
 801c77a:	185a      	adds	r2, r3, r1
 801c77c:	65c2      	str	r2, [r0, #92]	@ 0x5c
 801c77e:	1a5b      	subs	r3, r3, r1
 801c780:	fb84 2303 	smull	r2, r3, r4, r3

    return y;
 801c784:	e9cd b001 	strd	fp, r0, [sp, #4]
 801c788:	e9cd 8703 	strd	r8, r7, [sp, #12]
 801c78c:	011b      	lsls	r3, r3, #4
 801c78e:	f100 02a0 	add.w	r2, r0, #160	@ 0xa0
 801c792:	f8df a1a8 	ldr.w	sl, [pc, #424]	@ 801c93c <xmp3_FDCT32+0x3d0>
 801c796:	6603      	str	r3, [r0, #96]	@ 0x60

	/* second pass */
	for (i = 4; i > 0; i--) {
 801c798:	9605      	str	r6, [sp, #20]
 801c79a:	f100 0320 	add.w	r3, r0, #32
 801c79e:	9200      	str	r2, [sp, #0]
		a0 = buf[0]; 	    a7 = buf[7];		a3 = buf[3];	    a4 = buf[4];
 801c7a0:	f853 2c04 	ldr.w	r2, [r3, #-4]
 801c7a4:	f853 5c20 	ldr.w	r5, [r3, #-32]
 801c7a8:	f853 7c14 	ldr.w	r7, [r3, #-20]
 801c7ac:	f853 0c10 	ldr.w	r0, [r3, #-16]
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 801c7b0:	1aa9      	subs	r1, r5, r2
 801c7b2:	4415      	add	r5, r2
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801c7b4:	f8da 2060 	ldr.w	r2, [sl, #96]	@ 0x60
 801c7b8:	fb82 4101 	smull	r4, r1, r2, r1
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 801c7bc:	1a3c      	subs	r4, r7, r0
 801c7be:	f8da 2064 	ldr.w	r2, [sl, #100]	@ 0x64
		b0 = a0 + a7;	    b7 = MULSHIFT32(*cptr++, a0 - a7) << 1;
 801c7c2:	0049      	lsls	r1, r1, #1
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 801c7c4:	4407      	add	r7, r0
 801c7c6:	fb82 0404 	smull	r0, r4, r2, r4
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 801c7ca:	1be8      	subs	r0, r5, r7
 801c7cc:	f8da 2068 	ldr.w	r2, [sl, #104]	@ 0x68
		b3 = a3 + a4;	    b4 = MULSHIFT32(*cptr++, a3 - a4) << 3;
 801c7d0:	00e4      	lsls	r4, r4, #3
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 801c7d2:	443d      	add	r5, r7
 801c7d4:	fb82 7000 	smull	r7, r0, r2, r0
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 801c7d8:	1b0f      	subs	r7, r1, r4
		a0 = b0 + b3;	    a3 = MULSHIFT32(*cptr,   b0 - b3) << 1;
 801c7da:	0040      	lsls	r0, r0, #1
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 801c7dc:	4421      	add	r1, r4
 801c7de:	fb82 4707 	smull	r4, r7, r2, r7

		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 801c7e2:	f853 2c08 	ldr.w	r2, [r3, #-8]
 801c7e6:	f853 9c1c 	ldr.w	r9, [r3, #-28]
 801c7ea:	f853 cc18 	ldr.w	ip, [r3, #-24]
 801c7ee:	f8da 606c 	ldr.w	r6, [sl, #108]	@ 0x6c
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 801c7f2:	eba9 0402 	sub.w	r4, r9, r2
		a4 = b4 + b7;		a7 = MULSHIFT32(*cptr++, b7 - b4) << 1;
 801c7f6:	007f      	lsls	r7, r7, #1
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 801c7f8:	4491      	add	r9, r2
		a1 = buf[1];	    a6 = buf[6];	    a2 = buf[2];	    a5 = buf[5];
 801c7fa:	f853 2c0c 	ldr.w	r2, [r3, #-12]
 801c7fe:	fb86 8404 	smull	r8, r4, r6, r4
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 801c802:	ebac 0802 	sub.w	r8, ip, r2
		b1 = a1 + a6;	    b6 = MULSHIFT32(*cptr++, a1 - a6) << 1;
 801c806:	0064      	lsls	r4, r4, #1
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 801c808:	4494      	add	ip, r2
 801c80a:	f8da 2070 	ldr.w	r2, [sl, #112]	@ 0x70
 801c80e:	fb82 e808 	smull	lr, r8, r2, r8
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 801c812:	eba9 0e0c 	sub.w	lr, r9, ip
		b2 = a2 + a5;	    b5 = MULSHIFT32(*cptr++, a2 - a5) << 1;
 801c816:	ea4f 0848 	mov.w	r8, r8, lsl #1
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 801c81a:	44e1      	add	r9, ip
 801c81c:	f8da c074 	ldr.w	ip, [sl, #116]	@ 0x74
 801c820:	fb8c 2e0e 	smull	r2, lr, ip, lr
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 801c824:	eba4 0208 	sub.w	r2, r4, r8
		a1 = b1 + b2;		a2 = MULSHIFT32(*cptr,   b1 - b2) << 2;
 801c828:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
		a5 = b5 + b6;	    a6 = MULSHIFT32(*cptr++, b6 - b5) << 2;
 801c82c:	4444      	add	r4, r8
 801c82e:	fb8c 8202 	smull	r8, r2, ip, r2
 801c832:	4e41      	ldr	r6, [pc, #260]	@ (801c938 <xmp3_FDCT32+0x3cc>)
 801c834:	0092      	lsls	r2, r2, #2

		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 801c836:	eba5 0809 	sub.w	r8, r5, r9
 801c83a:	fb86 c808 	smull	ip, r8, r6, r8
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 801c83e:	eba0 0c0e 	sub.w	ip, r0, lr
 801c842:	fb86 bc0c 	smull	fp, ip, r6, ip
 801c846:	4470      	add	r0, lr
		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 801c848:	444d      	add	r5, r9
		buf[0] = b0;	    buf[1] = b1;
		buf[2] = b2 + b3;	buf[3] = b3;
 801c84a:	eb00 004c 	add.w	r0, r0, ip, lsl #1
		buf[0] = b0;	    buf[1] = b1;
 801c84e:	f843 5c20 	str.w	r5, [r3, #-32]
		buf[2] = b2 + b3;	buf[3] = b3;
 801c852:	f843 0c18 	str.w	r0, [r3, #-24]
		b0 = a0 + a1;	    b1 = MULSHIFT32(COS4_0, a0 - a1) << 1;
 801c856:	ea4f 0548 	mov.w	r5, r8, lsl #1
		b2 = a2 + a3;	    b3 = MULSHIFT32(COS4_0, a3 - a2) << 1;
 801c85a:	ea4f 004c 	mov.w	r0, ip, lsl #1
		buf[2] = b2 + b3;	buf[3] = b3;
 801c85e:	f843 0c14 	str.w	r0, [r3, #-20]
		buf[0] = b0;	    buf[1] = b1;
 801c862:	f843 5c1c 	str.w	r5, [r3, #-28]

		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 801c866:	1b08      	subs	r0, r1, r4
 801c868:	fb86 5000 	smull	r5, r0, r6, r0
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 801c86c:	1abd      	subs	r5, r7, r2
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 801c86e:	0040      	lsls	r0, r0, #1
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 801c870:	443a      	add	r2, r7
 801c872:	fb86 7505 	smull	r7, r5, r6, r5
		b6 += b7;
 801c876:	eb02 0245 	add.w	r2, r2, r5, lsl #1
		b4 = a4 + a5;	    b5 = MULSHIFT32(COS4_0, a4 - a5) << 1;
 801c87a:	4421      	add	r1, r4
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 801c87c:	4411      	add	r1, r2
		buf[6] = b5 + b6;	buf[7] = b7;
 801c87e:	4402      	add	r2, r0
 801c880:	f843 2c08 	str.w	r2, [r3, #-8]
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 801c884:	eb00 0045 	add.w	r0, r0, r5, lsl #1
	for (i = 4; i > 0; i--) {
 801c888:	9a00      	ldr	r2, [sp, #0]
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 801c88a:	f843 1c10 	str.w	r1, [r3, #-16]
		b6 = a6 + a7;	    b7 = MULSHIFT32(COS4_0, a7 - a6) << 1;
 801c88e:	006d      	lsls	r5, r5, #1
		buf[4] = b4 + b6;	buf[5] = b5 + b7;
 801c890:	f843 0c0c 	str.w	r0, [r3, #-12]
		buf[6] = b5 + b6;	buf[7] = b7;
 801c894:	f843 5c04 	str.w	r5, [r3, #-4]
	for (i = 4; i > 0; i--) {
 801c898:	3320      	adds	r3, #32
 801c89a:	4293      	cmp	r3, r2
 801c89c:	f10a 0a18 	add.w	sl, sl, #24
 801c8a0:	f47f af7e 	bne.w	801c7a0 <xmp3_FDCT32+0x234>
		buf += 8;
	}
	buf -= 32;	/* reset */

	/* sample 0 - always delayed one block */
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 801c8a4:	e9dd 8703 	ldrd	r8, r7, [sp, #12]
 801c8a8:	9e05      	ldr	r6, [sp, #20]
 801c8aa:	1bbb      	subs	r3, r7, r6
 801c8ac:	f003 0307 	and.w	r3, r3, #7
 801c8b0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801c8b4:	e9dd b001 	ldrd	fp, r0, [sp, #4]
	s = buf[ 0];				d[0] = d[8] = s;
    
	/* samples 16 to 31 */
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 801c8b8:	00ba      	lsls	r2, r7, #2
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 801c8ba:	0099      	lsls	r1, r3, #2
 801c8bc:	2e00      	cmp	r6, #0
 801c8be:	f000 8162 	beq.w	801cb86 <xmp3_FDCT32+0x61a>
 801c8c2:	eb08 0601 	add.w	r6, r8, r1
	s = buf[ 0];				d[0] = d[8] = s;
 801c8c6:	6804      	ldr	r4, [r0, #0]
 801c8c8:	6234      	str	r4, [r6, #32]
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 801c8ca:	f502 5288 	add.w	r2, r2, #4352	@ 0x1100
	s = buf[ 0];				d[0] = d[8] = s;
 801c8ce:	f848 4023 	str.w	r4, [r8, r3, lsl #2]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 801c8d2:	2300      	movs	r3, #0
 801c8d4:	e034      	b.n	801c940 <xmp3_FDCT32+0x3d4>
 801c8d6:	bf00      	nop
 801c8d8:	4013c251 	.word	0x4013c251
 801c8dc:	518522fb 	.word	0x518522fb
 801c8e0:	404f4672 	.word	0x404f4672
 801c8e4:	40b345bd 	.word	0x40b345bd
 801c8e8:	6d0b20cf 	.word	0x6d0b20cf
 801c8ec:	42e13c10 	.word	0x42e13c10
 801c8f0:	41fa2d6d 	.word	0x41fa2d6d
 801c8f4:	41d95790 	.word	0x41d95790
 801c8f8:	48919f44 	.word	0x48919f44
 801c8fc:	43f93421 	.word	0x43f93421
 801c900:	5efc8d96 	.word	0x5efc8d96
 801c904:	52cb0e63 	.word	0x52cb0e63
 801c908:	46cc1bc4 	.word	0x46cc1bc4
 801c90c:	4ad81a97 	.word	0x4ad81a97
 801c910:	64e2402e 	.word	0x64e2402e
 801c914:	4a9d9cf0 	.word	0x4a9d9cf0
 801c918:	7c7d1db3 	.word	0x7c7d1db3
 801c91c:	43e224a9 	.word	0x43e224a9
 801c920:	4fae3711 	.word	0x4fae3711
 801c924:	6b6fcf26 	.word	0x6b6fcf26
 801c928:	6e3c92c1 	.word	0x6e3c92c1
 801c92c:	56601ea7 	.word	0x56601ea7
 801c930:	5f4cf6eb 	.word	0x5f4cf6eb
 801c934:	519e4e04 	.word	0x519e4e04
 801c938:	5a82799a 	.word	0x5a82799a
 801c93c:	0803551c 	.word	0x0803551c
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
	s = buf[15];				d[0] = d[8] = s;	d += 64;
	s = tmp;					d[0] = d[8] = s;

	/* samples 16 to 1 (sample 16 used again) */
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 801c940:	f5a1 617c 	sub.w	r1, r1, #4032	@ 0xfc0
 801c944:	4419      	add	r1, r3
	d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
 801c946:	eb08 0302 	add.w	r3, r8, r2
	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 801c94a:	6844      	ldr	r4, [r0, #4]
 801c94c:	621c      	str	r4, [r3, #32]
 801c94e:	f848 4002 	str.w	r4, [r8, r2]
	tmp = buf[25] + buf[29];
 801c952:	6f45      	ldr	r5, [r0, #116]	@ 0x74
 801c954:	6e44      	ldr	r4, [r0, #100]	@ 0x64
 801c956:	442c      	add	r4, r5
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 801c958:	6c45      	ldr	r5, [r0, #68]	@ 0x44
 801c95a:	4425      	add	r5, r4
 801c95c:	f8c3 5120 	str.w	r5, [r3, #288]	@ 0x120
 801c960:	f8c3 5100 	str.w	r5, [r3, #256]	@ 0x100
	s = buf[ 9] + buf[13];		d[0] = d[8] = s;	d += 64;
 801c964:	6b47      	ldr	r7, [r0, #52]	@ 0x34
 801c966:	6a45      	ldr	r5, [r0, #36]	@ 0x24
 801c968:	443d      	add	r5, r7
 801c96a:	f8c3 5220 	str.w	r5, [r3, #544]	@ 0x220
 801c96e:	f8c3 5200 	str.w	r5, [r3, #512]	@ 0x200
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 801c972:	6d45      	ldr	r5, [r0, #84]	@ 0x54
 801c974:	442c      	add	r4, r5
 801c976:	f8c3 4320 	str.w	r4, [r3, #800]	@ 0x320
 801c97a:	f8c3 4300 	str.w	r4, [r3, #768]	@ 0x300
	tmp = buf[29] + buf[27];
 801c97e:	6f45      	ldr	r5, [r0, #116]	@ 0x74
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 801c980:	6947      	ldr	r7, [r0, #20]
	tmp = buf[29] + buf[27];
 801c982:	6ec4      	ldr	r4, [r0, #108]	@ 0x6c
	s = buf[ 5];				d[0] = d[8] = s;	d += 64;
 801c984:	f8c3 7420 	str.w	r7, [r3, #1056]	@ 0x420
 801c988:	f8c3 7400 	str.w	r7, [r3, #1024]	@ 0x400
	tmp = buf[29] + buf[27];
 801c98c:	442c      	add	r4, r5
	s = buf[21] + tmp;			d[0] = d[8] = s;	d += 64;
 801c98e:	6d45      	ldr	r5, [r0, #84]	@ 0x54
 801c990:	4425      	add	r5, r4
 801c992:	f8c3 5520 	str.w	r5, [r3, #1312]	@ 0x520
 801c996:	f8c3 5500 	str.w	r5, [r3, #1280]	@ 0x500
	s = buf[13] + buf[11];		d[0] = d[8] = s;	d += 64;
 801c99a:	6ac7      	ldr	r7, [r0, #44]	@ 0x2c
 801c99c:	6b45      	ldr	r5, [r0, #52]	@ 0x34
 801c99e:	443d      	add	r5, r7
 801c9a0:	f8c3 5620 	str.w	r5, [r3, #1568]	@ 0x620
 801c9a4:	f8c3 5600 	str.w	r5, [r3, #1536]	@ 0x600
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 801c9a8:	6cc5      	ldr	r5, [r0, #76]	@ 0x4c
 801c9aa:	442c      	add	r4, r5
 801c9ac:	f8c3 4720 	str.w	r4, [r3, #1824]	@ 0x720
 801c9b0:	f8c3 4700 	str.w	r4, [r3, #1792]	@ 0x700
	tmp = buf[27] + buf[31];
 801c9b4:	6ec5      	ldr	r5, [r0, #108]	@ 0x6c
 801c9b6:	6fc4      	ldr	r4, [r0, #124]	@ 0x7c
 801c9b8:	442c      	add	r4, r5
	s = buf[ 3];				d[0] = d[8] = s;	d += 64;
 801c9ba:	68c5      	ldr	r5, [r0, #12]
 801c9bc:	f8c3 5820 	str.w	r5, [r3, #2080]	@ 0x820
 801c9c0:	f8c3 5800 	str.w	r5, [r3, #2048]	@ 0x800
	s = buf[19] + tmp;			d[0] = d[8] = s;	d += 64;
 801c9c4:	6cc5      	ldr	r5, [r0, #76]	@ 0x4c
 801c9c6:	4425      	add	r5, r4
 801c9c8:	f8c3 5920 	str.w	r5, [r3, #2336]	@ 0x920
 801c9cc:	f8c3 5900 	str.w	r5, [r3, #2304]	@ 0x900
	s = buf[11] + buf[15];		d[0] = d[8] = s;	d += 64;
 801c9d0:	6ac5      	ldr	r5, [r0, #44]	@ 0x2c
 801c9d2:	6bc7      	ldr	r7, [r0, #60]	@ 0x3c
 801c9d4:	443d      	add	r5, r7
 801c9d6:	f8c3 5a20 	str.w	r5, [r3, #2592]	@ 0xa20
 801c9da:	f8c3 5a00 	str.w	r5, [r3, #2560]	@ 0xa00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 801c9de:	6dc5      	ldr	r5, [r0, #92]	@ 0x5c
 801c9e0:	442c      	add	r4, r5
 801c9e2:	f8c3 4b20 	str.w	r4, [r3, #2848]	@ 0xb20
 801c9e6:	f8c3 4b00 	str.w	r4, [r3, #2816]	@ 0xb00
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 801c9ea:	69c4      	ldr	r4, [r0, #28]
	tmp = buf[31];
 801c9ec:	6fc5      	ldr	r5, [r0, #124]	@ 0x7c
	s = buf[ 7];				d[0] = d[8] = s;	d += 64;
 801c9ee:	f8c3 4c20 	str.w	r4, [r3, #3104]	@ 0xc20
 801c9f2:	f8c3 4c00 	str.w	r4, [r3, #3072]	@ 0xc00
	s = buf[23] + tmp;			d[0] = d[8] = s;	d += 64;
 801c9f6:	6dc4      	ldr	r4, [r0, #92]	@ 0x5c
 801c9f8:	442c      	add	r4, r5
 801c9fa:	f8c3 4d20 	str.w	r4, [r3, #3360]	@ 0xd20
 801c9fe:	f8c3 4d00 	str.w	r4, [r3, #3328]	@ 0xd00
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 801ca02:	6bc4      	ldr	r4, [r0, #60]	@ 0x3c
 801ca04:	f8c3 4e20 	str.w	r4, [r3, #3616]	@ 0xe20
	d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 801ca08:	eb08 0201 	add.w	r2, r8, r1
	s = tmp;					d[0] = d[8] = s;
 801ca0c:	f8c3 5f20 	str.w	r5, [r3, #3872]	@ 0xf20
 801ca10:	f8c3 5f00 	str.w	r5, [r3, #3840]	@ 0xf00
	s = buf[15];				d[0] = d[8] = s;	d += 64;
 801ca14:	f8c3 4e00 	str.w	r4, [r3, #3584]	@ 0xe00

	s = buf[ 1];				d[0] = d[8] = s;	d += 64;
 801ca18:	6844      	ldr	r4, [r0, #4]
 801ca1a:	6214      	str	r4, [r2, #32]
 801ca1c:	f848 4001 	str.w	r4, [r8, r1]

	tmp = buf[30] + buf[25];
 801ca20:	6e44      	ldr	r4, [r0, #100]	@ 0x64
 801ca22:	6f81      	ldr	r1, [r0, #120]	@ 0x78
 801ca24:	4421      	add	r1, r4
	s = buf[17] + tmp;			d[0] = d[8] = s;	d += 64;
 801ca26:	6c44      	ldr	r4, [r0, #68]	@ 0x44
 801ca28:	440c      	add	r4, r1
 801ca2a:	f8c2 4120 	str.w	r4, [r2, #288]	@ 0x120
 801ca2e:	f8c2 4100 	str.w	r4, [r2, #256]	@ 0x100
	s = buf[14] + buf[ 9];		d[0] = d[8] = s;	d += 64;
 801ca32:	6a45      	ldr	r5, [r0, #36]	@ 0x24
 801ca34:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 801ca36:	442c      	add	r4, r5
 801ca38:	f8c2 4220 	str.w	r4, [r2, #544]	@ 0x220
 801ca3c:	f8c2 4200 	str.w	r4, [r2, #512]	@ 0x200
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 801ca40:	6d84      	ldr	r4, [r0, #88]	@ 0x58
 801ca42:	4421      	add	r1, r4
 801ca44:	f8c2 1320 	str.w	r1, [r2, #800]	@ 0x320
 801ca48:	f8c2 1300 	str.w	r1, [r2, #768]	@ 0x300
	s = buf[ 6];				d[0] = d[8] = s;	d += 64;
 801ca4c:	6981      	ldr	r1, [r0, #24]
 801ca4e:	f8c2 1420 	str.w	r1, [r2, #1056]	@ 0x420
 801ca52:	f8c2 1400 	str.w	r1, [r2, #1024]	@ 0x400

	tmp = buf[26] + buf[30];
 801ca56:	6f84      	ldr	r4, [r0, #120]	@ 0x78
 801ca58:	6e81      	ldr	r1, [r0, #104]	@ 0x68
 801ca5a:	4421      	add	r1, r4
	s = buf[22] + tmp;			d[0] = d[8] = s;	d += 64;
 801ca5c:	6d84      	ldr	r4, [r0, #88]	@ 0x58
 801ca5e:	440c      	add	r4, r1
 801ca60:	f8c2 4520 	str.w	r4, [r2, #1312]	@ 0x520
 801ca64:	f8c2 4500 	str.w	r4, [r2, #1280]	@ 0x500
	s = buf[10] + buf[14];		d[0] = d[8] = s;	d += 64;
 801ca68:	6b85      	ldr	r5, [r0, #56]	@ 0x38
 801ca6a:	6a84      	ldr	r4, [r0, #40]	@ 0x28
 801ca6c:	442c      	add	r4, r5
 801ca6e:	f8c2 4620 	str.w	r4, [r2, #1568]	@ 0x620
 801ca72:	f8c2 4600 	str.w	r4, [r2, #1536]	@ 0x600
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 801ca76:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 801ca78:	4421      	add	r1, r4
 801ca7a:	f8c2 1720 	str.w	r1, [r2, #1824]	@ 0x720
 801ca7e:	f8c2 1700 	str.w	r1, [r2, #1792]	@ 0x700
	s = buf[ 2];				d[0] = d[8] = s;	d += 64;
 801ca82:	6881      	ldr	r1, [r0, #8]
 801ca84:	f8c2 1820 	str.w	r1, [r2, #2080]	@ 0x820
 801ca88:	f8c2 1800 	str.w	r1, [r2, #2048]	@ 0x800

	tmp = buf[28] + buf[26];
 801ca8c:	6e84      	ldr	r4, [r0, #104]	@ 0x68
 801ca8e:	6f01      	ldr	r1, [r0, #112]	@ 0x70
 801ca90:	4421      	add	r1, r4
	s = buf[18] + tmp;			d[0] = d[8] = s;	d += 64;
 801ca92:	6c84      	ldr	r4, [r0, #72]	@ 0x48
 801ca94:	440c      	add	r4, r1
 801ca96:	f8c2 4920 	str.w	r4, [r2, #2336]	@ 0x920
 801ca9a:	f8c2 4900 	str.w	r4, [r2, #2304]	@ 0x900
	s = buf[12] + buf[10];		d[0] = d[8] = s;	d += 64;
 801ca9e:	6a85      	ldr	r5, [r0, #40]	@ 0x28
 801caa0:	6b04      	ldr	r4, [r0, #48]	@ 0x30
 801caa2:	442c      	add	r4, r5
 801caa4:	f8c2 4a20 	str.w	r4, [r2, #2592]	@ 0xa20
 801caa8:	f8c2 4a00 	str.w	r4, [r2, #2560]	@ 0xa00
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 801caac:	6d04      	ldr	r4, [r0, #80]	@ 0x50
 801caae:	4421      	add	r1, r4
 801cab0:	f8c2 1b20 	str.w	r1, [r2, #2848]	@ 0xb20
 801cab4:	f8c2 1b00 	str.w	r1, [r2, #2816]	@ 0xb00
	s = buf[ 4];				d[0] = d[8] = s;	d += 64;
 801cab8:	6901      	ldr	r1, [r0, #16]
 801caba:	f8c2 1c20 	str.w	r1, [r2, #3104]	@ 0xc20
 801cabe:	f8c2 1c00 	str.w	r1, [r2, #3072]	@ 0xc00

	tmp = buf[24] + buf[28];
 801cac2:	6f04      	ldr	r4, [r0, #112]	@ 0x70
 801cac4:	6e01      	ldr	r1, [r0, #96]	@ 0x60
 801cac6:	4421      	add	r1, r4
	s = buf[20] + tmp;			d[0] = d[8] = s;	d += 64;
 801cac8:	6d04      	ldr	r4, [r0, #80]	@ 0x50
 801caca:	440c      	add	r4, r1
 801cacc:	f8c2 4d20 	str.w	r4, [r2, #3360]	@ 0xd20
 801cad0:	f8c2 4d00 	str.w	r4, [r2, #3328]	@ 0xd00
	s = buf[ 8] + buf[12];		d[0] = d[8] = s;	d += 64;
 801cad4:	6a04      	ldr	r4, [r0, #32]
 801cad6:	6b05      	ldr	r5, [r0, #48]	@ 0x30
 801cad8:	442c      	add	r4, r5
 801cada:	f8c2 4e20 	str.w	r4, [r2, #3616]	@ 0xe20
 801cade:	f8c2 4e00 	str.w	r4, [r2, #3584]	@ 0xe00
	s = buf[16] + tmp;			d[0] = d[8] = s;
 801cae2:	6c00      	ldr	r0, [r0, #64]	@ 0x40
 801cae4:	4401      	add	r1, r0
 801cae6:	f8c2 1f20 	str.w	r1, [r2, #3872]	@ 0xf20
 801caea:	f8c2 1f00 	str.w	r1, [r2, #3840]	@ 0xf00

	/* this is so rarely invoked that it's not worth making two versions of the output
	 *   shuffle code (one for no shift, one for clip + variable shift) like in IMDCT
	 * here we just load, clip, shift, and store on the rare instances that es != 0
	 */
	if (es) {
 801caee:	f1bb 0f00 	cmp.w	fp, #0
 801caf2:	d045      	beq.n	801cb80 <xmp3_FDCT32+0x614>
		d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);
 801caf4:	6831      	ldr	r1, [r6, #0]
 801caf6:	f1cb 041f 	rsb	r4, fp, #31
 801cafa:	f04f 4500 	mov.w	r5, #2147483648	@ 0x80000000
 801cafe:	fa41 f004 	asr.w	r0, r1, r4
 801cb02:	fa25 f50b 	lsr.w	r5, r5, fp
 801cb06:	ebb0 7fe1 	cmp.w	r0, r1, asr #31
 801cb0a:	ea4f 77e1 	mov.w	r7, r1, asr #31
 801cb0e:	f105 35ff 	add.w	r5, r5, #4294967295
 801cb12:	bf18      	it	ne
 801cb14:	ea85 0107 	eorne.w	r1, r5, r7
 801cb18:	fa01 f10b 	lsl.w	r1, r1, fp
 801cb1c:	f103 0020 	add.w	r0, r3, #32
 801cb20:	6231      	str	r1, [r6, #32]
 801cb22:	6031      	str	r1, [r6, #0]
	
		d = dest + offset + (oddBlock ? VBUF_LENGTH  : 0);
		for (i = 16; i <= 31; i++) {
 801cb24:	f503 5381 	add.w	r3, r3, #4128	@ 0x1020
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 801cb28:	f850 1c20 	ldr.w	r1, [r0, #-32]
 801cb2c:	fa41 f604 	asr.w	r6, r1, r4
 801cb30:	ebb6 7fe1 	cmp.w	r6, r1, asr #31
 801cb34:	ea4f 77e1 	mov.w	r7, r1, asr #31
 801cb38:	bf18      	it	ne
 801cb3a:	ea85 0107 	eorne.w	r1, r5, r7
 801cb3e:	fa01 f10b 	lsl.w	r1, r1, fp
 801cb42:	6001      	str	r1, [r0, #0]
 801cb44:	f840 1c20 	str.w	r1, [r0, #-32]
		for (i = 16; i <= 31; i++) {
 801cb48:	f500 7080 	add.w	r0, r0, #256	@ 0x100
 801cb4c:	4298      	cmp	r0, r3
 801cb4e:	d1eb      	bne.n	801cb28 <xmp3_FDCT32+0x5bc>
 801cb50:	f102 0120 	add.w	r1, r2, #32
 801cb54:	f502 5281 	add.w	r2, r2, #4128	@ 0x1020
		}

		d = dest + 16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
		for (i = 15; i >= 0; i--) {
			s = d[0];	CLIP_2N(s, 31 - es);	d[0] = d[8] = (s << es);	d += 64;
 801cb58:	f851 3c20 	ldr.w	r3, [r1, #-32]
 801cb5c:	fa43 f004 	asr.w	r0, r3, r4
 801cb60:	ebb0 7fe3 	cmp.w	r0, r3, asr #31
 801cb64:	ea4f 76e3 	mov.w	r6, r3, asr #31
 801cb68:	bf18      	it	ne
 801cb6a:	ea85 0306 	eorne.w	r3, r5, r6
 801cb6e:	fa03 f30b 	lsl.w	r3, r3, fp
 801cb72:	600b      	str	r3, [r1, #0]
 801cb74:	f841 3c20 	str.w	r3, [r1, #-32]
		for (i = 15; i >= 0; i--) {
 801cb78:	f501 7180 	add.w	r1, r1, #256	@ 0x100
 801cb7c:	4291      	cmp	r1, r2
 801cb7e:	d1eb      	bne.n	801cb58 <xmp3_FDCT32+0x5ec>
		}
	}
}
 801cb80:	b007      	add	sp, #28
 801cb82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 801cb86:	f501 5388 	add.w	r3, r1, #4352	@ 0x1100
 801cb8a:	eb08 0603 	add.w	r6, r8, r3
	s = buf[ 0];				d[0] = d[8] = s;
 801cb8e:	6804      	ldr	r4, [r0, #0]
 801cb90:	6234      	str	r4, [r6, #32]
 801cb92:	f848 4003 	str.w	r4, [r8, r3]
	d = dest + 64*16 + ((offset - oddBlock) & 7) + (oddBlock ? 0 : VBUF_LENGTH);
 801cb96:	f44f 5388 	mov.w	r3, #4352	@ 0x1100
 801cb9a:	e6d1      	b.n	801c940 <xmp3_FDCT32+0x3d4>
	es = 0;
 801cb9c:	f04f 0b00 	mov.w	fp, #0
 801cba0:	e4fa      	b.n	801c598 <xmp3_FDCT32+0x2c>
 801cba2:	bf00      	nop

0801cba4 <xmp3_Dequantize>:
 *                round to PCM (>> by 15 less than we otherwise would have).
 *              Equivalently, we can think of the dequantized coefficients as 
 *                Q(DQ_FRACBITS_OUT - 15) with no implicit bias. 
 **************************************************************************************/
int Dequantize(MP3DecInfo *mp3DecInfo, int gr)
{
 801cba4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801cba8:	b08f      	sub	sp, #60	@ 0x3c
 801cbaa:	9109      	str	r1, [sp, #36]	@ 0x24
	HuffmanInfo *hi;
	DequantInfo *di;
	CriticalBandInfo *cbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 801cbac:	2800      	cmp	r0, #0
 801cbae:	f000 8133 	beq.w	801ce18 <xmp3_Dequantize+0x274>
 801cbb2:	f8d0 8000 	ldr.w	r8, [r0]
 801cbb6:	4604      	mov	r4, r0
 801cbb8:	f1b8 0f00 	cmp.w	r8, #0
 801cbbc:	f000 812c 	beq.w	801ce18 <xmp3_Dequantize+0x274>
 801cbc0:	6843      	ldr	r3, [r0, #4]
 801cbc2:	930a      	str	r3, [sp, #40]	@ 0x28
 801cbc4:	2b00      	cmp	r3, #0
 801cbc6:	f000 8127 	beq.w	801ce18 <xmp3_Dequantize+0x274>
 801cbca:	6883      	ldr	r3, [r0, #8]
 801cbcc:	9308      	str	r3, [sp, #32]
 801cbce:	2b00      	cmp	r3, #0
 801cbd0:	f000 8122 	beq.w	801ce18 <xmp3_Dequantize+0x274>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 801cbd4:	68c0      	ldr	r0, [r0, #12]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || 
 801cbd6:	2800      	cmp	r0, #0
 801cbd8:	f000 811e 	beq.w	801ce18 <xmp3_Dequantize+0x274>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->DequantInfoPS)
 801cbdc:	6923      	ldr	r3, [r4, #16]
 801cbde:	2b00      	cmp	r3, #0
 801cbe0:	f000 811a 	beq.w	801ce18 <xmp3_Dequantize+0x274>
	di = (DequantInfo *)mp3DecInfo->DequantInfoPS;
	cbi = di->cbi;
	mOut[0] = mOut[1] = 0;

	/* dequantize all the samples in each channel */
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801cbe4:	f8d4 17bc 	ldr.w	r1, [r4, #1980]	@ 0x7bc
	mOut[0] = mOut[1] = 0;
 801cbe8:	2600      	movs	r6, #0
 801cbea:	2700      	movs	r7, #0
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801cbec:	2900      	cmp	r1, #0
	mOut[0] = mOut[1] = 0;
 801cbee:	e9cd 670c 	strd	r6, r7, [sp, #48]	@ 0x30
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801cbf2:	dd37      	ble.n	801cc64 <xmp3_Dequantize+0xc0>
 801cbf4:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801cbf6:	990a      	ldr	r1, [sp, #40]	@ 0x28
 801cbf8:	f8cd 801c 	str.w	r8, [sp, #28]
 801cbfc:	eb02 05c2 	add.w	r5, r2, r2, lsl #3
 801cc00:	ebc2 1742 	rsb	r7, r2, r2, lsl #5
 801cc04:	9a08      	ldr	r2, [sp, #32]
 801cc06:	900b      	str	r0, [sp, #44]	@ 0x2c
 801cc08:	f503 7a46 	add.w	sl, r3, #792	@ 0x318
 801cc0c:	eb01 1505 	add.w	r5, r1, r5, lsl #4
 801cc10:	f500 5690 	add.w	r6, r0, #4608	@ 0x1200
 801cc14:	4698      	mov	r8, r3
 801cc16:	4623      	mov	r3, r4
 801cc18:	3528      	adds	r5, #40	@ 0x28
 801cc1a:	4654      	mov	r4, sl
 801cc1c:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 801cc20:	3604      	adds	r6, #4
 801cc22:	4683      	mov	fp, r0
 801cc24:	f04f 0900 	mov.w	r9, #0
 801cc28:	469a      	mov	sl, r3
		hi->gb[ch] = DequantChannel(hi->huffDecBuf[ch], di->workBuf, &hi->nonZeroBound[ch], fh, 
 801cc2a:	e9cd 7401 	strd	r7, r4, [sp, #4]
 801cc2e:	9b07      	ldr	r3, [sp, #28]
 801cc30:	9500      	str	r5, [sp, #0]
 801cc32:	1f32      	subs	r2, r6, #4
 801cc34:	4658      	mov	r0, fp
 801cc36:	4641      	mov	r1, r8
 801cc38:	f000 f9e4 	bl	801d004 <xmp3_DequantChannel>
 801cc3c:	f846 0f04 	str.w	r0, [r6, #4]!
	for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801cc40:	f8da 37bc 	ldr.w	r3, [sl, #1980]	@ 0x7bc
 801cc44:	f109 0901 	add.w	r9, r9, #1
 801cc48:	454b      	cmp	r3, r9
 801cc4a:	f105 0548 	add.w	r5, r5, #72	@ 0x48
 801cc4e:	f107 073e 	add.w	r7, r7, #62	@ 0x3e
 801cc52:	f104 0418 	add.w	r4, r4, #24
 801cc56:	f50b 6b10 	add.w	fp, fp, #2304	@ 0x900
 801cc5a:	dce6      	bgt.n	801cc2a <xmp3_Dequantize+0x86>
 801cc5c:	4643      	mov	r3, r8
 801cc5e:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 801cc60:	f8dd 801c 	ldr.w	r8, [sp, #28]
	/* joint stereo processing assumes one guard bit in input samples
	 * it's extremely rare not to have at least one gb, so if this is the case
	 *   just make a pass over the data and clip to [-2^30+1, 2^30-1]
	 * in practice this may never happen
	 */
	if (fh->modeExt && (hi->gb[0] < 1 || hi->gb[1] < 1)) {
 801cc64:	f8d8 1020 	ldr.w	r1, [r8, #32]
 801cc68:	2900      	cmp	r1, #0
 801cc6a:	d073      	beq.n	801cd54 <xmp3_Dequantize+0x1b0>
 801cc6c:	f500 5580 	add.w	r5, r0, #4096	@ 0x1000
 801cc70:	f8d5 2208 	ldr.w	r2, [r5, #520]	@ 0x208
 801cc74:	2a00      	cmp	r2, #0
 801cc76:	dd71      	ble.n	801cd5c <xmp3_Dequantize+0x1b8>
 801cc78:	f8d5 220c 	ldr.w	r2, [r5, #524]	@ 0x20c
 801cc7c:	2a00      	cmp	r2, #0
 801cc7e:	dd6d      	ble.n	801cd5c <xmp3_Dequantize+0x1b8>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
		}
	}

	/* do mid-side stereo processing, if enabled */
	if (fh->modeExt >> 1) {
 801cc80:	104a      	asrs	r2, r1, #1
		if (fh->modeExt & 0x01) {
 801cc82:	f001 0601 	and.w	r6, r1, #1
	if (fh->modeExt >> 1) {
 801cc86:	f000 80bf 	beq.w	801ce08 <xmp3_Dequantize+0x264>
		if (fh->modeExt & 0x01) {
 801cc8a:	b166      	cbz	r6, 801cca6 <xmp3_Dequantize+0x102>
			/* intensity stereo enabled - run mid-side up to start of right zero region */
			if (cbi[1].cbType == 0)
 801cc8c:	f8d3 1330 	ldr.w	r1, [r3, #816]	@ 0x330
				nSamps = fh->sfBand->l[cbi[1].cbEndL + 1];
 801cc90:	f8d8 2034 	ldr.w	r2, [r8, #52]	@ 0x34
			if (cbi[1].cbType == 0)
 801cc94:	2900      	cmp	r1, #0
 801cc96:	f040 80aa 	bne.w	801cdee <xmp3_Dequantize+0x24a>
				nSamps = fh->sfBand->l[cbi[1].cbEndL + 1];
 801cc9a:	f8d3 1344 	ldr.w	r1, [r3, #836]	@ 0x344
 801cc9e:	3101      	adds	r1, #1
 801cca0:	f932 1011 	ldrsh.w	r1, [r2, r1, lsl #1]
 801cca4:	e004      	b.n	801ccb0 <xmp3_Dequantize+0x10c>
			else 
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
		} else {
			/* intensity stereo disabled - run mid-side on whole spectrum */
			nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 801cca6:	e9d5 2180 	ldrd	r2, r1, [r5, #512]	@ 0x200
 801ccaa:	4291      	cmp	r1, r2
 801ccac:	bfb8      	it	lt
 801ccae:	4611      	movlt	r1, r2
		}
		MidSideProc(hi->huffDecBuf, nSamps, mOut);
 801ccb0:	ae0c      	add	r6, sp, #48	@ 0x30
 801ccb2:	4632      	mov	r2, r6
 801ccb4:	9007      	str	r0, [sp, #28]
 801ccb6:	930b      	str	r3, [sp, #44]	@ 0x2c
 801ccb8:	f003 f92e 	bl	801ff18 <xmp3_MidSideProc>
	}

	/* do intensity stereo processing, if enabled */
	if (fh->modeExt & 0x01) {
 801ccbc:	f8d8 2020 	ldr.w	r2, [r8, #32]
 801ccc0:	9807      	ldr	r0, [sp, #28]
 801ccc2:	f012 0f01 	tst.w	r2, #1
 801ccc6:	d023      	beq.n	801cd10 <xmp3_Dequantize+0x16c>
		nSamps = hi->nonZeroBound[0];
		if (fh->ver == MPEG1) {
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 801ccc8:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801ccca:	1052      	asrs	r2, r2, #1
	cbi = di->cbi;
 801cccc:	f503 7746 	add.w	r7, r3, #792	@ 0x318
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 801ccd0:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801ccd2:	9c0a      	ldr	r4, [sp, #40]	@ 0x28
 801ccd4:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
 801ccd8:	eb04 1101 	add.w	r1, r4, r1, lsl #4
 801ccdc:	ebc3 1443 	rsb	r4, r3, r3, lsl #5
 801cce0:	9b08      	ldr	r3, [sp, #32]
 801cce2:	f8d1 c088 	ldr.w	ip, [r1, #136]	@ 0x88
		nSamps = hi->nonZeroBound[0];
 801cce6:	f8d5 1200 	ldr.w	r1, [r5, #512]	@ 0x200
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 801ccea:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 801ccee:	f104 033e 	add.w	r3, r4, #62	@ 0x3e
		if (fh->ver == MPEG1) {
 801ccf2:	f898 4000 	ldrb.w	r4, [r8]
 801ccf6:	2c00      	cmp	r4, #0
 801ccf8:	d16a      	bne.n	801cdd0 <xmp3_Dequantize+0x22c>
			IntensityProcMPEG1(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, 
 801ccfa:	e9cd 7200 	strd	r7, r2, [sp]
 801ccfe:	e9cd c602 	strd	ip, r6, [sp, #8]
 801cd02:	4642      	mov	r2, r8
 801cd04:	9007      	str	r0, [sp, #28]
 801cd06:	f003 f93d 	bl	801ff84 <xmp3_IntensityProcMPEG1>
				fh->modeExt >> 1, si->sis[gr][1].mixedBlock, mOut);
		}
	}

	/* adjust guard bit count and nonZeroBound if we did any stereo processing */
	if (fh->modeExt) {
 801cd0a:	f8d8 2020 	ldr.w	r2, [r8, #32]
 801cd0e:	9807      	ldr	r0, [sp, #28]
 801cd10:	b302      	cbz	r2, 801cd54 <xmp3_Dequantize+0x1b0>
		hi->gb[0] = CLZ(mOut[0]) - 1;
 801cd12:	9b0c      	ldr	r3, [sp, #48]	@ 0x30

static __inline int CLZ(int x)
{
	int numZeros;

	if (!x)
 801cd14:	2b00      	cmp	r3, #0
 801cd16:	d075      	beq.n	801ce04 <xmp3_Dequantize+0x260>
		return (sizeof(int) * 8);

	numZeros = 0;
	while (!(x & 0x80000000)) {
 801cd18:	db7b      	blt.n	801ce12 <xmp3_Dequantize+0x26e>
	numZeros = 0;
 801cd1a:	2200      	movs	r2, #0
	while (!(x & 0x80000000)) {
 801cd1c:	005b      	lsls	r3, r3, #1
 801cd1e:	4611      	mov	r1, r2
		numZeros++;
 801cd20:	f102 0201 	add.w	r2, r2, #1
	while (!(x & 0x80000000)) {
 801cd24:	d5fa      	bpl.n	801cd1c <xmp3_Dequantize+0x178>
		hi->gb[1] = CLZ(mOut[1]) - 1;
 801cd26:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
		hi->gb[0] = CLZ(mOut[0]) - 1;
 801cd28:	f8c5 1208 	str.w	r1, [r5, #520]	@ 0x208
	if (!x)
 801cd2c:	2b00      	cmp	r3, #0
 801cd2e:	d067      	beq.n	801ce00 <xmp3_Dequantize+0x25c>
	while (!(x & 0x80000000)) {
 801cd30:	db6c      	blt.n	801ce0c <xmp3_Dequantize+0x268>
	numZeros = 0;
 801cd32:	2200      	movs	r2, #0
	while (!(x & 0x80000000)) {
 801cd34:	005b      	lsls	r3, r3, #1
 801cd36:	4611      	mov	r1, r2
		numZeros++;
 801cd38:	f102 0201 	add.w	r2, r2, #1
	while (!(x & 0x80000000)) {
 801cd3c:	d5fa      	bpl.n	801cd34 <xmp3_Dequantize+0x190>
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 801cd3e:	e9d5 2380 	ldrd	r2, r3, [r5, #512]	@ 0x200
 801cd42:	4293      	cmp	r3, r2
		hi->nonZeroBound[0] = nSamps;
 801cd44:	f500 5090 	add.w	r0, r0, #4608	@ 0x1200
		nSamps = MAX(hi->nonZeroBound[0], hi->nonZeroBound[1]);
 801cd48:	bfb8      	it	lt
 801cd4a:	4613      	movlt	r3, r2
		hi->gb[1] = CLZ(mOut[1]) - 1;
 801cd4c:	f8c5 120c 	str.w	r1, [r5, #524]	@ 0x20c
		hi->nonZeroBound[0] = nSamps;
 801cd50:	e9c0 3300 	strd	r3, r3, [r0]
		hi->nonZeroBound[1] = nSamps;
	}

	/* output format Q(DQ_FRACBITS_OUT) */
	return 0;
 801cd54:	2000      	movs	r0, #0
}
 801cd56:	b00f      	add	sp, #60	@ 0x3c
 801cd58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 801cd5c:	f8d5 7200 	ldr.w	r7, [r5, #512]	@ 0x200
 801cd60:	2f00      	cmp	r7, #0
 801cd62:	dd17      	ble.n	801cd94 <xmp3_Dequantize+0x1f0>
 801cd64:	1f02      	subs	r2, r0, #4
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 801cd66:	f8df e0b8 	ldr.w	lr, [pc, #184]	@ 801ce20 <xmp3_Dequantize+0x27c>
 801cd6a:	eb02 0787 	add.w	r7, r2, r7, lsl #2
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 801cd6e:	f06f 4c40 	mvn.w	ip, #3221225472	@ 0xc0000000
 801cd72:	e003      	b.n	801cd7c <xmp3_Dequantize+0x1d8>
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 801cd74:	4297      	cmp	r7, r2
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 801cd76:	f8c2 e000 	str.w	lr, [r2]
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 801cd7a:	d00b      	beq.n	801cd94 <xmp3_Dequantize+0x1f0>
			if (hi->huffDecBuf[0][i] < -0x3fffffff)	 hi->huffDecBuf[0][i] = -0x3fffffff;
 801cd7c:	f852 4f04 	ldr.w	r4, [r2, #4]!
 801cd80:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
 801cd84:	ddf6      	ble.n	801cd74 <xmp3_Dequantize+0x1d0>
			if (hi->huffDecBuf[0][i] >  0x3fffffff)	 hi->huffDecBuf[0][i] =  0x3fffffff;
 801cd86:	f1b4 4f80 	cmp.w	r4, #1073741824	@ 0x40000000
 801cd8a:	bfa8      	it	ge
 801cd8c:	f8c2 c000 	strge.w	ip, [r2]
		for (i = 0; i < hi->nonZeroBound[0]; i++) {
 801cd90:	4297      	cmp	r7, r2
 801cd92:	d1f3      	bne.n	801cd7c <xmp3_Dequantize+0x1d8>
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 801cd94:	f8d5 7204 	ldr.w	r7, [r5, #516]	@ 0x204
 801cd98:	2f00      	cmp	r7, #0
 801cd9a:	f77f af71 	ble.w	801cc80 <xmp3_Dequantize+0xdc>
 801cd9e:	f600 02fc 	addw	r2, r0, #2300	@ 0x8fc
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 801cda2:	f8df e07c 	ldr.w	lr, [pc, #124]	@ 801ce20 <xmp3_Dequantize+0x27c>
 801cda6:	eb02 0787 	add.w	r7, r2, r7, lsl #2
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 801cdaa:	f06f 4c40 	mvn.w	ip, #3221225472	@ 0xc0000000
 801cdae:	e004      	b.n	801cdba <xmp3_Dequantize+0x216>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 801cdb0:	f8c2 e000 	str.w	lr, [r2]
		for (i = 0; i < hi->nonZeroBound[1]; i++) {
 801cdb4:	42ba      	cmp	r2, r7
 801cdb6:	f43f af63 	beq.w	801cc80 <xmp3_Dequantize+0xdc>
			if (hi->huffDecBuf[1][i] < -0x3fffffff)	 hi->huffDecBuf[1][i] = -0x3fffffff;
 801cdba:	f852 4f04 	ldr.w	r4, [r2, #4]!
 801cdbe:	f1b4 4f40 	cmp.w	r4, #3221225472	@ 0xc0000000
 801cdc2:	ddf5      	ble.n	801cdb0 <xmp3_Dequantize+0x20c>
			if (hi->huffDecBuf[1][i] >  0x3fffffff)	 hi->huffDecBuf[1][i] =  0x3fffffff;
 801cdc4:	f1b4 4f80 	cmp.w	r4, #1073741824	@ 0x40000000
 801cdc8:	bfa8      	it	ge
 801cdca:	f8c2 c000 	strge.w	ip, [r2]
 801cdce:	e7f1      	b.n	801cdb4 <xmp3_Dequantize+0x210>
			IntensityProcMPEG2(hi->huffDecBuf, nSamps, fh, &sfi->sfis[gr][1], di->cbi, &sfi->sfjs,
 801cdd0:	9202      	str	r2, [sp, #8]
 801cdd2:	9a08      	ldr	r2, [sp, #32]
 801cdd4:	9700      	str	r7, [sp, #0]
 801cdd6:	32f8      	adds	r2, #248	@ 0xf8
 801cdd8:	9201      	str	r2, [sp, #4]
 801cdda:	e9cd c603 	strd	ip, r6, [sp, #12]
 801cdde:	4642      	mov	r2, r8
 801cde0:	9007      	str	r0, [sp, #28]
 801cde2:	f003 fa55 	bl	8020290 <xmp3_IntensityProcMPEG2>
	if (fh->modeExt) {
 801cde6:	f8d8 2020 	ldr.w	r2, [r8, #32]
 801cdea:	9807      	ldr	r0, [sp, #28]
 801cdec:	e790      	b.n	801cd10 <xmp3_Dequantize+0x16c>
				nSamps = 3 * fh->sfBand->s[cbi[1].cbEndSMax + 1];
 801cdee:	f8d3 1340 	ldr.w	r1, [r3, #832]	@ 0x340
 801cdf2:	eb02 0241 	add.w	r2, r2, r1, lsl #1
 801cdf6:	f9b2 1030 	ldrsh.w	r1, [r2, #48]	@ 0x30
 801cdfa:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 801cdfe:	e757      	b.n	801ccb0 <xmp3_Dequantize+0x10c>
 801ce00:	211f      	movs	r1, #31
 801ce02:	e79c      	b.n	801cd3e <xmp3_Dequantize+0x19a>
 801ce04:	211f      	movs	r1, #31
 801ce06:	e78e      	b.n	801cd26 <xmp3_Dequantize+0x182>
	if (fh->modeExt & 0x01) {
 801ce08:	ae0c      	add	r6, sp, #48	@ 0x30
 801ce0a:	e75f      	b.n	801cccc <xmp3_Dequantize+0x128>
 801ce0c:	f04f 31ff 	mov.w	r1, #4294967295
 801ce10:	e795      	b.n	801cd3e <xmp3_Dequantize+0x19a>
 801ce12:	f04f 31ff 	mov.w	r1, #4294967295
 801ce16:	e786      	b.n	801cd26 <xmp3_Dequantize+0x182>
		return -1;
 801ce18:	f04f 30ff 	mov.w	r0, #4294967295
 801ce1c:	e79b      	b.n	801cd56 <xmp3_Dequantize+0x1b2>
 801ce1e:	bf00      	nop
 801ce20:	c0000001 	.word	0xc0000001

0801ce24 <DequantBlock>:
 * Outputs:     dequantized samples in Q25 format
 *
 * Return:      bitwise-OR of the unsigned outputs (for guard bit calculations)
 **************************************************************************************/
/*__attribute__ ((section (".data")))*/ static int DequantBlock(int *inbuf, int *outbuf, int num, int scale)
{
 801ce24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int mask = 0;
	const int *tab16, *coef;

	tab16 = pow43_14[scale & 0x3];
	scalef = pow14[scale & 0x3];
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 801ce28:	ea4f 08a3 	mov.w	r8, r3, asr #2
	tab16 = pow43_14[scale & 0x3];
 801ce2c:	f003 0403 	and.w	r4, r3, #3
 801ce30:	4b64      	ldr	r3, [pc, #400]	@ (801cfc4 <DequantBlock+0x1a0>)
 801ce32:	eb03 1984 	add.w	r9, r3, r4, lsl #6

	/* cache first 4 values */
	shift = MIN(scalei + 3, 31);
 801ce36:	4643      	mov	r3, r8
 801ce38:	2b1c      	cmp	r3, #28
{
 801ce3a:	4686      	mov	lr, r0
	scalef = pow14[scale & 0x3];
 801ce3c:	4862      	ldr	r0, [pc, #392]	@ (801cfc8 <DequantBlock+0x1a4>)
	shift = MIN(scalei + 3, 31);
 801ce3e:	bfa8      	it	ge
 801ce40:	231c      	movge	r3, #28
	scalef = pow14[scale & 0x3];
 801ce42:	f850 a024 	ldr.w	sl, [r0, r4, lsl #2]
	shift = MAX(shift, 0);
	tab4[0] = 0;
	tab4[1] = tab16[1] >> shift;
 801ce46:	f8d9 0004 	ldr.w	r0, [r9, #4]
	shift = MIN(scalei + 3, 31);
 801ce4a:	3303      	adds	r3, #3
{
 801ce4c:	b089      	sub	sp, #36	@ 0x24
	shift = MAX(shift, 0);
 801ce4e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
	tab4[1] = tab16[1] >> shift;
 801ce52:	4118      	asrs	r0, r3
 801ce54:	9005      	str	r0, [sp, #20]
	tab4[2] = tab16[2] >> shift;
 801ce56:	f8d9 0008 	ldr.w	r0, [r9, #8]
 801ce5a:	4118      	asrs	r0, r3
 801ce5c:	9006      	str	r0, [sp, #24]
	tab4[3] = tab16[3] >> shift;
 801ce5e:	f8d9 000c 	ldr.w	r0, [r9, #12]
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 801ce62:	f1b8 0f1f 	cmp.w	r8, #31
 801ce66:	46c3      	mov	fp, r8
	tab4[3] = tab16[3] >> shift;
 801ce68:	fa40 f003 	asr.w	r0, r0, r3
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 801ce6c:	bfa8      	it	ge
 801ce6e:	f04f 0b1f 	movge.w	fp, #31
 801ce72:	465b      	mov	r3, fp
	tab4[3] = tab16[3] >> shift;
 801ce74:	9007      	str	r0, [sp, #28]
	tab4[0] = 0;
 801ce76:	2000      	movs	r0, #0
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 801ce78:	46c3      	mov	fp, r8
	tab4[0] = 0;
 801ce7a:	9004      	str	r0, [sp, #16]
	scalei = MIN(scale >> 2, 31);	/* smallest input scale = -47, so smallest scalei = -12 */
 801ce7c:	46c8      	mov	r8, r9
 801ce7e:	46d1      	mov	r9, sl
 801ce80:	469a      	mov	sl, r3
 801ce82:	e00e      	b.n	801cea2 <DequantBlock+0x7e>
		sx = *inbuf++;
		x = sx & 0x7fffffff;	/* sx = sign|mag */

		if (x < 4) {

			y = tab4[x];
 801ce84:	ac08      	add	r4, sp, #32
 801ce86:	eb04 0585 	add.w	r5, r4, r5, lsl #2
 801ce8a:	f855 4c10 	ldr.w	r4, [r5, #-16]
			}
		}

		/* sign and store */
		mask |= y;
		*outbuf++ = (sx < 0) ? -y : y;
 801ce8e:	2b00      	cmp	r3, #0
		mask |= y;
 801ce90:	ea40 0004 	orr.w	r0, r0, r4
		*outbuf++ = (sx < 0) ? -y : y;
 801ce94:	bfb8      	it	lt
 801ce96:	4264      	neglt	r4, r4

	} while (--num);
 801ce98:	3a01      	subs	r2, #1
		*outbuf++ = (sx < 0) ? -y : y;
 801ce9a:	f841 4b04 	str.w	r4, [r1], #4
	} while (--num);
 801ce9e:	f000 808e 	beq.w	801cfbe <DequantBlock+0x19a>
		sx = *inbuf++;
 801cea2:	f85e 3b04 	ldr.w	r3, [lr], #4
		if (x < 4) {
 801cea6:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
 801ceaa:	f024 0403 	bic.w	r4, r4, #3
		x = sx & 0x7fffffff;	/* sx = sign|mag */
 801ceae:	f023 4500 	bic.w	r5, r3, #2147483648	@ 0x80000000
		if (x < 4) {
 801ceb2:	2c00      	cmp	r4, #0
 801ceb4:	d0e6      	beq.n	801ce84 <DequantBlock+0x60>
		} else if (x < 16) {
 801ceb6:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
 801ceba:	f024 040f 	bic.w	r4, r4, #15
 801cebe:	b954      	cbnz	r4, 801ced6 <DequantBlock+0xb2>
			y = tab16[x];
 801cec0:	f858 4025 	ldr.w	r4, [r8, r5, lsl #2]
			y = (scalei < 0) ? y << -scalei : y >> scalei;
 801cec4:	f1bb 0f00 	cmp.w	fp, #0
 801cec8:	bfba      	itte	lt
 801ceca:	f1ca 0500 	rsblt	r5, sl, #0
 801cece:	40ac      	lsllt	r4, r5
 801ced0:	fa44 f40a 	asrge.w	r4, r4, sl
 801ced4:	e7db      	b.n	801ce8e <DequantBlock+0x6a>
			if (x < 64) {
 801ced6:	f023 4400 	bic.w	r4, r3, #2147483648	@ 0x80000000
 801ceda:	f024 043f 	bic.w	r4, r4, #63	@ 0x3f
 801cede:	b974      	cbnz	r4, 801cefe <DequantBlock+0xda>
				y = pow43[x-16];
 801cee0:	4c3a      	ldr	r4, [pc, #232]	@ (801cfcc <DequantBlock+0x1a8>)
 801cee2:	3d10      	subs	r5, #16
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801cee4:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
 801cee8:	464c      	mov	r4, r9
 801ceea:	fb85 6404 	smull	r6, r4, r5, r4
 801ceee:	4625      	mov	r5, r4
				shift = scalei - 3;
 801cef0:	f1aa 0403 	sub.w	r4, sl, #3
			if (shift < 0) {
 801cef4:	2c00      	cmp	r4, #0
 801cef6:	db57      	blt.n	801cfa8 <DequantBlock+0x184>
				y >>= shift;
 801cef8:	fa45 f404 	asr.w	r4, r5, r4
 801cefc:	e7c7      	b.n	801ce8e <DequantBlock+0x6a>
				x <<= 17;
 801cefe:	046c      	lsls	r4, r5, #17
				if (x < 0x08000000)
 801cf00:	f1b4 6f00 	cmp.w	r4, #134217728	@ 0x8000000
					x <<= 4, shift += 4;
 801cf04:	bfb6      	itet	lt
 801cf06:	056c      	lsllt	r4, r5, #21
				shift = 0;
 801cf08:	2500      	movge	r5, #0
					x <<= 4, shift += 4;
 801cf0a:	2504      	movlt	r5, #4
				if (x < 0x20000000)
 801cf0c:	f1b4 5f00 	cmp.w	r4, #536870912	@ 0x20000000
				shift = 0;
 801cf10:	9500      	str	r5, [sp, #0]
				if (x < 0x20000000)
 801cf12:	da03      	bge.n	801cf1c <DequantBlock+0xf8>
					x <<= 2, shift += 2;
 801cf14:	9d00      	ldr	r5, [sp, #0]
 801cf16:	3502      	adds	r5, #2
 801cf18:	00a4      	lsls	r4, r4, #2
 801cf1a:	9500      	str	r5, [sp, #0]
				if (x < 0x40000000)
 801cf1c:	f1b4 4f80 	cmp.w	r4, #1073741824	@ 0x40000000
 801cf20:	da03      	bge.n	801cf2a <DequantBlock+0x106>
					x <<= 1, shift += 1;
 801cf22:	9d00      	ldr	r5, [sp, #0]
 801cf24:	3501      	adds	r5, #1
 801cf26:	0064      	lsls	r4, r4, #1
 801cf28:	9500      	str	r5, [sp, #0]
				coef = (x < SQRTHALF) ? poly43lo : poly43hi;
 801cf2a:	4d29      	ldr	r5, [pc, #164]	@ (801cfd0 <DequantBlock+0x1ac>)
 801cf2c:	4e29      	ldr	r6, [pc, #164]	@ (801cfd4 <DequantBlock+0x1b0>)
 801cf2e:	4f2a      	ldr	r7, [pc, #168]	@ (801cfd8 <DequantBlock+0x1b4>)
 801cf30:	42ac      	cmp	r4, r5
 801cf32:	4d2a      	ldr	r5, [pc, #168]	@ (801cfdc <DequantBlock+0x1b8>)
 801cf34:	bfc8      	it	gt
 801cf36:	46ac      	movgt	ip, r5
 801cf38:	4d29      	ldr	r5, [pc, #164]	@ (801cfe0 <DequantBlock+0x1bc>)
 801cf3a:	bfd8      	it	le
 801cf3c:	46b4      	movle	ip, r6
 801cf3e:	4e29      	ldr	r6, [pc, #164]	@ (801cfe4 <DequantBlock+0x1c0>)
 801cf40:	bfd8      	it	le
 801cf42:	462e      	movle	r6, r5
 801cf44:	4d28      	ldr	r5, [pc, #160]	@ (801cfe8 <DequantBlock+0x1c4>)
 801cf46:	bfd8      	it	le
 801cf48:	462f      	movle	r7, r5
 801cf4a:	4d28      	ldr	r5, [pc, #160]	@ (801cfec <DequantBlock+0x1c8>)
 801cf4c:	9702      	str	r7, [sp, #8]
 801cf4e:	4f28      	ldr	r7, [pc, #160]	@ (801cff0 <DequantBlock+0x1cc>)
 801cf50:	bfd8      	it	le
 801cf52:	462f      	movle	r7, r5
 801cf54:	4d27      	ldr	r5, [pc, #156]	@ (801cff4 <DequantBlock+0x1d0>)
 801cf56:	9701      	str	r7, [sp, #4]
 801cf58:	4f27      	ldr	r7, [pc, #156]	@ (801cff8 <DequantBlock+0x1d4>)
 801cf5a:	bfd8      	it	le
 801cf5c:	462f      	movle	r7, r5
 801cf5e:	9703      	str	r7, [sp, #12]
 801cf60:	4625      	mov	r5, r4
 801cf62:	fb86 7505 	smull	r7, r5, r6, r5
				y = MULSHIFT32(y, x) + coef[1];
 801cf66:	4465      	add	r5, ip
 801cf68:	4626      	mov	r6, r4
 801cf6a:	fb85 c606 	smull	ip, r6, r5, r6
				y = MULSHIFT32(y, x) + coef[2];
 801cf6e:	9f03      	ldr	r7, [sp, #12]
 801cf70:	4625      	mov	r5, r4
 801cf72:	443e      	add	r6, r7
 801cf74:	fb86 c505 	smull	ip, r5, r6, r5
				y = MULSHIFT32(y, x) + coef[3];
 801cf78:	9f01      	ldr	r7, [sp, #4]
 801cf7a:	443d      	add	r5, r7
 801cf7c:	fb85 6404 	smull	r6, r4, r5, r4
				y = MULSHIFT32(y, x) + coef[4];
 801cf80:	9f02      	ldr	r7, [sp, #8]
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 801cf82:	4d1e      	ldr	r5, [pc, #120]	@ (801cffc <DequantBlock+0x1d8>)
				y = MULSHIFT32(y, x) + coef[4];
 801cf84:	443c      	add	r4, r7
 801cf86:	9f00      	ldr	r7, [sp, #0]
 801cf88:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
 801cf8c:	fb84 6505 	smull	r6, r5, r4, r5
				y = MULSHIFT32(y, pow2frac[shift]) << 3;
 801cf90:	00ed      	lsls	r5, r5, #3
 801cf92:	464c      	mov	r4, r9
 801cf94:	fb85 6404 	smull	r6, r4, r5, r4
 801cf98:	4625      	mov	r5, r4
				shift = scalei - pow2exp[shift];
 801cf9a:	4c19      	ldr	r4, [pc, #100]	@ (801d000 <DequantBlock+0x1dc>)
 801cf9c:	f854 4027 	ldr.w	r4, [r4, r7, lsl #2]
 801cfa0:	ebaa 0404 	sub.w	r4, sl, r4
			if (shift < 0) {
 801cfa4:	2c00      	cmp	r4, #0
 801cfa6:	daa7      	bge.n	801cef8 <DequantBlock+0xd4>
				shift = -shift;
 801cfa8:	4266      	negs	r6, r4
				if (y > (0x7fffffff >> shift))
 801cfaa:	f06f 4400 	mvn.w	r4, #2147483648	@ 0x80000000
 801cfae:	fa44 f706 	asr.w	r7, r4, r6
 801cfb2:	42af      	cmp	r7, r5
 801cfb4:	f6ff af6b 	blt.w	801ce8e <DequantBlock+0x6a>
					y <<= shift;
 801cfb8:	fa05 f406 	lsl.w	r4, r5, r6
 801cfbc:	e767      	b.n	801ce8e <DequantBlock+0x6a>

	return mask;
}
 801cfbe:	b009      	add	sp, #36	@ 0x24
 801cfc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801cfc4:	080356dc 	.word	0x080356dc
 801cfc8:	080357dc 	.word	0x080357dc
 801cfcc:	0803561c 	.word	0x0803561c
 801cfd0:	5a827999 	.word	0x5a827999
 801cfd4:	b02e4828 	.word	0xb02e4828
 801cfd8:	fef577b4 	.word	0xfef577b4
 801cfdc:	d333f6a4 	.word	0xd333f6a4
 801cfe0:	29a0bda9 	.word	0x29a0bda9
 801cfe4:	10852163 	.word	0x10852163
 801cfe8:	ff581859 	.word	0xff581859
 801cfec:	236c498d 	.word	0x236c498d
 801cff0:	27c2cef0 	.word	0x27c2cef0
 801cff4:	5957aa1b 	.word	0x5957aa1b
 801cff8:	46e9408b 	.word	0x46e9408b
 801cffc:	080355dc 	.word	0x080355dc
 801d000:	080355fc 	.word	0x080355fc

0801d004 <xmp3_DequantChannel>:
 *
 * Notes:       dequantized samples in Q(DQ_FRACBITS_OUT) format 
 **************************************************************************************/
/*__attribute__ ((section (".data")))*/ int DequantChannel(int *sampleBuf, int *workBuf, int *nonZeroBound, FrameHeader *fh, SideInfoSub *sis, 
					ScaleFactorInfoSub *sfis, CriticalBandInfo *cbi)
{
 801d004:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d008:	b091      	sub	sp, #68	@ 0x44
 801d00a:	f8dd b068 	ldr.w	fp, [sp, #104]	@ 0x68
 801d00e:	930a      	str	r3, [sp, #40]	@ 0x28
	int globalGain, gainI;
	int cbMax[3];
	ARRAY3 *buf;    /* short block reorder */
	
	/* set default start/end points for short/long blocks - will update with non-zero cb info */
	if (sis->blockType == 2) {
 801d010:	f8db 3014 	ldr.w	r3, [fp, #20]
{
 801d014:	f8dd 9070 	ldr.w	r9, [sp, #112]	@ 0x70
 801d018:	9004      	str	r0, [sp, #16]
	if (sis->blockType == 2) {
 801d01a:	2b02      	cmp	r3, #2
{
 801d01c:	9109      	str	r1, [sp, #36]	@ 0x24
 801d01e:	9203      	str	r2, [sp, #12]
	if (sis->blockType == 2) {
 801d020:	f000 8129 	beq.w	801d276 <xmp3_DequantChannel+0x272>
		}
		cbEndS = 13;
	} else {
		/* long block */
		cbEndL =   22;
		cbStartS = 13;
 801d024:	f04f 0e0d 	mov.w	lr, #13
		cbEndL =   22;
 801d028:	f04f 0a16 	mov.w	sl, #22

	/* sfactScale = 0 --> quantizer step size = 2
	 * sfactScale = 1 --> quantizer step size = sqrt(2)
	 *   so sfactMultiplier = 2 or 4 (jump through globalGain by powers of 2 or sqrt(2))
	 */
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 801d02c:	f8db 3040 	ldr.w	r3, [fp, #64]	@ 0x40

	/* offset globalGain by -2 if midSide enabled, for 1/sqrt(2) used in MidSideProc()
	 *  (DequantBlock() does 0.25 * gainI so knocking it down by two is the same as 
	 *   dividing every sample by sqrt(2) = multiplying by 2^-.5)
	 */
	globalGain = sis->globalGain;
 801d030:	f8db 1008 	ldr.w	r1, [fp, #8]
 801d034:	4e9c      	ldr	r6, [pc, #624]	@ (801d2a8 <xmp3_DequantChannel+0x2a4>)
 801d036:	f8cd 9070 	str.w	r9, [sp, #112]	@ 0x70
	sfactMultiplier = 2 * (sis->sfactScale + 1);
 801d03a:	3301      	adds	r3, #1
 801d03c:	005b      	lsls	r3, r3, #1
 801d03e:	9300      	str	r3, [sp, #0]
	if (fh->modeExt >> 1)
 801d040:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801d042:	6a1b      	ldr	r3, [r3, #32]
 801d044:	085b      	lsrs	r3, r3, #1
 801d046:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
		 globalGain -= 2;
	globalGain += IMDCT_SCALE;		/* scale everything by sqrt(2), for fast IMDCT36 */
 801d048:	bf08      	it	eq
 801d04a:	3102      	addeq	r1, #2
	gbMask = 0;
 801d04c:	2500      	movs	r5, #0
	cbMax[2] = cbMax[1] = cbMax[0] = 0;
 801d04e:	2200      	movs	r2, #0
 801d050:	f103 38ff 	add.w	r8, r3, #4294967295
	/* long blocks */
	for (cb = 0; cb < cbEndL; cb++) {

		nonZero = 0;
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 801d054:	f1c1 03d2 	rsb	r3, r1, #210	@ 0xd2
 801d058:	e9cd a305 	strd	sl, r3, [sp, #20]
 801d05c:	e9cd e107 	strd	lr, r1, [sp, #28]
 801d060:	e9cd 6501 	strd	r6, r5, [sp, #4]
 801d064:	f8dd a028 	ldr.w	sl, [sp, #40]	@ 0x28
	cbMax[2] = cbMax[1] = cbMax[0] = 0;
 801d068:	920c      	str	r2, [sp, #48]	@ 0x30
	for (cb = 0; cb < cbEndL; cb++) {
 801d06a:	462c      	mov	r4, r5
	i = 0;
 801d06c:	462f      	mov	r7, r5
	for (cb = 0; cb < cbEndL; cb++) {
 801d06e:	e02a      	b.n	801d0c6 <xmp3_DequantChannel+0xc2>
 801d070:	f8da 3034 	ldr.w	r3, [sl, #52]	@ 0x34
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 801d074:	f8db 503c 	ldr.w	r5, [fp, #60]	@ 0x3c
 801d078:	eb03 0244 	add.w	r2, r3, r4, lsl #1
		nSamps = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 801d07c:	f933 3014 	ldrsh.w	r3, [r3, r4, lsl #1]
 801d080:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801d084:	1ad2      	subs	r2, r2, r3
 801d086:	f104 0901 	add.w	r9, r4, #1
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 801d08a:	f818 3f01 	ldrb.w	r3, [r8, #1]!

		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
		i += nSamps;
 801d08e:	4417      	add	r7, r2
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 801d090:	4608      	mov	r0, r1
		gainI = 210 - globalGain + sfactMultiplier * (sfis->l[cb] + (sis->preFlag ? (int)preTab[cb] : 0));
 801d092:	b11d      	cbz	r5, 801d09c <xmp3_DequantChannel+0x98>
 801d094:	9d01      	ldr	r5, [sp, #4]
 801d096:	f895 c000 	ldrb.w	ip, [r5]
 801d09a:	4463      	add	r3, ip
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 801d09c:	9d06      	ldr	r5, [sp, #24]
 801d09e:	9e00      	ldr	r6, [sp, #0]
 801d0a0:	fb03 5306 	mla	r3, r3, r6, r5
 801d0a4:	f7ff febe 	bl	801ce24 <DequantBlock>
		/* update highest non-zero critical band */
		if (nonZero) 
			cbMax[0] = cb;
		gbMask |= nonZero;

		if (i >= *nonZeroBound) 
 801d0a8:	9b01      	ldr	r3, [sp, #4]
 801d0aa:	3301      	adds	r3, #1
 801d0ac:	9301      	str	r3, [sp, #4]
		gbMask |= nonZero;
 801d0ae:	9b02      	ldr	r3, [sp, #8]
 801d0b0:	4303      	orrs	r3, r0
 801d0b2:	9302      	str	r3, [sp, #8]
		if (nonZero) 
 801d0b4:	b900      	cbnz	r0, 801d0b8 <xmp3_DequantChannel+0xb4>
			cbMax[0] = cb;
 801d0b6:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
		if (i >= *nonZeroBound) 
 801d0b8:	9b03      	ldr	r3, [sp, #12]
 801d0ba:	940c      	str	r4, [sp, #48]	@ 0x30
 801d0bc:	681b      	ldr	r3, [r3, #0]
 801d0be:	42bb      	cmp	r3, r7
 801d0c0:	f340 80c8 	ble.w	801d254 <xmp3_DequantChannel+0x250>
	for (cb = 0; cb < cbEndL; cb++) {
 801d0c4:	464c      	mov	r4, r9
		nonZero |= DequantBlock(sampleBuf + i, sampleBuf + i, nSamps, gainI);
 801d0c6:	9b04      	ldr	r3, [sp, #16]
 801d0c8:	eb03 0187 	add.w	r1, r3, r7, lsl #2
	for (cb = 0; cb < cbEndL; cb++) {
 801d0cc:	9b05      	ldr	r3, [sp, #20]
 801d0ce:	429c      	cmp	r4, r3
 801d0d0:	d1ce      	bne.n	801d070 <xmp3_DequantChannel+0x6c>
			break;
	}

	/* set cbi (Type, EndS[], EndSMax will be overwritten if we proceed to do short blocks) */
	cbi->cbType = 0;			/* long only */
	cbi->cbEndL  = cbMax[0];
 801d0d2:	e9dd e107 	ldrd	lr, r1, [sp, #28]
 801d0d6:	9d02      	ldr	r5, [sp, #8]
 801d0d8:	f8dd 9070 	ldr.w	r9, [sp, #112]	@ 0x70
 801d0dc:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 801d0de:	f8c9 4014 	str.w	r4, [r9, #20]
	cbi->cbType = 0;			/* long only */
 801d0e2:	2300      	movs	r3, #0
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
	cbi->cbEndSMax = 0;
	
	/* early exit if no short blocks */
	if (cbStartS >= 12) 
 801d0e4:	f1be 0f0b 	cmp.w	lr, #11
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 801d0e8:	e9c9 3302 	strd	r3, r3, [r9, #8]
	cbi->cbType = 0;			/* long only */
 801d0ec:	f8c9 3000 	str.w	r3, [r9]
	cbi->cbEndS[0] = cbi->cbEndS[1] = cbi->cbEndS[2] = 0;
 801d0f0:	f8c9 3004 	str.w	r3, [r9, #4]
	cbi->cbEndSMax = 0;
 801d0f4:	f8c9 3010 	str.w	r3, [r9, #16]
	if (cbStartS >= 12) 
 801d0f8:	f300 80b2 	bgt.w	801d260 <xmp3_DequantChannel+0x25c>
		return CLZ(gbMask) - 1;
	
	/* short blocks */
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 801d0fc:	f1c1 03d2 	rsb	r3, r1, #210	@ 0xd2
 801d100:	9301      	str	r3, [sp, #4]
 801d102:	eb0e 0c4e 	add.w	ip, lr, lr, lsl #1
 801d106:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801d108:	9809      	ldr	r0, [sp, #36]	@ 0x24
 801d10a:	f8cd e038 	str.w	lr, [sp, #56]	@ 0x38
	for (cb = cbStartS; cb < cbEndS; cb++) {
 801d10e:	f10c 0c16 	add.w	ip, ip, #22
	cbMax[2] = cbMax[1] = cbMax[0] = cbStartS;
 801d112:	e9cd ee0c 	strd	lr, lr, [sp, #48]	@ 0x30
 801d116:	449c      	add	ip, r3
	for (cb = cbStartS; cb < cbEndS; cb++) {
 801d118:	f10b 0324 	add.w	r3, fp, #36	@ 0x24
 801d11c:	4639      	mov	r1, r7
 801d11e:	930b      	str	r3, [sp, #44]	@ 0x2c
 801d120:	f8cd c008 	str.w	ip, [sp, #8]
 801d124:	462f      	mov	r7, r5
 801d126:	f8cd b068 	str.w	fp, [sp, #104]	@ 0x68
 801d12a:	f8cd 9070 	str.w	r9, [sp, #112]	@ 0x70

		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 801d12e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801d130:	9d0b      	ldr	r5, [sp, #44]	@ 0x2c
 801d132:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
		for (w = 0; w < 3; w++) {
			nonZero =  0;
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);

			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 801d134:	f8dd b008 	ldr.w	fp, [sp, #8]
 801d138:	9009      	str	r0, [sp, #36]	@ 0x24
 801d13a:	eb03 034e 	add.w	r3, r3, lr, lsl #1
 801d13e:	46f4      	mov	ip, lr
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 801d140:	f9b3 2030 	ldrsh.w	r2, [r3, #48]	@ 0x30
 801d144:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	@ 0x2e
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 801d148:	f8cd c014 	str.w	ip, [sp, #20]
		nSamps = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 801d14c:	1ad2      	subs	r2, r2, r3
 801d14e:	f10e 0e01 	add.w	lr, lr, #1
 801d152:	9b04      	ldr	r3, [sp, #16]
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 801d154:	e9cd e106 	strd	lr, r1, [sp, #24]
 801d158:	eb03 0481 	add.w	r4, r3, r1, lsl #2
 801d15c:	46a1      	mov	r9, r4
 801d15e:	9408      	str	r4, [sp, #32]
 801d160:	0096      	lsls	r6, r2, #2
 801d162:	f10d 0830 	add.w	r8, sp, #48	@ 0x30
 801d166:	4682      	mov	sl, r0
 801d168:	4614      	mov	r4, r2
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 801d16a:	9a01      	ldr	r2, [sp, #4]
 801d16c:	f855 3f04 	ldr.w	r3, [r5, #4]!
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 801d170:	9900      	ldr	r1, [sp, #0]
			gainI = 210 - globalGain + 8*sis->subBlockGain[w] + sfactMultiplier*(sfis->s[cb][w]);
 801d172:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 801d176:	f81b 2f01 	ldrb.w	r2, [fp, #1]!
			nonZero |= DequantBlock(sampleBuf + i + nSamps*w, workBuf + nSamps*w, nSamps, gainI);
 801d17a:	4648      	mov	r0, r9
 801d17c:	fb01 3302 	mla	r3, r1, r2, r3
 801d180:	4651      	mov	r1, sl
 801d182:	4622      	mov	r2, r4
 801d184:	f7ff fe4e 	bl	801ce24 <DequantBlock>
		for (w = 0; w < 3; w++) {
 801d188:	44b2      	add	sl, r6
 801d18a:	44b1      	add	r9, r6

			/* update highest non-zero critical band */
			if (nonZero)
				cbMax[w] = cb;
			gbMask |= nonZero;
 801d18c:	4307      	orrs	r7, r0
			if (nonZero)
 801d18e:	b110      	cbz	r0, 801d196 <xmp3_DequantChannel+0x192>
				cbMax[w] = cb;
 801d190:	9b05      	ldr	r3, [sp, #20]
 801d192:	f8c8 3000 	str.w	r3, [r8]
		for (w = 0; w < 3; w++) {
 801d196:	f108 0804 	add.w	r8, r8, #4
 801d19a:	ab0f      	add	r3, sp, #60	@ 0x3c
 801d19c:	4598      	cmp	r8, r3
 801d19e:	d1e4      	bne.n	801d16a <xmp3_DequantChannel+0x166>
		}

		/* reorder blocks */
		buf = (ARRAY3 *)(sampleBuf + i);
		i += 3*nSamps;
 801d1a0:	e9dd e106 	ldrd	lr, r1, [sp, #24]
 801d1a4:	4622      	mov	r2, r4
 801d1a6:	eb02 0342 	add.w	r3, r2, r2, lsl #1
		for (j = 0; j < nSamps; j++) {
 801d1aa:	2a00      	cmp	r2, #0
		i += 3*nSamps;
 801d1ac:	e9dd 4008 	ldrd	r4, r0, [sp, #32]
 801d1b0:	4419      	add	r1, r3
 801d1b2:	ea4f 0542 	mov.w	r5, r2, lsl #1
		for (j = 0; j < nSamps; j++) {
 801d1b6:	dd19      	ble.n	801d1ec <xmp3_DequantChannel+0x1e8>
 801d1b8:	f102 4280 	add.w	r2, r2, #1073741824	@ 0x40000000
 801d1bc:	f105 4580 	add.w	r5, r5, #1073741824	@ 0x40000000
 801d1c0:	3a01      	subs	r2, #1
 801d1c2:	3d01      	subs	r5, #1
 801d1c4:	1f03      	subs	r3, r0, #4
 801d1c6:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 801d1ca:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 801d1ce:	eb03 0c06 	add.w	ip, r3, r6
			buf[j][0] = workBuf[0*nSamps + j];
 801d1d2:	f853 6f04 	ldr.w	r6, [r3, #4]!
 801d1d6:	6026      	str	r6, [r4, #0]
			buf[j][1] = workBuf[1*nSamps + j];
 801d1d8:	f852 6f04 	ldr.w	r6, [r2, #4]!
 801d1dc:	6066      	str	r6, [r4, #4]
			buf[j][2] = workBuf[2*nSamps + j];
 801d1de:	f855 6f04 	ldr.w	r6, [r5, #4]!
 801d1e2:	60a6      	str	r6, [r4, #8]
		for (j = 0; j < nSamps; j++) {
 801d1e4:	4563      	cmp	r3, ip
 801d1e6:	f104 040c 	add.w	r4, r4, #12
 801d1ea:	d1f2      	bne.n	801d1d2 <xmp3_DequantChannel+0x1ce>
		}

		ASSERT(3*nSamps <= MAX_REORDER_SAMPS);

		if (i >= *nonZeroBound) 
 801d1ec:	9b02      	ldr	r3, [sp, #8]
 801d1ee:	3303      	adds	r3, #3
 801d1f0:	9302      	str	r3, [sp, #8]
 801d1f2:	9b03      	ldr	r3, [sp, #12]
 801d1f4:	681b      	ldr	r3, [r3, #0]
 801d1f6:	428b      	cmp	r3, r1
 801d1f8:	dd02      	ble.n	801d200 <xmp3_DequantChannel+0x1fc>
	for (cb = cbStartS; cb < cbEndS; cb++) {
 801d1fa:	f1be 0f0d 	cmp.w	lr, #13
 801d1fe:	d196      	bne.n	801d12e <xmp3_DequantChannel+0x12a>
	 * however, the original nzb is no longer necessarily true
	 *   for each cb, buf[][] is updated with 3*nSamps samples (i increases 3*nSamps each time)
	 *   (buf[j + 1][0] = 3 (input) samples ahead of buf[j][0])
     * so update nonZeroBound to i
	 */
	*nonZeroBound = i;
 801d200:	9b03      	ldr	r3, [sp, #12]
 801d202:	f8dd b068 	ldr.w	fp, [sp, #104]	@ 0x68
 801d206:	6019      	str	r1, [r3, #0]

	ASSERT(*nonZeroBound <= MAX_NSAMP);

	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 801d208:	f8db 2018 	ldr.w	r2, [fp, #24]
 801d20c:	f8dd 9070 	ldr.w	r9, [sp, #112]	@ 0x70

	cbi->cbEndS[0] = cbMax[0];
	cbi->cbEndS[1] = cbMax[1];
 801d210:	e9dd 310c 	ldrd	r3, r1, [sp, #48]	@ 0x30
	cbi->cbType = (sis->mixedBlock ? 2 : 1);	/* 2 = mixed short/long, 1 = short only */
 801d214:	2a00      	cmp	r2, #0
 801d216:	bf0c      	ite	eq
 801d218:	2201      	moveq	r2, #1
 801d21a:	2202      	movne	r2, #2
 801d21c:	f8c9 2000 	str.w	r2, [r9]
	cbi->cbEndS[2] = cbMax[2];

	cbi->cbEndSMax = cbMax[0];
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
 801d220:	428b      	cmp	r3, r1
	cbi->cbEndS[2] = cbMax[2];
 801d222:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
	cbi->cbEndS[0] = cbMax[0];
 801d224:	f8c9 3004 	str.w	r3, [r9, #4]
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[1]);
 801d228:	bfb8      	it	lt
 801d22a:	460b      	movlt	r3, r1
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 801d22c:	4293      	cmp	r3, r2
 801d22e:	bfb8      	it	lt
 801d230:	4613      	movlt	r3, r2
	if (!x)
 801d232:	2f00      	cmp	r7, #0
	cbi->cbEndS[2] = cbMax[2];
 801d234:	e9c9 1202 	strd	r1, r2, [r9, #8]
 801d238:	463d      	mov	r5, r7
	cbi->cbEndSMax = MAX(cbi->cbEndSMax, cbMax[2]);
 801d23a:	f8c9 3010 	str.w	r3, [r9, #16]
 801d23e:	d02a      	beq.n	801d296 <xmp3_DequantChannel+0x292>
	while (!(x & 0x80000000)) {
 801d240:	db2f      	blt.n	801d2a2 <xmp3_DequantChannel+0x29e>
	numZeros = 0;
 801d242:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 801d244:	006d      	lsls	r5, r5, #1
 801d246:	4618      	mov	r0, r3
		numZeros++;
 801d248:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 801d24c:	d5fa      	bpl.n	801d244 <xmp3_DequantChannel+0x240>

	return CLZ(gbMask) - 1;
}
 801d24e:	b011      	add	sp, #68	@ 0x44
 801d250:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d254:	e9dd e107 	ldrd	lr, r1, [sp, #28]
 801d258:	9d02      	ldr	r5, [sp, #8]
 801d25a:	f8dd 9070 	ldr.w	r9, [sp, #112]	@ 0x70
 801d25e:	e73e      	b.n	801d0de <xmp3_DequantChannel+0xda>
	if (!x)
 801d260:	429d      	cmp	r5, r3
 801d262:	d018      	beq.n	801d296 <xmp3_DequantChannel+0x292>
	while (!(x & 0x80000000)) {
 801d264:	db1d      	blt.n	801d2a2 <xmp3_DequantChannel+0x29e>
 801d266:	006d      	lsls	r5, r5, #1
 801d268:	4618      	mov	r0, r3
		numZeros++;
 801d26a:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 801d26e:	d5fa      	bpl.n	801d266 <xmp3_DequantChannel+0x262>
 801d270:	b011      	add	sp, #68	@ 0x44
 801d272:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (sis->mixedBlock) { 
 801d276:	f8db a018 	ldr.w	sl, [fp, #24]
 801d27a:	f1ba 0f00 	cmp.w	sl, #0
 801d27e:	d00e      	beq.n	801d29e <xmp3_DequantChannel+0x29a>
			cbEndL = (fh->ver == MPEG1 ? 8 : 6); 
 801d280:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801d282:	781b      	ldrb	r3, [r3, #0]
			cbStartS = 3; 
 801d284:	2b00      	cmp	r3, #0
 801d286:	f04f 0e03 	mov.w	lr, #3
 801d28a:	bf14      	ite	ne
 801d28c:	f04f 0a06 	movne.w	sl, #6
 801d290:	f04f 0a08 	moveq.w	sl, #8
 801d294:	e6ca      	b.n	801d02c <xmp3_DequantChannel+0x28>
 801d296:	201f      	movs	r0, #31
}
 801d298:	b011      	add	sp, #68	@ 0x44
 801d29a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cbStartS = 0;
 801d29e:	46d6      	mov	lr, sl
 801d2a0:	e6c4      	b.n	801d02c <xmp3_DequantChannel+0x28>
 801d2a2:	f04f 30ff 	mov.w	r0, #4294967295
	return CLZ(gbMask) - 1;
 801d2a6:	e7d2      	b.n	801d24e <xmp3_DequantChannel+0x24a>
 801d2a8:	080357ec 	.word	0x080357ec

0801d2ac <xmp3_DecodeHuffman>:
 *              -1 if null input pointers, huffBlockBits < 0, or decoder runs 
 *                out of bits prematurely (invalid bitstream)
 **************************************************************************************/
// .data about 1ms faster per frame
int DecodeHuffman(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int huffBlockBits, int gr, int ch)
{
 801d2ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d2b0:	b097      	sub	sp, #92	@ 0x5c
 801d2b2:	f8dd c080 	ldr.w	ip, [sp, #128]	@ 0x80
 801d2b6:	9e21      	ldr	r6, [sp, #132]	@ 0x84
 801d2b8:	910b      	str	r1, [sp, #44]	@ 0x2c
 801d2ba:	9205      	str	r2, [sp, #20]
 801d2bc:	9301      	str	r3, [sp, #4]
	SideInfo *si;
	SideInfoSub *sis;
	HuffmanInfo *hi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS || !mp3DecInfo->HuffmanInfoPS)
 801d2be:	2800      	cmp	r0, #0
 801d2c0:	f000 8149 	beq.w	801d556 <xmp3_DecodeHuffman+0x2aa>
 801d2c4:	6805      	ldr	r5, [r0, #0]
 801d2c6:	2d00      	cmp	r5, #0
 801d2c8:	f000 8145 	beq.w	801d556 <xmp3_DecodeHuffman+0x2aa>
 801d2cc:	6842      	ldr	r2, [r0, #4]
 801d2ce:	2a00      	cmp	r2, #0
 801d2d0:	f000 8141 	beq.w	801d556 <xmp3_DecodeHuffman+0x2aa>
 801d2d4:	4619      	mov	r1, r3
 801d2d6:	6883      	ldr	r3, [r0, #8]
 801d2d8:	2b00      	cmp	r3, #0
 801d2da:	f000 813c 	beq.w	801d556 <xmp3_DecodeHuffman+0x2aa>
 801d2de:	68c0      	ldr	r0, [r0, #12]
 801d2e0:	2800      	cmp	r0, #0
 801d2e2:	f000 8138 	beq.w	801d556 <xmp3_DecodeHuffman+0x2aa>
	fh = ((FrameHeader *)(mp3DecInfo->FrameHeaderPS));
	si = ((SideInfo *)(mp3DecInfo->SideInfoPS));
	sis = &si->sis[gr][ch];
	hi = (HuffmanInfo*)(mp3DecInfo->HuffmanInfoPS);

	if (huffBlockBits < 0)
 801d2e6:	2900      	cmp	r1, #0
 801d2e8:	f2c0 8135 	blt.w	801d556 <xmp3_DecodeHuffman+0x2aa>
		return -1;

	/* figure out region boundaries (the first 2*bigVals coefficients divided into 3 regions) */
	if (sis->winSwitchFlag && sis->blockType == 2) {
 801d2ec:	eb0c 04cc 	add.w	r4, ip, ip, lsl #3
 801d2f0:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
 801d2f4:	0124      	lsls	r4, r4, #4
 801d2f6:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
 801d2fa:	4414      	add	r4, r2
 801d2fc:	00f1      	lsls	r1, r6, #3
 801d2fe:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 801d300:	910c      	str	r1, [sp, #48]	@ 0x30
		if (sis->mixedBlock == 0) {
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 801d302:	6b6f      	ldr	r7, [r5, #52]	@ 0x34
	if (sis->winSwitchFlag && sis->blockType == 2) {
 801d304:	ea4f 01cc 	mov.w	r1, ip, lsl #3
 801d308:	2b00      	cmp	r3, #0
 801d30a:	f040 82ae 	bne.w	801d86a <xmp3_DecodeHuffman+0x5be>
				r1Start = fh->sfBand->l[6] + 2*w;
			}
		}
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
	} else {
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 801d30e:	eb01 030c 	add.w	r3, r1, ip
 801d312:	00f4      	lsls	r4, r6, #3
 801d314:	4434      	add	r4, r6
 801d316:	011b      	lsls	r3, r3, #4
 801d318:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 801d31c:	4413      	add	r3, r2
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 801d31e:	e9d3 4317 	ldrd	r4, r3, [r3, #92]	@ 0x5c
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 801d322:	3401      	adds	r4, #1
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 801d324:	4423      	add	r3, r4
 801d326:	3301      	adds	r3, #1
		r1Start = fh->sfBand->l[sis->region0Count + 1];
 801d328:	f937 4014 	ldrsh.w	r4, [r7, r4, lsl #1]
		r2Start = fh->sfBand->l[sis->region0Count + 1 + sis->region1Count + 1];
 801d32c:	f937 e013 	ldrsh.w	lr, [r7, r3, lsl #1]
	}

	/* offset rEnd index by 1 so first region = rEnd[1] - rEnd[0], etc. */
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 801d330:	00f5      	lsls	r5, r6, #3
 801d332:	eb01 030c 	add.w	r3, r1, ip
 801d336:	19af      	adds	r7, r5, r6
 801d338:	011b      	lsls	r3, r3, #4
 801d33a:	eb03 05c7 	add.w	r5, r3, r7, lsl #3
 801d33e:	4415      	add	r5, r2
 801d340:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
 801d344:	6aed      	ldr	r5, [r5, #44]	@ 0x2c
 801d346:	006d      	lsls	r5, r5, #1
 801d348:	f5b5 7f10 	cmp.w	r5, #576	@ 0x240
 801d34c:	bfa8      	it	ge
 801d34e:	f44f 7510 	movge.w	r5, #576	@ 0x240
	rEnd[2] = MIN(r2Start, rEnd[3]);
 801d352:	45ae      	cmp	lr, r5
 801d354:	bfa8      	it	ge
 801d356:	46ae      	movge	lr, r5
	rEnd[1] = MIN(r1Start, rEnd[3]);
 801d358:	42ac      	cmp	r4, r5
 801d35a:	f103 0340 	add.w	r3, r3, #64	@ 0x40
 801d35e:	bfa8      	it	ge
 801d360:	462c      	movge	r4, r5
 801d362:	9413      	str	r4, [sp, #76]	@ 0x4c
	hi->nonZeroBound[ch] = rEnd[3];

	/* decode Huffman pairs (rEnd[i] are always even numbers) */
	bitsLeft = huffBlockBits;
	for (i = 0; i < 3; i++) {
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 801d364:	eb00 2407 	add.w	r4, r0, r7, lsl #8
 801d368:	18d7      	adds	r7, r2, r3
 801d36a:	eb00 0386 	add.w	r3, r0, r6, lsl #2
	hi->nonZeroBound[ch] = rEnd[3];
 801d36e:	f503 5380 	add.w	r3, r3, #4096	@ 0x1000
 801d372:	930e      	str	r3, [sp, #56]	@ 0x38
 801d374:	f8c3 5200 	str.w	r5, [r3, #512]	@ 0x200
	rEnd[0] = 0;
 801d378:	2300      	movs	r3, #0
 801d37a:	9312      	str	r3, [sp, #72]	@ 0x48
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 801d37c:	9b05      	ldr	r3, [sp, #20]
 801d37e:	940a      	str	r4, [sp, #40]	@ 0x28
 801d380:	e9cd 200f 	strd	r2, r0, [sp, #60]	@ 0x3c
 801d384:	681c      	ldr	r4, [r3, #0]
 801d386:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801d388:	9302      	str	r3, [sp, #8]
 801d38a:	e9cd c620 	strd	ip, r6, [sp, #128]	@ 0x80
 801d38e:	f10d 0b48 	add.w	fp, sp, #72	@ 0x48
 801d392:	f8cd b010 	str.w	fp, [sp, #16]
	rEnd[2] = MIN(r2Start, rEnd[3]);
 801d396:	f8cd e050 	str.w	lr, [sp, #80]	@ 0x50
	rEnd[3] = MIN(MAX_NSAMP, 2 * sis->nBigvals);
 801d39a:	9515      	str	r5, [sp, #84]	@ 0x54
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 801d39c:	9707      	str	r7, [sp, #28]
 801d39e:	9511      	str	r5, [sp, #68]	@ 0x44
 801d3a0:	4623      	mov	r3, r4
 801d3a2:	468b      	mov	fp, r1
 801d3a4:	9a04      	ldr	r2, [sp, #16]
 801d3a6:	9c07      	ldr	r4, [sp, #28]
 801d3a8:	6810      	ldr	r0, [r2, #0]
 801d3aa:	f852 1f04 	ldr.w	r1, [r2, #4]!
 801d3ae:	9204      	str	r2, [sp, #16]
 801d3b0:	1a09      	subs	r1, r1, r0
 801d3b2:	f854 2f04 	ldr.w	r2, [r4, #4]!
 801d3b6:	9407      	str	r4, [sp, #28]
	if(nVals <= 0) 
 801d3b8:	2900      	cmp	r1, #0
 801d3ba:	f340 80e8 	ble.w	801d58e <xmp3_DecodeHuffman+0x2e2>
	tabType = huffTabLookup[tabIdx].tabType;
 801d3be:	4ca5      	ldr	r4, [pc, #660]	@ (801d654 <xmp3_DecodeHuffman+0x3a8>)
 801d3c0:	eb04 05c2 	add.w	r5, r4, r2, lsl #3
	cachedBits = (8 - bitOffset) & 0x07;
 801d3c4:	425b      	negs	r3, r3
	tabType = huffTabLookup[tabIdx].tabType;
 801d3c6:	f895 8004 	ldrb.w	r8, [r5, #4]
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 801d3ca:	4da3      	ldr	r5, [pc, #652]	@ (801d658 <xmp3_DecodeHuffman+0x3ac>)
	linBits = huffTabLookup[tabIdx].linBits;
 801d3cc:	f854 e032 	ldr.w	lr, [r4, r2, lsl #3]
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 801d3d0:	f855 6022 	ldr.w	r6, [r5, r2, lsl #2]
	cachedBits = (8 - bitOffset) & 0x07;
 801d3d4:	f003 0307 	and.w	r3, r3, #7
 801d3d8:	9303      	str	r3, [sp, #12]
	if (cachedBits)
 801d3da:	2b00      	cmp	r3, #0
 801d3dc:	f000 8211 	beq.w	801d802 <xmp3_DecodeHuffman+0x556>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 801d3e0:	9d02      	ldr	r5, [sp, #8]
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 801d3e2:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 801d3e4:	f815 7b01 	ldrb.w	r7, [r5], #1
 801d3e8:	f1c3 0320 	rsb	r3, r3, #32
 801d3ec:	fa07 f303 	lsl.w	r3, r7, r3
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 801d3f0:	eb02 0080 	add.w	r0, r2, r0, lsl #2
	if (tabType == noBits) {
 801d3f4:	f1b8 0f00 	cmp.w	r8, #0
 801d3f8:	f000 820b 	beq.w	801d812 <xmp3_DecodeHuffman+0x566>
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 801d3fc:	4a97      	ldr	r2, [pc, #604]	@ (801d65c <xmp3_DecodeHuffman+0x3b0>)
	bitsLeft -= cachedBits;
 801d3fe:	9c03      	ldr	r4, [sp, #12]
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 801d400:	eb02 0c46 	add.w	ip, r2, r6, lsl #1
	bitsLeft -= cachedBits;
 801d404:	9a01      	ldr	r2, [sp, #4]
	} else if (tabType == oneShot) {
 801d406:	f1b8 0f01 	cmp.w	r8, #1
	bitsLeft -= cachedBits;
 801d40a:	eba2 0704 	sub.w	r7, r2, r4
	} else if (tabType == oneShot) {
 801d40e:	f000 8276 	beq.w	801d8fe <xmp3_DecodeHuffman+0x652>
	} else if (tabType == loopLinbits || tabType == loopNoLinbits) {
 801d412:	f1a8 0602 	sub.w	r6, r8, #2
 801d416:	2e01      	cmp	r6, #1
 801d418:	f200 809d 	bhi.w	801d556 <xmp3_DecodeHuffman+0x2aa>
					minBits = linBits + 1;
 801d41c:	f10e 0201 	add.w	r2, lr, #1
 801d420:	9208      	str	r2, [sp, #32]
					y += (int)(cache >> (32 - linBits));
 801d422:	f1ce 0220 	rsb	r2, lr, #32
 801d426:	9209      	str	r2, [sp, #36]	@ 0x24
 801d428:	9a03      	ldr	r2, [sp, #12]
 801d42a:	f8cd e018 	str.w	lr, [sp, #24]
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 801d42e:	4666      	mov	r6, ip
		padBits = 0;
 801d430:	f04f 0900 	mov.w	r9, #0
					y += (int)(cache >> (32 - linBits));
 801d434:	46c6      	mov	lr, r8
 801d436:	f8cd b034 	str.w	fp, [sp, #52]	@ 0x34
			if (bitsLeft >= 16) {
 801d43a:	2f0f      	cmp	r7, #15
 801d43c:	dd4a      	ble.n	801d4d4 <xmp3_DecodeHuffman+0x228>
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d43e:	f895 8001 	ldrb.w	r8, [r5, #1]
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d442:	f815 ab02 	ldrb.w	sl, [r5], #2
 801d446:	f1c2 0418 	rsb	r4, r2, #24
 801d44a:	fa0a f404 	lsl.w	r4, sl, r4
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d44e:	f1c2 0a10 	rsb	sl, r2, #16
 801d452:	fa08 f80a 	lsl.w	r8, r8, sl
 801d456:	ea44 0408 	orr.w	r4, r4, r8
			while (nVals > 0 && cachedBits >= 11 ) {
 801d45a:	2900      	cmp	r1, #0
				bitsLeft -= 16;
 801d45c:	f1a7 0710 	sub.w	r7, r7, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d460:	ea43 0304 	orr.w	r3, r3, r4
				cachedBits += 16;
 801d464:	f102 0210 	add.w	r2, r2, #16
			while (nVals > 0 && cachedBits >= 11 ) {
 801d468:	dd7f      	ble.n	801d56a <xmp3_DecodeHuffman+0x2be>
 801d46a:	2a0a      	cmp	r2, #10
 801d46c:	bfc8      	it	gt
 801d46e:	9503      	strgt	r5, [sp, #12]
 801d470:	dde3      	ble.n	801d43a <xmp3_DecodeHuffman+0x18e>
				maxBits = GetMaxbits(tCurr[0]);
 801d472:	8834      	ldrh	r4, [r6, #0]
 801d474:	f004 040f 	and.w	r4, r4, #15
				cw = tCurr[(cache >> (32 - maxBits)) + 1];
 801d478:	f1c4 0820 	rsb	r8, r4, #32
 801d47c:	fa23 f808 	lsr.w	r8, r3, r8
 801d480:	f108 0801 	add.w	r8, r8, #1
 801d484:	f836 8018 	ldrh.w	r8, [r6, r8, lsl #1]
				if (!len) {
 801d488:	ea5f 3a18 	movs.w	sl, r8, lsr #12
 801d48c:	d068      	beq.n	801d560 <xmp3_DecodeHuffman+0x2b4>
				cachedBits -= len;
 801d48e:	f3c8 2603 	ubfx	r6, r8, #8, #4
 801d492:	f3c8 1803 	ubfx	r8, r8, #4, #4
				if (x == 15 && tabType == loopLinbits) {
 801d496:	f1b8 0f0f 	cmp.w	r8, #15
				cachedBits -= len;
 801d49a:	eba2 020a 	sub.w	r2, r2, sl
				cache <<= len;
 801d49e:	fa03 f30a 	lsl.w	r3, r3, sl
				y = GetCWY(cw);
 801d4a2:	4634      	mov	r4, r6
				if (x == 15 && tabType == loopLinbits) {
 801d4a4:	d03b      	beq.n	801d51e <xmp3_DecodeHuffman+0x272>
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 801d4a6:	f1b8 0f00 	cmp.w	r8, #0
 801d4aa:	d13c      	bne.n	801d526 <xmp3_DecodeHuffman+0x27a>
				if (y == 15 && tabType == loopLinbits) {
 801d4ac:	2e0f      	cmp	r6, #15
 801d4ae:	d044      	beq.n	801d53a <xmp3_DecodeHuffman+0x28e>
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 801d4b0:	2c00      	cmp	r4, #0
 801d4b2:	d147      	bne.n	801d544 <xmp3_DecodeHuffman+0x298>
				if (cachedBits < padBits)
 801d4b4:	454a      	cmp	r2, r9
 801d4b6:	db4e      	blt.n	801d556 <xmp3_DecodeHuffman+0x2aa>
				nVals -= 2;
 801d4b8:	3902      	subs	r1, #2
				*xy++ = x;
 801d4ba:	4606      	mov	r6, r0
			while (nVals > 0 && cachedBits >= 11 ) {
 801d4bc:	2900      	cmp	r1, #0
				*xy++ = x;
 801d4be:	f846 8b08 	str.w	r8, [r6], #8
				*xy++ = y;
 801d4c2:	6044      	str	r4, [r0, #4]
			while (nVals > 0 && cachedBits >= 11 ) {
 801d4c4:	dd51      	ble.n	801d56a <xmp3_DecodeHuffman+0x2be>
				*xy++ = y;
 801d4c6:	4630      	mov	r0, r6
	tBase = (unsigned short *)(huffTable + huffTabOffset[tabIdx]);
 801d4c8:	4666      	mov	r6, ip
			while (nVals > 0 && cachedBits >= 11 ) {
 801d4ca:	2a0a      	cmp	r2, #10
 801d4cc:	dcd1      	bgt.n	801d472 <xmp3_DecodeHuffman+0x1c6>
			if (bitsLeft >= 16) {
 801d4ce:	2f0f      	cmp	r7, #15
 801d4d0:	9d03      	ldr	r5, [sp, #12]
 801d4d2:	dcb4      	bgt.n	801d43e <xmp3_DecodeHuffman+0x192>
				if (cachedBits + bitsLeft <= 0)	return -1;
 801d4d4:	19d4      	adds	r4, r2, r7
 801d4d6:	2c00      	cmp	r4, #0
 801d4d8:	dd3d      	ble.n	801d556 <xmp3_DecodeHuffman+0x2aa>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d4da:	2f00      	cmp	r7, #0
 801d4dc:	f340 81b9 	ble.w	801d852 <xmp3_DecodeHuffman+0x5a6>
 801d4e0:	f895 8000 	ldrb.w	r8, [r5]
 801d4e4:	f1c2 0918 	rsb	r9, r2, #24
 801d4e8:	fa08 f809 	lsl.w	r8, r8, r9
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d4ec:	2f08      	cmp	r7, #8
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d4ee:	ea48 0803 	orr.w	r8, r8, r3
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d4f2:	f340 828f 	ble.w	801da14 <xmp3_DecodeHuffman+0x768>
 801d4f6:	786b      	ldrb	r3, [r5, #1]
 801d4f8:	f1c2 0210 	rsb	r2, r2, #16
 801d4fc:	4093      	lsls	r3, r2
 801d4fe:	ea43 0708 	orr.w	r7, r3, r8
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 801d502:	f104 020b 	add.w	r2, r4, #11
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d506:	1e63      	subs	r3, r4, #1
 801d508:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d50c:	3502      	adds	r5, #2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d50e:	fa44 f303 	asr.w	r3, r4, r3
 801d512:	403b      	ands	r3, r7
				padBits = 11;
 801d514:	f04f 090b 	mov.w	r9, #11
				bitsLeft = 0;
 801d518:	2700      	movs	r7, #0
 801d51a:	9503      	str	r5, [sp, #12]
 801d51c:	e7a9      	b.n	801d472 <xmp3_DecodeHuffman+0x1c6>
				if (x == 15 && tabType == loopLinbits) {
 801d51e:	f1be 0f03 	cmp.w	lr, #3
 801d522:	f000 8106 	beq.w	801d732 <xmp3_DecodeHuffman+0x486>
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 801d526:	f003 4a00 	and.w	sl, r3, #2147483648	@ 0x80000000
				if (y == 15 && tabType == loopLinbits) {
 801d52a:	2e0f      	cmp	r6, #15
				if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 801d52c:	f102 32ff 	add.w	r2, r2, #4294967295
 801d530:	ea48 080a 	orr.w	r8, r8, sl
 801d534:	ea4f 0343 	mov.w	r3, r3, lsl #1
				if (y == 15 && tabType == loopLinbits) {
 801d538:	d1ba      	bne.n	801d4b0 <xmp3_DecodeHuffman+0x204>
 801d53a:	f1be 0f03 	cmp.w	lr, #3
 801d53e:	f000 8132 	beq.w	801d7a6 <xmp3_DecodeHuffman+0x4fa>
				y = GetCWY(cw);
 801d542:	4634      	mov	r4, r6
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 801d544:	3a01      	subs	r2, #1
 801d546:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
				if (cachedBits < padBits)
 801d54a:	454a      	cmp	r2, r9
				if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 801d54c:	ea44 0406 	orr.w	r4, r4, r6
 801d550:	ea4f 0343 	mov.w	r3, r3, lsl #1
				if (cachedBits < padBits)
 801d554:	dab0      	bge.n	801d4b8 <xmp3_DecodeHuffman+0x20c>
		return -1;
 801d556:	f04f 30ff 	mov.w	r0, #4294967295
	 */
	buf += (bitsLeft + *bitOffset) >> 3;
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
	
	return (buf - startBuf);
}
 801d55a:	b017      	add	sp, #92	@ 0x5c
 801d55c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					tCurr += cw;
 801d560:	eb06 0648 	add.w	r6, r6, r8, lsl #1
					cachedBits -= maxBits;
 801d564:	1b12      	subs	r2, r2, r4
					cache <<= maxBits;
 801d566:	40a3      	lsls	r3, r4
			while (nVals > 0 && cachedBits >= 11 ) {
 801d568:	e7af      	b.n	801d4ca <xmp3_DecodeHuffman+0x21e>
 801d56a:	9203      	str	r2, [sp, #12]
		bitsLeft += (cachedBits - padBits);
 801d56c:	9b03      	ldr	r3, [sp, #12]
 801d56e:	f8dd b034 	ldr.w	fp, [sp, #52]	@ 0x34
 801d572:	eba3 0209 	sub.w	r2, r3, r9
 801d576:	19d3      	adds	r3, r2, r7
		return (startBits - bitsLeft);
 801d578:	9a01      	ldr	r2, [sp, #4]
 801d57a:	1ad2      	subs	r2, r2, r3
		if (bitsUsed < 0 || bitsUsed > bitsLeft)	/* error - overran end of bitstream */
 801d57c:	9b01      	ldr	r3, [sp, #4]
 801d57e:	4293      	cmp	r3, r2
 801d580:	d3e9      	bcc.n	801d556 <xmp3_DecodeHuffman+0x2aa>
		bitsLeft -= bitsUsed;
 801d582:	9b01      	ldr	r3, [sp, #4]
 801d584:	1a9b      	subs	r3, r3, r2
 801d586:	9301      	str	r3, [sp, #4]
		buf += (bitsUsed + *bitOffset) >> 3;
 801d588:	9b05      	ldr	r3, [sp, #20]
 801d58a:	681b      	ldr	r3, [r3, #0]
 801d58c:	4413      	add	r3, r2
 801d58e:	9a02      	ldr	r2, [sp, #8]
 801d590:	eb02 02e3 	add.w	r2, r2, r3, asr #3
 801d594:	9202      	str	r2, [sp, #8]
		*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 801d596:	9a05      	ldr	r2, [sp, #20]
 801d598:	f003 0307 	and.w	r3, r3, #7
 801d59c:	6013      	str	r3, [r2, #0]
	for (i = 0; i < 3; i++) {
 801d59e:	9a04      	ldr	r2, [sp, #16]
 801d5a0:	a915      	add	r1, sp, #84	@ 0x54
 801d5a2:	428a      	cmp	r2, r1
 801d5a4:	f47f aefe 	bne.w	801d3a4 <xmp3_DecodeHuffman+0xf8>
	if (bitsLeft <= 0)
 801d5a8:	461c      	mov	r4, r3
 801d5aa:	9b01      	ldr	r3, [sp, #4]
 801d5ac:	9d11      	ldr	r5, [sp, #68]	@ 0x44
 801d5ae:	e9dd 200f 	ldrd	r2, r0, [sp, #60]	@ 0x3c
 801d5b2:	e9dd c620 	ldrd	ip, r6, [sp, #128]	@ 0x80
 801d5b6:	4659      	mov	r1, fp
 801d5b8:	2b00      	cmp	r3, #0
 801d5ba:	f000 8229 	beq.w	801da10 <xmp3_DecodeHuffman+0x764>
	cachedBits = (8 - bitOffset) & 0x07;
 801d5be:	4263      	negs	r3, r4
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 801d5c0:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 801d5c2:	4461      	add	r1, ip
 801d5c4:	0109      	lsls	r1, r1, #4
 801d5c6:	4434      	add	r4, r6
 801d5c8:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
 801d5cc:	440a      	add	r2, r1
	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 801d5ce:	4924      	ldr	r1, [pc, #144]	@ (801d660 <xmp3_DecodeHuffman+0x3b4>)
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 801d5d0:	6ed2      	ldr	r2, [r2, #108]	@ 0x6c
	tBase = (unsigned char *)quadTable + quadTabOffset[tabIdx];
 801d5d2:	f851 9022 	ldr.w	r9, [r1, r2, lsl #2]
	maxBits = quadTabMaxBits[tabIdx];
 801d5d6:	4923      	ldr	r1, [pc, #140]	@ (801d664 <xmp3_DecodeHuffman+0x3b8>)
 801d5d8:	f003 0307 	and.w	r3, r3, #7
 801d5dc:	f851 7022 	ldr.w	r7, [r1, r2, lsl #2]
	cachedBits = (8 - bitOffset) & 0x07;
 801d5e0:	4619      	mov	r1, r3
	if (cachedBits)
 801d5e2:	2b00      	cmp	r3, #0
 801d5e4:	f040 815a 	bne.w	801d89c <xmp3_DecodeHuffman+0x5f0>
		buf += (bitsUsed + *bitOffset) >> 3;
 801d5e8:	9c02      	ldr	r4, [sp, #8]
	bitsLeft -= cachedBits;
 801d5ea:	9a01      	ldr	r2, [sp, #4]
	while (i < (nVals - 3)) {
 801d5ec:	f5c5 7c0f 	rsb	ip, r5, #572	@ 0x23c
 801d5f0:	f10c 0c01 	add.w	ip, ip, #1
 801d5f4:	f1bc 0f00 	cmp.w	ip, #0
	bitsLeft -= cachedBits;
 801d5f8:	eba2 0b01 	sub.w	fp, r2, r1
	while (i < (nVals - 3)) {
 801d5fc:	f340 8208 	ble.w	801da10 <xmp3_DecodeHuffman+0x764>
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 801d600:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 801d602:	f8df a064 	ldr.w	sl, [pc, #100]	@ 801d668 <xmp3_DecodeHuffman+0x3bc>
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d606:	9004      	str	r0, [sp, #16]
	i = padBits = 0;
 801d608:	f04f 0e00 	mov.w	lr, #0
			cw = tBase[cache >> (32 - maxBits)];
 801d60c:	f1c7 0820 	rsb	r8, r7, #32
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 801d610:	eb02 0285 	add.w	r2, r2, r5, lsl #2
	i = padBits = 0;
 801d614:	4677      	mov	r7, lr
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d616:	9621      	str	r6, [sp, #132]	@ 0x84
		if (bitsLeft >= 16) {
 801d618:	f1bb 0f0f 	cmp.w	fp, #15
 801d61c:	f340 8146 	ble.w	801d8ac <xmp3_DecodeHuffman+0x600>
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d620:	4620      	mov	r0, r4
 801d622:	7865      	ldrb	r5, [r4, #1]
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d624:	f810 6b02 	ldrb.w	r6, [r0], #2
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d628:	4604      	mov	r4, r0
			cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d62a:	f1c1 0018 	rsb	r0, r1, #24
 801d62e:	fa06 f000 	lsl.w	r0, r6, r0
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d632:	f1c1 0610 	rsb	r6, r1, #16
 801d636:	40b5      	lsls	r5, r6
 801d638:	4328      	orrs	r0, r5
			bitsLeft -= 16;
 801d63a:	f1ab 0b10 	sub.w	fp, fp, #16
			cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d63e:	4303      	orrs	r3, r0
			cachedBits += 16;
 801d640:	3110      	adds	r1, #16
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 801d642:	45bc      	cmp	ip, r7
 801d644:	dd4e      	ble.n	801d6e4 <xmp3_DecodeHuffman+0x438>
 801d646:	f8cd b00c 	str.w	fp, [sp, #12]
 801d64a:	f102 0010 	add.w	r0, r2, #16
 801d64e:	46a3      	mov	fp, r4
 801d650:	e019      	b.n	801d686 <xmp3_DecodeHuffman+0x3da>
 801d652:	bf00      	nop
 801d654:	08035864 	.word	0x08035864
 801d658:	08035964 	.word	0x08035964
 801d65c:	080359e4 	.word	0x080359e4
 801d660:	0803580c 	.word	0x0803580c
 801d664:	08035804 	.word	0x08035804
 801d668:	08035814 	.word	0x08035814
			i += 4;
 801d66c:	3704      	adds	r7, #4
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 801d66e:	4567      	cmp	r7, ip
			*vwxy++ = y;
 801d670:	e940 5202 	strd	r5, r2, [r0, #-8]
			*vwxy++ = w;
 801d674:	e940 4604 	strd	r4, r6, [r0, #-16]
		while (i < (nVals - 3) && cachedBits >= 10 ) {
 801d678:	4602      	mov	r2, r0
 801d67a:	da33      	bge.n	801d6e4 <xmp3_DecodeHuffman+0x438>
 801d67c:	2909      	cmp	r1, #9
 801d67e:	f100 0010 	add.w	r0, r0, #16
 801d682:	f340 8138 	ble.w	801d8f6 <xmp3_DecodeHuffman+0x64a>
			cw = tBase[cache >> (32 - maxBits)];
 801d686:	fa23 f208 	lsr.w	r2, r3, r8
 801d68a:	444a      	add	r2, r9
 801d68c:	f81a 2002 	ldrb.w	r2, [sl, r2]
			len = GetHLenQ(cw);
 801d690:	0914      	lsrs	r4, r2, #4
			cache <<= len;
 801d692:	40a3      	lsls	r3, r4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 801d694:	f012 0408 	ands.w	r4, r2, #8
			cachedBits -= len;
 801d698:	eba1 1112 	sub.w	r1, r1, r2, lsr #4
			v = GetCWVQ(cw);	if(v) {ApplySign(v, cache); cache <<= 1; cachedBits--;}
 801d69c:	d005      	beq.n	801d6aa <xmp3_DecodeHuffman+0x3fe>
 801d69e:	f003 4400 	and.w	r4, r3, #2147483648	@ 0x80000000
 801d6a2:	3901      	subs	r1, #1
 801d6a4:	f044 0401 	orr.w	r4, r4, #1
 801d6a8:	005b      	lsls	r3, r3, #1
			w = GetCWWQ(cw);	if(w) {ApplySign(w, cache); cache <<= 1; cachedBits--;}
 801d6aa:	f012 0604 	ands.w	r6, r2, #4
 801d6ae:	d005      	beq.n	801d6bc <xmp3_DecodeHuffman+0x410>
 801d6b0:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
 801d6b4:	3901      	subs	r1, #1
 801d6b6:	f046 0601 	orr.w	r6, r6, #1
 801d6ba:	005b      	lsls	r3, r3, #1
			x = GetCWXQ(cw);	if(x) {ApplySign(x, cache); cache <<= 1; cachedBits--;}
 801d6bc:	f012 0502 	ands.w	r5, r2, #2
 801d6c0:	d005      	beq.n	801d6ce <xmp3_DecodeHuffman+0x422>
 801d6c2:	f003 4500 	and.w	r5, r3, #2147483648	@ 0x80000000
 801d6c6:	3901      	subs	r1, #1
 801d6c8:	f045 0501 	orr.w	r5, r5, #1
 801d6cc:	005b      	lsls	r3, r3, #1
			y = GetCWYQ(cw);	if(y) {ApplySign(y, cache); cache <<= 1; cachedBits--;}
 801d6ce:	f012 0201 	ands.w	r2, r2, #1
 801d6d2:	d005      	beq.n	801d6e0 <xmp3_DecodeHuffman+0x434>
 801d6d4:	f003 4200 	and.w	r2, r3, #2147483648	@ 0x80000000
 801d6d8:	3901      	subs	r1, #1
 801d6da:	f042 0201 	orr.w	r2, r2, #1
 801d6de:	005b      	lsls	r3, r3, #1
			if (cachedBits < padBits)
 801d6e0:	4571      	cmp	r1, lr
 801d6e2:	dac3      	bge.n	801d66c <xmp3_DecodeHuffman+0x3c0>
 801d6e4:	9804      	ldr	r0, [sp, #16]
 801d6e6:	9e21      	ldr	r6, [sp, #132]	@ 0x84
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 801d6e8:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 801d6ea:	f8d2 3200 	ldr.w	r3, [r2, #512]	@ 0x200
 801d6ee:	441f      	add	r7, r3
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++) {
 801d6f0:	f5b7 7f10 	cmp.w	r7, #576	@ 0x240
	hi->nonZeroBound[ch] += DecodeHuffmanQuads(hi->huffDecBuf[ch] + rEnd[3], MAX_NSAMP - rEnd[3], sis->count1TableSelect, bitsLeft, buf, *bitOffset);
 801d6f4:	f8c2 7200 	str.w	r7, [r2, #512]	@ 0x200
	for (i = hi->nonZeroBound[ch]; i < MAX_NSAMP; i++) {
 801d6f8:	da0b      	bge.n	801d712 <xmp3_DecodeHuffman+0x466>
		hi->huffDecBuf[ch][i] = 0;
 801d6fa:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 801d6fc:	4433      	add	r3, r6
 801d6fe:	eb07 1383 	add.w	r3, r7, r3, lsl #6
 801d702:	f5c7 7710 	rsb	r7, r7, #576	@ 0x240
 801d706:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 801d70a:	00ba      	lsls	r2, r7, #2
 801d70c:	2100      	movs	r1, #0
 801d70e:	f004 fcf9 	bl	8022104 <memset>
	buf += (bitsLeft + *bitOffset) >> 3;
 801d712:	9905      	ldr	r1, [sp, #20]
 801d714:	9a01      	ldr	r2, [sp, #4]
 801d716:	680b      	ldr	r3, [r1, #0]
 801d718:	9802      	ldr	r0, [sp, #8]
 801d71a:	441a      	add	r2, r3
 801d71c:	4613      	mov	r3, r2
	*bitOffset = (bitsLeft + *bitOffset) & 0x07;
 801d71e:	f002 0207 	and.w	r2, r2, #7
 801d722:	600a      	str	r2, [r1, #0]
	return (buf - startBuf);
 801d724:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
	buf += (bitsLeft + *bitOffset) >> 3;
 801d726:	eb00 03e3 	add.w	r3, r0, r3, asr #3
	return (buf - startBuf);
 801d72a:	1a98      	subs	r0, r3, r2
}
 801d72c:	b017      	add	sp, #92	@ 0x5c
 801d72e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					minBits = linBits + 1 + (y ? 1 : 0);
 801d732:	9d08      	ldr	r5, [sp, #32]
					if (cachedBits + bitsLeft < minBits)
 801d734:	eb02 0a07 	add.w	sl, r2, r7
					minBits = linBits + 1 + (y ? 1 : 0);
 801d738:	2e00      	cmp	r6, #0
 801d73a:	bf18      	it	ne
 801d73c:	3501      	addne	r5, #1
					if (cachedBits + bitsLeft < minBits)
 801d73e:	4555      	cmp	r5, sl
 801d740:	f73f af09 	bgt.w	801d556 <xmp3_DecodeHuffman+0x2aa>
					while (cachedBits < minBits) {
 801d744:	42aa      	cmp	r2, r5
 801d746:	da24      	bge.n	801d792 <xmp3_DecodeHuffman+0x4e6>
 801d748:	eba5 0a02 	sub.w	sl, r5, r2
 801d74c:	f10a 3aff 	add.w	sl, sl, #4294967295
 801d750:	9d03      	ldr	r5, [sp, #12]
 801d752:	f8cd c00c 	str.w	ip, [sp, #12]
 801d756:	ea4f 0ada 	mov.w	sl, sl, lsr #3
 801d75a:	f10a 0b01 	add.w	fp, sl, #1
 801d75e:	44ab      	add	fp, r5
 801d760:	f1c2 0818 	rsb	r8, r2, #24
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d764:	f815 cb01 	ldrb.w	ip, [r5], #1
 801d768:	fa0c fc08 	lsl.w	ip, ip, r8
					while (cachedBits < minBits) {
 801d76c:	455d      	cmp	r5, fp
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d76e:	ea43 030c 	orr.w	r3, r3, ip
					while (cachedBits < minBits) {
 801d772:	f1a8 0808 	sub.w	r8, r8, #8
 801d776:	d1f5      	bne.n	801d764 <xmp3_DecodeHuffman+0x4b8>
					if (bitsLeft < 0) {
 801d778:	f1a7 0808 	sub.w	r8, r7, #8
 801d77c:	ebb8 07ca 	subs.w	r7, r8, sl, lsl #3
 801d780:	f8dd c00c 	ldr.w	ip, [sp, #12]
 801d784:	9503      	str	r5, [sp, #12]
 801d786:	f102 0208 	add.w	r2, r2, #8
 801d78a:	ea4f 0bca 	mov.w	fp, sl, lsl #3
 801d78e:	d44e      	bmi.n	801d82e <xmp3_DecodeHuffman+0x582>
						cachedBits += 8;
 801d790:	445a      	add	r2, fp
					cachedBits -= linBits;
 801d792:	9d06      	ldr	r5, [sp, #24]
 801d794:	1b52      	subs	r2, r2, r5
					x += (int)(cache >> (32 - linBits));
 801d796:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 801d798:	fa23 f805 	lsr.w	r8, r3, r5
					cache <<= linBits;
 801d79c:	9d06      	ldr	r5, [sp, #24]
					x += (int)(cache >> (32 - linBits));
 801d79e:	f108 080f 	add.w	r8, r8, #15
					cache <<= linBits;
 801d7a2:	40ab      	lsls	r3, r5
 801d7a4:	e67f      	b.n	801d4a6 <xmp3_DecodeHuffman+0x1fa>
					if (cachedBits + bitsLeft < minBits)
 801d7a6:	9d08      	ldr	r5, [sp, #32]
 801d7a8:	19d4      	adds	r4, r2, r7
 801d7aa:	42a5      	cmp	r5, r4
 801d7ac:	f73f aed3 	bgt.w	801d556 <xmp3_DecodeHuffman+0x2aa>
					while (cachedBits < minBits) {
 801d7b0:	4295      	cmp	r5, r2
 801d7b2:	dd1e      	ble.n	801d7f2 <xmp3_DecodeHuffman+0x546>
 801d7b4:	9c06      	ldr	r4, [sp, #24]
 801d7b6:	9d03      	ldr	r5, [sp, #12]
 801d7b8:	eba4 0b02 	sub.w	fp, r4, r2
 801d7bc:	ea4f 0bdb 	mov.w	fp, fp, lsr #3
 801d7c0:	f10b 0a01 	add.w	sl, fp, #1
 801d7c4:	44aa      	add	sl, r5
 801d7c6:	f1c2 0618 	rsb	r6, r2, #24
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d7ca:	f815 4b01 	ldrb.w	r4, [r5], #1
 801d7ce:	40b4      	lsls	r4, r6
					while (cachedBits < minBits) {
 801d7d0:	45aa      	cmp	sl, r5
						cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d7d2:	ea43 0304 	orr.w	r3, r3, r4
					while (cachedBits < minBits) {
 801d7d6:	f1a6 0608 	sub.w	r6, r6, #8
 801d7da:	d1f6      	bne.n	801d7ca <xmp3_DecodeHuffman+0x51e>
					if (bitsLeft < 0) {
 801d7dc:	f1a7 0408 	sub.w	r4, r7, #8
 801d7e0:	ebb4 07cb 	subs.w	r7, r4, fp, lsl #3
 801d7e4:	9503      	str	r5, [sp, #12]
 801d7e6:	f102 0208 	add.w	r2, r2, #8
 801d7ea:	ea4f 06cb 	mov.w	r6, fp, lsl #3
 801d7ee:	d428      	bmi.n	801d842 <xmp3_DecodeHuffman+0x596>
						cachedBits += 8;
 801d7f0:	4432      	add	r2, r6
					y += (int)(cache >> (32 - linBits));
 801d7f2:	9c09      	ldr	r4, [sp, #36]	@ 0x24
					cachedBits -= linBits;
 801d7f4:	9d06      	ldr	r5, [sp, #24]
					y += (int)(cache >> (32 - linBits));
 801d7f6:	fa23 f404 	lsr.w	r4, r3, r4
					cachedBits -= linBits;
 801d7fa:	1b52      	subs	r2, r2, r5
					y += (int)(cache >> (32 - linBits));
 801d7fc:	340f      	adds	r4, #15
					cache <<= linBits;
 801d7fe:	40ab      	lsls	r3, r5
 801d800:	e656      	b.n	801d4b0 <xmp3_DecodeHuffman+0x204>
		bitsUsed = DecodeHuffmanPairs(hi->huffDecBuf[ch] + rEnd[i], rEnd[i+1] - rEnd[i], sis->tableSelect[i], bitsLeft, buf, *bitOffset);
 801d802:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 801d804:	9d02      	ldr	r5, [sp, #8]
 801d806:	eb02 0080 	add.w	r0, r2, r0, lsl #2
	if (tabType == noBits) {
 801d80a:	f1b8 0f00 	cmp.w	r8, #0
 801d80e:	f47f adf5 	bne.w	801d3fc <xmp3_DecodeHuffman+0x150>
 801d812:	1e4a      	subs	r2, r1, #1
 801d814:	0852      	lsrs	r2, r2, #1
 801d816:	f100 0308 	add.w	r3, r0, #8
 801d81a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801d81e:	4642      	mov	r2, r8
			xy[i+0] = 0;
 801d820:	e9c0 2200 	strd	r2, r2, [r0]
		for (i = 0; i < nVals; i+=2) {
 801d824:	3008      	adds	r0, #8
 801d826:	4283      	cmp	r3, r0
 801d828:	d1fa      	bne.n	801d820 <xmp3_DecodeHuffman+0x574>
		return 0;
 801d82a:	2200      	movs	r2, #0
 801d82c:	e6a9      	b.n	801d582 <xmp3_DecodeHuffman+0x2d6>
						cachedBits += bitsLeft;
 801d82e:	4442      	add	r2, r8
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d830:	f102 38ff 	add.w	r8, r2, #4294967295
 801d834:	f04f 4700 	mov.w	r7, #2147483648	@ 0x80000000
 801d838:	fa47 f708 	asr.w	r7, r7, r8
 801d83c:	403b      	ands	r3, r7
						bitsLeft = 0;
 801d83e:	2700      	movs	r7, #0
 801d840:	e7a7      	b.n	801d792 <xmp3_DecodeHuffman+0x4e6>
						cachedBits += bitsLeft;
 801d842:	4422      	add	r2, r4
						cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d844:	1e56      	subs	r6, r2, #1
 801d846:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
 801d84a:	4134      	asrs	r4, r6
 801d84c:	4023      	ands	r3, r4
						bitsLeft = 0;
 801d84e:	2700      	movs	r7, #0
 801d850:	e7cf      	b.n	801d7f2 <xmp3_DecodeHuffman+0x546>
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d852:	1e67      	subs	r7, r4, #1
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 801d854:	f104 020b 	add.w	r2, r4, #11
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d858:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
 801d85c:	413c      	asrs	r4, r7
 801d85e:	4023      	ands	r3, r4
				padBits = 11;
 801d860:	f04f 090b 	mov.w	r9, #11
				bitsLeft = 0;
 801d864:	2700      	movs	r7, #0
 801d866:	9503      	str	r5, [sp, #12]
 801d868:	e603      	b.n	801d472 <xmp3_DecodeHuffman+0x1c6>
	if (sis->winSwitchFlag && sis->blockType == 2) {
 801d86a:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 801d86c:	2b02      	cmp	r3, #2
 801d86e:	f47f ad4e 	bne.w	801d30e <xmp3_DecodeHuffman+0x62>
		if (sis->mixedBlock == 0) {
 801d872:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 801d874:	2b00      	cmp	r3, #0
 801d876:	f040 80de 	bne.w	801da36 <xmp3_DecodeHuffman+0x78a>
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 801d87a:	6de4      	ldr	r4, [r4, #92]	@ 0x5c
 801d87c:	f1a3 33aa 	sub.w	r3, r3, #2863311530	@ 0xaaaaaaaa
 801d880:	3401      	adds	r4, #1
 801d882:	fb83 5304 	smull	r5, r3, r3, r4
 801d886:	eba3 73e4 	sub.w	r3, r3, r4, asr #31
 801d88a:	eb07 0343 	add.w	r3, r7, r3, lsl #1
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 801d88e:	f44f 7e10 	mov.w	lr, #576	@ 0x240
			r1Start = fh->sfBand->s[(sis->region0Count + 1)/3] * 3;
 801d892:	f9b3 402e 	ldrsh.w	r4, [r3, #46]	@ 0x2e
 801d896:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 801d89a:	e549      	b.n	801d330 <xmp3_DecodeHuffman+0x84>
		cache = (unsigned int)(*buf++) << (32 - cachedBits);
 801d89c:	9c02      	ldr	r4, [sp, #8]
 801d89e:	f814 2b01 	ldrb.w	r2, [r4], #1
 801d8a2:	f1c3 0320 	rsb	r3, r3, #32
 801d8a6:	fa02 f303 	lsl.w	r3, r2, r3
 801d8aa:	e69e      	b.n	801d5ea <xmp3_DecodeHuffman+0x33e>
			if (cachedBits + bitsLeft <= 0) return i;
 801d8ac:	eb01 000b 	add.w	r0, r1, fp
 801d8b0:	2800      	cmp	r0, #0
 801d8b2:	f77f af17 	ble.w	801d6e4 <xmp3_DecodeHuffman+0x438>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d8b6:	f1bb 0f00 	cmp.w	fp, #0
 801d8ba:	dd0f      	ble.n	801d8dc <xmp3_DecodeHuffman+0x630>
 801d8bc:	7825      	ldrb	r5, [r4, #0]
 801d8be:	f1c1 0618 	rsb	r6, r1, #24
 801d8c2:	40b5      	lsls	r5, r6
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d8c4:	f1bb 0f08 	cmp.w	fp, #8
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d8c8:	ea43 0305 	orr.w	r3, r3, r5
			if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d8cc:	f340 80b1 	ble.w	801da32 <xmp3_DecodeHuffman+0x786>
 801d8d0:	f1c1 0510 	rsb	r5, r1, #16
 801d8d4:	7861      	ldrb	r1, [r4, #1]
 801d8d6:	40a9      	lsls	r1, r5
 801d8d8:	430b      	orrs	r3, r1
 801d8da:	3402      	adds	r4, #2
			cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d8dc:	1e41      	subs	r1, r0, #1
 801d8de:	f04f 4500 	mov.w	r5, #2147483648	@ 0x80000000
 801d8e2:	fa45 f101 	asr.w	r1, r5, r1
 801d8e6:	400b      	ands	r3, r1
			padBits = 10;
 801d8e8:	f04f 0e0a 	mov.w	lr, #10
			cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 801d8ec:	f100 010a 	add.w	r1, r0, #10
			bitsLeft = 0;
 801d8f0:	f04f 0b00 	mov.w	fp, #0
 801d8f4:	e6a5      	b.n	801d642 <xmp3_DecodeHuffman+0x396>
 801d8f6:	465c      	mov	r4, fp
 801d8f8:	f8dd b00c 	ldr.w	fp, [sp, #12]
 801d8fc:	e68c      	b.n	801d618 <xmp3_DecodeHuffman+0x36c>
		maxBits = GetMaxbits(tBase[0]);
 801d8fe:	4a5d      	ldr	r2, [pc, #372]	@ (801da74 <xmp3_DecodeHuffman+0x7c8>)
 801d900:	f832 8016 	ldrh.w	r8, [r2, r6, lsl #1]
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d904:	9e03      	ldr	r6, [sp, #12]
		maxBits = GetMaxbits(tBase[0]);
 801d906:	f008 080f 	and.w	r8, r8, #15
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d90a:	468a      	mov	sl, r1
				cw = tBase[cache >> (32 - maxBits)];
 801d90c:	f1c8 0820 	rsb	r8, r8, #32
		padBits = 0;
 801d910:	f04f 0900 	mov.w	r9, #0
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d914:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
 801d918:	4659      	mov	r1, fp
			if (bitsLeft >= 16) {
 801d91a:	2f0f      	cmp	r7, #15
 801d91c:	dd4d      	ble.n	801d9ba <xmp3_DecodeHuffman+0x70e>
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d91e:	f895 e001 	ldrb.w	lr, [r5, #1]
				cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d922:	f815 bb02 	ldrb.w	fp, [r5], #2
 801d926:	f1c6 0218 	rsb	r2, r6, #24
 801d92a:	fa0b f202 	lsl.w	r2, fp, r2
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d92e:	f1c6 0b10 	rsb	fp, r6, #16
 801d932:	fa0e fe0b 	lsl.w	lr, lr, fp
 801d936:	ea42 020e 	orr.w	r2, r2, lr
				bitsLeft -= 16;
 801d93a:	3f10      	subs	r7, #16
				cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d93c:	4313      	orrs	r3, r2
				cachedBits += 16;
 801d93e:	3610      	adds	r6, #16
			while (nVals > 0 && cachedBits >= 11 ) {
 801d940:	f1ba 0f00 	cmp.w	sl, #0
 801d944:	dd59      	ble.n	801d9fa <xmp3_DecodeHuffman+0x74e>
 801d946:	f10a 32ff 	add.w	r2, sl, #4294967295
 801d94a:	f022 0201 	bic.w	r2, r2, #1
 801d94e:	f1aa 0b02 	sub.w	fp, sl, #2
 801d952:	f100 0e08 	add.w	lr, r0, #8
 801d956:	ebab 0b02 	sub.w	fp, fp, r2
 801d95a:	9503      	str	r5, [sp, #12]
 801d95c:	e007      	b.n	801d96e <xmp3_DecodeHuffman+0x6c2>
 801d95e:	45d3      	cmp	fp, sl
				*xy++ = y;
 801d960:	e94e 5202 	strd	r5, r2, [lr, #-8]
			while (nVals > 0 && cachedBits >= 11 ) {
 801d964:	f10e 0e08 	add.w	lr, lr, #8
 801d968:	d047      	beq.n	801d9fa <xmp3_DecodeHuffman+0x74e>
 801d96a:	2e0a      	cmp	r6, #10
 801d96c:	dd4e      	ble.n	801da0c <xmp3_DecodeHuffman+0x760>
				cw = tBase[cache >> (32 - maxBits)];
 801d96e:	fa23 f208 	lsr.w	r2, r3, r8
 801d972:	3201      	adds	r2, #1
 801d974:	f83c 2012 	ldrh.w	r2, [ip, r2, lsl #1]
				len = GetHLen(cw);
 801d978:	0b10      	lsrs	r0, r2, #12
				cache <<= len;
 801d97a:	4083      	lsls	r3, r0
				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 801d97c:	f012 0ff0 	tst.w	r2, #240	@ 0xf0
				cachedBits -= len;
 801d980:	eba6 3612 	sub.w	r6, r6, r2, lsr #12
				x = GetCWX(cw);		if (x)	{ApplySign(x, cache); cache <<= 1; cachedBits--;}
 801d984:	f3c2 1503 	ubfx	r5, r2, #4, #4
 801d988:	f003 4000 	and.w	r0, r3, #2147483648	@ 0x80000000
 801d98c:	d002      	beq.n	801d994 <xmp3_DecodeHuffman+0x6e8>
 801d98e:	4305      	orrs	r5, r0
 801d990:	005b      	lsls	r3, r3, #1
 801d992:	3e01      	subs	r6, #1
				y = GetCWY(cw);		if (y)	{ApplySign(y, cache); cache <<= 1; cachedBits--;}
 801d994:	f412 6f70 	tst.w	r2, #3840	@ 0xf00
 801d998:	f3c2 2003 	ubfx	r0, r2, #8, #4
 801d99c:	bf18      	it	ne
 801d99e:	f106 36ff 	addne.w	r6, r6, #4294967295
 801d9a2:	f003 4200 	and.w	r2, r3, #2147483648	@ 0x80000000
 801d9a6:	bf16      	itet	ne
 801d9a8:	4302      	orrne	r2, r0
 801d9aa:	4602      	moveq	r2, r0
 801d9ac:	005b      	lslne	r3, r3, #1
				if (cachedBits < padBits)
 801d9ae:	454e      	cmp	r6, r9
				nVals -= 2;
 801d9b0:	f1aa 0a02 	sub.w	sl, sl, #2
 801d9b4:	4670      	mov	r0, lr
				if (cachedBits < padBits)
 801d9b6:	dad2      	bge.n	801d95e <xmp3_DecodeHuffman+0x6b2>
 801d9b8:	e5cd      	b.n	801d556 <xmp3_DecodeHuffman+0x2aa>
				if (cachedBits + bitsLeft <= 0)	return -1;
 801d9ba:	19f2      	adds	r2, r6, r7
 801d9bc:	2a00      	cmp	r2, #0
 801d9be:	f77f adca 	ble.w	801d556 <xmp3_DecodeHuffman+0x2aa>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d9c2:	2f00      	cmp	r7, #0
 801d9c4:	dd0f      	ble.n	801d9e6 <xmp3_DecodeHuffman+0x73a>
 801d9c6:	f895 e000 	ldrb.w	lr, [r5]
 801d9ca:	f1c6 0918 	rsb	r9, r6, #24
 801d9ce:	fa0e fe09 	lsl.w	lr, lr, r9
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d9d2:	2f08      	cmp	r7, #8
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801d9d4:	ea43 030e 	orr.w	r3, r3, lr
				if (bitsLeft > 8)	cache |= (unsigned int)(*buf++) << (16 - cachedBits);
 801d9d8:	dd3e      	ble.n	801da58 <xmp3_DecodeHuffman+0x7ac>
 801d9da:	f1c6 0710 	rsb	r7, r6, #16
 801d9de:	786e      	ldrb	r6, [r5, #1]
 801d9e0:	40be      	lsls	r6, r7
 801d9e2:	4333      	orrs	r3, r6
 801d9e4:	3502      	adds	r5, #2
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801d9e6:	1e56      	subs	r6, r2, #1
 801d9e8:	fa44 f606 	asr.w	r6, r4, r6
 801d9ec:	4033      	ands	r3, r6
				padBits = 11;
 801d9ee:	f04f 090b 	mov.w	r9, #11
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 801d9f2:	f102 060b 	add.w	r6, r2, #11
				bitsLeft = 0;
 801d9f6:	2700      	movs	r7, #0
 801d9f8:	e7a2      	b.n	801d940 <xmp3_DecodeHuffman+0x694>
 801d9fa:	9603      	str	r6, [sp, #12]
		bitsLeft += (cachedBits - padBits);
 801d9fc:	9b03      	ldr	r3, [sp, #12]
		return (startBits - bitsLeft);
 801d9fe:	9a01      	ldr	r2, [sp, #4]
		bitsLeft += (cachedBits - padBits);
 801da00:	eba3 0309 	sub.w	r3, r3, r9
 801da04:	443b      	add	r3, r7
 801da06:	468b      	mov	fp, r1
		return (startBits - bitsLeft);
 801da08:	1ad2      	subs	r2, r2, r3
 801da0a:	e5b7      	b.n	801d57c <xmp3_DecodeHuffman+0x2d0>
 801da0c:	9d03      	ldr	r5, [sp, #12]
 801da0e:	e784      	b.n	801d91a <xmp3_DecodeHuffman+0x66e>
		return 0;
 801da10:	2700      	movs	r7, #0
 801da12:	e669      	b.n	801d6e8 <xmp3_DecodeHuffman+0x43c>
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801da14:	1e63      	subs	r3, r4, #1
				cachedBits += padBits;	/* okay if this is > 32 (0's automatically shifted in from right) */
 801da16:	f104 020b 	add.w	r2, r4, #11
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801da1a:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801da1e:	3501      	adds	r5, #1
				cache &= (signed int)0x80000000 >> (cachedBits - 1);
 801da20:	fa44 f303 	asr.w	r3, r4, r3
 801da24:	ea03 0308 	and.w	r3, r3, r8
				padBits = 11;
 801da28:	f04f 090b 	mov.w	r9, #11
				bitsLeft = 0;
 801da2c:	2700      	movs	r7, #0
 801da2e:	9503      	str	r5, [sp, #12]
 801da30:	e51f      	b.n	801d472 <xmp3_DecodeHuffman+0x1c6>
			if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801da32:	3401      	adds	r4, #1
 801da34:	e752      	b.n	801d8dc <xmp3_DecodeHuffman+0x630>
			if (fh->ver == MPEG1) {
 801da36:	782b      	ldrb	r3, [r5, #0]
 801da38:	b983      	cbnz	r3, 801da5c <xmp3_DecodeHuffman+0x7b0>
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 801da3a:	eb01 030c 	add.w	r3, r1, ip
 801da3e:	00f4      	lsls	r4, r6, #3
 801da40:	4434      	add	r4, r6
 801da42:	011b      	lsls	r3, r3, #4
 801da44:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 801da48:	4413      	add	r3, r2
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 801da4a:	f44f 7e10 	mov.w	lr, #576	@ 0x240
				r1Start = fh->sfBand->l[sis->region0Count + 1];
 801da4e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 801da50:	3301      	adds	r3, #1
 801da52:	f937 4013 	ldrsh.w	r4, [r7, r3, lsl #1]
 801da56:	e46b      	b.n	801d330 <xmp3_DecodeHuffman+0x84>
				if (bitsLeft > 0)	cache |= (unsigned int)(*buf++) << (24 - cachedBits);
 801da58:	3501      	adds	r5, #1
 801da5a:	e7c4      	b.n	801d9e6 <xmp3_DecodeHuffman+0x73a>
				w = fh->sfBand->s[4] - fh->sfBand->s[3];
 801da5c:	f9b7 4034 	ldrsh.w	r4, [r7, #52]	@ 0x34
 801da60:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	@ 0x36
 801da64:	1b1b      	subs	r3, r3, r4
				r1Start = fh->sfBand->l[6] + 2*w;
 801da66:	f9b7 400c 	ldrsh.w	r4, [r7, #12]
		r2Start = MAX_NSAMP;	/* short blocks don't have region 2 */
 801da6a:	f44f 7e10 	mov.w	lr, #576	@ 0x240
				r1Start = fh->sfBand->l[6] + 2*w;
 801da6e:	eb04 0443 	add.w	r4, r4, r3, lsl #1
 801da72:	e45d      	b.n	801d330 <xmp3_DecodeHuffman+0x84>
 801da74:	080359e4 	.word	0x080359e4

0801da78 <FreqInvertRescale>:
 *              rescaled (as necessary) previous samples
 *
 * Return:      updated mOut (from new outputs y)
 **************************************************************************************/
static int FreqInvertRescale(int *y, int *xPrev, int blockIdx, int es)
{
 801da78:	4684      	mov	ip, r0
	int i, d, mOut;
	int y0, y1, y2, y3, y4, y5, y6, y7, y8;

	if (es == 0) {
		/* fast case - frequency invert only (no rescaling) - can fuse into overlap-add for speed, if desired */
		if (blockIdx & 0x01) {
 801da7a:	f002 0001 	and.w	r0, r2, #1
	if (es == 0) {
 801da7e:	bb7b      	cbnz	r3, 801dae0 <FreqInvertRescale+0x68>
		if (blockIdx & 0x01) {
 801da80:	b360      	cbz	r0, 801dadc <FreqInvertRescale+0x64>
			y += NBANDS;
			y0 = *y;	y += 2*NBANDS;
			y1 = *y;	y += 2*NBANDS;
			y2 = *y;	y += 2*NBANDS;
			y3 = *y;	y += 2*NBANDS;
			y4 = *y;	y += 2*NBANDS;
 801da82:	f8dc 3480 	ldr.w	r3, [ip, #1152]	@ 0x480
			y1 = *y;	y += 2*NBANDS;
 801da86:	f8dc 0180 	ldr.w	r0, [ip, #384]	@ 0x180
			y2 = *y;	y += 2*NBANDS;
 801da8a:	f8dc 1280 	ldr.w	r1, [ip, #640]	@ 0x280
			y3 = *y;	y += 2*NBANDS;
 801da8e:	f8dc 2380 	ldr.w	r2, [ip, #896]	@ 0x380
			y -= 18*NBANDS;
			*y = -y0;	y += 2*NBANDS;
			*y = -y1;	y += 2*NBANDS;
			*y = -y2;	y += 2*NBANDS;
			*y = -y3;	y += 2*NBANDS;
			*y = -y4;	y += 2*NBANDS;
 801da92:	425b      	negs	r3, r3
 801da94:	f8cc 3480 	str.w	r3, [ip, #1152]	@ 0x480
			y8 = *y;	y += 2*NBANDS;
 801da98:	f8dc 3880 	ldr.w	r3, [ip, #2176]	@ 0x880
			*y = -y1;	y += 2*NBANDS;
 801da9c:	4240      	negs	r0, r0
			*y = -y2;	y += 2*NBANDS;
 801da9e:	4249      	negs	r1, r1
			*y = -y3;	y += 2*NBANDS;
 801daa0:	4252      	negs	r2, r2
			*y = -y5;	y += 2*NBANDS;
			*y = -y6;	y += 2*NBANDS;
			*y = -y7;	y += 2*NBANDS;
			*y = -y8;	y += 2*NBANDS;
 801daa2:	425b      	negs	r3, r3
			*y = -y1;	y += 2*NBANDS;
 801daa4:	f8cc 0180 	str.w	r0, [ip, #384]	@ 0x180
			*y = -y2;	y += 2*NBANDS;
 801daa8:	f8cc 1280 	str.w	r1, [ip, #640]	@ 0x280
			y5 = *y;	y += 2*NBANDS;
 801daac:	f8dc 0580 	ldr.w	r0, [ip, #1408]	@ 0x580
			y6 = *y;	y += 2*NBANDS;
 801dab0:	f8dc 1680 	ldr.w	r1, [ip, #1664]	@ 0x680
			*y = -y3;	y += 2*NBANDS;
 801dab4:	f8cc 2380 	str.w	r2, [ip, #896]	@ 0x380
			*y = -y8;	y += 2*NBANDS;
 801dab8:	f8cc 3880 	str.w	r3, [ip, #2176]	@ 0x880
			y7 = *y;	y += 2*NBANDS;
 801dabc:	f8dc 2780 	ldr.w	r2, [ip, #1920]	@ 0x780
			*y = -y0;	y += 2*NBANDS;
 801dac0:	f8dc 3080 	ldr.w	r3, [ip, #128]	@ 0x80
			*y = -y5;	y += 2*NBANDS;
 801dac4:	4240      	negs	r0, r0
			*y = -y6;	y += 2*NBANDS;
 801dac6:	4249      	negs	r1, r1
			*y = -y7;	y += 2*NBANDS;
 801dac8:	4252      	negs	r2, r2
			*y = -y0;	y += 2*NBANDS;
 801daca:	425b      	negs	r3, r3
			*y = -y5;	y += 2*NBANDS;
 801dacc:	f8cc 0580 	str.w	r0, [ip, #1408]	@ 0x580
			*y = -y6;	y += 2*NBANDS;
 801dad0:	f8cc 1680 	str.w	r1, [ip, #1664]	@ 0x680
			*y = -y7;	y += 2*NBANDS;
 801dad4:	f8cc 2780 	str.w	r2, [ip, #1920]	@ 0x780
			*y = -y0;	y += 2*NBANDS;
 801dad8:	f8cc 3080 	str.w	r3, [ip, #128]	@ 0x80
		}
		return 0;
 801dadc:	2000      	movs	r0, #0
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
			}
		}
		return mOut;
	}
}
 801dade:	4770      	bx	lr
{
 801dae0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801dae4:	f04f 4500 	mov.w	r5, #2147483648	@ 0x80000000
 801dae8:	40dd      	lsrs	r5, r3
 801daea:	f1c3 021f 	rsb	r2, r3, #31
 801daee:	3d01      	subs	r5, #1
		if (blockIdx & 0x01) {
 801daf0:	2800      	cmp	r0, #0
 801daf2:	d046      	beq.n	801db82 <FreqInvertRescale+0x10a>
		mOut = 0;
 801daf4:	2000      	movs	r0, #0
 801daf6:	f10c 0780 	add.w	r7, ip, #128	@ 0x80
 801dafa:	f50c 6910 	add.w	r9, ip, #2304	@ 0x900
	__asm__ volatile (
 801dafe:	4680      	mov	r8, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801db00:	f857 4c80 	ldr.w	r4, [r7, #-128]
 801db04:	fa44 fe02 	asr.w	lr, r4, r2
 801db08:	ea4f 7ae4 	mov.w	sl, r4, asr #31
 801db0c:	ebbe 7fe4 	cmp.w	lr, r4, asr #31
 801db10:	bf18      	it	ne
 801db12:	ea8a 0405 	eorne.w	r4, sl, r5
 801db16:	409c      	lsls	r4, r3
 801db18:	4646      	mov	r6, r8
 801db1a:	f847 4c80 	str.w	r4, [r7, #-128]
 801db1e:	ea84 76e4 	eor.w	r6, r4, r4, asr #31
 801db22:	eba6 76e4 	sub.w	r6, r6, r4, asr #31
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801db26:	f8dc 4080 	ldr.w	r4, [ip, #128]	@ 0x80
 801db2a:	f1c4 0e00 	rsb	lr, r4, #0
 801db2e:	fa4e f402 	asr.w	r4, lr, r2
 801db32:	ebb4 7fee 	cmp.w	r4, lr, asr #31
 801db36:	ea4f 7bee 	mov.w	fp, lr, asr #31
 801db3a:	bf18      	it	ne
 801db3c:	ea8b 0e05 	eorne.w	lr, fp, r5
 801db40:	fa0e f403 	lsl.w	r4, lr, r3
 801db44:	46c2      	mov	sl, r8
 801db46:	f8cc 4080 	str.w	r4, [ip, #128]	@ 0x80
 801db4a:	ea84 7ae4 	eor.w	sl, r4, r4, asr #31
 801db4e:	ebaa 7ae4 	sub.w	sl, sl, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801db52:	680c      	ldr	r4, [r1, #0]
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801db54:	ea46 060a 	orr.w	r6, r6, sl
 801db58:	4330      	orrs	r0, r6
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801db5a:	fa44 f602 	asr.w	r6, r4, r2
 801db5e:	ebb6 7fe4 	cmp.w	r6, r4, asr #31
 801db62:	ea4f 7ee4 	mov.w	lr, r4, asr #31
 801db66:	bf18      	it	ne
 801db68:	ea8e 0405 	eorne.w	r4, lr, r5
				d = -*y;	CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801db6c:	f50c 7c80 	add.w	ip, ip, #256	@ 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801db70:	409c      	lsls	r4, r3
			for (i = 0; i < 18; i+=2) {
 801db72:	45e1      	cmp	r9, ip
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801db74:	f841 4b04 	str.w	r4, [r1], #4
			for (i = 0; i < 18; i+=2) {
 801db78:	f507 7780 	add.w	r7, r7, #256	@ 0x100
 801db7c:	d1c0      	bne.n	801db00 <FreqInvertRescale+0x88>
}
 801db7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801db82:	f10c 0680 	add.w	r6, ip, #128	@ 0x80
 801db86:	f50c 6e10 	add.w	lr, ip, #2304	@ 0x900
 801db8a:	4607      	mov	r7, r0
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801db8c:	f856 4c80 	ldr.w	r4, [r6, #-128]
 801db90:	fa44 f902 	asr.w	r9, r4, r2
 801db94:	ea4f 7ae4 	mov.w	sl, r4, asr #31
 801db98:	ebb9 7fe4 	cmp.w	r9, r4, asr #31
 801db9c:	bf18      	it	ne
 801db9e:	ea8a 0405 	eorne.w	r4, sl, r5
 801dba2:	409c      	lsls	r4, r3
 801dba4:	46b8      	mov	r8, r7
 801dba6:	f846 4c80 	str.w	r4, [r6, #-128]
 801dbaa:	ea84 78e4 	eor.w	r8, r4, r4, asr #31
 801dbae:	eba8 78e4 	sub.w	r8, r8, r4, asr #31
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801dbb2:	f8dc 4080 	ldr.w	r4, [ip, #128]	@ 0x80
 801dbb6:	fa44 fa02 	asr.w	sl, r4, r2
 801dbba:	ea4f 7be4 	mov.w	fp, r4, asr #31
 801dbbe:	ebba 7fe4 	cmp.w	sl, r4, asr #31
 801dbc2:	bf18      	it	ne
 801dbc4:	ea8b 0405 	eorne.w	r4, fp, r5
 801dbc8:	409c      	lsls	r4, r3
 801dbca:	46b9      	mov	r9, r7
 801dbcc:	f8cc 4080 	str.w	r4, [ip, #128]	@ 0x80
 801dbd0:	ea84 79e4 	eor.w	r9, r4, r4, asr #31
 801dbd4:	eba9 79e4 	sub.w	r9, r9, r4, asr #31
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801dbd8:	680c      	ldr	r4, [r1, #0]
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801dbda:	ea48 0809 	orr.w	r8, r8, r9
 801dbde:	ea40 0008 	orr.w	r0, r0, r8
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801dbe2:	fa44 f802 	asr.w	r8, r4, r2
 801dbe6:	ebb8 7fe4 	cmp.w	r8, r4, asr #31
 801dbea:	ea4f 79e4 	mov.w	r9, r4, asr #31
 801dbee:	bf18      	it	ne
 801dbf0:	ea89 0405 	eorne.w	r4, r9, r5
				d = *y;		CLIP_2N(d, 31 - es);	*y = d << es;	mOut |= FASTABS(*y);	y += NBANDS;
 801dbf4:	f50c 7c80 	add.w	ip, ip, #256	@ 0x100
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801dbf8:	409c      	lsls	r4, r3
			for (i = 0; i < 18; i+=2) {
 801dbfa:	45e6      	cmp	lr, ip
				d = *xPrev;	CLIP_2N(d, 31 - es);	*xPrev++ = d << es;
 801dbfc:	f841 4b04 	str.w	r4, [r1], #4
			for (i = 0; i < 18; i+=2) {
 801dc00:	f506 7680 	add.w	r6, r6, #256	@ 0x100
 801dc04:	d1c2      	bne.n	801db8c <FreqInvertRescale+0x114>
}
 801dc06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801dc0a:	bf00      	nop

0801dc0c <WinPrevious>:
	if (btPrev == 2) {
 801dc0c:	2a02      	cmp	r2, #2
{
 801dc0e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 801dc12:	4b46      	ldr	r3, [pc, #280]	@ (801dd2c <WinPrevious+0x120>)
	if (btPrev == 2) {
 801dc14:	d01e      	beq.n	801dc54 <WinPrevious+0x48>
		wpLo = imdctWin[btPrev] + 18;
 801dc16:	eb02 02c2 	add.w	r2, r2, r2, lsl #3
 801dc1a:	eb03 1c02 	add.w	ip, r3, r2, lsl #4
 801dc1e:	f10c 0648 	add.w	r6, ip, #72	@ 0x48
		xpwHi = xPrevWin + 17;
 801dc22:	f101 0e44 	add.w	lr, r1, #68	@ 0x44
		wpHi = wpLo + 17;
 801dc26:	f10c 0c8c 	add.w	ip, ip, #140	@ 0x8c
		for (i = 9; i > 0; i--) {
 801dc2a:	f100 0724 	add.w	r7, r0, #36	@ 0x24
			x = *xp++;	wLo = *wpLo++;	wHi = *wpHi--;
 801dc2e:	f850 3b04 	ldr.w	r3, [r0], #4
 801dc32:	f85c 4904 	ldr.w	r4, [ip], #-4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801dc36:	f856 5b04 	ldr.w	r5, [r6], #4
 801dc3a:	461a      	mov	r2, r3
 801dc3c:	fb85 8202 	smull	r8, r2, r5, r2
			*xpwLo++ = MULSHIFT32(wLo, x);
 801dc40:	f841 2b04 	str.w	r2, [r1], #4
 801dc44:	fb84 2303 	smull	r2, r3, r4, r3
		for (i = 9; i > 0; i--) {
 801dc48:	4287      	cmp	r7, r0
			*xpwHi-- = MULSHIFT32(wHi, x);
 801dc4a:	f84e 3904 	str.w	r3, [lr], #-4
		for (i = 9; i > 0; i--) {
 801dc4e:	d1ee      	bne.n	801dc2e <WinPrevious+0x22>
}
 801dc50:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801dc54:	6882      	ldr	r2, [r0, #8]
		xPrevWin[ 0] = MULSHIFT32(wpLo[ 6], xPrev[2]) + MULSHIFT32(wpLo[0], xPrev[6]);
 801dc56:	f8d3 c138 	ldr.w	ip, [r3, #312]	@ 0x138
 801dc5a:	fb8c 4202 	smull	r4, r2, ip, r2
 801dc5e:	6984      	ldr	r4, [r0, #24]
 801dc60:	f8d3 5120 	ldr.w	r5, [r3, #288]	@ 0x120
 801dc64:	fb85 6404 	smull	r6, r4, r5, r4
 801dc68:	4422      	add	r2, r4
 801dc6a:	600a      	str	r2, [r1, #0]
		xPrevWin[ 1] = MULSHIFT32(wpLo[ 7], xPrev[1]) + MULSHIFT32(wpLo[1], xPrev[7]);
 801dc6c:	f8d3 713c 	ldr.w	r7, [r3, #316]	@ 0x13c
 801dc70:	6842      	ldr	r2, [r0, #4]
 801dc72:	fb87 4202 	smull	r4, r2, r7, r2
 801dc76:	69c4      	ldr	r4, [r0, #28]
 801dc78:	f8d3 5124 	ldr.w	r5, [r3, #292]	@ 0x124
 801dc7c:	fb85 6404 	smull	r6, r4, r5, r4
 801dc80:	4422      	add	r2, r4
 801dc82:	604a      	str	r2, [r1, #4]
 801dc84:	6802      	ldr	r2, [r0, #0]
		xPrevWin[ 2] = MULSHIFT32(wpLo[ 8], xPrev[0]) + MULSHIFT32(wpLo[2], xPrev[8]);
 801dc86:	f8d3 6140 	ldr.w	r6, [r3, #320]	@ 0x140
 801dc8a:	fb86 4202 	smull	r4, r2, r6, r2
 801dc8e:	6a05      	ldr	r5, [r0, #32]
 801dc90:	f8d3 4128 	ldr.w	r4, [r3, #296]	@ 0x128
 801dc94:	fb84 e505 	smull	lr, r5, r4, r5
 801dc98:	442a      	add	r2, r5
 801dc9a:	608a      	str	r2, [r1, #8]
 801dc9c:	6802      	ldr	r2, [r0, #0]
		xPrevWin[ 3] = MULSHIFT32(wpLo[ 9], xPrev[0]) + MULSHIFT32(wpLo[3], xPrev[8]);
 801dc9e:	f8d3 5144 	ldr.w	r5, [r3, #324]	@ 0x144
 801dca2:	4696      	mov	lr, r2
 801dca4:	fb85 2e0e 	smull	r2, lr, r5, lr
 801dca8:	6a02      	ldr	r2, [r0, #32]
 801dcaa:	f8d3 412c 	ldr.w	r4, [r3, #300]	@ 0x12c
 801dcae:	fb84 8202 	smull	r8, r2, r4, r2
 801dcb2:	4472      	add	r2, lr
 801dcb4:	60ca      	str	r2, [r1, #12]
 801dcb6:	6842      	ldr	r2, [r0, #4]
		xPrevWin[ 4] = MULSHIFT32(wpLo[10], xPrev[1]) + MULSHIFT32(wpLo[4], xPrev[7]);
 801dcb8:	f8d3 e148 	ldr.w	lr, [r3, #328]	@ 0x148
 801dcbc:	4691      	mov	r9, r2
 801dcbe:	fb8e 4909 	smull	r4, r9, lr, r9
 801dcc2:	69c4      	ldr	r4, [r0, #28]
 801dcc4:	f8d3 2130 	ldr.w	r2, [r3, #304]	@ 0x130
 801dcc8:	fb82 8404 	smull	r8, r4, r2, r4
 801dccc:	eb09 0204 	add.w	r2, r9, r4
 801dcd0:	610a      	str	r2, [r1, #16]
 801dcd2:	6882      	ldr	r2, [r0, #8]
		xPrevWin[ 5] = MULSHIFT32(wpLo[11], xPrev[2]) + MULSHIFT32(wpLo[5], xPrev[6]);
 801dcd4:	f8d3 814c 	ldr.w	r8, [r3, #332]	@ 0x14c
 801dcd8:	fb88 4202 	smull	r4, r2, r8, r2
 801dcdc:	f8d3 4134 	ldr.w	r4, [r3, #308]	@ 0x134
 801dce0:	6983      	ldr	r3, [r0, #24]
 801dce2:	fb84 9303 	smull	r9, r3, r4, r3
 801dce6:	441a      	add	r2, r3
 801dce8:	614a      	str	r2, [r1, #20]
 801dcea:	6943      	ldr	r3, [r0, #20]
 801dcec:	fb8c 2303 	smull	r2, r3, ip, r3
		xPrevWin[ 6] = MULSHIFT32(wpLo[ 6], xPrev[5]);
 801dcf0:	618b      	str	r3, [r1, #24]
 801dcf2:	6903      	ldr	r3, [r0, #16]
 801dcf4:	fb87 2303 	smull	r2, r3, r7, r3
		xPrevWin[ 7] = MULSHIFT32(wpLo[ 7], xPrev[4]);
 801dcf8:	61cb      	str	r3, [r1, #28]
 801dcfa:	68c3      	ldr	r3, [r0, #12]
 801dcfc:	fb86 2303 	smull	r2, r3, r6, r3
		xPrevWin[ 8] = MULSHIFT32(wpLo[ 8], xPrev[3]);
 801dd00:	620b      	str	r3, [r1, #32]
 801dd02:	68c3      	ldr	r3, [r0, #12]
 801dd04:	fb85 2303 	smull	r2, r3, r5, r3
		xPrevWin[ 9] = MULSHIFT32(wpLo[ 9], xPrev[3]);
 801dd08:	624b      	str	r3, [r1, #36]	@ 0x24
 801dd0a:	6903      	ldr	r3, [r0, #16]
 801dd0c:	fb8e 2303 	smull	r2, r3, lr, r3
		xPrevWin[10] = MULSHIFT32(wpLo[10], xPrev[4]);
 801dd10:	628b      	str	r3, [r1, #40]	@ 0x28
 801dd12:	6942      	ldr	r2, [r0, #20]
 801dd14:	fb88 3202 	smull	r3, r2, r8, r2
		xPrevWin[12] = xPrevWin[13] = xPrevWin[14] = xPrevWin[15] = xPrevWin[16] = xPrevWin[17] = 0;
 801dd18:	2300      	movs	r3, #0
 801dd1a:	e9c1 3310 	strd	r3, r3, [r1, #64]	@ 0x40
 801dd1e:	e9c1 330e 	strd	r3, r3, [r1, #56]	@ 0x38
 801dd22:	e9c1 330c 	strd	r3, r3, [r1, #48]	@ 0x30
		xPrevWin[11] = MULSHIFT32(wpLo[11], xPrev[5]);
 801dd26:	62ca      	str	r2, [r1, #44]	@ 0x2c
}
 801dd28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801dd2c:	08038684 	.word	0x08038684

0801dd30 <xmp3_IMDCT>:
 *
 * Return:      0 on success,  -1 if null input pointers
 **************************************************************************************/
 // a bit faster in RAM
/*__attribute__ ((section (".data")))*/ int IMDCT(MP3DecInfo *mp3DecInfo, int gr, int ch)
{
 801dd30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801dd34:	b0c5      	sub	sp, #276	@ 0x114
 801dd36:	911a      	str	r1, [sp, #104]	@ 0x68
 801dd38:	9217      	str	r2, [sp, #92]	@ 0x5c
	HuffmanInfo *hi;
	IMDCTInfo *mi;
	BlockCount bc;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 801dd3a:	2800      	cmp	r0, #0
 801dd3c:	f000 8679 	beq.w	801ea32 <xmp3_IMDCT+0xd02>
 801dd40:	6803      	ldr	r3, [r0, #0]
 801dd42:	2b00      	cmp	r3, #0
 801dd44:	f000 8675 	beq.w	801ea32 <xmp3_IMDCT+0xd02>
 801dd48:	6844      	ldr	r4, [r0, #4]
 801dd4a:	9419      	str	r4, [sp, #100]	@ 0x64
 801dd4c:	2c00      	cmp	r4, #0
 801dd4e:	f000 8670 	beq.w	801ea32 <xmp3_IMDCT+0xd02>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 801dd52:	f8d0 a00c 	ldr.w	sl, [r0, #12]
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || 
 801dd56:	f1ba 0f00 	cmp.w	sl, #0
 801dd5a:	f000 866a 	beq.w	801ea32 <xmp3_IMDCT+0xd02>
		!mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS)
 801dd5e:	6940      	ldr	r0, [r0, #20]
 801dd60:	900e      	str	r0, [sp, #56]	@ 0x38
 801dd62:	2800      	cmp	r0, #0
 801dd64:	f000 8665 	beq.w	801ea32 <xmp3_IMDCT+0xd02>
	/* anti-aliasing done on whole long blocks only
	 * for mixed blocks, nBfly always 1, except 3 for 8 kHz MPEG 2.5 (see sfBandTab) 
     *   nLongBlocks = number of blocks with (possibly) non-zero power 
	 *   nBfly = number of butterflies to do (nLongBlocks - 1, unless no long blocks)
	 */
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 801dd68:	4616      	mov	r6, r2
 801dd6a:	781a      	ldrb	r2, [r3, #0]
 801dd6c:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801dd6e:	2a00      	cmp	r2, #0
 801dd70:	bf14      	ite	ne
 801dd72:	2206      	movne	r2, #6
 801dd74:	2208      	moveq	r2, #8
 801dd76:	460f      	mov	r7, r1
	if (si->sis[gr][ch].blockType != 2) {
 801dd78:	eb01 01c1 	add.w	r1, r1, r1, lsl #3
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 801dd7c:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
 801dd80:	4ac5      	ldr	r2, [pc, #788]	@ (801e098 <xmp3_IMDCT+0x368>)
 801dd82:	eb06 00c6 	add.w	r0, r6, r6, lsl #3
	if (si->sis[gr][ch].blockType != 2) {
 801dd86:	0109      	lsls	r1, r1, #4
 801dd88:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 801dd8c:	4421      	add	r1, r4
	blockCutoff = fh->sfBand->l[(fh->ver == MPEG1 ? 8 : 6)] / 18;	/* same as 3* num short sfb's in spec */
 801dd8e:	17dc      	asrs	r4, r3, #31
 801dd90:	fb82 5303 	smull	r5, r3, r2, r3
 801dd94:	ebc4 03a3 	rsb	r3, r4, r3, asr #2
 801dd98:	b21b      	sxth	r3, r3
 801dd9a:	00f5      	lsls	r5, r6, #3
 801dd9c:	9314      	str	r3, [sp, #80]	@ 0x50
	if (si->sis[gr][ch].blockType != 2) {
 801dd9e:	6bcb      	ldr	r3, [r1, #60]	@ 0x3c
 801dda0:	9518      	str	r5, [sp, #96]	@ 0x60
 801dda2:	0205      	lsls	r5, r0, #8
		/* all short transforms */
		bc.nBlocksLong = 0;
		nBfly = 0;
	}
 
	AntiAlias(hi->huffDecBuf[ch], nBfly);
 801dda4:	eb0a 2000 	add.w	r0, sl, r0, lsl #8
 801dda8:	9015      	str	r0, [sp, #84]	@ 0x54
	if (si->sis[gr][ch].blockType != 2) {
 801ddaa:	2b02      	cmp	r3, #2
 801ddac:	ea4f 00c7 	mov.w	r0, r7, lsl #3
 801ddb0:	950f      	str	r5, [sp, #60]	@ 0x3c
 801ddb2:	901b      	str	r0, [sp, #108]	@ 0x6c
 801ddb4:	f000 8602 	beq.w	801e9bc <xmp3_IMDCT+0xc8c>
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 801ddb8:	f506 6390 	add.w	r3, r6, #1152	@ 0x480
 801ddbc:	f240 2126 	movw	r1, #550	@ 0x226
 801ddc0:	f85a 3023 	ldr.w	r3, [sl, r3, lsl #2]
 801ddc4:	428b      	cmp	r3, r1
 801ddc6:	f340 82e1 	ble.w	801e38c <xmp3_IMDCT+0x65c>
 801ddca:	2320      	movs	r3, #32
 801ddcc:	f240 2936 	movw	r9, #566	@ 0x236
 801ddd0:	9304      	str	r3, [sp, #16]
		nBfly = bc.nBlocksLong - 1;
 801ddd2:	f04f 0c1f 	mov.w	ip, #31
		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 801ddd6:	4ab1      	ldr	r2, [pc, #708]	@ (801e09c <xmp3_IMDCT+0x36c>)
 801ddd8:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 801ddda:	6811      	ldr	r1, [r2, #0]
 801dddc:	9101      	str	r1, [sp, #4]
 801ddde:	6851      	ldr	r1, [r2, #4]
 801dde0:	9102      	str	r1, [sp, #8]
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 801dde2:	6891      	ldr	r1, [r2, #8]
 801dde4:	9103      	str	r1, [sp, #12]
 801dde6:	68d1      	ldr	r1, [r2, #12]
 801dde8:	9105      	str	r1, [sp, #20]
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 801ddea:	6911      	ldr	r1, [r2, #16]
 801ddec:	9106      	str	r1, [sp, #24]
 801ddee:	6951      	ldr	r1, [r2, #20]
 801ddf0:	9107      	str	r1, [sp, #28]
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 801ddf2:	e9d2 e707 	ldrd	lr, r7, [r2, #28]
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 801ddf6:	6991      	ldr	r1, [r2, #24]
 801ddf8:	9108      	str	r1, [sp, #32]
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801ddfa:	e9d2 800d 	ldrd	r8, r0, [r2, #52]	@ 0x34
 801ddfe:	6bd1      	ldr	r1, [r2, #60]	@ 0x3c
 801de00:	f8cd a034 	str.w	sl, [sp, #52]	@ 0x34
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 801de04:	e9d2 6509 	ldrd	r6, r5, [r2, #36]	@ 0x24
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 801de08:	e9d2 4b0b 	ldrd	r4, fp, [r2, #44]	@ 0x2c
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801de0c:	e9cd e709 	strd	lr, r7, [sp, #36]	@ 0x24
 801de10:	e9cd 010b 	strd	r0, r1, [sp, #44]	@ 0x2c
 801de14:	f8cd 9040 	str.w	r9, [sp, #64]	@ 0x40
		a0 = x[-1];			c0 = *c;	c++;	b0 = x[0];		c1 = *c;	c++;
 801de18:	e9d3 e211 	ldrd	lr, r2, [r3, #68]	@ 0x44
 801de1c:	9901      	ldr	r1, [sp, #4]
 801de1e:	4677      	mov	r7, lr
 801de20:	fb81 9707 	smull	r9, r7, r1, r7
 801de24:	9802      	ldr	r0, [sp, #8]
 801de26:	4691      	mov	r9, r2
 801de28:	fb80 a909 	smull	sl, r9, r0, r9
		x[-1] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801de2c:	eba7 0709 	sub.w	r7, r7, r9
 801de30:	007f      	lsls	r7, r7, #1
 801de32:	9901      	ldr	r1, [sp, #4]
 801de34:	645f      	str	r7, [r3, #68]	@ 0x44
 801de36:	fb81 7202 	smull	r7, r2, r1, r2
 801de3a:	fb80 7e0e 	smull	r7, lr, r0, lr
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801de3e:	4472      	add	r2, lr
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 801de40:	f8d3 e040 	ldr.w	lr, [r3, #64]	@ 0x40
 801de44:	9903      	ldr	r1, [sp, #12]
		x[0] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801de46:	0052      	lsls	r2, r2, #1
 801de48:	649a      	str	r2, [r3, #72]	@ 0x48
 801de4a:	4677      	mov	r7, lr
		a0 = x[-2];			c0 = *c;	c++;	b0 = x[1];		c1 = *c;	c++;
 801de4c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 801de4e:	fb81 9707 	smull	r9, r7, r1, r7
 801de52:	9805      	ldr	r0, [sp, #20]
 801de54:	4691      	mov	r9, r2
 801de56:	fb80 a909 	smull	sl, r9, r0, r9
		x[-2] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801de5a:	eba7 0709 	sub.w	r7, r7, r9
 801de5e:	007f      	lsls	r7, r7, #1
 801de60:	641f      	str	r7, [r3, #64]	@ 0x40
 801de62:	fb81 7202 	smull	r7, r2, r1, r2
 801de66:	fb80 7e0e 	smull	r7, lr, r0, lr
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801de6a:	4472      	add	r2, lr
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 801de6c:	f8d3 e03c 	ldr.w	lr, [r3, #60]	@ 0x3c
 801de70:	9906      	ldr	r1, [sp, #24]
		x[1] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801de72:	0052      	lsls	r2, r2, #1
 801de74:	64da      	str	r2, [r3, #76]	@ 0x4c
 801de76:	4677      	mov	r7, lr
		a0 = x[-3];			c0 = *c;	c++;	b0 = x[2];		c1 = *c;	c++;
 801de78:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 801de7a:	fb81 9707 	smull	r9, r7, r1, r7
 801de7e:	9807      	ldr	r0, [sp, #28]
 801de80:	4691      	mov	r9, r2
 801de82:	fb80 a909 	smull	sl, r9, r0, r9
		x[-3] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801de86:	eba7 0709 	sub.w	r7, r7, r9
 801de8a:	007f      	lsls	r7, r7, #1
 801de8c:	63df      	str	r7, [r3, #60]	@ 0x3c
 801de8e:	fb81 7202 	smull	r7, r2, r1, r2
 801de92:	fb80 7e0e 	smull	r7, lr, r0, lr
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801de96:	4472      	add	r2, lr
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 801de98:	f8d3 e038 	ldr.w	lr, [r3, #56]	@ 0x38
 801de9c:	9908      	ldr	r1, [sp, #32]
		x[2] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801de9e:	0052      	lsls	r2, r2, #1
 801dea0:	651a      	str	r2, [r3, #80]	@ 0x50
 801dea2:	4677      	mov	r7, lr
		a0 = x[-4];			c0 = *c;	c++;	b0 = x[3];		c1 = *c;	c++;
 801dea4:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 801dea6:	fb81 9707 	smull	r9, r7, r1, r7
 801deaa:	9809      	ldr	r0, [sp, #36]	@ 0x24
 801deac:	4691      	mov	r9, r2
 801deae:	fb80 a909 	smull	sl, r9, r0, r9
		x[-4] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801deb2:	eba7 0709 	sub.w	r7, r7, r9
 801deb6:	007f      	lsls	r7, r7, #1
 801deb8:	639f      	str	r7, [r3, #56]	@ 0x38
 801deba:	fb81 7202 	smull	r7, r2, r1, r2
 801debe:	fb80 7e0e 	smull	r7, lr, r0, lr
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801dec2:	4472      	add	r2, lr
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 801dec4:	f8d3 e034 	ldr.w	lr, [r3, #52]	@ 0x34
 801dec8:	990a      	ldr	r1, [sp, #40]	@ 0x28
		x[3] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801deca:	0052      	lsls	r2, r2, #1
 801decc:	655a      	str	r2, [r3, #84]	@ 0x54
 801dece:	4677      	mov	r7, lr
		a0 = x[-5];			c0 = *c;	c++;	b0 = x[4];		c1 = *c;	c++;
 801ded0:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 801ded2:	fb81 9707 	smull	r9, r7, r1, r7
 801ded6:	4691      	mov	r9, r2
 801ded8:	fb86 a909 	smull	sl, r9, r6, r9
		x[-5] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801dedc:	eba7 0709 	sub.w	r7, r7, r9
 801dee0:	007f      	lsls	r7, r7, #1
 801dee2:	635f      	str	r7, [r3, #52]	@ 0x34
 801dee4:	fb81 7202 	smull	r7, r2, r1, r2
 801dee8:	fb86 7e0e 	smull	r7, lr, r6, lr
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801deec:	4472      	add	r2, lr
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 801deee:	f8d3 e030 	ldr.w	lr, [r3, #48]	@ 0x30
		x[4] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801def2:	0052      	lsls	r2, r2, #1
 801def4:	659a      	str	r2, [r3, #88]	@ 0x58
 801def6:	4677      	mov	r7, lr
		a0 = x[-6];			c0 = *c;	c++;	b0 = x[5];		c1 = *c;	c++;
 801def8:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 801defa:	fb85 9707 	smull	r9, r7, r5, r7
 801defe:	4691      	mov	r9, r2
 801df00:	fb84 a909 	smull	sl, r9, r4, r9
		x[-6] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801df04:	eba7 0709 	sub.w	r7, r7, r9
 801df08:	007f      	lsls	r7, r7, #1
 801df0a:	631f      	str	r7, [r3, #48]	@ 0x30
 801df0c:	fb85 7202 	smull	r7, r2, r5, r2
 801df10:	fb84 7e0e 	smull	r7, lr, r4, lr
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801df14:	4472      	add	r2, lr
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 801df16:	f8d3 e02c 	ldr.w	lr, [r3, #44]	@ 0x2c
		x[5] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801df1a:	0052      	lsls	r2, r2, #1
 801df1c:	65da      	str	r2, [r3, #92]	@ 0x5c
 801df1e:	4677      	mov	r7, lr
		a0 = x[-7];			c0 = *c;	c++;	b0 = x[6];		c1 = *c;	c++;
 801df20:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 801df22:	fb8b 9707 	smull	r9, r7, fp, r7
 801df26:	4691      	mov	r9, r2
 801df28:	fb88 a909 	smull	sl, r9, r8, r9
		x[-7] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801df2c:	eba7 0709 	sub.w	r7, r7, r9
 801df30:	007f      	lsls	r7, r7, #1
 801df32:	62df      	str	r7, [r3, #44]	@ 0x2c
 801df34:	fb8b 7202 	smull	r7, r2, fp, r2
 801df38:	fb88 7e0e 	smull	r7, lr, r8, lr
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801df3c:	4472      	add	r2, lr
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801df3e:	f8d3 e028 	ldr.w	lr, [r3, #40]	@ 0x28
 801df42:	980b      	ldr	r0, [sp, #44]	@ 0x2c
		x[6] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801df44:	0052      	lsls	r2, r2, #1
 801df46:	661a      	str	r2, [r3, #96]	@ 0x60
 801df48:	4677      	mov	r7, lr
		a0 = x[-8];			c0 = *c;	c++;	b0 = x[7];		c1 = *c;	c++;
 801df4a:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 801df4c:	fb80 9707 	smull	r9, r7, r0, r7
 801df50:	990c      	ldr	r1, [sp, #48]	@ 0x30
 801df52:	4691      	mov	r9, r2
 801df54:	fb81 a909 	smull	sl, r9, r1, r9
		x[-8] = (MULSHIFT32(c0, a0) - MULSHIFT32(c1, b0)) << 1;	
 801df58:	eba7 0709 	sub.w	r7, r7, r9
 801df5c:	007f      	lsls	r7, r7, #1
 801df5e:	629f      	str	r7, [r3, #40]	@ 0x28
 801df60:	fb80 7202 	smull	r7, r2, r0, r2
 801df64:	fb81 7e0e 	smull	r7, lr, r1, lr
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801df68:	4472      	add	r2, lr
 801df6a:	0052      	lsls	r2, r2, #1
	for (k = nBfly; k > 0; k--) {
 801df6c:	f1bc 0c01 	subs.w	ip, ip, #1
		x[7] =  (MULSHIFT32(c0, b0) + MULSHIFT32(c1, a0)) << 1;
 801df70:	665a      	str	r2, [r3, #100]	@ 0x64
	for (k = nBfly; k > 0; k--) {
 801df72:	f103 0348 	add.w	r3, r3, #72	@ 0x48
 801df76:	f47f af4f 	bne.w	801de18 <xmp3_IMDCT+0xe8>
	/* for readability, use a struct instead of passing a million parameters to HybridTransform() */
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
	bc.prevType = mi->prevType[ch];
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 801df7a:	f8dd a034 	ldr.w	sl, [sp, #52]	@ 0x34
 801df7e:	f8dd 9040 	ldr.w	r9, [sp, #64]	@ 0x40
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801df82:	980e      	ldr	r0, [sp, #56]	@ 0x38
	} else if (si->sis[gr][ch].blockType == 2 && si->sis[gr][ch].mixedBlock) {
 801df84:	e9dd 231a 	ldrd	r2, r3, [sp, #104]	@ 0x68
 801df88:	4413      	add	r3, r2
 801df8a:	e9dd 1217 	ldrd	r1, r2, [sp, #92]	@ 0x5c
 801df8e:	011b      	lsls	r3, r3, #4
 801df90:	440a      	add	r2, r1
 801df92:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801df96:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 801df98:	4413      	add	r3, r2
 801df9a:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 801df9c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801df9e:	eb0a 0182 	add.w	r1, sl, r2, lsl #2
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801dfa2:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
 801dfa6:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 801dfaa:	f8d1 2200 	ldr.w	r2, [r1, #512]	@ 0x200
 801dfae:	454a      	cmp	r2, r9
 801dfb0:	bfb8      	it	lt
 801dfb2:	464a      	movlt	r2, r9
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 801dfb4:	2b00      	cmp	r3, #0
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 801dfb6:	f500 5880 	add.w	r8, r0, #4096	@ 0x1000
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 801dfba:	9814      	ldr	r0, [sp, #80]	@ 0x50
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801dfbc:	f8c1 2200 	str.w	r2, [r1, #512]	@ 0x200
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 801dfc0:	bf08      	it	eq
 801dfc2:	2000      	moveq	r0, #0
 801dfc4:	9014      	str	r0, [sp, #80]	@ 0x50
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 801dfc6:	4834      	ldr	r0, [pc, #208]	@ (801e098 <xmp3_IMDCT+0x368>)
 801dfc8:	3211      	adds	r2, #17
 801dfca:	fb80 0402 	smull	r0, r4, r0, r2
 801dfce:	17d2      	asrs	r2, r2, #31
 801dfd0:	ebc2 0ba4 	rsb	fp, r2, r4, asr #2
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 801dfd4:	f8d8 2b00 	ldr.w	r2, [r8, #2816]	@ 0xb00
 801dfd8:	9212      	str	r2, [sp, #72]	@ 0x48
	bc.prevType = mi->prevType[ch];
 801dfda:	f8d8 2b08 	ldr.w	r2, [r8, #2824]	@ 0xb08
 801dfde:	920c      	str	r2, [sp, #48]	@ 0x30
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 801dfe0:	f8d8 2b10 	ldr.w	r2, [r8, #2832]	@ 0xb10
 801dfe4:	9209      	str	r2, [sp, #36]	@ 0x24
	bc.gbIn = hi->gb[ch];

	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801dfe6:	e9dd 420e 	ldrd	r4, r2, [sp, #56]	@ 0x38
 801dfea:	4422      	add	r2, r4
	bc.gbIn = hi->gb[ch];
 801dfec:	f8d1 0208 	ldr.w	r0, [r1, #520]	@ 0x208
 801dff0:	900d      	str	r0, [sp, #52]	@ 0x34
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801dff2:	4691      	mov	r9, r2
 801dff4:	e9dd 1217 	ldrd	r1, r2, [sp, #92]	@ 0x5c
 801dff8:	1851      	adds	r1, r2, r1
 801dffa:	eb04 12c1 	add.w	r2, r4, r1, lsl #7
 801dffe:	f502 5a90 	add.w	sl, r2, #4608	@ 0x1200
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e002:	9a04      	ldr	r2, [sp, #16]
 801e004:	2a00      	cmp	r2, #0
 801e006:	f340 850d 	ble.w	801ea24 <xmp3_IMDCT+0xcf4>
		currWinIdx = sis->blockType;
 801e00a:	e9dd 421a 	ldrd	r4, r2, [sp, #104]	@ 0x68
 801e00e:	4422      	add	r2, r4
 801e010:	0112      	lsls	r2, r2, #4
 801e012:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801e016:	9919      	ldr	r1, [sp, #100]	@ 0x64
 801e018:	f8cd 900c 	str.w	r9, [sp, #12]
 801e01c:	188a      	adds	r2, r1, r2
 801e01e:	2806      	cmp	r0, #6
	mOut = 0;
 801e020:	f04f 0100 	mov.w	r1, #0
		currWinIdx = sis->blockType;
 801e024:	9210      	str	r2, [sp, #64]	@ 0x40
		es = 7 - gb;
 801e026:	f1c0 0207 	rsb	r2, r0, #7
 801e02a:	9216      	str	r2, [sp, #88]	@ 0x58
 801e02c:	bfc8      	it	gt
 801e02e:	460a      	movgt	r2, r1
 801e030:	9213      	str	r2, [sp, #76]	@ 0x4c
 801e032:	f10a 0224 	add.w	r2, sl, #36	@ 0x24
 801e036:	9207      	str	r2, [sp, #28]
 801e038:	e9cd 9a1c 	strd	r9, sl, [sp, #112]	@ 0x70
 801e03c:	9a15      	ldr	r2, [sp, #84]	@ 0x54
	mOut = 0;
 801e03e:	9105      	str	r1, [sp, #20]
 801e040:	e9cd b81e 	strd	fp, r8, [sp, #120]	@ 0x78
 801e044:	f1a2 050c 	sub.w	r5, r2, #12
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e048:	9106      	str	r1, [sp, #24]
		currWinIdx = sis->blockType;
 801e04a:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 801e04c:	9907      	ldr	r1, [sp, #28]
 801e04e:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 801e050:	9202      	str	r2, [sp, #8]
 801e052:	3924      	subs	r1, #36	@ 0x24
 801e054:	9108      	str	r1, [sp, #32]
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 801e056:	b12b      	cbz	r3, 801e064 <xmp3_IMDCT+0x334>
			currWinIdx = 0;
 801e058:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 801e05a:	9906      	ldr	r1, [sp, #24]
 801e05c:	428b      	cmp	r3, r1
 801e05e:	bfc8      	it	gt
 801e060:	2200      	movgt	r2, #0
 801e062:	9202      	str	r2, [sp, #8]
		if (i < bc->prevWinSwitch)
 801e064:	9b06      	ldr	r3, [sp, #24]
 801e066:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801e068:	4293      	cmp	r3, r2
 801e06a:	f2c0 821a 	blt.w	801e4a2 <xmp3_IMDCT+0x772>
 801e06e:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 801e070:	9a02      	ldr	r2, [sp, #8]
 801e072:	9311      	str	r3, [sp, #68]	@ 0x44
 801e074:	431a      	orrs	r2, r3
 801e076:	9201      	str	r2, [sp, #4]
	if (gb < 7) {
 801e078:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 801e07a:	2b06      	cmp	r3, #6
 801e07c:	f105 0348 	add.w	r3, r5, #72	@ 0x48
 801e080:	930f      	str	r3, [sp, #60]	@ 0x3c
	acc1 = acc2 = 0;
 801e082:	f04f 0000 	mov.w	r0, #0
 801e086:	4619      	mov	r1, r3
	if (gb < 7) {
 801e088:	f300 81fc 	bgt.w	801e484 <xmp3_IMDCT+0x754>
 801e08c:	9c07      	ldr	r4, [sp, #28]
	acc1 = acc2 = 0;
 801e08e:	9f16      	ldr	r7, [sp, #88]	@ 0x58
 801e090:	ae29      	add	r6, sp, #164	@ 0xa4
 801e092:	4603      	mov	r3, r0
 801e094:	e004      	b.n	801e0a0 <xmp3_IMDCT+0x370>
 801e096:	bf00      	nop
 801e098:	38e38e39 	.word	0x38e38e39
 801e09c:	080384fc 	.word	0x080384fc
			acc1 = ((*xCurr--) >> es) - acc1;
 801e0a0:	688a      	ldr	r2, [r1, #8]
 801e0a2:	413a      	asrs	r2, r7
 801e0a4:	1ad3      	subs	r3, r2, r3
			acc1 = ((*xCurr--) >> es) - acc1;
 801e0a6:	684a      	ldr	r2, [r1, #4]
 801e0a8:	413a      	asrs	r2, r7
			acc2 = acc1 - acc2;
 801e0aa:	1a18      	subs	r0, r3, r0
			acc1 = ((*xCurr--) >> es) - acc1;
 801e0ac:	1ad3      	subs	r3, r2, r3
			xPrev[i] >>= es;
 801e0ae:	f854 2d04 	ldr.w	r2, [r4, #-4]!
			xBuf[i+9] = acc2;	/* odd */
 801e0b2:	6230      	str	r0, [r6, #32]
		for (i = 8; i >= 0; i--) {	
 801e0b4:	3908      	subs	r1, #8
			xPrev[i] >>= es;
 801e0b6:	413a      	asrs	r2, r7
		for (i = 8; i >= 0; i--) {	
 801e0b8:	428d      	cmp	r5, r1
			xBuf[i+0] = acc1;	/* even */
 801e0ba:	f846 3d04 	str.w	r3, [r6, #-4]!
			xPrev[i] >>= es;
 801e0be:	6022      	str	r2, [r4, #0]
		for (i = 8; i >= 0; i--) {	
 801e0c0:	d1ee      	bne.n	801e0a0 <xmp3_IMDCT+0x370>
 801e0c2:	9923      	ldr	r1, [sp, #140]	@ 0x8c
	xBuf[9] >>= 1;
 801e0c4:	9a29      	ldr	r2, [sp, #164]	@ 0xa4
	xBuf[0] >>= 1;
 801e0c6:	9f20      	ldr	r7, [sp, #128]	@ 0x80
	x0 = x[0]; x1 = x[1]; x2 = x[2]; x3 = x[3]; x4 = x[4];
 801e0c8:	9b22      	ldr	r3, [sp, #136]	@ 0x88
 801e0ca:	f8dd 8090 	ldr.w	r8, [sp, #144]	@ 0x90
	a1 = x0 - x6;
 801e0ce:	9826      	ldr	r0, [sp, #152]	@ 0x98
	x5 = x[5]; x6 = x[6]; x7 = x[7]; x8 = x[8];
 801e0d0:	9d28      	ldr	r5, [sp, #160]	@ 0xa0
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801e0d2:	9e25      	ldr	r6, [sp, #148]	@ 0x94
	x0 = x[0]; x1 = x[1]; x2 = x[2]; x3 = x[3]; x4 = x[4];
 801e0d4:	9c21      	ldr	r4, [sp, #132]	@ 0x84
	xBuf[9] >>= 1;
 801e0d6:	1052      	asrs	r2, r2, #1
 801e0d8:	468c      	mov	ip, r1
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801e0da:	9927      	ldr	r1, [sp, #156]	@ 0x9c
	xBuf[9] >>= 1;
 801e0dc:	920a      	str	r2, [sp, #40]	@ 0x28
	a4 = x2 - x4;
 801e0de:	eba3 0e08 	sub.w	lr, r3, r8
	a1 = x0 - x6;
 801e0e2:	ebc0 0267 	rsb	r2, r0, r7, asr #1
	xBuf[0] >>= 1;
 801e0e6:	ea4f 0b67 	mov.w	fp, r7, asr #1
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 801e0ea:	ebae 0e05 	sub.w	lr, lr, r5
 801e0ee:	4fb1      	ldr	r7, [pc, #708]	@ (801e3b4 <xmp3_IMDCT+0x684>)
	a1 = x0 - x6;
 801e0f0:	920b      	str	r2, [sp, #44]	@ 0x2c
	a5 = x2 + x4;
 801e0f2:	eb03 0008 	add.w	r0, r3, r8
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801e0f6:	1a71      	subs	r1, r6, r1
 801e0f8:	fb87 6c0c 	smull	r6, ip, r7, ip
	a2 = x1 - x5;
 801e0fc:	9e25      	ldr	r6, [sp, #148]	@ 0x94
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 801e0fe:	9a27      	ldr	r2, [sp, #156]	@ 0x9c
	a2 = x1 - x5;
 801e100:	1ba6      	subs	r6, r4, r6
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 801e102:	1ab6      	subs	r6, r6, r2
 801e104:	fb87 9606 	smull	r9, r6, r7, r6
 801e108:	4fab      	ldr	r7, [pc, #684]	@ (801e3b8 <xmp3_IMDCT+0x688>)
 801e10a:	4681      	mov	r9, r0
 801e10c:	fb87 a909 	smull	sl, r9, r7, r9
 801e110:	4aaa      	ldr	r2, [pc, #680]	@ (801e3bc <xmp3_IMDCT+0x68c>)
	a6 = x2 + x8;
 801e112:	442b      	add	r3, r5
 801e114:	fb82 a303 	smull	sl, r3, r2, r3
 801e118:	930e      	str	r3, [sp, #56]	@ 0x38
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 801e11a:	eba5 0508 	sub.w	r5, r5, r8
 801e11e:	fb87 8505 	smull	r8, r5, r7, r5
 801e122:	fb82 8000 	smull	r8, r0, r2, r0
 801e126:	f1a7 677c 	sub.w	r7, r7, #264241152	@ 0xfc00000
 801e12a:	f5a7 27dc 	sub.w	r7, r7, #450560	@ 0x6e000
 801e12e:	4688      	mov	r8, r1
 801e130:	f5a7 77a1 	sub.w	r7, r7, #322	@ 0x142
 801e134:	fb87 a808 	smull	sl, r8, r7, r8
	a7 = x1 + x7;
 801e138:	9a27      	ldr	r2, [sp, #156]	@ 0x9c
 801e13a:	4ba1      	ldr	r3, [pc, #644]	@ (801e3c0 <xmp3_IMDCT+0x690>)
 801e13c:	4422      	add	r2, r4
 801e13e:	fb83 a202 	smull	sl, r2, r3, r2
	a3 = x1 + x5;
 801e142:	9b25      	ldr	r3, [sp, #148]	@ 0x94
 801e144:	441c      	add	r4, r3
 801e146:	fb87 a404 	smull	sl, r4, r7, r4
 801e14a:	4b9d      	ldr	r3, [pc, #628]	@ (801e3c0 <xmp3_IMDCT+0x690>)
 801e14c:	fb83 a101 	smull	sl, r1, r3, r1
	a12 = x[0] +  (x[6] >> 1);
 801e150:	9b26      	ldr	r3, [sp, #152]	@ 0x98
 801e152:	eb0b 0a63 	add.w	sl, fp, r3, asr #1
	a16 = ( m5 << 1) + (m6 << 1);
 801e156:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
	x0 = x[0]; x1 = x[1]; x2 = x[2]; x3 = x[3]; x4 = x[4];
 801e158:	f8dd b0ac 	ldr.w	fp, [sp, #172]	@ 0xac
	a20 = (m11 << 1) - (m12 << 1);
 801e15c:	0049      	lsls	r1, r1, #1
 801e15e:	ebc1 0144 	rsb	r1, r1, r4, lsl #1
	a16 = ( m5 << 1) + (m6 << 1);
 801e162:	005b      	lsls	r3, r3, #1
	a15 = a1   +  ( a11 >> 1);
 801e164:	9c0b      	ldr	r4, [sp, #44]	@ 0x2c
	a17 = ( m7 << 1) - (m8 << 1);
 801e166:	0040      	lsls	r0, r0, #1
 801e168:	ebc0 0045 	rsb	r0, r0, r5, lsl #1
	a16 = ( m5 << 1) + (m6 << 1);
 801e16c:	eb03 0349 	add.w	r3, r3, r9, lsl #1
	a13 = a12  +  (  m1 << 1);
 801e170:	eb0a 054c 	add.w	r5, sl, ip, lsl #1
	a19 = ( m9 << 1) + (m10 << 1);
 801e174:	0052      	lsls	r2, r2, #1
	a14 = a12  -  (  m1 << 1);
 801e176:	ebaa 0a4c 	sub.w	sl, sl, ip, lsl #1
	a19 = ( m9 << 1) + (m10 << 1);
 801e17a:	eb02 0248 	add.w	r2, r2, r8, lsl #1
	a18 = a16 + a17;
 801e17e:	eb03 0c00 	add.w	ip, r3, r0
	a15 = a1   +  ( a11 >> 1);
 801e182:	eb04 086e 	add.w	r8, r4, lr, asr #1
	x4 = a1 - a11;			x[4] = x4;
 801e186:	eba4 070e 	sub.w	r7, r4, lr
	a22 = a13 + a16;
 801e18a:	eb05 0e03 	add.w	lr, r5, r3
	a23 = a14 + a16;
 801e18e:	4453      	add	r3, sl
	x8 = a23 - a19;			x[8] = x8;
 801e190:	1a9b      	subs	r3, r3, r2
 801e192:	9328      	str	r3, [sp, #160]	@ 0xa0
	a24 = a14 + a17;
 801e194:	eb0a 0300 	add.w	r3, sl, r0
	a26 = a14 - a18;
 801e198:	ebaa 0a0c 	sub.w	sl, sl, ip
	a27 = a13 - a18;
 801e19c:	eba5 0c0c 	sub.w	ip, r5, ip
	a25 = a13 + a17;
 801e1a0:	4405      	add	r5, r0
	a21 = a20 - a19;
 801e1a2:	eba1 0902 	sub.w	r9, r1, r2
	x2 = a24 + a20;			x[2] = x2;
 801e1a6:	440b      	add	r3, r1
	x6 = a25 - a20;			x[6] = x6;
 801e1a8:	1a6d      	subs	r5, r5, r1
	x2 = a24 + a20;			x[2] = x2;
 801e1aa:	9322      	str	r3, [sp, #136]	@ 0x88
	a1 = x0 - x6;
 801e1ac:	990a      	ldr	r1, [sp, #40]	@ 0x28
	x6 = a25 - a20;			x[6] = x6;
 801e1ae:	9526      	str	r5, [sp, #152]	@ 0x98
	x3 = a26 - a21;			x[3] = x3;
 801e1b0:	ebaa 0309 	sub.w	r3, sl, r9
	a1 = x0 - x6;
 801e1b4:	9d2f      	ldr	r5, [sp, #188]	@ 0xbc
	x3 = a26 - a21;			x[3] = x3;
 801e1b6:	9323      	str	r3, [sp, #140]	@ 0x8c
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801e1b8:	eb08 0346 	add.w	r3, r8, r6, lsl #1
	a1 = x0 - x6;
 801e1bc:	eba1 0a05 	sub.w	sl, r1, r5
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801e1c0:	9321      	str	r3, [sp, #132]	@ 0x84
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801e1c2:	9d2e      	ldr	r5, [sp, #184]	@ 0xb8
 801e1c4:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
	a4 = x2 - x4;
 801e1c6:	982d      	ldr	r0, [sp, #180]	@ 0xb4
	x5 = x[5]; x6 = x[6]; x7 = x[7]; x8 = x[8];
 801e1c8:	9c31      	ldr	r4, [sp, #196]	@ 0xc4
	a5 = x2 + x4;
 801e1ca:	992d      	ldr	r1, [sp, #180]	@ 0xb4
	x4 = a1 - a11;			x[4] = x4;
 801e1cc:	9724      	str	r7, [sp, #144]	@ 0x90
	a9 = a3 - a7;		/* ie x[5] - x[7] */
 801e1ce:	1aeb      	subs	r3, r5, r3
 801e1d0:	4d78      	ldr	r5, [pc, #480]	@ (801e3b4 <xmp3_IMDCT+0x684>)
 801e1d2:	9f2c      	ldr	r7, [sp, #176]	@ 0xb0
 801e1d4:	930b      	str	r3, [sp, #44]	@ 0x2c
	x0 = a22 + a19;			x[0] = x0;
 801e1d6:	4496      	add	lr, r2
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801e1d8:	eba8 0646 	sub.w	r6, r8, r6, lsl #1
	x5 = a27 + a21;			x[5] = x5;
 801e1dc:	eb0c 0209 	add.w	r2, ip, r9
	a4 = x2 - x4;
 801e1e0:	ebab 0c00 	sub.w	ip, fp, r0
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801e1e4:	9627      	str	r6, [sp, #156]	@ 0x9c
	x0 = x[0]; x1 = x[1]; x2 = x[2]; x3 = x[3]; x4 = x[4];
 801e1e6:	982a      	ldr	r0, [sp, #168]	@ 0xa8
	x0 = a22 + a19;			x[0] = x0;
 801e1e8:	f8cd e080 	str.w	lr, [sp, #128]	@ 0x80
	x5 = a27 + a21;			x[5] = x5;
 801e1ec:	9225      	str	r2, [sp, #148]	@ 0x94
	a11 = a4 - x8;		/* ie x[2] - x[4] - x[8] */
 801e1ee:	ebac 0c04 	sub.w	ip, ip, r4
	a5 = x2 + x4;
 801e1f2:	4459      	add	r1, fp
 801e1f4:	462e      	mov	r6, r5
 801e1f6:	fb85 3707 	smull	r3, r7, r5, r7
	a2 = x1 - x5;
 801e1fa:	9d2e      	ldr	r5, [sp, #184]	@ 0xb8
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 801e1fc:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
	a2 = x1 - x5;
 801e1fe:	1b45      	subs	r5, r0, r5
	a10 = a2 - x7;		/* ie x[1] - x[5] - x[7] */
 801e200:	1aed      	subs	r5, r5, r3
 801e202:	fb86 3505 	smull	r3, r5, r6, r5
 801e206:	4e6c      	ldr	r6, [pc, #432]	@ (801e3b8 <xmp3_IMDCT+0x688>)
 801e208:	468e      	mov	lr, r1
 801e20a:	fb86 3e0e 	smull	r3, lr, r6, lr
 801e20e:	4a6b      	ldr	r2, [pc, #428]	@ (801e3bc <xmp3_IMDCT+0x68c>)
	a6 = x2 + x8;
 801e210:	44a3      	add	fp, r4
 801e212:	fb82 3b0b 	smull	r3, fp, r2, fp
	a8 = a6 - a5;		/* ie x[8] - x[4] */
 801e216:	9b2d      	ldr	r3, [sp, #180]	@ 0xb4
 801e218:	1ae4      	subs	r4, r4, r3
 801e21a:	fb86 3404 	smull	r3, r4, r6, r4
 801e21e:	fb82 3101 	smull	r3, r1, r2, r1
 801e222:	f102 5270 	add.w	r2, r2, #1006632960	@ 0x3c000000
 801e226:	f502 224c 	add.w	r2, r2, #835584	@ 0xcc000
 801e22a:	f8dd 802c 	ldr.w	r8, [sp, #44]	@ 0x2c
 801e22e:	f202 22cb 	addw	r2, r2, #715	@ 0x2cb
 801e232:	fb82 3808 	smull	r3, r8, r2, r8
	a7 = x1 + x7;
 801e236:	9b30      	ldr	r3, [sp, #192]	@ 0xc0
 801e238:	4e61      	ldr	r6, [pc, #388]	@ (801e3c0 <xmp3_IMDCT+0x690>)
 801e23a:	18c3      	adds	r3, r0, r3
 801e23c:	fb86 9303 	smull	r9, r3, r6, r3
	a3 = x1 + x5;
 801e240:	9a2e      	ldr	r2, [sp, #184]	@ 0xb8
 801e242:	eb00 0902 	add.w	r9, r0, r2
 801e246:	4a5f      	ldr	r2, [pc, #380]	@ (801e3c4 <xmp3_IMDCT+0x694>)
 801e248:	fb82 0909 	smull	r0, r9, r2, r9
 801e24c:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 801e24e:	fb86 0202 	smull	r0, r2, r6, r2
	a12 = x[0] +  (x[6] >> 1);
 801e252:	9e2f      	ldr	r6, [sp, #188]	@ 0xbc
 801e254:	980a      	ldr	r0, [sp, #40]	@ 0x28
	a16 = ( m5 << 1) + (m6 << 1);
 801e256:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
	a12 = x[0] +  (x[6] >> 1);
 801e25a:	eb00 0066 	add.w	r0, r0, r6, asr #1
	a17 = ( m7 << 1) - (m8 << 1);
 801e25e:	0049      	lsls	r1, r1, #1
	a16 = ( m5 << 1) + (m6 << 1);
 801e260:	eb0b 0b4e 	add.w	fp, fp, lr, lsl #1
	a17 = ( m7 << 1) - (m8 << 1);
 801e264:	ebc1 0144 	rsb	r1, r1, r4, lsl #1
	x4 = a1 - a11;			x[4] = x4;
 801e268:	ebaa 060c 	sub.w	r6, sl, ip
	a13 = a12  +  (  m1 << 1);
 801e26c:	eb00 0447 	add.w	r4, r0, r7, lsl #1
	a19 = ( m9 << 1) + (m10 << 1);
 801e270:	005b      	lsls	r3, r3, #1
	a14 = a12  -  (  m1 << 1);
 801e272:	eba0 0047 	sub.w	r0, r0, r7, lsl #1
	a20 = (m11 << 1) - (m12 << 1);
 801e276:	0052      	lsls	r2, r2, #1
	a19 = ( m9 << 1) + (m10 << 1);
 801e278:	eb03 0348 	add.w	r3, r3, r8, lsl #1
	a20 = (m11 << 1) - (m12 << 1);
 801e27c:	ebc2 0249 	rsb	r2, r2, r9, lsl #1
	a18 = a16 + a17;
 801e280:	eb0b 0701 	add.w	r7, fp, r1
	x4 = a1 - a11;			x[4] = x4;
 801e284:	962d      	str	r6, [sp, #180]	@ 0xb4
	a22 = a13 + a16;
 801e286:	eb04 060b 	add.w	r6, r4, fp
	a23 = a14 + a16;
 801e28a:	4483      	add	fp, r0
	a15 = a1   +  ( a11 >> 1);
 801e28c:	eb0a 0e6c 	add.w	lr, sl, ip, asr #1
	x0 = a22 + a19;			x[0] = x0;
 801e290:	441e      	add	r6, r3
	a21 = a20 - a19;
 801e292:	eba2 0c03 	sub.w	ip, r2, r3
	x8 = a23 - a19;			x[8] = x8;
 801e296:	ebab 0303 	sub.w	r3, fp, r3
 801e29a:	9331      	str	r3, [sp, #196]	@ 0xc4
	a24 = a14 + a17;
 801e29c:	1843      	adds	r3, r0, r1
	x2 = a24 + a20;			x[2] = x2;
 801e29e:	4413      	add	r3, r2
 801e2a0:	932b      	str	r3, [sp, #172]	@ 0xac
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801e2a2:	eb0e 0345 	add.w	r3, lr, r5, lsl #1
	a26 = a14 - a18;
 801e2a6:	1bc0      	subs	r0, r0, r7
	x1 = a15 + (m3 << 1);	x[1] = x1;
 801e2a8:	932a      	str	r3, [sp, #168]	@ 0xa8
	a27 = a13 - a18;
 801e2aa:	1be7      	subs	r7, r4, r7
	if (btPrev == 0 && btCurr == 0) {
 801e2ac:	9b01      	ldr	r3, [sp, #4]
	x0 = a22 + a19;			x[0] = x0;
 801e2ae:	9629      	str	r6, [sp, #164]	@ 0xa4
	a25 = a13 + a17;
 801e2b0:	440c      	add	r4, r1
	x6 = a25 - a20;			x[6] = x6;
 801e2b2:	1aa4      	subs	r4, r4, r2
	x3 = a26 - a21;			x[3] = x3;
 801e2b4:	eba0 000c 	sub.w	r0, r0, ip
	x5 = a27 + a21;			x[5] = x5;
 801e2b8:	4467      	add	r7, ip
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801e2ba:	ebae 0545 	sub.w	r5, lr, r5, lsl #1
	x6 = a25 - a20;			x[6] = x6;
 801e2be:	942f      	str	r4, [sp, #188]	@ 0xbc
	x3 = a26 - a21;			x[3] = x3;
 801e2c0:	902c      	str	r0, [sp, #176]	@ 0xb0
	x5 = a27 + a21;			x[5] = x5;
 801e2c2:	972e      	str	r7, [sp, #184]	@ 0xb8
	x7 = a15 - (m3 << 1);	x[7] = x7;
 801e2c4:	9530      	str	r5, [sp, #192]	@ 0xc0
	if (btPrev == 0 && btCurr == 0) {
 801e2c6:	2b00      	cmp	r3, #0
 801e2c8:	f040 8082 	bne.w	801e3d0 <xmp3_IMDCT+0x6a0>
 801e2cc:	9901      	ldr	r1, [sp, #4]
 801e2ce:	f8dd c00c 	ldr.w	ip, [sp, #12]
 801e2d2:	4c3d      	ldr	r4, [pc, #244]	@ (801e3c8 <xmp3_IMDCT+0x698>)
	cp = c18 + 8;
 801e2d4:	f8df 80f4 	ldr.w	r8, [pc, #244]	@ 801e3cc <xmp3_IMDCT+0x69c>
	if (btPrev == 0 && btCurr == 0) {
 801e2d8:	9e08      	ldr	r6, [sp, #32]
 801e2da:	4667      	mov	r7, ip
 801e2dc:	4608      	mov	r0, r1
	xp = xBuf + 8;
 801e2de:	ad28      	add	r5, sp, #160	@ 0xa0
	__asm__ volatile (
 801e2e0:	468e      	mov	lr, r1
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 801e2e2:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801e2e4:	f858 9904 	ldr.w	r9, [r8], #-4
 801e2e8:	f855 2904 	ldr.w	r2, [r5], #-4
 801e2ec:	fb89 a303 	smull	sl, r3, r9, r3
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 801e2f0:	eb03 09a2 	add.w	r9, r3, r2, asr #2
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 801e2f4:	f8d6 a000 	ldr.w	sl, [r6]
			(*xPrev++) = xe + xo;			/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 801e2f8:	f846 9b04 	str.w	r9, [r6], #4
			d = -(xe - xo);		/* gain 2 int bits, don't shift xo (effective << 1 to eat sign bit, << 1 for mul by 2) */
 801e2fc:	eba3 03a2 	sub.w	r3, r3, r2, asr #2
			s = -(*xPrev);		/* sum from last block (always at least 2 guard bits) */
 801e300:	f1ca 0900 	rsb	r9, sl, #0
 801e304:	f854 2c08 	ldr.w	r2, [r4, #-8]
			t = s - d;
 801e308:	eba9 0903 	sub.w	r9, r9, r3
 801e30c:	fb89 b202 	smull	fp, r2, r9, r2
			yLo = (d + (MULSHIFT32(t, *wp++) << 2));
 801e310:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801e314:	f854 2c04 	ldr.w	r2, [r4, #-4]
 801e318:	fb89 b202 	smull	fp, r2, r9, r2
    return y;
 801e31c:	ebca 0a82 	rsb	sl, sl, r2, lsl #2
			y[(i)*NBANDS]    = 	yLo;
 801e320:	f84c 3020 	str.w	r3, [ip, r0, lsl #2]
	__asm__ volatile (
 801e324:	4672      	mov	r2, lr
			y[(17-i)*NBANDS] =  yHi;
 801e326:	f8c7 a880 	str.w	sl, [r7, #2176]	@ 0x880
 801e32a:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 801e32e:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 801e332:	4673      	mov	r3, lr
 801e334:	ea8a 73ea 	eor.w	r3, sl, sl, asr #31
 801e338:	eba3 73ea 	sub.w	r3, r3, sl, asr #31
		for (i = 0; i < 9; i++) {
 801e33c:	3020      	adds	r0, #32
			mOut |= FASTABS(yHi);
 801e33e:	431a      	orrs	r2, r3
		for (i = 0; i < 9; i++) {
 801e340:	f5b0 7f90 	cmp.w	r0, #288	@ 0x120
			mOut |= FASTABS(yHi);
 801e344:	ea41 0102 	orr.w	r1, r1, r2
		for (i = 0; i < 9; i++) {
 801e348:	f104 0408 	add.w	r4, r4, #8
 801e34c:	f1a7 0780 	sub.w	r7, r7, #128	@ 0x80
 801e350:	d1c7      	bne.n	801e2e2 <xmp3_IMDCT+0x5b2>
 801e352:	9101      	str	r1, [sp, #4]
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e354:	e9dd 3107 	ldrd	r3, r1, [sp, #28]
 801e358:	3324      	adds	r3, #36	@ 0x24
 801e35a:	9307      	str	r3, [sp, #28]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e35c:	9b03      	ldr	r3, [sp, #12]
 801e35e:	9c06      	ldr	r4, [sp, #24]
 801e360:	4618      	mov	r0, r3
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e362:	3304      	adds	r3, #4
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e364:	4622      	mov	r2, r4
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e366:	9303      	str	r3, [sp, #12]
 801e368:	3401      	adds	r4, #1
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e36a:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e36c:	9406      	str	r4, [sp, #24]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e36e:	f7ff fb83 	bl	801da78 <FreqInvertRescale>
 801e372:	9b01      	ldr	r3, [sp, #4]
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e374:	9d0f      	ldr	r5, [sp, #60]	@ 0x3c
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e376:	4318      	orrs	r0, r3
		mOut |= IMDCT36(xCurr, xPrev, &(y[0][i]), currWinIdx, prevWinIdx, i, bc->gbIn);
 801e378:	9b05      	ldr	r3, [sp, #20]
 801e37a:	4303      	orrs	r3, r0
 801e37c:	9305      	str	r3, [sp, #20]
	for(i = 0; i < bc->nBlocksLong; i++) {
 801e37e:	9b04      	ldr	r3, [sp, #16]
 801e380:	429c      	cmp	r4, r3
 801e382:	f000 8097 	beq.w	801e4b4 <xmp3_IMDCT+0x784>
		if (sis->mixedBlock && i < bc->currWinSwitch) 
 801e386:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 801e388:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 801e38a:	e65e      	b.n	801e04a <xmp3_IMDCT+0x31a>
		bc.nBlocksLong = MIN((hi->nonZeroBound[ch] + 7) / 18 + 1, 32);	
 801e38c:	3307      	adds	r3, #7
 801e38e:	fb82 1203 	smull	r1, r2, r2, r3
 801e392:	17db      	asrs	r3, r3, #31
 801e394:	ebc3 0ca2 	rsb	ip, r3, r2, asr #2
 801e398:	f10c 0301 	add.w	r3, ip, #1
 801e39c:	9304      	str	r3, [sp, #16]
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801e39e:	eb0c 03cc 	add.w	r3, ip, ip, lsl #3
 801e3a2:	005b      	lsls	r3, r3, #1
	for (k = nBfly; k > 0; k--) {
 801e3a4:	f1bc 0f00 	cmp.w	ip, #0
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801e3a8:	f103 0908 	add.w	r9, r3, #8
	for (k = nBfly; k > 0; k--) {
 801e3ac:	f73f ad13 	bgt.w	801ddd6 <xmp3_IMDCT+0xa6>
 801e3b0:	e5e7      	b.n	801df82 <xmp3_IMDCT+0x252>
 801e3b2:	bf00      	nop
 801e3b4:	6ed9eba1 	.word	0x6ed9eba1
 801e3b8:	620dbe8b 	.word	0x620dbe8b
 801e3bc:	163a1a7e 	.word	0x163a1a7e
 801e3c0:	7e0e2e32 	.word	0x7e0e2e32
 801e3c4:	5246dd49 	.word	0x5246dd49
 801e3c8:	08037b10 	.word	0x08037b10
 801e3cc:	08037b70 	.word	0x08037b70
		WinPrevious(xPrev, xPrevWin, btPrev);
 801e3d0:	9c08      	ldr	r4, [sp, #32]
 801e3d2:	9a11      	ldr	r2, [sp, #68]	@ 0x44
		wp = imdctWin[btCurr];
 801e3d4:	4e35      	ldr	r6, [pc, #212]	@ (801e4ac <xmp3_IMDCT+0x77c>)
	cp = c18 + 8;
 801e3d6:	f8df a0d8 	ldr.w	sl, [pc, #216]	@ 801e4b0 <xmp3_IMDCT+0x780>
		WinPrevious(xPrev, xPrevWin, btPrev);
 801e3da:	f10d 08c8 	add.w	r8, sp, #200	@ 0xc8
 801e3de:	4620      	mov	r0, r4
 801e3e0:	4641      	mov	r1, r8
 801e3e2:	f7ff fc13 	bl	801dc0c <WinPrevious>
		wp = imdctWin[btCurr];
 801e3e6:	9b02      	ldr	r3, [sp, #8]
 801e3e8:	9d03      	ldr	r5, [sp, #12]
 801e3ea:	f8cd a008 	str.w	sl, [sp, #8]
 801e3ee:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 801e3f2:	eb06 1603 	add.w	r6, r6, r3, lsl #4
	mOut = 0;
 801e3f6:	2300      	movs	r3, #0
 801e3f8:	f1a6 0904 	sub.w	r9, r6, #4
		wp = imdctWin[btCurr];
 801e3fc:	46a4      	mov	ip, r4
	mOut = 0;
 801e3fe:	461f      	mov	r7, r3
 801e400:	9301      	str	r3, [sp, #4]
 801e402:	3648      	adds	r6, #72	@ 0x48
 801e404:	f50d 7e88 	add.w	lr, sp, #272	@ 0x110
		for (i = 0; i < 9; i++) {
 801e408:	4618      	mov	r0, r3
	xp = xBuf + 8;
 801e40a:	ac28      	add	r4, sp, #160	@ 0xa0
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801e40c:	9902      	ldr	r1, [sp, #8]
			c = *cp--;	xo = *(xp + 9);		xe = *xp--;
 801e40e:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 801e410:	f851 a904 	ldr.w	sl, [r1], #-4
 801e414:	f854 2904 	ldr.w	r2, [r4], #-4
 801e418:	9102      	str	r1, [sp, #8]
 801e41a:	fb8a b303 	smull	fp, r3, sl, r3
			(*xPrev++) = xe + xo;	/* symmetry - xPrev[i] = xPrev[17-i] for long blocks */
 801e41e:	eb03 0aa2 	add.w	sl, r3, r2, asr #2
 801e422:	f84c ab04 	str.w	sl, [ip], #4
			d = xe - xo;
 801e426:	ebc3 0aa2 	rsb	sl, r3, r2, asr #2
 801e42a:	f859 2f04 	ldr.w	r2, [r9, #4]!
 801e42e:	fb8a 3202 	smull	r3, r2, sl, r2
			yLo = (xPrevWin[i]    + MULSHIFT32(d, wp[i])) << 2;
 801e432:	f858 3020 	ldr.w	r3, [r8, r0, lsl #2]
 801e436:	441a      	add	r2, r3
 801e438:	0092      	lsls	r2, r2, #2
 801e43a:	f856 3d04 	ldr.w	r3, [r6, #-4]!
 801e43e:	fb8a b303 	smull	fp, r3, sl, r3
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 801e442:	f85e ad04 	ldr.w	sl, [lr, #-4]!
			y[(i)*NBANDS]    = yLo;
 801e446:	9903      	ldr	r1, [sp, #12]
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 801e448:	4453      	add	r3, sl
			y[(i)*NBANDS]    = yLo;
 801e44a:	ea4f 1ac0 	mov.w	sl, r0, lsl #7
			yHi = (xPrevWin[17-i] + MULSHIFT32(d, wp[17-i])) << 2;
 801e44e:	009b      	lsls	r3, r3, #2
			y[(i)*NBANDS]    = yLo;
 801e450:	f841 200a 	str.w	r2, [r1, sl]
			y[(17-i)*NBANDS] = yHi;
 801e454:	f8c5 3880 	str.w	r3, [r5, #2176]	@ 0x880
	__asm__ volatile (
 801e458:	46ba      	mov	sl, r7
 801e45a:	ea82 7ae2 	eor.w	sl, r2, r2, asr #31
 801e45e:	ebaa 7ae2 	sub.w	sl, sl, r2, asr #31
 801e462:	463a      	mov	r2, r7
 801e464:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 801e468:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
			mOut |= FASTABS(yHi);
 801e46c:	9b01      	ldr	r3, [sp, #4]
 801e46e:	ea4a 0a02 	orr.w	sl, sl, r2
		for (i = 0; i < 9; i++) {
 801e472:	3001      	adds	r0, #1
			mOut |= FASTABS(yHi);
 801e474:	ea43 030a 	orr.w	r3, r3, sl
		for (i = 0; i < 9; i++) {
 801e478:	2809      	cmp	r0, #9
			mOut |= FASTABS(yHi);
 801e47a:	9301      	str	r3, [sp, #4]
		for (i = 0; i < 9; i++) {
 801e47c:	f1a5 0580 	sub.w	r5, r5, #128	@ 0x80
 801e480:	d1c4      	bne.n	801e40c <xmp3_IMDCT+0x6dc>
 801e482:	e767      	b.n	801e354 <xmp3_IMDCT+0x624>
 801e484:	ac29      	add	r4, sp, #164	@ 0xa4
	acc1 = acc2 = 0;
 801e486:	4602      	mov	r2, r0
			acc1 = (*xCurr--) - acc1;
 801e488:	688b      	ldr	r3, [r1, #8]
 801e48a:	1a9a      	subs	r2, r3, r2
			acc1 = (*xCurr--) - acc1;
 801e48c:	684b      	ldr	r3, [r1, #4]
		for (i = 8; i >= 0; i--) {	
 801e48e:	3908      	subs	r1, #8
			acc2 = acc1 - acc2;
 801e490:	1a10      	subs	r0, r2, r0
		for (i = 8; i >= 0; i--) {	
 801e492:	428d      	cmp	r5, r1
			acc1 = (*xCurr--) - acc1;
 801e494:	eba3 0202 	sub.w	r2, r3, r2
			xBuf[i+9] = acc2;	/* odd */
 801e498:	6220      	str	r0, [r4, #32]
			xBuf[i+0] = acc1;	/* even */
 801e49a:	f844 2d04 	str.w	r2, [r4, #-4]!
		for (i = 8; i >= 0; i--) {	
 801e49e:	d1f3      	bne.n	801e488 <xmp3_IMDCT+0x758>
 801e4a0:	e60f      	b.n	801e0c2 <xmp3_IMDCT+0x392>
 801e4a2:	9b02      	ldr	r3, [sp, #8]
 801e4a4:	9301      	str	r3, [sp, #4]
			 prevWinIdx = 0;
 801e4a6:	2300      	movs	r3, #0
 801e4a8:	9311      	str	r3, [sp, #68]	@ 0x44
 801e4aa:	e5e5      	b.n	801e078 <xmp3_IMDCT+0x348>
 801e4ac:	08038684 	.word	0x08038684
 801e4b0:	08037b70 	.word	0x08037b70
		xCurr += 18;
 801e4b4:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 801e4b6:	e9dd 9a1c 	ldrd	r9, sl, [sp, #112]	@ 0x70
 801e4ba:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 801e4be:	e9dd b81e 	ldrd	fp, r8, [sp, #120]	@ 0x78
 801e4c2:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 801e4c6:	9215      	str	r2, [sp, #84]	@ 0x54
		xPrev += 9;
 801e4c8:	eb0a 0a83 	add.w	sl, sl, r3, lsl #2
	for (   ; i < bc->nBlocksTotal; i++) {
 801e4cc:	9c04      	ldr	r4, [sp, #16]
 801e4ce:	45a3      	cmp	fp, r4
 801e4d0:	f340 82a5 	ble.w	801ea1e <xmp3_IMDCT+0xcee>
 801e4d4:	eb09 0384 	add.w	r3, r9, r4, lsl #2
 801e4d8:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
 801e4dc:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 801e4de:	9302      	str	r3, [sp, #8]
 801e4e0:	f509 73c0 	add.w	r3, r9, #384	@ 0x180
 801e4e4:	eb03 038b 	add.w	r3, r3, fp, lsl #2
 801e4e8:	2a06      	cmp	r2, #6
 801e4ea:	9311      	str	r3, [sp, #68]	@ 0x44
		es = 7 - gb;
 801e4ec:	f1c2 0307 	rsb	r3, r2, #7
 801e4f0:	9d15      	ldr	r5, [sp, #84]	@ 0x54
 801e4f2:	9313      	str	r3, [sp, #76]	@ 0x4c
 801e4f4:	e9cd 9a15 	strd	r9, sl, [sp, #84]	@ 0x54
 801e4f8:	bfc8      	it	gt
 801e4fa:	2300      	movgt	r3, #0
 801e4fc:	e9cd b41c 	strd	fp, r4, [sp, #112]	@ 0x70
 801e500:	f10a 0224 	add.w	r2, sl, #36	@ 0x24
 801e504:	9310      	str	r3, [sp, #64]	@ 0x40
 801e506:	ab32      	add	r3, sp, #200	@ 0xc8
 801e508:	3504      	adds	r5, #4
 801e50a:	9206      	str	r2, [sp, #24]
 801e50c:	9307      	str	r3, [sp, #28]
 801e50e:	f8cd 8078 	str.w	r8, [sp, #120]	@ 0x78
 801e512:	9b02      	ldr	r3, [sp, #8]
			 prevWinIdx = 0;
 801e514:	9a04      	ldr	r2, [sp, #16]
 801e516:	9809      	ldr	r0, [sp, #36]	@ 0x24
 801e518:	f5a3 7ac0 	sub.w	sl, r3, #384	@ 0x180
 801e51c:	9b06      	ldr	r3, [sp, #24]
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 801e51e:	f8cd a020 	str.w	sl, [sp, #32]
 801e522:	f1a3 0124 	sub.w	r1, r3, #36	@ 0x24
			 prevWinIdx = 0;
 801e526:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 801e528:	9103      	str	r1, [sp, #12]
 801e52a:	4282      	cmp	r2, r0
 801e52c:	bfb8      	it	lt
 801e52e:	2300      	movlt	r3, #0
 801e530:	930a      	str	r3, [sp, #40]	@ 0x28
	if (gb < 7) {
 801e532:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 801e534:	2b06      	cmp	r3, #6
 801e536:	dc14      	bgt.n	801e562 <xmp3_IMDCT+0x832>
		for (i = 0; i < 18; i+=2) {
 801e538:	9c13      	ldr	r4, [sp, #76]	@ 0x4c
 801e53a:	1f28      	subs	r0, r5, #4
 801e53c:	2200      	movs	r2, #0
			xCurr[i+0] >>= es;
 801e53e:	f850 3022 	ldr.w	r3, [r0, r2, lsl #2]
 801e542:	4123      	asrs	r3, r4
 801e544:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
			xCurr[i+1] >>= es;
 801e548:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
 801e54c:	4123      	asrs	r3, r4
 801e54e:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
			*xPrev++ >>= es;
 801e552:	f851 3b04 	ldr.w	r3, [r1], #4
		for (i = 0; i < 18; i+=2) {
 801e556:	3202      	adds	r2, #2
			*xPrev++ >>= es;
 801e558:	4123      	asrs	r3, r4
		for (i = 0; i < 18; i+=2) {
 801e55a:	2a12      	cmp	r2, #18
			*xPrev++ >>= es;
 801e55c:	f841 3c04 	str.w	r3, [r1, #-4]
		for (i = 0; i < 18; i+=2) {
 801e560:	d1ed      	bne.n	801e53e <xmp3_IMDCT+0x80e>
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 801e562:	6baa      	ldr	r2, [r5, #56]	@ 0x38
 801e564:	6aee      	ldr	r6, [r5, #44]	@ 0x2c
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 801e566:	6a29      	ldr	r1, [r5, #32]
 801e568:	696c      	ldr	r4, [r5, #20]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801e56a:	68ab      	ldr	r3, [r5, #8]
 801e56c:	f855 0c04 	ldr.w	r0, [r5, #-4]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801e570:	4fc6      	ldr	r7, [pc, #792]	@ (801e88c <xmp3_IMDCT+0xb5c>)
	x4 -= x5;
 801e572:	1ab6      	subs	r6, r6, r2
	x3 -= x4;
 801e574:	1b89      	subs	r1, r1, r6
	x2 -= x3;
 801e576:	1a64      	subs	r4, r4, r1
	x1 -= x2;
 801e578:	1b1b      	subs	r3, r3, r4
	x3 -= x5;
 801e57a:	1a89      	subs	r1, r1, r2
	x0 -= x1;
 801e57c:	1ac0      	subs	r0, r0, r3
	x1 -= x3;
 801e57e:	1a5b      	subs	r3, r3, r1
	x0 >>= 1;
 801e580:	1040      	asrs	r0, r0, #1
	x1 >>= 1;
 801e582:	105b      	asrs	r3, r3, #1
 801e584:	fb87 c404 	smull	ip, r4, r7, r4
	a1 = x0 + (x4 >> 1);
 801e588:	eb00 0e66 	add.w	lr, r0, r6, asr #1
	x0 = a1 + a0;
 801e58c:	eb0e 0c44 	add.w	ip, lr, r4, lsl #1
	a2 = x0 - x4;
 801e590:	1b80      	subs	r0, r0, r6
	x4 = a1 - a0;
 801e592:	ebae 0b44 	sub.w	fp, lr, r4, lsl #1
 801e596:	fb87 4101 	smull	r4, r1, r7, r1
	a1 = x1 + (x5 >> 1);
 801e59a:	eb03 0462 	add.w	r4, r3, r2, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801e59e:	eb04 0641 	add.w	r6, r4, r1, lsl #1
 801e5a2:	4fbb      	ldr	r7, [pc, #748]	@ (801e890 <xmp3_IMDCT+0xb60>)
	a0 = MULSHIFT32(c3_0, x3) << 1;
 801e5a4:	0049      	lsls	r1, r1, #1
 801e5a6:	fb87 e606 	smull	lr, r6, r7, r6
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801e5aa:	00b6      	lsls	r6, r6, #2
 801e5ac:	9601      	str	r6, [sp, #4]
	a2 = x1 - x5;
 801e5ae:	1a9b      	subs	r3, r3, r2
 801e5b0:	4eb8      	ldr	r6, [pc, #736]	@ (801e894 <xmp3_IMDCT+0xb64>)
 801e5b2:	fb86 2303 	smull	r2, r3, r6, r3
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 801e5b6:	1a64      	subs	r4, r4, r1
	x3 = MULSHIFT32(c6[1], a2) << 2;
 801e5b8:	009a      	lsls	r2, r3, #2
 801e5ba:	49b7      	ldr	r1, [pc, #732]	@ (801e898 <xmp3_IMDCT+0xb68>)
 801e5bc:	fb81 3404 	smull	r3, r4, r1, r4
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 801e5c0:	6b2b      	ldr	r3, [r5, #48]	@ 0x30
	x4 -= x5;
 801e5c2:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
	*out = x0 + x1;	out++;
 801e5c4:	9e01      	ldr	r6, [sp, #4]
	x4 -= x5;
 801e5c6:	eba3 0e01 	sub.w	lr, r3, r1
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 801e5ca:	6a6b      	ldr	r3, [r5, #36]	@ 0x24
 801e5cc:	69a9      	ldr	r1, [r5, #24]
	x3 -= x4;
 801e5ce:	eba3 030e 	sub.w	r3, r3, lr
	x2 -= x3;
 801e5d2:	eba1 0903 	sub.w	r9, r1, r3
	x3 -= x5;
 801e5d6:	6be9      	ldr	r1, [r5, #60]	@ 0x3c
	*out = x0 + x1;	out++;
 801e5d8:	4466      	add	r6, ip
	x3 -= x5;
 801e5da:	eba3 0801 	sub.w	r8, r3, r1
	*out = x0 + x1;	out++;
 801e5de:	9620      	str	r6, [sp, #128]	@ 0x80
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801e5e0:	68eb      	ldr	r3, [r5, #12]
	*out = x0 - x1;
 801e5e2:	9e01      	ldr	r6, [sp, #4]
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801e5e4:	6829      	ldr	r1, [r5, #0]
	x1 -= x2;
 801e5e6:	eba3 0309 	sub.w	r3, r3, r9
	*out = x0 - x1;
 801e5ea:	ebac 0606 	sub.w	r6, ip, r6
	x0 -= x1;
 801e5ee:	1ac9      	subs	r1, r1, r3
	*out = x0 - x1;
 801e5f0:	9625      	str	r6, [sp, #148]	@ 0x94
	x1 -= x3;
 801e5f2:	eba3 0308 	sub.w	r3, r3, r8
	*out = x2 + x3;	out++;
 801e5f6:	1886      	adds	r6, r0, r2
	*out = x2 - x3;	out++;
 801e5f8:	1a80      	subs	r0, r0, r2
	*out = x4 + x5;	out++;
 801e5fa:	eb0b 0284 	add.w	r2, fp, r4, lsl #2
	*out = x4 - x5;	out++;
 801e5fe:	ebab 0484 	sub.w	r4, fp, r4, lsl #2
	*out = x2 - x3;	out++;
 801e602:	9024      	str	r0, [sp, #144]	@ 0x90
	x0 >>= 1;
 801e604:	1049      	asrs	r1, r1, #1
	x1 >>= 1;
 801e606:	105b      	asrs	r3, r3, #1
	*out = x2 + x3;	out++;
 801e608:	9621      	str	r6, [sp, #132]	@ 0x84
	*out = x4 - x5;	out++;
 801e60a:	e9cd 2422 	strd	r2, r4, [sp, #136]	@ 0x88
 801e60e:	489f      	ldr	r0, [pc, #636]	@ (801e88c <xmp3_IMDCT+0xb5c>)
 801e610:	fb80 2909 	smull	r2, r9, r0, r9
	a1 = x0 + (x4 >> 1);
 801e614:	eb01 046e 	add.w	r4, r1, lr, asr #1
	x0 = a1 + a0;
 801e618:	eb04 0649 	add.w	r6, r4, r9, lsl #1
	a2 = x0 - x4;
 801e61c:	eba1 010e 	sub.w	r1, r1, lr
	x4 = a1 - a0;
 801e620:	eba4 0449 	sub.w	r4, r4, r9, lsl #1
 801e624:	fb80 2808 	smull	r2, r8, r0, r8
	a1 = x1 + (x5 >> 1);
 801e628:	6bea      	ldr	r2, [r5, #60]	@ 0x3c
 801e62a:	eb03 0c62 	add.w	ip, r3, r2, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801e62e:	eb0c 0e48 	add.w	lr, ip, r8, lsl #1
	a0 = MULSHIFT32(c3_0, x3) << 1;
 801e632:	ea4f 0848 	mov.w	r8, r8, lsl #1
 801e636:	fb87 2e0e 	smull	r2, lr, r7, lr
	a2 = x1 - x5;
 801e63a:	6bea      	ldr	r2, [r5, #60]	@ 0x3c
 801e63c:	4895      	ldr	r0, [pc, #596]	@ (801e894 <xmp3_IMDCT+0xb64>)
 801e63e:	1a9b      	subs	r3, r3, r2
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801e640:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 801e644:	fb80 2303 	smull	r2, r3, r0, r3
	x3 = MULSHIFT32(c6[1], a2) << 2;
 801e648:	009b      	lsls	r3, r3, #2
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 801e64a:	ebac 0c08 	sub.w	ip, ip, r8
	x3 = MULSHIFT32(c6[1], a2) << 2;
 801e64e:	9301      	str	r3, [sp, #4]
 801e650:	4891      	ldr	r0, [pc, #580]	@ (801e898 <xmp3_IMDCT+0xb68>)
 801e652:	fb80 3c0c 	smull	r3, ip, r0, ip
	x4 -= x5;
 801e656:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
	x4 = *x;	x+=3;	x5 = *x;	x+=3;
 801e658:	6b6b      	ldr	r3, [r5, #52]	@ 0x34
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 801e65a:	69e8      	ldr	r0, [r5, #28]
	x4 -= x5;
 801e65c:	eba3 0802 	sub.w	r8, r3, r2
	x2 = *x;	x+=3;	x3 = *x;	x+=3;
 801e660:	6aab      	ldr	r3, [r5, #40]	@ 0x28
	x3 -= x4;
 801e662:	eba3 0308 	sub.w	r3, r3, r8
	x2 -= x3;
 801e666:	1ac0      	subs	r0, r0, r3
	x3 -= x5;
 801e668:	eba3 0902 	sub.w	r9, r3, r2
	*out = x0 + x1;	out++;
 801e66c:	eb06 020e 	add.w	r2, r6, lr
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801e670:	692b      	ldr	r3, [r5, #16]
	*out = x0 + x1;	out++;
 801e672:	920b      	str	r2, [sp, #44]	@ 0x2c
	*out = x0 - x1;
 801e674:	eba6 060e 	sub.w	r6, r6, lr
 801e678:	962b      	str	r6, [sp, #172]	@ 0xac
	*out = x2 + x3;	out++;
 801e67a:	9e01      	ldr	r6, [sp, #4]
	*out = x0 + x1;	out++;
 801e67c:	9226      	str	r2, [sp, #152]	@ 0x98
	x1 -= x2;
 801e67e:	1a1b      	subs	r3, r3, r0
 801e680:	4683      	mov	fp, r0
	x0 = *x;	x+=3;	x1 = *x;	x+=3;
 801e682:	6868      	ldr	r0, [r5, #4]
	*out = x2 + x3;	out++;
 801e684:	198a      	adds	r2, r1, r6
	x0 -= x1;
 801e686:	1ac0      	subs	r0, r0, r3
	*out = x2 - x3;	out++;
 801e688:	1b89      	subs	r1, r1, r6
	x1 -= x3;
 801e68a:	eba3 0309 	sub.w	r3, r3, r9
	*out = x2 + x3;	out++;
 801e68e:	920e      	str	r2, [sp, #56]	@ 0x38
 801e690:	9227      	str	r2, [sp, #156]	@ 0x9c
	*out = x4 + x5;	out++;
 801e692:	eb04 028c 	add.w	r2, r4, ip, lsl #2
	*out = x4 - x5;	out++;
 801e696:	eba4 048c 	sub.w	r4, r4, ip, lsl #2
	*out = x2 - x3;	out++;
 801e69a:	912a      	str	r1, [sp, #168]	@ 0xa8
	x0 >>= 1;
 801e69c:	1040      	asrs	r0, r0, #1
	x1 >>= 1;
 801e69e:	105b      	asrs	r3, r3, #1
	*out = x4 + x5;	out++;
 801e6a0:	920f      	str	r2, [sp, #60]	@ 0x3c
 801e6a2:	e9cd 2428 	strd	r2, r4, [sp, #160]	@ 0xa0
 801e6a6:	4979      	ldr	r1, [pc, #484]	@ (801e88c <xmp3_IMDCT+0xb5c>)
 801e6a8:	fb81 2b0b 	smull	r2, fp, r1, fp
	a1 = x0 + (x4 >> 1);
 801e6ac:	eb00 0668 	add.w	r6, r0, r8, asr #1
	x0 = a1 + a0;
 801e6b0:	eb06 044b 	add.w	r4, r6, fp, lsl #1
	a2 = x0 - x4;
 801e6b4:	eba0 0008 	sub.w	r0, r0, r8
	x4 = a1 - a0;
 801e6b8:	eba6 064b 	sub.w	r6, r6, fp, lsl #1
 801e6bc:	fb81 2909 	smull	r2, r9, r1, r9
	a1 = x1 + (x5 >> 1);
 801e6c0:	6c2a      	ldr	r2, [r5, #64]	@ 0x40
 801e6c2:	eb03 0262 	add.w	r2, r3, r2, asr #1
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801e6c6:	eb02 0149 	add.w	r1, r2, r9, lsl #1
	a0 = MULSHIFT32(c3_0, x3) << 1;
 801e6ca:	ea4f 0949 	mov.w	r9, r9, lsl #1
 801e6ce:	fb87 c101 	smull	ip, r1, r7, r1
	a2 = x1 - x5;
 801e6d2:	6c2f      	ldr	r7, [r5, #64]	@ 0x40
	x1 = MULSHIFT32(c6[0], a1 + a0) << 2;			
 801e6d4:	0089      	lsls	r1, r1, #2
	a2 = x1 - x5;
 801e6d6:	1bdb      	subs	r3, r3, r7
 801e6d8:	4f6e      	ldr	r7, [pc, #440]	@ (801e894 <xmp3_IMDCT+0xb64>)
 801e6da:	fb87 c303 	smull	ip, r3, r7, r3
 801e6de:	4f6e      	ldr	r7, [pc, #440]	@ (801e898 <xmp3_IMDCT+0xb68>)
	x5 = MULSHIFT32(c6[2], a1 - a0) << 2;
 801e6e0:	eba2 0c09 	sub.w	ip, r2, r9
	x3 = MULSHIFT32(c6[1], a2) << 2;
 801e6e4:	009b      	lsls	r3, r3, #2
 801e6e6:	fb87 2c0c 	smull	r2, ip, r7, ip
	*out = x0 + x1;	out++;
 801e6ea:	eb04 0e01 	add.w	lr, r4, r1
	*out = x0 - x1;
 801e6ee:	1a64      	subs	r4, r4, r1
 801e6f0:	9431      	str	r4, [sp, #196]	@ 0xc4
	WinPrevious(xPrev, xPrevWin, btPrev);
 801e6f2:	9c07      	ldr	r4, [sp, #28]
 801e6f4:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
	*out = x0 + x1;	out++;
 801e6f6:	f8cd e0b0 	str.w	lr, [sp, #176]	@ 0xb0
	*out = x2 + x3;	out++;
 801e6fa:	18c1      	adds	r1, r0, r3
	*out = x2 - x3;	out++;
 801e6fc:	1ac0      	subs	r0, r0, r3
	*out = x2 + x3;	out++;
 801e6fe:	912d      	str	r1, [sp, #180]	@ 0xb4
	*out = x4 + x5;	out++;
 801e700:	eb06 038c 	add.w	r3, r6, ip, lsl #2
	*out = x2 - x3;	out++;
 801e704:	9030      	str	r0, [sp, #192]	@ 0xc0
	*out = x4 - x5;	out++;
 801e706:	eba6 068c 	sub.w	r6, r6, ip, lsl #2
	WinPrevious(xPrev, xPrevWin, btPrev);
 801e70a:	9803      	ldr	r0, [sp, #12]
 801e70c:	4621      	mov	r1, r4
	*out = x4 - x5;	out++;
 801e70e:	e9cd 362e 	strd	r3, r6, [sp, #184]	@ 0xb8
	WinPrevious(xPrev, xPrevWin, btPrev);
 801e712:	f7ff fa7b 	bl	801dc0c <WinPrevious>
	mOut = 0;
 801e716:	2300      	movs	r3, #0
 801e718:	4960      	ldr	r1, [pc, #384]	@ (801e89c <xmp3_IMDCT+0xb6c>)
 801e71a:	9301      	str	r3, [sp, #4]
 801e71c:	4622      	mov	r2, r4
 801e71e:	a820      	add	r0, sp, #128	@ 0x80
 801e720:	f10d 0b8c 	add.w	fp, sp, #140	@ 0x8c
 801e724:	950a      	str	r5, [sp, #40]	@ 0x28
		yLo = (xPrevWin[ 0+i] << 2);
 801e726:	f852 3b04 	ldr.w	r3, [r2], #4
	__asm__ volatile (
 801e72a:	f04f 0900 	mov.w	r9, #0
 801e72e:	009b      	lsls	r3, r3, #2
 801e730:	ea83 79e3 	eor.w	r9, r3, r3, asr #31
 801e734:	eba9 79e3 	sub.w	r9, r9, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 0+i)*NBANDS] = yLo;
 801e738:	f8ca 3000 	str.w	r3, [sl]
		yLo = (xPrevWin[ 3+i] << 2);
 801e73c:	6893      	ldr	r3, [r2, #8]
 801e73e:	f04f 0c00 	mov.w	ip, #0
 801e742:	009b      	lsls	r3, r3, #2
 801e744:	ea83 7ce3 	eor.w	ip, r3, r3, asr #31
 801e748:	ebac 7ce3 	sub.w	ip, ip, r3, asr #31
		mOut |= FASTABS(yLo);	y[( 3+i)*NBANDS] = yLo;
 801e74c:	f8ca 3180 	str.w	r3, [sl, #384]	@ 0x180
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801e750:	68c3      	ldr	r3, [r0, #12]
 801e752:	461c      	mov	r4, r3
 801e754:	f851 3f04 	ldr.w	r3, [r1, #4]!
 801e758:	fb83 5404 	smull	r5, r4, r3, r4
		yLo = (xPrevWin[ 6+i] << 2) + (MULSHIFT32(wp[0+i], xBuf[3+i]));	
 801e75c:	6953      	ldr	r3, [r2, #20]
	__asm__ volatile (
 801e75e:	2500      	movs	r5, #0
 801e760:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 801e764:	ea84 75e4 	eor.w	r5, r4, r4, asr #31
 801e768:	eba5 75e4 	sub.w	r5, r5, r4, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801e76c:	f8db 3008 	ldr.w	r3, [fp, #8]
		mOut |= FASTABS(yLo);	y[( 6+i)*NBANDS] = yLo;
 801e770:	f8ca 4300 	str.w	r4, [sl, #768]	@ 0x300
 801e774:	461c      	mov	r4, r3
 801e776:	68cb      	ldr	r3, [r1, #12]
 801e778:	fb83 e404 	smull	lr, r4, r3, r4
		yLo = (xPrevWin[ 9+i] << 2) + (MULSHIFT32(wp[3+i], xBuf[5-i]));	
 801e77c:	6a13      	ldr	r3, [r2, #32]
 801e77e:	eb04 0483 	add.w	r4, r4, r3, lsl #2
	__asm__ volatile (
 801e782:	2300      	movs	r3, #0
 801e784:	ea84 73e4 	eor.w	r3, r4, r4, asr #31
 801e788:	eba3 73e4 	sub.w	r3, r3, r4, asr #31
		mOut |= FASTABS(yLo);	y[( 9+i)*NBANDS] = yLo;
 801e78c:	f8ca 4480 	str.w	r4, [sl, #1152]	@ 0x480
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801e790:	f85b 4d04 	ldr.w	r4, [fp, #-4]!
 801e794:	46a6      	mov	lr, r4
 801e796:	698c      	ldr	r4, [r1, #24]
 801e798:	fb84 8e0e 	smull	r8, lr, r4, lr
 801e79c:	6a44      	ldr	r4, [r0, #36]	@ 0x24
 801e79e:	680f      	ldr	r7, [r1, #0]
 801e7a0:	46a0      	mov	r8, r4
 801e7a2:	fb87 4808 	smull	r4, r8, r7, r8
		yLo = (xPrevWin[12+i] << 2) + (MULSHIFT32(wp[6+i], xBuf[2-i]) + MULSHIFT32(wp[0+i], xBuf[(6+3)+i]));	
 801e7a6:	6ad4      	ldr	r4, [r2, #44]	@ 0x2c
 801e7a8:	44c6      	add	lr, r8
 801e7aa:	eb0e 0484 	add.w	r4, lr, r4, lsl #2
	__asm__ volatile (
 801e7ae:	f04f 0e00 	mov.w	lr, #0
 801e7b2:	ea84 7ee4 	eor.w	lr, r4, r4, asr #31
 801e7b6:	ebae 7ee4 	sub.w	lr, lr, r4, asr #31
		mOut |= FASTABS(yLo);	y[(12+i)*NBANDS] = yLo;
 801e7ba:	f8ca 4600 	str.w	r4, [sl, #1536]	@ 0x600
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 801e7be:	6806      	ldr	r6, [r0, #0]
 801e7c0:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
 801e7c2:	3004      	adds	r0, #4
 801e7c4:	fb84 8606 	smull	r8, r6, r4, r6
 801e7c8:	f8db 4024 	ldr.w	r4, [fp, #36]	@ 0x24
 801e7cc:	68cf      	ldr	r7, [r1, #12]
 801e7ce:	46a0      	mov	r8, r4
 801e7d0:	fb87 4808 	smull	r4, r8, r7, r8
		yLo = (xPrevWin[15+i] << 2) + (MULSHIFT32(wp[9+i], xBuf[0+i]) + MULSHIFT32(wp[3+i], xBuf[(6+5)-i]));	
 801e7d4:	6b94      	ldr	r4, [r2, #56]	@ 0x38
 801e7d6:	4446      	add	r6, r8
 801e7d8:	eb06 0684 	add.w	r6, r6, r4, lsl #2
	__asm__ volatile (
 801e7dc:	2400      	movs	r4, #0
 801e7de:	ea86 74e6 	eor.w	r4, r6, r6, asr #31
 801e7e2:	eba4 74e6 	sub.w	r4, r4, r6, asr #31
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801e7e6:	ea49 0c0c 	orr.w	ip, r9, ip
 801e7ea:	ea4c 0c05 	orr.w	ip, ip, r5
 801e7ee:	ea4c 0303 	orr.w	r3, ip, r3
 801e7f2:	ea43 030e 	orr.w	r3, r3, lr
 801e7f6:	4323      	orrs	r3, r4
 801e7f8:	9c01      	ldr	r4, [sp, #4]
 801e7fa:	f8ca 6780 	str.w	r6, [sl, #1920]	@ 0x780
 801e7fe:	431c      	orrs	r4, r3
	for (i = 0; i < 3; i++) {
 801e800:	9b02      	ldr	r3, [sp, #8]
		mOut |= FASTABS(yLo);	y[(15+i)*NBANDS] = yLo;
 801e802:	9401      	str	r4, [sp, #4]
	for (i = 0; i < 3; i++) {
 801e804:	f10a 0a80 	add.w	sl, sl, #128	@ 0x80
 801e808:	4553      	cmp	r3, sl
 801e80a:	d18c      	bne.n	801e726 <xmp3_IMDCT+0x9f6>
		*xPrev++ = xBuf[i] >> 2;
 801e80c:	e9dd 530a 	ldrd	r5, r3, [sp, #40]	@ 0x28
 801e810:	9806      	ldr	r0, [sp, #24]
 801e812:	109b      	asrs	r3, r3, #2
 801e814:	f840 3c24 	str.w	r3, [r0, #-36]
 801e818:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 801e81a:	109b      	asrs	r3, r3, #2
 801e81c:	f840 3c20 	str.w	r3, [r0, #-32]
 801e820:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 801e822:	109b      	asrs	r3, r3, #2
 801e824:	f840 3c1c 	str.w	r3, [r0, #-28]
 801e828:	f1a0 0218 	sub.w	r2, r0, #24
 801e82c:	a92b      	add	r1, sp, #172	@ 0xac
		*xPrev++ = xBuf[i] >> 2;
 801e82e:	f851 3f04 	ldr.w	r3, [r1, #4]!
 801e832:	109b      	asrs	r3, r3, #2
 801e834:	f842 3b04 	str.w	r3, [r2], #4
	for (i = 12; i < 18; i++)
 801e838:	4282      	cmp	r2, r0
 801e83a:	d1f8      	bne.n	801e82e <xmp3_IMDCT+0xafe>
	for (   ; i < bc->nBlocksTotal; i++) {
 801e83c:	f102 0324 	add.w	r3, r2, #36	@ 0x24
 801e840:	9306      	str	r3, [sp, #24]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e842:	9b04      	ldr	r3, [sp, #16]
	for (   ; i < bc->nBlocksTotal; i++) {
 801e844:	9c02      	ldr	r4, [sp, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e846:	9903      	ldr	r1, [sp, #12]
 801e848:	9808      	ldr	r0, [sp, #32]
 801e84a:	461a      	mov	r2, r3
	for (   ; i < bc->nBlocksTotal; i++) {
 801e84c:	3301      	adds	r3, #1
 801e84e:	3404      	adds	r4, #4
 801e850:	9304      	str	r3, [sp, #16]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e852:	9b10      	ldr	r3, [sp, #64]	@ 0x40
	for (   ; i < bc->nBlocksTotal; i++) {
 801e854:	9402      	str	r4, [sp, #8]
	mOut |= FreqInvertRescale(y, xPrev, blockIdx, es);
 801e856:	f7ff f90f 	bl	801da78 <FreqInvertRescale>
 801e85a:	9b05      	ldr	r3, [sp, #20]
 801e85c:	9a01      	ldr	r2, [sp, #4]
 801e85e:	4313      	orrs	r3, r2
		mOut |= IMDCT12x3(xCurr, xPrev, &(y[0][i]), prevWinIdx, i, bc->gbIn);
 801e860:	4303      	orrs	r3, r0
 801e862:	9305      	str	r3, [sp, #20]
	for (   ; i < bc->nBlocksTotal; i++) {
 801e864:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 801e866:	42a3      	cmp	r3, r4
 801e868:	f105 0548 	add.w	r5, r5, #72	@ 0x48
 801e86c:	f47f ae51 	bne.w	801e512 <xmp3_IMDCT+0x7e2>
		xPrev += 9;
 801e870:	e9dd b41c 	ldrd	fp, r4, [sp, #112]	@ 0x70
 801e874:	e9dd 9a15 	ldrd	r9, sl, [sp, #84]	@ 0x54
 801e878:	ebab 0304 	sub.w	r3, fp, r4
 801e87c:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 801e880:	f8dd 8078 	ldr.w	r8, [sp, #120]	@ 0x78
 801e884:	eb0a 0a83 	add.w	sl, sl, r3, lsl #2
 801e888:	e00a      	b.n	801e8a0 <xmp3_IMDCT+0xb70>
 801e88a:	bf00      	nop
 801e88c:	6ed9eba1 	.word	0x6ed9eba1
 801e890:	7ba3751d 	.word	0x7ba3751d
 801e894:	5a82799a 	.word	0x5a82799a
 801e898:	2120fb83 	.word	0x2120fb83
 801e89c:	080387a0 	.word	0x080387a0
	for (   ; i < bc->nBlocksPrev; i++) {
 801e8a0:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 801e8a2:	455b      	cmp	r3, fp
 801e8a4:	f340 80b8 	ble.w	801ea18 <xmp3_IMDCT+0xce8>
 801e8a8:	e9cd 9802 	strd	r9, r8, [sp, #8]
 801e8ac:	ab32      	add	r3, sp, #200	@ 0xc8
 801e8ae:	f8dd 8014 	ldr.w	r8, [sp, #20]
 801e8b2:	9307      	str	r3, [sp, #28]
 801e8b4:	465e      	mov	r6, fp
 801e8b6:	ad44      	add	r5, sp, #272	@ 0x110
 801e8b8:	2400      	movs	r4, #0
		WinPrevious(xPrev, xPrevWin, prevWinIdx);
 801e8ba:	9f07      	ldr	r7, [sp, #28]
 801e8bc:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 801e8be:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 801e8c0:	4639      	mov	r1, r7
 801e8c2:	42b3      	cmp	r3, r6
 801e8c4:	bfc8      	it	gt
 801e8c6:	2200      	movgt	r2, #0
 801e8c8:	4650      	mov	r0, sl
 801e8ca:	f7ff f99f 	bl	801dc0c <WinPrevious>
		for (j = 0; j < 9; j++) {
 801e8ce:	9b02      	ldr	r3, [sp, #8]
		nonZero = 0;
 801e8d0:	f8cd a004 	str.w	sl, [sp, #4]
 801e8d4:	4639      	mov	r1, r7
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 801e8d6:	f346 0900 	sbfx	r9, r6, #0, #1
 801e8da:	f006 0e01 	and.w	lr, r6, #1
 801e8de:	eb03 0786 	add.w	r7, r3, r6, lsl #2
 801e8e2:	f1aa 0c04 	sub.w	ip, sl, #4
		nonZero = 0;
 801e8e6:	2000      	movs	r0, #0
			xp = xPrevWin[2*j+0] << 2;	/* << 2 temp for scaling */
 801e8e8:	680b      	ldr	r3, [r1, #0]
 801e8ea:	ea4f 0a83 	mov.w	sl, r3, lsl #2
			y[2*j+0][i] = xp;
 801e8ee:	f8c7 a000 	str.w	sl, [r7]
 801e8f2:	4622      	mov	r2, r4
 801e8f4:	ea8a 72ea 	eor.w	r2, sl, sl, asr #31
 801e8f8:	eba2 72ea 	sub.w	r2, r2, sl, asr #31
			xp = xPrevWin[2*j+1] << 2;
 801e8fc:	684b      	ldr	r3, [r1, #4]
			xp = (xp ^ (fiBit >> 31)) + (i & 0x01);	
 801e8fe:	ea89 0383 	eor.w	r3, r9, r3, lsl #2
 801e902:	4473      	add	r3, lr
			nonZero |= xp;
 801e904:	ea4a 0a03 	orr.w	sl, sl, r3
 801e908:	ea40 000a 	orr.w	r0, r0, sl
			y[2*j+1][i] = xp;
 801e90c:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 801e910:	46a2      	mov	sl, r4
 801e912:	ea83 7ae3 	eor.w	sl, r3, r3, asr #31
 801e916:	ebaa 7ae3 	sub.w	sl, sl, r3, asr #31
		for (j = 0; j < 9; j++) {
 801e91a:	3108      	adds	r1, #8
			mOut |= FASTABS(xp);
 801e91c:	ea42 020a 	orr.w	r2, r2, sl
		for (j = 0; j < 9; j++) {
 801e920:	42a9      	cmp	r1, r5
			xPrev[j] = 0;
 801e922:	f84c 4f04 	str.w	r4, [ip, #4]!
			mOut |= FASTABS(xp);
 801e926:	ea48 0802 	orr.w	r8, r8, r2
		for (j = 0; j < 9; j++) {
 801e92a:	f507 7780 	add.w	r7, r7, #256	@ 0x100
 801e92e:	d1db      	bne.n	801e8e8 <xmp3_IMDCT+0xbb8>
	for (   ; i < bc->nBlocksPrev; i++) {
 801e930:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 801e932:	f8dd a004 	ldr.w	sl, [sp, #4]
 801e936:	2800      	cmp	r0, #0
 801e938:	bf18      	it	ne
 801e93a:	46b3      	movne	fp, r6
 801e93c:	3601      	adds	r6, #1
 801e93e:	429e      	cmp	r6, r3
		xPrev += 9;
 801e940:	f10a 0a24 	add.w	sl, sl, #36	@ 0x24
	for (   ; i < bc->nBlocksPrev; i++) {
 801e944:	d1b9      	bne.n	801e8ba <xmp3_IMDCT+0xb8a>
 801e946:	f8cd 8014 	str.w	r8, [sp, #20]
 801e94a:	f8dd 9008 	ldr.w	r9, [sp, #8]
 801e94e:	f8dd 800c 	ldr.w	r8, [sp, #12]
	for (   ; i < 32; i++) {
 801e952:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 801e954:	2b1f      	cmp	r3, #31
 801e956:	dc0e      	bgt.n	801e976 <xmp3_IMDCT+0xc46>
 801e958:	eb09 0283 	add.w	r2, r9, r3, lsl #2
 801e95c:	f109 0080 	add.w	r0, r9, #128	@ 0x80
			y[j][i] = 0;
 801e960:	2100      	movs	r1, #0
	for (   ; i < bc->nBlocksPrev; i++) {
 801e962:	2300      	movs	r3, #0
			y[j][i] = 0;
 801e964:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
		for (j = 0; j < 18; j++) 
 801e968:	3320      	adds	r3, #32
 801e96a:	f5b3 7f10 	cmp.w	r3, #576	@ 0x240
 801e96e:	d1f9      	bne.n	801e964 <xmp3_IMDCT+0xc34>
	for (   ; i < 32; i++) {
 801e970:	3204      	adds	r2, #4
 801e972:	4282      	cmp	r2, r0
 801e974:	d1f5      	bne.n	801e962 <xmp3_IMDCT+0xc32>
	if (!x)
 801e976:	9905      	ldr	r1, [sp, #20]
 801e978:	2900      	cmp	r1, #0
 801e97a:	d027      	beq.n	801e9cc <xmp3_IMDCT+0xc9c>
	while (!(x & 0x80000000)) {
 801e97c:	db56      	blt.n	801ea2c <xmp3_IMDCT+0xcfc>
	numZeros = 0;
 801e97e:	2300      	movs	r3, #0
	while (!(x & 0x80000000)) {
 801e980:	0049      	lsls	r1, r1, #1
 801e982:	461a      	mov	r2, r3
		numZeros++;
 801e984:	f103 0301 	add.w	r3, r3, #1
	while (!(x & 0x80000000)) {
 801e988:	d5fa      	bpl.n	801e980 <xmp3_IMDCT+0xc50>
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 801e98a:	e9dd 131a 	ldrd	r1, r3, [sp, #104]	@ 0x68
 801e98e:	440b      	add	r3, r1
 801e990:	e9dd 0117 	ldrd	r0, r1, [sp, #92]	@ 0x5c
 801e994:	011b      	lsls	r3, r3, #4
 801e996:	4401      	add	r1, r0
 801e998:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 801e99c:	9919      	ldr	r1, [sp, #100]	@ 0x64
	mi->numPrevIMDCT[ch] = HybridTransform(hi->huffDecBuf[ch], mi->overBuf[ch], mi->outBuf[ch], &si->sis[gr][ch], &bc);
 801e99e:	f8c8 bb00 	str.w	fp, [r8, #2816]	@ 0xb00
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 801e9a2:	4419      	add	r1, r3
	mi->gb[ch] = bc.gbOut;

	ASSERT(mi->numPrevIMDCT[ch] <= NBANDS);

	/* output has gained 2 int bits */
	return 0;
 801e9a4:	2000      	movs	r0, #0
	mi->prevType[ch] = si->sis[gr][ch].blockType;
 801e9a6:	6bcb      	ldr	r3, [r1, #60]	@ 0x3c
 801e9a8:	f8c8 3b08 	str.w	r3, [r8, #2824]	@ 0xb08
	mi->prevWinSwitch[ch] = bc.currWinSwitch;		/* 0 means not a mixed block (either all short or all long) */
 801e9ac:	9b14      	ldr	r3, [sp, #80]	@ 0x50
 801e9ae:	f8c8 3b10 	str.w	r3, [r8, #2832]	@ 0xb10
	mi->gb[ch] = bc.gbOut;
 801e9b2:	f8c8 2b18 	str.w	r2, [r8, #2840]	@ 0xb18
}
 801e9b6:	b045      	add	sp, #276	@ 0x114
 801e9b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (si->sis[gr][ch].blockType == 2 && si->sis[gr][ch].mixedBlock) {
 801e9bc:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 801e9be:	9304      	str	r3, [sp, #16]
 801e9c0:	b133      	cbz	r3, 801e9d0 <xmp3_IMDCT+0xca0>
		nBfly = bc.nBlocksLong - 1;
 801e9c2:	9b14      	ldr	r3, [sp, #80]	@ 0x50
		bc.nBlocksLong = blockCutoff;	
 801e9c4:	9304      	str	r3, [sp, #16]
		nBfly = bc.nBlocksLong - 1;
 801e9c6:	f103 3cff 	add.w	ip, r3, #4294967295
 801e9ca:	e4e8      	b.n	801e39e <xmp3_IMDCT+0x66e>
 801e9cc:	221f      	movs	r2, #31
 801e9ce:	e7dc      	b.n	801e98a <xmp3_IMDCT+0xc5a>
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801e9d0:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 801e9d2:	980e      	ldr	r0, [sp, #56]	@ 0x38
 801e9d4:	eb0a 0183 	add.w	r1, sl, r3, lsl #2
 801e9d8:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
 801e9dc:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 801e9e0:	f8d1 3200 	ldr.w	r3, [r1, #512]	@ 0x200
 801e9e4:	2b08      	cmp	r3, #8
 801e9e6:	bfb8      	it	lt
 801e9e8:	2308      	movlt	r3, #8
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 801e9ea:	f500 5880 	add.w	r8, r0, #4096	@ 0x1000
	hi->nonZeroBound[ch] = MAX(hi->nonZeroBound[ch], (nBfly * 18) + 8);
 801e9ee:	f8c1 3200 	str.w	r3, [r1, #512]	@ 0x200
	bc.nBlocksTotal = (hi->nonZeroBound[ch] + 17) / 18;
 801e9f2:	3311      	adds	r3, #17
 801e9f4:	fba2 2303 	umull	r2, r3, r2, r3
 801e9f8:	ea4f 0b93 	mov.w	fp, r3, lsr #2
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 801e9fc:	f8d8 3b00 	ldr.w	r3, [r8, #2816]	@ 0xb00
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 801ea00:	9a04      	ldr	r2, [sp, #16]
	bc.nBlocksPrev = mi->numPrevIMDCT[ch];
 801ea02:	9312      	str	r3, [sp, #72]	@ 0x48
	bc.prevType = mi->prevType[ch];
 801ea04:	f8d8 3b08 	ldr.w	r3, [r8, #2824]	@ 0xb08
 801ea08:	930c      	str	r3, [sp, #48]	@ 0x30
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 801ea0a:	f8d8 3b10 	ldr.w	r3, [r8, #2832]	@ 0xb10
 801ea0e:	9309      	str	r3, [sp, #36]	@ 0x24
	bc.currWinSwitch = (si->sis[gr][ch].mixedBlock ? blockCutoff : 0);	/* where WINDOW switches (not nec. transform) */
 801ea10:	9214      	str	r2, [sp, #80]	@ 0x50
	bc.prevWinSwitch = mi->prevWinSwitch[ch];
 801ea12:	4613      	mov	r3, r2
 801ea14:	f7ff bae7 	b.w	801dfe6 <xmp3_IMDCT+0x2b6>
	for (   ; i < bc->nBlocksPrev; i++) {
 801ea18:	f8cd b048 	str.w	fp, [sp, #72]	@ 0x48
 801ea1c:	e799      	b.n	801e952 <xmp3_IMDCT+0xc22>
	for (   ; i < bc->nBlocksTotal; i++) {
 801ea1e:	f8dd b010 	ldr.w	fp, [sp, #16]
 801ea22:	e73d      	b.n	801e8a0 <xmp3_IMDCT+0xb70>
	mOut = 0;
 801ea24:	2300      	movs	r3, #0
	for(i = 0; i < bc->nBlocksLong; i++) {
 801ea26:	e9cd 3304 	strd	r3, r3, [sp, #16]
 801ea2a:	e54f      	b.n	801e4cc <xmp3_IMDCT+0x79c>
 801ea2c:	f04f 32ff 	mov.w	r2, #4294967295
 801ea30:	e7ab      	b.n	801e98a <xmp3_IMDCT+0xc5a>
		return -1;
 801ea32:	f04f 30ff 	mov.w	r0, #4294967295
 801ea36:	e7be      	b.n	801e9b6 <xmp3_IMDCT+0xc86>

0801ea38 <MP3InitDecoder>:
 **************************************************************************************/
HMP3Decoder MP3InitDecoder(void)
{
	MP3DecInfo *mp3DecInfo;

	mp3DecInfo = AllocateBuffers();
 801ea38:	f7fd bd40 	b.w	801c4bc <xmp3_AllocateBuffers>

0801ea3c <MP3FindSyncWord>:
int MP3FindSyncWord(unsigned char *buf, int nBytes)
{
	int i;

	/* find byte-aligned syncword - need 12 (MPEG 1,2) or 11 (MPEG 2.5) matching bits */
	for (i = 0; i < nBytes - 1; i++) {
 801ea3c:	2901      	cmp	r1, #1
 801ea3e:	dd13      	ble.n	801ea68 <MP3FindSyncWord+0x2c>
 801ea40:	1e82      	subs	r2, r0, #2
 801ea42:	1e43      	subs	r3, r0, #1
 801ea44:	4411      	add	r1, r2
 801ea46:	e001      	b.n	801ea4c <MP3FindSyncWord+0x10>
 801ea48:	428b      	cmp	r3, r1
 801ea4a:	d00d      	beq.n	801ea68 <MP3FindSyncWord+0x2c>
 801ea4c:	469c      	mov	ip, r3
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 801ea4e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 801ea52:	2aff      	cmp	r2, #255	@ 0xff
 801ea54:	d1f8      	bne.n	801ea48 <MP3FindSyncWord+0xc>
 801ea56:	785a      	ldrb	r2, [r3, #1]
 801ea58:	f002 02e0 	and.w	r2, r2, #224	@ 0xe0
 801ea5c:	2ae0      	cmp	r2, #224	@ 0xe0
 801ea5e:	d1f3      	bne.n	801ea48 <MP3FindSyncWord+0xc>
 801ea60:	f1c0 0001 	rsb	r0, r0, #1
 801ea64:	4460      	add	r0, ip
 801ea66:	4770      	bx	lr
			return i;
	}
	
	return -1;
 801ea68:	f04f 30ff 	mov.w	r0, #4294967295
}
 801ea6c:	4770      	bx	lr
 801ea6e:	bf00      	nop

0801ea70 <MP3GetNextFrameInfo>:
 **************************************************************************************/
int MP3GetNextFrameInfo(HMP3Decoder hMP3Decoder, MP3FrameInfo *mp3FrameInfo, unsigned char *buf)
{
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;

	if (!mp3DecInfo)
 801ea70:	b348      	cbz	r0, 801eac6 <MP3GetNextFrameInfo+0x56>
{
 801ea72:	b538      	push	{r3, r4, r5, lr}
 801ea74:	460c      	mov	r4, r1
 801ea76:	4611      	mov	r1, r2
 801ea78:	4605      	mov	r5, r0
		return ERR_MP3_NULL_POINTER;

	if (UnpackFrameHeader(mp3DecInfo, buf) == -1 || mp3DecInfo->layer != 3)
 801ea7a:	f7fd faf7 	bl	801c06c <xmp3_UnpackFrameHeader>
 801ea7e:	3001      	adds	r0, #1
 801ea80:	d01e      	beq.n	801eac0 <MP3GetNextFrameInfo+0x50>
 801ea82:	f8d5 27d0 	ldr.w	r2, [r5, #2000]	@ 0x7d0
 801ea86:	2a03      	cmp	r2, #3
 801ea88:	d11a      	bne.n	801eac0 <MP3GetNextFrameInfo+0x50>
		mp3FrameInfo->bitrate = mp3DecInfo->bitrate;
 801ea8a:	f8d5 37b8 	ldr.w	r3, [r5, #1976]	@ 0x7b8
 801ea8e:	f8d5 17bc 	ldr.w	r1, [r5, #1980]	@ 0x7bc
 801ea92:	e9c4 3100 	strd	r3, r1, [r4]
		mp3FrameInfo->samprate = mp3DecInfo->samprate;
 801ea96:	f8d5 37c0 	ldr.w	r3, [r5, #1984]	@ 0x7c0
 801ea9a:	60a3      	str	r3, [r4, #8]
		mp3FrameInfo->bitsPerSample = 16;
 801ea9c:	2310      	movs	r3, #16
 801ea9e:	60e3      	str	r3, [r4, #12]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 801eaa0:	f895 37d4 	ldrb.w	r3, [r5, #2004]	@ 0x7d4
		mp3FrameInfo->version = mp3DecInfo->version;
 801eaa4:	e9c4 2305 	strd	r2, r3, [r4, #20]
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 801eaa8:	4a08      	ldr	r2, [pc, #32]	@ (801eacc <MP3GetNextFrameInfo+0x5c>)
 801eaaa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801eaae:	eb02 0343 	add.w	r3, r2, r3, lsl #1
		return ERR_MP3_INVALID_FRAMEHEADER;

	MP3GetLastFrameInfo(mp3DecInfo, mp3FrameInfo);

	return ERR_MP3_NONE;
 801eab2:	2000      	movs	r0, #0
		mp3FrameInfo->outputSamps = mp3DecInfo->nChans * (int)samplesPerFrameTab[mp3DecInfo->version][mp3DecInfo->layer - 1];
 801eab4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801eab8:	fb01 f303 	mul.w	r3, r1, r3
 801eabc:	6123      	str	r3, [r4, #16]
}
 801eabe:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_MP3_INVALID_FRAMEHEADER;
 801eac0:	f06f 0005 	mvn.w	r0, #5
}
 801eac4:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_MP3_NULL_POINTER;
 801eac6:	f06f 0004 	mvn.w	r0, #4
}
 801eaca:	4770      	bx	lr
 801eacc:	08037f2c 	.word	0x08037f2c

0801ead0 <MP3Decode>:
 *
 * Notes:       switching useSize on and off between frames in the same stream 
 *                is not supported (bit reservoir is not maintained if useSize on)
 **************************************************************************************/
int MP3Decode(HMP3Decoder hMP3Decoder, unsigned char **inbuf, int *bytesLeft, short *outbuf, int useSize)
{
 801ead0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ead4:	b089      	sub	sp, #36	@ 0x24
 801ead6:	9304      	str	r3, [sp, #16]
	int prevBitOffset, sfBlockBits, huffBlockBits;
	unsigned char *mainPtr;
	MP3DecInfo *mp3DecInfo = (MP3DecInfo *)hMP3Decoder;
//	ULONG32 ulTime;
//	StartYield(&ulTime);
	if (!mp3DecInfo)
 801ead8:	2800      	cmp	r0, #0
 801eada:	f000 81b7 	beq.w	801ee4c <MP3Decode+0x37c>
		return ERR_MP3_NULL_POINTER;

	/* unpack frame header */
	fhBytes = UnpackFrameHeader(mp3DecInfo, *inbuf);
 801eade:	460d      	mov	r5, r1
 801eae0:	6809      	ldr	r1, [r1, #0]
 801eae2:	4616      	mov	r6, r2
 801eae4:	4681      	mov	r9, r0
 801eae6:	f7fd fac1 	bl	801c06c <xmp3_UnpackFrameHeader>
	if (fhBytes < 0)	
 801eaea:	1e07      	subs	r7, r0, #0
 801eaec:	f2c0 81ab 	blt.w	801ee46 <MP3Decode+0x376>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
	*inbuf += fhBytes;
 801eaf0:	6829      	ldr	r1, [r5, #0]
 801eaf2:	4439      	add	r1, r7
 801eaf4:	6029      	str	r1, [r5, #0]
	
	/* unpack side info */
	siBytes = UnpackSideInfo(mp3DecInfo, *inbuf);
 801eaf6:	4648      	mov	r0, r9
 801eaf8:	f7fd fba4 	bl	801c244 <xmp3_UnpackSideInfo>
	if (siBytes < 0) {
 801eafc:	1e02      	subs	r2, r0, #0
 801eafe:	f2c0 81e2 	blt.w	801eec6 <MP3Decode+0x3f6>
		MP3ClearBadFrame(mp3DecInfo, outbuf);
		return ERR_MP3_INVALID_SIDEINFO;
	}
	*inbuf += siBytes;
	*bytesLeft -= (fhBytes + siBytes);
 801eb02:	6833      	ldr	r3, [r6, #0]
	*inbuf += siBytes;
 801eb04:	6828      	ldr	r0, [r5, #0]
	*bytesLeft -= (fhBytes + siBytes);
 801eb06:	18b9      	adds	r1, r7, r2
 801eb08:	1a59      	subs	r1, r3, r1
	*inbuf += siBytes;
 801eb0a:	eb00 0e02 	add.w	lr, r0, r2
 801eb0e:	f8c5 e000 	str.w	lr, [r5]
	*bytesLeft -= (fhBytes + siBytes);
 801eb12:	6031      	str	r1, [r6, #0]
	
	/* if free mode, need to calculate bitrate and nSlots manually, based on frame size */
	if (mp3DecInfo->bitrate == 0 || mp3DecInfo->freeBitrateFlag) {
 801eb14:	f8d9 37b8 	ldr.w	r3, [r9, #1976]	@ 0x7b8
 801eb18:	2b00      	cmp	r3, #0
 801eb1a:	f000 8086 	beq.w	801ec2a <MP3Decode+0x15a>
 801eb1e:	f8d9 37b0 	ldr.w	r3, [r9, #1968]	@ 0x7b0
 801eb22:	b143      	cbz	r3, 801eb36 <MP3Decode+0x66>
				return ERR_MP3_FREE_BITRATE_SYNC;
			}
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
		}
		mp3DecInfo->nSlots = mp3DecInfo->freeBitrateSlots + CheckPadBit(mp3DecInfo);	/* add pad byte, if required */
 801eb24:	f8d9 47b4 	ldr.w	r4, [r9, #1972]	@ 0x7b4
 801eb28:	4648      	mov	r0, r9
 801eb2a:	f7fd fa93 	bl	801c054 <xmp3_CheckPadBit>
 801eb2e:	4420      	add	r0, r4
 801eb30:	f8c9 07cc 	str.w	r0, [r9, #1996]	@ 0x7cc
	 *      from the bit reservoir (in previous frames) to AFTER the sync word and side info
	 *  - calling function should set mainDataBegin to 0, and tell us exactly how large this
	 *      frame is (in bytesLeft)
	 */
	if (useSize) {
		mp3DecInfo->nSlots = *bytesLeft;
 801eb34:	6831      	ldr	r1, [r6, #0]
	if (useSize) {
 801eb36:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 801eb38:	2b00      	cmp	r3, #0
 801eb3a:	f000 80e6 	beq.w	801ed0a <MP3Decode+0x23a>
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 801eb3e:	f8d9 37d8 	ldr.w	r3, [r9, #2008]	@ 0x7d8
		mp3DecInfo->nSlots = *bytesLeft;
 801eb42:	f8c9 17cc 	str.w	r1, [r9, #1996]	@ 0x7cc
		if (mp3DecInfo->mainDataBegin != 0 || mp3DecInfo->nSlots <= 0) {
 801eb46:	2b00      	cmp	r3, #0
 801eb48:	f040 816c 	bne.w	801ee24 <MP3Decode+0x354>
 801eb4c:	2900      	cmp	r1, #0
 801eb4e:	f340 8169 	ble.w	801ee24 <MP3Decode+0x354>
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_FRAMEHEADER;
		}

		/* can operate in-place on reformatted frames */
		mp3DecInfo->mainDataBytes = mp3DecInfo->nSlots;
 801eb52:	f8c9 17dc 	str.w	r1, [r9, #2012]	@ 0x7dc
		mainPtr = *inbuf;
 801eb56:	f8d5 8000 	ldr.w	r8, [r5]
		*inbuf += mp3DecInfo->nSlots;
		*bytesLeft -= (mp3DecInfo->nSlots);
 801eb5a:	6833      	ldr	r3, [r6, #0]
 801eb5c:	1a5b      	subs	r3, r3, r1
		*inbuf += mp3DecInfo->nSlots;
 801eb5e:	4441      	add	r1, r8
 801eb60:	6029      	str	r1, [r5, #0]
		*bytesLeft -= (mp3DecInfo->nSlots);
 801eb62:	6033      	str	r3, [r6, #0]
	}
	bitOffset = 0;
	mainBits = mp3DecInfo->mainDataBytes * 8;

	/* decode one complete frame */
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 801eb64:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
	mainBits = mp3DecInfo->mainDataBytes * 8;
 801eb68:	f8d9 47dc 	ldr.w	r4, [r9, #2012]	@ 0x7dc
	bitOffset = 0;
 801eb6c:	2300      	movs	r3, #0
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 801eb6e:	429a      	cmp	r2, r3
	bitOffset = 0;
 801eb70:	9307      	str	r3, [sp, #28]
	mainBits = mp3DecInfo->mainDataBytes * 8;
 801eb72:	ea4f 04c4 	mov.w	r4, r4, lsl #3
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 801eb76:	f340 8153 	ble.w	801ee20 <MP3Decode+0x350>
 801eb7a:	9303      	str	r3, [sp, #12]
 801eb7c:	f509 65fc 	add.w	r5, r9, #2016	@ 0x7e0
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801eb80:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801eb84:	2b00      	cmp	r3, #0
 801eb86:	f340 80ea 	ble.w	801ed5e <MP3Decode+0x28e>
 801eb8a:	f04f 0a00 	mov.w	sl, #0
 801eb8e:	4657      	mov	r7, sl
			/* unpack scale factors and compute size of scale factor block */
			prevBitOffset = bitOffset;
 801eb90:	9e07      	ldr	r6, [sp, #28]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801eb92:	9505      	str	r5, [sp, #20]
			prevBitOffset = bitOffset;
 801eb94:	46ab      	mov	fp, r5
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801eb96:	46c2      	mov	sl, r8
 801eb98:	e018      	b.n	801ebcc <MP3Decode+0xfc>
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
			mainPtr += offset;
			mainBits -= sfBlockBits;

			if (offset < 0 || mainBits < huffBlockBits) {
 801eb9a:	45a6      	cmp	lr, r4
 801eb9c:	dc2f      	bgt.n	801ebfe <MP3Decode+0x12e>
				return ERR_MP3_INVALID_SCALEFACT;
			}

			/* decode Huffman code words */
			prevBitOffset = bitOffset;
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 801eb9e:	9803      	ldr	r0, [sp, #12]
 801eba0:	9701      	str	r7, [sp, #4]
 801eba2:	9000      	str	r0, [sp, #0]
 801eba4:	4648      	mov	r0, r9
 801eba6:	f7fe fb81 	bl	801d2ac <xmp3_DecodeHuffman>
			if (offset < 0) {
 801ebaa:	1e01      	subs	r1, r0, #0
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801ebac:	f107 0701 	add.w	r7, r7, #1
				MP3ClearBadFrame(mp3DecInfo, outbuf);
				return ERR_MP3_INVALID_HUFFCODES;
			}

			mainPtr += offset;
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 801ebb0:	ebc5 05c1 	rsb	r5, r5, r1, lsl #3
			mainPtr += offset;
 801ebb4:	448a      	add	sl, r1
			if (offset < 0) {
 801ebb6:	f2c0 8103 	blt.w	801edc0 <MP3Decode+0x2f0>
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 801ebba:	9e07      	ldr	r6, [sp, #28]
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801ebbc:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 801ebc0:	4435      	add	r5, r6
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801ebc2:	42bb      	cmp	r3, r7
			mainBits -= (8*offset - prevBitOffset + bitOffset);
 801ebc4:	eba8 0405 	sub.w	r4, r8, r5
		for (ch = 0; ch < mp3DecInfo->nChans; ch++) {
 801ebc8:	f340 80c7 	ble.w	801ed5a <MP3Decode+0x28a>
			offset = UnpackScaleFactors(mp3DecInfo, mainPtr, &bitOffset, mainBits, gr, ch);
 801ebcc:	9803      	ldr	r0, [sp, #12]
 801ebce:	9000      	str	r0, [sp, #0]
 801ebd0:	4651      	mov	r1, sl
 801ebd2:	4623      	mov	r3, r4
 801ebd4:	aa07      	add	r2, sp, #28
 801ebd6:	9701      	str	r7, [sp, #4]
 801ebd8:	4648      	mov	r0, r9
 801ebda:	f000 fde3 	bl	801f7a4 <xmp3_UnpackScaleFactors>
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 801ebde:	9d07      	ldr	r5, [sp, #28]
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 801ebe0:	f85b eb04 	ldr.w	lr, [fp], #4
			sfBlockBits = 8*offset - prevBitOffset + bitOffset;
 801ebe4:	ebc6 06c0 	rsb	r6, r6, r0, lsl #3
 801ebe8:	eb06 0c05 	add.w	ip, r6, r5
			mainPtr += offset;
 801ebec:	4482      	add	sl, r0
			if (offset < 0 || mainBits < huffBlockBits) {
 801ebee:	2800      	cmp	r0, #0
			offset = DecodeHuffman(mp3DecInfo, mainPtr, &bitOffset, huffBlockBits, gr, ch);
 801ebf0:	aa07      	add	r2, sp, #28
 801ebf2:	4651      	mov	r1, sl
			huffBlockBits = mp3DecInfo->part23Length[gr][ch] - sfBlockBits;
 801ebf4:	ebae 030c 	sub.w	r3, lr, ip
			mainBits -= sfBlockBits;
 801ebf8:	eba4 080c 	sub.w	r8, r4, ip
			if (offset < 0 || mainBits < huffBlockBits) {
 801ebfc:	dacd      	bge.n	801eb9a <MP3Decode+0xca>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ebfe:	f8d9 27c8 	ldr.w	r2, [r9, #1992]	@ 0x7c8
 801ec02:	f8d9 17c4 	ldr.w	r1, [r9, #1988]	@ 0x7c4
 801ec06:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801ec0a:	fb01 f202 	mul.w	r2, r1, r2
 801ec0e:	fb03 f202 	mul.w	r2, r3, r2
 801ec12:	2a00      	cmp	r2, #0
 801ec14:	dd04      	ble.n	801ec20 <MP3Decode+0x150>
		outbuf[i] = 0;
 801ec16:	9804      	ldr	r0, [sp, #16]
 801ec18:	0052      	lsls	r2, r2, #1
 801ec1a:	2100      	movs	r1, #0
 801ec1c:	f003 fa72 	bl	8022104 <memset>
				return ERR_MP3_INVALID_SCALEFACT;
 801ec20:	f06f 0007 	mvn.w	r0, #7
			MP3ClearBadFrame(mp3DecInfo, outbuf);
			return ERR_MP3_INVALID_SUBBAND;			
		}
	}
	return ERR_MP3_NONE;
}
 801ec24:	b009      	add	sp, #36	@ 0x24
 801ec26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!mp3DecInfo->freeBitrateFlag) {
 801ec2a:	f8d9 37b0 	ldr.w	r3, [r9, #1968]	@ 0x7b0
 801ec2e:	2b00      	cmp	r3, #0
 801ec30:	f47f af78 	bne.w	801eb24 <MP3Decode+0x54>
			mp3DecInfo->freeBitrateFlag = 1;
 801ec34:	2301      	movs	r3, #1
 801ec36:	f8c9 37b0 	str.w	r3, [r9, #1968]	@ 0x7b0
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 801ec3a:	6831      	ldr	r1, [r6, #0]
	for (i = 0; i < nBytes - 1; i++) {
 801ec3c:	2901      	cmp	r1, #1
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 801ec3e:	eba0 0c07 	sub.w	ip, r0, r7
	unsigned char *bufPtr = buf;
 801ec42:	4673      	mov	r3, lr
	for (i = 0; i < nBytes - 1; i++) {
 801ec44:	f101 3aff 	add.w	sl, r1, #4294967295
 801ec48:	dd1d      	ble.n	801ec86 <MP3Decode+0x1b6>
 801ec4a:	2400      	movs	r4, #0
 801ec4c:	e002      	b.n	801ec54 <MP3Decode+0x184>
 801ec4e:	3401      	adds	r4, #1
 801ec50:	4554      	cmp	r4, sl
 801ec52:	d018      	beq.n	801ec86 <MP3Decode+0x1b6>
		if ( (buf[i+0] & SYNCWORDH) == SYNCWORDH && (buf[i+1] & SYNCWORDL) == SYNCWORDL )
 801ec54:	4618      	mov	r0, r3
 801ec56:	f813 8b01 	ldrb.w	r8, [r3], #1
 801ec5a:	f1b8 0fff 	cmp.w	r8, #255	@ 0xff
 801ec5e:	d1f6      	bne.n	801ec4e <MP3Decode+0x17e>
 801ec60:	f890 8001 	ldrb.w	r8, [r0, #1]
 801ec64:	f008 08e0 	and.w	r8, r8, #224	@ 0xe0
 801ec68:	f1b8 0fe0 	cmp.w	r8, #224	@ 0xe0
 801ec6c:	d1ef      	bne.n	801ec4e <MP3Decode+0x17e>
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 801ec6e:	f89c 3000 	ldrb.w	r3, [ip]
 801ec72:	2bff      	cmp	r3, #255	@ 0xff
 801ec74:	d01f      	beq.n	801ecb6 <MP3Decode+0x1e6>
		nBytes -= (offset + 3);
 801ec76:	3403      	adds	r4, #3
 801ec78:	1b09      	subs	r1, r1, r4
	for (i = 0; i < nBytes - 1; i++) {
 801ec7a:	2901      	cmp	r1, #1
		bufPtr += 3;
 801ec7c:	f100 0303 	add.w	r3, r0, #3
	for (i = 0; i < nBytes - 1; i++) {
 801ec80:	f101 3aff 	add.w	sl, r1, #4294967295
 801ec84:	dce1      	bgt.n	801ec4a <MP3Decode+0x17a>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ec86:	f8d9 37c8 	ldr.w	r3, [r9, #1992]	@ 0x7c8
 801ec8a:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 801ec8e:	f04f 31ff 	mov.w	r1, #4294967295
 801ec92:	f8c9 17b4 	str.w	r1, [r9, #1972]	@ 0x7b4
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ec96:	fb02 f103 	mul.w	r1, r2, r3
 801ec9a:	f8d9 27bc 	ldr.w	r2, [r9, #1980]	@ 0x7bc
 801ec9e:	fb01 f202 	mul.w	r2, r1, r2
 801eca2:	2a00      	cmp	r2, #0
 801eca4:	dd04      	ble.n	801ecb0 <MP3Decode+0x1e0>
		outbuf[i] = 0;
 801eca6:	9804      	ldr	r0, [sp, #16]
 801eca8:	0052      	lsls	r2, r2, #1
 801ecaa:	2100      	movs	r1, #0
 801ecac:	f003 fa2a 	bl	8022104 <memset>
				return ERR_MP3_FREE_BITRATE_SYNC;
 801ecb0:	f06f 0002 	mvn.w	r0, #2
 801ecb4:	e7b6      	b.n	801ec24 <MP3Decode+0x154>
		} else if ( (bufPtr[0] == firstFH[0]) && (bufPtr[1] == firstFH[1]) && ((bufPtr[2] & 0xfc) == (firstFH[2] & 0xfc)) ) {
 801ecb6:	f890 8001 	ldrb.w	r8, [r0, #1]
 801ecba:	f89c 3001 	ldrb.w	r3, [ip, #1]
 801ecbe:	4598      	cmp	r8, r3
 801ecc0:	d1d9      	bne.n	801ec76 <MP3Decode+0x1a6>
 801ecc2:	f89c 8002 	ldrb.w	r8, [ip, #2]
 801ecc6:	7883      	ldrb	r3, [r0, #2]
 801ecc8:	ea88 0303 	eor.w	r3, r8, r3
 801eccc:	2b03      	cmp	r3, #3
 801ecce:	d8d2      	bhi.n	801ec76 <MP3Decode+0x1a6>
			if ((firstFH[2] >> 1) & 0x01)
 801ecd0:	f018 0f02 	tst.w	r8, #2
				bufPtr--;
 801ecd4:	bf18      	it	ne
 801ecd6:	f100 30ff 	addne.w	r0, r0, #4294967295
			return bufPtr - buf;
 801ecda:	eba0 040e 	sub.w	r4, r0, lr
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ecde:	f8d9 37c8 	ldr.w	r3, [r9, #1992]	@ 0x7c8
 801ece2:	f8d9 17c4 	ldr.w	r1, [r9, #1988]	@ 0x7c4
			mp3DecInfo->freeBitrateSlots = MP3FindFreeSync(*inbuf, *inbuf - fhBytes - siBytes, *bytesLeft);
 801ece6:	f8c9 47b4 	str.w	r4, [r9, #1972]	@ 0x7b4
			if (mp3DecInfo->freeBitrateSlots < 0) {
 801ecea:	2c00      	cmp	r4, #0
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ecec:	fb03 f101 	mul.w	r1, r3, r1
			if (mp3DecInfo->freeBitrateSlots < 0) {
 801ecf0:	dbd3      	blt.n	801ec9a <MP3Decode+0x1ca>
			freeFrameBytes = mp3DecInfo->freeBitrateSlots + fhBytes + siBytes;
 801ecf2:	193b      	adds	r3, r7, r4
 801ecf4:	4413      	add	r3, r2
			mp3DecInfo->bitrate = (freeFrameBytes * mp3DecInfo->samprate * 8) / (mp3DecInfo->nGrans * mp3DecInfo->nGranSamps);
 801ecf6:	f8d9 27c0 	ldr.w	r2, [r9, #1984]	@ 0x7c0
 801ecfa:	fb02 f303 	mul.w	r3, r2, r3
 801ecfe:	00db      	lsls	r3, r3, #3
 801ed00:	fb93 f3f1 	sdiv	r3, r3, r1
 801ed04:	f8c9 37b8 	str.w	r3, [r9, #1976]	@ 0x7b8
 801ed08:	e70e      	b.n	801eb28 <MP3Decode+0x58>
		if (mp3DecInfo->nSlots > *bytesLeft) {
 801ed0a:	f8d9 37cc 	ldr.w	r3, [r9, #1996]	@ 0x7cc
 801ed0e:	428b      	cmp	r3, r1
 801ed10:	f300 8101 	bgt.w	801ef16 <MP3Decode+0x446>
		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
 801ed14:	f8d9 07dc 	ldr.w	r0, [r9, #2012]	@ 0x7dc
 801ed18:	f8d9 27d8 	ldr.w	r2, [r9, #2008]	@ 0x7d8
 801ed1c:	4290      	cmp	r0, r2
			memmove(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
 801ed1e:	f109 081c 	add.w	r8, r9, #28
		if (mp3DecInfo->mainDataBytes >= mp3DecInfo->mainDataBegin) {
 801ed22:	f2c0 8096 	blt.w	801ee52 <MP3Decode+0x382>
			memmove(mp3DecInfo->mainBuf, mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes - mp3DecInfo->mainDataBegin, mp3DecInfo->mainDataBegin);
 801ed26:	1a81      	subs	r1, r0, r2
 801ed28:	4441      	add	r1, r8
 801ed2a:	4640      	mov	r0, r8
 801ed2c:	f003 f9d0 	bl	80220d0 <memmove>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBegin, *inbuf, mp3DecInfo->nSlots);
 801ed30:	f8d9 07d8 	ldr.w	r0, [r9, #2008]	@ 0x7d8
 801ed34:	f8d9 27cc 	ldr.w	r2, [r9, #1996]	@ 0x7cc
 801ed38:	6829      	ldr	r1, [r5, #0]
 801ed3a:	4440      	add	r0, r8
 801ed3c:	f003 fab3 	bl	80222a6 <memcpy>
			mp3DecInfo->mainDataBytes = mp3DecInfo->mainDataBegin + mp3DecInfo->nSlots;
 801ed40:	f8d9 27cc 	ldr.w	r2, [r9, #1996]	@ 0x7cc
 801ed44:	f8d9 37d8 	ldr.w	r3, [r9, #2008]	@ 0x7d8
 801ed48:	4413      	add	r3, r2
 801ed4a:	f8c9 37dc 	str.w	r3, [r9, #2012]	@ 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 801ed4e:	682b      	ldr	r3, [r5, #0]
 801ed50:	4413      	add	r3, r2
 801ed52:	602b      	str	r3, [r5, #0]
			*bytesLeft -= (mp3DecInfo->nSlots);
 801ed54:	6833      	ldr	r3, [r6, #0]
 801ed56:	1a9b      	subs	r3, r3, r2
			mainPtr = mp3DecInfo->mainBuf;
 801ed58:	e703      	b.n	801eb62 <MP3Decode+0x92>
 801ed5a:	9d05      	ldr	r5, [sp, #20]
 801ed5c:	46d0      	mov	r8, sl
		if (Dequantize(mp3DecInfo, gr) < 0) {
 801ed5e:	9903      	ldr	r1, [sp, #12]
 801ed60:	4648      	mov	r0, r9
 801ed62:	f7fd ff1f 	bl	801cba4 <xmp3_Dequantize>
 801ed66:	2800      	cmp	r0, #0
 801ed68:	f2c0 8099 	blt.w	801ee9e <MP3Decode+0x3ce>
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 801ed6c:	f8d9 17bc 	ldr.w	r1, [r9, #1980]	@ 0x7bc
 801ed70:	2900      	cmp	r1, #0
 801ed72:	dd3b      	ble.n	801edec <MP3Decode+0x31c>
 801ed74:	9f03      	ldr	r7, [sp, #12]
 801ed76:	2600      	movs	r6, #0
 801ed78:	e003      	b.n	801ed82 <MP3Decode+0x2b2>
 801ed7a:	f8d9 17bc 	ldr.w	r1, [r9, #1980]	@ 0x7bc
 801ed7e:	42b1      	cmp	r1, r6
 801ed80:	dd34      	ble.n	801edec <MP3Decode+0x31c>
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 801ed82:	4632      	mov	r2, r6
 801ed84:	4639      	mov	r1, r7
 801ed86:	4648      	mov	r0, r9
 801ed88:	f7fe ffd2 	bl	801dd30 <xmp3_IMDCT>
 801ed8c:	2800      	cmp	r0, #0
		for (ch = 0; ch < mp3DecInfo->nChans; ch++)
 801ed8e:	f106 0601 	add.w	r6, r6, #1
			if (IMDCT(mp3DecInfo, gr, ch) < 0) {
 801ed92:	daf2      	bge.n	801ed7a <MP3Decode+0x2aa>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ed94:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
 801ed98:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	@ 0x7c8
 801ed9c:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801eda0:	fb01 f202 	mul.w	r2, r1, r2
 801eda4:	fb03 f202 	mul.w	r2, r3, r2
 801eda8:	2a00      	cmp	r2, #0
 801edaa:	dd04      	ble.n	801edb6 <MP3Decode+0x2e6>
		outbuf[i] = 0;
 801edac:	9804      	ldr	r0, [sp, #16]
 801edae:	0052      	lsls	r2, r2, #1
 801edb0:	2100      	movs	r1, #0
 801edb2:	f003 f9a7 	bl	8022104 <memset>
				return ERR_MP3_INVALID_IMDCT;			
 801edb6:	f06f 000a 	mvn.w	r0, #10
}
 801edba:	b009      	add	sp, #36	@ 0x24
 801edbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801edc0:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
 801edc4:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	@ 0x7c8
 801edc8:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801edcc:	fb01 f202 	mul.w	r2, r1, r2
 801edd0:	fb03 f202 	mul.w	r2, r3, r2
 801edd4:	2a00      	cmp	r2, #0
 801edd6:	dd04      	ble.n	801ede2 <MP3Decode+0x312>
		outbuf[i] = 0;
 801edd8:	9804      	ldr	r0, [sp, #16]
 801edda:	0052      	lsls	r2, r2, #1
 801eddc:	2100      	movs	r1, #0
 801edde:	f003 f991 	bl	8022104 <memset>
				return ERR_MP3_INVALID_HUFFCODES;
 801ede2:	f06f 0008 	mvn.w	r0, #8
}
 801ede6:	b009      	add	sp, #36	@ 0x24
 801ede8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (Subband(mp3DecInfo, outbuf + gr*mp3DecInfo->nGranSamps*mp3DecInfo->nChans) < 0) {
 801edec:	9b03      	ldr	r3, [sp, #12]
 801edee:	f8d9 27c8 	ldr.w	r2, [r9, #1992]	@ 0x7c8
 801edf2:	fb03 f202 	mul.w	r2, r3, r2
 801edf6:	9b04      	ldr	r3, [sp, #16]
 801edf8:	fb02 f101 	mul.w	r1, r2, r1
 801edfc:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 801ee00:	4648      	mov	r0, r9
 801ee02:	f001 fb89 	bl	8020518 <xmp3_Subband>
 801ee06:	2800      	cmp	r0, #0
 801ee08:	db71      	blt.n	801eeee <MP3Decode+0x41e>
	for (gr = 0; gr < mp3DecInfo->nGrans; gr++) {
 801ee0a:	9b03      	ldr	r3, [sp, #12]
 801ee0c:	3301      	adds	r3, #1
 801ee0e:	461a      	mov	r2, r3
 801ee10:	9303      	str	r3, [sp, #12]
 801ee12:	f8d9 37c4 	ldr.w	r3, [r9, #1988]	@ 0x7c4
 801ee16:	4293      	cmp	r3, r2
 801ee18:	f105 0508 	add.w	r5, r5, #8
 801ee1c:	f73f aeb0 	bgt.w	801eb80 <MP3Decode+0xb0>
	return ERR_MP3_NONE;
 801ee20:	2000      	movs	r0, #0
 801ee22:	e6ff      	b.n	801ec24 <MP3Decode+0x154>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ee24:	f8d9 27c8 	ldr.w	r2, [r9, #1992]	@ 0x7c8
 801ee28:	f8d9 17c4 	ldr.w	r1, [r9, #1988]	@ 0x7c4
 801ee2c:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801ee30:	fb01 f202 	mul.w	r2, r1, r2
 801ee34:	fb03 f202 	mul.w	r2, r3, r2
 801ee38:	2a00      	cmp	r2, #0
 801ee3a:	dd04      	ble.n	801ee46 <MP3Decode+0x376>
		outbuf[i] = 0;
 801ee3c:	9804      	ldr	r0, [sp, #16]
 801ee3e:	0052      	lsls	r2, r2, #1
 801ee40:	2100      	movs	r1, #0
 801ee42:	f003 f95f 	bl	8022104 <memset>
		return ERR_MP3_INVALID_FRAMEHEADER;		/* don't clear outbuf since we don't know size (failed to parse header) */
 801ee46:	f06f 0005 	mvn.w	r0, #5
 801ee4a:	e6eb      	b.n	801ec24 <MP3Decode+0x154>
		return ERR_MP3_NULL_POINTER;
 801ee4c:	f06f 0004 	mvn.w	r0, #4
 801ee50:	e6e8      	b.n	801ec24 <MP3Decode+0x154>
			memcpy(mp3DecInfo->mainBuf + mp3DecInfo->mainDataBytes, *inbuf, mp3DecInfo->nSlots);
 801ee52:	461a      	mov	r2, r3
 801ee54:	6829      	ldr	r1, [r5, #0]
 801ee56:	4440      	add	r0, r8
 801ee58:	f003 fa25 	bl	80222a6 <memcpy>
			mp3DecInfo->mainDataBytes += mp3DecInfo->nSlots;
 801ee5c:	f8d9 27cc 	ldr.w	r2, [r9, #1996]	@ 0x7cc
 801ee60:	f8d9 37dc 	ldr.w	r3, [r9, #2012]	@ 0x7dc
 801ee64:	4413      	add	r3, r2
 801ee66:	f8c9 37dc 	str.w	r3, [r9, #2012]	@ 0x7dc
			*inbuf += mp3DecInfo->nSlots;
 801ee6a:	682b      	ldr	r3, [r5, #0]
 801ee6c:	4413      	add	r3, r2
 801ee6e:	602b      	str	r3, [r5, #0]
			*bytesLeft -= (mp3DecInfo->nSlots);
 801ee70:	6833      	ldr	r3, [r6, #0]
 801ee72:	1a9b      	subs	r3, r3, r2
 801ee74:	6033      	str	r3, [r6, #0]
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ee76:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
 801ee7a:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	@ 0x7c8
 801ee7e:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801ee82:	fb01 f202 	mul.w	r2, r1, r2
 801ee86:	fb03 f202 	mul.w	r2, r3, r2
 801ee8a:	2a00      	cmp	r2, #0
 801ee8c:	dd04      	ble.n	801ee98 <MP3Decode+0x3c8>
		outbuf[i] = 0;
 801ee8e:	9912      	ldr	r1, [sp, #72]	@ 0x48
 801ee90:	9804      	ldr	r0, [sp, #16]
 801ee92:	0052      	lsls	r2, r2, #1
 801ee94:	f003 f936 	bl	8022104 <memset>
			return ERR_MP3_MAINDATA_UNDERFLOW;
 801ee98:	f06f 0001 	mvn.w	r0, #1
 801ee9c:	e6c2      	b.n	801ec24 <MP3Decode+0x154>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ee9e:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
 801eea2:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	@ 0x7c8
 801eea6:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801eeaa:	fb01 f202 	mul.w	r2, r1, r2
 801eeae:	fb03 f202 	mul.w	r2, r3, r2
 801eeb2:	2a00      	cmp	r2, #0
 801eeb4:	dd04      	ble.n	801eec0 <MP3Decode+0x3f0>
		outbuf[i] = 0;
 801eeb6:	9804      	ldr	r0, [sp, #16]
 801eeb8:	0052      	lsls	r2, r2, #1
 801eeba:	2100      	movs	r1, #0
 801eebc:	f003 f922 	bl	8022104 <memset>
			return ERR_MP3_INVALID_DEQUANTIZE;			
 801eec0:	f06f 0009 	mvn.w	r0, #9
 801eec4:	e6ae      	b.n	801ec24 <MP3Decode+0x154>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801eec6:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
 801eeca:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	@ 0x7c8
 801eece:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801eed2:	fb01 f202 	mul.w	r2, r1, r2
 801eed6:	fb03 f202 	mul.w	r2, r3, r2
 801eeda:	2a00      	cmp	r2, #0
 801eedc:	dd04      	ble.n	801eee8 <MP3Decode+0x418>
		outbuf[i] = 0;
 801eede:	9804      	ldr	r0, [sp, #16]
 801eee0:	0052      	lsls	r2, r2, #1
 801eee2:	2100      	movs	r1, #0
 801eee4:	f003 f90e 	bl	8022104 <memset>
		return ERR_MP3_INVALID_SIDEINFO;
 801eee8:	f06f 0006 	mvn.w	r0, #6
 801eeec:	e69a      	b.n	801ec24 <MP3Decode+0x154>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801eeee:	f8d9 27c8 	ldr.w	r2, [r9, #1992]	@ 0x7c8
 801eef2:	f8d9 17c4 	ldr.w	r1, [r9, #1988]	@ 0x7c4
 801eef6:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801eefa:	fb01 f202 	mul.w	r2, r1, r2
 801eefe:	fb03 f202 	mul.w	r2, r3, r2
 801ef02:	2a00      	cmp	r2, #0
 801ef04:	dd04      	ble.n	801ef10 <MP3Decode+0x440>
		outbuf[i] = 0;
 801ef06:	9804      	ldr	r0, [sp, #16]
 801ef08:	0052      	lsls	r2, r2, #1
 801ef0a:	2100      	movs	r1, #0
 801ef0c:	f003 f8fa 	bl	8022104 <memset>
			return ERR_MP3_INVALID_SUBBAND;			
 801ef10:	f06f 000b 	mvn.w	r0, #11
 801ef14:	e686      	b.n	801ec24 <MP3Decode+0x154>
	for (i = 0; i < mp3DecInfo->nGrans * mp3DecInfo->nGranSamps * mp3DecInfo->nChans; i++)
 801ef16:	f8d9 27c4 	ldr.w	r2, [r9, #1988]	@ 0x7c4
 801ef1a:	f8d9 17c8 	ldr.w	r1, [r9, #1992]	@ 0x7c8
 801ef1e:	f8d9 37bc 	ldr.w	r3, [r9, #1980]	@ 0x7bc
 801ef22:	fb01 f202 	mul.w	r2, r1, r2
 801ef26:	fb03 f202 	mul.w	r2, r3, r2
 801ef2a:	2a00      	cmp	r2, #0
 801ef2c:	dd04      	ble.n	801ef38 <MP3Decode+0x468>
		outbuf[i] = 0;
 801ef2e:	9912      	ldr	r1, [sp, #72]	@ 0x48
 801ef30:	9804      	ldr	r0, [sp, #16]
 801ef32:	0052      	lsls	r2, r2, #1
 801ef34:	f003 f8e6 	bl	8022104 <memset>
			return ERR_MP3_INDATA_UNDERFLOW;	
 801ef38:	f04f 30ff 	mov.w	r0, #4294967295
 801ef3c:	e672      	b.n	801ec24 <MP3Decode+0x154>
 801ef3e:	bf00      	nop

0801ef40 <xmp3_PolyphaseMono>:
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 *                (note max filter gain - see polyCoef[] comments)
 **************************************************************************************/
void PolyphaseMono(short *pcm, int *vbuf, const int *coefBase)
{	
 801ef40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ef44:	4684      	mov	ip, r0
 801ef46:	b083      	sub	sp, #12
	vb1 = vbuf;
	sum1L = rndVal;
	
	c1 = *coef;
	coef++;
	c2 = *coef;
 801ef48:	e9d2 6400 	ldrd	r6, r4, [r2]
static __inline Word64 MADD64(Word64 sum64, int x, int y)
{
        U64 u;
        u.w64 = sum64;

        __asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 801ef4c:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 801ef50:	2000      	movs	r0, #0
	coef++;
	vLo = *(vb1+(0));
	vHi = *(vb1+(23-(0)));
 801ef52:	6dcd      	ldr	r5, [r1, #92]	@ 0x5c
 801ef54:	680f      	ldr	r7, [r1, #0]
 801ef56:	fbc7 3006 	smlal	r3, r0, r7, r6
	sum1L = MADD64(sum1L, vLo,  c1);
	sum1L = MADD64(sum1L, vHi, -c2);
 801ef5a:	4264      	negs	r4, r4
 801ef5c:	fbc5 3004 	smlal	r3, r0, r5, r4
	
	//MC0M(0) // a
	MC0M(1)
 801ef60:	68d4      	ldr	r4, [r2, #12]
 801ef62:	684e      	ldr	r6, [r1, #4]
 801ef64:	6d8d      	ldr	r5, [r1, #88]	@ 0x58
 801ef66:	6897      	ldr	r7, [r2, #8]
 801ef68:	fbc6 3007 	smlal	r3, r0, r6, r7
 801ef6c:	4264      	negs	r4, r4
 801ef6e:	fbc5 3004 	smlal	r3, r0, r5, r4
	MC0M(2)
 801ef72:	6954      	ldr	r4, [r2, #20]
 801ef74:	688e      	ldr	r6, [r1, #8]
 801ef76:	6d4d      	ldr	r5, [r1, #84]	@ 0x54
 801ef78:	6917      	ldr	r7, [r2, #16]
 801ef7a:	fbc6 3007 	smlal	r3, r0, r6, r7
 801ef7e:	4264      	negs	r4, r4
 801ef80:	fbc5 3004 	smlal	r3, r0, r5, r4
	MC0M(3)
 801ef84:	69d4      	ldr	r4, [r2, #28]
 801ef86:	68ce      	ldr	r6, [r1, #12]
 801ef88:	6d0d      	ldr	r5, [r1, #80]	@ 0x50
 801ef8a:	6997      	ldr	r7, [r2, #24]
 801ef8c:	fbc6 3007 	smlal	r3, r0, r6, r7
 801ef90:	4264      	negs	r4, r4
 801ef92:	fbc5 3004 	smlal	r3, r0, r5, r4
	MC0M(4)
 801ef96:	6a54      	ldr	r4, [r2, #36]	@ 0x24
 801ef98:	690e      	ldr	r6, [r1, #16]
 801ef9a:	6ccd      	ldr	r5, [r1, #76]	@ 0x4c
 801ef9c:	6a17      	ldr	r7, [r2, #32]
 801ef9e:	fbc6 3007 	smlal	r3, r0, r6, r7
 801efa2:	4264      	negs	r4, r4
 801efa4:	fbc5 3004 	smlal	r3, r0, r5, r4
	MC0M(5)
 801efa8:	6ad4      	ldr	r4, [r2, #44]	@ 0x2c
 801efaa:	694e      	ldr	r6, [r1, #20]
 801efac:	6c8d      	ldr	r5, [r1, #72]	@ 0x48
 801efae:	6a97      	ldr	r7, [r2, #40]	@ 0x28
 801efb0:	fbc6 3007 	smlal	r3, r0, r6, r7
 801efb4:	4264      	negs	r4, r4
 801efb6:	fbc5 3004 	smlal	r3, r0, r5, r4
	MC0M(6)
 801efba:	6b54      	ldr	r4, [r2, #52]	@ 0x34
 801efbc:	698e      	ldr	r6, [r1, #24]
 801efbe:	6c4d      	ldr	r5, [r1, #68]	@ 0x44
 801efc0:	6b17      	ldr	r7, [r2, #48]	@ 0x30
 801efc2:	fbc6 3007 	smlal	r3, r0, r6, r7
 801efc6:	4264      	negs	r4, r4
 801efc8:	fbc5 3004 	smlal	r3, r0, r5, r4
	MC0M(7)
 801efcc:	6bd4      	ldr	r4, [r2, #60]	@ 0x3c
 801efce:	69ce      	ldr	r6, [r1, #28]
 801efd0:	6c0d      	ldr	r5, [r1, #64]	@ 0x40
 801efd2:	6b97      	ldr	r7, [r2, #56]	@ 0x38
 801efd4:	fbc6 3007 	smlal	r3, r0, r6, r7
 801efd8:	4264      	negs	r4, r4
 801efda:	fbc5 3004 	smlal	r3, r0, r5, r4
  unsigned int xLo = (unsigned int) x;
  int xHi = (int) (x >> 32);
  int nComp = 32-n;
  int tmp;
  // Shortcut: n is always < 32.
  __asm__ __volatile__( "lsl %2, %0, %3\n\t"  // tmp <- xHi<<(32-n)
 801efde:	240c      	movs	r4, #12
 801efe0:	2514      	movs	r5, #20
 801efe2:	fa00 f604 	lsl.w	r6, r0, r4
 801efe6:	fa40 f005 	asr.w	r0, r0, r5
 801efea:	fa23 f305 	lsr.w	r3, r3, r5
 801efee:	ea43 0306 	orr.w	r3, r3, r6
	if (sign != (x >> 15))
 801eff2:	155c      	asrs	r4, r3, #21
 801eff4:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
 801eff8:	bf1c      	itt	ne
 801effa:	17d8      	asrne	r0, r3, #31
		x = sign ^ ((1 << 15) - 1);
 801effc:	f480 43ff 	eorne.w	r3, r0, #32640	@ 0x7f80
	/* special case, output sample 16 */
	coef = coefBase + 256;
	vb1 = vbuf + 64*16;
	sum1L = rndVal;

	MC1M(0)
 801f000:	f501 5480 	add.w	r4, r1, #4096	@ 0x1000
	x >>= fracBits;
 801f004:	bf0c      	ite	eq
 801f006:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 801f008:	f083 037f 	eorne.w	r3, r3, #127	@ 0x7f
	MC1M(0)
 801f00c:	f8d2 6400 	ldr.w	r6, [r2, #1024]	@ 0x400
 801f010:	6825      	ldr	r5, [r4, #0]
	return (short)x;
 801f012:	f8ac 3000 	strh.w	r3, [ip]
        __asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 801f016:	2000      	movs	r0, #0
 801f018:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 801f01c:	fbc5 3006 	smlal	r3, r0, r5, r6
	MC1M(1)
 801f020:	f8d2 6404 	ldr.w	r6, [r2, #1028]	@ 0x404
 801f024:	6865      	ldr	r5, [r4, #4]
 801f026:	fbc5 3006 	smlal	r3, r0, r5, r6
	MC1M(2)
 801f02a:	f8d2 6408 	ldr.w	r6, [r2, #1032]	@ 0x408
 801f02e:	68a5      	ldr	r5, [r4, #8]
 801f030:	fbc5 3006 	smlal	r3, r0, r5, r6
	MC1M(3)
 801f034:	f8d2 640c 	ldr.w	r6, [r2, #1036]	@ 0x40c
 801f038:	68e5      	ldr	r5, [r4, #12]
 801f03a:	fbc5 3006 	smlal	r3, r0, r5, r6
	MC1M(4)
 801f03e:	f8d2 6410 	ldr.w	r6, [r2, #1040]	@ 0x410
 801f042:	6925      	ldr	r5, [r4, #16]
 801f044:	fbc5 3006 	smlal	r3, r0, r5, r6
	MC1M(5)
 801f048:	f8d2 6414 	ldr.w	r6, [r2, #1044]	@ 0x414
 801f04c:	6965      	ldr	r5, [r4, #20]
 801f04e:	fbc5 3006 	smlal	r3, r0, r5, r6
	MC1M(6)
 801f052:	f8d2 6418 	ldr.w	r6, [r2, #1048]	@ 0x418
 801f056:	69a5      	ldr	r5, [r4, #24]
 801f058:	fbc5 3006 	smlal	r3, r0, r5, r6
	MC1M(7)
 801f05c:	69e4      	ldr	r4, [r4, #28]
 801f05e:	f8d2 541c 	ldr.w	r5, [r2, #1052]	@ 0x41c
 801f062:	fbc4 3005 	smlal	r3, r0, r4, r5
  __asm__ __volatile__( "lsl %2, %0, %3\n\t"  // tmp <- xHi<<(32-n)
 801f066:	240c      	movs	r4, #12
 801f068:	2514      	movs	r5, #20
 801f06a:	fa00 f604 	lsl.w	r6, r0, r4
 801f06e:	fa40 f005 	asr.w	r0, r0, r5
 801f072:	fa23 f305 	lsr.w	r3, r3, r5
 801f076:	ea43 0306 	orr.w	r3, r3, r6
	if (sign != (x >> 15))
 801f07a:	155c      	asrs	r4, r3, #21
 801f07c:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
	sign = x >> 31;
 801f080:	ea4f 70e3 	mov.w	r0, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f084:	bf16      	itet	ne
 801f086:	f480 43ff 	eorne.w	r3, r0, #32640	@ 0x7f80
	x >>= fracBits;
 801f08a:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 801f08c:	f083 037f 	eorne.w	r3, r3, #127	@ 0x7f
	return (short)x;
 801f090:	f8ac 3020 	strh.w	r3, [ip, #32]
	coef = coefBase + 16;
	vb1 = vbuf + 64;
	pcm++;

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 801f094:	f502 6388 	add.w	r3, r2, #1088	@ 0x440
 801f098:	f102 0480 	add.w	r4, r2, #128	@ 0x80
 801f09c:	f10c 0a40 	add.w	sl, ip, #64	@ 0x40
 801f0a0:	9301      	str	r3, [sp, #4]
        __asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 801f0a2:	f04f 7900 	mov.w	r9, #33554432	@ 0x2000000
 801f0a6:	f04f 0800 	mov.w	r8, #0
		x = sign ^ ((1 << 15) - 1);
 801f0aa:	46e6      	mov	lr, ip
		sum1L = sum2L = rndVal;

		MC2M(0)
 801f0ac:	e954 cb10 	ldrd	ip, fp, [r4, #-64]	@ 0x40
 801f0b0:	f8d1 6100 	ldr.w	r6, [r1, #256]	@ 0x100
 801f0b4:	f8d1 715c 	ldr.w	r7, [r1, #348]	@ 0x15c
 801f0b8:	464a      	mov	r2, r9
 801f0ba:	4645      	mov	r5, r8
 801f0bc:	fbc6 250c 	smlal	r2, r5, r6, ip
 801f0c0:	464b      	mov	r3, r9
 801f0c2:	4640      	mov	r0, r8
 801f0c4:	fbc6 300b 	smlal	r3, r0, r6, fp
 801f0c8:	f1cb 0600 	rsb	r6, fp, #0
 801f0cc:	fbc7 2506 	smlal	r2, r5, r7, r6
 801f0d0:	fbc7 300c 	smlal	r3, r0, r7, ip
		MC2M(1)
 801f0d4:	e954 7c0e 	ldrd	r7, ip, [r4, #-56]	@ 0x38
 801f0d8:	f8d1 b104 	ldr.w	fp, [r1, #260]	@ 0x104
 801f0dc:	f8d1 6158 	ldr.w	r6, [r1, #344]	@ 0x158
 801f0e0:	fbcb 2507 	smlal	r2, r5, fp, r7
 801f0e4:	fbcb 300c 	smlal	r3, r0, fp, ip
 801f0e8:	f1cc 0c00 	rsb	ip, ip, #0
 801f0ec:	fbc6 250c 	smlal	r2, r5, r6, ip
 801f0f0:	fbc6 3007 	smlal	r3, r0, r6, r7
		MC2M(2)
 801f0f4:	e954 7c0c 	ldrd	r7, ip, [r4, #-48]	@ 0x30
 801f0f8:	f8d1 b108 	ldr.w	fp, [r1, #264]	@ 0x108
 801f0fc:	f8d1 6154 	ldr.w	r6, [r1, #340]	@ 0x154
 801f100:	fbcb 2507 	smlal	r2, r5, fp, r7
 801f104:	fbcb 300c 	smlal	r3, r0, fp, ip
 801f108:	f1cc 0c00 	rsb	ip, ip, #0
 801f10c:	fbc6 250c 	smlal	r2, r5, r6, ip
 801f110:	fbc6 3007 	smlal	r3, r0, r6, r7
		MC2M(3)
 801f114:	e954 7c0a 	ldrd	r7, ip, [r4, #-40]	@ 0x28
 801f118:	f8d1 b10c 	ldr.w	fp, [r1, #268]	@ 0x10c
 801f11c:	f8d1 6150 	ldr.w	r6, [r1, #336]	@ 0x150
 801f120:	fbcb 2507 	smlal	r2, r5, fp, r7
 801f124:	fbcb 300c 	smlal	r3, r0, fp, ip
 801f128:	f1cc 0c00 	rsb	ip, ip, #0
 801f12c:	fbc6 250c 	smlal	r2, r5, r6, ip
 801f130:	fbc6 3007 	smlal	r3, r0, r6, r7
		MC2M(4)
 801f134:	e954 cb08 	ldrd	ip, fp, [r4, #-32]
 801f138:	f8d1 6110 	ldr.w	r6, [r1, #272]	@ 0x110
 801f13c:	f8d1 714c 	ldr.w	r7, [r1, #332]	@ 0x14c
 801f140:	fbc6 250c 	smlal	r2, r5, r6, ip
 801f144:	fbc6 300b 	smlal	r3, r0, r6, fp
 801f148:	f1cb 0600 	rsb	r6, fp, #0
 801f14c:	fbc7 2506 	smlal	r2, r5, r7, r6
 801f150:	fbc7 300c 	smlal	r3, r0, r7, ip
		MC2M(5)
 801f154:	e954 c606 	ldrd	ip, r6, [r4, #-24]
 801f158:	f8d1 b114 	ldr.w	fp, [r1, #276]	@ 0x114
 801f15c:	f8d1 7148 	ldr.w	r7, [r1, #328]	@ 0x148
 801f160:	fbcb 250c 	smlal	r2, r5, fp, ip
 801f164:	fbcb 3006 	smlal	r3, r0, fp, r6
 801f168:	4276      	negs	r6, r6
 801f16a:	fbc7 2506 	smlal	r2, r5, r7, r6
 801f16e:	fbc7 300c 	smlal	r3, r0, r7, ip
		MC2M(6)
 801f172:	e954 c604 	ldrd	ip, r6, [r4, #-16]
 801f176:	f8d1 b118 	ldr.w	fp, [r1, #280]	@ 0x118
 801f17a:	f8d1 7144 	ldr.w	r7, [r1, #324]	@ 0x144
 801f17e:	fbcb 250c 	smlal	r2, r5, fp, ip
 801f182:	fbcb 3006 	smlal	r3, r0, fp, r6
 801f186:	4276      	negs	r6, r6
 801f188:	fbc7 2506 	smlal	r2, r5, r7, r6
 801f18c:	fbc7 300c 	smlal	r3, r0, r7, ip
		MC2M(7)
 801f190:	e954 c602 	ldrd	ip, r6, [r4, #-8]
 801f194:	f8d1 b11c 	ldr.w	fp, [r1, #284]	@ 0x11c
 801f198:	f8d1 7140 	ldr.w	r7, [r1, #320]	@ 0x140
 801f19c:	fbcb 250c 	smlal	r2, r5, fp, ip
 801f1a0:	fbcb 3006 	smlal	r3, r0, fp, r6
 801f1a4:	4276      	negs	r6, r6
 801f1a6:	fbc7 2506 	smlal	r2, r5, r7, r6
 801f1aa:	fbc7 300c 	smlal	r3, r0, r7, ip
  __asm__ __volatile__( "lsl %2, %0, %3\n\t"  // tmp <- xHi<<(32-n)
 801f1ae:	270c      	movs	r7, #12
 801f1b0:	f04f 0c14 	mov.w	ip, #20
 801f1b4:	fa05 f607 	lsl.w	r6, r5, r7
 801f1b8:	fa45 f50c 	asr.w	r5, r5, ip
 801f1bc:	fa22 f20c 	lsr.w	r2, r2, ip
 801f1c0:	ea42 0206 	orr.w	r2, r2, r6
	if (sign != (x >> 15))
 801f1c4:	1556      	asrs	r6, r2, #21
	sign = x >> 31;
 801f1c6:	17d5      	asrs	r5, r2, #31
	if (sign != (x >> 15))
 801f1c8:	ebb6 7fe2 	cmp.w	r6, r2, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f1cc:	bf16      	itet	ne
 801f1ce:	f485 42ff 	eorne.w	r2, r5, #32640	@ 0x7f80
	x >>= fracBits;
 801f1d2:	1192      	asreq	r2, r2, #6
		x = sign ^ ((1 << 15) - 1);
 801f1d4:	f082 027f 	eorne.w	r2, r2, #127	@ 0x7f
	return (short)x;
 801f1d8:	f82e 2f02 	strh.w	r2, [lr, #2]!
 801f1dc:	250c      	movs	r5, #12
 801f1de:	2614      	movs	r6, #20
 801f1e0:	fa00 f205 	lsl.w	r2, r0, r5
 801f1e4:	fa40 f006 	asr.w	r0, r0, r6
 801f1e8:	fa23 f306 	lsr.w	r3, r3, r6
 801f1ec:	ea43 0302 	orr.w	r3, r3, r2
	if (sign != (x >> 15))
 801f1f0:	1558      	asrs	r0, r3, #21
 801f1f2:	ebb0 7fe3 	cmp.w	r0, r3, asr #31
	sign = x >> 31;
 801f1f6:	ea4f 72e3 	mov.w	r2, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f1fa:	bf16      	itet	ne
 801f1fc:	f482 43ff 	eorne.w	r3, r2, #32640	@ 0x7f80
	x >>= fracBits;
 801f200:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 801f202:	f083 037f 	eorne.w	r3, r3, #127	@ 0x7f
	return (short)x;
 801f206:	f82a 3d02 	strh.w	r3, [sl, #-2]!
	for (i = 15; i > 0; i--) {
 801f20a:	9b01      	ldr	r3, [sp, #4]
 801f20c:	3440      	adds	r4, #64	@ 0x40
 801f20e:	429c      	cmp	r4, r3
 801f210:	f501 7180 	add.w	r1, r1, #256	@ 0x100
 801f214:	f47f af4a 	bne.w	801f0ac <xmp3_PolyphaseMono+0x16c>
		vb1 += 64;
		*(pcm)       = ClipToShort((int)SAR64(sum1L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*i) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		pcm++;
	}
}
 801f218:	b003      	add	sp, #12
 801f21a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801f21e:	bf00      	nop

0801f220 <xmp3_PolyphaseStereo>:
 * Notes:       interleaves PCM samples LRLRLR...
 *
 * TODO:        add 32-bit version for platforms where 64-bit mul-acc is not supported
 **************************************************************************************/
void PolyphaseStereo(short *pcm, int *vbuf, const int *coefBase)
{
 801f220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f224:	460e      	mov	r6, r1
        __asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 801f226:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 801f22a:	2400      	movs	r4, #0
 801f22c:	4680      	mov	r8, r0
 801f22e:	b085      	sub	sp, #20
	/* special case, output sample 0 */
	coef = coefBase;
	vb1 = vbuf;
	sum1L = sum1R = rndVal;

	MC0S(0)
 801f230:	6817      	ldr	r7, [r2, #0]
 801f232:	6830      	ldr	r0, [r6, #0]
 801f234:	4619      	mov	r1, r3
 801f236:	4625      	mov	r5, r4
 801f238:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f23c:	6850      	ldr	r0, [r2, #4]
 801f23e:	f1c0 0c00 	rsb	ip, r0, #0
 801f242:	6df0      	ldr	r0, [r6, #92]	@ 0x5c
 801f244:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f248:	f8d6 0080 	ldr.w	r0, [r6, #128]	@ 0x80
 801f24c:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f250:	f8d6 00dc 	ldr.w	r0, [r6, #220]	@ 0xdc
 801f254:	fbc0 340c 	smlal	r3, r4, r0, ip
	MC0S(1)
 801f258:	6897      	ldr	r7, [r2, #8]
 801f25a:	6870      	ldr	r0, [r6, #4]
 801f25c:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f260:	68d0      	ldr	r0, [r2, #12]
 801f262:	f1c0 0c00 	rsb	ip, r0, #0
 801f266:	6db0      	ldr	r0, [r6, #88]	@ 0x58
 801f268:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f26c:	f8d6 0084 	ldr.w	r0, [r6, #132]	@ 0x84
 801f270:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f274:	f8d6 00d8 	ldr.w	r0, [r6, #216]	@ 0xd8
 801f278:	fbc0 340c 	smlal	r3, r4, r0, ip
	MC0S(2)
 801f27c:	6917      	ldr	r7, [r2, #16]
 801f27e:	68b0      	ldr	r0, [r6, #8]
 801f280:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f284:	6950      	ldr	r0, [r2, #20]
 801f286:	f1c0 0c00 	rsb	ip, r0, #0
 801f28a:	6d70      	ldr	r0, [r6, #84]	@ 0x54
 801f28c:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f290:	f8d6 0088 	ldr.w	r0, [r6, #136]	@ 0x88
 801f294:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f298:	f8d6 00d4 	ldr.w	r0, [r6, #212]	@ 0xd4
 801f29c:	fbc0 340c 	smlal	r3, r4, r0, ip
	MC0S(3)
 801f2a0:	6997      	ldr	r7, [r2, #24]
 801f2a2:	68f0      	ldr	r0, [r6, #12]
 801f2a4:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f2a8:	69d0      	ldr	r0, [r2, #28]
 801f2aa:	f1c0 0c00 	rsb	ip, r0, #0
 801f2ae:	6d30      	ldr	r0, [r6, #80]	@ 0x50
 801f2b0:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f2b4:	f8d6 008c 	ldr.w	r0, [r6, #140]	@ 0x8c
 801f2b8:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f2bc:	f8d6 00d0 	ldr.w	r0, [r6, #208]	@ 0xd0
 801f2c0:	fbc0 340c 	smlal	r3, r4, r0, ip
	MC0S(4)
 801f2c4:	6a17      	ldr	r7, [r2, #32]
 801f2c6:	6930      	ldr	r0, [r6, #16]
 801f2c8:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f2cc:	6a50      	ldr	r0, [r2, #36]	@ 0x24
 801f2ce:	f1c0 0c00 	rsb	ip, r0, #0
 801f2d2:	6cf0      	ldr	r0, [r6, #76]	@ 0x4c
 801f2d4:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f2d8:	f8d6 0090 	ldr.w	r0, [r6, #144]	@ 0x90
 801f2dc:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f2e0:	f8d6 00cc 	ldr.w	r0, [r6, #204]	@ 0xcc
 801f2e4:	fbc0 340c 	smlal	r3, r4, r0, ip
	MC0S(5)
 801f2e8:	6a97      	ldr	r7, [r2, #40]	@ 0x28
 801f2ea:	6970      	ldr	r0, [r6, #20]
 801f2ec:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f2f0:	6ad0      	ldr	r0, [r2, #44]	@ 0x2c
 801f2f2:	f1c0 0c00 	rsb	ip, r0, #0
 801f2f6:	6cb0      	ldr	r0, [r6, #72]	@ 0x48
 801f2f8:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f2fc:	f8d6 0094 	ldr.w	r0, [r6, #148]	@ 0x94
 801f300:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f304:	f8d6 00c8 	ldr.w	r0, [r6, #200]	@ 0xc8
 801f308:	fbc0 340c 	smlal	r3, r4, r0, ip
	MC0S(6)
 801f30c:	6b17      	ldr	r7, [r2, #48]	@ 0x30
 801f30e:	69b0      	ldr	r0, [r6, #24]
 801f310:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f314:	6b50      	ldr	r0, [r2, #52]	@ 0x34
 801f316:	f1c0 0c00 	rsb	ip, r0, #0
 801f31a:	6c70      	ldr	r0, [r6, #68]	@ 0x44
 801f31c:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f320:	f8d6 0098 	ldr.w	r0, [r6, #152]	@ 0x98
 801f324:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f328:	f8d6 00c4 	ldr.w	r0, [r6, #196]	@ 0xc4
 801f32c:	fbc0 340c 	smlal	r3, r4, r0, ip
	MC0S(7)
 801f330:	6b97      	ldr	r7, [r2, #56]	@ 0x38
 801f332:	69f0      	ldr	r0, [r6, #28]
 801f334:	fbc0 1507 	smlal	r1, r5, r0, r7
 801f338:	6bd0      	ldr	r0, [r2, #60]	@ 0x3c
 801f33a:	f1c0 0c00 	rsb	ip, r0, #0
 801f33e:	6c30      	ldr	r0, [r6, #64]	@ 0x40
 801f340:	fbc0 150c 	smlal	r1, r5, r0, ip
 801f344:	f8d6 009c 	ldr.w	r0, [r6, #156]	@ 0x9c
 801f348:	fbc0 3407 	smlal	r3, r4, r0, r7
 801f34c:	f8d6 00c0 	ldr.w	r0, [r6, #192]	@ 0xc0
 801f350:	fbc0 340c 	smlal	r3, r4, r0, ip
  __asm__ __volatile__( "lsl %2, %0, %3\n\t"  // tmp <- xHi<<(32-n)
 801f354:	270c      	movs	r7, #12
 801f356:	f04f 0c14 	mov.w	ip, #20
 801f35a:	fa05 fe07 	lsl.w	lr, r5, r7
 801f35e:	fa45 f50c 	asr.w	r5, r5, ip
 801f362:	fa21 f10c 	lsr.w	r1, r1, ip
 801f366:	ea41 010e 	orr.w	r1, r1, lr
	if (sign != (x >> 15))
 801f36a:	154f      	asrs	r7, r1, #21
 801f36c:	ebb7 7fe1 	cmp.w	r7, r1, asr #31
 801f370:	bf1b      	ittet	ne
 801f372:	17cd      	asrne	r5, r1, #31
		x = sign ^ ((1 << 15) - 1);
 801f374:	f485 41ff 	eorne.w	r1, r5, #32640	@ 0x7f80
	x >>= fracBits;
 801f378:	1189      	asreq	r1, r1, #6
		x = sign ^ ((1 << 15) - 1);
 801f37a:	f081 017f 	eorne.w	r1, r1, #127	@ 0x7f
	return (short)x;
 801f37e:	f8a8 1000 	strh.w	r1, [r8]
 801f382:	2514      	movs	r5, #20
 801f384:	4621      	mov	r1, r4
 801f386:	240c      	movs	r4, #12
 801f388:	fa01 f704 	lsl.w	r7, r1, r4
 801f38c:	fa41 f105 	asr.w	r1, r1, r5
 801f390:	fa23 f305 	lsr.w	r3, r3, r5
 801f394:	ea43 0307 	orr.w	r3, r3, r7
	if (sign != (x >> 15))
 801f398:	155c      	asrs	r4, r3, #21
 801f39a:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
	sign = x >> 31;
 801f39e:	ea4f 71e3 	mov.w	r1, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f3a2:	bf18      	it	ne
 801f3a4:	f481 43ff 	eorne.w	r3, r1, #32640	@ 0x7f80
	/* special case, output sample 16 */
	coef = coefBase + 256;
	vb1 = vbuf + 64*16;
	sum1L = sum1R = rndVal;

	MC1S(0)
 801f3a8:	f506 5480 	add.w	r4, r6, #4096	@ 0x1000
	x >>= fracBits;
 801f3ac:	bf0c      	ite	eq
 801f3ae:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 801f3b0:	f083 037f 	eorne.w	r3, r3, #127	@ 0x7f
        __asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 801f3b4:	f04f 7c00 	mov.w	ip, #33554432	@ 0x2000000
 801f3b8:	2500      	movs	r5, #0
	MC1S(0)
 801f3ba:	f8d2 7400 	ldr.w	r7, [r2, #1024]	@ 0x400
 801f3be:	6820      	ldr	r0, [r4, #0]
	return (short)x;
 801f3c0:	f8a8 3002 	strh.w	r3, [r8, #2]
 801f3c4:	4661      	mov	r1, ip
 801f3c6:	462b      	mov	r3, r5
 801f3c8:	fbc0 1307 	smlal	r1, r3, r0, r7
 801f3cc:	f8d4 0080 	ldr.w	r0, [r4, #128]	@ 0x80
 801f3d0:	fbc0 c507 	smlal	ip, r5, r0, r7
	MC1S(1)
 801f3d4:	f8d2 7404 	ldr.w	r7, [r2, #1028]	@ 0x404
 801f3d8:	6860      	ldr	r0, [r4, #4]
 801f3da:	fbc0 1307 	smlal	r1, r3, r0, r7
 801f3de:	f8d4 0084 	ldr.w	r0, [r4, #132]	@ 0x84
 801f3e2:	fbc0 c507 	smlal	ip, r5, r0, r7
	MC1S(2)
 801f3e6:	f8d2 7408 	ldr.w	r7, [r2, #1032]	@ 0x408
 801f3ea:	68a0      	ldr	r0, [r4, #8]
 801f3ec:	fbc0 1307 	smlal	r1, r3, r0, r7
 801f3f0:	f8d4 0088 	ldr.w	r0, [r4, #136]	@ 0x88
 801f3f4:	fbc0 c507 	smlal	ip, r5, r0, r7
	MC1S(3)
 801f3f8:	f8d2 740c 	ldr.w	r7, [r2, #1036]	@ 0x40c
 801f3fc:	68e0      	ldr	r0, [r4, #12]
 801f3fe:	fbc0 1307 	smlal	r1, r3, r0, r7
 801f402:	f8d4 008c 	ldr.w	r0, [r4, #140]	@ 0x8c
 801f406:	fbc0 c507 	smlal	ip, r5, r0, r7
	MC1S(4)
 801f40a:	f8d2 7410 	ldr.w	r7, [r2, #1040]	@ 0x410
 801f40e:	6920      	ldr	r0, [r4, #16]
 801f410:	fbc0 1307 	smlal	r1, r3, r0, r7
 801f414:	f8d4 0090 	ldr.w	r0, [r4, #144]	@ 0x90
 801f418:	fbc0 c507 	smlal	ip, r5, r0, r7
	MC1S(5)
 801f41c:	f8d2 7414 	ldr.w	r7, [r2, #1044]	@ 0x414
 801f420:	6960      	ldr	r0, [r4, #20]
 801f422:	fbc0 1307 	smlal	r1, r3, r0, r7
 801f426:	f8d4 0094 	ldr.w	r0, [r4, #148]	@ 0x94
 801f42a:	fbc0 c507 	smlal	ip, r5, r0, r7
	MC1S(6)
 801f42e:	f8d2 7418 	ldr.w	r7, [r2, #1048]	@ 0x418
 801f432:	69a0      	ldr	r0, [r4, #24]
 801f434:	fbc0 1307 	smlal	r1, r3, r0, r7
 801f438:	f8d4 0098 	ldr.w	r0, [r4, #152]	@ 0x98
 801f43c:	fbc0 c507 	smlal	ip, r5, r0, r7
	MC1S(7)
 801f440:	f8d2 e41c 	ldr.w	lr, [r2, #1052]	@ 0x41c
 801f444:	69e7      	ldr	r7, [r4, #28]
 801f446:	fbc7 130e 	smlal	r1, r3, r7, lr
 801f44a:	f8d4 709c 	ldr.w	r7, [r4, #156]	@ 0x9c
 801f44e:	4664      	mov	r4, ip
 801f450:	fbc7 450e 	smlal	r4, r5, r7, lr
  __asm__ __volatile__( "lsl %2, %0, %3\n\t"  // tmp <- xHi<<(32-n)
 801f454:	270c      	movs	r7, #12
 801f456:	f04f 0c14 	mov.w	ip, #20
 801f45a:	fa03 fe07 	lsl.w	lr, r3, r7
 801f45e:	fa43 f30c 	asr.w	r3, r3, ip
 801f462:	fa21 f10c 	lsr.w	r1, r1, ip
 801f466:	ea41 010e 	orr.w	r1, r1, lr
	if (sign != (x >> 15))
 801f46a:	154f      	asrs	r7, r1, #21
	sign = x >> 31;
 801f46c:	17cb      	asrs	r3, r1, #31
	if (sign != (x >> 15))
 801f46e:	ebb7 7fe1 	cmp.w	r7, r1, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f472:	bf16      	itet	ne
 801f474:	f483 43ff 	eorne.w	r3, r3, #32640	@ 0x7f80
	x >>= fracBits;
 801f478:	118b      	asreq	r3, r1, #6
		x = sign ^ ((1 << 15) - 1);
 801f47a:	f083 037f 	eorne.w	r3, r3, #127	@ 0x7f
	return (short)x;
 801f47e:	f8a8 3040 	strh.w	r3, [r8, #64]	@ 0x40
 801f482:	210c      	movs	r1, #12
 801f484:	4623      	mov	r3, r4
 801f486:	2414      	movs	r4, #20
 801f488:	fa05 f701 	lsl.w	r7, r5, r1
 801f48c:	fa45 f504 	asr.w	r5, r5, r4
 801f490:	fa23 f304 	lsr.w	r3, r3, r4
 801f494:	ea43 0307 	orr.w	r3, r3, r7
	if (sign != (x >> 15))
 801f498:	155c      	asrs	r4, r3, #21
	sign = x >> 31;
 801f49a:	17d9      	asrs	r1, r3, #31
	if (sign != (x >> 15))
 801f49c:	ebb4 7fe3 	cmp.w	r4, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f4a0:	bf16      	itet	ne
 801f4a2:	f481 43ff 	eorne.w	r3, r1, #32640	@ 0x7f80
	x >>= fracBits;
 801f4a6:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 801f4a8:	f083 037f 	eorne.w	r3, r3, #127	@ 0x7f
	return (short)x;
 801f4ac:	f8a8 3042 	strh.w	r3, [r8, #66]	@ 0x42
	coef = coefBase + 16;
	vb1 = vbuf + 64;
	pcm += 2;

	/* right now, the compiler creates bad asm from this... */
	for (i = 15; i > 0; i--) {
 801f4b0:	f108 0308 	add.w	r3, r8, #8
 801f4b4:	e9cd 3800 	strd	r3, r8, [sp]
 801f4b8:	f502 6388 	add.w	r3, r2, #1088	@ 0x440
 801f4bc:	f102 0b80 	add.w	fp, r2, #128	@ 0x80
 801f4c0:	9303      	str	r3, [sp, #12]
		sum1L = sum2L = rndVal;
		sum1R = sum2R = rndVal;

		MC2S(0)
 801f4c2:	e95b e810 	ldrd	lr, r8, [fp, #-64]	@ 0x40
 801f4c6:	f8d6 1100 	ldr.w	r1, [r6, #256]	@ 0x100
 801f4ca:	f8d6 315c 	ldr.w	r3, [r6, #348]	@ 0x15c
        __asm__ volatile ("smlal %0,%1,%2,%3" : "+&r" (u.r.lo32), "+&r" (u.r.hi32) : "r" (x), "r" (y) : "cc");
 801f4ce:	f04f 7000 	mov.w	r0, #33554432	@ 0x2000000
 801f4d2:	f04f 0c00 	mov.w	ip, #0
 801f4d6:	fbc1 0c0e 	smlal	r0, ip, r1, lr
 801f4da:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 801f4de:	2500      	movs	r5, #0
 801f4e0:	fbc1 2508 	smlal	r2, r5, r1, r8
 801f4e4:	f1c8 0900 	rsb	r9, r8, #0
 801f4e8:	fbc3 0c09 	smlal	r0, ip, r3, r9
 801f4ec:	fbc3 250e 	smlal	r2, r5, r3, lr
 801f4f0:	f04f 7100 	mov.w	r1, #33554432	@ 0x2000000
 801f4f4:	f8d6 a180 	ldr.w	sl, [r6, #384]	@ 0x180
 801f4f8:	9202      	str	r2, [sp, #8]
 801f4fa:	2700      	movs	r7, #0
 801f4fc:	fbca 170e 	smlal	r1, r7, sl, lr
 801f500:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 801f504:	2400      	movs	r4, #0
 801f506:	fbca 3408 	smlal	r3, r4, sl, r8
 801f50a:	f8d6 21dc 	ldr.w	r2, [r6, #476]	@ 0x1dc
 801f50e:	fbc2 1709 	smlal	r1, r7, r2, r9
 801f512:	fbc2 340e 	smlal	r3, r4, r2, lr
		MC2S(1)
 801f516:	e95b ae0e 	ldrd	sl, lr, [fp, #-56]	@ 0x38
 801f51a:	f8d6 9104 	ldr.w	r9, [r6, #260]	@ 0x104
 801f51e:	f8d6 8158 	ldr.w	r8, [r6, #344]	@ 0x158
 801f522:	fbc9 0c0a 	smlal	r0, ip, r9, sl
 801f526:	9a02      	ldr	r2, [sp, #8]
 801f528:	fbc9 250e 	smlal	r2, r5, r9, lr
 801f52c:	f1ce 0900 	rsb	r9, lr, #0
 801f530:	fbc8 0c09 	smlal	r0, ip, r8, r9
 801f534:	fbc8 250a 	smlal	r2, r5, r8, sl
 801f538:	9202      	str	r2, [sp, #8]
 801f53a:	f8d6 81d8 	ldr.w	r8, [r6, #472]	@ 0x1d8
 801f53e:	f8d6 2184 	ldr.w	r2, [r6, #388]	@ 0x184
 801f542:	fbc2 170a 	smlal	r1, r7, r2, sl
 801f546:	fbc2 340e 	smlal	r3, r4, r2, lr
 801f54a:	fbc8 1709 	smlal	r1, r7, r8, r9
 801f54e:	fbc8 340a 	smlal	r3, r4, r8, sl
		MC2S(2)
 801f552:	e95b ae0c 	ldrd	sl, lr, [fp, #-48]	@ 0x30
 801f556:	f8d6 9108 	ldr.w	r9, [r6, #264]	@ 0x108
 801f55a:	f8d6 8154 	ldr.w	r8, [r6, #340]	@ 0x154
 801f55e:	fbc9 0c0a 	smlal	r0, ip, r9, sl
 801f562:	9a02      	ldr	r2, [sp, #8]
 801f564:	fbc9 250e 	smlal	r2, r5, r9, lr
 801f568:	f1ce 0900 	rsb	r9, lr, #0
 801f56c:	fbc8 0c09 	smlal	r0, ip, r8, r9
 801f570:	fbc8 250a 	smlal	r2, r5, r8, sl
 801f574:	9202      	str	r2, [sp, #8]
 801f576:	f8d6 81d4 	ldr.w	r8, [r6, #468]	@ 0x1d4
 801f57a:	f8d6 2188 	ldr.w	r2, [r6, #392]	@ 0x188
 801f57e:	fbc2 170a 	smlal	r1, r7, r2, sl
 801f582:	fbc2 340e 	smlal	r3, r4, r2, lr
 801f586:	fbc8 1709 	smlal	r1, r7, r8, r9
 801f58a:	fbc8 340a 	smlal	r3, r4, r8, sl
		MC2S(3)
 801f58e:	e95b ae0a 	ldrd	sl, lr, [fp, #-40]	@ 0x28
 801f592:	f8d6 910c 	ldr.w	r9, [r6, #268]	@ 0x10c
 801f596:	f8d6 8150 	ldr.w	r8, [r6, #336]	@ 0x150
 801f59a:	fbc9 0c0a 	smlal	r0, ip, r9, sl
 801f59e:	9a02      	ldr	r2, [sp, #8]
 801f5a0:	fbc9 250e 	smlal	r2, r5, r9, lr
 801f5a4:	f1ce 0900 	rsb	r9, lr, #0
 801f5a8:	fbc8 0c09 	smlal	r0, ip, r8, r9
 801f5ac:	fbc8 250a 	smlal	r2, r5, r8, sl
 801f5b0:	9202      	str	r2, [sp, #8]
 801f5b2:	f8d6 81d0 	ldr.w	r8, [r6, #464]	@ 0x1d0
 801f5b6:	f8d6 218c 	ldr.w	r2, [r6, #396]	@ 0x18c
 801f5ba:	fbc2 170a 	smlal	r1, r7, r2, sl
 801f5be:	fbc2 340e 	smlal	r3, r4, r2, lr
 801f5c2:	fbc8 1709 	smlal	r1, r7, r8, r9
 801f5c6:	fbc8 340a 	smlal	r3, r4, r8, sl
		MC2S(4)
 801f5ca:	e95b ae08 	ldrd	sl, lr, [fp, #-32]
 801f5ce:	f8d6 9110 	ldr.w	r9, [r6, #272]	@ 0x110
 801f5d2:	f8d6 814c 	ldr.w	r8, [r6, #332]	@ 0x14c
 801f5d6:	fbc9 0c0a 	smlal	r0, ip, r9, sl
 801f5da:	9a02      	ldr	r2, [sp, #8]
 801f5dc:	fbc9 250e 	smlal	r2, r5, r9, lr
 801f5e0:	f1ce 0900 	rsb	r9, lr, #0
 801f5e4:	fbc8 0c09 	smlal	r0, ip, r8, r9
 801f5e8:	fbc8 250a 	smlal	r2, r5, r8, sl
 801f5ec:	9202      	str	r2, [sp, #8]
 801f5ee:	f8d6 81cc 	ldr.w	r8, [r6, #460]	@ 0x1cc
 801f5f2:	f8d6 2190 	ldr.w	r2, [r6, #400]	@ 0x190
 801f5f6:	fbc2 170a 	smlal	r1, r7, r2, sl
 801f5fa:	fbc2 340e 	smlal	r3, r4, r2, lr
 801f5fe:	fbc8 1709 	smlal	r1, r7, r8, r9
 801f602:	fbc8 340a 	smlal	r3, r4, r8, sl
		MC2S(5)
 801f606:	e95b ae06 	ldrd	sl, lr, [fp, #-24]
 801f60a:	f8d6 9114 	ldr.w	r9, [r6, #276]	@ 0x114
 801f60e:	f8d6 8148 	ldr.w	r8, [r6, #328]	@ 0x148
 801f612:	fbc9 0c0a 	smlal	r0, ip, r9, sl
 801f616:	9a02      	ldr	r2, [sp, #8]
 801f618:	fbc9 250e 	smlal	r2, r5, r9, lr
 801f61c:	f1ce 0900 	rsb	r9, lr, #0
 801f620:	fbc8 0c09 	smlal	r0, ip, r8, r9
 801f624:	fbc8 250a 	smlal	r2, r5, r8, sl
 801f628:	9202      	str	r2, [sp, #8]
 801f62a:	f8d6 81c8 	ldr.w	r8, [r6, #456]	@ 0x1c8
 801f62e:	f8d6 2194 	ldr.w	r2, [r6, #404]	@ 0x194
 801f632:	fbc2 170a 	smlal	r1, r7, r2, sl
 801f636:	fbc2 340e 	smlal	r3, r4, r2, lr
 801f63a:	fbc8 1709 	smlal	r1, r7, r8, r9
 801f63e:	fbc8 340a 	smlal	r3, r4, r8, sl
		MC2S(6)
 801f642:	e95b ae04 	ldrd	sl, lr, [fp, #-16]
 801f646:	f8d6 9118 	ldr.w	r9, [r6, #280]	@ 0x118
 801f64a:	f8d6 8144 	ldr.w	r8, [r6, #324]	@ 0x144
 801f64e:	fbc9 0c0a 	smlal	r0, ip, r9, sl
 801f652:	9a02      	ldr	r2, [sp, #8]
 801f654:	fbc9 250e 	smlal	r2, r5, r9, lr
 801f658:	f1ce 0900 	rsb	r9, lr, #0
 801f65c:	fbc8 0c09 	smlal	r0, ip, r8, r9
 801f660:	fbc8 250a 	smlal	r2, r5, r8, sl
 801f664:	9202      	str	r2, [sp, #8]
 801f666:	f8d6 81c4 	ldr.w	r8, [r6, #452]	@ 0x1c4
 801f66a:	f8d6 2198 	ldr.w	r2, [r6, #408]	@ 0x198
 801f66e:	fbc2 170a 	smlal	r1, r7, r2, sl
 801f672:	fbc2 340e 	smlal	r3, r4, r2, lr
 801f676:	fbc8 1709 	smlal	r1, r7, r8, r9
 801f67a:	fbc8 340a 	smlal	r3, r4, r8, sl
		MC2S(7)
 801f67e:	e95b ae02 	ldrd	sl, lr, [fp, #-8]
 801f682:	f8d6 911c 	ldr.w	r9, [r6, #284]	@ 0x11c
 801f686:	f8d6 8140 	ldr.w	r8, [r6, #320]	@ 0x140
 801f68a:	fbc9 0c0a 	smlal	r0, ip, r9, sl
 801f68e:	9a02      	ldr	r2, [sp, #8]
 801f690:	fbc9 250e 	smlal	r2, r5, r9, lr
 801f694:	f1ce 0900 	rsb	r9, lr, #0
 801f698:	fbc8 0c09 	smlal	r0, ip, r8, r9
 801f69c:	fbc8 250a 	smlal	r2, r5, r8, sl
 801f6a0:	9202      	str	r2, [sp, #8]
 801f6a2:	f8d6 81c0 	ldr.w	r8, [r6, #448]	@ 0x1c0
 801f6a6:	f8d6 219c 	ldr.w	r2, [r6, #412]	@ 0x19c
 801f6aa:	fbc2 170a 	smlal	r1, r7, r2, sl
 801f6ae:	fbc2 340e 	smlal	r3, r4, r2, lr
 801f6b2:	fbc8 1709 	smlal	r1, r7, r8, r9
 801f6b6:	fbc8 340a 	smlal	r3, r4, r8, sl
  __asm__ __volatile__( "lsl %2, %0, %3\n\t"  // tmp <- xHi<<(32-n)
 801f6ba:	220c      	movs	r2, #12
 801f6bc:	f04f 0814 	mov.w	r8, #20
 801f6c0:	fa0c fe02 	lsl.w	lr, ip, r2
 801f6c4:	fa4c fc08 	asr.w	ip, ip, r8
 801f6c8:	fa20 f008 	lsr.w	r0, r0, r8
 801f6cc:	ea40 000e 	orr.w	r0, r0, lr
	if (sign != (x >> 15))
 801f6d0:	ea4f 5e60 	mov.w	lr, r0, asr #21
	sign = x >> 31;
 801f6d4:	ea4f 7ce0 	mov.w	ip, r0, asr #31
	if (sign != (x >> 15))
 801f6d8:	ebbe 7fe0 	cmp.w	lr, r0, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f6dc:	bf18      	it	ne
 801f6de:	f48c 40ff 	eorne.w	r0, ip, #32640	@ 0x7f80
	return (short)x;
 801f6e2:	9a00      	ldr	r2, [sp, #0]
	x >>= fracBits;
 801f6e4:	bf0c      	ite	eq
 801f6e6:	1180      	asreq	r0, r0, #6
		x = sign ^ ((1 << 15) - 1);
 801f6e8:	f080 007f 	eorne.w	r0, r0, #127	@ 0x7f
	return (short)x;
 801f6ec:	f822 0c04 	strh.w	r0, [r2, #-4]
 801f6f0:	f04f 0c14 	mov.w	ip, #20
 801f6f4:	220c      	movs	r2, #12
 801f6f6:	fa07 f002 	lsl.w	r0, r7, r2
 801f6fa:	fa47 f70c 	asr.w	r7, r7, ip
 801f6fe:	fa21 f10c 	lsr.w	r1, r1, ip
 801f702:	ea41 0100 	orr.w	r1, r1, r0
	if (sign != (x >> 15))
 801f706:	154f      	asrs	r7, r1, #21
	sign = x >> 31;
 801f708:	17c8      	asrs	r0, r1, #31
	if (sign != (x >> 15))
 801f70a:	ebb7 7fe1 	cmp.w	r7, r1, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f70e:	bf18      	it	ne
 801f710:	f480 41ff 	eorne.w	r1, r0, #32640	@ 0x7f80
	return (short)x;
 801f714:	9a00      	ldr	r2, [sp, #0]
	x >>= fracBits;
 801f716:	bf0c      	ite	eq
 801f718:	1189      	asreq	r1, r1, #6
		x = sign ^ ((1 << 15) - 1);
 801f71a:	f081 017f 	eorne.w	r1, r1, #127	@ 0x7f
	return (short)x;
 801f71e:	f822 1c02 	strh.w	r1, [r2, #-2]
 801f722:	200c      	movs	r0, #12
 801f724:	9a02      	ldr	r2, [sp, #8]
 801f726:	2714      	movs	r7, #20
 801f728:	fa05 f100 	lsl.w	r1, r5, r0
 801f72c:	fa45 f507 	asr.w	r5, r5, r7
 801f730:	fa22 f207 	lsr.w	r2, r2, r7
 801f734:	ea42 0201 	orr.w	r2, r2, r1
	if (sign != (x >> 15))
 801f738:	1550      	asrs	r0, r2, #21
	sign = x >> 31;
 801f73a:	17d1      	asrs	r1, r2, #31
	if (sign != (x >> 15))
 801f73c:	ebb0 7fe2 	cmp.w	r0, r2, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f740:	bf18      	it	ne
 801f742:	f481 42ff 	eorne.w	r2, r1, #32640	@ 0x7f80
	return (short)x;
 801f746:	9901      	ldr	r1, [sp, #4]
	x >>= fracBits;
 801f748:	bf0c      	ite	eq
 801f74a:	1192      	asreq	r2, r2, #6
		x = sign ^ ((1 << 15) - 1);
 801f74c:	f082 027f 	eorne.w	r2, r2, #127	@ 0x7f
	return (short)x;
 801f750:	f8a1 207c 	strh.w	r2, [r1, #124]	@ 0x7c
 801f754:	2014      	movs	r0, #20
 801f756:	210c      	movs	r1, #12
 801f758:	fa04 f201 	lsl.w	r2, r4, r1
 801f75c:	fa44 f400 	asr.w	r4, r4, r0
 801f760:	fa23 f300 	lsr.w	r3, r3, r0
 801f764:	ea43 0302 	orr.w	r3, r3, r2
	if (sign != (x >> 15))
 801f768:	1559      	asrs	r1, r3, #21
	sign = x >> 31;
 801f76a:	17da      	asrs	r2, r3, #31
	if (sign != (x >> 15))
 801f76c:	ebb1 7fe3 	cmp.w	r1, r3, asr #31
		x = sign ^ ((1 << 15) - 1);
 801f770:	bf18      	it	ne
 801f772:	f482 43ff 	eorne.w	r3, r2, #32640	@ 0x7f80
	return (short)x;
 801f776:	9a01      	ldr	r2, [sp, #4]
	x >>= fracBits;
 801f778:	bf0c      	ite	eq
 801f77a:	119b      	asreq	r3, r3, #6
		x = sign ^ ((1 << 15) - 1);
 801f77c:	f083 037f 	eorne.w	r3, r3, #127	@ 0x7f
	return (short)x;
 801f780:	f8a2 307e 	strh.w	r3, [r2, #126]	@ 0x7e
	for (i = 15; i > 0; i--) {
 801f784:	9b00      	ldr	r3, [sp, #0]
 801f786:	3304      	adds	r3, #4
 801f788:	9300      	str	r3, [sp, #0]
 801f78a:	1f13      	subs	r3, r2, #4
 801f78c:	9301      	str	r3, [sp, #4]
 801f78e:	9b03      	ldr	r3, [sp, #12]
 801f790:	f10b 0b40 	add.w	fp, fp, #64	@ 0x40
 801f794:	459b      	cmp	fp, r3
 801f796:	f506 7680 	add.w	r6, r6, #256	@ 0x100
 801f79a:	f47f ae92 	bne.w	801f4c2 <xmp3_PolyphaseStereo+0x2a2>
		*(pcm + 1)         = ClipToShort((int)SAR64(sum1R, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 0) = ClipToShort((int)SAR64(sum2L, (32-CSHIFT)), DEF_NFRACBITS);
		*(pcm + 2*2*i + 1) = ClipToShort((int)SAR64(sum2R, (32-CSHIFT)), DEF_NFRACBITS);
		pcm += 2;
	}
}
 801f79e:	b005      	add	sp, #20
 801f7a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801f7a4 <xmp3_UnpackScaleFactors>:
 *              updated bitOffset
 *
 * Return:      length (in bytes) of scale factor data, -1 if null input pointers
 **************************************************************************************/
int UnpackScaleFactors(MP3DecInfo *mp3DecInfo, unsigned char *buf, int *bitOffset, int bitsAvail, int gr, int ch)
{
 801f7a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f7a8:	b097      	sub	sp, #92	@ 0x5c
 801f7aa:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 801f7ac:	9d21      	ldr	r5, [sp, #132]	@ 0x84
 801f7ae:	9101      	str	r1, [sp, #4]
	FrameHeader *fh;
	SideInfo *si;
	ScaleFactorInfo *sfi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->FrameHeaderPS || !mp3DecInfo->SideInfoPS || !mp3DecInfo->ScaleFactorInfoPS)
 801f7b0:	9003      	str	r0, [sp, #12]
 801f7b2:	2800      	cmp	r0, #0
 801f7b4:	f000 8396 	beq.w	801fee4 <xmp3_UnpackScaleFactors+0x740>
 801f7b8:	f8d0 9000 	ldr.w	r9, [r0]
 801f7bc:	4617      	mov	r7, r2
 801f7be:	f1b9 0f00 	cmp.w	r9, #0
 801f7c2:	f000 838f 	beq.w	801fee4 <xmp3_UnpackScaleFactors+0x740>
 801f7c6:	6841      	ldr	r1, [r0, #4]
 801f7c8:	9100      	str	r1, [sp, #0]
 801f7ca:	2900      	cmp	r1, #0
 801f7cc:	f000 838a 	beq.w	801fee4 <xmp3_UnpackScaleFactors+0x740>
 801f7d0:	f8d0 8008 	ldr.w	r8, [r0, #8]
 801f7d4:	f1b8 0f00 	cmp.w	r8, #0
 801f7d8:	f000 8384 	beq.w	801fee4 <xmp3_UnpackScaleFactors+0x740>
	sfi = ((ScaleFactorInfo *)(mp3DecInfo->ScaleFactorInfoPS));

	/* init GetBits reader */
	startBuf = buf;
	bsi = &bitStreamInfo;
	SetBitstreamPointer(bsi, (bitsAvail + *bitOffset + 7) / 8, buf);
 801f7dc:	683a      	ldr	r2, [r7, #0]
 801f7de:	4413      	add	r3, r2
 801f7e0:	1dd9      	adds	r1, r3, #7
 801f7e2:	bf48      	it	mi
 801f7e4:	f103 010e 	addmi.w	r1, r3, #14
 801f7e8:	10c9      	asrs	r1, r1, #3
 801f7ea:	9a01      	ldr	r2, [sp, #4]
 801f7ec:	a80a      	add	r0, sp, #40	@ 0x28
 801f7ee:	f7fc fbc1 	bl	801bf74 <xmp3_SetBitstreamPointer>
	if (*bitOffset)
 801f7f2:	6839      	ldr	r1, [r7, #0]
 801f7f4:	2900      	cmp	r1, #0
 801f7f6:	f040 8133 	bne.w	801fa60 <xmp3_UnpackScaleFactors+0x2bc>
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 801f7fa:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
 801f7fe:	eb05 03c5 	add.w	r3, r5, r5, lsl #3
 801f802:	0112      	lsls	r2, r2, #4
 801f804:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 801f808:	9b00      	ldr	r3, [sp, #0]
		GetBits(bsi, *bitOffset);

	if (fh->ver == MPEG1) 
 801f80a:	f899 1000 	ldrb.w	r1, [r9]
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 801f80e:	441a      	add	r2, r3
 801f810:	00e8      	lsls	r0, r5, #3
 801f812:	9005      	str	r0, [sp, #20]
 801f814:	00e0      	lsls	r0, r4, #3
 801f816:	6b53      	ldr	r3, [r2, #52]	@ 0x34
	if (sis->blockType == 2) {
 801f818:	6bd6      	ldr	r6, [r2, #60]	@ 0x3c
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 801f81a:	9004      	str	r0, [sp, #16]
	if (fh->ver == MPEG1) 
 801f81c:	2900      	cmp	r1, #0
 801f81e:	d16f      	bne.n	801f900 <xmp3_UnpackScaleFactors+0x15c>
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 801f820:	49cb      	ldr	r1, [pc, #812]	@ (801fb50 <xmp3_UnpackScaleFactors+0x3ac>)
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 801f822:	eb01 0043 	add.w	r0, r1, r3, lsl #1
	if (sis->blockType == 2) {
 801f826:	2e02      	cmp	r6, #2
	slen0 = (int)SFLenTab[sis->sfCompress][0];
 801f828:	f811 9013 	ldrb.w	r9, [r1, r3, lsl #1]
	slen1 = (int)SFLenTab[sis->sfCompress][1];
 801f82c:	f890 a001 	ldrb.w	sl, [r0, #1]
	if (sis->blockType == 2) {
 801f830:	f000 81ce 	beq.w	801fbd0 <xmp3_UnpackScaleFactors+0x42c>
		if(gr == 0) {
 801f834:	2c00      	cmp	r4, #0
 801f836:	f000 8272 	beq.w	801fd1e <xmp3_UnpackScaleFactors+0x57a>
		UnpackSFMPEG1(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], si->scfsi[ch], gr, &sfi->sfis[0][ch]);
 801f83a:	012b      	lsls	r3, r5, #4
 801f83c:	9a00      	ldr	r2, [sp, #0]
 801f83e:	3308      	adds	r3, #8
 801f840:	18d1      	adds	r1, r2, r3
			if(scfsi[0])  for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801f842:	58d3      	ldr	r3, [r2, r3]
 801f844:	2b00      	cmp	r3, #0
 801f846:	f000 8135 	beq.w	801fab4 <xmp3_UnpackScaleFactors+0x310>
 801f84a:	ebc5 1245 	rsb	r2, r5, r5, lsl #5
 801f84e:	0052      	lsls	r2, r2, #1
 801f850:	1e53      	subs	r3, r2, #1
 801f852:	3205      	adds	r2, #5
 801f854:	eb08 0002 	add.w	r0, r8, r2
 801f858:	ebc4 1244 	rsb	r2, r4, r4, lsl #5
 801f85c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 801f860:	016e      	lsls	r6, r5, #5
 801f862:	4443      	add	r3, r8
 801f864:	4442      	add	r2, r8
 801f866:	9602      	str	r6, [sp, #8]
 801f868:	ea4f 1e44 	mov.w	lr, r4, lsl #5
 801f86c:	f813 6f01 	ldrb.w	r6, [r3, #1]!
 801f870:	f802 6f01 	strb.w	r6, [r2, #1]!
 801f874:	4283      	cmp	r3, r0
 801f876:	d1f9      	bne.n	801f86c <xmp3_UnpackScaleFactors+0xc8>
			if(scfsi[1])  for(  ; sfb <11 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801f878:	684b      	ldr	r3, [r1, #4]
 801f87a:	2b00      	cmp	r3, #0
 801f87c:	f000 82ac 	beq.w	801fdd8 <xmp3_UnpackScaleFactors+0x634>
 801f880:	9b02      	ldr	r3, [sp, #8]
 801f882:	1b5b      	subs	r3, r3, r5
 801f884:	005b      	lsls	r3, r3, #1
 801f886:	1d98      	adds	r0, r3, #6
 801f888:	ebae 0204 	sub.w	r2, lr, r4
 801f88c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 801f890:	f858 6000 	ldr.w	r6, [r8, r0]
 801f894:	1d90      	adds	r0, r2, #6
 801f896:	4443      	add	r3, r8
 801f898:	f848 6000 	str.w	r6, [r8, r0]
 801f89c:	4442      	add	r2, r8
 801f89e:	7a9b      	ldrb	r3, [r3, #10]
 801f8a0:	7293      	strb	r3, [r2, #10]
			if(scfsi[2])  for(  ; sfb <16 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801f8a2:	688b      	ldr	r3, [r1, #8]
 801f8a4:	2b00      	cmp	r3, #0
 801f8a6:	f000 8277 	beq.w	801fd98 <xmp3_UnpackScaleFactors+0x5f4>
 801f8aa:	9b02      	ldr	r3, [sp, #8]
 801f8ac:	1b5b      	subs	r3, r3, r5
 801f8ae:	005b      	lsls	r3, r3, #1
 801f8b0:	f103 000b 	add.w	r0, r3, #11
 801f8b4:	ebae 0204 	sub.w	r2, lr, r4
 801f8b8:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 801f8bc:	f858 6000 	ldr.w	r6, [r8, r0]
 801f8c0:	f102 000b 	add.w	r0, r2, #11
 801f8c4:	4443      	add	r3, r8
 801f8c6:	f848 6000 	str.w	r6, [r8, r0]
 801f8ca:	4442      	add	r2, r8
 801f8cc:	7bdb      	ldrb	r3, [r3, #15]
 801f8ce:	73d3      	strb	r3, [r2, #15]
			if(scfsi[3])  for(  ; sfb <21 ; sfb++) sfis->l[sfb] = sfisGr0->l[sfb];
 801f8d0:	68cb      	ldr	r3, [r1, #12]
 801f8d2:	2b00      	cmp	r3, #0
 801f8d4:	f000 8245 	beq.w	801fd62 <xmp3_UnpackScaleFactors+0x5be>
 801f8d8:	9b02      	ldr	r3, [sp, #8]
 801f8da:	1b5b      	subs	r3, r3, r5
 801f8dc:	005b      	lsls	r3, r3, #1
 801f8de:	f103 0110 	add.w	r1, r3, #16
 801f8e2:	ebae 0204 	sub.w	r2, lr, r4
 801f8e6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 801f8ea:	f858 0001 	ldr.w	r0, [r8, r1]
 801f8ee:	f102 0110 	add.w	r1, r2, #16
 801f8f2:	4443      	add	r3, r8
 801f8f4:	f848 0001 	str.w	r0, [r8, r1]
 801f8f8:	4442      	add	r2, r8
 801f8fa:	7d1b      	ldrb	r3, [r3, #20]
 801f8fc:	7513      	strb	r3, [r2, #20]
 801f8fe:	e085      	b.n	801fa0c <xmp3_UnpackScaleFactors+0x268>
	if (! ((modeExt & 0x01) && (ch == 1)) ) {
 801f900:	f8d9 2020 	ldr.w	r2, [r9, #32]
 801f904:	f012 0901 	ands.w	r9, r2, #1
 801f908:	d002      	beq.n	801f910 <xmp3_UnpackScaleFactors+0x16c>
 801f90a:	2d01      	cmp	r5, #1
 801f90c:	f000 8147 	beq.w	801fb9e <xmp3_UnpackScaleFactors+0x3fa>
		if (sfCompress < 400) {
 801f910:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 801f914:	f280 80a8 	bge.w	801fa68 <xmp3_UnpackScaleFactors+0x2c4>
			slen[0] = (sfCompress >> 4) / 5;
 801f918:	498e      	ldr	r1, [pc, #568]	@ (801fb54 <xmp3_UnpackScaleFactors+0x3b0>)
 801f91a:	1118      	asrs	r0, r3, #4
 801f91c:	fb81 1c00 	smull	r1, ip, r1, r0
 801f920:	17d9      	asrs	r1, r3, #31
 801f922:	ebc1 016c 	rsb	r1, r1, ip, asr #1
 801f926:	910e      	str	r1, [sp, #56]	@ 0x38
			slen[1]= (sfCompress >> 4) % 5;
 801f928:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 801f92c:	1a40      	subs	r0, r0, r1
 801f92e:	900f      	str	r0, [sp, #60]	@ 0x3c
	intensityScale = 0;
 801f930:	2100      	movs	r1, #0
			slen[2]= (sfCompress & 0x0f) >> 2;
 801f932:	f3c3 0081 	ubfx	r0, r3, #2, #2
			slen[3]= (sfCompress & 0x03);
 801f936:	f003 0303 	and.w	r3, r3, #3
 801f93a:	9311      	str	r3, [sp, #68]	@ 0x44
			slen[2]= (sfCompress & 0x0f) >> 2;
 801f93c:	9010      	str	r0, [sp, #64]	@ 0x40
	preFlag = 0;
 801f93e:	468c      	mov	ip, r1
			sfcIdx = 0;
 801f940:	460b      	mov	r3, r1
	if (sis->blockType == 2) 
 801f942:	2e02      	cmp	r6, #2
 801f944:	f000 80f4 	beq.w	801fb30 <xmp3_UnpackScaleFactors+0x38c>
	btIdx = 0;
 801f948:	2000      	movs	r0, #0
		nr[i] = (int)NRTab[sfcIdx][btIdx][i];
 801f94a:	f8df e214 	ldr.w	lr, [pc, #532]	@ 801fb60 <xmp3_UnpackScaleFactors+0x3bc>
 801f94e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801f952:	4403      	add	r3, r0
 801f954:	eb0e 0083 	add.w	r0, lr, r3, lsl #2
 801f958:	f81e 3023 	ldrb.w	r3, [lr, r3, lsl #2]
 801f95c:	9312      	str	r3, [sp, #72]	@ 0x48
 801f95e:	7843      	ldrb	r3, [r0, #1]
 801f960:	9313      	str	r3, [sp, #76]	@ 0x4c
 801f962:	7883      	ldrb	r3, [r0, #2]
 801f964:	9314      	str	r3, [sp, #80]	@ 0x50
 801f966:	78c3      	ldrb	r3, [r0, #3]
 801f968:	9315      	str	r3, [sp, #84]	@ 0x54
	if( (modeExt & 0x01) && (ch == 1) ) {
 801f96a:	f1b9 0f00 	cmp.w	r9, #0
 801f96e:	d002      	beq.n	801f976 <xmp3_UnpackScaleFactors+0x1d2>
 801f970:	2d01      	cmp	r5, #1
 801f972:	f000 80f7 	beq.w	801fb64 <xmp3_UnpackScaleFactors+0x3c0>
 801f976:	f10d 0938 	add.w	r9, sp, #56	@ 0x38
 801f97a:	f10d 0b48 	add.w	fp, sp, #72	@ 0x48
	sis->preFlag = preFlag;
 801f97e:	00e3      	lsls	r3, r4, #3
 801f980:	4423      	add	r3, r4
 801f982:	00ea      	lsls	r2, r5, #3
 801f984:	442a      	add	r2, r5
 801f986:	011b      	lsls	r3, r3, #4
 801f988:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801f98c:	9a00      	ldr	r2, [sp, #0]
 801f98e:	4413      	add	r3, r2
	if(sis->blockType == 2) {
 801f990:	2e02      	cmp	r6, #2
	sis->preFlag = preFlag;
 801f992:	f8c3 c064 	str.w	ip, [r3, #100]	@ 0x64
	if(sis->blockType == 2) {
 801f996:	f000 8174 	beq.w	801fc82 <xmp3_UnpackScaleFactors+0x4de>
 801f99a:	ebc4 1144 	rsb	r1, r4, r4, lsl #5
 801f99e:	ebc5 1245 	rsb	r2, r5, r5, lsl #5
 801f9a2:	0089      	lsls	r1, r1, #2
 801f9a4:	eb01 0142 	add.w	r1, r1, r2, lsl #1
 801f9a8:	016b      	lsls	r3, r5, #5
 801f9aa:	e9cd 1707 	strd	r1, r7, [sp, #28]
		sfb = 0;
 801f9ae:	f04f 0a00 	mov.w	sl, #0
 801f9b2:	9302      	str	r3, [sp, #8]
 801f9b4:	ea4f 1e44 	mov.w	lr, r4, lsl #5
 801f9b8:	eb08 0301 	add.w	r3, r8, r1
 801f9bc:	e9cd 4520 	strd	r4, r5, [sp, #128]	@ 0x80
 801f9c0:	9306      	str	r3, [sp, #24]
 801f9c2:	4655      	mov	r5, sl
 801f9c4:	f8cd e024 	str.w	lr, [sp, #36]	@ 0x24
 801f9c8:	46da      	mov	sl, fp
 801f9ca:	46cb      	mov	fp, r9
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 801f9cc:	f85a 7b04 	ldr.w	r7, [sl], #4
 801f9d0:	2f00      	cmp	r7, #0
 801f9d2:	dd11      	ble.n	801f9f8 <xmp3_UnpackScaleFactors+0x254>
 801f9d4:	9b07      	ldr	r3, [sp, #28]
				sfis->l[sfb] = (char)GetBits(bsi, slen[nrIdx]);
 801f9d6:	f8db 4000 	ldr.w	r4, [fp]
 801f9da:	442b      	add	r3, r5
 801f9dc:	eb08 0903 	add.w	r9, r8, r3
 801f9e0:	9b06      	ldr	r3, [sp, #24]
 801f9e2:	18ee      	adds	r6, r5, r3
 801f9e4:	443e      	add	r6, r7
 801f9e6:	4621      	mov	r1, r4
 801f9e8:	a80a      	add	r0, sp, #40	@ 0x28
 801f9ea:	f7fc fac9 	bl	801bf80 <xmp3_GetBits>
 801f9ee:	f809 0b01 	strb.w	r0, [r9], #1
			for(i=0; i < nr[nrIdx]; i++, sfb++) {
 801f9f2:	45b1      	cmp	r9, r6
 801f9f4:	d1f7      	bne.n	801f9e6 <xmp3_UnpackScaleFactors+0x242>
 801f9f6:	443d      	add	r5, r7
		for (nrIdx = 0; nrIdx <= 3; nrIdx++) {
 801f9f8:	ab16      	add	r3, sp, #88	@ 0x58
 801f9fa:	459a      	cmp	sl, r3
 801f9fc:	f10b 0b04 	add.w	fp, fp, #4
 801fa00:	d1e4      	bne.n	801f9cc <xmp3_UnpackScaleFactors+0x228>
		sfis->l[21] = sfis->l[22] = 0;
 801fa02:	e9dd 4520 	ldrd	r4, r5, [sp, #128]	@ 0x80
 801fa06:	9f08      	ldr	r7, [sp, #32]
 801fa08:	f8dd e024 	ldr.w	lr, [sp, #36]	@ 0x24
 801fa0c:	9a02      	ldr	r2, [sp, #8]
 801fa0e:	ebae 0304 	sub.w	r3, lr, r4
 801fa12:	1b52      	subs	r2, r2, r5
 801fa14:	009b      	lsls	r3, r3, #2
 801fa16:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 801fa1a:	3315      	adds	r3, #21
 801fa1c:	2200      	movs	r2, #0
 801fa1e:	f828 2003 	strh.w	r2, [r8, r3]
	else 
		UnpackSFMPEG2(bsi, &si->sis[gr][ch], &sfi->sfis[gr][ch], gr, ch, fh->modeExt, &sfi->sfjs);

	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 801fa22:	9b04      	ldr	r3, [sp, #16]
 801fa24:	9a05      	ldr	r2, [sp, #20]

	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 801fa26:	9901      	ldr	r1, [sp, #4]
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 801fa28:	4423      	add	r3, r4
 801fa2a:	442a      	add	r2, r5
 801fa2c:	011b      	lsls	r3, r3, #4
 801fa2e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801fa32:	9a00      	ldr	r2, [sp, #0]
 801fa34:	441a      	add	r2, r3
 801fa36:	eb05 0544 	add.w	r5, r5, r4, lsl #1
 801fa3a:	6a93      	ldr	r3, [r2, #40]	@ 0x28
 801fa3c:	9a03      	ldr	r2, [sp, #12]
 801fa3e:	f505 75fc 	add.w	r5, r5, #504	@ 0x1f8
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 801fa42:	a80a      	add	r0, sp, #40	@ 0x28
	mp3DecInfo->part23Length[gr][ch] = si->sis[gr][ch].part23Length;
 801fa44:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
	bitsUsed = CalcBitsUsed(bsi, buf, *bitOffset);
 801fa48:	683a      	ldr	r2, [r7, #0]
 801fa4a:	f7fc faf9 	bl	801c040 <xmp3_CalcBitsUsed>
	buf += (bitsUsed + *bitOffset) >> 3;
 801fa4e:	683b      	ldr	r3, [r7, #0]
 801fa50:	4418      	add	r0, r3
	*bitOffset = (bitsUsed + *bitOffset) & 0x07;
 801fa52:	f000 0307 	and.w	r3, r0, #7
 801fa56:	603b      	str	r3, [r7, #0]
	buf += (bitsUsed + *bitOffset) >> 3;
 801fa58:	10c0      	asrs	r0, r0, #3

	return (buf - startBuf);
}
 801fa5a:	b017      	add	sp, #92	@ 0x5c
 801fa5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		GetBits(bsi, *bitOffset);
 801fa60:	a80a      	add	r0, sp, #40	@ 0x28
 801fa62:	f7fc fa8d 	bl	801bf80 <xmp3_GetBits>
 801fa66:	e6c8      	b.n	801f7fa <xmp3_UnpackScaleFactors+0x56>
		} else if (sfCompress < 500) {
 801fa68:	f5b3 7ffa 	cmp.w	r3, #500	@ 0x1f4
 801fa6c:	db48      	blt.n	801fb00 <xmp3_UnpackScaleFactors+0x35c>
			if (sis->mixedBlock) {
 801fa6e:	00e2      	lsls	r2, r4, #3
			slen[0] = sfCompress / 3;
 801fa70:	4939      	ldr	r1, [pc, #228]	@ (801fb58 <xmp3_UnpackScaleFactors+0x3b4>)
			sfCompress -= 500;
 801fa72:	f5a3 73fa 	sub.w	r3, r3, #500	@ 0x1f4
			if (sis->mixedBlock) {
 801fa76:	1910      	adds	r0, r2, r4
 801fa78:	00ea      	lsls	r2, r5, #3
			slen[0] = sfCompress / 3;
 801fa7a:	fba1 c103 	umull	ip, r1, r1, r3
			if (sis->mixedBlock) {
 801fa7e:	0100      	lsls	r0, r0, #4
 801fa80:	eb02 0c05 	add.w	ip, r2, r5
 801fa84:	9a00      	ldr	r2, [sp, #0]
 801fa86:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
 801fa8a:	4410      	add	r0, r2
			slen[0] = sfCompress / 3;
 801fa8c:	0849      	lsrs	r1, r1, #1
			slen[1] = sfCompress % 3;
 801fa8e:	eb01 0c41 	add.w	ip, r1, r1, lsl #1
			if (sis->mixedBlock) {
 801fa92:	6c00      	ldr	r0, [r0, #64]	@ 0x40
			slen[0] = sfCompress / 3;
 801fa94:	910e      	str	r1, [sp, #56]	@ 0x38
			slen[1] = sfCompress % 3;
 801fa96:	eba3 030c 	sub.w	r3, r3, ip
			slen[2] = slen[3] = 0;
 801fa9a:	f04f 0c00 	mov.w	ip, #0
 801fa9e:	e9cd cc10 	strd	ip, ip, [sp, #64]	@ 0x40
			slen[1] = sfCompress % 3;
 801faa2:	930f      	str	r3, [sp, #60]	@ 0x3c
			if (sis->mixedBlock) {
 801faa4:	b108      	cbz	r0, 801faaa <xmp3_UnpackScaleFactors+0x306>
				slen[1] = slen[0];
 801faa6:	e9cd 130f 	strd	r1, r3, [sp, #60]	@ 0x3c
	intensityScale = 0;
 801faaa:	2100      	movs	r1, #0
			preFlag = 1;
 801faac:	f04f 0c01 	mov.w	ip, #1
			sfcIdx = 2;
 801fab0:	2302      	movs	r3, #2
 801fab2:	e746      	b.n	801f942 <xmp3_UnpackScaleFactors+0x19e>
 801fab4:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
 801fab8:	005b      	lsls	r3, r3, #1
 801faba:	ebc4 1244 	rsb	r2, r4, r4, lsl #5
 801fabe:	f103 3bff 	add.w	fp, r3, #4294967295
 801fac2:	1d5e      	adds	r6, r3, #5
 801fac4:	eb0b 0b82 	add.w	fp, fp, r2, lsl #2
 801fac8:	44c3      	add	fp, r8
 801faca:	ea4f 1e44 	mov.w	lr, r4, lsl #5
 801face:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 801fad2:	016b      	lsls	r3, r5, #5
 801fad4:	4446      	add	r6, r8
 801fad6:	f8cd 8018 	str.w	r8, [sp, #24]
 801fada:	9420      	str	r4, [sp, #128]	@ 0x80
 801fadc:	9302      	str	r3, [sp, #8]
 801fade:	465c      	mov	r4, fp
 801fae0:	4688      	mov	r8, r1
 801fae2:	46f3      	mov	fp, lr
			else          for(  ; sfb < 6 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 801fae4:	4649      	mov	r1, r9
 801fae6:	a80a      	add	r0, sp, #40	@ 0x28
 801fae8:	f7fc fa4a 	bl	801bf80 <xmp3_GetBits>
 801faec:	f804 0f01 	strb.w	r0, [r4, #1]!
 801faf0:	42b4      	cmp	r4, r6
 801faf2:	d1f7      	bne.n	801fae4 <xmp3_UnpackScaleFactors+0x340>
 801faf4:	4641      	mov	r1, r8
 801faf6:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 801faf8:	f8dd 8018 	ldr.w	r8, [sp, #24]
 801fafc:	46de      	mov	lr, fp
 801fafe:	e6bb      	b.n	801f878 <xmp3_UnpackScaleFactors+0xd4>
			sfCompress -= 400;
 801fb00:	f5a3 73c8 	sub.w	r3, r3, #400	@ 0x190
			slen[0] = (sfCompress >> 2) / 5;
 801fb04:	4915      	ldr	r1, [pc, #84]	@ (801fb5c <xmp3_UnpackScaleFactors+0x3b8>)
 801fb06:	1098      	asrs	r0, r3, #2
 801fb08:	fba1 c100 	umull	ip, r1, r1, r0
 801fb0c:	0889      	lsrs	r1, r1, #2
 801fb0e:	910e      	str	r1, [sp, #56]	@ 0x38
			slen[1]= (sfCompress >> 2) % 5;
 801fb10:	eb01 0181 	add.w	r1, r1, r1, lsl #2
			slen[2]= (sfCompress & 0x03);
 801fb14:	f003 0303 	and.w	r3, r3, #3
			slen[1]= (sfCompress >> 2) % 5;
 801fb18:	1a40      	subs	r0, r0, r1
	if (sis->blockType == 2) 
 801fb1a:	2e02      	cmp	r6, #2
			slen[3]= 0;
 801fb1c:	f04f 0100 	mov.w	r1, #0
			slen[2]= (sfCompress & 0x03);
 801fb20:	9310      	str	r3, [sp, #64]	@ 0x40
			slen[1]= (sfCompress >> 2) % 5;
 801fb22:	900f      	str	r0, [sp, #60]	@ 0x3c
			slen[3]= 0;
 801fb24:	9111      	str	r1, [sp, #68]	@ 0x44
	preFlag = 0;
 801fb26:	468c      	mov	ip, r1
			sfcIdx = 1;
 801fb28:	f04f 0301 	mov.w	r3, #1
	if (sis->blockType == 2) 
 801fb2c:	f47f af0c 	bne.w	801f948 <xmp3_UnpackScaleFactors+0x1a4>
		btIdx = (sis->mixedBlock ? 2 : 1);
 801fb30:	00e0      	lsls	r0, r4, #3
 801fb32:	00ea      	lsls	r2, r5, #3
 801fb34:	4420      	add	r0, r4
 801fb36:	eb02 0e05 	add.w	lr, r2, r5
 801fb3a:	0100      	lsls	r0, r0, #4
 801fb3c:	9a00      	ldr	r2, [sp, #0]
 801fb3e:	eb00 00ce 	add.w	r0, r0, lr, lsl #3
 801fb42:	4410      	add	r0, r2
 801fb44:	6c00      	ldr	r0, [r0, #64]	@ 0x40
 801fb46:	2800      	cmp	r0, #0
 801fb48:	bf0c      	ite	eq
 801fb4a:	2001      	moveq	r0, #1
 801fb4c:	2002      	movne	r0, #2
 801fb4e:	e6fc      	b.n	801f94a <xmp3_UnpackScaleFactors+0x1a6>
 801fb50:	080380bc 	.word	0x080380bc
 801fb54:	66666667 	.word	0x66666667
 801fb58:	aaaaaaab 	.word	0xaaaaaaab
 801fb5c:	cccccccd 	.word	0xcccccccd
 801fb60:	08038074 	.word	0x08038074
			sfjs->slen[i] = slen[i];
 801fb64:	f10d 0938 	add.w	r9, sp, #56	@ 0x38
 801fb68:	46ca      	mov	sl, r9
		sfjs->intensityScale = intensityScale;
 801fb6a:	f8c8 10f8 	str.w	r1, [r8, #248]	@ 0xf8
			sfjs->slen[i] = slen[i];
 801fb6e:	e8ba 000f 	ldmia.w	sl!, {r0, r1, r2, r3}
			sfjs->nr[i] = nr[i];
 801fb72:	f10d 0b48 	add.w	fp, sp, #72	@ 0x48
 801fb76:	46de      	mov	lr, fp
			sfjs->slen[i] = slen[i];
 801fb78:	f8c8 00fc 	str.w	r0, [r8, #252]	@ 0xfc
 801fb7c:	f8c8 1100 	str.w	r1, [r8, #256]	@ 0x100
 801fb80:	f8c8 2104 	str.w	r2, [r8, #260]	@ 0x104
 801fb84:	f8c8 3108 	str.w	r3, [r8, #264]	@ 0x108
			sfjs->nr[i] = nr[i];
 801fb88:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801fb8c:	f8c8 010c 	str.w	r0, [r8, #268]	@ 0x10c
 801fb90:	f8c8 1110 	str.w	r1, [r8, #272]	@ 0x110
 801fb94:	f8c8 2114 	str.w	r2, [r8, #276]	@ 0x114
 801fb98:	f8c8 3118 	str.w	r3, [r8, #280]	@ 0x118
		sfjs->intensityScale = intensityScale;
 801fb9c:	e6ef      	b.n	801f97e <xmp3_UnpackScaleFactors+0x1da>
		if (sfCompress < 180) {
 801fb9e:	f5b3 7fb4 	cmp.w	r3, #360	@ 0x168
		intensityScale = sfCompress & 0x01;
 801fba2:	f003 0101 	and.w	r1, r3, #1
		sfCompress >>= 1;
 801fba6:	ea4f 0063 	mov.w	r0, r3, asr #1
		if (sfCompress < 180) {
 801fbaa:	f2c0 817f 	blt.w	801feac <xmp3_UnpackScaleFactors+0x708>
		} else if (sfCompress < 244) {
 801fbae:	28f3      	cmp	r0, #243	@ 0xf3
 801fbb0:	f300 819b 	bgt.w	801feea <xmp3_UnpackScaleFactors+0x746>
			sfCompress -= 180;
 801fbb4:	38b4      	subs	r0, #180	@ 0xb4
			slen[3] = 0;
 801fbb6:	2300      	movs	r3, #0
 801fbb8:	9311      	str	r3, [sp, #68]	@ 0x44
	preFlag = 0;
 801fbba:	469c      	mov	ip, r3
			slen[0] = (sfCompress & 0x3f) >> 4;
 801fbbc:	1103      	asrs	r3, r0, #4
 801fbbe:	930e      	str	r3, [sp, #56]	@ 0x38
			slen[1] = (sfCompress & 0x0f) >> 2;
 801fbc0:	f3c0 0381 	ubfx	r3, r0, #2, #2
			slen[2] = (sfCompress & 0x03);
 801fbc4:	f000 0003 	and.w	r0, r0, #3
			slen[1] = (sfCompress & 0x0f) >> 2;
 801fbc8:	930f      	str	r3, [sp, #60]	@ 0x3c
			slen[2] = (sfCompress & 0x03);
 801fbca:	9010      	str	r0, [sp, #64]	@ 0x40
			sfcIdx = 4;
 801fbcc:	2304      	movs	r3, #4
 801fbce:	e6b8      	b.n	801f942 <xmp3_UnpackScaleFactors+0x19e>
		if (sis->mixedBlock) {          
 801fbd0:	6c11      	ldr	r1, [r2, #64]	@ 0x40
 801fbd2:	2900      	cmp	r1, #0
 801fbd4:	f040 8149 	bne.w	801fe6a <xmp3_UnpackScaleFactors+0x6c6>
 801fbd8:	016b      	lsls	r3, r5, #5
 801fbda:	9302      	str	r3, [sp, #8]
 801fbdc:	ea4f 1e44 	mov.w	lr, r4, lsl #5
 801fbe0:	9b02      	ldr	r3, [sp, #8]
 801fbe2:	9420      	str	r4, [sp, #128]	@ 0x80
 801fbe4:	ebae 0204 	sub.w	r2, lr, r4
 801fbe8:	0092      	lsls	r2, r2, #2
 801fbea:	1b58      	subs	r0, r3, r5
 801fbec:	eb02 0340 	add.w	r3, r2, r0, lsl #1
 801fbf0:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 801fbf4:	461e      	mov	r6, r3
 801fbf6:	4419      	add	r1, r3
 801fbf8:	eb08 0b01 	add.w	fp, r8, r1
 801fbfc:	3612      	adds	r6, #18
 801fbfe:	465c      	mov	r4, fp
 801fc00:	4446      	add	r6, r8
 801fc02:	9306      	str	r3, [sp, #24]
 801fc04:	46f3      	mov	fp, lr
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 801fc06:	4649      	mov	r1, r9
 801fc08:	a80a      	add	r0, sp, #40	@ 0x28
 801fc0a:	f7fc f9b9 	bl	801bf80 <xmp3_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 801fc0e:	4649      	mov	r1, r9
			sfis->s[sfb][0] = (char)GetBits(bsi, slen0);
 801fc10:	75e0      	strb	r0, [r4, #23]
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 801fc12:	a80a      	add	r0, sp, #40	@ 0x28
 801fc14:	f7fc f9b4 	bl	801bf80 <xmp3_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 801fc18:	4649      	mov	r1, r9
			sfis->s[sfb][1] = (char)GetBits(bsi, slen0);
 801fc1a:	7620      	strb	r0, [r4, #24]
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 801fc1c:	a80a      	add	r0, sp, #40	@ 0x28
 801fc1e:	f7fc f9af 	bl	801bf80 <xmp3_GetBits>
		for (      ; sfb < 6; sfb++) {
 801fc22:	3403      	adds	r4, #3
			sfis->s[sfb][2] = (char)GetBits(bsi, slen0);
 801fc24:	75a0      	strb	r0, [r4, #22]
		for (      ; sfb < 6; sfb++) {
 801fc26:	42b4      	cmp	r4, r6
 801fc28:	d1ed      	bne.n	801fc06 <xmp3_UnpackScaleFactors+0x462>
 801fc2a:	9b06      	ldr	r3, [sp, #24]
 801fc2c:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 801fc2e:	eb08 0903 	add.w	r9, r8, r3
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 801fc32:	4651      	mov	r1, sl
 801fc34:	a80a      	add	r0, sp, #40	@ 0x28
 801fc36:	f7fc f9a3 	bl	801bf80 <xmp3_GetBits>
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 801fc3a:	4651      	mov	r1, sl
			sfis->s[sfb][0] = (char)GetBits(bsi, slen1);
 801fc3c:	f889 0029 	strb.w	r0, [r9, #41]	@ 0x29
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 801fc40:	a80a      	add	r0, sp, #40	@ 0x28
 801fc42:	f7fc f99d 	bl	801bf80 <xmp3_GetBits>
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 801fc46:	4651      	mov	r1, sl
			sfis->s[sfb][1] = (char)GetBits(bsi, slen1);
 801fc48:	f889 002a 	strb.w	r0, [r9, #42]	@ 0x2a
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 801fc4c:	a80a      	add	r0, sp, #40	@ 0x28
 801fc4e:	f7fc f997 	bl	801bf80 <xmp3_GetBits>
		for (      ; sfb < 12; sfb++) {
 801fc52:	f109 0903 	add.w	r9, r9, #3
			sfis->s[sfb][2] = (char)GetBits(bsi, slen1);
 801fc56:	f889 0028 	strb.w	r0, [r9, #40]	@ 0x28
		for (      ; sfb < 12; sfb++) {
 801fc5a:	454e      	cmp	r6, r9
 801fc5c:	d1e9      	bne.n	801fc32 <xmp3_UnpackScaleFactors+0x48e>
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 801fc5e:	46de      	mov	lr, fp
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 801fc60:	9a02      	ldr	r2, [sp, #8]
 801fc62:	ebae 0304 	sub.w	r3, lr, r4
 801fc66:	1b52      	subs	r2, r2, r5
 801fc68:	009b      	lsls	r3, r3, #2
 801fc6a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 801fc6e:	f103 0234 	add.w	r2, r3, #52	@ 0x34
 801fc72:	4442      	add	r2, r8
 801fc74:	4443      	add	r3, r8
 801fc76:	2100      	movs	r1, #0
 801fc78:	f883 103d 	strb.w	r1, [r3, #61]	@ 0x3d
 801fc7c:	f8a2 1007 	strh.w	r1, [r2, #7]
 801fc80:	e6cf      	b.n	801fa22 <xmp3_UnpackScaleFactors+0x27e>
		if(sis->mixedBlock) {
 801fc82:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 801fc84:	2a00      	cmp	r2, #0
 801fc86:	f040 80ca 	bne.w	801fe1e <xmp3_UnpackScaleFactors+0x67a>
 801fc8a:	0169      	lsls	r1, r5, #5
			sfb = 0;
 801fc8c:	4613      	mov	r3, r2
 801fc8e:	9102      	str	r1, [sp, #8]
 801fc90:	ea4f 1e44 	mov.w	lr, r4, lsl #5
 801fc94:	eb09 0a82 	add.w	sl, r9, r2, lsl #2
 801fc98:	eb0b 0b82 	add.w	fp, fp, r2, lsl #2
 801fc9c:	9a02      	ldr	r2, [sp, #8]
 801fc9e:	9420      	str	r4, [sp, #128]	@ 0x80
 801fca0:	ebae 0c04 	sub.w	ip, lr, r4
 801fca4:	1b50      	subs	r0, r2, r5
 801fca6:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 801fcaa:	eb0c 0240 	add.w	r2, ip, r0, lsl #1
 801fcae:	eb08 0102 	add.w	r1, r8, r2
 801fcb2:	e9cd 1706 	strd	r1, r7, [sp, #24]
 801fcb6:	9521      	str	r5, [sp, #132]	@ 0x84
 801fcb8:	465c      	mov	r4, fp
 801fcba:	4655      	mov	r5, sl
 801fcbc:	f8cd e020 	str.w	lr, [sp, #32]
 801fcc0:	4692      	mov	sl, r2
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 801fcc2:	f854 2b04 	ldr.w	r2, [r4], #4
 801fcc6:	2a00      	cmp	r2, #0
 801fcc8:	dd1e      	ble.n	801fd08 <xmp3_UnpackScaleFactors+0x564>
 801fcca:	eb02 0b03 	add.w	fp, r2, r3
 801fcce:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801fcd2:	4453      	add	r3, sl
 801fcd4:	eb08 0703 	add.w	r7, r8, r3
 801fcd8:	9b06      	ldr	r3, [sp, #24]
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 801fcda:	682e      	ldr	r6, [r5, #0]
 801fcdc:	eb0b 094b 	add.w	r9, fp, fp, lsl #1
 801fce0:	4499      	add	r9, r3
 801fce2:	4631      	mov	r1, r6
 801fce4:	a80a      	add	r0, sp, #40	@ 0x28
 801fce6:	f7fc f94b 	bl	801bf80 <xmp3_GetBits>
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 801fcea:	4631      	mov	r1, r6
				sfis->s[sfb][0] = (char)GetBits(bsi, slen[nrIdx]);
 801fcec:	75f8      	strb	r0, [r7, #23]
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 801fcee:	a80a      	add	r0, sp, #40	@ 0x28
 801fcf0:	f7fc f946 	bl	801bf80 <xmp3_GetBits>
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 801fcf4:	4631      	mov	r1, r6
				sfis->s[sfb][1] = (char)GetBits(bsi, slen[nrIdx]);
 801fcf6:	7638      	strb	r0, [r7, #24]
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 801fcf8:	a80a      	add	r0, sp, #40	@ 0x28
 801fcfa:	f7fc f941 	bl	801bf80 <xmp3_GetBits>
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 801fcfe:	3703      	adds	r7, #3
				sfis->s[sfb][2] = (char)GetBits(bsi, slen[nrIdx]);
 801fd00:	75b8      	strb	r0, [r7, #22]
			for (i=0; i < nr[nrIdx]; i++, sfb++) {
 801fd02:	454f      	cmp	r7, r9
 801fd04:	d1ed      	bne.n	801fce2 <xmp3_UnpackScaleFactors+0x53e>
 801fd06:	465b      	mov	r3, fp
		for (    ; nrIdx <= 3; nrIdx++) {
 801fd08:	aa16      	add	r2, sp, #88	@ 0x58
 801fd0a:	4294      	cmp	r4, r2
 801fd0c:	f105 0504 	add.w	r5, r5, #4
 801fd10:	d1d7      	bne.n	801fcc2 <xmp3_UnpackScaleFactors+0x51e>
		sfis->s[12][0] = sfis->s[12][1] = sfis->s[12][2] = 0;
 801fd12:	e9dd 4520 	ldrd	r4, r5, [sp, #128]	@ 0x80
 801fd16:	9f07      	ldr	r7, [sp, #28]
 801fd18:	f8dd e020 	ldr.w	lr, [sp, #32]
 801fd1c:	e7a0      	b.n	801fc60 <xmp3_UnpackScaleFactors+0x4bc>
 801fd1e:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
 801fd22:	005b      	lsls	r3, r3, #1
 801fd24:	f103 3bff 	add.w	fp, r3, #4294967295
 801fd28:	44c3      	add	fp, r8
 801fd2a:	f103 060a 	add.w	r6, r3, #10
 801fd2e:	9420      	str	r4, [sp, #128]	@ 0x80
 801fd30:	4446      	add	r6, r8
 801fd32:	465c      	mov	r4, fp
 801fd34:	469b      	mov	fp, r3
				sfis->l[sfb] = (char)GetBits(bsi, slen0);
 801fd36:	4649      	mov	r1, r9
 801fd38:	a80a      	add	r0, sp, #40	@ 0x28
 801fd3a:	f7fc f921 	bl	801bf80 <xmp3_GetBits>
 801fd3e:	f804 0f01 	strb.w	r0, [r4, #1]!
			for (sfb = 0;  sfb < 11; sfb++) 
 801fd42:	42b4      	cmp	r4, r6
 801fd44:	d1f7      	bne.n	801fd36 <xmp3_UnpackScaleFactors+0x592>
 801fd46:	465b      	mov	r3, fp
 801fd48:	3314      	adds	r3, #20
 801fd4a:	46a3      	mov	fp, r4
 801fd4c:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 801fd4e:	4498      	add	r8, r3
				sfis->l[sfb] = (char)GetBits(bsi, slen1);
 801fd50:	4651      	mov	r1, sl
 801fd52:	a80a      	add	r0, sp, #40	@ 0x28
 801fd54:	f7fc f914 	bl	801bf80 <xmp3_GetBits>
 801fd58:	f80b 0f01 	strb.w	r0, [fp, #1]!
			for (sfb = 11; sfb < 21; sfb++) 
 801fd5c:	45c3      	cmp	fp, r8
 801fd5e:	d1f7      	bne.n	801fd50 <xmp3_UnpackScaleFactors+0x5ac>
 801fd60:	e65f      	b.n	801fa22 <xmp3_UnpackScaleFactors+0x27e>
 801fd62:	9b02      	ldr	r3, [sp, #8]
 801fd64:	1b5a      	subs	r2, r3, r5
 801fd66:	0052      	lsls	r2, r2, #1
 801fd68:	ebae 0304 	sub.w	r3, lr, r4
 801fd6c:	f102 010f 	add.w	r1, r2, #15
 801fd70:	f102 0614 	add.w	r6, r2, #20
 801fd74:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801fd78:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 801fd7c:	eb08 0901 	add.w	r9, r8, r1
 801fd80:	4446      	add	r6, r8
 801fd82:	46f3      	mov	fp, lr
			else          for(  ; sfb <21 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 801fd84:	4651      	mov	r1, sl
 801fd86:	a80a      	add	r0, sp, #40	@ 0x28
 801fd88:	f7fc f8fa 	bl	801bf80 <xmp3_GetBits>
 801fd8c:	f809 0f01 	strb.w	r0, [r9, #1]!
 801fd90:	45b1      	cmp	r9, r6
 801fd92:	d1f7      	bne.n	801fd84 <xmp3_UnpackScaleFactors+0x5e0>
 801fd94:	46de      	mov	lr, fp
 801fd96:	e639      	b.n	801fa0c <xmp3_UnpackScaleFactors+0x268>
 801fd98:	9b02      	ldr	r3, [sp, #8]
 801fd9a:	9420      	str	r4, [sp, #128]	@ 0x80
 801fd9c:	1b5b      	subs	r3, r3, r5
 801fd9e:	005b      	lsls	r3, r3, #1
 801fda0:	ebae 0204 	sub.w	r2, lr, r4
 801fda4:	f103 000a 	add.w	r0, r3, #10
 801fda8:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 801fdac:	330f      	adds	r3, #15
 801fdae:	eb08 0900 	add.w	r9, r8, r0
 801fdb2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801fdb6:	464c      	mov	r4, r9
 801fdb8:	eb08 0603 	add.w	r6, r8, r3
 801fdbc:	468b      	mov	fp, r1
 801fdbe:	46f1      	mov	r9, lr
			else          for(  ; sfb <16 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen1);
 801fdc0:	4651      	mov	r1, sl
 801fdc2:	a80a      	add	r0, sp, #40	@ 0x28
 801fdc4:	f7fc f8dc 	bl	801bf80 <xmp3_GetBits>
 801fdc8:	f804 0f01 	strb.w	r0, [r4, #1]!
 801fdcc:	42b4      	cmp	r4, r6
 801fdce:	d1f7      	bne.n	801fdc0 <xmp3_UnpackScaleFactors+0x61c>
 801fdd0:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 801fdd2:	4659      	mov	r1, fp
 801fdd4:	46ce      	mov	lr, r9
 801fdd6:	e57b      	b.n	801f8d0 <xmp3_UnpackScaleFactors+0x12c>
 801fdd8:	9b02      	ldr	r3, [sp, #8]
 801fdda:	f8cd 8018 	str.w	r8, [sp, #24]
 801fdde:	1b5b      	subs	r3, r3, r5
 801fde0:	005b      	lsls	r3, r3, #1
 801fde2:	ebae 0204 	sub.w	r2, lr, r4
 801fde6:	1d58      	adds	r0, r3, #5
 801fde8:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 801fdec:	330a      	adds	r3, #10
 801fdee:	eb08 0b00 	add.w	fp, r8, r0
 801fdf2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801fdf6:	eb08 0603 	add.w	r6, r8, r3
 801fdfa:	9420      	str	r4, [sp, #128]	@ 0x80
 801fdfc:	4688      	mov	r8, r1
 801fdfe:	465c      	mov	r4, fp
 801fe00:	46f3      	mov	fp, lr
			else          for(  ; sfb <11 ; sfb++) sfis->l[sfb] = (char)GetBits(bsi, slen0);
 801fe02:	4649      	mov	r1, r9
 801fe04:	a80a      	add	r0, sp, #40	@ 0x28
 801fe06:	f7fc f8bb 	bl	801bf80 <xmp3_GetBits>
 801fe0a:	f804 0f01 	strb.w	r0, [r4, #1]!
 801fe0e:	42b4      	cmp	r4, r6
 801fe10:	d1f7      	bne.n	801fe02 <xmp3_UnpackScaleFactors+0x65e>
 801fe12:	4641      	mov	r1, r8
 801fe14:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 801fe16:	f8dd 8018 	ldr.w	r8, [sp, #24]
 801fe1a:	46de      	mov	lr, fp
 801fe1c:	e541      	b.n	801f8a2 <xmp3_UnpackScaleFactors+0xfe>
 801fe1e:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
 801fe22:	005b      	lsls	r3, r3, #1
 801fe24:	ebc4 1244 	rsb	r2, r4, r4, lsl #5
 801fe28:	1e59      	subs	r1, r3, #1
 801fe2a:	1d5e      	adds	r6, r3, #5
 801fe2c:	eb01 0382 	add.w	r3, r1, r2, lsl #2
 801fe30:	eb08 0a03 	add.w	sl, r8, r3
				sfis->l[sfb] = (char)GetBits(bsi, slen[0]);
 801fe34:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 801fe36:	9420      	str	r4, [sp, #128]	@ 0x80
 801fe38:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 801fe3c:	ea4f 1e44 	mov.w	lr, r4, lsl #5
 801fe40:	016a      	lsls	r2, r5, #5
 801fe42:	9521      	str	r5, [sp, #132]	@ 0x84
 801fe44:	4446      	add	r6, r8
 801fe46:	4655      	mov	r5, sl
 801fe48:	9202      	str	r2, [sp, #8]
 801fe4a:	461c      	mov	r4, r3
 801fe4c:	46f2      	mov	sl, lr
 801fe4e:	4621      	mov	r1, r4
 801fe50:	a80a      	add	r0, sp, #40	@ 0x28
 801fe52:	f7fc f895 	bl	801bf80 <xmp3_GetBits>
 801fe56:	f805 0f01 	strb.w	r0, [r5, #1]!
			for (sfb=0; sfb < 6; sfb++) {
 801fe5a:	42b5      	cmp	r5, r6
 801fe5c:	d1f7      	bne.n	801fe4e <xmp3_UnpackScaleFactors+0x6aa>
			sfb = 3;  /* start sfb for short */
 801fe5e:	e9dd 4520 	ldrd	r4, r5, [sp, #128]	@ 0x80
 801fe62:	46d6      	mov	lr, sl
 801fe64:	2303      	movs	r3, #3
			nrIdx = 1;
 801fe66:	2201      	movs	r2, #1
 801fe68:	e714      	b.n	801fc94 <xmp3_UnpackScaleFactors+0x4f0>
 801fe6a:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
 801fe6e:	005b      	lsls	r3, r3, #1
 801fe70:	ebc4 1244 	rsb	r2, r4, r4, lsl #5
 801fe74:	f103 3bff 	add.w	fp, r3, #4294967295
 801fe78:	1dde      	adds	r6, r3, #7
 801fe7a:	eb0b 0b82 	add.w	fp, fp, r2, lsl #2
 801fe7e:	44c3      	add	fp, r8
 801fe80:	ea4f 1e44 	mov.w	lr, r4, lsl #5
 801fe84:	eb06 0682 	add.w	r6, r6, r2, lsl #2
 801fe88:	016b      	lsls	r3, r5, #5
 801fe8a:	9420      	str	r4, [sp, #128]	@ 0x80
 801fe8c:	4446      	add	r6, r8
 801fe8e:	465c      	mov	r4, fp
 801fe90:	9302      	str	r3, [sp, #8]
 801fe92:	46f3      	mov	fp, lr
				sfis->l[sfb] =    (char)GetBits(bsi, slen0);
 801fe94:	4649      	mov	r1, r9
 801fe96:	a80a      	add	r0, sp, #40	@ 0x28
 801fe98:	f7fc f872 	bl	801bf80 <xmp3_GetBits>
 801fe9c:	f804 0f01 	strb.w	r0, [r4, #1]!
			for (sfb = 0; sfb < 8; sfb++)
 801fea0:	42b4      	cmp	r4, r6
 801fea2:	d1f7      	bne.n	801fe94 <xmp3_UnpackScaleFactors+0x6f0>
			sfb = 3;
 801fea4:	9c20      	ldr	r4, [sp, #128]	@ 0x80
 801fea6:	46de      	mov	lr, fp
 801fea8:	2103      	movs	r1, #3
 801feaa:	e699      	b.n	801fbe0 <xmp3_UnpackScaleFactors+0x43c>
			slen[0] = (sfCompress / 36);
 801feac:	f8df c064 	ldr.w	ip, [pc, #100]	@ 801ff14 <xmp3_UnpackScaleFactors+0x770>
 801feb0:	17db      	asrs	r3, r3, #31
 801feb2:	fb8c ce00 	smull	ip, lr, ip, r0
 801feb6:	ebc3 03ee 	rsb	r3, r3, lr, asr #3
 801feba:	930e      	str	r3, [sp, #56]	@ 0x38
			slen[1] = (sfCompress % 36) / 6;
 801febc:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
 801fec0:	eba0 0383 	sub.w	r3, r0, r3, lsl #2
 801fec4:	4811      	ldr	r0, [pc, #68]	@ (801ff0c <xmp3_UnpackScaleFactors+0x768>)
 801fec6:	fb80 c003 	smull	ip, r0, r0, r3
 801feca:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
 801fece:	900f      	str	r0, [sp, #60]	@ 0x3c
			slen[2] = (sfCompress % 36) % 6;
 801fed0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801fed4:	eba3 0340 	sub.w	r3, r3, r0, lsl #1
 801fed8:	9310      	str	r3, [sp, #64]	@ 0x40
			slen[3] = 0;
 801feda:	2300      	movs	r3, #0
 801fedc:	9311      	str	r3, [sp, #68]	@ 0x44
	preFlag = 0;
 801fede:	469c      	mov	ip, r3
			sfcIdx = 3;
 801fee0:	2303      	movs	r3, #3
 801fee2:	e52e      	b.n	801f942 <xmp3_UnpackScaleFactors+0x19e>
		return -1;
 801fee4:	f04f 30ff 	mov.w	r0, #4294967295
 801fee8:	e5b7      	b.n	801fa5a <xmp3_UnpackScaleFactors+0x2b6>
			slen[0] = (sfCompress / 3);
 801feea:	4b09      	ldr	r3, [pc, #36]	@ (801ff10 <xmp3_UnpackScaleFactors+0x76c>)
			sfCompress -= 244;
 801feec:	38f4      	subs	r0, #244	@ 0xf4
			slen[0] = (sfCompress / 3);
 801feee:	fba3 c300 	umull	ip, r3, r3, r0
 801fef2:	085b      	lsrs	r3, r3, #1
 801fef4:	930e      	str	r3, [sp, #56]	@ 0x38
			slen[1] = (sfCompress % 3);
 801fef6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801fefa:	1ac0      	subs	r0, r0, r3
			slen[2] = slen[3] = 0;
 801fefc:	2300      	movs	r3, #0
 801fefe:	e9cd 3310 	strd	r3, r3, [sp, #64]	@ 0x40
	preFlag = 0;
 801ff02:	469c      	mov	ip, r3
			slen[1] = (sfCompress % 3);
 801ff04:	900f      	str	r0, [sp, #60]	@ 0x3c
			sfcIdx = 5;
 801ff06:	2305      	movs	r3, #5
 801ff08:	e51b      	b.n	801f942 <xmp3_UnpackScaleFactors+0x19e>
 801ff0a:	bf00      	nop
 801ff0c:	2aaaaaab 	.word	0x2aaaaaab
 801ff10:	aaaaaaab 	.word	0xaaaaaaab
 801ff14:	38e38e39 	.word	0x38e38e39

0801ff18 <xmp3_MidSideProc>:
 * Return:      none
 *
 * Notes:       assume at least 1 GB in input
 **************************************************************************************/
void MidSideProc(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, int mOut[2])  
{
 801ff18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	
	/* L = (M+S)/sqrt(2), R = (M-S)/sqrt(2) 
	 * NOTE: 1/sqrt(2) done in DequantChannel() - see comments there
	 */
	mOutL = mOutR = 0;
	for(i = 0; i < nSamps; i++) {
 801ff1c:	f1b1 0800 	subs.w	r8, r1, #0
 801ff20:	dd2c      	ble.n	801ff7c <xmp3_MidSideProc+0x64>
	mOutL = mOutR = 0;
 801ff22:	2500      	movs	r5, #0
 801ff24:	f1a0 0c04 	sub.w	ip, r0, #4
 801ff28:	f600 0efc 	addw	lr, r0, #2300	@ 0x8fc
 801ff2c:	462e      	mov	r6, r5
	for(i = 0; i < nSamps; i++) {
 801ff2e:	4629      	mov	r1, r5
	__asm__ volatile (
 801ff30:	462f      	mov	r7, r5
		xl = x[0][i];
 801ff32:	f85c 3f04 	ldr.w	r3, [ip, #4]!
		xr = x[1][i];
 801ff36:	f85e 4f04 	ldr.w	r4, [lr, #4]!
		x[0][i] = xl + xr;
 801ff3a:	eb03 0904 	add.w	r9, r3, r4
		x[1][i] = xl - xr;
 801ff3e:	1b1b      	subs	r3, r3, r4
		x[0][i] = xl + xr;
 801ff40:	f8cc 9000 	str.w	r9, [ip]
		x[1][i] = xl - xr;
 801ff44:	f8ce 3000 	str.w	r3, [lr]
 801ff48:	f8dc 4000 	ldr.w	r4, [ip]
 801ff4c:	4638      	mov	r0, r7
 801ff4e:	ea84 70e4 	eor.w	r0, r4, r4, asr #31
 801ff52:	eba0 70e4 	sub.w	r0, r0, r4, asr #31
		mOutL |= FASTABS(x[0][i]);
 801ff56:	4306      	orrs	r6, r0
 801ff58:	4638      	mov	r0, r7
 801ff5a:	ea83 70e3 	eor.w	r0, r3, r3, asr #31
 801ff5e:	eba0 70e3 	sub.w	r0, r0, r3, asr #31
	for(i = 0; i < nSamps; i++) {
 801ff62:	3101      	adds	r1, #1
 801ff64:	4588      	cmp	r8, r1
		mOutR |= FASTABS(x[1][i]);
 801ff66:	ea45 0500 	orr.w	r5, r5, r0
	for(i = 0; i < nSamps; i++) {
 801ff6a:	d1e2      	bne.n	801ff32 <xmp3_MidSideProc+0x1a>
	}
	mOut[0] |= mOutL;
	mOut[1] |= mOutR;
 801ff6c:	e9d2 1300 	ldrd	r1, r3, [r2]
	mOut[0] |= mOutL;
 801ff70:	4331      	orrs	r1, r6
	mOut[1] |= mOutR;
 801ff72:	432b      	orrs	r3, r5
 801ff74:	e9c2 1300 	strd	r1, r3, [r2]
}
 801ff78:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	mOutL = mOutR = 0;
 801ff7c:	2500      	movs	r5, #0
 801ff7e:	462e      	mov	r6, r5
 801ff80:	e7f4      	b.n	801ff6c <xmp3_MidSideProc+0x54>
 801ff82:	bf00      	nop

0801ff84 <xmp3_IntensityProcMPEG1>:
 * TODO:        combine MPEG1/2 into one function (maybe)
 *              make sure all the mixed-block and IIP logic is right
 **************************************************************************************/
void IntensityProcMPEG1(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, int midSideFlag, int mixFlag, int mOut[2])
{
 801ff84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ff88:	b095      	sub	sp, #84	@ 0x54
 801ff8a:	9e1e      	ldr	r6, [sp, #120]	@ 0x78
 801ff8c:	9d21      	ldr	r5, [sp, #132]	@ 0x84
	 *  short block section (i.e. on or after sample 36 = sfBand->l[8] = 3*sfBand->s[3]
	 * is this a safe assumption?
	 * TODO - intensity + mixed not quite right (diff = 11 on he_mode)
	 *  figure out correct implementation (spec ambiguous about when to do short block reorder)
	 */
	if (cbi[1].cbType == 0) {
 801ff8e:	f8d6 a018 	ldr.w	sl, [r6, #24]
{
 801ff92:	9006      	str	r0, [sp, #24]
	if (cbi[1].cbType == 0) {
 801ff94:	f1ba 0f00 	cmp.w	sl, #0
 801ff98:	f040 8081 	bne.w	802009e <xmp3_IntensityProcMPEG1+0x11a>
		/* long block */
		cbStartL = cbi[1].cbEndL + 1;
		cbEndL =   cbi[0].cbEndL + 1;
		cbStartS = cbEndS = 0;
		i = fh->sfBand->l[cbStartL];
 801ff9c:	6b57      	ldr	r7, [r2, #52]	@ 0x34
		cbStartL = cbi[1].cbEndL + 1;
 801ff9e:	6af2      	ldr	r2, [r6, #44]	@ 0x2c
		cbEndL =   cbi[0].cbEndL + 1;
 801ffa0:	6974      	ldr	r4, [r6, #20]
		cbStartL = cbEndL = 0;
		i = 3 * fh->sfBand->s[cbStartS];
	}

	sampsLeft = nSamps - i;		/* process to length of left */
	isfTab = (int *)ISFMpeg1[midSideFlag];
 801ffa2:	981f      	ldr	r0, [sp, #124]	@ 0x7c
 801ffa4:	f8df 82e4 	ldr.w	r8, [pc, #740]	@ 802028c <xmp3_IntensityProcMPEG1+0x308>
		i = fh->sfBand->l[cbStartL];
 801ffa8:	1c56      	adds	r6, r2, #1
	isfTab = (int *)ISFMpeg1[midSideFlag];
 801ffaa:	ebc0 0ec0 	rsb	lr, r0, r0, lsl #3
		i = fh->sfBand->l[cbStartL];
 801ffae:	f937 c016 	ldrsh.w	ip, [r7, r6, lsl #1]
	mOutL = mOutR = 0;

	/* long blocks */
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 801ffb2:	42a2      	cmp	r2, r4
	sampsLeft = nSamps - i;		/* process to length of left */
 801ffb4:	eba1 010c 	sub.w	r1, r1, ip
	isfTab = (int *)ISFMpeg1[midSideFlag];
 801ffb8:	eb08 098e 	add.w	r9, r8, lr, lsl #2
 801ffbc:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 801ffc0:	f280 8160 	bge.w	8020284 <xmp3_IntensityProcMPEG1+0x300>
 801ffc4:	2900      	cmp	r1, #0
 801ffc6:	f340 815d 	ble.w	8020284 <xmp3_IntensityProcMPEG1+0x300>
 801ffca:	441a      	add	r2, r3
 801ffcc:	4423      	add	r3, r4
 801ffce:	9302      	str	r3, [sp, #8]
		isf = sfis->l[cb];
		if (isf == 7) {
			fl = ISFIIP[midSideFlag][0];
			fr = ISFIIP[midSideFlag][1];
 801ffd0:	4bad      	ldr	r3, [pc, #692]	@ (8020288 <xmp3_IntensityProcMPEG1+0x304>)
 801ffd2:	9521      	str	r5, [sp, #132]	@ 0x84
 801ffd4:	4403      	add	r3, r0
 801ffd6:	eb07 0b46 	add.w	fp, r7, r6, lsl #1
 801ffda:	9303      	str	r3, [sp, #12]
	mOutL = mOutR = 0;
 801ffdc:	46d0      	mov	r8, sl
 801ffde:	4656      	mov	r6, sl
 801ffe0:	4648      	mov	r0, r9
		isf = sfis->l[cb];
 801ffe2:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		if (isf == 7) {
 801ffe6:	2b07      	cmp	r3, #7
 801ffe8:	d049      	beq.n	802007e <xmp3_IntensityProcMPEG1+0xfa>
		} else {
			fl = isfTab[isf];	
 801ffea:	f850 5023 	ldr.w	r5, [r0, r3, lsl #2]
			fr = isfTab[6] - isfTab[isf];
 801ffee:	6987      	ldr	r7, [r0, #24]
 801fff0:	1b7f      	subs	r7, r7, r5
		}

		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 801fff2:	465b      	mov	r3, fp
 801fff4:	f9bb e002 	ldrsh.w	lr, [fp, #2]
 801fff8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fffc:	ebae 0e03 	sub.w	lr, lr, r3
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8020000:	f1be 0f00 	cmp.w	lr, #0
		n = fh->sfBand->l[cb + 1] - fh->sfBand->l[cb];
 8020004:	f10b 0b02 	add.w	fp, fp, #2
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8020008:	dd40      	ble.n	802008c <xmp3_IntensityProcMPEG1+0x108>
 802000a:	9b06      	ldr	r3, [sp, #24]
 802000c:	f10c 4480 	add.w	r4, ip, #1073741824	@ 0x40000000
 8020010:	3c01      	subs	r4, #1
 8020012:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8020016:	e9cd 0c00 	strd	r0, ip, [sp]
 802001a:	eba1 0e0e 	sub.w	lr, r1, lr
 802001e:	460b      	mov	r3, r1
 8020020:	46a1      	mov	r9, r4
 8020022:	e000      	b.n	8020026 <xmp3_IntensityProcMPEG1+0xa2>
 8020024:	b3a9      	cbz	r1, 8020092 <xmp3_IntensityProcMPEG1+0x10e>
			xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr; mOutR |= FASTABS(xr);
 8020026:	f859 0f04 	ldr.w	r0, [r9, #4]!
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 802002a:	4684      	mov	ip, r0
 802002c:	fb87 4c0c 	smull	r4, ip, r7, ip
 8020030:	ea4f 048c 	mov.w	r4, ip, lsl #2
 8020034:	f8c9 4900 	str.w	r4, [r9, #2304]	@ 0x900
	__asm__ volatile (
 8020038:	46b4      	mov	ip, r6
 802003a:	ea84 7ce4 	eor.w	ip, r4, r4, asr #31
 802003e:	ebac 7ce4 	sub.w	ip, ip, r4, asr #31
 8020042:	ea48 080c 	orr.w	r8, r8, ip
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8020046:	fb85 4000 	smull	r4, r0, r5, r0
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 802004a:	0080      	lsls	r0, r0, #2
 802004c:	f8c9 0000 	str.w	r0, [r9]
	__asm__ volatile (
 8020050:	4634      	mov	r4, r6
 8020052:	ea80 74e0 	eor.w	r4, r0, r0, asr #31
 8020056:	eba4 74e0 	sub.w	r4, r4, r0, asr #31
			sampsLeft--;
 802005a:	3901      	subs	r1, #1
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 802005c:	4571      	cmp	r1, lr
			xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl; mOutL |= FASTABS(xl);
 802005e:	ea4a 0a04 	orr.w	sl, sl, r4
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8020062:	d1df      	bne.n	8020024 <xmp3_IntensityProcMPEG1+0xa0>
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 8020064:	9c02      	ldr	r4, [sp, #8]
 8020066:	42a2      	cmp	r2, r4
 8020068:	e9dd 0c00 	ldrd	r0, ip, [sp]
 802006c:	d011      	beq.n	8020092 <xmp3_IntensityProcMPEG1+0x10e>
 802006e:	b181      	cbz	r1, 8020092 <xmp3_IntensityProcMPEG1+0x10e>
		for (j = 0; j < n && sampsLeft > 0; j++, i++) {
 8020070:	4463      	add	r3, ip
 8020072:	eba3 0c01 	sub.w	ip, r3, r1
		isf = sfis->l[cb];
 8020076:	f812 3f01 	ldrb.w	r3, [r2, #1]!
		if (isf == 7) {
 802007a:	2b07      	cmp	r3, #7
 802007c:	d1b5      	bne.n	801ffea <xmp3_IntensityProcMPEG1+0x66>
			fl = ISFIIP[midSideFlag][0];
 802007e:	4b82      	ldr	r3, [pc, #520]	@ (8020288 <xmp3_IntensityProcMPEG1+0x304>)
 8020080:	9c1f      	ldr	r4, [sp, #124]	@ 0x7c
 8020082:	f853 5034 	ldr.w	r5, [r3, r4, lsl #3]
			fr = ISFIIP[midSideFlag][1];
 8020086:	9b03      	ldr	r3, [sp, #12]
 8020088:	685f      	ldr	r7, [r3, #4]
 802008a:	e7b2      	b.n	801fff2 <xmp3_IntensityProcMPEG1+0x6e>
	for (cb = cbStartL; cb < cbEndL && sampsLeft > 0; cb++) {
 802008c:	9b02      	ldr	r3, [sp, #8]
 802008e:	429a      	cmp	r2, r3
 8020090:	d1a7      	bne.n	801ffe2 <xmp3_IntensityProcMPEG1+0x5e>
 8020092:	9d21      	ldr	r5, [sp, #132]	@ 0x84
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
			sampsLeft -= 3;
		}
	}
	mOut[0] = mOutL;
	mOut[1] = mOutR;
 8020094:	e9c5 a800 	strd	sl, r8, [r5]
	
	return;
}
 8020098:	b015      	add	sp, #84	@ 0x54
 802009a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (cbi[1].cbType == 1 || cbi[1].cbType == 2) {
 802009e:	f10a 30ff 	add.w	r0, sl, #4294967295
 80200a2:	2801      	cmp	r0, #1
 80200a4:	d907      	bls.n	80200b6 <xmp3_IntensityProcMPEG1+0x132>
	mOutL = mOutR = 0;
 80200a6:	f04f 0800 	mov.w	r8, #0
 80200aa:	46c2      	mov	sl, r8
	mOut[1] = mOutR;
 80200ac:	e9c5 a800 	strd	sl, r8, [r5]
}
 80200b0:	b015      	add	sp, #84	@ 0x54
 80200b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		cbStartS = cbi[1].cbEndSMax + 1;
 80200b6:	6ab4      	ldr	r4, [r6, #40]	@ 0x28
		i = 3 * fh->sfBand->s[cbStartS];
 80200b8:	f8d2 e034 	ldr.w	lr, [r2, #52]	@ 0x34
		cbEndS =   cbi[0].cbEndSMax + 1;
 80200bc:	f8d6 c010 	ldr.w	ip, [r6, #16]
	isfTab = (int *)ISFMpeg1[midSideFlag];
 80200c0:	981f      	ldr	r0, [sp, #124]	@ 0x7c
		i = 3 * fh->sfBand->s[cbStartS];
 80200c2:	eb0e 0244 	add.w	r2, lr, r4, lsl #1
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 80200c6:	4564      	cmp	r4, ip
		i = 3 * fh->sfBand->s[cbStartS];
 80200c8:	f9b2 2030 	ldrsh.w	r2, [r2, #48]	@ 0x30
 80200cc:	eb02 0b42 	add.w	fp, r2, r2, lsl #1
	sampsLeft = nSamps - i;		/* process to length of left */
 80200d0:	eba1 070b 	sub.w	r7, r1, fp
	isfTab = (int *)ISFMpeg1[midSideFlag];
 80200d4:	991f      	ldr	r1, [sp, #124]	@ 0x7c
 80200d6:	4a6d      	ldr	r2, [pc, #436]	@ (802028c <xmp3_IntensityProcMPEG1+0x308>)
 80200d8:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 80200dc:	eb02 0181 	add.w	r1, r2, r1, lsl #2
		cbEndS =   cbi[0].cbEndSMax + 1;
 80200e0:	f10c 0601 	add.w	r6, ip, #1
		cbStartS = cbi[1].cbEndSMax + 1;
 80200e4:	f104 0201 	add.w	r2, r4, #1
	isfTab = (int *)ISFMpeg1[midSideFlag];
 80200e8:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 80200ec:	dadb      	bge.n	80200a6 <xmp3_IntensityProcMPEG1+0x122>
 80200ee:	2f02      	cmp	r7, #2
 80200f0:	ddd9      	ble.n	80200a6 <xmp3_IntensityProcMPEG1+0x122>
 80200f2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80200f6:	3216      	adds	r2, #22
 80200f8:	eb03 0c02 	add.w	ip, r3, r2
 80200fc:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 8020100:	3313      	adds	r3, #19
 8020102:	4433      	add	r3, r6
 8020104:	930d      	str	r3, [sp, #52]	@ 0x34
				frs[w] = ISFIIP[midSideFlag][1];
 8020106:	4b60      	ldr	r3, [pc, #384]	@ (8020288 <xmp3_IntensityProcMPEG1+0x304>)
 8020108:	3418      	adds	r4, #24
 802010a:	eb0e 0e44 	add.w	lr, lr, r4, lsl #1
 802010e:	4403      	add	r3, r0
	mOutL = mOutR = 0;
 8020110:	f04f 0800 	mov.w	r8, #0
				frs[w] = ISFIIP[midSideFlag][1];
 8020114:	930c      	str	r3, [sp, #48]	@ 0x30
	mOutL = mOutR = 0;
 8020116:	46c2      	mov	sl, r8
 8020118:	46c1      	mov	r9, r8
 802011a:	460c      	mov	r4, r1
 802011c:	4662      	mov	r2, ip
 802011e:	4670      	mov	r0, lr
		for (w = 0; w < 3; w++) {
 8020120:	a911      	add	r1, sp, #68	@ 0x44
 8020122:	f10d 0e38 	add.w	lr, sp, #56	@ 0x38
			sampsLeft--;
 8020126:	4694      	mov	ip, r2
			isf = sfis->s[cb][w];
 8020128:	f81c 3f01 	ldrb.w	r3, [ip, #1]!
			if (isf == 7) {
 802012c:	2b07      	cmp	r3, #7
 802012e:	f000 809c 	beq.w	802026a <xmp3_IntensityProcMPEG1+0x2e6>
				fls[w] = isfTab[isf];
 8020132:	f854 6023 	ldr.w	r6, [r4, r3, lsl #2]
				frs[w] = isfTab[6] - isfTab[isf];
 8020136:	69a3      	ldr	r3, [r4, #24]
 8020138:	1b9b      	subs	r3, r3, r6
 802013a:	f841 3b04 	str.w	r3, [r1], #4
		for (w = 0; w < 3; w++) {
 802013e:	ab14      	add	r3, sp, #80	@ 0x50
 8020140:	4299      	cmp	r1, r3
 8020142:	f84e 6b04 	str.w	r6, [lr], #4
 8020146:	d1ef      	bne.n	8020128 <xmp3_IntensityProcMPEG1+0x1a4>
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8020148:	4603      	mov	r3, r0
 802014a:	f9b0 e002 	ldrsh.w	lr, [r0, #2]
 802014e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020152:	ebae 0e03 	sub.w	lr, lr, r3
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8020156:	f1be 0f00 	cmp.w	lr, #0
		n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 802015a:	f100 0002 	add.w	r0, r0, #2
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 802015e:	f340 808b 	ble.w	8020278 <xmp3_IntensityProcMPEG1+0x2f4>
			xr = MULSHIFT32(frs[0], x[0][i+0]) << 2;	x[1][i+0] = xr;	mOutR |= FASTABS(xr);
 8020162:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8020164:	9301      	str	r3, [sp, #4]
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 8020166:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8020168:	9302      	str	r3, [sp, #8]
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 802016a:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 802016c:	9303      	str	r3, [sp, #12]
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 802016e:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8020170:	9304      	str	r3, [sp, #16]
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 8020172:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 8020174:	9305      	str	r3, [sp, #20]
 8020176:	9b06      	ldr	r3, [sp, #24]
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8020178:	f8dd c040 	ldr.w	ip, [sp, #64]	@ 0x40
 802017c:	900b      	str	r0, [sp, #44]	@ 0x2c
 802017e:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
 8020182:	e9cd 4b07 	strd	r4, fp, [sp, #28]
 8020186:	e9cd 2709 	strd	r2, r7, [sp, #36]	@ 0x24
 802018a:	eba7 0e0e 	sub.w	lr, r7, lr
 802018e:	eb03 038b 	add.w	r3, r3, fp, lsl #2
 8020192:	9521      	str	r5, [sp, #132]	@ 0x84
 8020194:	e002      	b.n	802019c <xmp3_IntensityProcMPEG1+0x218>
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8020196:	2f02      	cmp	r7, #2
 8020198:	f77f af7b 	ble.w	8020092 <xmp3_IntensityProcMPEG1+0x10e>
			xr = MULSHIFT32(frs[0], x[0][i+0]) << 2;	x[1][i+0] = xr;	mOutR |= FASTABS(xr);
 802019c:	681a      	ldr	r2, [r3, #0]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 802019e:	9c01      	ldr	r4, [sp, #4]
 80201a0:	4611      	mov	r1, r2
 80201a2:	fb84 0101 	smull	r0, r1, r4, r1
 80201a6:	0089      	lsls	r1, r1, #2
 80201a8:	f8c3 1900 	str.w	r1, [r3, #2304]	@ 0x900
	__asm__ volatile (
 80201ac:	464e      	mov	r6, r9
 80201ae:	ea81 76e1 	eor.w	r6, r1, r1, asr #31
 80201b2:	eba6 76e1 	sub.w	r6, r6, r1, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80201b6:	9802      	ldr	r0, [sp, #8]
 80201b8:	fb80 1202 	smull	r1, r2, r0, r2
			xl = MULSHIFT32(fls[0], x[0][i+0]) << 2;	x[0][i+0] = xl;	mOutL |= FASTABS(xl);
 80201bc:	0092      	lsls	r2, r2, #2
 80201be:	601a      	str	r2, [r3, #0]
	__asm__ volatile (
 80201c0:	464d      	mov	r5, r9
 80201c2:	ea82 75e2 	eor.w	r5, r2, r2, asr #31
 80201c6:	eba5 75e2 	sub.w	r5, r5, r2, asr #31
			xr = MULSHIFT32(frs[1], x[0][i+1]) << 2;	x[1][i+1] = xr;	mOutR |= FASTABS(xr);
 80201ca:	685a      	ldr	r2, [r3, #4]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80201cc:	9c03      	ldr	r4, [sp, #12]
 80201ce:	4611      	mov	r1, r2
 80201d0:	fb84 0101 	smull	r0, r1, r4, r1
 80201d4:	0089      	lsls	r1, r1, #2
 80201d6:	f8c3 1904 	str.w	r1, [r3, #2308]	@ 0x904
	__asm__ volatile (
 80201da:	4648      	mov	r0, r9
 80201dc:	ea81 70e1 	eor.w	r0, r1, r1, asr #31
 80201e0:	eba0 70e1 	sub.w	r0, r0, r1, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80201e4:	9c04      	ldr	r4, [sp, #16]
 80201e6:	fb84 1202 	smull	r1, r2, r4, r2
			xl = MULSHIFT32(fls[1], x[0][i+1]) << 2;	x[0][i+1] = xl;	mOutL |= FASTABS(xl);
 80201ea:	0092      	lsls	r2, r2, #2
 80201ec:	605a      	str	r2, [r3, #4]
	__asm__ volatile (
 80201ee:	4649      	mov	r1, r9
 80201f0:	ea82 71e2 	eor.w	r1, r2, r2, asr #31
 80201f4:	eba1 71e2 	sub.w	r1, r1, r2, asr #31
			xr = MULSHIFT32(frs[2], x[0][i+2]) << 2;	x[1][i+2] = xr;	mOutR |= FASTABS(xr);
 80201f8:	689a      	ldr	r2, [r3, #8]
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80201fa:	9200      	str	r2, [sp, #0]
 80201fc:	4614      	mov	r4, r2
 80201fe:	9a05      	ldr	r2, [sp, #20]
 8020200:	fb82 b404 	smull	fp, r4, r2, r4
 8020204:	00a4      	lsls	r4, r4, #2
 8020206:	f8c3 4908 	str.w	r4, [r3, #2312]	@ 0x908
	__asm__ volatile (
 802020a:	46cb      	mov	fp, r9
 802020c:	ea84 7be4 	eor.w	fp, r4, r4, asr #31
 8020210:	ebab 7be4 	sub.w	fp, fp, r4, asr #31
 8020214:	4330      	orrs	r0, r6
 8020216:	ea40 000b 	orr.w	r0, r0, fp
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 802021a:	9a00      	ldr	r2, [sp, #0]
 802021c:	ea48 0800 	orr.w	r8, r8, r0
 8020220:	fb8c 0202 	smull	r0, r2, ip, r2
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8020224:	0092      	lsls	r2, r2, #2
 8020226:	609a      	str	r2, [r3, #8]
	__asm__ volatile (
 8020228:	4648      	mov	r0, r9
 802022a:	ea82 70e2 	eor.w	r0, r2, r2, asr #31
 802022e:	eba0 70e2 	sub.w	r0, r0, r2, asr #31
 8020232:	4329      	orrs	r1, r5
			sampsLeft -= 3;
 8020234:	3f03      	subs	r7, #3
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 8020236:	4301      	orrs	r1, r0
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8020238:	4577      	cmp	r7, lr
			xl = MULSHIFT32(fls[2], x[0][i+2]) << 2;	x[0][i+2] = xl;	mOutL |= FASTABS(xl);
 802023a:	ea4a 0a01 	orr.w	sl, sl, r1
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 802023e:	f103 030c 	add.w	r3, r3, #12
 8020242:	d1a8      	bne.n	8020196 <xmp3_IntensityProcMPEG1+0x212>
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 8020244:	e9dd 2609 	ldrd	r2, r6, [sp, #36]	@ 0x24
 8020248:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 802024a:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 802024c:	9d21      	ldr	r5, [sp, #132]	@ 0x84
 802024e:	429a      	cmp	r2, r3
 8020250:	e9dd 4b07 	ldrd	r4, fp, [sp, #28]
 8020254:	f43f af1e 	beq.w	8020094 <xmp3_IntensityProcMPEG1+0x110>
 8020258:	2f02      	cmp	r7, #2
 802025a:	f102 0203 	add.w	r2, r2, #3
 802025e:	f77f af19 	ble.w	8020094 <xmp3_IntensityProcMPEG1+0x110>
		for (j = 0; j < n && sampsLeft >= 3; j++, i+=3) {
 8020262:	445e      	add	r6, fp
 8020264:	eba6 0b07 	sub.w	fp, r6, r7
 8020268:	e75a      	b.n	8020120 <xmp3_IntensityProcMPEG1+0x19c>
				fls[w] = ISFIIP[midSideFlag][0];
 802026a:	4b07      	ldr	r3, [pc, #28]	@ (8020288 <xmp3_IntensityProcMPEG1+0x304>)
 802026c:	9e1f      	ldr	r6, [sp, #124]	@ 0x7c
 802026e:	f853 6036 	ldr.w	r6, [r3, r6, lsl #3]
				frs[w] = ISFIIP[midSideFlag][1];
 8020272:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8020274:	685b      	ldr	r3, [r3, #4]
 8020276:	e760      	b.n	802013a <xmp3_IntensityProcMPEG1+0x1b6>
	for (cb = cbStartS; cb < cbEndS && sampsLeft >= 3; cb++) {
 8020278:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 802027a:	429a      	cmp	r2, r3
 802027c:	f43f af0a 	beq.w	8020094 <xmp3_IntensityProcMPEG1+0x110>
 8020280:	3203      	adds	r2, #3
 8020282:	e74d      	b.n	8020120 <xmp3_IntensityProcMPEG1+0x19c>
	mOutL = mOutR = 0;
 8020284:	46d0      	mov	r8, sl
 8020286:	e705      	b.n	8020094 <xmp3_IntensityProcMPEG1+0x110>
 8020288:	0803853c 	.word	0x0803853c
 802028c:	0803864c 	.word	0x0803864c

08020290 <xmp3_IntensityProcMPEG2>:
 *              make sure all the mixed-block and IIP logic is right
 *                probably redo IIP logic to be simpler
 **************************************************************************************/
void IntensityProcMPEG2(int x[MAX_NCHAN][MAX_NSAMP], int nSamps, FrameHeader *fh, ScaleFactorInfoSub *sfis, 
						CriticalBandInfo *cbi, ScaleFactorJS *sfjs, int midSideFlag, int mixFlag, int mOut[2])
{
 8020290:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020294:	b0a1      	sub	sp, #132	@ 0x84
 8020296:	4688      	mov	r8, r1
 8020298:	9f2b      	ldr	r7, [sp, #172]	@ 0xac
	int sampsLeft;
	int isf, sfIdx, tmp, il[23];
	int *isfTab;
	int cbStartL, cbStartS, cbEndL, cbEndS;
	
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 802029a:	992c      	ldr	r1, [sp, #176]	@ 0xb0
{
 802029c:	9e2a      	ldr	r6, [sp, #168]	@ 0xa8
 802029e:	461c      	mov	r4, r3
	isfTab = (int *)ISFMpeg2[sfjs->intensityScale][midSideFlag];
 80202a0:	683b      	ldr	r3, [r7, #0]
 80202a2:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 80202a6:	499a      	ldr	r1, [pc, #616]	@ (8020510 <xmp3_IntensityProcMPEG2+0x280>)
 80202a8:	eb01 1383 	add.w	r3, r1, r3, lsl #6
 80202ac:	9301      	str	r3, [sp, #4]
	mOutL = mOutR = 0;

	/* fill buffer with illegal intensity positions (depending on slen) */
	for (k = r = 0; r < 4; r++) {
 80202ae:	f107 0e10 	add.w	lr, r7, #16
 80202b2:	2300      	movs	r3, #0
		tmp = (1 << sfjs->slen[r]) - 1;
 80202b4:	f04f 0c01 	mov.w	ip, #1
 80202b8:	f857 1f04 	ldr.w	r1, [r7, #4]!
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 80202bc:	693d      	ldr	r5, [r7, #16]
		tmp = (1 << sfjs->slen[r]) - 1;
 80202be:	fa0c f101 	lsl.w	r1, ip, r1
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 80202c2:	2d00      	cmp	r5, #0
		tmp = (1 << sfjs->slen[r]) - 1;
 80202c4:	f101 31ff 	add.w	r1, r1, #4294967295
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 80202c8:	dd0b      	ble.n	80202e2 <xmp3_IntensityProcMPEG2+0x52>
 80202ca:	eb05 0903 	add.w	r9, r5, r3
 80202ce:	ad08      	add	r5, sp, #32
 80202d0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80202d4:	eb05 0589 	add.w	r5, r5, r9, lsl #2
			il[k] = tmp;
 80202d8:	f843 1b04 	str.w	r1, [r3], #4
		for (j = 0; j < sfjs->nr[r]; j++, k++) 
 80202dc:	42ab      	cmp	r3, r5
 80202de:	d1fb      	bne.n	80202d8 <xmp3_IntensityProcMPEG2+0x48>
 80202e0:	464b      	mov	r3, r9
	for (k = r = 0; r < 4; r++) {
 80202e2:	4577      	cmp	r7, lr
 80202e4:	d1e8      	bne.n	80202b8 <xmp3_IntensityProcMPEG2+0x28>
	}

	if (cbi[1].cbType == 0) {
 80202e6:	69b1      	ldr	r1, [r6, #24]
		/* long blocks */
		il[21] = il[22] = 1;
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
		i = fh->sfBand->l[cbStartL];
 80202e8:	f8d2 b034 	ldr.w	fp, [r2, #52]	@ 0x34
	if (cbi[1].cbType == 0) {
 80202ec:	2900      	cmp	r1, #0
 80202ee:	d17f      	bne.n	80203f0 <xmp3_IntensityProcMPEG2+0x160>
		cbStartL = cbi[1].cbEndL + 1;	/* start at end of right */
 80202f0:	6af5      	ldr	r5, [r6, #44]	@ 0x2c
		cbEndL =   cbi[0].cbEndL + 1;	/* process to end of left */
 80202f2:	6973      	ldr	r3, [r6, #20]
 80202f4:	9304      	str	r3, [sp, #16]
		il[21] = il[22] = 1;
 80202f6:	2601      	movs	r6, #1
		i = fh->sfBand->l[cbStartL];
 80202f8:	1c6b      	adds	r3, r5, #1
 80202fa:	eb04 0905 	add.w	r9, r4, r5
		il[21] = il[22] = 1;
 80202fe:	e9cd 661d 	strd	r6, r6, [sp, #116]	@ 0x74
		i = fh->sfBand->l[cbStartL];
 8020302:	f1c4 0401 	rsb	r4, r4, #1
 8020306:	ae08      	add	r6, sp, #32
 8020308:	f93b 2013 	ldrsh.w	r2, [fp, r3, lsl #1]
		sampsLeft = nSamps - i;
 802030c:	9405      	str	r4, [sp, #20]
 802030e:	eb0b 0343 	add.w	r3, fp, r3, lsl #1

		for(cb = cbStartL; cb < cbEndL; cb++) {
			sfIdx = sfis->l[cb];
			if (sfIdx == il[cb]) {
				fl = ISFIIP[midSideFlag][0];
				fr = ISFIIP[midSideFlag][1];
 8020312:	4c80      	ldr	r4, [pc, #512]	@ (8020514 <xmp3_IntensityProcMPEG2+0x284>)
 8020314:	eb06 0b85 	add.w	fp, r6, r5, lsl #2
 8020318:	9d2c      	ldr	r5, [sp, #176]	@ 0xb0
 802031a:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 802031e:	9406      	str	r4, [sp, #24]
 8020320:	4604      	mov	r4, r0
		sampsLeft = nSamps - i;
 8020322:	eba8 0802 	sub.w	r8, r8, r2
		for(cb = cbStartL; cb < cbEndL; cb++) {
 8020326:	4610      	mov	r0, r2
	mOutL = mOutR = 0;
 8020328:	468c      	mov	ip, r1
 802032a:	465a      	mov	r2, fp
 802032c:	460e      	mov	r6, r1
 802032e:	46a3      	mov	fp, r4
		for(cb = cbStartL; cb < cbEndL; cb++) {
 8020330:	9c05      	ldr	r4, [sp, #20]
 8020332:	9d04      	ldr	r5, [sp, #16]
 8020334:	444c      	add	r4, r9
 8020336:	42a5      	cmp	r5, r4
 8020338:	db4d      	blt.n	80203d6 <xmp3_IntensityProcMPEG2+0x146>
			sfIdx = sfis->l[cb];
 802033a:	f819 4f01 	ldrb.w	r4, [r9, #1]!
			if (sfIdx == il[cb]) {
 802033e:	f852 5f04 	ldr.w	r5, [r2, #4]!
 8020342:	42a5      	cmp	r5, r4
 8020344:	d04d      	beq.n	80203e2 <xmp3_IntensityProcMPEG2+0x152>
			} else {
				isf = (sfis->l[cb] + 1) >> 1;
 8020346:	1c67      	adds	r7, r4, #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8020348:	9d01      	ldr	r5, [sp, #4]
 802034a:	07e4      	lsls	r4, r4, #31
				isf = (sfis->l[cb] + 1) >> 1;
 802034c:	ea4f 0767 	mov.w	r7, r7, asr #1
				fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 8020350:	eb05 0587 	add.w	r5, r5, r7, lsl #2
 8020354:	bf55      	itete	pl
 8020356:	9c01      	ldrpl	r4, [sp, #4]
 8020358:	9d01      	ldrmi	r5, [sp, #4]
 802035a:	6824      	ldrpl	r4, [r4, #0]
 802035c:	f855 4027 	ldrmi.w	r4, [r5, r7, lsl #2]
				fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 8020360:	682d      	ldr	r5, [r5, #0]
			}
			n = MIN(fh->sfBand->l[cb + 1] - fh->sfBand->l[cb], sampsLeft);
 8020362:	f9b3 e002 	ldrsh.w	lr, [r3, #2]
 8020366:	461f      	mov	r7, r3
 8020368:	3302      	adds	r3, #2
 802036a:	f9b7 7000 	ldrsh.w	r7, [r7]
 802036e:	ebae 0e07 	sub.w	lr, lr, r7
 8020372:	45c6      	cmp	lr, r8
 8020374:	bfa8      	it	ge
 8020376:	46c6      	movge	lr, r8

			for(j = 0; j < n; j++, i++) {
 8020378:	f1be 0f00 	cmp.w	lr, #0
 802037c:	dd28      	ble.n	80203d0 <xmp3_IntensityProcMPEG2+0x140>
 802037e:	eb0e 0a00 	add.w	sl, lr, r0
 8020382:	e9cd 3a02 	strd	r3, sl, [sp, #8]
 8020386:	eb0b 0080 	add.w	r0, fp, r0, lsl #2
 802038a:	eb0b 078a 	add.w	r7, fp, sl, lsl #2
				xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 802038e:	f850 3b04 	ldr.w	r3, [r0], #4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8020392:	fb85 a303 	smull	sl, r3, r5, r3
 8020396:	009b      	lsls	r3, r3, #2
 8020398:	f8c0 38fc 	str.w	r3, [r0, #2300]	@ 0x8fc
	__asm__ volatile (
 802039c:	46b2      	mov	sl, r6
 802039e:	ea83 7ae3 	eor.w	sl, r3, r3, asr #31
 80203a2:	ebaa 7ae3 	sub.w	sl, sl, r3, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80203a6:	f850 3c04 	ldr.w	r3, [r0, #-4]
 80203aa:	ea4c 0c0a 	orr.w	ip, ip, sl
 80203ae:	fb84 a303 	smull	sl, r3, r4, r3
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 80203b2:	009b      	lsls	r3, r3, #2
 80203b4:	f840 3c04 	str.w	r3, [r0, #-4]
	__asm__ volatile (
 80203b8:	46b2      	mov	sl, r6
 80203ba:	ea83 7ae3 	eor.w	sl, r3, r3, asr #31
 80203be:	ebaa 7ae3 	sub.w	sl, sl, r3, asr #31
			for(j = 0; j < n; j++, i++) {
 80203c2:	4287      	cmp	r7, r0
				xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 80203c4:	ea41 010a 	orr.w	r1, r1, sl
			for(j = 0; j < n; j++, i++) {
 80203c8:	d1e1      	bne.n	802038e <xmp3_IntensityProcMPEG2+0xfe>
 80203ca:	e9dd 3a02 	ldrd	r3, sl, [sp, #8]
 80203ce:	4650      	mov	r0, sl
			}

			/* early exit once we've used all the non-zero samples */
			sampsLeft -= n;
			if (sampsLeft == 0)		
 80203d0:	ebb8 080e 	subs.w	r8, r8, lr
 80203d4:	d1ac      	bne.n	8020330 <xmp3_IntensityProcMPEG2+0xa0>
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
				}
			}
		}
	}
	mOut[0] = mOutL;
 80203d6:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
	mOut[1] = mOutR;
 80203d8:	e9c3 1c00 	strd	r1, ip, [r3]

	return;
}
 80203dc:	b021      	add	sp, #132	@ 0x84
 80203de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				fl = ISFIIP[midSideFlag][0];
 80203e2:	9d2c      	ldr	r5, [sp, #176]	@ 0xb0
 80203e4:	4c4b      	ldr	r4, [pc, #300]	@ (8020514 <xmp3_IntensityProcMPEG2+0x284>)
 80203e6:	f854 4035 	ldr.w	r4, [r4, r5, lsl #3]
				fr = ISFIIP[midSideFlag][1];
 80203ea:	9d06      	ldr	r5, [sp, #24]
 80203ec:	686d      	ldr	r5, [r5, #4]
 80203ee:	e7b8      	b.n	8020362 <xmp3_IntensityProcMPEG2+0xd2>
		il[12] = 1;
 80203f0:	f104 0317 	add.w	r3, r4, #23
					fr = ISFIIP[midSideFlag][1];
 80203f4:	4a47      	ldr	r2, [pc, #284]	@ (8020514 <xmp3_IntensityProcMPEG2+0x284>)
 80203f6:	9c2c      	ldr	r4, [sp, #176]	@ 0xb0
 80203f8:	9302      	str	r3, [sp, #8]
	mOutL = mOutR = 0;
 80203fa:	f04f 0c00 	mov.w	ip, #0
					fr = ISFIIP[midSideFlag][1];
 80203fe:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
		il[12] = 1;
 8020402:	2301      	movs	r3, #1
 8020404:	4635      	mov	r5, r6
 8020406:	9314      	str	r3, [sp, #80]	@ 0x50
	mOutL = mOutR = 0;
 8020408:	4661      	mov	r1, ip
					fr = ISFIIP[midSideFlag][1];
 802040a:	9204      	str	r2, [sp, #16]
 802040c:	f500 6a10 	add.w	sl, r0, #2304	@ 0x900
 8020410:	4666      	mov	r6, ip
 8020412:	4664      	mov	r4, ip
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 8020414:	69ef      	ldr	r7, [r5, #28]
			cbEndS =   cbi[0].cbEndS[w] + 1;		/* process to end of left */
 8020416:	f855 2f04 	ldr.w	r2, [r5, #4]!
 802041a:	9203      	str	r2, [sp, #12]
 802041c:	4613      	mov	r3, r2
			i = 3 * fh->sfBand->s[cbStartS] + w;
 802041e:	eb0b 0247 	add.w	r2, fp, r7, lsl #1
 8020422:	f04f 0e03 	mov.w	lr, #3
 8020426:	8e12      	ldrh	r2, [r2, #48]	@ 0x30
 8020428:	fb12 420e 	smlabb	r2, r2, lr, r4
			cbStartS = cbi[1].cbEndS[w] + 1;		/* start at end of right */
 802042c:	f107 0e01 	add.w	lr, r7, #1
			for(cb = cbStartS; cb < cbEndS; cb++) {
 8020430:	4573      	cmp	r3, lr
 8020432:	db59      	blt.n	80204e8 <xmp3_IntensityProcMPEG2+0x258>
 8020434:	ab08      	add	r3, sp, #32
 8020436:	e9cd 4b05 	strd	r4, fp, [sp, #20]
 802043a:	eb03 0987 	add.w	r9, r3, r7, lsl #2
 802043e:	3718      	adds	r7, #24
 8020440:	9b01      	ldr	r3, [sp, #4]
 8020442:	9507      	str	r5, [sp, #28]
 8020444:	eb0b 0847 	add.w	r8, fp, r7, lsl #1
				sfIdx = sfis->s[cb][w];
 8020448:	9d02      	ldr	r5, [sp, #8]
 802044a:	eb0e 044e 	add.w	r4, lr, lr, lsl #1
 802044e:	5d2c      	ldrb	r4, [r5, r4]
				if (sfIdx == il[cb]) {
 8020450:	f859 5f04 	ldr.w	r5, [r9, #4]!
 8020454:	42a5      	cmp	r5, r4
 8020456:	d053      	beq.n	8020500 <xmp3_IntensityProcMPEG2+0x270>
					isf = (sfis->s[cb][w] + 1) >> 1;
 8020458:	1c67      	adds	r7, r4, #1
 802045a:	107f      	asrs	r7, r7, #1
					fl = isfTab[(sfIdx & 0x01 ? isf : 0)];
 802045c:	07e4      	lsls	r4, r4, #31
 802045e:	eb03 0587 	add.w	r5, r3, r7, lsl #2
 8020462:	bf46      	itte	mi
 8020464:	461d      	movmi	r5, r3
 8020466:	f853 4027 	ldrmi.w	r4, [r3, r7, lsl #2]
 802046a:	681c      	ldrpl	r4, [r3, #0]
					fr = isfTab[(sfIdx & 0x01 ? 0 : isf)];
 802046c:	682d      	ldr	r5, [r5, #0]
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 802046e:	f9b8 7002 	ldrsh.w	r7, [r8, #2]
 8020472:	46c3      	mov	fp, r8
 8020474:	f10e 0e01 	add.w	lr, lr, #1
 8020478:	f9bb b000 	ldrsh.w	fp, [fp]
 802047c:	eba7 070b 	sub.w	r7, r7, fp
				for(j = 0; j < n; j++, i+=3) {
 8020480:	2f00      	cmp	r7, #0
				n = fh->sfBand->s[cb + 1] - fh->sfBand->s[cb];
 8020482:	f108 0802 	add.w	r8, r8, #2
				for(j = 0; j < n; j++, i+=3) {
 8020486:	dd28      	ble.n	80204da <xmp3_IntensityProcMPEG2+0x24a>
 8020488:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 802048c:	4417      	add	r7, r2
 802048e:	f8cd e004 	str.w	lr, [sp, #4]
 8020492:	46a3      	mov	fp, r4
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 8020494:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 8020498:	fb85 e404 	smull	lr, r4, r5, r4
					xr = MULSHIFT32(fr, x[0][i]) << 2;	x[1][i] = xr;	mOutR |= FASTABS(xr);
 802049c:	00a4      	lsls	r4, r4, #2
 802049e:	f84a 4022 	str.w	r4, [sl, r2, lsl #2]
	__asm__ volatile (
 80204a2:	46b6      	mov	lr, r6
 80204a4:	ea84 7ee4 	eor.w	lr, r4, r4, asr #31
 80204a8:	ebae 7ee4 	sub.w	lr, lr, r4, asr #31
    __asm__ volatile ("smull %0,%1,%2,%3" : "=&r" (zlow), "=r" (y) : "r" (x), "1" (y)) ;
 80204ac:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
 80204b0:	ea4c 0c0e 	orr.w	ip, ip, lr
 80204b4:	46a6      	mov	lr, r4
 80204b6:	fb8b 4e0e 	smull	r4, lr, fp, lr
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 80204ba:	ea4f 048e 	mov.w	r4, lr, lsl #2
 80204be:	f840 4022 	str.w	r4, [r0, r2, lsl #2]
	__asm__ volatile (
 80204c2:	46b6      	mov	lr, r6
 80204c4:	ea84 7ee4 	eor.w	lr, r4, r4, asr #31
 80204c8:	ebae 7ee4 	sub.w	lr, lr, r4, asr #31
				for(j = 0; j < n; j++, i+=3) {
 80204cc:	3203      	adds	r2, #3
 80204ce:	42ba      	cmp	r2, r7
					xl = MULSHIFT32(fl, x[0][i]) << 2;	x[0][i] = xl;	mOutL |= FASTABS(xl);
 80204d0:	ea41 010e 	orr.w	r1, r1, lr
				for(j = 0; j < n; j++, i+=3) {
 80204d4:	d1de      	bne.n	8020494 <xmp3_IntensityProcMPEG2+0x204>
 80204d6:	f8dd e004 	ldr.w	lr, [sp, #4]
			for(cb = cbStartS; cb < cbEndS; cb++) {
 80204da:	9c03      	ldr	r4, [sp, #12]
 80204dc:	4574      	cmp	r4, lr
 80204de:	dab3      	bge.n	8020448 <xmp3_IntensityProcMPEG2+0x1b8>
 80204e0:	e9dd 4b05 	ldrd	r4, fp, [sp, #20]
 80204e4:	9d07      	ldr	r5, [sp, #28]
 80204e6:	9301      	str	r3, [sp, #4]
		for(w = 0; w < 3; w++) {
 80204e8:	9b02      	ldr	r3, [sp, #8]
 80204ea:	3401      	adds	r4, #1
 80204ec:	3301      	adds	r3, #1
 80204ee:	2c03      	cmp	r4, #3
 80204f0:	9302      	str	r3, [sp, #8]
 80204f2:	d18f      	bne.n	8020414 <xmp3_IntensityProcMPEG2+0x184>
	mOut[0] = mOutL;
 80204f4:	9b2e      	ldr	r3, [sp, #184]	@ 0xb8
	mOut[1] = mOutR;
 80204f6:	e9c3 1c00 	strd	r1, ip, [r3]
}
 80204fa:	b021      	add	sp, #132	@ 0x84
 80204fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					fl = ISFIIP[midSideFlag][0];
 8020500:	9d2c      	ldr	r5, [sp, #176]	@ 0xb0
 8020502:	4c04      	ldr	r4, [pc, #16]	@ (8020514 <xmp3_IntensityProcMPEG2+0x284>)
 8020504:	f854 4035 	ldr.w	r4, [r4, r5, lsl #3]
					fr = ISFIIP[midSideFlag][1];
 8020508:	9d04      	ldr	r5, [sp, #16]
 802050a:	686d      	ldr	r5, [r5, #4]
 802050c:	e7af      	b.n	802046e <xmp3_IntensityProcMPEG2+0x1de>
 802050e:	bf00      	nop
 8020510:	0803854c 	.word	0x0803854c
 8020514:	0803853c 	.word	0x0803853c

08020518 <xmp3_Subband>:
	int b;
	IMDCTInfo *mi;
	SubbandInfo *sbi;

	/* validate pointers */
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8020518:	2800      	cmp	r0, #0
 802051a:	f000 8085 	beq.w	8020628 <xmp3_Subband+0x110>
 802051e:	68c2      	ldr	r2, [r0, #12]
 8020520:	2a00      	cmp	r2, #0
 8020522:	f000 8081 	beq.w	8020628 <xmp3_Subband+0x110>
{
 8020526:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 802052a:	f8d0 9014 	ldr.w	r9, [r0, #20]
{
 802052e:	b085      	sub	sp, #20
	if (!mp3DecInfo || !mp3DecInfo->HuffmanInfoPS || !mp3DecInfo->IMDCTInfoPS || !mp3DecInfo->SubbandInfoPS)
 8020530:	f1b9 0f00 	cmp.w	r9, #0
 8020534:	d075      	beq.n	8020622 <xmp3_Subband+0x10a>
 8020536:	f8d0 a018 	ldr.w	sl, [r0, #24]
 802053a:	f1ba 0f00 	cmp.w	sl, #0
 802053e:	d070      	beq.n	8020622 <xmp3_Subband+0x10a>
	return -1;

	mi = (IMDCTInfo *)(mp3DecInfo->IMDCTInfoPS);
	sbi = (SubbandInfo*)(mp3DecInfo->SubbandInfoPS);

	if (mp3DecInfo->nChans == 2) {
 8020540:	f8d0 37bc 	ldr.w	r3, [r0, #1980]	@ 0x7bc
			pcmBuf += (2 * NBANDS);
		}
		} else {
		/* mono */
		for (b = 0; b < BLOCK_SIZE; b++) {
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 8020544:	f50a 5400 	add.w	r4, sl, #8192	@ 0x2000
	if (mp3DecInfo->nChans == 2) {
 8020548:	2b02      	cmp	r3, #2
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 802054a:	f8d4 2200 	ldr.w	r2, [r4, #512]	@ 0x200
 802054e:	4688      	mov	r8, r1
	if (mp3DecInfo->nChans == 2) {
 8020550:	d02d      	beq.n	80205ae <xmp3_Subband+0x96>
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8020552:	f8df b0dc 	ldr.w	fp, [pc, #220]	@ 8020630 <xmp3_Subband+0x118>
 8020556:	9403      	str	r4, [sp, #12]
		for (b = 0; b < BLOCK_SIZE; b++) {
 8020558:	2500      	movs	r5, #0
 802055a:	f509 5780 	add.w	r7, r9, #4096	@ 0x1000
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 802055e:	f005 0601 	and.w	r6, r5, #1
 8020562:	f8d7 4b18 	ldr.w	r4, [r7, #2840]	@ 0xb18
 8020566:	9400      	str	r4, [sp, #0]
 8020568:	eb09 10c5 	add.w	r0, r9, r5, lsl #7
 802056c:	4633      	mov	r3, r6
 802056e:	4651      	mov	r1, sl
 8020570:	f7fb fffc 	bl	801c56c <xmp3_FDCT32>
			PolyphaseMono(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 8020574:	9c03      	ldr	r4, [sp, #12]
 8020576:	f8d4 1200 	ldr.w	r1, [r4, #512]	@ 0x200
 802057a:	eb06 1206 	add.w	r2, r6, r6, lsl #4
 802057e:	eb01 1182 	add.w	r1, r1, r2, lsl #6
 8020582:	4640      	mov	r0, r8
 8020584:	465a      	mov	r2, fp
 8020586:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
 802058a:	f7fe fcd9 	bl	801ef40 <xmp3_PolyphaseMono>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 802058e:	f8d4 2200 	ldr.w	r2, [r4, #512]	@ 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8020592:	3501      	adds	r5, #1
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8020594:	1b92      	subs	r2, r2, r6
 8020596:	f002 0207 	and.w	r2, r2, #7
		for (b = 0; b < BLOCK_SIZE; b++) {
 802059a:	2d12      	cmp	r5, #18
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 802059c:	f8c4 2200 	str.w	r2, [r4, #512]	@ 0x200
			pcmBuf += NBANDS;
 80205a0:	f108 0840 	add.w	r8, r8, #64	@ 0x40
		for (b = 0; b < BLOCK_SIZE; b++) {
 80205a4:	d1db      	bne.n	802055e <xmp3_Subband+0x46>
		}
	}

	return 0;
 80205a6:	2000      	movs	r0, #0
}
 80205a8:	b005      	add	sp, #20
 80205aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80205ae:	464d      	mov	r5, r9
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 80205b0:	f10a 0380 	add.w	r3, sl, #128	@ 0x80
 80205b4:	9303      	str	r3, [sp, #12]
 80205b6:	f509 6910 	add.w	r9, r9, #2304	@ 0x900
		for (b = 0; b < BLOCK_SIZE; b++) {
 80205ba:	2600      	movs	r6, #0
 80205bc:	f505 5780 	add.w	r7, r5, #4096	@ 0x1000
			FDCT32(mi->outBuf[0][b], sbi->vbuf + 0*32, sbi->vindex, (b & 0x01), mi->gb[0]);
 80205c0:	f006 0b01 	and.w	fp, r6, #1
 80205c4:	f8d7 1b18 	ldr.w	r1, [r7, #2840]	@ 0xb18
 80205c8:	9100      	str	r1, [sp, #0]
 80205ca:	4628      	mov	r0, r5
 80205cc:	465b      	mov	r3, fp
 80205ce:	4651      	mov	r1, sl
 80205d0:	f7fb ffcc 	bl	801c56c <xmp3_FDCT32>
			FDCT32(mi->outBuf[1][b], sbi->vbuf + 1*32, sbi->vindex, (b & 0x01), mi->gb[1]);
 80205d4:	f8d7 1b1c 	ldr.w	r1, [r7, #2844]	@ 0xb1c
 80205d8:	f8d4 2200 	ldr.w	r2, [r4, #512]	@ 0x200
 80205dc:	9100      	str	r1, [sp, #0]
 80205de:	f505 6010 	add.w	r0, r5, #2304	@ 0x900
 80205e2:	9903      	ldr	r1, [sp, #12]
 80205e4:	465b      	mov	r3, fp
 80205e6:	f7fb ffc1 	bl	801c56c <xmp3_FDCT32>
			PolyphaseStereo(pcmBuf, sbi->vbuf + sbi->vindex + VBUF_LENGTH * (b & 0x01), polyCoef);
 80205ea:	f8d4 1200 	ldr.w	r1, [r4, #512]	@ 0x200
 80205ee:	eb0b 120b 	add.w	r2, fp, fp, lsl #4
 80205f2:	eb01 1182 	add.w	r1, r1, r2, lsl #6
 80205f6:	4640      	mov	r0, r8
 80205f8:	4a0d      	ldr	r2, [pc, #52]	@ (8020630 <xmp3_Subband+0x118>)
 80205fa:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
 80205fe:	f7fe fe0f 	bl	801f220 <xmp3_PolyphaseStereo>
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8020602:	f8d4 2200 	ldr.w	r2, [r4, #512]	@ 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 8020606:	3580      	adds	r5, #128	@ 0x80
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 8020608:	eba2 020b 	sub.w	r2, r2, fp
 802060c:	f002 0207 	and.w	r2, r2, #7
		for (b = 0; b < BLOCK_SIZE; b++) {
 8020610:	454d      	cmp	r5, r9
 8020612:	f106 0601 	add.w	r6, r6, #1
			pcmBuf += (2 * NBANDS);
 8020616:	f108 0880 	add.w	r8, r8, #128	@ 0x80
			sbi->vindex = (sbi->vindex - (b & 0x01)) & 7;
 802061a:	f8c4 2200 	str.w	r2, [r4, #512]	@ 0x200
		for (b = 0; b < BLOCK_SIZE; b++) {
 802061e:	d1cf      	bne.n	80205c0 <xmp3_Subband+0xa8>
 8020620:	e7c1      	b.n	80205a6 <xmp3_Subband+0x8e>
	return -1;
 8020622:	f04f 30ff 	mov.w	r0, #4294967295
 8020626:	e7bf      	b.n	80205a8 <xmp3_Subband+0x90>
 8020628:	f04f 30ff 	mov.w	r0, #4294967295
}
 802062c:	4770      	bx	lr
 802062e:	bf00      	nop
 8020630:	080380dc 	.word	0x080380dc

08020634 <arm_cfft_radix4by2_q15>:
 8020634:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020638:	084d      	lsrs	r5, r1, #1
 802063a:	b081      	sub	sp, #4
 802063c:	eb00 0741 	add.w	r7, r0, r1, lsl #1
 8020640:	4616      	mov	r6, r2
 8020642:	d04d      	beq.n	80206e0 <arm_cfft_radix4by2_q15+0xac>
 8020644:	4604      	mov	r4, r0
 8020646:	4686      	mov	lr, r0
 8020648:	46bc      	mov	ip, r7
 802064a:	4691      	mov	r9, r2
 802064c:	4628      	mov	r0, r5
 802064e:	f04f 0800 	mov.w	r8, #0
 8020652:	f859 2b04 	ldr.w	r2, [r9], #4
 8020656:	f8de 3000 	ldr.w	r3, [lr]
 802065a:	fa93 fa28 	shadd16	sl, r3, r8
 802065e:	f8dc 1000 	ldr.w	r1, [ip]
 8020662:	fa91 f128 	shadd16	r1, r1, r8
 8020666:	fada fb11 	qsub16	fp, sl, r1
 802066a:	fa9a f121 	shadd16	r1, sl, r1
 802066e:	f84e 1b04 	str.w	r1, [lr], #4
 8020672:	fb22 f10b 	smuad	r1, r2, fp
 8020676:	fb42 f21b 	smusdx	r2, r2, fp
 802067a:	0c13      	lsrs	r3, r2, #16
 802067c:	041b      	lsls	r3, r3, #16
 802067e:	ea43 4311 	orr.w	r3, r3, r1, lsr #16
 8020682:	3801      	subs	r0, #1
 8020684:	f84c 3b04 	str.w	r3, [ip], #4
 8020688:	d1e3      	bne.n	8020652 <arm_cfft_radix4by2_q15+0x1e>
 802068a:	4629      	mov	r1, r5
 802068c:	2302      	movs	r3, #2
 802068e:	4632      	mov	r2, r6
 8020690:	4620      	mov	r0, r4
 8020692:	f000 f8f5 	bl	8020880 <arm_radix4_butterfly_q15>
 8020696:	2302      	movs	r3, #2
 8020698:	4629      	mov	r1, r5
 802069a:	4632      	mov	r2, r6
 802069c:	4638      	mov	r0, r7
 802069e:	f000 f8ef 	bl	8020880 <arm_radix4_butterfly_q15>
 80206a2:	eb04 05c5 	add.w	r5, r4, r5, lsl #3
 80206a6:	1ca3      	adds	r3, r4, #2
 80206a8:	f933 7c02 	ldrsh.w	r7, [r3, #-2]
 80206ac:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
 80206b0:	f9b4 0004 	ldrsh.w	r0, [r4, #4]
 80206b4:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
 80206b8:	007f      	lsls	r7, r7, #1
 80206ba:	0076      	lsls	r6, r6, #1
 80206bc:	0040      	lsls	r0, r0, #1
 80206be:	0052      	lsls	r2, r2, #1
 80206c0:	f823 7c02 	strh.w	r7, [r3, #-2]
 80206c4:	3408      	adds	r4, #8
 80206c6:	f824 6c06 	strh.w	r6, [r4, #-6]
 80206ca:	f824 0c04 	strh.w	r0, [r4, #-4]
 80206ce:	f824 2c02 	strh.w	r2, [r4, #-2]
 80206d2:	42a5      	cmp	r5, r4
 80206d4:	f103 0308 	add.w	r3, r3, #8
 80206d8:	d1e6      	bne.n	80206a8 <arm_cfft_radix4by2_q15+0x74>
 80206da:	b001      	add	sp, #4
 80206dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80206e0:	4629      	mov	r1, r5
 80206e2:	2302      	movs	r3, #2
 80206e4:	f000 f8cc 	bl	8020880 <arm_radix4_butterfly_q15>
 80206e8:	4632      	mov	r2, r6
 80206ea:	4629      	mov	r1, r5
 80206ec:	4638      	mov	r0, r7
 80206ee:	2302      	movs	r3, #2
 80206f0:	b001      	add	sp, #4
 80206f2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80206f6:	f000 b8c3 	b.w	8020880 <arm_radix4_butterfly_q15>
 80206fa:	bf00      	nop

080206fc <arm_cfft_radix4by2_inverse_q15>:
 80206fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020700:	084d      	lsrs	r5, r1, #1
 8020702:	b081      	sub	sp, #4
 8020704:	eb00 0741 	add.w	r7, r0, r1, lsl #1
 8020708:	4616      	mov	r6, r2
 802070a:	d04d      	beq.n	80207a8 <arm_cfft_radix4by2_inverse_q15+0xac>
 802070c:	4604      	mov	r4, r0
 802070e:	4686      	mov	lr, r0
 8020710:	46bc      	mov	ip, r7
 8020712:	4691      	mov	r9, r2
 8020714:	4628      	mov	r0, r5
 8020716:	f04f 0800 	mov.w	r8, #0
 802071a:	f859 2b04 	ldr.w	r2, [r9], #4
 802071e:	f8de 3000 	ldr.w	r3, [lr]
 8020722:	fa93 fa28 	shadd16	sl, r3, r8
 8020726:	f8dc 1000 	ldr.w	r1, [ip]
 802072a:	fa91 f128 	shadd16	r1, r1, r8
 802072e:	fada fb11 	qsub16	fp, sl, r1
 8020732:	fa9a f121 	shadd16	r1, sl, r1
 8020736:	f84e 1b04 	str.w	r1, [lr], #4
 802073a:	fb42 f10b 	smusd	r1, r2, fp
 802073e:	fb22 f21b 	smuadx	r2, r2, fp
 8020742:	0c13      	lsrs	r3, r2, #16
 8020744:	041b      	lsls	r3, r3, #16
 8020746:	ea43 4311 	orr.w	r3, r3, r1, lsr #16
 802074a:	3801      	subs	r0, #1
 802074c:	f84c 3b04 	str.w	r3, [ip], #4
 8020750:	d1e3      	bne.n	802071a <arm_cfft_radix4by2_inverse_q15+0x1e>
 8020752:	4629      	mov	r1, r5
 8020754:	2302      	movs	r3, #2
 8020756:	4632      	mov	r2, r6
 8020758:	4620      	mov	r0, r4
 802075a:	f000 f9bf 	bl	8020adc <arm_radix4_butterfly_inverse_q15>
 802075e:	2302      	movs	r3, #2
 8020760:	4629      	mov	r1, r5
 8020762:	4632      	mov	r2, r6
 8020764:	4638      	mov	r0, r7
 8020766:	f000 f9b9 	bl	8020adc <arm_radix4_butterfly_inverse_q15>
 802076a:	eb04 05c5 	add.w	r5, r4, r5, lsl #3
 802076e:	1ca3      	adds	r3, r4, #2
 8020770:	f933 7c02 	ldrsh.w	r7, [r3, #-2]
 8020774:	f9b4 6002 	ldrsh.w	r6, [r4, #2]
 8020778:	f9b4 0004 	ldrsh.w	r0, [r4, #4]
 802077c:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
 8020780:	007f      	lsls	r7, r7, #1
 8020782:	0076      	lsls	r6, r6, #1
 8020784:	0040      	lsls	r0, r0, #1
 8020786:	0052      	lsls	r2, r2, #1
 8020788:	f823 7c02 	strh.w	r7, [r3, #-2]
 802078c:	3408      	adds	r4, #8
 802078e:	f824 6c06 	strh.w	r6, [r4, #-6]
 8020792:	f824 0c04 	strh.w	r0, [r4, #-4]
 8020796:	f824 2c02 	strh.w	r2, [r4, #-2]
 802079a:	42a5      	cmp	r5, r4
 802079c:	f103 0308 	add.w	r3, r3, #8
 80207a0:	d1e6      	bne.n	8020770 <arm_cfft_radix4by2_inverse_q15+0x74>
 80207a2:	b001      	add	sp, #4
 80207a4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80207a8:	4629      	mov	r1, r5
 80207aa:	2302      	movs	r3, #2
 80207ac:	f000 f996 	bl	8020adc <arm_radix4_butterfly_inverse_q15>
 80207b0:	4632      	mov	r2, r6
 80207b2:	4629      	mov	r1, r5
 80207b4:	4638      	mov	r0, r7
 80207b6:	2302      	movs	r3, #2
 80207b8:	b001      	add	sp, #4
 80207ba:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80207be:	f000 b98d 	b.w	8020adc <arm_radix4_butterfly_inverse_q15>
 80207c2:	bf00      	nop

080207c4 <arm_cfft_q15>:
 80207c4:	b570      	push	{r4, r5, r6, lr}
 80207c6:	2a01      	cmp	r2, #1
 80207c8:	460d      	mov	r5, r1
 80207ca:	4604      	mov	r4, r0
 80207cc:	461e      	mov	r6, r3
 80207ce:	8801      	ldrh	r1, [r0, #0]
 80207d0:	d024      	beq.n	802081c <arm_cfft_q15+0x58>
 80207d2:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 80207d6:	d013      	beq.n	8020800 <arm_cfft_q15+0x3c>
 80207d8:	d808      	bhi.n	80207ec <arm_cfft_q15+0x28>
 80207da:	2920      	cmp	r1, #32
 80207dc:	d031      	beq.n	8020842 <arm_cfft_q15+0x7e>
 80207de:	d945      	bls.n	802086c <arm_cfft_q15+0xa8>
 80207e0:	2940      	cmp	r1, #64	@ 0x40
 80207e2:	d00d      	beq.n	8020800 <arm_cfft_q15+0x3c>
 80207e4:	2980      	cmp	r1, #128	@ 0x80
 80207e6:	d02c      	beq.n	8020842 <arm_cfft_q15+0x7e>
 80207e8:	b98e      	cbnz	r6, 802080e <arm_cfft_q15+0x4a>
 80207ea:	bd70      	pop	{r4, r5, r6, pc}
 80207ec:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
 80207f0:	d006      	beq.n	8020800 <arm_cfft_q15+0x3c>
 80207f2:	d923      	bls.n	802083c <arm_cfft_q15+0x78>
 80207f4:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
 80207f8:	d023      	beq.n	8020842 <arm_cfft_q15+0x7e>
 80207fa:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
 80207fe:	d1f3      	bne.n	80207e8 <arm_cfft_q15+0x24>
 8020800:	2301      	movs	r3, #1
 8020802:	6862      	ldr	r2, [r4, #4]
 8020804:	4628      	mov	r0, r5
 8020806:	f000 f83b 	bl	8020880 <arm_radix4_butterfly_q15>
 802080a:	2e00      	cmp	r6, #0
 802080c:	d0ed      	beq.n	80207ea <arm_cfft_q15+0x26>
 802080e:	4628      	mov	r0, r5
 8020810:	68a2      	ldr	r2, [r4, #8]
 8020812:	89a1      	ldrh	r1, [r4, #12]
 8020814:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8020818:	f7df bd17 	b.w	800024a <arm_bitreversal_16>
 802081c:	f5b1 7f80 	cmp.w	r1, #256	@ 0x100
 8020820:	d01e      	beq.n	8020860 <arm_cfft_q15+0x9c>
 8020822:	d813      	bhi.n	802084c <arm_cfft_q15+0x88>
 8020824:	2920      	cmp	r1, #32
 8020826:	d004      	beq.n	8020832 <arm_cfft_q15+0x6e>
 8020828:	d927      	bls.n	802087a <arm_cfft_q15+0xb6>
 802082a:	2940      	cmp	r1, #64	@ 0x40
 802082c:	d018      	beq.n	8020860 <arm_cfft_q15+0x9c>
 802082e:	2980      	cmp	r1, #128	@ 0x80
 8020830:	d1da      	bne.n	80207e8 <arm_cfft_q15+0x24>
 8020832:	6862      	ldr	r2, [r4, #4]
 8020834:	4628      	mov	r0, r5
 8020836:	f7ff ff61 	bl	80206fc <arm_cfft_radix4by2_inverse_q15>
 802083a:	e7d5      	b.n	80207e8 <arm_cfft_q15+0x24>
 802083c:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
 8020840:	d1d2      	bne.n	80207e8 <arm_cfft_q15+0x24>
 8020842:	6862      	ldr	r2, [r4, #4]
 8020844:	4628      	mov	r0, r5
 8020846:	f7ff fef5 	bl	8020634 <arm_cfft_radix4by2_q15>
 802084a:	e7cd      	b.n	80207e8 <arm_cfft_q15+0x24>
 802084c:	f5b1 6f80 	cmp.w	r1, #1024	@ 0x400
 8020850:	d006      	beq.n	8020860 <arm_cfft_q15+0x9c>
 8020852:	d90e      	bls.n	8020872 <arm_cfft_q15+0xae>
 8020854:	f5b1 6f00 	cmp.w	r1, #2048	@ 0x800
 8020858:	d0eb      	beq.n	8020832 <arm_cfft_q15+0x6e>
 802085a:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
 802085e:	d1c3      	bne.n	80207e8 <arm_cfft_q15+0x24>
 8020860:	2301      	movs	r3, #1
 8020862:	6862      	ldr	r2, [r4, #4]
 8020864:	4628      	mov	r0, r5
 8020866:	f000 f939 	bl	8020adc <arm_radix4_butterfly_inverse_q15>
 802086a:	e7bd      	b.n	80207e8 <arm_cfft_q15+0x24>
 802086c:	2910      	cmp	r1, #16
 802086e:	d1bb      	bne.n	80207e8 <arm_cfft_q15+0x24>
 8020870:	e7c6      	b.n	8020800 <arm_cfft_q15+0x3c>
 8020872:	f5b1 7f00 	cmp.w	r1, #512	@ 0x200
 8020876:	d0dc      	beq.n	8020832 <arm_cfft_q15+0x6e>
 8020878:	e7b6      	b.n	80207e8 <arm_cfft_q15+0x24>
 802087a:	2910      	cmp	r1, #16
 802087c:	d1b4      	bne.n	80207e8 <arm_cfft_q15+0x24>
 802087e:	e7ef      	b.n	8020860 <arm_cfft_q15+0x9c>

08020880 <arm_radix4_butterfly_q15>:
 8020880:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020884:	b08f      	sub	sp, #60	@ 0x3c
 8020886:	469b      	mov	fp, r3
 8020888:	9101      	str	r1, [sp, #4]
 802088a:	0889      	lsrs	r1, r1, #2
 802088c:	460e      	mov	r6, r1
 802088e:	910d      	str	r1, [sp, #52]	@ 0x34
 8020890:	0089      	lsls	r1, r1, #2
 8020892:	4607      	mov	r7, r0
 8020894:	900c      	str	r0, [sp, #48]	@ 0x30
 8020896:	eb0b 034b 	add.w	r3, fp, fp, lsl #1
 802089a:	4408      	add	r0, r1
 802089c:	2400      	movs	r4, #0
 802089e:	1845      	adds	r5, r0, r1
 80208a0:	009b      	lsls	r3, r3, #2
 80208a2:	4696      	mov	lr, r2
 80208a4:	9209      	str	r2, [sp, #36]	@ 0x24
 80208a6:	46b2      	mov	sl, r6
 80208a8:	4429      	add	r1, r5
 80208aa:	9302      	str	r3, [sp, #8]
 80208ac:	4626      	mov	r6, r4
 80208ae:	4622      	mov	r2, r4
 80208b0:	f8cd b000 	str.w	fp, [sp]
 80208b4:	683b      	ldr	r3, [r7, #0]
 80208b6:	fa93 fc22 	shadd16	ip, r3, r2
 80208ba:	fa9c fc22 	shadd16	ip, ip, r2
 80208be:	682b      	ldr	r3, [r5, #0]
 80208c0:	fa93 f322 	shadd16	r3, r3, r2
 80208c4:	fa93 f322 	shadd16	r3, r3, r2
 80208c8:	fa9c f813 	qadd16	r8, ip, r3
 80208cc:	fadc fc13 	qsub16	ip, ip, r3
 80208d0:	6803      	ldr	r3, [r0, #0]
 80208d2:	fa93 f322 	shadd16	r3, r3, r2
 80208d6:	fa93 f922 	shadd16	r9, r3, r2
 80208da:	680b      	ldr	r3, [r1, #0]
 80208dc:	fa93 f322 	shadd16	r3, r3, r2
 80208e0:	fa93 f322 	shadd16	r3, r3, r2
 80208e4:	fa99 f313 	qadd16	r3, r9, r3
 80208e8:	fa98 f923 	shadd16	r9, r8, r3
 80208ec:	f847 9b04 	str.w	r9, [r7], #4
 80208f0:	fad8 f313 	qsub16	r3, r8, r3
 80208f4:	f85e 9036 	ldr.w	r9, [lr, r6, lsl #3]
 80208f8:	fb29 fb03 	smuad	fp, r9, r3
 80208fc:	fb49 f913 	smusdx	r9, r9, r3
 8020900:	6803      	ldr	r3, [r0, #0]
 8020902:	fa93 f322 	shadd16	r3, r3, r2
 8020906:	fa93 f822 	shadd16	r8, r3, r2
 802090a:	ea4f 4919 	mov.w	r9, r9, lsr #16
 802090e:	ea4f 4909 	mov.w	r9, r9, lsl #16
 8020912:	ea49 431b 	orr.w	r3, r9, fp, lsr #16
 8020916:	f840 3b04 	str.w	r3, [r0], #4
 802091a:	680b      	ldr	r3, [r1, #0]
 802091c:	fa93 f322 	shadd16	r3, r3, r2
 8020920:	fa93 f322 	shadd16	r3, r3, r2
 8020924:	fad8 f313 	qsub16	r3, r8, r3
 8020928:	faac f913 	qasx	r9, ip, r3
 802092c:	faec fc13 	qsax	ip, ip, r3
 8020930:	f85e 3026 	ldr.w	r3, [lr, r6, lsl #2]
 8020934:	fb23 f80c 	smuad	r8, r3, ip
 8020938:	fb43 f31c 	smusdx	r3, r3, ip
 802093c:	0c1b      	lsrs	r3, r3, #16
 802093e:	041b      	lsls	r3, r3, #16
 8020940:	ea43 4318 	orr.w	r3, r3, r8, lsr #16
 8020944:	f845 3b04 	str.w	r3, [r5], #4
 8020948:	f85e 3004 	ldr.w	r3, [lr, r4]
 802094c:	fb23 fc09 	smuad	ip, r3, r9
 8020950:	fb43 f319 	smusdx	r3, r3, r9
 8020954:	0c1b      	lsrs	r3, r3, #16
 8020956:	041b      	lsls	r3, r3, #16
 8020958:	ea43 431c 	orr.w	r3, r3, ip, lsr #16
 802095c:	f841 3b04 	str.w	r3, [r1], #4
 8020960:	9b00      	ldr	r3, [sp, #0]
 8020962:	441e      	add	r6, r3
 8020964:	9b02      	ldr	r3, [sp, #8]
 8020966:	f1ba 0a01 	subs.w	sl, sl, #1
 802096a:	441c      	add	r4, r3
 802096c:	d1a2      	bne.n	80208b4 <arm_radix4_butterfly_q15+0x34>
 802096e:	f8dd b000 	ldr.w	fp, [sp]
 8020972:	ea4f 038b 	mov.w	r3, fp, lsl #2
 8020976:	9306      	str	r3, [sp, #24]
 8020978:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 802097a:	2b04      	cmp	r3, #4
 802097c:	f240 8081 	bls.w	8020a82 <arm_radix4_butterfly_q15+0x202>
 8020980:	f8cd a008 	str.w	sl, [sp, #8]
 8020984:	930a      	str	r3, [sp, #40]	@ 0x28
 8020986:	469a      	mov	sl, r3
 8020988:	ea4f 039a 	mov.w	r3, sl, lsr #2
 802098c:	2200      	movs	r2, #0
 802098e:	4611      	mov	r1, r2
 8020990:	930b      	str	r3, [sp, #44]	@ 0x2c
 8020992:	9204      	str	r2, [sp, #16]
 8020994:	1e5a      	subs	r2, r3, #1
 8020996:	009b      	lsls	r3, r3, #2
 8020998:	9308      	str	r3, [sp, #32]
 802099a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 802099c:	9207      	str	r2, [sp, #28]
 802099e:	9105      	str	r1, [sp, #20]
 80209a0:	ea4f 078a 	mov.w	r7, sl, lsl #2
 80209a4:	9303      	str	r3, [sp, #12]
 80209a6:	9908      	ldr	r1, [sp, #32]
 80209a8:	9a03      	ldr	r2, [sp, #12]
 80209aa:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 80209ac:	1850      	adds	r0, r2, r1
 80209ae:	9a05      	ldr	r2, [sp, #20]
 80209b0:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80209b4:	f856 c022 	ldr.w	ip, [r6, r2, lsl #2]
 80209b8:	f856 9023 	ldr.w	r9, [r6, r3, lsl #2]
 80209bc:	9b06      	ldr	r3, [sp, #24]
 80209be:	f856 8032 	ldr.w	r8, [r6, r2, lsl #3]
 80209c2:	18d3      	adds	r3, r2, r3
 80209c4:	9305      	str	r3, [sp, #20]
 80209c6:	9a04      	ldr	r2, [sp, #16]
 80209c8:	9b01      	ldr	r3, [sp, #4]
 80209ca:	180d      	adds	r5, r1, r0
 80209cc:	4293      	cmp	r3, r2
 80209ce:	46b6      	mov	lr, r6
 80209d0:	eb01 0405 	add.w	r4, r1, r5
 80209d4:	9e03      	ldr	r6, [sp, #12]
 80209d6:	d941      	bls.n	8020a5c <arm_radix4_butterfly_q15+0x1dc>
 80209d8:	eb0a 0e02 	add.w	lr, sl, r2
 80209dc:	6833      	ldr	r3, [r6, #0]
 80209de:	682a      	ldr	r2, [r5, #0]
 80209e0:	fa93 fb12 	qadd16	fp, r3, r2
 80209e4:	fad3 f312 	qsub16	r3, r3, r2
 80209e8:	9300      	str	r3, [sp, #0]
 80209ea:	6802      	ldr	r2, [r0, #0]
 80209ec:	6821      	ldr	r1, [r4, #0]
 80209ee:	fa92 f211 	qadd16	r2, r2, r1
 80209f2:	fa9b f322 	shadd16	r3, fp, r2
 80209f6:	9902      	ldr	r1, [sp, #8]
 80209f8:	fa93 f121 	shadd16	r1, r3, r1
 80209fc:	6031      	str	r1, [r6, #0]
 80209fe:	443e      	add	r6, r7
 8020a00:	fadb f222 	shsub16	r2, fp, r2
 8020a04:	fb28 f102 	smuad	r1, r8, r2
 8020a08:	fb48 f212 	smusdx	r2, r8, r2
 8020a0c:	0c12      	lsrs	r2, r2, #16
 8020a0e:	0412      	lsls	r2, r2, #16
 8020a10:	ea42 4211 	orr.w	r2, r2, r1, lsr #16
 8020a14:	6801      	ldr	r1, [r0, #0]
 8020a16:	6002      	str	r2, [r0, #0]
 8020a18:	6822      	ldr	r2, [r4, #0]
 8020a1a:	4438      	add	r0, r7
 8020a1c:	fad1 f212 	qsub16	r2, r1, r2
 8020a20:	9b00      	ldr	r3, [sp, #0]
 8020a22:	faa3 f122 	shasx	r1, r3, r2
 8020a26:	fae3 f322 	shsax	r3, r3, r2
 8020a2a:	fb2c fb03 	smuad	fp, ip, r3
 8020a2e:	fb4c f313 	smusdx	r3, ip, r3
 8020a32:	0c1b      	lsrs	r3, r3, #16
 8020a34:	041b      	lsls	r3, r3, #16
 8020a36:	ea43 431b 	orr.w	r3, r3, fp, lsr #16
 8020a3a:	602b      	str	r3, [r5, #0]
 8020a3c:	443d      	add	r5, r7
 8020a3e:	fb29 f301 	smuad	r3, r9, r1
 8020a42:	fb49 f111 	smusdx	r1, r9, r1
 8020a46:	0c09      	lsrs	r1, r1, #16
 8020a48:	0409      	lsls	r1, r1, #16
 8020a4a:	9a01      	ldr	r2, [sp, #4]
 8020a4c:	ea41 4113 	orr.w	r1, r1, r3, lsr #16
 8020a50:	4673      	mov	r3, lr
 8020a52:	429a      	cmp	r2, r3
 8020a54:	6021      	str	r1, [r4, #0]
 8020a56:	44d6      	add	lr, sl
 8020a58:	443c      	add	r4, r7
 8020a5a:	d8bf      	bhi.n	80209dc <arm_radix4_butterfly_q15+0x15c>
 8020a5c:	9a03      	ldr	r2, [sp, #12]
 8020a5e:	9b04      	ldr	r3, [sp, #16]
 8020a60:	3204      	adds	r2, #4
 8020a62:	9203      	str	r2, [sp, #12]
 8020a64:	9a07      	ldr	r2, [sp, #28]
 8020a66:	3301      	adds	r3, #1
 8020a68:	4293      	cmp	r3, r2
 8020a6a:	9304      	str	r3, [sp, #16]
 8020a6c:	d99b      	bls.n	80209a6 <arm_radix4_butterfly_q15+0x126>
 8020a6e:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8020a70:	9a06      	ldr	r2, [sp, #24]
 8020a72:	f8dd a02c 	ldr.w	sl, [sp, #44]	@ 0x2c
 8020a76:	089b      	lsrs	r3, r3, #2
 8020a78:	0092      	lsls	r2, r2, #2
 8020a7a:	2b04      	cmp	r3, #4
 8020a7c:	930a      	str	r3, [sp, #40]	@ 0x28
 8020a7e:	9206      	str	r2, [sp, #24]
 8020a80:	d882      	bhi.n	8020988 <arm_radix4_butterfly_q15+0x108>
 8020a82:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 8020a84:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 8020a86:	3410      	adds	r4, #16
 8020a88:	f854 3c10 	ldr.w	r3, [r4, #-16]
 8020a8c:	f854 7c08 	ldr.w	r7, [r4, #-8]
 8020a90:	fa93 f117 	qadd16	r1, r3, r7
 8020a94:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 8020a98:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8020a9c:	fa92 f510 	qadd16	r5, r2, r0
 8020aa0:	fa91 f525 	shadd16	r5, r1, r5
 8020aa4:	f844 5c10 	str.w	r5, [r4, #-16]
 8020aa8:	fa92 f510 	qadd16	r5, r2, r0
 8020aac:	fad1 f125 	shsub16	r1, r1, r5
 8020ab0:	f844 1c0c 	str.w	r1, [r4, #-12]
 8020ab4:	fad3 f317 	qsub16	r3, r3, r7
 8020ab8:	fad2 f210 	qsub16	r2, r2, r0
 8020abc:	fae3 f122 	shsax	r1, r3, r2
 8020ac0:	f844 1c08 	str.w	r1, [r4, #-8]
 8020ac4:	faa3 f322 	shasx	r3, r3, r2
 8020ac8:	3e01      	subs	r6, #1
 8020aca:	f844 3c04 	str.w	r3, [r4, #-4]
 8020ace:	f104 0410 	add.w	r4, r4, #16
 8020ad2:	d1d9      	bne.n	8020a88 <arm_radix4_butterfly_q15+0x208>
 8020ad4:	b00f      	add	sp, #60	@ 0x3c
 8020ad6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020ada:	bf00      	nop

08020adc <arm_radix4_butterfly_inverse_q15>:
 8020adc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020ae0:	b08f      	sub	sp, #60	@ 0x3c
 8020ae2:	469b      	mov	fp, r3
 8020ae4:	9101      	str	r1, [sp, #4]
 8020ae6:	0889      	lsrs	r1, r1, #2
 8020ae8:	460e      	mov	r6, r1
 8020aea:	910d      	str	r1, [sp, #52]	@ 0x34
 8020aec:	0089      	lsls	r1, r1, #2
 8020aee:	4607      	mov	r7, r0
 8020af0:	900c      	str	r0, [sp, #48]	@ 0x30
 8020af2:	eb0b 034b 	add.w	r3, fp, fp, lsl #1
 8020af6:	4408      	add	r0, r1
 8020af8:	2400      	movs	r4, #0
 8020afa:	1845      	adds	r5, r0, r1
 8020afc:	009b      	lsls	r3, r3, #2
 8020afe:	4696      	mov	lr, r2
 8020b00:	9209      	str	r2, [sp, #36]	@ 0x24
 8020b02:	46b2      	mov	sl, r6
 8020b04:	4429      	add	r1, r5
 8020b06:	9302      	str	r3, [sp, #8]
 8020b08:	4626      	mov	r6, r4
 8020b0a:	4622      	mov	r2, r4
 8020b0c:	f8cd b000 	str.w	fp, [sp]
 8020b10:	683b      	ldr	r3, [r7, #0]
 8020b12:	fa93 fc22 	shadd16	ip, r3, r2
 8020b16:	fa9c fc22 	shadd16	ip, ip, r2
 8020b1a:	682b      	ldr	r3, [r5, #0]
 8020b1c:	fa93 f322 	shadd16	r3, r3, r2
 8020b20:	fa93 f322 	shadd16	r3, r3, r2
 8020b24:	fa9c f813 	qadd16	r8, ip, r3
 8020b28:	fadc fc13 	qsub16	ip, ip, r3
 8020b2c:	6803      	ldr	r3, [r0, #0]
 8020b2e:	fa93 f322 	shadd16	r3, r3, r2
 8020b32:	fa93 f922 	shadd16	r9, r3, r2
 8020b36:	680b      	ldr	r3, [r1, #0]
 8020b38:	fa93 f322 	shadd16	r3, r3, r2
 8020b3c:	fa93 f322 	shadd16	r3, r3, r2
 8020b40:	fa99 f313 	qadd16	r3, r9, r3
 8020b44:	fa98 f923 	shadd16	r9, r8, r3
 8020b48:	f847 9b04 	str.w	r9, [r7], #4
 8020b4c:	fad8 f313 	qsub16	r3, r8, r3
 8020b50:	f85e 9036 	ldr.w	r9, [lr, r6, lsl #3]
 8020b54:	fb49 fb03 	smusd	fp, r9, r3
 8020b58:	fb29 f913 	smuadx	r9, r9, r3
 8020b5c:	6803      	ldr	r3, [r0, #0]
 8020b5e:	fa93 f322 	shadd16	r3, r3, r2
 8020b62:	fa93 f822 	shadd16	r8, r3, r2
 8020b66:	ea4f 4919 	mov.w	r9, r9, lsr #16
 8020b6a:	ea4f 4909 	mov.w	r9, r9, lsl #16
 8020b6e:	ea49 431b 	orr.w	r3, r9, fp, lsr #16
 8020b72:	f840 3b04 	str.w	r3, [r0], #4
 8020b76:	680b      	ldr	r3, [r1, #0]
 8020b78:	fa93 f322 	shadd16	r3, r3, r2
 8020b7c:	fa93 f322 	shadd16	r3, r3, r2
 8020b80:	fad8 f313 	qsub16	r3, r8, r3
 8020b84:	faec f913 	qsax	r9, ip, r3
 8020b88:	faac fc13 	qasx	ip, ip, r3
 8020b8c:	f85e 3026 	ldr.w	r3, [lr, r6, lsl #2]
 8020b90:	fb43 f80c 	smusd	r8, r3, ip
 8020b94:	fb23 f31c 	smuadx	r3, r3, ip
 8020b98:	0c1b      	lsrs	r3, r3, #16
 8020b9a:	041b      	lsls	r3, r3, #16
 8020b9c:	ea43 4318 	orr.w	r3, r3, r8, lsr #16
 8020ba0:	f845 3b04 	str.w	r3, [r5], #4
 8020ba4:	f85e 3004 	ldr.w	r3, [lr, r4]
 8020ba8:	fb43 fc09 	smusd	ip, r3, r9
 8020bac:	fb23 f319 	smuadx	r3, r3, r9
 8020bb0:	0c1b      	lsrs	r3, r3, #16
 8020bb2:	041b      	lsls	r3, r3, #16
 8020bb4:	ea43 431c 	orr.w	r3, r3, ip, lsr #16
 8020bb8:	f841 3b04 	str.w	r3, [r1], #4
 8020bbc:	9b00      	ldr	r3, [sp, #0]
 8020bbe:	441e      	add	r6, r3
 8020bc0:	9b02      	ldr	r3, [sp, #8]
 8020bc2:	f1ba 0a01 	subs.w	sl, sl, #1
 8020bc6:	441c      	add	r4, r3
 8020bc8:	d1a2      	bne.n	8020b10 <arm_radix4_butterfly_inverse_q15+0x34>
 8020bca:	f8dd b000 	ldr.w	fp, [sp]
 8020bce:	ea4f 038b 	mov.w	r3, fp, lsl #2
 8020bd2:	9306      	str	r3, [sp, #24]
 8020bd4:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 8020bd6:	2b04      	cmp	r3, #4
 8020bd8:	f240 8081 	bls.w	8020cde <arm_radix4_butterfly_inverse_q15+0x202>
 8020bdc:	f8cd a008 	str.w	sl, [sp, #8]
 8020be0:	930a      	str	r3, [sp, #40]	@ 0x28
 8020be2:	469a      	mov	sl, r3
 8020be4:	ea4f 039a 	mov.w	r3, sl, lsr #2
 8020be8:	2200      	movs	r2, #0
 8020bea:	4611      	mov	r1, r2
 8020bec:	930b      	str	r3, [sp, #44]	@ 0x2c
 8020bee:	9204      	str	r2, [sp, #16]
 8020bf0:	1e5a      	subs	r2, r3, #1
 8020bf2:	009b      	lsls	r3, r3, #2
 8020bf4:	9308      	str	r3, [sp, #32]
 8020bf6:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8020bf8:	9207      	str	r2, [sp, #28]
 8020bfa:	9105      	str	r1, [sp, #20]
 8020bfc:	ea4f 078a 	mov.w	r7, sl, lsl #2
 8020c00:	9303      	str	r3, [sp, #12]
 8020c02:	9908      	ldr	r1, [sp, #32]
 8020c04:	9a03      	ldr	r2, [sp, #12]
 8020c06:	9e09      	ldr	r6, [sp, #36]	@ 0x24
 8020c08:	1850      	adds	r0, r2, r1
 8020c0a:	9a05      	ldr	r2, [sp, #20]
 8020c0c:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 8020c10:	f856 c022 	ldr.w	ip, [r6, r2, lsl #2]
 8020c14:	f856 9023 	ldr.w	r9, [r6, r3, lsl #2]
 8020c18:	9b06      	ldr	r3, [sp, #24]
 8020c1a:	f856 8032 	ldr.w	r8, [r6, r2, lsl #3]
 8020c1e:	18d3      	adds	r3, r2, r3
 8020c20:	9305      	str	r3, [sp, #20]
 8020c22:	9a04      	ldr	r2, [sp, #16]
 8020c24:	9b01      	ldr	r3, [sp, #4]
 8020c26:	180d      	adds	r5, r1, r0
 8020c28:	4293      	cmp	r3, r2
 8020c2a:	46b6      	mov	lr, r6
 8020c2c:	eb01 0405 	add.w	r4, r1, r5
 8020c30:	9e03      	ldr	r6, [sp, #12]
 8020c32:	d941      	bls.n	8020cb8 <arm_radix4_butterfly_inverse_q15+0x1dc>
 8020c34:	eb0a 0e02 	add.w	lr, sl, r2
 8020c38:	6833      	ldr	r3, [r6, #0]
 8020c3a:	682a      	ldr	r2, [r5, #0]
 8020c3c:	fa93 fb12 	qadd16	fp, r3, r2
 8020c40:	fad3 f312 	qsub16	r3, r3, r2
 8020c44:	9300      	str	r3, [sp, #0]
 8020c46:	6802      	ldr	r2, [r0, #0]
 8020c48:	6821      	ldr	r1, [r4, #0]
 8020c4a:	fa92 f211 	qadd16	r2, r2, r1
 8020c4e:	fa9b f322 	shadd16	r3, fp, r2
 8020c52:	9902      	ldr	r1, [sp, #8]
 8020c54:	fa93 f121 	shadd16	r1, r3, r1
 8020c58:	6031      	str	r1, [r6, #0]
 8020c5a:	443e      	add	r6, r7
 8020c5c:	fadb f222 	shsub16	r2, fp, r2
 8020c60:	fb48 f102 	smusd	r1, r8, r2
 8020c64:	fb28 f212 	smuadx	r2, r8, r2
 8020c68:	0c12      	lsrs	r2, r2, #16
 8020c6a:	0412      	lsls	r2, r2, #16
 8020c6c:	ea42 4211 	orr.w	r2, r2, r1, lsr #16
 8020c70:	6801      	ldr	r1, [r0, #0]
 8020c72:	6002      	str	r2, [r0, #0]
 8020c74:	6822      	ldr	r2, [r4, #0]
 8020c76:	4438      	add	r0, r7
 8020c78:	fad1 f212 	qsub16	r2, r1, r2
 8020c7c:	9b00      	ldr	r3, [sp, #0]
 8020c7e:	fae3 f122 	shsax	r1, r3, r2
 8020c82:	faa3 f322 	shasx	r3, r3, r2
 8020c86:	fb4c fb03 	smusd	fp, ip, r3
 8020c8a:	fb2c f313 	smuadx	r3, ip, r3
 8020c8e:	0c1b      	lsrs	r3, r3, #16
 8020c90:	041b      	lsls	r3, r3, #16
 8020c92:	ea43 431b 	orr.w	r3, r3, fp, lsr #16
 8020c96:	602b      	str	r3, [r5, #0]
 8020c98:	443d      	add	r5, r7
 8020c9a:	fb49 f301 	smusd	r3, r9, r1
 8020c9e:	fb29 f111 	smuadx	r1, r9, r1
 8020ca2:	0c09      	lsrs	r1, r1, #16
 8020ca4:	0409      	lsls	r1, r1, #16
 8020ca6:	9a01      	ldr	r2, [sp, #4]
 8020ca8:	ea41 4113 	orr.w	r1, r1, r3, lsr #16
 8020cac:	4673      	mov	r3, lr
 8020cae:	429a      	cmp	r2, r3
 8020cb0:	6021      	str	r1, [r4, #0]
 8020cb2:	44d6      	add	lr, sl
 8020cb4:	443c      	add	r4, r7
 8020cb6:	d8bf      	bhi.n	8020c38 <arm_radix4_butterfly_inverse_q15+0x15c>
 8020cb8:	9a03      	ldr	r2, [sp, #12]
 8020cba:	9b04      	ldr	r3, [sp, #16]
 8020cbc:	3204      	adds	r2, #4
 8020cbe:	9203      	str	r2, [sp, #12]
 8020cc0:	9a07      	ldr	r2, [sp, #28]
 8020cc2:	3301      	adds	r3, #1
 8020cc4:	4293      	cmp	r3, r2
 8020cc6:	9304      	str	r3, [sp, #16]
 8020cc8:	d99b      	bls.n	8020c02 <arm_radix4_butterfly_inverse_q15+0x126>
 8020cca:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8020ccc:	9a06      	ldr	r2, [sp, #24]
 8020cce:	f8dd a02c 	ldr.w	sl, [sp, #44]	@ 0x2c
 8020cd2:	089b      	lsrs	r3, r3, #2
 8020cd4:	0092      	lsls	r2, r2, #2
 8020cd6:	2b04      	cmp	r3, #4
 8020cd8:	930a      	str	r3, [sp, #40]	@ 0x28
 8020cda:	9206      	str	r2, [sp, #24]
 8020cdc:	d882      	bhi.n	8020be4 <arm_radix4_butterfly_inverse_q15+0x108>
 8020cde:	9c0c      	ldr	r4, [sp, #48]	@ 0x30
 8020ce0:	9e0d      	ldr	r6, [sp, #52]	@ 0x34
 8020ce2:	3410      	adds	r4, #16
 8020ce4:	f854 3c10 	ldr.w	r3, [r4, #-16]
 8020ce8:	f854 7c08 	ldr.w	r7, [r4, #-8]
 8020cec:	fa93 f117 	qadd16	r1, r3, r7
 8020cf0:	f854 2c0c 	ldr.w	r2, [r4, #-12]
 8020cf4:	f854 0c04 	ldr.w	r0, [r4, #-4]
 8020cf8:	fa92 f510 	qadd16	r5, r2, r0
 8020cfc:	fa91 f525 	shadd16	r5, r1, r5
 8020d00:	f844 5c10 	str.w	r5, [r4, #-16]
 8020d04:	fa92 f510 	qadd16	r5, r2, r0
 8020d08:	fad1 f125 	shsub16	r1, r1, r5
 8020d0c:	f844 1c0c 	str.w	r1, [r4, #-12]
 8020d10:	fad3 f317 	qsub16	r3, r3, r7
 8020d14:	fad2 f210 	qsub16	r2, r2, r0
 8020d18:	faa3 f122 	shasx	r1, r3, r2
 8020d1c:	f844 1c08 	str.w	r1, [r4, #-8]
 8020d20:	fae3 f322 	shsax	r3, r3, r2
 8020d24:	3e01      	subs	r6, #1
 8020d26:	f844 3c04 	str.w	r3, [r4, #-4]
 8020d2a:	f104 0410 	add.w	r4, r4, #16
 8020d2e:	d1d9      	bne.n	8020ce4 <arm_radix4_butterfly_inverse_q15+0x208>
 8020d30:	b00f      	add	sp, #60	@ 0x3c
 8020d32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020d36:	bf00      	nop

08020d38 <malloc>:
 8020d38:	4b02      	ldr	r3, [pc, #8]	@ (8020d44 <malloc+0xc>)
 8020d3a:	4601      	mov	r1, r0
 8020d3c:	6818      	ldr	r0, [r3, #0]
 8020d3e:	f000 b82d 	b.w	8020d9c <_malloc_r>
 8020d42:	bf00      	nop
 8020d44:	2000031c 	.word	0x2000031c

08020d48 <free>:
 8020d48:	4b02      	ldr	r3, [pc, #8]	@ (8020d54 <free+0xc>)
 8020d4a:	4601      	mov	r1, r0
 8020d4c:	6818      	ldr	r0, [r3, #0]
 8020d4e:	f001 bac9 	b.w	80222e4 <_free_r>
 8020d52:	bf00      	nop
 8020d54:	2000031c 	.word	0x2000031c

08020d58 <sbrk_aligned>:
 8020d58:	b570      	push	{r4, r5, r6, lr}
 8020d5a:	4e0f      	ldr	r6, [pc, #60]	@ (8020d98 <sbrk_aligned+0x40>)
 8020d5c:	460c      	mov	r4, r1
 8020d5e:	6831      	ldr	r1, [r6, #0]
 8020d60:	4605      	mov	r5, r0
 8020d62:	b911      	cbnz	r1, 8020d6a <sbrk_aligned+0x12>
 8020d64:	f001 fa48 	bl	80221f8 <_sbrk_r>
 8020d68:	6030      	str	r0, [r6, #0]
 8020d6a:	4621      	mov	r1, r4
 8020d6c:	4628      	mov	r0, r5
 8020d6e:	f001 fa43 	bl	80221f8 <_sbrk_r>
 8020d72:	1c43      	adds	r3, r0, #1
 8020d74:	d103      	bne.n	8020d7e <sbrk_aligned+0x26>
 8020d76:	f04f 34ff 	mov.w	r4, #4294967295
 8020d7a:	4620      	mov	r0, r4
 8020d7c:	bd70      	pop	{r4, r5, r6, pc}
 8020d7e:	1cc4      	adds	r4, r0, #3
 8020d80:	f024 0403 	bic.w	r4, r4, #3
 8020d84:	42a0      	cmp	r0, r4
 8020d86:	d0f8      	beq.n	8020d7a <sbrk_aligned+0x22>
 8020d88:	1a21      	subs	r1, r4, r0
 8020d8a:	4628      	mov	r0, r5
 8020d8c:	f001 fa34 	bl	80221f8 <_sbrk_r>
 8020d90:	3001      	adds	r0, #1
 8020d92:	d1f2      	bne.n	8020d7a <sbrk_aligned+0x22>
 8020d94:	e7ef      	b.n	8020d76 <sbrk_aligned+0x1e>
 8020d96:	bf00      	nop
 8020d98:	200121c0 	.word	0x200121c0

08020d9c <_malloc_r>:
 8020d9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8020da0:	1ccd      	adds	r5, r1, #3
 8020da2:	f025 0503 	bic.w	r5, r5, #3
 8020da6:	3508      	adds	r5, #8
 8020da8:	2d0c      	cmp	r5, #12
 8020daa:	bf38      	it	cc
 8020dac:	250c      	movcc	r5, #12
 8020dae:	2d00      	cmp	r5, #0
 8020db0:	4606      	mov	r6, r0
 8020db2:	db01      	blt.n	8020db8 <_malloc_r+0x1c>
 8020db4:	42a9      	cmp	r1, r5
 8020db6:	d904      	bls.n	8020dc2 <_malloc_r+0x26>
 8020db8:	230c      	movs	r3, #12
 8020dba:	6033      	str	r3, [r6, #0]
 8020dbc:	2000      	movs	r0, #0
 8020dbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8020dc2:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8020e98 <_malloc_r+0xfc>
 8020dc6:	f000 f869 	bl	8020e9c <__malloc_lock>
 8020dca:	f8d8 3000 	ldr.w	r3, [r8]
 8020dce:	461c      	mov	r4, r3
 8020dd0:	bb44      	cbnz	r4, 8020e24 <_malloc_r+0x88>
 8020dd2:	4629      	mov	r1, r5
 8020dd4:	4630      	mov	r0, r6
 8020dd6:	f7ff ffbf 	bl	8020d58 <sbrk_aligned>
 8020dda:	1c43      	adds	r3, r0, #1
 8020ddc:	4604      	mov	r4, r0
 8020dde:	d158      	bne.n	8020e92 <_malloc_r+0xf6>
 8020de0:	f8d8 4000 	ldr.w	r4, [r8]
 8020de4:	4627      	mov	r7, r4
 8020de6:	2f00      	cmp	r7, #0
 8020de8:	d143      	bne.n	8020e72 <_malloc_r+0xd6>
 8020dea:	2c00      	cmp	r4, #0
 8020dec:	d04b      	beq.n	8020e86 <_malloc_r+0xea>
 8020dee:	6823      	ldr	r3, [r4, #0]
 8020df0:	4639      	mov	r1, r7
 8020df2:	4630      	mov	r0, r6
 8020df4:	eb04 0903 	add.w	r9, r4, r3
 8020df8:	f001 f9fe 	bl	80221f8 <_sbrk_r>
 8020dfc:	4581      	cmp	r9, r0
 8020dfe:	d142      	bne.n	8020e86 <_malloc_r+0xea>
 8020e00:	6821      	ldr	r1, [r4, #0]
 8020e02:	1a6d      	subs	r5, r5, r1
 8020e04:	4629      	mov	r1, r5
 8020e06:	4630      	mov	r0, r6
 8020e08:	f7ff ffa6 	bl	8020d58 <sbrk_aligned>
 8020e0c:	3001      	adds	r0, #1
 8020e0e:	d03a      	beq.n	8020e86 <_malloc_r+0xea>
 8020e10:	6823      	ldr	r3, [r4, #0]
 8020e12:	442b      	add	r3, r5
 8020e14:	6023      	str	r3, [r4, #0]
 8020e16:	f8d8 3000 	ldr.w	r3, [r8]
 8020e1a:	685a      	ldr	r2, [r3, #4]
 8020e1c:	bb62      	cbnz	r2, 8020e78 <_malloc_r+0xdc>
 8020e1e:	f8c8 7000 	str.w	r7, [r8]
 8020e22:	e00f      	b.n	8020e44 <_malloc_r+0xa8>
 8020e24:	6822      	ldr	r2, [r4, #0]
 8020e26:	1b52      	subs	r2, r2, r5
 8020e28:	d420      	bmi.n	8020e6c <_malloc_r+0xd0>
 8020e2a:	2a0b      	cmp	r2, #11
 8020e2c:	d917      	bls.n	8020e5e <_malloc_r+0xc2>
 8020e2e:	1961      	adds	r1, r4, r5
 8020e30:	42a3      	cmp	r3, r4
 8020e32:	6025      	str	r5, [r4, #0]
 8020e34:	bf18      	it	ne
 8020e36:	6059      	strne	r1, [r3, #4]
 8020e38:	6863      	ldr	r3, [r4, #4]
 8020e3a:	bf08      	it	eq
 8020e3c:	f8c8 1000 	streq.w	r1, [r8]
 8020e40:	5162      	str	r2, [r4, r5]
 8020e42:	604b      	str	r3, [r1, #4]
 8020e44:	4630      	mov	r0, r6
 8020e46:	f000 f82f 	bl	8020ea8 <__malloc_unlock>
 8020e4a:	f104 000b 	add.w	r0, r4, #11
 8020e4e:	1d23      	adds	r3, r4, #4
 8020e50:	f020 0007 	bic.w	r0, r0, #7
 8020e54:	1ac2      	subs	r2, r0, r3
 8020e56:	bf1c      	itt	ne
 8020e58:	1a1b      	subne	r3, r3, r0
 8020e5a:	50a3      	strne	r3, [r4, r2]
 8020e5c:	e7af      	b.n	8020dbe <_malloc_r+0x22>
 8020e5e:	6862      	ldr	r2, [r4, #4]
 8020e60:	42a3      	cmp	r3, r4
 8020e62:	bf0c      	ite	eq
 8020e64:	f8c8 2000 	streq.w	r2, [r8]
 8020e68:	605a      	strne	r2, [r3, #4]
 8020e6a:	e7eb      	b.n	8020e44 <_malloc_r+0xa8>
 8020e6c:	4623      	mov	r3, r4
 8020e6e:	6864      	ldr	r4, [r4, #4]
 8020e70:	e7ae      	b.n	8020dd0 <_malloc_r+0x34>
 8020e72:	463c      	mov	r4, r7
 8020e74:	687f      	ldr	r7, [r7, #4]
 8020e76:	e7b6      	b.n	8020de6 <_malloc_r+0x4a>
 8020e78:	461a      	mov	r2, r3
 8020e7a:	685b      	ldr	r3, [r3, #4]
 8020e7c:	42a3      	cmp	r3, r4
 8020e7e:	d1fb      	bne.n	8020e78 <_malloc_r+0xdc>
 8020e80:	2300      	movs	r3, #0
 8020e82:	6053      	str	r3, [r2, #4]
 8020e84:	e7de      	b.n	8020e44 <_malloc_r+0xa8>
 8020e86:	230c      	movs	r3, #12
 8020e88:	6033      	str	r3, [r6, #0]
 8020e8a:	4630      	mov	r0, r6
 8020e8c:	f000 f80c 	bl	8020ea8 <__malloc_unlock>
 8020e90:	e794      	b.n	8020dbc <_malloc_r+0x20>
 8020e92:	6005      	str	r5, [r0, #0]
 8020e94:	e7d6      	b.n	8020e44 <_malloc_r+0xa8>
 8020e96:	bf00      	nop
 8020e98:	200121c4 	.word	0x200121c4

08020e9c <__malloc_lock>:
 8020e9c:	4801      	ldr	r0, [pc, #4]	@ (8020ea4 <__malloc_lock+0x8>)
 8020e9e:	f001 b9f8 	b.w	8022292 <__retarget_lock_acquire_recursive>
 8020ea2:	bf00      	nop
 8020ea4:	20012308 	.word	0x20012308

08020ea8 <__malloc_unlock>:
 8020ea8:	4801      	ldr	r0, [pc, #4]	@ (8020eb0 <__malloc_unlock+0x8>)
 8020eaa:	f001 b9f3 	b.w	8022294 <__retarget_lock_release_recursive>
 8020eae:	bf00      	nop
 8020eb0:	20012308 	.word	0x20012308

08020eb4 <sulp>:
 8020eb4:	b570      	push	{r4, r5, r6, lr}
 8020eb6:	4604      	mov	r4, r0
 8020eb8:	460d      	mov	r5, r1
 8020eba:	ec45 4b10 	vmov	d0, r4, r5
 8020ebe:	4616      	mov	r6, r2
 8020ec0:	f002 f91a 	bl	80230f8 <__ulp>
 8020ec4:	ec51 0b10 	vmov	r0, r1, d0
 8020ec8:	b17e      	cbz	r6, 8020eea <sulp+0x36>
 8020eca:	f3c5 530a 	ubfx	r3, r5, #20, #11
 8020ece:	f1c3 036b 	rsb	r3, r3, #107	@ 0x6b
 8020ed2:	2b00      	cmp	r3, #0
 8020ed4:	dd09      	ble.n	8020eea <sulp+0x36>
 8020ed6:	051b      	lsls	r3, r3, #20
 8020ed8:	f103 557f 	add.w	r5, r3, #1069547520	@ 0x3fc00000
 8020edc:	2400      	movs	r4, #0
 8020ede:	f505 1540 	add.w	r5, r5, #3145728	@ 0x300000
 8020ee2:	4622      	mov	r2, r4
 8020ee4:	462b      	mov	r3, r5
 8020ee6:	f7df fbf7 	bl	80006d8 <__aeabi_dmul>
 8020eea:	ec41 0b10 	vmov	d0, r0, r1
 8020eee:	bd70      	pop	{r4, r5, r6, pc}

08020ef0 <_strtod_l>:
 8020ef0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8020ef4:	b09f      	sub	sp, #124	@ 0x7c
 8020ef6:	460c      	mov	r4, r1
 8020ef8:	9217      	str	r2, [sp, #92]	@ 0x5c
 8020efa:	2200      	movs	r2, #0
 8020efc:	921a      	str	r2, [sp, #104]	@ 0x68
 8020efe:	9005      	str	r0, [sp, #20]
 8020f00:	f04f 0a00 	mov.w	sl, #0
 8020f04:	f04f 0b00 	mov.w	fp, #0
 8020f08:	460a      	mov	r2, r1
 8020f0a:	9219      	str	r2, [sp, #100]	@ 0x64
 8020f0c:	7811      	ldrb	r1, [r2, #0]
 8020f0e:	292b      	cmp	r1, #43	@ 0x2b
 8020f10:	d04a      	beq.n	8020fa8 <_strtod_l+0xb8>
 8020f12:	d838      	bhi.n	8020f86 <_strtod_l+0x96>
 8020f14:	290d      	cmp	r1, #13
 8020f16:	d832      	bhi.n	8020f7e <_strtod_l+0x8e>
 8020f18:	2908      	cmp	r1, #8
 8020f1a:	d832      	bhi.n	8020f82 <_strtod_l+0x92>
 8020f1c:	2900      	cmp	r1, #0
 8020f1e:	d03b      	beq.n	8020f98 <_strtod_l+0xa8>
 8020f20:	2200      	movs	r2, #0
 8020f22:	920b      	str	r2, [sp, #44]	@ 0x2c
 8020f24:	9d19      	ldr	r5, [sp, #100]	@ 0x64
 8020f26:	782a      	ldrb	r2, [r5, #0]
 8020f28:	2a30      	cmp	r2, #48	@ 0x30
 8020f2a:	f040 80b3 	bne.w	8021094 <_strtod_l+0x1a4>
 8020f2e:	786a      	ldrb	r2, [r5, #1]
 8020f30:	f002 02df 	and.w	r2, r2, #223	@ 0xdf
 8020f34:	2a58      	cmp	r2, #88	@ 0x58
 8020f36:	d16e      	bne.n	8021016 <_strtod_l+0x126>
 8020f38:	9302      	str	r3, [sp, #8]
 8020f3a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8020f3c:	9301      	str	r3, [sp, #4]
 8020f3e:	ab1a      	add	r3, sp, #104	@ 0x68
 8020f40:	9300      	str	r3, [sp, #0]
 8020f42:	4a8e      	ldr	r2, [pc, #568]	@ (802117c <_strtod_l+0x28c>)
 8020f44:	9805      	ldr	r0, [sp, #20]
 8020f46:	ab1b      	add	r3, sp, #108	@ 0x6c
 8020f48:	a919      	add	r1, sp, #100	@ 0x64
 8020f4a:	f001 fa7d 	bl	8022448 <__gethex>
 8020f4e:	f010 060f 	ands.w	r6, r0, #15
 8020f52:	4604      	mov	r4, r0
 8020f54:	d005      	beq.n	8020f62 <_strtod_l+0x72>
 8020f56:	2e06      	cmp	r6, #6
 8020f58:	d128      	bne.n	8020fac <_strtod_l+0xbc>
 8020f5a:	3501      	adds	r5, #1
 8020f5c:	2300      	movs	r3, #0
 8020f5e:	9519      	str	r5, [sp, #100]	@ 0x64
 8020f60:	930b      	str	r3, [sp, #44]	@ 0x2c
 8020f62:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8020f64:	2b00      	cmp	r3, #0
 8020f66:	f040 858e 	bne.w	8021a86 <_strtod_l+0xb96>
 8020f6a:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8020f6c:	b1cb      	cbz	r3, 8020fa2 <_strtod_l+0xb2>
 8020f6e:	4652      	mov	r2, sl
 8020f70:	f10b 4300 	add.w	r3, fp, #2147483648	@ 0x80000000
 8020f74:	ec43 2b10 	vmov	d0, r2, r3
 8020f78:	b01f      	add	sp, #124	@ 0x7c
 8020f7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020f7e:	2920      	cmp	r1, #32
 8020f80:	d1ce      	bne.n	8020f20 <_strtod_l+0x30>
 8020f82:	3201      	adds	r2, #1
 8020f84:	e7c1      	b.n	8020f0a <_strtod_l+0x1a>
 8020f86:	292d      	cmp	r1, #45	@ 0x2d
 8020f88:	d1ca      	bne.n	8020f20 <_strtod_l+0x30>
 8020f8a:	2101      	movs	r1, #1
 8020f8c:	910b      	str	r1, [sp, #44]	@ 0x2c
 8020f8e:	1c51      	adds	r1, r2, #1
 8020f90:	9119      	str	r1, [sp, #100]	@ 0x64
 8020f92:	7852      	ldrb	r2, [r2, #1]
 8020f94:	2a00      	cmp	r2, #0
 8020f96:	d1c5      	bne.n	8020f24 <_strtod_l+0x34>
 8020f98:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8020f9a:	9419      	str	r4, [sp, #100]	@ 0x64
 8020f9c:	2b00      	cmp	r3, #0
 8020f9e:	f040 8570 	bne.w	8021a82 <_strtod_l+0xb92>
 8020fa2:	4652      	mov	r2, sl
 8020fa4:	465b      	mov	r3, fp
 8020fa6:	e7e5      	b.n	8020f74 <_strtod_l+0x84>
 8020fa8:	2100      	movs	r1, #0
 8020faa:	e7ef      	b.n	8020f8c <_strtod_l+0x9c>
 8020fac:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 8020fae:	b13a      	cbz	r2, 8020fc0 <_strtod_l+0xd0>
 8020fb0:	2135      	movs	r1, #53	@ 0x35
 8020fb2:	a81c      	add	r0, sp, #112	@ 0x70
 8020fb4:	f002 f99a 	bl	80232ec <__copybits>
 8020fb8:	991a      	ldr	r1, [sp, #104]	@ 0x68
 8020fba:	9805      	ldr	r0, [sp, #20]
 8020fbc:	f001 fd68 	bl	8022a90 <_Bfree>
 8020fc0:	3e01      	subs	r6, #1
 8020fc2:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 8020fc4:	2e04      	cmp	r6, #4
 8020fc6:	d806      	bhi.n	8020fd6 <_strtod_l+0xe6>
 8020fc8:	e8df f006 	tbb	[pc, r6]
 8020fcc:	201d0314 	.word	0x201d0314
 8020fd0:	14          	.byte	0x14
 8020fd1:	00          	.byte	0x00
 8020fd2:	e9dd ab1c 	ldrd	sl, fp, [sp, #112]	@ 0x70
 8020fd6:	05e1      	lsls	r1, r4, #23
 8020fd8:	bf48      	it	mi
 8020fda:	f04b 4b00 	orrmi.w	fp, fp, #2147483648	@ 0x80000000
 8020fde:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 8020fe2:	0d1b      	lsrs	r3, r3, #20
 8020fe4:	051b      	lsls	r3, r3, #20
 8020fe6:	2b00      	cmp	r3, #0
 8020fe8:	d1bb      	bne.n	8020f62 <_strtod_l+0x72>
 8020fea:	f001 f927 	bl	802223c <__errno>
 8020fee:	2322      	movs	r3, #34	@ 0x22
 8020ff0:	6003      	str	r3, [r0, #0]
 8020ff2:	e7b6      	b.n	8020f62 <_strtod_l+0x72>
 8020ff4:	e9dd a31c 	ldrd	sl, r3, [sp, #112]	@ 0x70
 8020ff8:	f202 4233 	addw	r2, r2, #1075	@ 0x433
 8020ffc:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8021000:	ea43 5b02 	orr.w	fp, r3, r2, lsl #20
 8021004:	e7e7      	b.n	8020fd6 <_strtod_l+0xe6>
 8021006:	f8df b17c 	ldr.w	fp, [pc, #380]	@ 8021184 <_strtod_l+0x294>
 802100a:	e7e4      	b.n	8020fd6 <_strtod_l+0xe6>
 802100c:	f06f 4b00 	mvn.w	fp, #2147483648	@ 0x80000000
 8021010:	f04f 3aff 	mov.w	sl, #4294967295
 8021014:	e7df      	b.n	8020fd6 <_strtod_l+0xe6>
 8021016:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8021018:	1c5a      	adds	r2, r3, #1
 802101a:	9219      	str	r2, [sp, #100]	@ 0x64
 802101c:	785b      	ldrb	r3, [r3, #1]
 802101e:	2b30      	cmp	r3, #48	@ 0x30
 8021020:	d0f9      	beq.n	8021016 <_strtod_l+0x126>
 8021022:	2b00      	cmp	r3, #0
 8021024:	d09d      	beq.n	8020f62 <_strtod_l+0x72>
 8021026:	2301      	movs	r3, #1
 8021028:	9309      	str	r3, [sp, #36]	@ 0x24
 802102a:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 802102c:	930c      	str	r3, [sp, #48]	@ 0x30
 802102e:	2300      	movs	r3, #0
 8021030:	9308      	str	r3, [sp, #32]
 8021032:	930a      	str	r3, [sp, #40]	@ 0x28
 8021034:	461f      	mov	r7, r3
 8021036:	220a      	movs	r2, #10
 8021038:	9819      	ldr	r0, [sp, #100]	@ 0x64
 802103a:	7805      	ldrb	r5, [r0, #0]
 802103c:	f1a5 0330 	sub.w	r3, r5, #48	@ 0x30
 8021040:	b2d9      	uxtb	r1, r3
 8021042:	2909      	cmp	r1, #9
 8021044:	d928      	bls.n	8021098 <_strtod_l+0x1a8>
 8021046:	494e      	ldr	r1, [pc, #312]	@ (8021180 <_strtod_l+0x290>)
 8021048:	2201      	movs	r2, #1
 802104a:	f001 f863 	bl	8022114 <strncmp>
 802104e:	2800      	cmp	r0, #0
 8021050:	d032      	beq.n	80210b8 <_strtod_l+0x1c8>
 8021052:	2000      	movs	r0, #0
 8021054:	462a      	mov	r2, r5
 8021056:	4681      	mov	r9, r0
 8021058:	463d      	mov	r5, r7
 802105a:	4603      	mov	r3, r0
 802105c:	2a65      	cmp	r2, #101	@ 0x65
 802105e:	d001      	beq.n	8021064 <_strtod_l+0x174>
 8021060:	2a45      	cmp	r2, #69	@ 0x45
 8021062:	d114      	bne.n	802108e <_strtod_l+0x19e>
 8021064:	b91d      	cbnz	r5, 802106e <_strtod_l+0x17e>
 8021066:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8021068:	4302      	orrs	r2, r0
 802106a:	d095      	beq.n	8020f98 <_strtod_l+0xa8>
 802106c:	2500      	movs	r5, #0
 802106e:	9c19      	ldr	r4, [sp, #100]	@ 0x64
 8021070:	1c62      	adds	r2, r4, #1
 8021072:	9219      	str	r2, [sp, #100]	@ 0x64
 8021074:	7862      	ldrb	r2, [r4, #1]
 8021076:	2a2b      	cmp	r2, #43	@ 0x2b
 8021078:	d077      	beq.n	802116a <_strtod_l+0x27a>
 802107a:	2a2d      	cmp	r2, #45	@ 0x2d
 802107c:	d07b      	beq.n	8021176 <_strtod_l+0x286>
 802107e:	f04f 0c00 	mov.w	ip, #0
 8021082:	f1a2 0130 	sub.w	r1, r2, #48	@ 0x30
 8021086:	2909      	cmp	r1, #9
 8021088:	f240 8082 	bls.w	8021190 <_strtod_l+0x2a0>
 802108c:	9419      	str	r4, [sp, #100]	@ 0x64
 802108e:	f04f 0800 	mov.w	r8, #0
 8021092:	e0a2      	b.n	80211da <_strtod_l+0x2ea>
 8021094:	2300      	movs	r3, #0
 8021096:	e7c7      	b.n	8021028 <_strtod_l+0x138>
 8021098:	2f08      	cmp	r7, #8
 802109a:	bfd5      	itete	le
 802109c:	990a      	ldrle	r1, [sp, #40]	@ 0x28
 802109e:	9908      	ldrgt	r1, [sp, #32]
 80210a0:	fb02 3301 	mlale	r3, r2, r1, r3
 80210a4:	fb02 3301 	mlagt	r3, r2, r1, r3
 80210a8:	f100 0001 	add.w	r0, r0, #1
 80210ac:	bfd4      	ite	le
 80210ae:	930a      	strle	r3, [sp, #40]	@ 0x28
 80210b0:	9308      	strgt	r3, [sp, #32]
 80210b2:	3701      	adds	r7, #1
 80210b4:	9019      	str	r0, [sp, #100]	@ 0x64
 80210b6:	e7bf      	b.n	8021038 <_strtod_l+0x148>
 80210b8:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80210ba:	1c5a      	adds	r2, r3, #1
 80210bc:	9219      	str	r2, [sp, #100]	@ 0x64
 80210be:	785a      	ldrb	r2, [r3, #1]
 80210c0:	b37f      	cbz	r7, 8021122 <_strtod_l+0x232>
 80210c2:	4681      	mov	r9, r0
 80210c4:	463d      	mov	r5, r7
 80210c6:	f1a2 0330 	sub.w	r3, r2, #48	@ 0x30
 80210ca:	2b09      	cmp	r3, #9
 80210cc:	d912      	bls.n	80210f4 <_strtod_l+0x204>
 80210ce:	2301      	movs	r3, #1
 80210d0:	e7c4      	b.n	802105c <_strtod_l+0x16c>
 80210d2:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80210d4:	1c5a      	adds	r2, r3, #1
 80210d6:	9219      	str	r2, [sp, #100]	@ 0x64
 80210d8:	785a      	ldrb	r2, [r3, #1]
 80210da:	3001      	adds	r0, #1
 80210dc:	2a30      	cmp	r2, #48	@ 0x30
 80210de:	d0f8      	beq.n	80210d2 <_strtod_l+0x1e2>
 80210e0:	f1a2 0331 	sub.w	r3, r2, #49	@ 0x31
 80210e4:	2b08      	cmp	r3, #8
 80210e6:	f200 84d3 	bhi.w	8021a90 <_strtod_l+0xba0>
 80210ea:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80210ec:	930c      	str	r3, [sp, #48]	@ 0x30
 80210ee:	4681      	mov	r9, r0
 80210f0:	2000      	movs	r0, #0
 80210f2:	4605      	mov	r5, r0
 80210f4:	3a30      	subs	r2, #48	@ 0x30
 80210f6:	f100 0301 	add.w	r3, r0, #1
 80210fa:	d02a      	beq.n	8021152 <_strtod_l+0x262>
 80210fc:	4499      	add	r9, r3
 80210fe:	eb00 0c05 	add.w	ip, r0, r5
 8021102:	462b      	mov	r3, r5
 8021104:	210a      	movs	r1, #10
 8021106:	4563      	cmp	r3, ip
 8021108:	d10d      	bne.n	8021126 <_strtod_l+0x236>
 802110a:	1c69      	adds	r1, r5, #1
 802110c:	4401      	add	r1, r0
 802110e:	4428      	add	r0, r5
 8021110:	2808      	cmp	r0, #8
 8021112:	dc16      	bgt.n	8021142 <_strtod_l+0x252>
 8021114:	980a      	ldr	r0, [sp, #40]	@ 0x28
 8021116:	230a      	movs	r3, #10
 8021118:	fb03 2300 	mla	r3, r3, r0, r2
 802111c:	930a      	str	r3, [sp, #40]	@ 0x28
 802111e:	2300      	movs	r3, #0
 8021120:	e018      	b.n	8021154 <_strtod_l+0x264>
 8021122:	4638      	mov	r0, r7
 8021124:	e7da      	b.n	80210dc <_strtod_l+0x1ec>
 8021126:	2b08      	cmp	r3, #8
 8021128:	f103 0301 	add.w	r3, r3, #1
 802112c:	dc03      	bgt.n	8021136 <_strtod_l+0x246>
 802112e:	9e0a      	ldr	r6, [sp, #40]	@ 0x28
 8021130:	434e      	muls	r6, r1
 8021132:	960a      	str	r6, [sp, #40]	@ 0x28
 8021134:	e7e7      	b.n	8021106 <_strtod_l+0x216>
 8021136:	2b10      	cmp	r3, #16
 8021138:	bfde      	ittt	le
 802113a:	9e08      	ldrle	r6, [sp, #32]
 802113c:	434e      	mulle	r6, r1
 802113e:	9608      	strle	r6, [sp, #32]
 8021140:	e7e1      	b.n	8021106 <_strtod_l+0x216>
 8021142:	280f      	cmp	r0, #15
 8021144:	dceb      	bgt.n	802111e <_strtod_l+0x22e>
 8021146:	9808      	ldr	r0, [sp, #32]
 8021148:	230a      	movs	r3, #10
 802114a:	fb03 2300 	mla	r3, r3, r0, r2
 802114e:	9308      	str	r3, [sp, #32]
 8021150:	e7e5      	b.n	802111e <_strtod_l+0x22e>
 8021152:	4629      	mov	r1, r5
 8021154:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 8021156:	1c50      	adds	r0, r2, #1
 8021158:	9019      	str	r0, [sp, #100]	@ 0x64
 802115a:	7852      	ldrb	r2, [r2, #1]
 802115c:	4618      	mov	r0, r3
 802115e:	460d      	mov	r5, r1
 8021160:	e7b1      	b.n	80210c6 <_strtod_l+0x1d6>
 8021162:	f04f 0900 	mov.w	r9, #0
 8021166:	2301      	movs	r3, #1
 8021168:	e77d      	b.n	8021066 <_strtod_l+0x176>
 802116a:	f04f 0c00 	mov.w	ip, #0
 802116e:	1ca2      	adds	r2, r4, #2
 8021170:	9219      	str	r2, [sp, #100]	@ 0x64
 8021172:	78a2      	ldrb	r2, [r4, #2]
 8021174:	e785      	b.n	8021082 <_strtod_l+0x192>
 8021176:	f04f 0c01 	mov.w	ip, #1
 802117a:	e7f8      	b.n	802116e <_strtod_l+0x27e>
 802117c:	080392b8 	.word	0x080392b8
 8021180:	08039294 	.word	0x08039294
 8021184:	7ff00000 	.word	0x7ff00000
 8021188:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 802118a:	1c51      	adds	r1, r2, #1
 802118c:	9119      	str	r1, [sp, #100]	@ 0x64
 802118e:	7852      	ldrb	r2, [r2, #1]
 8021190:	2a30      	cmp	r2, #48	@ 0x30
 8021192:	d0f9      	beq.n	8021188 <_strtod_l+0x298>
 8021194:	f1a2 0131 	sub.w	r1, r2, #49	@ 0x31
 8021198:	2908      	cmp	r1, #8
 802119a:	f63f af78 	bhi.w	802108e <_strtod_l+0x19e>
 802119e:	3a30      	subs	r2, #48	@ 0x30
 80211a0:	920e      	str	r2, [sp, #56]	@ 0x38
 80211a2:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 80211a4:	920f      	str	r2, [sp, #60]	@ 0x3c
 80211a6:	f04f 080a 	mov.w	r8, #10
 80211aa:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 80211ac:	1c56      	adds	r6, r2, #1
 80211ae:	9619      	str	r6, [sp, #100]	@ 0x64
 80211b0:	7852      	ldrb	r2, [r2, #1]
 80211b2:	f1a2 0e30 	sub.w	lr, r2, #48	@ 0x30
 80211b6:	f1be 0f09 	cmp.w	lr, #9
 80211ba:	d939      	bls.n	8021230 <_strtod_l+0x340>
 80211bc:	990f      	ldr	r1, [sp, #60]	@ 0x3c
 80211be:	1a76      	subs	r6, r6, r1
 80211c0:	2e08      	cmp	r6, #8
 80211c2:	f644 681f 	movw	r8, #19999	@ 0x4e1f
 80211c6:	dc03      	bgt.n	80211d0 <_strtod_l+0x2e0>
 80211c8:	990e      	ldr	r1, [sp, #56]	@ 0x38
 80211ca:	4588      	cmp	r8, r1
 80211cc:	bfa8      	it	ge
 80211ce:	4688      	movge	r8, r1
 80211d0:	f1bc 0f00 	cmp.w	ip, #0
 80211d4:	d001      	beq.n	80211da <_strtod_l+0x2ea>
 80211d6:	f1c8 0800 	rsb	r8, r8, #0
 80211da:	2d00      	cmp	r5, #0
 80211dc:	d14e      	bne.n	802127c <_strtod_l+0x38c>
 80211de:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80211e0:	4308      	orrs	r0, r1
 80211e2:	f47f aebe 	bne.w	8020f62 <_strtod_l+0x72>
 80211e6:	2b00      	cmp	r3, #0
 80211e8:	f47f aed6 	bne.w	8020f98 <_strtod_l+0xa8>
 80211ec:	2a69      	cmp	r2, #105	@ 0x69
 80211ee:	d028      	beq.n	8021242 <_strtod_l+0x352>
 80211f0:	dc25      	bgt.n	802123e <_strtod_l+0x34e>
 80211f2:	2a49      	cmp	r2, #73	@ 0x49
 80211f4:	d025      	beq.n	8021242 <_strtod_l+0x352>
 80211f6:	2a4e      	cmp	r2, #78	@ 0x4e
 80211f8:	f47f aece 	bne.w	8020f98 <_strtod_l+0xa8>
 80211fc:	499b      	ldr	r1, [pc, #620]	@ (802146c <_strtod_l+0x57c>)
 80211fe:	a819      	add	r0, sp, #100	@ 0x64
 8021200:	f001 fb44 	bl	802288c <__match>
 8021204:	2800      	cmp	r0, #0
 8021206:	f43f aec7 	beq.w	8020f98 <_strtod_l+0xa8>
 802120a:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 802120c:	781b      	ldrb	r3, [r3, #0]
 802120e:	2b28      	cmp	r3, #40	@ 0x28
 8021210:	d12e      	bne.n	8021270 <_strtod_l+0x380>
 8021212:	4997      	ldr	r1, [pc, #604]	@ (8021470 <_strtod_l+0x580>)
 8021214:	aa1c      	add	r2, sp, #112	@ 0x70
 8021216:	a819      	add	r0, sp, #100	@ 0x64
 8021218:	f001 fb4c 	bl	80228b4 <__hexnan>
 802121c:	2805      	cmp	r0, #5
 802121e:	d127      	bne.n	8021270 <_strtod_l+0x380>
 8021220:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8021222:	f8dd a070 	ldr.w	sl, [sp, #112]	@ 0x70
 8021226:	f043 4bff 	orr.w	fp, r3, #2139095040	@ 0x7f800000
 802122a:	f44b 0be0 	orr.w	fp, fp, #7340032	@ 0x700000
 802122e:	e698      	b.n	8020f62 <_strtod_l+0x72>
 8021230:	990e      	ldr	r1, [sp, #56]	@ 0x38
 8021232:	fb08 2101 	mla	r1, r8, r1, r2
 8021236:	f1a1 0230 	sub.w	r2, r1, #48	@ 0x30
 802123a:	920e      	str	r2, [sp, #56]	@ 0x38
 802123c:	e7b5      	b.n	80211aa <_strtod_l+0x2ba>
 802123e:	2a6e      	cmp	r2, #110	@ 0x6e
 8021240:	e7da      	b.n	80211f8 <_strtod_l+0x308>
 8021242:	498c      	ldr	r1, [pc, #560]	@ (8021474 <_strtod_l+0x584>)
 8021244:	a819      	add	r0, sp, #100	@ 0x64
 8021246:	f001 fb21 	bl	802288c <__match>
 802124a:	2800      	cmp	r0, #0
 802124c:	f43f aea4 	beq.w	8020f98 <_strtod_l+0xa8>
 8021250:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8021252:	4989      	ldr	r1, [pc, #548]	@ (8021478 <_strtod_l+0x588>)
 8021254:	3b01      	subs	r3, #1
 8021256:	a819      	add	r0, sp, #100	@ 0x64
 8021258:	9319      	str	r3, [sp, #100]	@ 0x64
 802125a:	f001 fb17 	bl	802288c <__match>
 802125e:	b910      	cbnz	r0, 8021266 <_strtod_l+0x376>
 8021260:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8021262:	3301      	adds	r3, #1
 8021264:	9319      	str	r3, [sp, #100]	@ 0x64
 8021266:	f8df b220 	ldr.w	fp, [pc, #544]	@ 8021488 <_strtod_l+0x598>
 802126a:	f04f 0a00 	mov.w	sl, #0
 802126e:	e678      	b.n	8020f62 <_strtod_l+0x72>
 8021270:	4882      	ldr	r0, [pc, #520]	@ (802147c <_strtod_l+0x58c>)
 8021272:	f001 f829 	bl	80222c8 <nan>
 8021276:	ec5b ab10 	vmov	sl, fp, d0
 802127a:	e672      	b.n	8020f62 <_strtod_l+0x72>
 802127c:	eba8 0309 	sub.w	r3, r8, r9
 8021280:	980a      	ldr	r0, [sp, #40]	@ 0x28
 8021282:	9309      	str	r3, [sp, #36]	@ 0x24
 8021284:	2f00      	cmp	r7, #0
 8021286:	bf08      	it	eq
 8021288:	462f      	moveq	r7, r5
 802128a:	2d10      	cmp	r5, #16
 802128c:	462c      	mov	r4, r5
 802128e:	bfa8      	it	ge
 8021290:	2410      	movge	r4, #16
 8021292:	f7df f9a7 	bl	80005e4 <__aeabi_ui2d>
 8021296:	2d09      	cmp	r5, #9
 8021298:	4682      	mov	sl, r0
 802129a:	468b      	mov	fp, r1
 802129c:	dc13      	bgt.n	80212c6 <_strtod_l+0x3d6>
 802129e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80212a0:	2b00      	cmp	r3, #0
 80212a2:	f43f ae5e 	beq.w	8020f62 <_strtod_l+0x72>
 80212a6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80212a8:	dd78      	ble.n	802139c <_strtod_l+0x4ac>
 80212aa:	2b16      	cmp	r3, #22
 80212ac:	dc5f      	bgt.n	802136e <_strtod_l+0x47e>
 80212ae:	4974      	ldr	r1, [pc, #464]	@ (8021480 <_strtod_l+0x590>)
 80212b0:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 80212b4:	e9d1 0100 	ldrd	r0, r1, [r1]
 80212b8:	4652      	mov	r2, sl
 80212ba:	465b      	mov	r3, fp
 80212bc:	f7df fa0c 	bl	80006d8 <__aeabi_dmul>
 80212c0:	4682      	mov	sl, r0
 80212c2:	468b      	mov	fp, r1
 80212c4:	e64d      	b.n	8020f62 <_strtod_l+0x72>
 80212c6:	4b6e      	ldr	r3, [pc, #440]	@ (8021480 <_strtod_l+0x590>)
 80212c8:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 80212cc:	e953 2312 	ldrd	r2, r3, [r3, #-72]	@ 0x48
 80212d0:	f7df fa02 	bl	80006d8 <__aeabi_dmul>
 80212d4:	4682      	mov	sl, r0
 80212d6:	9808      	ldr	r0, [sp, #32]
 80212d8:	468b      	mov	fp, r1
 80212da:	f7df f983 	bl	80005e4 <__aeabi_ui2d>
 80212de:	4602      	mov	r2, r0
 80212e0:	460b      	mov	r3, r1
 80212e2:	4650      	mov	r0, sl
 80212e4:	4659      	mov	r1, fp
 80212e6:	f7df f841 	bl	800036c <__adddf3>
 80212ea:	2d0f      	cmp	r5, #15
 80212ec:	4682      	mov	sl, r0
 80212ee:	468b      	mov	fp, r1
 80212f0:	ddd5      	ble.n	802129e <_strtod_l+0x3ae>
 80212f2:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80212f4:	1b2c      	subs	r4, r5, r4
 80212f6:	441c      	add	r4, r3
 80212f8:	2c00      	cmp	r4, #0
 80212fa:	f340 8096 	ble.w	802142a <_strtod_l+0x53a>
 80212fe:	f014 030f 	ands.w	r3, r4, #15
 8021302:	d00a      	beq.n	802131a <_strtod_l+0x42a>
 8021304:	495e      	ldr	r1, [pc, #376]	@ (8021480 <_strtod_l+0x590>)
 8021306:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
 802130a:	4652      	mov	r2, sl
 802130c:	465b      	mov	r3, fp
 802130e:	e9d1 0100 	ldrd	r0, r1, [r1]
 8021312:	f7df f9e1 	bl	80006d8 <__aeabi_dmul>
 8021316:	4682      	mov	sl, r0
 8021318:	468b      	mov	fp, r1
 802131a:	f034 040f 	bics.w	r4, r4, #15
 802131e:	d073      	beq.n	8021408 <_strtod_l+0x518>
 8021320:	f5b4 7f9a 	cmp.w	r4, #308	@ 0x134
 8021324:	dd48      	ble.n	80213b8 <_strtod_l+0x4c8>
 8021326:	2400      	movs	r4, #0
 8021328:	46a0      	mov	r8, r4
 802132a:	940a      	str	r4, [sp, #40]	@ 0x28
 802132c:	46a1      	mov	r9, r4
 802132e:	9a05      	ldr	r2, [sp, #20]
 8021330:	f8df b154 	ldr.w	fp, [pc, #340]	@ 8021488 <_strtod_l+0x598>
 8021334:	2322      	movs	r3, #34	@ 0x22
 8021336:	6013      	str	r3, [r2, #0]
 8021338:	f04f 0a00 	mov.w	sl, #0
 802133c:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 802133e:	2b00      	cmp	r3, #0
 8021340:	f43f ae0f 	beq.w	8020f62 <_strtod_l+0x72>
 8021344:	991a      	ldr	r1, [sp, #104]	@ 0x68
 8021346:	9805      	ldr	r0, [sp, #20]
 8021348:	f001 fba2 	bl	8022a90 <_Bfree>
 802134c:	9805      	ldr	r0, [sp, #20]
 802134e:	4649      	mov	r1, r9
 8021350:	f001 fb9e 	bl	8022a90 <_Bfree>
 8021354:	9805      	ldr	r0, [sp, #20]
 8021356:	4641      	mov	r1, r8
 8021358:	f001 fb9a 	bl	8022a90 <_Bfree>
 802135c:	990a      	ldr	r1, [sp, #40]	@ 0x28
 802135e:	9805      	ldr	r0, [sp, #20]
 8021360:	f001 fb96 	bl	8022a90 <_Bfree>
 8021364:	9805      	ldr	r0, [sp, #20]
 8021366:	4621      	mov	r1, r4
 8021368:	f001 fb92 	bl	8022a90 <_Bfree>
 802136c:	e5f9      	b.n	8020f62 <_strtod_l+0x72>
 802136e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8021370:	f1c5 0325 	rsb	r3, r5, #37	@ 0x25
 8021374:	4293      	cmp	r3, r2
 8021376:	dbbc      	blt.n	80212f2 <_strtod_l+0x402>
 8021378:	4c41      	ldr	r4, [pc, #260]	@ (8021480 <_strtod_l+0x590>)
 802137a:	f1c5 050f 	rsb	r5, r5, #15
 802137e:	eb04 01c5 	add.w	r1, r4, r5, lsl #3
 8021382:	4652      	mov	r2, sl
 8021384:	465b      	mov	r3, fp
 8021386:	e9d1 0100 	ldrd	r0, r1, [r1]
 802138a:	f7df f9a5 	bl	80006d8 <__aeabi_dmul>
 802138e:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8021390:	1b5d      	subs	r5, r3, r5
 8021392:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
 8021396:	e9d4 2300 	ldrd	r2, r3, [r4]
 802139a:	e78f      	b.n	80212bc <_strtod_l+0x3cc>
 802139c:	3316      	adds	r3, #22
 802139e:	dba8      	blt.n	80212f2 <_strtod_l+0x402>
 80213a0:	4b37      	ldr	r3, [pc, #220]	@ (8021480 <_strtod_l+0x590>)
 80213a2:	eba9 0808 	sub.w	r8, r9, r8
 80213a6:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
 80213aa:	e9d8 2300 	ldrd	r2, r3, [r8]
 80213ae:	4650      	mov	r0, sl
 80213b0:	4659      	mov	r1, fp
 80213b2:	f7df fabb 	bl	800092c <__aeabi_ddiv>
 80213b6:	e783      	b.n	80212c0 <_strtod_l+0x3d0>
 80213b8:	4b32      	ldr	r3, [pc, #200]	@ (8021484 <_strtod_l+0x594>)
 80213ba:	9308      	str	r3, [sp, #32]
 80213bc:	2300      	movs	r3, #0
 80213be:	1124      	asrs	r4, r4, #4
 80213c0:	4650      	mov	r0, sl
 80213c2:	4659      	mov	r1, fp
 80213c4:	461e      	mov	r6, r3
 80213c6:	2c01      	cmp	r4, #1
 80213c8:	dc21      	bgt.n	802140e <_strtod_l+0x51e>
 80213ca:	b10b      	cbz	r3, 80213d0 <_strtod_l+0x4e0>
 80213cc:	4682      	mov	sl, r0
 80213ce:	468b      	mov	fp, r1
 80213d0:	492c      	ldr	r1, [pc, #176]	@ (8021484 <_strtod_l+0x594>)
 80213d2:	f1ab 7b54 	sub.w	fp, fp, #55574528	@ 0x3500000
 80213d6:	eb01 01c6 	add.w	r1, r1, r6, lsl #3
 80213da:	4652      	mov	r2, sl
 80213dc:	465b      	mov	r3, fp
 80213de:	e9d1 0100 	ldrd	r0, r1, [r1]
 80213e2:	f7df f979 	bl	80006d8 <__aeabi_dmul>
 80213e6:	4b28      	ldr	r3, [pc, #160]	@ (8021488 <_strtod_l+0x598>)
 80213e8:	460a      	mov	r2, r1
 80213ea:	400b      	ands	r3, r1
 80213ec:	4927      	ldr	r1, [pc, #156]	@ (802148c <_strtod_l+0x59c>)
 80213ee:	428b      	cmp	r3, r1
 80213f0:	4682      	mov	sl, r0
 80213f2:	d898      	bhi.n	8021326 <_strtod_l+0x436>
 80213f4:	f5a1 1180 	sub.w	r1, r1, #1048576	@ 0x100000
 80213f8:	428b      	cmp	r3, r1
 80213fa:	bf86      	itte	hi
 80213fc:	f8df b090 	ldrhi.w	fp, [pc, #144]	@ 8021490 <_strtod_l+0x5a0>
 8021400:	f04f 3aff 	movhi.w	sl, #4294967295
 8021404:	f102 7b54 	addls.w	fp, r2, #55574528	@ 0x3500000
 8021408:	2300      	movs	r3, #0
 802140a:	9308      	str	r3, [sp, #32]
 802140c:	e07a      	b.n	8021504 <_strtod_l+0x614>
 802140e:	07e2      	lsls	r2, r4, #31
 8021410:	d505      	bpl.n	802141e <_strtod_l+0x52e>
 8021412:	9b08      	ldr	r3, [sp, #32]
 8021414:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021418:	f7df f95e 	bl	80006d8 <__aeabi_dmul>
 802141c:	2301      	movs	r3, #1
 802141e:	9a08      	ldr	r2, [sp, #32]
 8021420:	3208      	adds	r2, #8
 8021422:	3601      	adds	r6, #1
 8021424:	1064      	asrs	r4, r4, #1
 8021426:	9208      	str	r2, [sp, #32]
 8021428:	e7cd      	b.n	80213c6 <_strtod_l+0x4d6>
 802142a:	d0ed      	beq.n	8021408 <_strtod_l+0x518>
 802142c:	4264      	negs	r4, r4
 802142e:	f014 020f 	ands.w	r2, r4, #15
 8021432:	d00a      	beq.n	802144a <_strtod_l+0x55a>
 8021434:	4b12      	ldr	r3, [pc, #72]	@ (8021480 <_strtod_l+0x590>)
 8021436:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 802143a:	4650      	mov	r0, sl
 802143c:	4659      	mov	r1, fp
 802143e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021442:	f7df fa73 	bl	800092c <__aeabi_ddiv>
 8021446:	4682      	mov	sl, r0
 8021448:	468b      	mov	fp, r1
 802144a:	1124      	asrs	r4, r4, #4
 802144c:	d0dc      	beq.n	8021408 <_strtod_l+0x518>
 802144e:	2c1f      	cmp	r4, #31
 8021450:	dd20      	ble.n	8021494 <_strtod_l+0x5a4>
 8021452:	2400      	movs	r4, #0
 8021454:	46a0      	mov	r8, r4
 8021456:	940a      	str	r4, [sp, #40]	@ 0x28
 8021458:	46a1      	mov	r9, r4
 802145a:	9a05      	ldr	r2, [sp, #20]
 802145c:	2322      	movs	r3, #34	@ 0x22
 802145e:	f04f 0a00 	mov.w	sl, #0
 8021462:	f04f 0b00 	mov.w	fp, #0
 8021466:	6013      	str	r3, [r2, #0]
 8021468:	e768      	b.n	802133c <_strtod_l+0x44c>
 802146a:	bf00      	nop
 802146c:	0803929f 	.word	0x0803929f
 8021470:	080392a4 	.word	0x080392a4
 8021474:	08039296 	.word	0x08039296
 8021478:	08039299 	.word	0x08039299
 802147c:	0803964e 	.word	0x0803964e
 8021480:	08039518 	.word	0x08039518
 8021484:	080394f0 	.word	0x080394f0
 8021488:	7ff00000 	.word	0x7ff00000
 802148c:	7ca00000 	.word	0x7ca00000
 8021490:	7fefffff 	.word	0x7fefffff
 8021494:	f014 0310 	ands.w	r3, r4, #16
 8021498:	bf18      	it	ne
 802149a:	236a      	movne	r3, #106	@ 0x6a
 802149c:	4ea9      	ldr	r6, [pc, #676]	@ (8021744 <_strtod_l+0x854>)
 802149e:	9308      	str	r3, [sp, #32]
 80214a0:	4650      	mov	r0, sl
 80214a2:	4659      	mov	r1, fp
 80214a4:	2300      	movs	r3, #0
 80214a6:	07e2      	lsls	r2, r4, #31
 80214a8:	d504      	bpl.n	80214b4 <_strtod_l+0x5c4>
 80214aa:	e9d6 2300 	ldrd	r2, r3, [r6]
 80214ae:	f7df f913 	bl	80006d8 <__aeabi_dmul>
 80214b2:	2301      	movs	r3, #1
 80214b4:	1064      	asrs	r4, r4, #1
 80214b6:	f106 0608 	add.w	r6, r6, #8
 80214ba:	d1f4      	bne.n	80214a6 <_strtod_l+0x5b6>
 80214bc:	b10b      	cbz	r3, 80214c2 <_strtod_l+0x5d2>
 80214be:	4682      	mov	sl, r0
 80214c0:	468b      	mov	fp, r1
 80214c2:	9b08      	ldr	r3, [sp, #32]
 80214c4:	b1b3      	cbz	r3, 80214f4 <_strtod_l+0x604>
 80214c6:	f3cb 520a 	ubfx	r2, fp, #20, #11
 80214ca:	f1c2 036b 	rsb	r3, r2, #107	@ 0x6b
 80214ce:	2b00      	cmp	r3, #0
 80214d0:	4659      	mov	r1, fp
 80214d2:	dd0f      	ble.n	80214f4 <_strtod_l+0x604>
 80214d4:	2b1f      	cmp	r3, #31
 80214d6:	dd55      	ble.n	8021584 <_strtod_l+0x694>
 80214d8:	2b34      	cmp	r3, #52	@ 0x34
 80214da:	bfde      	ittt	le
 80214dc:	f04f 33ff 	movle.w	r3, #4294967295
 80214e0:	f1c2 024b 	rsble	r2, r2, #75	@ 0x4b
 80214e4:	4093      	lslle	r3, r2
 80214e6:	f04f 0a00 	mov.w	sl, #0
 80214ea:	bfcc      	ite	gt
 80214ec:	f04f 7b5c 	movgt.w	fp, #57671680	@ 0x3700000
 80214f0:	ea03 0b01 	andle.w	fp, r3, r1
 80214f4:	2200      	movs	r2, #0
 80214f6:	2300      	movs	r3, #0
 80214f8:	4650      	mov	r0, sl
 80214fa:	4659      	mov	r1, fp
 80214fc:	f7df fb54 	bl	8000ba8 <__aeabi_dcmpeq>
 8021500:	2800      	cmp	r0, #0
 8021502:	d1a6      	bne.n	8021452 <_strtod_l+0x562>
 8021504:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8021506:	9300      	str	r3, [sp, #0]
 8021508:	990c      	ldr	r1, [sp, #48]	@ 0x30
 802150a:	9805      	ldr	r0, [sp, #20]
 802150c:	462b      	mov	r3, r5
 802150e:	463a      	mov	r2, r7
 8021510:	f001 fb26 	bl	8022b60 <__s2b>
 8021514:	900a      	str	r0, [sp, #40]	@ 0x28
 8021516:	2800      	cmp	r0, #0
 8021518:	f43f af05 	beq.w	8021326 <_strtod_l+0x436>
 802151c:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 802151e:	2a00      	cmp	r2, #0
 8021520:	eba9 0308 	sub.w	r3, r9, r8
 8021524:	bfa8      	it	ge
 8021526:	2300      	movge	r3, #0
 8021528:	9312      	str	r3, [sp, #72]	@ 0x48
 802152a:	2400      	movs	r4, #0
 802152c:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
 8021530:	9316      	str	r3, [sp, #88]	@ 0x58
 8021532:	46a0      	mov	r8, r4
 8021534:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8021536:	9805      	ldr	r0, [sp, #20]
 8021538:	6859      	ldr	r1, [r3, #4]
 802153a:	f001 fa69 	bl	8022a10 <_Balloc>
 802153e:	4681      	mov	r9, r0
 8021540:	2800      	cmp	r0, #0
 8021542:	f43f aef4 	beq.w	802132e <_strtod_l+0x43e>
 8021546:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 8021548:	691a      	ldr	r2, [r3, #16]
 802154a:	3202      	adds	r2, #2
 802154c:	f103 010c 	add.w	r1, r3, #12
 8021550:	0092      	lsls	r2, r2, #2
 8021552:	300c      	adds	r0, #12
 8021554:	f000 fea7 	bl	80222a6 <memcpy>
 8021558:	ec4b ab10 	vmov	d0, sl, fp
 802155c:	9805      	ldr	r0, [sp, #20]
 802155e:	aa1c      	add	r2, sp, #112	@ 0x70
 8021560:	a91b      	add	r1, sp, #108	@ 0x6c
 8021562:	e9cd ab0c 	strd	sl, fp, [sp, #48]	@ 0x30
 8021566:	f001 fe37 	bl	80231d8 <__d2b>
 802156a:	901a      	str	r0, [sp, #104]	@ 0x68
 802156c:	2800      	cmp	r0, #0
 802156e:	f43f aede 	beq.w	802132e <_strtod_l+0x43e>
 8021572:	9805      	ldr	r0, [sp, #20]
 8021574:	2101      	movs	r1, #1
 8021576:	f001 fb89 	bl	8022c8c <__i2b>
 802157a:	4680      	mov	r8, r0
 802157c:	b948      	cbnz	r0, 8021592 <_strtod_l+0x6a2>
 802157e:	f04f 0800 	mov.w	r8, #0
 8021582:	e6d4      	b.n	802132e <_strtod_l+0x43e>
 8021584:	f04f 32ff 	mov.w	r2, #4294967295
 8021588:	fa02 f303 	lsl.w	r3, r2, r3
 802158c:	ea03 0a0a 	and.w	sl, r3, sl
 8021590:	e7b0      	b.n	80214f4 <_strtod_l+0x604>
 8021592:	9d1b      	ldr	r5, [sp, #108]	@ 0x6c
 8021594:	9a1c      	ldr	r2, [sp, #112]	@ 0x70
 8021596:	2d00      	cmp	r5, #0
 8021598:	bfab      	itete	ge
 802159a:	9b12      	ldrge	r3, [sp, #72]	@ 0x48
 802159c:	9b16      	ldrlt	r3, [sp, #88]	@ 0x58
 802159e:	9e16      	ldrge	r6, [sp, #88]	@ 0x58
 80215a0:	9f12      	ldrlt	r7, [sp, #72]	@ 0x48
 80215a2:	bfac      	ite	ge
 80215a4:	18ef      	addge	r7, r5, r3
 80215a6:	1b5e      	sublt	r6, r3, r5
 80215a8:	9b08      	ldr	r3, [sp, #32]
 80215aa:	1aed      	subs	r5, r5, r3
 80215ac:	4415      	add	r5, r2
 80215ae:	4b66      	ldr	r3, [pc, #408]	@ (8021748 <_strtod_l+0x858>)
 80215b0:	3d01      	subs	r5, #1
 80215b2:	429d      	cmp	r5, r3
 80215b4:	f1c2 0236 	rsb	r2, r2, #54	@ 0x36
 80215b8:	da50      	bge.n	802165c <_strtod_l+0x76c>
 80215ba:	1b5b      	subs	r3, r3, r5
 80215bc:	2b1f      	cmp	r3, #31
 80215be:	eba2 0203 	sub.w	r2, r2, r3
 80215c2:	f04f 0101 	mov.w	r1, #1
 80215c6:	dc3d      	bgt.n	8021644 <_strtod_l+0x754>
 80215c8:	fa01 f303 	lsl.w	r3, r1, r3
 80215cc:	9313      	str	r3, [sp, #76]	@ 0x4c
 80215ce:	2300      	movs	r3, #0
 80215d0:	9310      	str	r3, [sp, #64]	@ 0x40
 80215d2:	18bd      	adds	r5, r7, r2
 80215d4:	9b08      	ldr	r3, [sp, #32]
 80215d6:	42af      	cmp	r7, r5
 80215d8:	4416      	add	r6, r2
 80215da:	441e      	add	r6, r3
 80215dc:	463b      	mov	r3, r7
 80215de:	bfa8      	it	ge
 80215e0:	462b      	movge	r3, r5
 80215e2:	42b3      	cmp	r3, r6
 80215e4:	bfa8      	it	ge
 80215e6:	4633      	movge	r3, r6
 80215e8:	2b00      	cmp	r3, #0
 80215ea:	bfc2      	ittt	gt
 80215ec:	1aed      	subgt	r5, r5, r3
 80215ee:	1af6      	subgt	r6, r6, r3
 80215f0:	1aff      	subgt	r7, r7, r3
 80215f2:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 80215f4:	2b00      	cmp	r3, #0
 80215f6:	dd16      	ble.n	8021626 <_strtod_l+0x736>
 80215f8:	4641      	mov	r1, r8
 80215fa:	9805      	ldr	r0, [sp, #20]
 80215fc:	461a      	mov	r2, r3
 80215fe:	f001 fc05 	bl	8022e0c <__pow5mult>
 8021602:	4680      	mov	r8, r0
 8021604:	2800      	cmp	r0, #0
 8021606:	d0ba      	beq.n	802157e <_strtod_l+0x68e>
 8021608:	4601      	mov	r1, r0
 802160a:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 802160c:	9805      	ldr	r0, [sp, #20]
 802160e:	f001 fb53 	bl	8022cb8 <__multiply>
 8021612:	900e      	str	r0, [sp, #56]	@ 0x38
 8021614:	2800      	cmp	r0, #0
 8021616:	f43f ae8a 	beq.w	802132e <_strtod_l+0x43e>
 802161a:	991a      	ldr	r1, [sp, #104]	@ 0x68
 802161c:	9805      	ldr	r0, [sp, #20]
 802161e:	f001 fa37 	bl	8022a90 <_Bfree>
 8021622:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8021624:	931a      	str	r3, [sp, #104]	@ 0x68
 8021626:	2d00      	cmp	r5, #0
 8021628:	dc1d      	bgt.n	8021666 <_strtod_l+0x776>
 802162a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 802162c:	2b00      	cmp	r3, #0
 802162e:	dd23      	ble.n	8021678 <_strtod_l+0x788>
 8021630:	4649      	mov	r1, r9
 8021632:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 8021634:	9805      	ldr	r0, [sp, #20]
 8021636:	f001 fbe9 	bl	8022e0c <__pow5mult>
 802163a:	4681      	mov	r9, r0
 802163c:	b9e0      	cbnz	r0, 8021678 <_strtod_l+0x788>
 802163e:	f04f 0900 	mov.w	r9, #0
 8021642:	e674      	b.n	802132e <_strtod_l+0x43e>
 8021644:	f1c5 457f 	rsb	r5, r5, #4278190080	@ 0xff000000
 8021648:	f505 057f 	add.w	r5, r5, #16711680	@ 0xff0000
 802164c:	f505 457b 	add.w	r5, r5, #64256	@ 0xfb00
 8021650:	35e2      	adds	r5, #226	@ 0xe2
 8021652:	fa01 f305 	lsl.w	r3, r1, r5
 8021656:	9310      	str	r3, [sp, #64]	@ 0x40
 8021658:	9113      	str	r1, [sp, #76]	@ 0x4c
 802165a:	e7ba      	b.n	80215d2 <_strtod_l+0x6e2>
 802165c:	2300      	movs	r3, #0
 802165e:	9310      	str	r3, [sp, #64]	@ 0x40
 8021660:	2301      	movs	r3, #1
 8021662:	9313      	str	r3, [sp, #76]	@ 0x4c
 8021664:	e7b5      	b.n	80215d2 <_strtod_l+0x6e2>
 8021666:	991a      	ldr	r1, [sp, #104]	@ 0x68
 8021668:	9805      	ldr	r0, [sp, #20]
 802166a:	462a      	mov	r2, r5
 802166c:	f001 fc28 	bl	8022ec0 <__lshift>
 8021670:	901a      	str	r0, [sp, #104]	@ 0x68
 8021672:	2800      	cmp	r0, #0
 8021674:	d1d9      	bne.n	802162a <_strtod_l+0x73a>
 8021676:	e65a      	b.n	802132e <_strtod_l+0x43e>
 8021678:	2e00      	cmp	r6, #0
 802167a:	dd07      	ble.n	802168c <_strtod_l+0x79c>
 802167c:	4649      	mov	r1, r9
 802167e:	9805      	ldr	r0, [sp, #20]
 8021680:	4632      	mov	r2, r6
 8021682:	f001 fc1d 	bl	8022ec0 <__lshift>
 8021686:	4681      	mov	r9, r0
 8021688:	2800      	cmp	r0, #0
 802168a:	d0d8      	beq.n	802163e <_strtod_l+0x74e>
 802168c:	2f00      	cmp	r7, #0
 802168e:	dd08      	ble.n	80216a2 <_strtod_l+0x7b2>
 8021690:	4641      	mov	r1, r8
 8021692:	9805      	ldr	r0, [sp, #20]
 8021694:	463a      	mov	r2, r7
 8021696:	f001 fc13 	bl	8022ec0 <__lshift>
 802169a:	4680      	mov	r8, r0
 802169c:	2800      	cmp	r0, #0
 802169e:	f43f ae46 	beq.w	802132e <_strtod_l+0x43e>
 80216a2:	991a      	ldr	r1, [sp, #104]	@ 0x68
 80216a4:	9805      	ldr	r0, [sp, #20]
 80216a6:	464a      	mov	r2, r9
 80216a8:	f001 fc92 	bl	8022fd0 <__mdiff>
 80216ac:	4604      	mov	r4, r0
 80216ae:	2800      	cmp	r0, #0
 80216b0:	f43f ae3d 	beq.w	802132e <_strtod_l+0x43e>
 80216b4:	68c3      	ldr	r3, [r0, #12]
 80216b6:	930f      	str	r3, [sp, #60]	@ 0x3c
 80216b8:	2300      	movs	r3, #0
 80216ba:	60c3      	str	r3, [r0, #12]
 80216bc:	4641      	mov	r1, r8
 80216be:	f001 fc6b 	bl	8022f98 <__mcmp>
 80216c2:	2800      	cmp	r0, #0
 80216c4:	da46      	bge.n	8021754 <_strtod_l+0x864>
 80216c6:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80216c8:	ea53 030a 	orrs.w	r3, r3, sl
 80216cc:	d16c      	bne.n	80217a8 <_strtod_l+0x8b8>
 80216ce:	f3cb 0313 	ubfx	r3, fp, #0, #20
 80216d2:	2b00      	cmp	r3, #0
 80216d4:	d168      	bne.n	80217a8 <_strtod_l+0x8b8>
 80216d6:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 80216da:	0d1b      	lsrs	r3, r3, #20
 80216dc:	051b      	lsls	r3, r3, #20
 80216de:	f1b3 6fd6 	cmp.w	r3, #112197632	@ 0x6b00000
 80216e2:	d961      	bls.n	80217a8 <_strtod_l+0x8b8>
 80216e4:	6963      	ldr	r3, [r4, #20]
 80216e6:	b913      	cbnz	r3, 80216ee <_strtod_l+0x7fe>
 80216e8:	6923      	ldr	r3, [r4, #16]
 80216ea:	2b01      	cmp	r3, #1
 80216ec:	dd5c      	ble.n	80217a8 <_strtod_l+0x8b8>
 80216ee:	4621      	mov	r1, r4
 80216f0:	2201      	movs	r2, #1
 80216f2:	9805      	ldr	r0, [sp, #20]
 80216f4:	f001 fbe4 	bl	8022ec0 <__lshift>
 80216f8:	4641      	mov	r1, r8
 80216fa:	4604      	mov	r4, r0
 80216fc:	f001 fc4c 	bl	8022f98 <__mcmp>
 8021700:	2800      	cmp	r0, #0
 8021702:	dd51      	ble.n	80217a8 <_strtod_l+0x8b8>
 8021704:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 8021708:	9a08      	ldr	r2, [sp, #32]
 802170a:	0d1b      	lsrs	r3, r3, #20
 802170c:	051b      	lsls	r3, r3, #20
 802170e:	2a00      	cmp	r2, #0
 8021710:	d06b      	beq.n	80217ea <_strtod_l+0x8fa>
 8021712:	f1b3 6fd6 	cmp.w	r3, #112197632	@ 0x6b00000
 8021716:	d868      	bhi.n	80217ea <_strtod_l+0x8fa>
 8021718:	f1b3 7f5c 	cmp.w	r3, #57671680	@ 0x3700000
 802171c:	f67f ae9d 	bls.w	802145a <_strtod_l+0x56a>
 8021720:	4b0a      	ldr	r3, [pc, #40]	@ (802174c <_strtod_l+0x85c>)
 8021722:	4650      	mov	r0, sl
 8021724:	4659      	mov	r1, fp
 8021726:	2200      	movs	r2, #0
 8021728:	f7de ffd6 	bl	80006d8 <__aeabi_dmul>
 802172c:	4b08      	ldr	r3, [pc, #32]	@ (8021750 <_strtod_l+0x860>)
 802172e:	400b      	ands	r3, r1
 8021730:	4682      	mov	sl, r0
 8021732:	468b      	mov	fp, r1
 8021734:	2b00      	cmp	r3, #0
 8021736:	f47f ae05 	bne.w	8021344 <_strtod_l+0x454>
 802173a:	9a05      	ldr	r2, [sp, #20]
 802173c:	2322      	movs	r3, #34	@ 0x22
 802173e:	6013      	str	r3, [r2, #0]
 8021740:	e600      	b.n	8021344 <_strtod_l+0x454>
 8021742:	bf00      	nop
 8021744:	080392d0 	.word	0x080392d0
 8021748:	fffffc02 	.word	0xfffffc02
 802174c:	39500000 	.word	0x39500000
 8021750:	7ff00000 	.word	0x7ff00000
 8021754:	f8cd b038 	str.w	fp, [sp, #56]	@ 0x38
 8021758:	d165      	bne.n	8021826 <_strtod_l+0x936>
 802175a:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 802175c:	f3cb 0313 	ubfx	r3, fp, #0, #20
 8021760:	b35a      	cbz	r2, 80217ba <_strtod_l+0x8ca>
 8021762:	4a9f      	ldr	r2, [pc, #636]	@ (80219e0 <_strtod_l+0xaf0>)
 8021764:	4293      	cmp	r3, r2
 8021766:	d12b      	bne.n	80217c0 <_strtod_l+0x8d0>
 8021768:	9b08      	ldr	r3, [sp, #32]
 802176a:	4651      	mov	r1, sl
 802176c:	b303      	cbz	r3, 80217b0 <_strtod_l+0x8c0>
 802176e:	4b9d      	ldr	r3, [pc, #628]	@ (80219e4 <_strtod_l+0xaf4>)
 8021770:	465a      	mov	r2, fp
 8021772:	4013      	ands	r3, r2
 8021774:	f1b3 6fd4 	cmp.w	r3, #111149056	@ 0x6a00000
 8021778:	f04f 32ff 	mov.w	r2, #4294967295
 802177c:	d81b      	bhi.n	80217b6 <_strtod_l+0x8c6>
 802177e:	0d1b      	lsrs	r3, r3, #20
 8021780:	f1c3 036b 	rsb	r3, r3, #107	@ 0x6b
 8021784:	fa02 f303 	lsl.w	r3, r2, r3
 8021788:	4299      	cmp	r1, r3
 802178a:	d119      	bne.n	80217c0 <_strtod_l+0x8d0>
 802178c:	4b96      	ldr	r3, [pc, #600]	@ (80219e8 <_strtod_l+0xaf8>)
 802178e:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8021790:	429a      	cmp	r2, r3
 8021792:	d102      	bne.n	802179a <_strtod_l+0x8aa>
 8021794:	3101      	adds	r1, #1
 8021796:	f43f adca 	beq.w	802132e <_strtod_l+0x43e>
 802179a:	4b92      	ldr	r3, [pc, #584]	@ (80219e4 <_strtod_l+0xaf4>)
 802179c:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 802179e:	401a      	ands	r2, r3
 80217a0:	f502 1b80 	add.w	fp, r2, #1048576	@ 0x100000
 80217a4:	f04f 0a00 	mov.w	sl, #0
 80217a8:	9b08      	ldr	r3, [sp, #32]
 80217aa:	2b00      	cmp	r3, #0
 80217ac:	d1b8      	bne.n	8021720 <_strtod_l+0x830>
 80217ae:	e5c9      	b.n	8021344 <_strtod_l+0x454>
 80217b0:	f04f 33ff 	mov.w	r3, #4294967295
 80217b4:	e7e8      	b.n	8021788 <_strtod_l+0x898>
 80217b6:	4613      	mov	r3, r2
 80217b8:	e7e6      	b.n	8021788 <_strtod_l+0x898>
 80217ba:	ea53 030a 	orrs.w	r3, r3, sl
 80217be:	d0a1      	beq.n	8021704 <_strtod_l+0x814>
 80217c0:	9b10      	ldr	r3, [sp, #64]	@ 0x40
 80217c2:	b1db      	cbz	r3, 80217fc <_strtod_l+0x90c>
 80217c4:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 80217c6:	4213      	tst	r3, r2
 80217c8:	d0ee      	beq.n	80217a8 <_strtod_l+0x8b8>
 80217ca:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80217cc:	9a08      	ldr	r2, [sp, #32]
 80217ce:	4650      	mov	r0, sl
 80217d0:	4659      	mov	r1, fp
 80217d2:	b1bb      	cbz	r3, 8021804 <_strtod_l+0x914>
 80217d4:	f7ff fb6e 	bl	8020eb4 <sulp>
 80217d8:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 80217dc:	ec53 2b10 	vmov	r2, r3, d0
 80217e0:	f7de fdc4 	bl	800036c <__adddf3>
 80217e4:	4682      	mov	sl, r0
 80217e6:	468b      	mov	fp, r1
 80217e8:	e7de      	b.n	80217a8 <_strtod_l+0x8b8>
 80217ea:	f5a3 1380 	sub.w	r3, r3, #1048576	@ 0x100000
 80217ee:	ea6f 5b13 	mvn.w	fp, r3, lsr #20
 80217f2:	ea6f 5b0b 	mvn.w	fp, fp, lsl #20
 80217f6:	f04f 3aff 	mov.w	sl, #4294967295
 80217fa:	e7d5      	b.n	80217a8 <_strtod_l+0x8b8>
 80217fc:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 80217fe:	ea13 0f0a 	tst.w	r3, sl
 8021802:	e7e1      	b.n	80217c8 <_strtod_l+0x8d8>
 8021804:	f7ff fb56 	bl	8020eb4 <sulp>
 8021808:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 802180c:	ec53 2b10 	vmov	r2, r3, d0
 8021810:	f7de fdaa 	bl	8000368 <__aeabi_dsub>
 8021814:	2200      	movs	r2, #0
 8021816:	2300      	movs	r3, #0
 8021818:	4682      	mov	sl, r0
 802181a:	468b      	mov	fp, r1
 802181c:	f7df f9c4 	bl	8000ba8 <__aeabi_dcmpeq>
 8021820:	2800      	cmp	r0, #0
 8021822:	d0c1      	beq.n	80217a8 <_strtod_l+0x8b8>
 8021824:	e619      	b.n	802145a <_strtod_l+0x56a>
 8021826:	4641      	mov	r1, r8
 8021828:	4620      	mov	r0, r4
 802182a:	f001 fd2d 	bl	8023288 <__ratio>
 802182e:	ec57 6b10 	vmov	r6, r7, d0
 8021832:	2200      	movs	r2, #0
 8021834:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8021838:	4630      	mov	r0, r6
 802183a:	4639      	mov	r1, r7
 802183c:	f7df f9c8 	bl	8000bd0 <__aeabi_dcmple>
 8021840:	2800      	cmp	r0, #0
 8021842:	d06f      	beq.n	8021924 <_strtod_l+0xa34>
 8021844:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8021846:	2b00      	cmp	r3, #0
 8021848:	d17a      	bne.n	8021940 <_strtod_l+0xa50>
 802184a:	f1ba 0f00 	cmp.w	sl, #0
 802184e:	d158      	bne.n	8021902 <_strtod_l+0xa12>
 8021850:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8021852:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8021856:	2b00      	cmp	r3, #0
 8021858:	d15a      	bne.n	8021910 <_strtod_l+0xa20>
 802185a:	4b64      	ldr	r3, [pc, #400]	@ (80219ec <_strtod_l+0xafc>)
 802185c:	2200      	movs	r2, #0
 802185e:	4630      	mov	r0, r6
 8021860:	4639      	mov	r1, r7
 8021862:	f7df f9ab 	bl	8000bbc <__aeabi_dcmplt>
 8021866:	2800      	cmp	r0, #0
 8021868:	d159      	bne.n	802191e <_strtod_l+0xa2e>
 802186a:	4630      	mov	r0, r6
 802186c:	4639      	mov	r1, r7
 802186e:	4b60      	ldr	r3, [pc, #384]	@ (80219f0 <_strtod_l+0xb00>)
 8021870:	2200      	movs	r2, #0
 8021872:	f7de ff31 	bl	80006d8 <__aeabi_dmul>
 8021876:	4606      	mov	r6, r0
 8021878:	460f      	mov	r7, r1
 802187a:	f107 4300 	add.w	r3, r7, #2147483648	@ 0x80000000
 802187e:	9606      	str	r6, [sp, #24]
 8021880:	9307      	str	r3, [sp, #28]
 8021882:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 8021886:	4d57      	ldr	r5, [pc, #348]	@ (80219e4 <_strtod_l+0xaf4>)
 8021888:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 802188c:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 802188e:	401d      	ands	r5, r3
 8021890:	4b58      	ldr	r3, [pc, #352]	@ (80219f4 <_strtod_l+0xb04>)
 8021892:	429d      	cmp	r5, r3
 8021894:	f040 80b2 	bne.w	80219fc <_strtod_l+0xb0c>
 8021898:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 802189a:	f1a3 7b54 	sub.w	fp, r3, #55574528	@ 0x3500000
 802189e:	ec4b ab10 	vmov	d0, sl, fp
 80218a2:	f001 fc29 	bl	80230f8 <__ulp>
 80218a6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80218aa:	ec51 0b10 	vmov	r0, r1, d0
 80218ae:	f7de ff13 	bl	80006d8 <__aeabi_dmul>
 80218b2:	4652      	mov	r2, sl
 80218b4:	465b      	mov	r3, fp
 80218b6:	f7de fd59 	bl	800036c <__adddf3>
 80218ba:	460b      	mov	r3, r1
 80218bc:	4949      	ldr	r1, [pc, #292]	@ (80219e4 <_strtod_l+0xaf4>)
 80218be:	4a4e      	ldr	r2, [pc, #312]	@ (80219f8 <_strtod_l+0xb08>)
 80218c0:	4019      	ands	r1, r3
 80218c2:	4291      	cmp	r1, r2
 80218c4:	4682      	mov	sl, r0
 80218c6:	d942      	bls.n	802194e <_strtod_l+0xa5e>
 80218c8:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 80218ca:	4b47      	ldr	r3, [pc, #284]	@ (80219e8 <_strtod_l+0xaf8>)
 80218cc:	429a      	cmp	r2, r3
 80218ce:	d103      	bne.n	80218d8 <_strtod_l+0x9e8>
 80218d0:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 80218d2:	3301      	adds	r3, #1
 80218d4:	f43f ad2b 	beq.w	802132e <_strtod_l+0x43e>
 80218d8:	f8df b10c 	ldr.w	fp, [pc, #268]	@ 80219e8 <_strtod_l+0xaf8>
 80218dc:	f04f 3aff 	mov.w	sl, #4294967295
 80218e0:	991a      	ldr	r1, [sp, #104]	@ 0x68
 80218e2:	9805      	ldr	r0, [sp, #20]
 80218e4:	f001 f8d4 	bl	8022a90 <_Bfree>
 80218e8:	9805      	ldr	r0, [sp, #20]
 80218ea:	4649      	mov	r1, r9
 80218ec:	f001 f8d0 	bl	8022a90 <_Bfree>
 80218f0:	9805      	ldr	r0, [sp, #20]
 80218f2:	4641      	mov	r1, r8
 80218f4:	f001 f8cc 	bl	8022a90 <_Bfree>
 80218f8:	9805      	ldr	r0, [sp, #20]
 80218fa:	4621      	mov	r1, r4
 80218fc:	f001 f8c8 	bl	8022a90 <_Bfree>
 8021900:	e618      	b.n	8021534 <_strtod_l+0x644>
 8021902:	f1ba 0f01 	cmp.w	sl, #1
 8021906:	d103      	bne.n	8021910 <_strtod_l+0xa20>
 8021908:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 802190a:	2b00      	cmp	r3, #0
 802190c:	f43f ada5 	beq.w	802145a <_strtod_l+0x56a>
 8021910:	ed9f 7b2b 	vldr	d7, [pc, #172]	@ 80219c0 <_strtod_l+0xad0>
 8021914:	4f35      	ldr	r7, [pc, #212]	@ (80219ec <_strtod_l+0xafc>)
 8021916:	ed8d 7b06 	vstr	d7, [sp, #24]
 802191a:	2600      	movs	r6, #0
 802191c:	e7b1      	b.n	8021882 <_strtod_l+0x992>
 802191e:	4f34      	ldr	r7, [pc, #208]	@ (80219f0 <_strtod_l+0xb00>)
 8021920:	2600      	movs	r6, #0
 8021922:	e7aa      	b.n	802187a <_strtod_l+0x98a>
 8021924:	4b32      	ldr	r3, [pc, #200]	@ (80219f0 <_strtod_l+0xb00>)
 8021926:	4630      	mov	r0, r6
 8021928:	4639      	mov	r1, r7
 802192a:	2200      	movs	r2, #0
 802192c:	f7de fed4 	bl	80006d8 <__aeabi_dmul>
 8021930:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8021932:	4606      	mov	r6, r0
 8021934:	460f      	mov	r7, r1
 8021936:	2b00      	cmp	r3, #0
 8021938:	d09f      	beq.n	802187a <_strtod_l+0x98a>
 802193a:	e9cd 6706 	strd	r6, r7, [sp, #24]
 802193e:	e7a0      	b.n	8021882 <_strtod_l+0x992>
 8021940:	ed9f 7b21 	vldr	d7, [pc, #132]	@ 80219c8 <_strtod_l+0xad8>
 8021944:	ed8d 7b06 	vstr	d7, [sp, #24]
 8021948:	ec57 6b17 	vmov	r6, r7, d7
 802194c:	e799      	b.n	8021882 <_strtod_l+0x992>
 802194e:	f103 7b54 	add.w	fp, r3, #55574528	@ 0x3500000
 8021952:	9b08      	ldr	r3, [sp, #32]
 8021954:	f8cd b038 	str.w	fp, [sp, #56]	@ 0x38
 8021958:	2b00      	cmp	r3, #0
 802195a:	d1c1      	bne.n	80218e0 <_strtod_l+0x9f0>
 802195c:	f02b 4300 	bic.w	r3, fp, #2147483648	@ 0x80000000
 8021960:	0d1b      	lsrs	r3, r3, #20
 8021962:	051b      	lsls	r3, r3, #20
 8021964:	429d      	cmp	r5, r3
 8021966:	d1bb      	bne.n	80218e0 <_strtod_l+0x9f0>
 8021968:	4630      	mov	r0, r6
 802196a:	4639      	mov	r1, r7
 802196c:	f7df f9ec 	bl	8000d48 <__aeabi_d2lz>
 8021970:	f7de fe84 	bl	800067c <__aeabi_l2d>
 8021974:	4602      	mov	r2, r0
 8021976:	460b      	mov	r3, r1
 8021978:	4630      	mov	r0, r6
 802197a:	4639      	mov	r1, r7
 802197c:	f7de fcf4 	bl	8000368 <__aeabi_dsub>
 8021980:	460b      	mov	r3, r1
 8021982:	4602      	mov	r2, r0
 8021984:	e9cd 230c 	strd	r2, r3, [sp, #48]	@ 0x30
 8021988:	f3cb 0613 	ubfx	r6, fp, #0, #20
 802198c:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 802198e:	ea46 060a 	orr.w	r6, r6, sl
 8021992:	431e      	orrs	r6, r3
 8021994:	d06f      	beq.n	8021a76 <_strtod_l+0xb86>
 8021996:	a30e      	add	r3, pc, #56	@ (adr r3, 80219d0 <_strtod_l+0xae0>)
 8021998:	e9d3 2300 	ldrd	r2, r3, [r3]
 802199c:	f7df f90e 	bl	8000bbc <__aeabi_dcmplt>
 80219a0:	2800      	cmp	r0, #0
 80219a2:	f47f accf 	bne.w	8021344 <_strtod_l+0x454>
 80219a6:	a30c      	add	r3, pc, #48	@ (adr r3, 80219d8 <_strtod_l+0xae8>)
 80219a8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80219ac:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	@ 0x30
 80219b0:	f7df f922 	bl	8000bf8 <__aeabi_dcmpgt>
 80219b4:	2800      	cmp	r0, #0
 80219b6:	d093      	beq.n	80218e0 <_strtod_l+0x9f0>
 80219b8:	e4c4      	b.n	8021344 <_strtod_l+0x454>
 80219ba:	bf00      	nop
 80219bc:	f3af 8000 	nop.w
 80219c0:	00000000 	.word	0x00000000
 80219c4:	bff00000 	.word	0xbff00000
 80219c8:	00000000 	.word	0x00000000
 80219cc:	3ff00000 	.word	0x3ff00000
 80219d0:	94a03595 	.word	0x94a03595
 80219d4:	3fdfffff 	.word	0x3fdfffff
 80219d8:	35afe535 	.word	0x35afe535
 80219dc:	3fe00000 	.word	0x3fe00000
 80219e0:	000fffff 	.word	0x000fffff
 80219e4:	7ff00000 	.word	0x7ff00000
 80219e8:	7fefffff 	.word	0x7fefffff
 80219ec:	3ff00000 	.word	0x3ff00000
 80219f0:	3fe00000 	.word	0x3fe00000
 80219f4:	7fe00000 	.word	0x7fe00000
 80219f8:	7c9fffff 	.word	0x7c9fffff
 80219fc:	9b08      	ldr	r3, [sp, #32]
 80219fe:	b323      	cbz	r3, 8021a4a <_strtod_l+0xb5a>
 8021a00:	f1b5 6fd4 	cmp.w	r5, #111149056	@ 0x6a00000
 8021a04:	d821      	bhi.n	8021a4a <_strtod_l+0xb5a>
 8021a06:	a328      	add	r3, pc, #160	@ (adr r3, 8021aa8 <_strtod_l+0xbb8>)
 8021a08:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021a0c:	4630      	mov	r0, r6
 8021a0e:	4639      	mov	r1, r7
 8021a10:	f7df f8de 	bl	8000bd0 <__aeabi_dcmple>
 8021a14:	b1a0      	cbz	r0, 8021a40 <_strtod_l+0xb50>
 8021a16:	4639      	mov	r1, r7
 8021a18:	4630      	mov	r0, r6
 8021a1a:	f7df f90d 	bl	8000c38 <__aeabi_d2uiz>
 8021a1e:	2801      	cmp	r0, #1
 8021a20:	bf38      	it	cc
 8021a22:	2001      	movcc	r0, #1
 8021a24:	f7de fdde 	bl	80005e4 <__aeabi_ui2d>
 8021a28:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8021a2a:	4606      	mov	r6, r0
 8021a2c:	460f      	mov	r7, r1
 8021a2e:	b9fb      	cbnz	r3, 8021a70 <_strtod_l+0xb80>
 8021a30:	f101 4300 	add.w	r3, r1, #2147483648	@ 0x80000000
 8021a34:	9014      	str	r0, [sp, #80]	@ 0x50
 8021a36:	9315      	str	r3, [sp, #84]	@ 0x54
 8021a38:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	@ 0x50
 8021a3c:	e9cd 2310 	strd	r2, r3, [sp, #64]	@ 0x40
 8021a40:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 8021a42:	f103 63d6 	add.w	r3, r3, #112197632	@ 0x6b00000
 8021a46:	1b5b      	subs	r3, r3, r5
 8021a48:	9311      	str	r3, [sp, #68]	@ 0x44
 8021a4a:	ed9d 0b0c 	vldr	d0, [sp, #48]	@ 0x30
 8021a4e:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	@ 0x40
 8021a52:	f001 fb51 	bl	80230f8 <__ulp>
 8021a56:	4650      	mov	r0, sl
 8021a58:	ec53 2b10 	vmov	r2, r3, d0
 8021a5c:	4659      	mov	r1, fp
 8021a5e:	f7de fe3b 	bl	80006d8 <__aeabi_dmul>
 8021a62:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	@ 0x30
 8021a66:	f7de fc81 	bl	800036c <__adddf3>
 8021a6a:	4682      	mov	sl, r0
 8021a6c:	468b      	mov	fp, r1
 8021a6e:	e770      	b.n	8021952 <_strtod_l+0xa62>
 8021a70:	e9cd 6714 	strd	r6, r7, [sp, #80]	@ 0x50
 8021a74:	e7e0      	b.n	8021a38 <_strtod_l+0xb48>
 8021a76:	a30e      	add	r3, pc, #56	@ (adr r3, 8021ab0 <_strtod_l+0xbc0>)
 8021a78:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021a7c:	f7df f89e 	bl	8000bbc <__aeabi_dcmplt>
 8021a80:	e798      	b.n	80219b4 <_strtod_l+0xac4>
 8021a82:	2300      	movs	r3, #0
 8021a84:	930b      	str	r3, [sp, #44]	@ 0x2c
 8021a86:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 8021a88:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8021a8a:	6013      	str	r3, [r2, #0]
 8021a8c:	f7ff ba6d 	b.w	8020f6a <_strtod_l+0x7a>
 8021a90:	2a65      	cmp	r2, #101	@ 0x65
 8021a92:	f43f ab66 	beq.w	8021162 <_strtod_l+0x272>
 8021a96:	2a45      	cmp	r2, #69	@ 0x45
 8021a98:	f43f ab63 	beq.w	8021162 <_strtod_l+0x272>
 8021a9c:	2301      	movs	r3, #1
 8021a9e:	f7ff bb9e 	b.w	80211de <_strtod_l+0x2ee>
 8021aa2:	bf00      	nop
 8021aa4:	f3af 8000 	nop.w
 8021aa8:	ffc00000 	.word	0xffc00000
 8021aac:	41dfffff 	.word	0x41dfffff
 8021ab0:	94a03595 	.word	0x94a03595
 8021ab4:	3fcfffff 	.word	0x3fcfffff

08021ab8 <strtof>:
 8021ab8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021abc:	f8df 80bc 	ldr.w	r8, [pc, #188]	@ 8021b7c <strtof+0xc4>
 8021ac0:	4b29      	ldr	r3, [pc, #164]	@ (8021b68 <strtof+0xb0>)
 8021ac2:	460a      	mov	r2, r1
 8021ac4:	ed2d 8b02 	vpush	{d8}
 8021ac8:	4601      	mov	r1, r0
 8021aca:	f8d8 0000 	ldr.w	r0, [r8]
 8021ace:	f7ff fa0f 	bl	8020ef0 <_strtod_l>
 8021ad2:	ec55 4b10 	vmov	r4, r5, d0
 8021ad6:	4622      	mov	r2, r4
 8021ad8:	462b      	mov	r3, r5
 8021ada:	4620      	mov	r0, r4
 8021adc:	4629      	mov	r1, r5
 8021ade:	f7df f895 	bl	8000c0c <__aeabi_dcmpun>
 8021ae2:	b190      	cbz	r0, 8021b0a <strtof+0x52>
 8021ae4:	2d00      	cmp	r5, #0
 8021ae6:	4821      	ldr	r0, [pc, #132]	@ (8021b6c <strtof+0xb4>)
 8021ae8:	da09      	bge.n	8021afe <strtof+0x46>
 8021aea:	f000 fbf5 	bl	80222d8 <nanf>
 8021aee:	eeb1 8a40 	vneg.f32	s16, s0
 8021af2:	eeb0 0a48 	vmov.f32	s0, s16
 8021af6:	ecbd 8b02 	vpop	{d8}
 8021afa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021afe:	ecbd 8b02 	vpop	{d8}
 8021b02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8021b06:	f000 bbe7 	b.w	80222d8 <nanf>
 8021b0a:	4620      	mov	r0, r4
 8021b0c:	4629      	mov	r1, r5
 8021b0e:	f7df f8b3 	bl	8000c78 <__aeabi_d2f>
 8021b12:	ee08 0a10 	vmov	s16, r0
 8021b16:	eddf 7a16 	vldr	s15, [pc, #88]	@ 8021b70 <strtof+0xb8>
 8021b1a:	eeb0 7ac8 	vabs.f32	s14, s16
 8021b1e:	eeb4 7a67 	vcmp.f32	s14, s15
 8021b22:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8021b26:	dd11      	ble.n	8021b4c <strtof+0x94>
 8021b28:	f025 4700 	bic.w	r7, r5, #2147483648	@ 0x80000000
 8021b2c:	4b11      	ldr	r3, [pc, #68]	@ (8021b74 <strtof+0xbc>)
 8021b2e:	f04f 32ff 	mov.w	r2, #4294967295
 8021b32:	4620      	mov	r0, r4
 8021b34:	4639      	mov	r1, r7
 8021b36:	f7df f869 	bl	8000c0c <__aeabi_dcmpun>
 8021b3a:	b980      	cbnz	r0, 8021b5e <strtof+0xa6>
 8021b3c:	4b0d      	ldr	r3, [pc, #52]	@ (8021b74 <strtof+0xbc>)
 8021b3e:	f04f 32ff 	mov.w	r2, #4294967295
 8021b42:	4620      	mov	r0, r4
 8021b44:	4639      	mov	r1, r7
 8021b46:	f7df f843 	bl	8000bd0 <__aeabi_dcmple>
 8021b4a:	b940      	cbnz	r0, 8021b5e <strtof+0xa6>
 8021b4c:	ee18 3a10 	vmov	r3, s16
 8021b50:	f013 4fff 	tst.w	r3, #2139095040	@ 0x7f800000
 8021b54:	d1cd      	bne.n	8021af2 <strtof+0x3a>
 8021b56:	4b08      	ldr	r3, [pc, #32]	@ (8021b78 <strtof+0xc0>)
 8021b58:	402b      	ands	r3, r5
 8021b5a:	2b00      	cmp	r3, #0
 8021b5c:	d0c9      	beq.n	8021af2 <strtof+0x3a>
 8021b5e:	f8d8 3000 	ldr.w	r3, [r8]
 8021b62:	2222      	movs	r2, #34	@ 0x22
 8021b64:	601a      	str	r2, [r3, #0]
 8021b66:	e7c4      	b.n	8021af2 <strtof+0x3a>
 8021b68:	200001b0 	.word	0x200001b0
 8021b6c:	0803964e 	.word	0x0803964e
 8021b70:	7f7fffff 	.word	0x7f7fffff
 8021b74:	7fefffff 	.word	0x7fefffff
 8021b78:	7ff00000 	.word	0x7ff00000
 8021b7c:	2000031c 	.word	0x2000031c

08021b80 <_strtoul_l.constprop.0>:
 8021b80:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8021b84:	4e34      	ldr	r6, [pc, #208]	@ (8021c58 <_strtoul_l.constprop.0+0xd8>)
 8021b86:	4686      	mov	lr, r0
 8021b88:	460d      	mov	r5, r1
 8021b8a:	4628      	mov	r0, r5
 8021b8c:	f815 4b01 	ldrb.w	r4, [r5], #1
 8021b90:	5d37      	ldrb	r7, [r6, r4]
 8021b92:	f017 0708 	ands.w	r7, r7, #8
 8021b96:	d1f8      	bne.n	8021b8a <_strtoul_l.constprop.0+0xa>
 8021b98:	2c2d      	cmp	r4, #45	@ 0x2d
 8021b9a:	d12f      	bne.n	8021bfc <_strtoul_l.constprop.0+0x7c>
 8021b9c:	782c      	ldrb	r4, [r5, #0]
 8021b9e:	2701      	movs	r7, #1
 8021ba0:	1c85      	adds	r5, r0, #2
 8021ba2:	f033 0010 	bics.w	r0, r3, #16
 8021ba6:	d109      	bne.n	8021bbc <_strtoul_l.constprop.0+0x3c>
 8021ba8:	2c30      	cmp	r4, #48	@ 0x30
 8021baa:	d12c      	bne.n	8021c06 <_strtoul_l.constprop.0+0x86>
 8021bac:	7828      	ldrb	r0, [r5, #0]
 8021bae:	f000 00df 	and.w	r0, r0, #223	@ 0xdf
 8021bb2:	2858      	cmp	r0, #88	@ 0x58
 8021bb4:	d127      	bne.n	8021c06 <_strtoul_l.constprop.0+0x86>
 8021bb6:	786c      	ldrb	r4, [r5, #1]
 8021bb8:	2310      	movs	r3, #16
 8021bba:	3502      	adds	r5, #2
 8021bbc:	f04f 38ff 	mov.w	r8, #4294967295
 8021bc0:	2600      	movs	r6, #0
 8021bc2:	fbb8 f8f3 	udiv	r8, r8, r3
 8021bc6:	fb03 f908 	mul.w	r9, r3, r8
 8021bca:	ea6f 0909 	mvn.w	r9, r9
 8021bce:	4630      	mov	r0, r6
 8021bd0:	f1a4 0c30 	sub.w	ip, r4, #48	@ 0x30
 8021bd4:	f1bc 0f09 	cmp.w	ip, #9
 8021bd8:	d81c      	bhi.n	8021c14 <_strtoul_l.constprop.0+0x94>
 8021bda:	4664      	mov	r4, ip
 8021bdc:	42a3      	cmp	r3, r4
 8021bde:	dd2a      	ble.n	8021c36 <_strtoul_l.constprop.0+0xb6>
 8021be0:	f1b6 3fff 	cmp.w	r6, #4294967295
 8021be4:	d007      	beq.n	8021bf6 <_strtoul_l.constprop.0+0x76>
 8021be6:	4580      	cmp	r8, r0
 8021be8:	d322      	bcc.n	8021c30 <_strtoul_l.constprop.0+0xb0>
 8021bea:	d101      	bne.n	8021bf0 <_strtoul_l.constprop.0+0x70>
 8021bec:	45a1      	cmp	r9, r4
 8021bee:	db1f      	blt.n	8021c30 <_strtoul_l.constprop.0+0xb0>
 8021bf0:	fb00 4003 	mla	r0, r0, r3, r4
 8021bf4:	2601      	movs	r6, #1
 8021bf6:	f815 4b01 	ldrb.w	r4, [r5], #1
 8021bfa:	e7e9      	b.n	8021bd0 <_strtoul_l.constprop.0+0x50>
 8021bfc:	2c2b      	cmp	r4, #43	@ 0x2b
 8021bfe:	bf04      	itt	eq
 8021c00:	782c      	ldrbeq	r4, [r5, #0]
 8021c02:	1c85      	addeq	r5, r0, #2
 8021c04:	e7cd      	b.n	8021ba2 <_strtoul_l.constprop.0+0x22>
 8021c06:	2b00      	cmp	r3, #0
 8021c08:	d1d8      	bne.n	8021bbc <_strtoul_l.constprop.0+0x3c>
 8021c0a:	2c30      	cmp	r4, #48	@ 0x30
 8021c0c:	bf0c      	ite	eq
 8021c0e:	2308      	moveq	r3, #8
 8021c10:	230a      	movne	r3, #10
 8021c12:	e7d3      	b.n	8021bbc <_strtoul_l.constprop.0+0x3c>
 8021c14:	f1a4 0c41 	sub.w	ip, r4, #65	@ 0x41
 8021c18:	f1bc 0f19 	cmp.w	ip, #25
 8021c1c:	d801      	bhi.n	8021c22 <_strtoul_l.constprop.0+0xa2>
 8021c1e:	3c37      	subs	r4, #55	@ 0x37
 8021c20:	e7dc      	b.n	8021bdc <_strtoul_l.constprop.0+0x5c>
 8021c22:	f1a4 0c61 	sub.w	ip, r4, #97	@ 0x61
 8021c26:	f1bc 0f19 	cmp.w	ip, #25
 8021c2a:	d804      	bhi.n	8021c36 <_strtoul_l.constprop.0+0xb6>
 8021c2c:	3c57      	subs	r4, #87	@ 0x57
 8021c2e:	e7d5      	b.n	8021bdc <_strtoul_l.constprop.0+0x5c>
 8021c30:	f04f 36ff 	mov.w	r6, #4294967295
 8021c34:	e7df      	b.n	8021bf6 <_strtoul_l.constprop.0+0x76>
 8021c36:	1c73      	adds	r3, r6, #1
 8021c38:	d106      	bne.n	8021c48 <_strtoul_l.constprop.0+0xc8>
 8021c3a:	2322      	movs	r3, #34	@ 0x22
 8021c3c:	f8ce 3000 	str.w	r3, [lr]
 8021c40:	4630      	mov	r0, r6
 8021c42:	b932      	cbnz	r2, 8021c52 <_strtoul_l.constprop.0+0xd2>
 8021c44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8021c48:	b107      	cbz	r7, 8021c4c <_strtoul_l.constprop.0+0xcc>
 8021c4a:	4240      	negs	r0, r0
 8021c4c:	2a00      	cmp	r2, #0
 8021c4e:	d0f9      	beq.n	8021c44 <_strtoul_l.constprop.0+0xc4>
 8021c50:	b106      	cbz	r6, 8021c54 <_strtoul_l.constprop.0+0xd4>
 8021c52:	1e69      	subs	r1, r5, #1
 8021c54:	6011      	str	r1, [r2, #0]
 8021c56:	e7f5      	b.n	8021c44 <_strtoul_l.constprop.0+0xc4>
 8021c58:	080392f9 	.word	0x080392f9

08021c5c <strtoul>:
 8021c5c:	4613      	mov	r3, r2
 8021c5e:	460a      	mov	r2, r1
 8021c60:	4601      	mov	r1, r0
 8021c62:	4802      	ldr	r0, [pc, #8]	@ (8021c6c <strtoul+0x10>)
 8021c64:	6800      	ldr	r0, [r0, #0]
 8021c66:	f7ff bf8b 	b.w	8021b80 <_strtoul_l.constprop.0>
 8021c6a:	bf00      	nop
 8021c6c:	2000031c 	.word	0x2000031c

08021c70 <std>:
 8021c70:	2300      	movs	r3, #0
 8021c72:	b510      	push	{r4, lr}
 8021c74:	4604      	mov	r4, r0
 8021c76:	e9c0 3300 	strd	r3, r3, [r0]
 8021c7a:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8021c7e:	6083      	str	r3, [r0, #8]
 8021c80:	8181      	strh	r1, [r0, #12]
 8021c82:	6643      	str	r3, [r0, #100]	@ 0x64
 8021c84:	81c2      	strh	r2, [r0, #14]
 8021c86:	6183      	str	r3, [r0, #24]
 8021c88:	4619      	mov	r1, r3
 8021c8a:	2208      	movs	r2, #8
 8021c8c:	305c      	adds	r0, #92	@ 0x5c
 8021c8e:	f000 fa39 	bl	8022104 <memset>
 8021c92:	4b0d      	ldr	r3, [pc, #52]	@ (8021cc8 <std+0x58>)
 8021c94:	6263      	str	r3, [r4, #36]	@ 0x24
 8021c96:	4b0d      	ldr	r3, [pc, #52]	@ (8021ccc <std+0x5c>)
 8021c98:	62a3      	str	r3, [r4, #40]	@ 0x28
 8021c9a:	4b0d      	ldr	r3, [pc, #52]	@ (8021cd0 <std+0x60>)
 8021c9c:	62e3      	str	r3, [r4, #44]	@ 0x2c
 8021c9e:	4b0d      	ldr	r3, [pc, #52]	@ (8021cd4 <std+0x64>)
 8021ca0:	6323      	str	r3, [r4, #48]	@ 0x30
 8021ca2:	4b0d      	ldr	r3, [pc, #52]	@ (8021cd8 <std+0x68>)
 8021ca4:	6224      	str	r4, [r4, #32]
 8021ca6:	429c      	cmp	r4, r3
 8021ca8:	d006      	beq.n	8021cb8 <std+0x48>
 8021caa:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 8021cae:	4294      	cmp	r4, r2
 8021cb0:	d002      	beq.n	8021cb8 <std+0x48>
 8021cb2:	33d0      	adds	r3, #208	@ 0xd0
 8021cb4:	429c      	cmp	r4, r3
 8021cb6:	d105      	bne.n	8021cc4 <std+0x54>
 8021cb8:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 8021cbc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8021cc0:	f000 bae6 	b.w	8022290 <__retarget_lock_init_recursive>
 8021cc4:	bd10      	pop	{r4, pc}
 8021cc6:	bf00      	nop
 8021cc8:	08021eb1 	.word	0x08021eb1
 8021ccc:	08021ed3 	.word	0x08021ed3
 8021cd0:	08021f0b 	.word	0x08021f0b
 8021cd4:	08021f2f 	.word	0x08021f2f
 8021cd8:	200121c8 	.word	0x200121c8

08021cdc <stdio_exit_handler>:
 8021cdc:	4a02      	ldr	r2, [pc, #8]	@ (8021ce8 <stdio_exit_handler+0xc>)
 8021cde:	4903      	ldr	r1, [pc, #12]	@ (8021cec <stdio_exit_handler+0x10>)
 8021ce0:	4803      	ldr	r0, [pc, #12]	@ (8021cf0 <stdio_exit_handler+0x14>)
 8021ce2:	f000 b869 	b.w	8021db8 <_fwalk_sglue>
 8021ce6:	bf00      	nop
 8021ce8:	200001a4 	.word	0x200001a4
 8021cec:	08023a61 	.word	0x08023a61
 8021cf0:	20000320 	.word	0x20000320

08021cf4 <cleanup_stdio>:
 8021cf4:	6841      	ldr	r1, [r0, #4]
 8021cf6:	4b0c      	ldr	r3, [pc, #48]	@ (8021d28 <cleanup_stdio+0x34>)
 8021cf8:	4299      	cmp	r1, r3
 8021cfa:	b510      	push	{r4, lr}
 8021cfc:	4604      	mov	r4, r0
 8021cfe:	d001      	beq.n	8021d04 <cleanup_stdio+0x10>
 8021d00:	f001 feae 	bl	8023a60 <_fflush_r>
 8021d04:	68a1      	ldr	r1, [r4, #8]
 8021d06:	4b09      	ldr	r3, [pc, #36]	@ (8021d2c <cleanup_stdio+0x38>)
 8021d08:	4299      	cmp	r1, r3
 8021d0a:	d002      	beq.n	8021d12 <cleanup_stdio+0x1e>
 8021d0c:	4620      	mov	r0, r4
 8021d0e:	f001 fea7 	bl	8023a60 <_fflush_r>
 8021d12:	68e1      	ldr	r1, [r4, #12]
 8021d14:	4b06      	ldr	r3, [pc, #24]	@ (8021d30 <cleanup_stdio+0x3c>)
 8021d16:	4299      	cmp	r1, r3
 8021d18:	d004      	beq.n	8021d24 <cleanup_stdio+0x30>
 8021d1a:	4620      	mov	r0, r4
 8021d1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8021d20:	f001 be9e 	b.w	8023a60 <_fflush_r>
 8021d24:	bd10      	pop	{r4, pc}
 8021d26:	bf00      	nop
 8021d28:	200121c8 	.word	0x200121c8
 8021d2c:	20012230 	.word	0x20012230
 8021d30:	20012298 	.word	0x20012298

08021d34 <global_stdio_init.part.0>:
 8021d34:	b510      	push	{r4, lr}
 8021d36:	4b0b      	ldr	r3, [pc, #44]	@ (8021d64 <global_stdio_init.part.0+0x30>)
 8021d38:	4c0b      	ldr	r4, [pc, #44]	@ (8021d68 <global_stdio_init.part.0+0x34>)
 8021d3a:	4a0c      	ldr	r2, [pc, #48]	@ (8021d6c <global_stdio_init.part.0+0x38>)
 8021d3c:	601a      	str	r2, [r3, #0]
 8021d3e:	4620      	mov	r0, r4
 8021d40:	2200      	movs	r2, #0
 8021d42:	2104      	movs	r1, #4
 8021d44:	f7ff ff94 	bl	8021c70 <std>
 8021d48:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8021d4c:	2201      	movs	r2, #1
 8021d4e:	2109      	movs	r1, #9
 8021d50:	f7ff ff8e 	bl	8021c70 <std>
 8021d54:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8021d58:	2202      	movs	r2, #2
 8021d5a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8021d5e:	2112      	movs	r1, #18
 8021d60:	f7ff bf86 	b.w	8021c70 <std>
 8021d64:	20012300 	.word	0x20012300
 8021d68:	200121c8 	.word	0x200121c8
 8021d6c:	08021cdd 	.word	0x08021cdd

08021d70 <__sfp_lock_acquire>:
 8021d70:	4801      	ldr	r0, [pc, #4]	@ (8021d78 <__sfp_lock_acquire+0x8>)
 8021d72:	f000 ba8e 	b.w	8022292 <__retarget_lock_acquire_recursive>
 8021d76:	bf00      	nop
 8021d78:	20012309 	.word	0x20012309

08021d7c <__sfp_lock_release>:
 8021d7c:	4801      	ldr	r0, [pc, #4]	@ (8021d84 <__sfp_lock_release+0x8>)
 8021d7e:	f000 ba89 	b.w	8022294 <__retarget_lock_release_recursive>
 8021d82:	bf00      	nop
 8021d84:	20012309 	.word	0x20012309

08021d88 <__sinit>:
 8021d88:	b510      	push	{r4, lr}
 8021d8a:	4604      	mov	r4, r0
 8021d8c:	f7ff fff0 	bl	8021d70 <__sfp_lock_acquire>
 8021d90:	6a23      	ldr	r3, [r4, #32]
 8021d92:	b11b      	cbz	r3, 8021d9c <__sinit+0x14>
 8021d94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8021d98:	f7ff bff0 	b.w	8021d7c <__sfp_lock_release>
 8021d9c:	4b04      	ldr	r3, [pc, #16]	@ (8021db0 <__sinit+0x28>)
 8021d9e:	6223      	str	r3, [r4, #32]
 8021da0:	4b04      	ldr	r3, [pc, #16]	@ (8021db4 <__sinit+0x2c>)
 8021da2:	681b      	ldr	r3, [r3, #0]
 8021da4:	2b00      	cmp	r3, #0
 8021da6:	d1f5      	bne.n	8021d94 <__sinit+0xc>
 8021da8:	f7ff ffc4 	bl	8021d34 <global_stdio_init.part.0>
 8021dac:	e7f2      	b.n	8021d94 <__sinit+0xc>
 8021dae:	bf00      	nop
 8021db0:	08021cf5 	.word	0x08021cf5
 8021db4:	20012300 	.word	0x20012300

08021db8 <_fwalk_sglue>:
 8021db8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8021dbc:	4607      	mov	r7, r0
 8021dbe:	4688      	mov	r8, r1
 8021dc0:	4614      	mov	r4, r2
 8021dc2:	2600      	movs	r6, #0
 8021dc4:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 8021dc8:	f1b9 0901 	subs.w	r9, r9, #1
 8021dcc:	d505      	bpl.n	8021dda <_fwalk_sglue+0x22>
 8021dce:	6824      	ldr	r4, [r4, #0]
 8021dd0:	2c00      	cmp	r4, #0
 8021dd2:	d1f7      	bne.n	8021dc4 <_fwalk_sglue+0xc>
 8021dd4:	4630      	mov	r0, r6
 8021dd6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8021dda:	89ab      	ldrh	r3, [r5, #12]
 8021ddc:	2b01      	cmp	r3, #1
 8021dde:	d907      	bls.n	8021df0 <_fwalk_sglue+0x38>
 8021de0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8021de4:	3301      	adds	r3, #1
 8021de6:	d003      	beq.n	8021df0 <_fwalk_sglue+0x38>
 8021de8:	4629      	mov	r1, r5
 8021dea:	4638      	mov	r0, r7
 8021dec:	47c0      	blx	r8
 8021dee:	4306      	orrs	r6, r0
 8021df0:	3568      	adds	r5, #104	@ 0x68
 8021df2:	e7e9      	b.n	8021dc8 <_fwalk_sglue+0x10>

08021df4 <_puts_r>:
 8021df4:	6a03      	ldr	r3, [r0, #32]
 8021df6:	b570      	push	{r4, r5, r6, lr}
 8021df8:	6884      	ldr	r4, [r0, #8]
 8021dfa:	4605      	mov	r5, r0
 8021dfc:	460e      	mov	r6, r1
 8021dfe:	b90b      	cbnz	r3, 8021e04 <_puts_r+0x10>
 8021e00:	f7ff ffc2 	bl	8021d88 <__sinit>
 8021e04:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8021e06:	07db      	lsls	r3, r3, #31
 8021e08:	d405      	bmi.n	8021e16 <_puts_r+0x22>
 8021e0a:	89a3      	ldrh	r3, [r4, #12]
 8021e0c:	0598      	lsls	r0, r3, #22
 8021e0e:	d402      	bmi.n	8021e16 <_puts_r+0x22>
 8021e10:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8021e12:	f000 fa3e 	bl	8022292 <__retarget_lock_acquire_recursive>
 8021e16:	89a3      	ldrh	r3, [r4, #12]
 8021e18:	0719      	lsls	r1, r3, #28
 8021e1a:	d502      	bpl.n	8021e22 <_puts_r+0x2e>
 8021e1c:	6923      	ldr	r3, [r4, #16]
 8021e1e:	2b00      	cmp	r3, #0
 8021e20:	d135      	bne.n	8021e8e <_puts_r+0x9a>
 8021e22:	4621      	mov	r1, r4
 8021e24:	4628      	mov	r0, r5
 8021e26:	f000 f8fd 	bl	8022024 <__swsetup_r>
 8021e2a:	b380      	cbz	r0, 8021e8e <_puts_r+0x9a>
 8021e2c:	f04f 35ff 	mov.w	r5, #4294967295
 8021e30:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8021e32:	07da      	lsls	r2, r3, #31
 8021e34:	d405      	bmi.n	8021e42 <_puts_r+0x4e>
 8021e36:	89a3      	ldrh	r3, [r4, #12]
 8021e38:	059b      	lsls	r3, r3, #22
 8021e3a:	d402      	bmi.n	8021e42 <_puts_r+0x4e>
 8021e3c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8021e3e:	f000 fa29 	bl	8022294 <__retarget_lock_release_recursive>
 8021e42:	4628      	mov	r0, r5
 8021e44:	bd70      	pop	{r4, r5, r6, pc}
 8021e46:	2b00      	cmp	r3, #0
 8021e48:	da04      	bge.n	8021e54 <_puts_r+0x60>
 8021e4a:	69a2      	ldr	r2, [r4, #24]
 8021e4c:	429a      	cmp	r2, r3
 8021e4e:	dc17      	bgt.n	8021e80 <_puts_r+0x8c>
 8021e50:	290a      	cmp	r1, #10
 8021e52:	d015      	beq.n	8021e80 <_puts_r+0x8c>
 8021e54:	6823      	ldr	r3, [r4, #0]
 8021e56:	1c5a      	adds	r2, r3, #1
 8021e58:	6022      	str	r2, [r4, #0]
 8021e5a:	7019      	strb	r1, [r3, #0]
 8021e5c:	68a3      	ldr	r3, [r4, #8]
 8021e5e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8021e62:	3b01      	subs	r3, #1
 8021e64:	60a3      	str	r3, [r4, #8]
 8021e66:	2900      	cmp	r1, #0
 8021e68:	d1ed      	bne.n	8021e46 <_puts_r+0x52>
 8021e6a:	2b00      	cmp	r3, #0
 8021e6c:	da11      	bge.n	8021e92 <_puts_r+0x9e>
 8021e6e:	4622      	mov	r2, r4
 8021e70:	210a      	movs	r1, #10
 8021e72:	4628      	mov	r0, r5
 8021e74:	f000 f898 	bl	8021fa8 <__swbuf_r>
 8021e78:	3001      	adds	r0, #1
 8021e7a:	d0d7      	beq.n	8021e2c <_puts_r+0x38>
 8021e7c:	250a      	movs	r5, #10
 8021e7e:	e7d7      	b.n	8021e30 <_puts_r+0x3c>
 8021e80:	4622      	mov	r2, r4
 8021e82:	4628      	mov	r0, r5
 8021e84:	f000 f890 	bl	8021fa8 <__swbuf_r>
 8021e88:	3001      	adds	r0, #1
 8021e8a:	d1e7      	bne.n	8021e5c <_puts_r+0x68>
 8021e8c:	e7ce      	b.n	8021e2c <_puts_r+0x38>
 8021e8e:	3e01      	subs	r6, #1
 8021e90:	e7e4      	b.n	8021e5c <_puts_r+0x68>
 8021e92:	6823      	ldr	r3, [r4, #0]
 8021e94:	1c5a      	adds	r2, r3, #1
 8021e96:	6022      	str	r2, [r4, #0]
 8021e98:	220a      	movs	r2, #10
 8021e9a:	701a      	strb	r2, [r3, #0]
 8021e9c:	e7ee      	b.n	8021e7c <_puts_r+0x88>
	...

08021ea0 <puts>:
 8021ea0:	4b02      	ldr	r3, [pc, #8]	@ (8021eac <puts+0xc>)
 8021ea2:	4601      	mov	r1, r0
 8021ea4:	6818      	ldr	r0, [r3, #0]
 8021ea6:	f7ff bfa5 	b.w	8021df4 <_puts_r>
 8021eaa:	bf00      	nop
 8021eac:	2000031c 	.word	0x2000031c

08021eb0 <__sread>:
 8021eb0:	b510      	push	{r4, lr}
 8021eb2:	460c      	mov	r4, r1
 8021eb4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021eb8:	f000 f98c 	bl	80221d4 <_read_r>
 8021ebc:	2800      	cmp	r0, #0
 8021ebe:	bfab      	itete	ge
 8021ec0:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8021ec2:	89a3      	ldrhlt	r3, [r4, #12]
 8021ec4:	181b      	addge	r3, r3, r0
 8021ec6:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 8021eca:	bfac      	ite	ge
 8021ecc:	6563      	strge	r3, [r4, #84]	@ 0x54
 8021ece:	81a3      	strhlt	r3, [r4, #12]
 8021ed0:	bd10      	pop	{r4, pc}

08021ed2 <__swrite>:
 8021ed2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021ed6:	461f      	mov	r7, r3
 8021ed8:	898b      	ldrh	r3, [r1, #12]
 8021eda:	05db      	lsls	r3, r3, #23
 8021edc:	4605      	mov	r5, r0
 8021ede:	460c      	mov	r4, r1
 8021ee0:	4616      	mov	r6, r2
 8021ee2:	d505      	bpl.n	8021ef0 <__swrite+0x1e>
 8021ee4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021ee8:	2302      	movs	r3, #2
 8021eea:	2200      	movs	r2, #0
 8021eec:	f000 f960 	bl	80221b0 <_lseek_r>
 8021ef0:	89a3      	ldrh	r3, [r4, #12]
 8021ef2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8021ef6:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 8021efa:	81a3      	strh	r3, [r4, #12]
 8021efc:	4632      	mov	r2, r6
 8021efe:	463b      	mov	r3, r7
 8021f00:	4628      	mov	r0, r5
 8021f02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8021f06:	f000 b987 	b.w	8022218 <_write_r>

08021f0a <__sseek>:
 8021f0a:	b510      	push	{r4, lr}
 8021f0c:	460c      	mov	r4, r1
 8021f0e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021f12:	f000 f94d 	bl	80221b0 <_lseek_r>
 8021f16:	1c43      	adds	r3, r0, #1
 8021f18:	89a3      	ldrh	r3, [r4, #12]
 8021f1a:	bf15      	itete	ne
 8021f1c:	6560      	strne	r0, [r4, #84]	@ 0x54
 8021f1e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8021f22:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8021f26:	81a3      	strheq	r3, [r4, #12]
 8021f28:	bf18      	it	ne
 8021f2a:	81a3      	strhne	r3, [r4, #12]
 8021f2c:	bd10      	pop	{r4, pc}

08021f2e <__sclose>:
 8021f2e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8021f32:	f000 b92d 	b.w	8022190 <_close_r>

08021f36 <_vsniprintf_r>:
 8021f36:	b530      	push	{r4, r5, lr}
 8021f38:	4614      	mov	r4, r2
 8021f3a:	2c00      	cmp	r4, #0
 8021f3c:	b09b      	sub	sp, #108	@ 0x6c
 8021f3e:	4605      	mov	r5, r0
 8021f40:	461a      	mov	r2, r3
 8021f42:	da05      	bge.n	8021f50 <_vsniprintf_r+0x1a>
 8021f44:	238b      	movs	r3, #139	@ 0x8b
 8021f46:	6003      	str	r3, [r0, #0]
 8021f48:	f04f 30ff 	mov.w	r0, #4294967295
 8021f4c:	b01b      	add	sp, #108	@ 0x6c
 8021f4e:	bd30      	pop	{r4, r5, pc}
 8021f50:	f44f 7302 	mov.w	r3, #520	@ 0x208
 8021f54:	f8ad 300c 	strh.w	r3, [sp, #12]
 8021f58:	bf14      	ite	ne
 8021f5a:	f104 33ff 	addne.w	r3, r4, #4294967295
 8021f5e:	4623      	moveq	r3, r4
 8021f60:	9302      	str	r3, [sp, #8]
 8021f62:	9305      	str	r3, [sp, #20]
 8021f64:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8021f68:	9100      	str	r1, [sp, #0]
 8021f6a:	9104      	str	r1, [sp, #16]
 8021f6c:	f8ad 300e 	strh.w	r3, [sp, #14]
 8021f70:	4669      	mov	r1, sp
 8021f72:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 8021f74:	f001 fa66 	bl	8023444 <_svfiprintf_r>
 8021f78:	1c43      	adds	r3, r0, #1
 8021f7a:	bfbc      	itt	lt
 8021f7c:	238b      	movlt	r3, #139	@ 0x8b
 8021f7e:	602b      	strlt	r3, [r5, #0]
 8021f80:	2c00      	cmp	r4, #0
 8021f82:	d0e3      	beq.n	8021f4c <_vsniprintf_r+0x16>
 8021f84:	9b00      	ldr	r3, [sp, #0]
 8021f86:	2200      	movs	r2, #0
 8021f88:	701a      	strb	r2, [r3, #0]
 8021f8a:	e7df      	b.n	8021f4c <_vsniprintf_r+0x16>

08021f8c <vsniprintf>:
 8021f8c:	b507      	push	{r0, r1, r2, lr}
 8021f8e:	9300      	str	r3, [sp, #0]
 8021f90:	4613      	mov	r3, r2
 8021f92:	460a      	mov	r2, r1
 8021f94:	4601      	mov	r1, r0
 8021f96:	4803      	ldr	r0, [pc, #12]	@ (8021fa4 <vsniprintf+0x18>)
 8021f98:	6800      	ldr	r0, [r0, #0]
 8021f9a:	f7ff ffcc 	bl	8021f36 <_vsniprintf_r>
 8021f9e:	b003      	add	sp, #12
 8021fa0:	f85d fb04 	ldr.w	pc, [sp], #4
 8021fa4:	2000031c 	.word	0x2000031c

08021fa8 <__swbuf_r>:
 8021fa8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021faa:	460e      	mov	r6, r1
 8021fac:	4614      	mov	r4, r2
 8021fae:	4605      	mov	r5, r0
 8021fb0:	b118      	cbz	r0, 8021fba <__swbuf_r+0x12>
 8021fb2:	6a03      	ldr	r3, [r0, #32]
 8021fb4:	b90b      	cbnz	r3, 8021fba <__swbuf_r+0x12>
 8021fb6:	f7ff fee7 	bl	8021d88 <__sinit>
 8021fba:	69a3      	ldr	r3, [r4, #24]
 8021fbc:	60a3      	str	r3, [r4, #8]
 8021fbe:	89a3      	ldrh	r3, [r4, #12]
 8021fc0:	071a      	lsls	r2, r3, #28
 8021fc2:	d501      	bpl.n	8021fc8 <__swbuf_r+0x20>
 8021fc4:	6923      	ldr	r3, [r4, #16]
 8021fc6:	b943      	cbnz	r3, 8021fda <__swbuf_r+0x32>
 8021fc8:	4621      	mov	r1, r4
 8021fca:	4628      	mov	r0, r5
 8021fcc:	f000 f82a 	bl	8022024 <__swsetup_r>
 8021fd0:	b118      	cbz	r0, 8021fda <__swbuf_r+0x32>
 8021fd2:	f04f 37ff 	mov.w	r7, #4294967295
 8021fd6:	4638      	mov	r0, r7
 8021fd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021fda:	6823      	ldr	r3, [r4, #0]
 8021fdc:	6922      	ldr	r2, [r4, #16]
 8021fde:	1a98      	subs	r0, r3, r2
 8021fe0:	6963      	ldr	r3, [r4, #20]
 8021fe2:	b2f6      	uxtb	r6, r6
 8021fe4:	4283      	cmp	r3, r0
 8021fe6:	4637      	mov	r7, r6
 8021fe8:	dc05      	bgt.n	8021ff6 <__swbuf_r+0x4e>
 8021fea:	4621      	mov	r1, r4
 8021fec:	4628      	mov	r0, r5
 8021fee:	f001 fd37 	bl	8023a60 <_fflush_r>
 8021ff2:	2800      	cmp	r0, #0
 8021ff4:	d1ed      	bne.n	8021fd2 <__swbuf_r+0x2a>
 8021ff6:	68a3      	ldr	r3, [r4, #8]
 8021ff8:	3b01      	subs	r3, #1
 8021ffa:	60a3      	str	r3, [r4, #8]
 8021ffc:	6823      	ldr	r3, [r4, #0]
 8021ffe:	1c5a      	adds	r2, r3, #1
 8022000:	6022      	str	r2, [r4, #0]
 8022002:	701e      	strb	r6, [r3, #0]
 8022004:	6962      	ldr	r2, [r4, #20]
 8022006:	1c43      	adds	r3, r0, #1
 8022008:	429a      	cmp	r2, r3
 802200a:	d004      	beq.n	8022016 <__swbuf_r+0x6e>
 802200c:	89a3      	ldrh	r3, [r4, #12]
 802200e:	07db      	lsls	r3, r3, #31
 8022010:	d5e1      	bpl.n	8021fd6 <__swbuf_r+0x2e>
 8022012:	2e0a      	cmp	r6, #10
 8022014:	d1df      	bne.n	8021fd6 <__swbuf_r+0x2e>
 8022016:	4621      	mov	r1, r4
 8022018:	4628      	mov	r0, r5
 802201a:	f001 fd21 	bl	8023a60 <_fflush_r>
 802201e:	2800      	cmp	r0, #0
 8022020:	d0d9      	beq.n	8021fd6 <__swbuf_r+0x2e>
 8022022:	e7d6      	b.n	8021fd2 <__swbuf_r+0x2a>

08022024 <__swsetup_r>:
 8022024:	b538      	push	{r3, r4, r5, lr}
 8022026:	4b29      	ldr	r3, [pc, #164]	@ (80220cc <__swsetup_r+0xa8>)
 8022028:	4605      	mov	r5, r0
 802202a:	6818      	ldr	r0, [r3, #0]
 802202c:	460c      	mov	r4, r1
 802202e:	b118      	cbz	r0, 8022038 <__swsetup_r+0x14>
 8022030:	6a03      	ldr	r3, [r0, #32]
 8022032:	b90b      	cbnz	r3, 8022038 <__swsetup_r+0x14>
 8022034:	f7ff fea8 	bl	8021d88 <__sinit>
 8022038:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802203c:	0719      	lsls	r1, r3, #28
 802203e:	d422      	bmi.n	8022086 <__swsetup_r+0x62>
 8022040:	06da      	lsls	r2, r3, #27
 8022042:	d407      	bmi.n	8022054 <__swsetup_r+0x30>
 8022044:	2209      	movs	r2, #9
 8022046:	602a      	str	r2, [r5, #0]
 8022048:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802204c:	81a3      	strh	r3, [r4, #12]
 802204e:	f04f 30ff 	mov.w	r0, #4294967295
 8022052:	e033      	b.n	80220bc <__swsetup_r+0x98>
 8022054:	0758      	lsls	r0, r3, #29
 8022056:	d512      	bpl.n	802207e <__swsetup_r+0x5a>
 8022058:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 802205a:	b141      	cbz	r1, 802206e <__swsetup_r+0x4a>
 802205c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8022060:	4299      	cmp	r1, r3
 8022062:	d002      	beq.n	802206a <__swsetup_r+0x46>
 8022064:	4628      	mov	r0, r5
 8022066:	f000 f93d 	bl	80222e4 <_free_r>
 802206a:	2300      	movs	r3, #0
 802206c:	6363      	str	r3, [r4, #52]	@ 0x34
 802206e:	89a3      	ldrh	r3, [r4, #12]
 8022070:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8022074:	81a3      	strh	r3, [r4, #12]
 8022076:	2300      	movs	r3, #0
 8022078:	6063      	str	r3, [r4, #4]
 802207a:	6923      	ldr	r3, [r4, #16]
 802207c:	6023      	str	r3, [r4, #0]
 802207e:	89a3      	ldrh	r3, [r4, #12]
 8022080:	f043 0308 	orr.w	r3, r3, #8
 8022084:	81a3      	strh	r3, [r4, #12]
 8022086:	6923      	ldr	r3, [r4, #16]
 8022088:	b94b      	cbnz	r3, 802209e <__swsetup_r+0x7a>
 802208a:	89a3      	ldrh	r3, [r4, #12]
 802208c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8022090:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8022094:	d003      	beq.n	802209e <__swsetup_r+0x7a>
 8022096:	4621      	mov	r1, r4
 8022098:	4628      	mov	r0, r5
 802209a:	f001 fd2f 	bl	8023afc <__smakebuf_r>
 802209e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80220a2:	f013 0201 	ands.w	r2, r3, #1
 80220a6:	d00a      	beq.n	80220be <__swsetup_r+0x9a>
 80220a8:	2200      	movs	r2, #0
 80220aa:	60a2      	str	r2, [r4, #8]
 80220ac:	6962      	ldr	r2, [r4, #20]
 80220ae:	4252      	negs	r2, r2
 80220b0:	61a2      	str	r2, [r4, #24]
 80220b2:	6922      	ldr	r2, [r4, #16]
 80220b4:	b942      	cbnz	r2, 80220c8 <__swsetup_r+0xa4>
 80220b6:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 80220ba:	d1c5      	bne.n	8022048 <__swsetup_r+0x24>
 80220bc:	bd38      	pop	{r3, r4, r5, pc}
 80220be:	0799      	lsls	r1, r3, #30
 80220c0:	bf58      	it	pl
 80220c2:	6962      	ldrpl	r2, [r4, #20]
 80220c4:	60a2      	str	r2, [r4, #8]
 80220c6:	e7f4      	b.n	80220b2 <__swsetup_r+0x8e>
 80220c8:	2000      	movs	r0, #0
 80220ca:	e7f7      	b.n	80220bc <__swsetup_r+0x98>
 80220cc:	2000031c 	.word	0x2000031c

080220d0 <memmove>:
 80220d0:	4288      	cmp	r0, r1
 80220d2:	b510      	push	{r4, lr}
 80220d4:	eb01 0402 	add.w	r4, r1, r2
 80220d8:	d902      	bls.n	80220e0 <memmove+0x10>
 80220da:	4284      	cmp	r4, r0
 80220dc:	4623      	mov	r3, r4
 80220de:	d807      	bhi.n	80220f0 <memmove+0x20>
 80220e0:	1e43      	subs	r3, r0, #1
 80220e2:	42a1      	cmp	r1, r4
 80220e4:	d008      	beq.n	80220f8 <memmove+0x28>
 80220e6:	f811 2b01 	ldrb.w	r2, [r1], #1
 80220ea:	f803 2f01 	strb.w	r2, [r3, #1]!
 80220ee:	e7f8      	b.n	80220e2 <memmove+0x12>
 80220f0:	4402      	add	r2, r0
 80220f2:	4601      	mov	r1, r0
 80220f4:	428a      	cmp	r2, r1
 80220f6:	d100      	bne.n	80220fa <memmove+0x2a>
 80220f8:	bd10      	pop	{r4, pc}
 80220fa:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80220fe:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8022102:	e7f7      	b.n	80220f4 <memmove+0x24>

08022104 <memset>:
 8022104:	4402      	add	r2, r0
 8022106:	4603      	mov	r3, r0
 8022108:	4293      	cmp	r3, r2
 802210a:	d100      	bne.n	802210e <memset+0xa>
 802210c:	4770      	bx	lr
 802210e:	f803 1b01 	strb.w	r1, [r3], #1
 8022112:	e7f9      	b.n	8022108 <memset+0x4>

08022114 <strncmp>:
 8022114:	b510      	push	{r4, lr}
 8022116:	b16a      	cbz	r2, 8022134 <strncmp+0x20>
 8022118:	3901      	subs	r1, #1
 802211a:	1884      	adds	r4, r0, r2
 802211c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8022120:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8022124:	429a      	cmp	r2, r3
 8022126:	d103      	bne.n	8022130 <strncmp+0x1c>
 8022128:	42a0      	cmp	r0, r4
 802212a:	d001      	beq.n	8022130 <strncmp+0x1c>
 802212c:	2a00      	cmp	r2, #0
 802212e:	d1f5      	bne.n	802211c <strncmp+0x8>
 8022130:	1ad0      	subs	r0, r2, r3
 8022132:	bd10      	pop	{r4, pc}
 8022134:	4610      	mov	r0, r2
 8022136:	e7fc      	b.n	8022132 <strncmp+0x1e>

08022138 <__strtok_r>:
 8022138:	b5f0      	push	{r4, r5, r6, r7, lr}
 802213a:	4604      	mov	r4, r0
 802213c:	b908      	cbnz	r0, 8022142 <__strtok_r+0xa>
 802213e:	6814      	ldr	r4, [r2, #0]
 8022140:	b144      	cbz	r4, 8022154 <__strtok_r+0x1c>
 8022142:	4620      	mov	r0, r4
 8022144:	f814 5b01 	ldrb.w	r5, [r4], #1
 8022148:	460f      	mov	r7, r1
 802214a:	f817 6b01 	ldrb.w	r6, [r7], #1
 802214e:	b91e      	cbnz	r6, 8022158 <__strtok_r+0x20>
 8022150:	b965      	cbnz	r5, 802216c <__strtok_r+0x34>
 8022152:	6015      	str	r5, [r2, #0]
 8022154:	2000      	movs	r0, #0
 8022156:	e005      	b.n	8022164 <__strtok_r+0x2c>
 8022158:	42b5      	cmp	r5, r6
 802215a:	d1f6      	bne.n	802214a <__strtok_r+0x12>
 802215c:	2b00      	cmp	r3, #0
 802215e:	d1f0      	bne.n	8022142 <__strtok_r+0xa>
 8022160:	6014      	str	r4, [r2, #0]
 8022162:	7003      	strb	r3, [r0, #0]
 8022164:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8022166:	461c      	mov	r4, r3
 8022168:	e00c      	b.n	8022184 <__strtok_r+0x4c>
 802216a:	b915      	cbnz	r5, 8022172 <__strtok_r+0x3a>
 802216c:	f814 3b01 	ldrb.w	r3, [r4], #1
 8022170:	460e      	mov	r6, r1
 8022172:	f816 5b01 	ldrb.w	r5, [r6], #1
 8022176:	42ab      	cmp	r3, r5
 8022178:	d1f7      	bne.n	802216a <__strtok_r+0x32>
 802217a:	2b00      	cmp	r3, #0
 802217c:	d0f3      	beq.n	8022166 <__strtok_r+0x2e>
 802217e:	2300      	movs	r3, #0
 8022180:	f804 3c01 	strb.w	r3, [r4, #-1]
 8022184:	6014      	str	r4, [r2, #0]
 8022186:	e7ed      	b.n	8022164 <__strtok_r+0x2c>

08022188 <strtok_r>:
 8022188:	2301      	movs	r3, #1
 802218a:	f7ff bfd5 	b.w	8022138 <__strtok_r>
	...

08022190 <_close_r>:
 8022190:	b538      	push	{r3, r4, r5, lr}
 8022192:	4d06      	ldr	r5, [pc, #24]	@ (80221ac <_close_r+0x1c>)
 8022194:	2300      	movs	r3, #0
 8022196:	4604      	mov	r4, r0
 8022198:	4608      	mov	r0, r1
 802219a:	602b      	str	r3, [r5, #0]
 802219c:	f7df fbc8 	bl	8001930 <_close>
 80221a0:	1c43      	adds	r3, r0, #1
 80221a2:	d102      	bne.n	80221aa <_close_r+0x1a>
 80221a4:	682b      	ldr	r3, [r5, #0]
 80221a6:	b103      	cbz	r3, 80221aa <_close_r+0x1a>
 80221a8:	6023      	str	r3, [r4, #0]
 80221aa:	bd38      	pop	{r3, r4, r5, pc}
 80221ac:	20012304 	.word	0x20012304

080221b0 <_lseek_r>:
 80221b0:	b538      	push	{r3, r4, r5, lr}
 80221b2:	4d07      	ldr	r5, [pc, #28]	@ (80221d0 <_lseek_r+0x20>)
 80221b4:	4604      	mov	r4, r0
 80221b6:	4608      	mov	r0, r1
 80221b8:	4611      	mov	r1, r2
 80221ba:	2200      	movs	r2, #0
 80221bc:	602a      	str	r2, [r5, #0]
 80221be:	461a      	mov	r2, r3
 80221c0:	f7df fbdd 	bl	800197e <_lseek>
 80221c4:	1c43      	adds	r3, r0, #1
 80221c6:	d102      	bne.n	80221ce <_lseek_r+0x1e>
 80221c8:	682b      	ldr	r3, [r5, #0]
 80221ca:	b103      	cbz	r3, 80221ce <_lseek_r+0x1e>
 80221cc:	6023      	str	r3, [r4, #0]
 80221ce:	bd38      	pop	{r3, r4, r5, pc}
 80221d0:	20012304 	.word	0x20012304

080221d4 <_read_r>:
 80221d4:	b538      	push	{r3, r4, r5, lr}
 80221d6:	4d07      	ldr	r5, [pc, #28]	@ (80221f4 <_read_r+0x20>)
 80221d8:	4604      	mov	r4, r0
 80221da:	4608      	mov	r0, r1
 80221dc:	4611      	mov	r1, r2
 80221de:	2200      	movs	r2, #0
 80221e0:	602a      	str	r2, [r5, #0]
 80221e2:	461a      	mov	r2, r3
 80221e4:	f7df fb6b 	bl	80018be <_read>
 80221e8:	1c43      	adds	r3, r0, #1
 80221ea:	d102      	bne.n	80221f2 <_read_r+0x1e>
 80221ec:	682b      	ldr	r3, [r5, #0]
 80221ee:	b103      	cbz	r3, 80221f2 <_read_r+0x1e>
 80221f0:	6023      	str	r3, [r4, #0]
 80221f2:	bd38      	pop	{r3, r4, r5, pc}
 80221f4:	20012304 	.word	0x20012304

080221f8 <_sbrk_r>:
 80221f8:	b538      	push	{r3, r4, r5, lr}
 80221fa:	4d06      	ldr	r5, [pc, #24]	@ (8022214 <_sbrk_r+0x1c>)
 80221fc:	2300      	movs	r3, #0
 80221fe:	4604      	mov	r4, r0
 8022200:	4608      	mov	r0, r1
 8022202:	602b      	str	r3, [r5, #0]
 8022204:	f7df fbc8 	bl	8001998 <_sbrk>
 8022208:	1c43      	adds	r3, r0, #1
 802220a:	d102      	bne.n	8022212 <_sbrk_r+0x1a>
 802220c:	682b      	ldr	r3, [r5, #0]
 802220e:	b103      	cbz	r3, 8022212 <_sbrk_r+0x1a>
 8022210:	6023      	str	r3, [r4, #0]
 8022212:	bd38      	pop	{r3, r4, r5, pc}
 8022214:	20012304 	.word	0x20012304

08022218 <_write_r>:
 8022218:	b538      	push	{r3, r4, r5, lr}
 802221a:	4d07      	ldr	r5, [pc, #28]	@ (8022238 <_write_r+0x20>)
 802221c:	4604      	mov	r4, r0
 802221e:	4608      	mov	r0, r1
 8022220:	4611      	mov	r1, r2
 8022222:	2200      	movs	r2, #0
 8022224:	602a      	str	r2, [r5, #0]
 8022226:	461a      	mov	r2, r3
 8022228:	f7df fb66 	bl	80018f8 <_write>
 802222c:	1c43      	adds	r3, r0, #1
 802222e:	d102      	bne.n	8022236 <_write_r+0x1e>
 8022230:	682b      	ldr	r3, [r5, #0]
 8022232:	b103      	cbz	r3, 8022236 <_write_r+0x1e>
 8022234:	6023      	str	r3, [r4, #0]
 8022236:	bd38      	pop	{r3, r4, r5, pc}
 8022238:	20012304 	.word	0x20012304

0802223c <__errno>:
 802223c:	4b01      	ldr	r3, [pc, #4]	@ (8022244 <__errno+0x8>)
 802223e:	6818      	ldr	r0, [r3, #0]
 8022240:	4770      	bx	lr
 8022242:	bf00      	nop
 8022244:	2000031c 	.word	0x2000031c

08022248 <__libc_init_array>:
 8022248:	b570      	push	{r4, r5, r6, lr}
 802224a:	4d0d      	ldr	r5, [pc, #52]	@ (8022280 <__libc_init_array+0x38>)
 802224c:	4c0d      	ldr	r4, [pc, #52]	@ (8022284 <__libc_init_array+0x3c>)
 802224e:	1b64      	subs	r4, r4, r5
 8022250:	10a4      	asrs	r4, r4, #2
 8022252:	2600      	movs	r6, #0
 8022254:	42a6      	cmp	r6, r4
 8022256:	d109      	bne.n	802226c <__libc_init_array+0x24>
 8022258:	4d0b      	ldr	r5, [pc, #44]	@ (8022288 <__libc_init_array+0x40>)
 802225a:	4c0c      	ldr	r4, [pc, #48]	@ (802228c <__libc_init_array+0x44>)
 802225c:	f001 feb2 	bl	8023fc4 <_init>
 8022260:	1b64      	subs	r4, r4, r5
 8022262:	10a4      	asrs	r4, r4, #2
 8022264:	2600      	movs	r6, #0
 8022266:	42a6      	cmp	r6, r4
 8022268:	d105      	bne.n	8022276 <__libc_init_array+0x2e>
 802226a:	bd70      	pop	{r4, r5, r6, pc}
 802226c:	f855 3b04 	ldr.w	r3, [r5], #4
 8022270:	4798      	blx	r3
 8022272:	3601      	adds	r6, #1
 8022274:	e7ee      	b.n	8022254 <__libc_init_array+0xc>
 8022276:	f855 3b04 	ldr.w	r3, [r5], #4
 802227a:	4798      	blx	r3
 802227c:	3601      	adds	r6, #1
 802227e:	e7f2      	b.n	8022266 <__libc_init_array+0x1e>
 8022280:	08039658 	.word	0x08039658
 8022284:	08039658 	.word	0x08039658
 8022288:	08039658 	.word	0x08039658
 802228c:	0803965c 	.word	0x0803965c

08022290 <__retarget_lock_init_recursive>:
 8022290:	4770      	bx	lr

08022292 <__retarget_lock_acquire_recursive>:
 8022292:	4770      	bx	lr

08022294 <__retarget_lock_release_recursive>:
 8022294:	4770      	bx	lr

08022296 <strcpy>:
 8022296:	4603      	mov	r3, r0
 8022298:	f811 2b01 	ldrb.w	r2, [r1], #1
 802229c:	f803 2b01 	strb.w	r2, [r3], #1
 80222a0:	2a00      	cmp	r2, #0
 80222a2:	d1f9      	bne.n	8022298 <strcpy+0x2>
 80222a4:	4770      	bx	lr

080222a6 <memcpy>:
 80222a6:	440a      	add	r2, r1
 80222a8:	4291      	cmp	r1, r2
 80222aa:	f100 33ff 	add.w	r3, r0, #4294967295
 80222ae:	d100      	bne.n	80222b2 <memcpy+0xc>
 80222b0:	4770      	bx	lr
 80222b2:	b510      	push	{r4, lr}
 80222b4:	f811 4b01 	ldrb.w	r4, [r1], #1
 80222b8:	f803 4f01 	strb.w	r4, [r3, #1]!
 80222bc:	4291      	cmp	r1, r2
 80222be:	d1f9      	bne.n	80222b4 <memcpy+0xe>
 80222c0:	bd10      	pop	{r4, pc}
 80222c2:	0000      	movs	r0, r0
 80222c4:	0000      	movs	r0, r0
	...

080222c8 <nan>:
 80222c8:	ed9f 0b01 	vldr	d0, [pc, #4]	@ 80222d0 <nan+0x8>
 80222cc:	4770      	bx	lr
 80222ce:	bf00      	nop
 80222d0:	00000000 	.word	0x00000000
 80222d4:	7ff80000 	.word	0x7ff80000

080222d8 <nanf>:
 80222d8:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 80222e0 <nanf+0x8>
 80222dc:	4770      	bx	lr
 80222de:	bf00      	nop
 80222e0:	7fc00000 	.word	0x7fc00000

080222e4 <_free_r>:
 80222e4:	b538      	push	{r3, r4, r5, lr}
 80222e6:	4605      	mov	r5, r0
 80222e8:	2900      	cmp	r1, #0
 80222ea:	d041      	beq.n	8022370 <_free_r+0x8c>
 80222ec:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80222f0:	1f0c      	subs	r4, r1, #4
 80222f2:	2b00      	cmp	r3, #0
 80222f4:	bfb8      	it	lt
 80222f6:	18e4      	addlt	r4, r4, r3
 80222f8:	f7fe fdd0 	bl	8020e9c <__malloc_lock>
 80222fc:	4a1d      	ldr	r2, [pc, #116]	@ (8022374 <_free_r+0x90>)
 80222fe:	6813      	ldr	r3, [r2, #0]
 8022300:	b933      	cbnz	r3, 8022310 <_free_r+0x2c>
 8022302:	6063      	str	r3, [r4, #4]
 8022304:	6014      	str	r4, [r2, #0]
 8022306:	4628      	mov	r0, r5
 8022308:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802230c:	f7fe bdcc 	b.w	8020ea8 <__malloc_unlock>
 8022310:	42a3      	cmp	r3, r4
 8022312:	d908      	bls.n	8022326 <_free_r+0x42>
 8022314:	6820      	ldr	r0, [r4, #0]
 8022316:	1821      	adds	r1, r4, r0
 8022318:	428b      	cmp	r3, r1
 802231a:	bf01      	itttt	eq
 802231c:	6819      	ldreq	r1, [r3, #0]
 802231e:	685b      	ldreq	r3, [r3, #4]
 8022320:	1809      	addeq	r1, r1, r0
 8022322:	6021      	streq	r1, [r4, #0]
 8022324:	e7ed      	b.n	8022302 <_free_r+0x1e>
 8022326:	461a      	mov	r2, r3
 8022328:	685b      	ldr	r3, [r3, #4]
 802232a:	b10b      	cbz	r3, 8022330 <_free_r+0x4c>
 802232c:	42a3      	cmp	r3, r4
 802232e:	d9fa      	bls.n	8022326 <_free_r+0x42>
 8022330:	6811      	ldr	r1, [r2, #0]
 8022332:	1850      	adds	r0, r2, r1
 8022334:	42a0      	cmp	r0, r4
 8022336:	d10b      	bne.n	8022350 <_free_r+0x6c>
 8022338:	6820      	ldr	r0, [r4, #0]
 802233a:	4401      	add	r1, r0
 802233c:	1850      	adds	r0, r2, r1
 802233e:	4283      	cmp	r3, r0
 8022340:	6011      	str	r1, [r2, #0]
 8022342:	d1e0      	bne.n	8022306 <_free_r+0x22>
 8022344:	6818      	ldr	r0, [r3, #0]
 8022346:	685b      	ldr	r3, [r3, #4]
 8022348:	6053      	str	r3, [r2, #4]
 802234a:	4408      	add	r0, r1
 802234c:	6010      	str	r0, [r2, #0]
 802234e:	e7da      	b.n	8022306 <_free_r+0x22>
 8022350:	d902      	bls.n	8022358 <_free_r+0x74>
 8022352:	230c      	movs	r3, #12
 8022354:	602b      	str	r3, [r5, #0]
 8022356:	e7d6      	b.n	8022306 <_free_r+0x22>
 8022358:	6820      	ldr	r0, [r4, #0]
 802235a:	1821      	adds	r1, r4, r0
 802235c:	428b      	cmp	r3, r1
 802235e:	bf04      	itt	eq
 8022360:	6819      	ldreq	r1, [r3, #0]
 8022362:	685b      	ldreq	r3, [r3, #4]
 8022364:	6063      	str	r3, [r4, #4]
 8022366:	bf04      	itt	eq
 8022368:	1809      	addeq	r1, r1, r0
 802236a:	6021      	streq	r1, [r4, #0]
 802236c:	6054      	str	r4, [r2, #4]
 802236e:	e7ca      	b.n	8022306 <_free_r+0x22>
 8022370:	bd38      	pop	{r3, r4, r5, pc}
 8022372:	bf00      	nop
 8022374:	200121c4 	.word	0x200121c4

08022378 <rshift>:
 8022378:	6903      	ldr	r3, [r0, #16]
 802237a:	ebb3 1f61 	cmp.w	r3, r1, asr #5
 802237e:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8022382:	ea4f 1261 	mov.w	r2, r1, asr #5
 8022386:	f100 0414 	add.w	r4, r0, #20
 802238a:	dd45      	ble.n	8022418 <rshift+0xa0>
 802238c:	f011 011f 	ands.w	r1, r1, #31
 8022390:	eb04 0683 	add.w	r6, r4, r3, lsl #2
 8022394:	eb04 0582 	add.w	r5, r4, r2, lsl #2
 8022398:	d10c      	bne.n	80223b4 <rshift+0x3c>
 802239a:	f100 0710 	add.w	r7, r0, #16
 802239e:	4629      	mov	r1, r5
 80223a0:	42b1      	cmp	r1, r6
 80223a2:	d334      	bcc.n	802240e <rshift+0x96>
 80223a4:	1a9b      	subs	r3, r3, r2
 80223a6:	009b      	lsls	r3, r3, #2
 80223a8:	1eea      	subs	r2, r5, #3
 80223aa:	4296      	cmp	r6, r2
 80223ac:	bf38      	it	cc
 80223ae:	2300      	movcc	r3, #0
 80223b0:	4423      	add	r3, r4
 80223b2:	e015      	b.n	80223e0 <rshift+0x68>
 80223b4:	f854 7022 	ldr.w	r7, [r4, r2, lsl #2]
 80223b8:	f1c1 0820 	rsb	r8, r1, #32
 80223bc:	40cf      	lsrs	r7, r1
 80223be:	f105 0e04 	add.w	lr, r5, #4
 80223c2:	46a1      	mov	r9, r4
 80223c4:	4576      	cmp	r6, lr
 80223c6:	46f4      	mov	ip, lr
 80223c8:	d815      	bhi.n	80223f6 <rshift+0x7e>
 80223ca:	1a9a      	subs	r2, r3, r2
 80223cc:	0092      	lsls	r2, r2, #2
 80223ce:	3a04      	subs	r2, #4
 80223d0:	3501      	adds	r5, #1
 80223d2:	42ae      	cmp	r6, r5
 80223d4:	bf38      	it	cc
 80223d6:	2200      	movcc	r2, #0
 80223d8:	18a3      	adds	r3, r4, r2
 80223da:	50a7      	str	r7, [r4, r2]
 80223dc:	b107      	cbz	r7, 80223e0 <rshift+0x68>
 80223de:	3304      	adds	r3, #4
 80223e0:	1b1a      	subs	r2, r3, r4
 80223e2:	42a3      	cmp	r3, r4
 80223e4:	ea4f 02a2 	mov.w	r2, r2, asr #2
 80223e8:	bf08      	it	eq
 80223ea:	2300      	moveq	r3, #0
 80223ec:	6102      	str	r2, [r0, #16]
 80223ee:	bf08      	it	eq
 80223f0:	6143      	streq	r3, [r0, #20]
 80223f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80223f6:	f8dc c000 	ldr.w	ip, [ip]
 80223fa:	fa0c fc08 	lsl.w	ip, ip, r8
 80223fe:	ea4c 0707 	orr.w	r7, ip, r7
 8022402:	f849 7b04 	str.w	r7, [r9], #4
 8022406:	f85e 7b04 	ldr.w	r7, [lr], #4
 802240a:	40cf      	lsrs	r7, r1
 802240c:	e7da      	b.n	80223c4 <rshift+0x4c>
 802240e:	f851 cb04 	ldr.w	ip, [r1], #4
 8022412:	f847 cf04 	str.w	ip, [r7, #4]!
 8022416:	e7c3      	b.n	80223a0 <rshift+0x28>
 8022418:	4623      	mov	r3, r4
 802241a:	e7e1      	b.n	80223e0 <rshift+0x68>

0802241c <__hexdig_fun>:
 802241c:	f1a0 0330 	sub.w	r3, r0, #48	@ 0x30
 8022420:	2b09      	cmp	r3, #9
 8022422:	d802      	bhi.n	802242a <__hexdig_fun+0xe>
 8022424:	3820      	subs	r0, #32
 8022426:	b2c0      	uxtb	r0, r0
 8022428:	4770      	bx	lr
 802242a:	f1a0 0361 	sub.w	r3, r0, #97	@ 0x61
 802242e:	2b05      	cmp	r3, #5
 8022430:	d801      	bhi.n	8022436 <__hexdig_fun+0x1a>
 8022432:	3847      	subs	r0, #71	@ 0x47
 8022434:	e7f7      	b.n	8022426 <__hexdig_fun+0xa>
 8022436:	f1a0 0341 	sub.w	r3, r0, #65	@ 0x41
 802243a:	2b05      	cmp	r3, #5
 802243c:	d801      	bhi.n	8022442 <__hexdig_fun+0x26>
 802243e:	3827      	subs	r0, #39	@ 0x27
 8022440:	e7f1      	b.n	8022426 <__hexdig_fun+0xa>
 8022442:	2000      	movs	r0, #0
 8022444:	4770      	bx	lr
	...

08022448 <__gethex>:
 8022448:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802244c:	b085      	sub	sp, #20
 802244e:	468a      	mov	sl, r1
 8022450:	9302      	str	r3, [sp, #8]
 8022452:	680b      	ldr	r3, [r1, #0]
 8022454:	9001      	str	r0, [sp, #4]
 8022456:	4690      	mov	r8, r2
 8022458:	1c9c      	adds	r4, r3, #2
 802245a:	46a1      	mov	r9, r4
 802245c:	f814 0b01 	ldrb.w	r0, [r4], #1
 8022460:	2830      	cmp	r0, #48	@ 0x30
 8022462:	d0fa      	beq.n	802245a <__gethex+0x12>
 8022464:	eba9 0303 	sub.w	r3, r9, r3
 8022468:	f1a3 0b02 	sub.w	fp, r3, #2
 802246c:	f7ff ffd6 	bl	802241c <__hexdig_fun>
 8022470:	4605      	mov	r5, r0
 8022472:	2800      	cmp	r0, #0
 8022474:	d168      	bne.n	8022548 <__gethex+0x100>
 8022476:	49a0      	ldr	r1, [pc, #640]	@ (80226f8 <__gethex+0x2b0>)
 8022478:	2201      	movs	r2, #1
 802247a:	4648      	mov	r0, r9
 802247c:	f7ff fe4a 	bl	8022114 <strncmp>
 8022480:	4607      	mov	r7, r0
 8022482:	2800      	cmp	r0, #0
 8022484:	d167      	bne.n	8022556 <__gethex+0x10e>
 8022486:	f899 0001 	ldrb.w	r0, [r9, #1]
 802248a:	4626      	mov	r6, r4
 802248c:	f7ff ffc6 	bl	802241c <__hexdig_fun>
 8022490:	2800      	cmp	r0, #0
 8022492:	d062      	beq.n	802255a <__gethex+0x112>
 8022494:	4623      	mov	r3, r4
 8022496:	7818      	ldrb	r0, [r3, #0]
 8022498:	2830      	cmp	r0, #48	@ 0x30
 802249a:	4699      	mov	r9, r3
 802249c:	f103 0301 	add.w	r3, r3, #1
 80224a0:	d0f9      	beq.n	8022496 <__gethex+0x4e>
 80224a2:	f7ff ffbb 	bl	802241c <__hexdig_fun>
 80224a6:	fab0 f580 	clz	r5, r0
 80224aa:	096d      	lsrs	r5, r5, #5
 80224ac:	f04f 0b01 	mov.w	fp, #1
 80224b0:	464a      	mov	r2, r9
 80224b2:	4616      	mov	r6, r2
 80224b4:	3201      	adds	r2, #1
 80224b6:	7830      	ldrb	r0, [r6, #0]
 80224b8:	f7ff ffb0 	bl	802241c <__hexdig_fun>
 80224bc:	2800      	cmp	r0, #0
 80224be:	d1f8      	bne.n	80224b2 <__gethex+0x6a>
 80224c0:	498d      	ldr	r1, [pc, #564]	@ (80226f8 <__gethex+0x2b0>)
 80224c2:	2201      	movs	r2, #1
 80224c4:	4630      	mov	r0, r6
 80224c6:	f7ff fe25 	bl	8022114 <strncmp>
 80224ca:	2800      	cmp	r0, #0
 80224cc:	d13f      	bne.n	802254e <__gethex+0x106>
 80224ce:	b944      	cbnz	r4, 80224e2 <__gethex+0x9a>
 80224d0:	1c74      	adds	r4, r6, #1
 80224d2:	4622      	mov	r2, r4
 80224d4:	4616      	mov	r6, r2
 80224d6:	3201      	adds	r2, #1
 80224d8:	7830      	ldrb	r0, [r6, #0]
 80224da:	f7ff ff9f 	bl	802241c <__hexdig_fun>
 80224de:	2800      	cmp	r0, #0
 80224e0:	d1f8      	bne.n	80224d4 <__gethex+0x8c>
 80224e2:	1ba4      	subs	r4, r4, r6
 80224e4:	00a7      	lsls	r7, r4, #2
 80224e6:	7833      	ldrb	r3, [r6, #0]
 80224e8:	f003 03df 	and.w	r3, r3, #223	@ 0xdf
 80224ec:	2b50      	cmp	r3, #80	@ 0x50
 80224ee:	d13e      	bne.n	802256e <__gethex+0x126>
 80224f0:	7873      	ldrb	r3, [r6, #1]
 80224f2:	2b2b      	cmp	r3, #43	@ 0x2b
 80224f4:	d033      	beq.n	802255e <__gethex+0x116>
 80224f6:	2b2d      	cmp	r3, #45	@ 0x2d
 80224f8:	d034      	beq.n	8022564 <__gethex+0x11c>
 80224fa:	1c71      	adds	r1, r6, #1
 80224fc:	2400      	movs	r4, #0
 80224fe:	7808      	ldrb	r0, [r1, #0]
 8022500:	f7ff ff8c 	bl	802241c <__hexdig_fun>
 8022504:	1e43      	subs	r3, r0, #1
 8022506:	b2db      	uxtb	r3, r3
 8022508:	2b18      	cmp	r3, #24
 802250a:	d830      	bhi.n	802256e <__gethex+0x126>
 802250c:	f1a0 0210 	sub.w	r2, r0, #16
 8022510:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8022514:	f7ff ff82 	bl	802241c <__hexdig_fun>
 8022518:	f100 3cff 	add.w	ip, r0, #4294967295
 802251c:	fa5f fc8c 	uxtb.w	ip, ip
 8022520:	f1bc 0f18 	cmp.w	ip, #24
 8022524:	f04f 030a 	mov.w	r3, #10
 8022528:	d91e      	bls.n	8022568 <__gethex+0x120>
 802252a:	b104      	cbz	r4, 802252e <__gethex+0xe6>
 802252c:	4252      	negs	r2, r2
 802252e:	4417      	add	r7, r2
 8022530:	f8ca 1000 	str.w	r1, [sl]
 8022534:	b1ed      	cbz	r5, 8022572 <__gethex+0x12a>
 8022536:	f1bb 0f00 	cmp.w	fp, #0
 802253a:	bf0c      	ite	eq
 802253c:	2506      	moveq	r5, #6
 802253e:	2500      	movne	r5, #0
 8022540:	4628      	mov	r0, r5
 8022542:	b005      	add	sp, #20
 8022544:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022548:	2500      	movs	r5, #0
 802254a:	462c      	mov	r4, r5
 802254c:	e7b0      	b.n	80224b0 <__gethex+0x68>
 802254e:	2c00      	cmp	r4, #0
 8022550:	d1c7      	bne.n	80224e2 <__gethex+0x9a>
 8022552:	4627      	mov	r7, r4
 8022554:	e7c7      	b.n	80224e6 <__gethex+0x9e>
 8022556:	464e      	mov	r6, r9
 8022558:	462f      	mov	r7, r5
 802255a:	2501      	movs	r5, #1
 802255c:	e7c3      	b.n	80224e6 <__gethex+0x9e>
 802255e:	2400      	movs	r4, #0
 8022560:	1cb1      	adds	r1, r6, #2
 8022562:	e7cc      	b.n	80224fe <__gethex+0xb6>
 8022564:	2401      	movs	r4, #1
 8022566:	e7fb      	b.n	8022560 <__gethex+0x118>
 8022568:	fb03 0002 	mla	r0, r3, r2, r0
 802256c:	e7ce      	b.n	802250c <__gethex+0xc4>
 802256e:	4631      	mov	r1, r6
 8022570:	e7de      	b.n	8022530 <__gethex+0xe8>
 8022572:	eba6 0309 	sub.w	r3, r6, r9
 8022576:	3b01      	subs	r3, #1
 8022578:	4629      	mov	r1, r5
 802257a:	2b07      	cmp	r3, #7
 802257c:	dc0a      	bgt.n	8022594 <__gethex+0x14c>
 802257e:	9801      	ldr	r0, [sp, #4]
 8022580:	f000 fa46 	bl	8022a10 <_Balloc>
 8022584:	4604      	mov	r4, r0
 8022586:	b940      	cbnz	r0, 802259a <__gethex+0x152>
 8022588:	4b5c      	ldr	r3, [pc, #368]	@ (80226fc <__gethex+0x2b4>)
 802258a:	4602      	mov	r2, r0
 802258c:	21e4      	movs	r1, #228	@ 0xe4
 802258e:	485c      	ldr	r0, [pc, #368]	@ (8022700 <__gethex+0x2b8>)
 8022590:	f001 fb12 	bl	8023bb8 <__assert_func>
 8022594:	3101      	adds	r1, #1
 8022596:	105b      	asrs	r3, r3, #1
 8022598:	e7ef      	b.n	802257a <__gethex+0x132>
 802259a:	f100 0a14 	add.w	sl, r0, #20
 802259e:	2300      	movs	r3, #0
 80225a0:	4655      	mov	r5, sl
 80225a2:	469b      	mov	fp, r3
 80225a4:	45b1      	cmp	r9, r6
 80225a6:	d337      	bcc.n	8022618 <__gethex+0x1d0>
 80225a8:	f845 bb04 	str.w	fp, [r5], #4
 80225ac:	eba5 050a 	sub.w	r5, r5, sl
 80225b0:	10ad      	asrs	r5, r5, #2
 80225b2:	6125      	str	r5, [r4, #16]
 80225b4:	4658      	mov	r0, fp
 80225b6:	f000 fb1d 	bl	8022bf4 <__hi0bits>
 80225ba:	016d      	lsls	r5, r5, #5
 80225bc:	f8d8 6000 	ldr.w	r6, [r8]
 80225c0:	1a2d      	subs	r5, r5, r0
 80225c2:	42b5      	cmp	r5, r6
 80225c4:	dd54      	ble.n	8022670 <__gethex+0x228>
 80225c6:	1bad      	subs	r5, r5, r6
 80225c8:	4629      	mov	r1, r5
 80225ca:	4620      	mov	r0, r4
 80225cc:	f000 feb1 	bl	8023332 <__any_on>
 80225d0:	4681      	mov	r9, r0
 80225d2:	b178      	cbz	r0, 80225f4 <__gethex+0x1ac>
 80225d4:	1e6b      	subs	r3, r5, #1
 80225d6:	1159      	asrs	r1, r3, #5
 80225d8:	f003 021f 	and.w	r2, r3, #31
 80225dc:	f85a 1021 	ldr.w	r1, [sl, r1, lsl #2]
 80225e0:	f04f 0901 	mov.w	r9, #1
 80225e4:	fa09 f202 	lsl.w	r2, r9, r2
 80225e8:	420a      	tst	r2, r1
 80225ea:	d003      	beq.n	80225f4 <__gethex+0x1ac>
 80225ec:	454b      	cmp	r3, r9
 80225ee:	dc36      	bgt.n	802265e <__gethex+0x216>
 80225f0:	f04f 0902 	mov.w	r9, #2
 80225f4:	4629      	mov	r1, r5
 80225f6:	4620      	mov	r0, r4
 80225f8:	f7ff febe 	bl	8022378 <rshift>
 80225fc:	442f      	add	r7, r5
 80225fe:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8022602:	42bb      	cmp	r3, r7
 8022604:	da42      	bge.n	802268c <__gethex+0x244>
 8022606:	9801      	ldr	r0, [sp, #4]
 8022608:	4621      	mov	r1, r4
 802260a:	f000 fa41 	bl	8022a90 <_Bfree>
 802260e:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 8022610:	2300      	movs	r3, #0
 8022612:	6013      	str	r3, [r2, #0]
 8022614:	25a3      	movs	r5, #163	@ 0xa3
 8022616:	e793      	b.n	8022540 <__gethex+0xf8>
 8022618:	f816 2d01 	ldrb.w	r2, [r6, #-1]!
 802261c:	2a2e      	cmp	r2, #46	@ 0x2e
 802261e:	d012      	beq.n	8022646 <__gethex+0x1fe>
 8022620:	2b20      	cmp	r3, #32
 8022622:	d104      	bne.n	802262e <__gethex+0x1e6>
 8022624:	f845 bb04 	str.w	fp, [r5], #4
 8022628:	f04f 0b00 	mov.w	fp, #0
 802262c:	465b      	mov	r3, fp
 802262e:	7830      	ldrb	r0, [r6, #0]
 8022630:	9303      	str	r3, [sp, #12]
 8022632:	f7ff fef3 	bl	802241c <__hexdig_fun>
 8022636:	9b03      	ldr	r3, [sp, #12]
 8022638:	f000 000f 	and.w	r0, r0, #15
 802263c:	4098      	lsls	r0, r3
 802263e:	ea4b 0b00 	orr.w	fp, fp, r0
 8022642:	3304      	adds	r3, #4
 8022644:	e7ae      	b.n	80225a4 <__gethex+0x15c>
 8022646:	45b1      	cmp	r9, r6
 8022648:	d8ea      	bhi.n	8022620 <__gethex+0x1d8>
 802264a:	492b      	ldr	r1, [pc, #172]	@ (80226f8 <__gethex+0x2b0>)
 802264c:	9303      	str	r3, [sp, #12]
 802264e:	2201      	movs	r2, #1
 8022650:	4630      	mov	r0, r6
 8022652:	f7ff fd5f 	bl	8022114 <strncmp>
 8022656:	9b03      	ldr	r3, [sp, #12]
 8022658:	2800      	cmp	r0, #0
 802265a:	d1e1      	bne.n	8022620 <__gethex+0x1d8>
 802265c:	e7a2      	b.n	80225a4 <__gethex+0x15c>
 802265e:	1ea9      	subs	r1, r5, #2
 8022660:	4620      	mov	r0, r4
 8022662:	f000 fe66 	bl	8023332 <__any_on>
 8022666:	2800      	cmp	r0, #0
 8022668:	d0c2      	beq.n	80225f0 <__gethex+0x1a8>
 802266a:	f04f 0903 	mov.w	r9, #3
 802266e:	e7c1      	b.n	80225f4 <__gethex+0x1ac>
 8022670:	da09      	bge.n	8022686 <__gethex+0x23e>
 8022672:	1b75      	subs	r5, r6, r5
 8022674:	4621      	mov	r1, r4
 8022676:	9801      	ldr	r0, [sp, #4]
 8022678:	462a      	mov	r2, r5
 802267a:	f000 fc21 	bl	8022ec0 <__lshift>
 802267e:	1b7f      	subs	r7, r7, r5
 8022680:	4604      	mov	r4, r0
 8022682:	f100 0a14 	add.w	sl, r0, #20
 8022686:	f04f 0900 	mov.w	r9, #0
 802268a:	e7b8      	b.n	80225fe <__gethex+0x1b6>
 802268c:	f8d8 5004 	ldr.w	r5, [r8, #4]
 8022690:	42bd      	cmp	r5, r7
 8022692:	dd6f      	ble.n	8022774 <__gethex+0x32c>
 8022694:	1bed      	subs	r5, r5, r7
 8022696:	42ae      	cmp	r6, r5
 8022698:	dc34      	bgt.n	8022704 <__gethex+0x2bc>
 802269a:	f8d8 300c 	ldr.w	r3, [r8, #12]
 802269e:	2b02      	cmp	r3, #2
 80226a0:	d022      	beq.n	80226e8 <__gethex+0x2a0>
 80226a2:	2b03      	cmp	r3, #3
 80226a4:	d024      	beq.n	80226f0 <__gethex+0x2a8>
 80226a6:	2b01      	cmp	r3, #1
 80226a8:	d115      	bne.n	80226d6 <__gethex+0x28e>
 80226aa:	42ae      	cmp	r6, r5
 80226ac:	d113      	bne.n	80226d6 <__gethex+0x28e>
 80226ae:	2e01      	cmp	r6, #1
 80226b0:	d10b      	bne.n	80226ca <__gethex+0x282>
 80226b2:	9a02      	ldr	r2, [sp, #8]
 80226b4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80226b8:	6013      	str	r3, [r2, #0]
 80226ba:	2301      	movs	r3, #1
 80226bc:	6123      	str	r3, [r4, #16]
 80226be:	f8ca 3000 	str.w	r3, [sl]
 80226c2:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80226c4:	2562      	movs	r5, #98	@ 0x62
 80226c6:	601c      	str	r4, [r3, #0]
 80226c8:	e73a      	b.n	8022540 <__gethex+0xf8>
 80226ca:	1e71      	subs	r1, r6, #1
 80226cc:	4620      	mov	r0, r4
 80226ce:	f000 fe30 	bl	8023332 <__any_on>
 80226d2:	2800      	cmp	r0, #0
 80226d4:	d1ed      	bne.n	80226b2 <__gethex+0x26a>
 80226d6:	9801      	ldr	r0, [sp, #4]
 80226d8:	4621      	mov	r1, r4
 80226da:	f000 f9d9 	bl	8022a90 <_Bfree>
 80226de:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 80226e0:	2300      	movs	r3, #0
 80226e2:	6013      	str	r3, [r2, #0]
 80226e4:	2550      	movs	r5, #80	@ 0x50
 80226e6:	e72b      	b.n	8022540 <__gethex+0xf8>
 80226e8:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80226ea:	2b00      	cmp	r3, #0
 80226ec:	d1f3      	bne.n	80226d6 <__gethex+0x28e>
 80226ee:	e7e0      	b.n	80226b2 <__gethex+0x26a>
 80226f0:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 80226f2:	2b00      	cmp	r3, #0
 80226f4:	d1dd      	bne.n	80226b2 <__gethex+0x26a>
 80226f6:	e7ee      	b.n	80226d6 <__gethex+0x28e>
 80226f8:	08039294 	.word	0x08039294
 80226fc:	08039401 	.word	0x08039401
 8022700:	08039412 	.word	0x08039412
 8022704:	1e6f      	subs	r7, r5, #1
 8022706:	f1b9 0f00 	cmp.w	r9, #0
 802270a:	d130      	bne.n	802276e <__gethex+0x326>
 802270c:	b127      	cbz	r7, 8022718 <__gethex+0x2d0>
 802270e:	4639      	mov	r1, r7
 8022710:	4620      	mov	r0, r4
 8022712:	f000 fe0e 	bl	8023332 <__any_on>
 8022716:	4681      	mov	r9, r0
 8022718:	117a      	asrs	r2, r7, #5
 802271a:	2301      	movs	r3, #1
 802271c:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
 8022720:	f007 071f 	and.w	r7, r7, #31
 8022724:	40bb      	lsls	r3, r7
 8022726:	4213      	tst	r3, r2
 8022728:	4629      	mov	r1, r5
 802272a:	4620      	mov	r0, r4
 802272c:	bf18      	it	ne
 802272e:	f049 0902 	orrne.w	r9, r9, #2
 8022732:	f7ff fe21 	bl	8022378 <rshift>
 8022736:	f8d8 7004 	ldr.w	r7, [r8, #4]
 802273a:	1b76      	subs	r6, r6, r5
 802273c:	2502      	movs	r5, #2
 802273e:	f1b9 0f00 	cmp.w	r9, #0
 8022742:	d047      	beq.n	80227d4 <__gethex+0x38c>
 8022744:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8022748:	2b02      	cmp	r3, #2
 802274a:	d015      	beq.n	8022778 <__gethex+0x330>
 802274c:	2b03      	cmp	r3, #3
 802274e:	d017      	beq.n	8022780 <__gethex+0x338>
 8022750:	2b01      	cmp	r3, #1
 8022752:	d109      	bne.n	8022768 <__gethex+0x320>
 8022754:	f019 0f02 	tst.w	r9, #2
 8022758:	d006      	beq.n	8022768 <__gethex+0x320>
 802275a:	f8da 3000 	ldr.w	r3, [sl]
 802275e:	ea49 0903 	orr.w	r9, r9, r3
 8022762:	f019 0f01 	tst.w	r9, #1
 8022766:	d10e      	bne.n	8022786 <__gethex+0x33e>
 8022768:	f045 0510 	orr.w	r5, r5, #16
 802276c:	e032      	b.n	80227d4 <__gethex+0x38c>
 802276e:	f04f 0901 	mov.w	r9, #1
 8022772:	e7d1      	b.n	8022718 <__gethex+0x2d0>
 8022774:	2501      	movs	r5, #1
 8022776:	e7e2      	b.n	802273e <__gethex+0x2f6>
 8022778:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 802277a:	f1c3 0301 	rsb	r3, r3, #1
 802277e:	930f      	str	r3, [sp, #60]	@ 0x3c
 8022780:	9b0f      	ldr	r3, [sp, #60]	@ 0x3c
 8022782:	2b00      	cmp	r3, #0
 8022784:	d0f0      	beq.n	8022768 <__gethex+0x320>
 8022786:	f8d4 b010 	ldr.w	fp, [r4, #16]
 802278a:	f104 0314 	add.w	r3, r4, #20
 802278e:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
 8022792:	eb03 018b 	add.w	r1, r3, fp, lsl #2
 8022796:	f04f 0c00 	mov.w	ip, #0
 802279a:	4618      	mov	r0, r3
 802279c:	f853 2b04 	ldr.w	r2, [r3], #4
 80227a0:	f1b2 3fff 	cmp.w	r2, #4294967295
 80227a4:	d01b      	beq.n	80227de <__gethex+0x396>
 80227a6:	3201      	adds	r2, #1
 80227a8:	6002      	str	r2, [r0, #0]
 80227aa:	2d02      	cmp	r5, #2
 80227ac:	f104 0314 	add.w	r3, r4, #20
 80227b0:	d13c      	bne.n	802282c <__gethex+0x3e4>
 80227b2:	f8d8 2000 	ldr.w	r2, [r8]
 80227b6:	3a01      	subs	r2, #1
 80227b8:	42b2      	cmp	r2, r6
 80227ba:	d109      	bne.n	80227d0 <__gethex+0x388>
 80227bc:	1171      	asrs	r1, r6, #5
 80227be:	2201      	movs	r2, #1
 80227c0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 80227c4:	f006 061f 	and.w	r6, r6, #31
 80227c8:	fa02 f606 	lsl.w	r6, r2, r6
 80227cc:	421e      	tst	r6, r3
 80227ce:	d13a      	bne.n	8022846 <__gethex+0x3fe>
 80227d0:	f045 0520 	orr.w	r5, r5, #32
 80227d4:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 80227d6:	601c      	str	r4, [r3, #0]
 80227d8:	9b02      	ldr	r3, [sp, #8]
 80227da:	601f      	str	r7, [r3, #0]
 80227dc:	e6b0      	b.n	8022540 <__gethex+0xf8>
 80227de:	4299      	cmp	r1, r3
 80227e0:	f843 cc04 	str.w	ip, [r3, #-4]
 80227e4:	d8d9      	bhi.n	802279a <__gethex+0x352>
 80227e6:	68a3      	ldr	r3, [r4, #8]
 80227e8:	459b      	cmp	fp, r3
 80227ea:	db17      	blt.n	802281c <__gethex+0x3d4>
 80227ec:	6861      	ldr	r1, [r4, #4]
 80227ee:	9801      	ldr	r0, [sp, #4]
 80227f0:	3101      	adds	r1, #1
 80227f2:	f000 f90d 	bl	8022a10 <_Balloc>
 80227f6:	4681      	mov	r9, r0
 80227f8:	b918      	cbnz	r0, 8022802 <__gethex+0x3ba>
 80227fa:	4b1a      	ldr	r3, [pc, #104]	@ (8022864 <__gethex+0x41c>)
 80227fc:	4602      	mov	r2, r0
 80227fe:	2184      	movs	r1, #132	@ 0x84
 8022800:	e6c5      	b.n	802258e <__gethex+0x146>
 8022802:	6922      	ldr	r2, [r4, #16]
 8022804:	3202      	adds	r2, #2
 8022806:	f104 010c 	add.w	r1, r4, #12
 802280a:	0092      	lsls	r2, r2, #2
 802280c:	300c      	adds	r0, #12
 802280e:	f7ff fd4a 	bl	80222a6 <memcpy>
 8022812:	4621      	mov	r1, r4
 8022814:	9801      	ldr	r0, [sp, #4]
 8022816:	f000 f93b 	bl	8022a90 <_Bfree>
 802281a:	464c      	mov	r4, r9
 802281c:	6923      	ldr	r3, [r4, #16]
 802281e:	1c5a      	adds	r2, r3, #1
 8022820:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 8022824:	6122      	str	r2, [r4, #16]
 8022826:	2201      	movs	r2, #1
 8022828:	615a      	str	r2, [r3, #20]
 802282a:	e7be      	b.n	80227aa <__gethex+0x362>
 802282c:	6922      	ldr	r2, [r4, #16]
 802282e:	455a      	cmp	r2, fp
 8022830:	dd0b      	ble.n	802284a <__gethex+0x402>
 8022832:	2101      	movs	r1, #1
 8022834:	4620      	mov	r0, r4
 8022836:	f7ff fd9f 	bl	8022378 <rshift>
 802283a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 802283e:	3701      	adds	r7, #1
 8022840:	42bb      	cmp	r3, r7
 8022842:	f6ff aee0 	blt.w	8022606 <__gethex+0x1be>
 8022846:	2501      	movs	r5, #1
 8022848:	e7c2      	b.n	80227d0 <__gethex+0x388>
 802284a:	f016 061f 	ands.w	r6, r6, #31
 802284e:	d0fa      	beq.n	8022846 <__gethex+0x3fe>
 8022850:	4453      	add	r3, sl
 8022852:	f1c6 0620 	rsb	r6, r6, #32
 8022856:	f853 0c04 	ldr.w	r0, [r3, #-4]
 802285a:	f000 f9cb 	bl	8022bf4 <__hi0bits>
 802285e:	42b0      	cmp	r0, r6
 8022860:	dbe7      	blt.n	8022832 <__gethex+0x3ea>
 8022862:	e7f0      	b.n	8022846 <__gethex+0x3fe>
 8022864:	08039401 	.word	0x08039401

08022868 <L_shift>:
 8022868:	f1c2 0208 	rsb	r2, r2, #8
 802286c:	0092      	lsls	r2, r2, #2
 802286e:	b570      	push	{r4, r5, r6, lr}
 8022870:	f1c2 0620 	rsb	r6, r2, #32
 8022874:	6843      	ldr	r3, [r0, #4]
 8022876:	6804      	ldr	r4, [r0, #0]
 8022878:	fa03 f506 	lsl.w	r5, r3, r6
 802287c:	432c      	orrs	r4, r5
 802287e:	40d3      	lsrs	r3, r2
 8022880:	6004      	str	r4, [r0, #0]
 8022882:	f840 3f04 	str.w	r3, [r0, #4]!
 8022886:	4288      	cmp	r0, r1
 8022888:	d3f4      	bcc.n	8022874 <L_shift+0xc>
 802288a:	bd70      	pop	{r4, r5, r6, pc}

0802288c <__match>:
 802288c:	b530      	push	{r4, r5, lr}
 802288e:	6803      	ldr	r3, [r0, #0]
 8022890:	3301      	adds	r3, #1
 8022892:	f811 4b01 	ldrb.w	r4, [r1], #1
 8022896:	b914      	cbnz	r4, 802289e <__match+0x12>
 8022898:	6003      	str	r3, [r0, #0]
 802289a:	2001      	movs	r0, #1
 802289c:	bd30      	pop	{r4, r5, pc}
 802289e:	f813 2b01 	ldrb.w	r2, [r3], #1
 80228a2:	f1a2 0541 	sub.w	r5, r2, #65	@ 0x41
 80228a6:	2d19      	cmp	r5, #25
 80228a8:	bf98      	it	ls
 80228aa:	3220      	addls	r2, #32
 80228ac:	42a2      	cmp	r2, r4
 80228ae:	d0f0      	beq.n	8022892 <__match+0x6>
 80228b0:	2000      	movs	r0, #0
 80228b2:	e7f3      	b.n	802289c <__match+0x10>

080228b4 <__hexnan>:
 80228b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80228b8:	680b      	ldr	r3, [r1, #0]
 80228ba:	6801      	ldr	r1, [r0, #0]
 80228bc:	115e      	asrs	r6, r3, #5
 80228be:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 80228c2:	f013 031f 	ands.w	r3, r3, #31
 80228c6:	b087      	sub	sp, #28
 80228c8:	bf18      	it	ne
 80228ca:	3604      	addne	r6, #4
 80228cc:	2500      	movs	r5, #0
 80228ce:	1f37      	subs	r7, r6, #4
 80228d0:	4682      	mov	sl, r0
 80228d2:	4690      	mov	r8, r2
 80228d4:	9301      	str	r3, [sp, #4]
 80228d6:	f846 5c04 	str.w	r5, [r6, #-4]
 80228da:	46b9      	mov	r9, r7
 80228dc:	463c      	mov	r4, r7
 80228de:	9502      	str	r5, [sp, #8]
 80228e0:	46ab      	mov	fp, r5
 80228e2:	784a      	ldrb	r2, [r1, #1]
 80228e4:	1c4b      	adds	r3, r1, #1
 80228e6:	9303      	str	r3, [sp, #12]
 80228e8:	b342      	cbz	r2, 802293c <__hexnan+0x88>
 80228ea:	4610      	mov	r0, r2
 80228ec:	9105      	str	r1, [sp, #20]
 80228ee:	9204      	str	r2, [sp, #16]
 80228f0:	f7ff fd94 	bl	802241c <__hexdig_fun>
 80228f4:	2800      	cmp	r0, #0
 80228f6:	d151      	bne.n	802299c <__hexnan+0xe8>
 80228f8:	9a04      	ldr	r2, [sp, #16]
 80228fa:	9905      	ldr	r1, [sp, #20]
 80228fc:	2a20      	cmp	r2, #32
 80228fe:	d818      	bhi.n	8022932 <__hexnan+0x7e>
 8022900:	9b02      	ldr	r3, [sp, #8]
 8022902:	459b      	cmp	fp, r3
 8022904:	dd13      	ble.n	802292e <__hexnan+0x7a>
 8022906:	454c      	cmp	r4, r9
 8022908:	d206      	bcs.n	8022918 <__hexnan+0x64>
 802290a:	2d07      	cmp	r5, #7
 802290c:	dc04      	bgt.n	8022918 <__hexnan+0x64>
 802290e:	462a      	mov	r2, r5
 8022910:	4649      	mov	r1, r9
 8022912:	4620      	mov	r0, r4
 8022914:	f7ff ffa8 	bl	8022868 <L_shift>
 8022918:	4544      	cmp	r4, r8
 802291a:	d952      	bls.n	80229c2 <__hexnan+0x10e>
 802291c:	2300      	movs	r3, #0
 802291e:	f1a4 0904 	sub.w	r9, r4, #4
 8022922:	f844 3c04 	str.w	r3, [r4, #-4]
 8022926:	f8cd b008 	str.w	fp, [sp, #8]
 802292a:	464c      	mov	r4, r9
 802292c:	461d      	mov	r5, r3
 802292e:	9903      	ldr	r1, [sp, #12]
 8022930:	e7d7      	b.n	80228e2 <__hexnan+0x2e>
 8022932:	2a29      	cmp	r2, #41	@ 0x29
 8022934:	d157      	bne.n	80229e6 <__hexnan+0x132>
 8022936:	3102      	adds	r1, #2
 8022938:	f8ca 1000 	str.w	r1, [sl]
 802293c:	f1bb 0f00 	cmp.w	fp, #0
 8022940:	d051      	beq.n	80229e6 <__hexnan+0x132>
 8022942:	454c      	cmp	r4, r9
 8022944:	d206      	bcs.n	8022954 <__hexnan+0xa0>
 8022946:	2d07      	cmp	r5, #7
 8022948:	dc04      	bgt.n	8022954 <__hexnan+0xa0>
 802294a:	462a      	mov	r2, r5
 802294c:	4649      	mov	r1, r9
 802294e:	4620      	mov	r0, r4
 8022950:	f7ff ff8a 	bl	8022868 <L_shift>
 8022954:	4544      	cmp	r4, r8
 8022956:	d936      	bls.n	80229c6 <__hexnan+0x112>
 8022958:	f1a8 0204 	sub.w	r2, r8, #4
 802295c:	4623      	mov	r3, r4
 802295e:	f853 1b04 	ldr.w	r1, [r3], #4
 8022962:	f842 1f04 	str.w	r1, [r2, #4]!
 8022966:	429f      	cmp	r7, r3
 8022968:	d2f9      	bcs.n	802295e <__hexnan+0xaa>
 802296a:	1b3b      	subs	r3, r7, r4
 802296c:	f023 0303 	bic.w	r3, r3, #3
 8022970:	3304      	adds	r3, #4
 8022972:	3401      	adds	r4, #1
 8022974:	3e03      	subs	r6, #3
 8022976:	42b4      	cmp	r4, r6
 8022978:	bf88      	it	hi
 802297a:	2304      	movhi	r3, #4
 802297c:	4443      	add	r3, r8
 802297e:	2200      	movs	r2, #0
 8022980:	f843 2b04 	str.w	r2, [r3], #4
 8022984:	429f      	cmp	r7, r3
 8022986:	d2fb      	bcs.n	8022980 <__hexnan+0xcc>
 8022988:	683b      	ldr	r3, [r7, #0]
 802298a:	b91b      	cbnz	r3, 8022994 <__hexnan+0xe0>
 802298c:	4547      	cmp	r7, r8
 802298e:	d128      	bne.n	80229e2 <__hexnan+0x12e>
 8022990:	2301      	movs	r3, #1
 8022992:	603b      	str	r3, [r7, #0]
 8022994:	2005      	movs	r0, #5
 8022996:	b007      	add	sp, #28
 8022998:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802299c:	3501      	adds	r5, #1
 802299e:	2d08      	cmp	r5, #8
 80229a0:	f10b 0b01 	add.w	fp, fp, #1
 80229a4:	dd06      	ble.n	80229b4 <__hexnan+0x100>
 80229a6:	4544      	cmp	r4, r8
 80229a8:	d9c1      	bls.n	802292e <__hexnan+0x7a>
 80229aa:	2300      	movs	r3, #0
 80229ac:	f844 3c04 	str.w	r3, [r4, #-4]
 80229b0:	2501      	movs	r5, #1
 80229b2:	3c04      	subs	r4, #4
 80229b4:	6822      	ldr	r2, [r4, #0]
 80229b6:	f000 000f 	and.w	r0, r0, #15
 80229ba:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
 80229be:	6020      	str	r0, [r4, #0]
 80229c0:	e7b5      	b.n	802292e <__hexnan+0x7a>
 80229c2:	2508      	movs	r5, #8
 80229c4:	e7b3      	b.n	802292e <__hexnan+0x7a>
 80229c6:	9b01      	ldr	r3, [sp, #4]
 80229c8:	2b00      	cmp	r3, #0
 80229ca:	d0dd      	beq.n	8022988 <__hexnan+0xd4>
 80229cc:	f1c3 0320 	rsb	r3, r3, #32
 80229d0:	f04f 32ff 	mov.w	r2, #4294967295
 80229d4:	40da      	lsrs	r2, r3
 80229d6:	f856 3c04 	ldr.w	r3, [r6, #-4]
 80229da:	4013      	ands	r3, r2
 80229dc:	f846 3c04 	str.w	r3, [r6, #-4]
 80229e0:	e7d2      	b.n	8022988 <__hexnan+0xd4>
 80229e2:	3f04      	subs	r7, #4
 80229e4:	e7d0      	b.n	8022988 <__hexnan+0xd4>
 80229e6:	2004      	movs	r0, #4
 80229e8:	e7d5      	b.n	8022996 <__hexnan+0xe2>

080229ea <__ascii_mbtowc>:
 80229ea:	b082      	sub	sp, #8
 80229ec:	b901      	cbnz	r1, 80229f0 <__ascii_mbtowc+0x6>
 80229ee:	a901      	add	r1, sp, #4
 80229f0:	b142      	cbz	r2, 8022a04 <__ascii_mbtowc+0x1a>
 80229f2:	b14b      	cbz	r3, 8022a08 <__ascii_mbtowc+0x1e>
 80229f4:	7813      	ldrb	r3, [r2, #0]
 80229f6:	600b      	str	r3, [r1, #0]
 80229f8:	7812      	ldrb	r2, [r2, #0]
 80229fa:	1e10      	subs	r0, r2, #0
 80229fc:	bf18      	it	ne
 80229fe:	2001      	movne	r0, #1
 8022a00:	b002      	add	sp, #8
 8022a02:	4770      	bx	lr
 8022a04:	4610      	mov	r0, r2
 8022a06:	e7fb      	b.n	8022a00 <__ascii_mbtowc+0x16>
 8022a08:	f06f 0001 	mvn.w	r0, #1
 8022a0c:	e7f8      	b.n	8022a00 <__ascii_mbtowc+0x16>
	...

08022a10 <_Balloc>:
 8022a10:	b570      	push	{r4, r5, r6, lr}
 8022a12:	69c6      	ldr	r6, [r0, #28]
 8022a14:	4604      	mov	r4, r0
 8022a16:	460d      	mov	r5, r1
 8022a18:	b976      	cbnz	r6, 8022a38 <_Balloc+0x28>
 8022a1a:	2010      	movs	r0, #16
 8022a1c:	f7fe f98c 	bl	8020d38 <malloc>
 8022a20:	4602      	mov	r2, r0
 8022a22:	61e0      	str	r0, [r4, #28]
 8022a24:	b920      	cbnz	r0, 8022a30 <_Balloc+0x20>
 8022a26:	4b18      	ldr	r3, [pc, #96]	@ (8022a88 <_Balloc+0x78>)
 8022a28:	4818      	ldr	r0, [pc, #96]	@ (8022a8c <_Balloc+0x7c>)
 8022a2a:	216b      	movs	r1, #107	@ 0x6b
 8022a2c:	f001 f8c4 	bl	8023bb8 <__assert_func>
 8022a30:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8022a34:	6006      	str	r6, [r0, #0]
 8022a36:	60c6      	str	r6, [r0, #12]
 8022a38:	69e6      	ldr	r6, [r4, #28]
 8022a3a:	68f3      	ldr	r3, [r6, #12]
 8022a3c:	b183      	cbz	r3, 8022a60 <_Balloc+0x50>
 8022a3e:	69e3      	ldr	r3, [r4, #28]
 8022a40:	68db      	ldr	r3, [r3, #12]
 8022a42:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 8022a46:	b9b8      	cbnz	r0, 8022a78 <_Balloc+0x68>
 8022a48:	2101      	movs	r1, #1
 8022a4a:	fa01 f605 	lsl.w	r6, r1, r5
 8022a4e:	1d72      	adds	r2, r6, #5
 8022a50:	0092      	lsls	r2, r2, #2
 8022a52:	4620      	mov	r0, r4
 8022a54:	f001 f8ce 	bl	8023bf4 <_calloc_r>
 8022a58:	b160      	cbz	r0, 8022a74 <_Balloc+0x64>
 8022a5a:	e9c0 5601 	strd	r5, r6, [r0, #4]
 8022a5e:	e00e      	b.n	8022a7e <_Balloc+0x6e>
 8022a60:	2221      	movs	r2, #33	@ 0x21
 8022a62:	2104      	movs	r1, #4
 8022a64:	4620      	mov	r0, r4
 8022a66:	f001 f8c5 	bl	8023bf4 <_calloc_r>
 8022a6a:	69e3      	ldr	r3, [r4, #28]
 8022a6c:	60f0      	str	r0, [r6, #12]
 8022a6e:	68db      	ldr	r3, [r3, #12]
 8022a70:	2b00      	cmp	r3, #0
 8022a72:	d1e4      	bne.n	8022a3e <_Balloc+0x2e>
 8022a74:	2000      	movs	r0, #0
 8022a76:	bd70      	pop	{r4, r5, r6, pc}
 8022a78:	6802      	ldr	r2, [r0, #0]
 8022a7a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 8022a7e:	2300      	movs	r3, #0
 8022a80:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8022a84:	e7f7      	b.n	8022a76 <_Balloc+0x66>
 8022a86:	bf00      	nop
 8022a88:	08039472 	.word	0x08039472
 8022a8c:	08039489 	.word	0x08039489

08022a90 <_Bfree>:
 8022a90:	b570      	push	{r4, r5, r6, lr}
 8022a92:	69c6      	ldr	r6, [r0, #28]
 8022a94:	4605      	mov	r5, r0
 8022a96:	460c      	mov	r4, r1
 8022a98:	b976      	cbnz	r6, 8022ab8 <_Bfree+0x28>
 8022a9a:	2010      	movs	r0, #16
 8022a9c:	f7fe f94c 	bl	8020d38 <malloc>
 8022aa0:	4602      	mov	r2, r0
 8022aa2:	61e8      	str	r0, [r5, #28]
 8022aa4:	b920      	cbnz	r0, 8022ab0 <_Bfree+0x20>
 8022aa6:	4b09      	ldr	r3, [pc, #36]	@ (8022acc <_Bfree+0x3c>)
 8022aa8:	4809      	ldr	r0, [pc, #36]	@ (8022ad0 <_Bfree+0x40>)
 8022aaa:	218f      	movs	r1, #143	@ 0x8f
 8022aac:	f001 f884 	bl	8023bb8 <__assert_func>
 8022ab0:	e9c0 6601 	strd	r6, r6, [r0, #4]
 8022ab4:	6006      	str	r6, [r0, #0]
 8022ab6:	60c6      	str	r6, [r0, #12]
 8022ab8:	b13c      	cbz	r4, 8022aca <_Bfree+0x3a>
 8022aba:	69eb      	ldr	r3, [r5, #28]
 8022abc:	6862      	ldr	r2, [r4, #4]
 8022abe:	68db      	ldr	r3, [r3, #12]
 8022ac0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8022ac4:	6021      	str	r1, [r4, #0]
 8022ac6:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 8022aca:	bd70      	pop	{r4, r5, r6, pc}
 8022acc:	08039472 	.word	0x08039472
 8022ad0:	08039489 	.word	0x08039489

08022ad4 <__multadd>:
 8022ad4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022ad8:	690d      	ldr	r5, [r1, #16]
 8022ada:	4607      	mov	r7, r0
 8022adc:	460c      	mov	r4, r1
 8022ade:	461e      	mov	r6, r3
 8022ae0:	f101 0c14 	add.w	ip, r1, #20
 8022ae4:	2000      	movs	r0, #0
 8022ae6:	f8dc 3000 	ldr.w	r3, [ip]
 8022aea:	b299      	uxth	r1, r3
 8022aec:	fb02 6101 	mla	r1, r2, r1, r6
 8022af0:	0c1e      	lsrs	r6, r3, #16
 8022af2:	0c0b      	lsrs	r3, r1, #16
 8022af4:	fb02 3306 	mla	r3, r2, r6, r3
 8022af8:	b289      	uxth	r1, r1
 8022afa:	3001      	adds	r0, #1
 8022afc:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 8022b00:	4285      	cmp	r5, r0
 8022b02:	f84c 1b04 	str.w	r1, [ip], #4
 8022b06:	ea4f 4613 	mov.w	r6, r3, lsr #16
 8022b0a:	dcec      	bgt.n	8022ae6 <__multadd+0x12>
 8022b0c:	b30e      	cbz	r6, 8022b52 <__multadd+0x7e>
 8022b0e:	68a3      	ldr	r3, [r4, #8]
 8022b10:	42ab      	cmp	r3, r5
 8022b12:	dc19      	bgt.n	8022b48 <__multadd+0x74>
 8022b14:	6861      	ldr	r1, [r4, #4]
 8022b16:	4638      	mov	r0, r7
 8022b18:	3101      	adds	r1, #1
 8022b1a:	f7ff ff79 	bl	8022a10 <_Balloc>
 8022b1e:	4680      	mov	r8, r0
 8022b20:	b928      	cbnz	r0, 8022b2e <__multadd+0x5a>
 8022b22:	4602      	mov	r2, r0
 8022b24:	4b0c      	ldr	r3, [pc, #48]	@ (8022b58 <__multadd+0x84>)
 8022b26:	480d      	ldr	r0, [pc, #52]	@ (8022b5c <__multadd+0x88>)
 8022b28:	21ba      	movs	r1, #186	@ 0xba
 8022b2a:	f001 f845 	bl	8023bb8 <__assert_func>
 8022b2e:	6922      	ldr	r2, [r4, #16]
 8022b30:	3202      	adds	r2, #2
 8022b32:	f104 010c 	add.w	r1, r4, #12
 8022b36:	0092      	lsls	r2, r2, #2
 8022b38:	300c      	adds	r0, #12
 8022b3a:	f7ff fbb4 	bl	80222a6 <memcpy>
 8022b3e:	4621      	mov	r1, r4
 8022b40:	4638      	mov	r0, r7
 8022b42:	f7ff ffa5 	bl	8022a90 <_Bfree>
 8022b46:	4644      	mov	r4, r8
 8022b48:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 8022b4c:	3501      	adds	r5, #1
 8022b4e:	615e      	str	r6, [r3, #20]
 8022b50:	6125      	str	r5, [r4, #16]
 8022b52:	4620      	mov	r0, r4
 8022b54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8022b58:	08039401 	.word	0x08039401
 8022b5c:	08039489 	.word	0x08039489

08022b60 <__s2b>:
 8022b60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8022b64:	460c      	mov	r4, r1
 8022b66:	4615      	mov	r5, r2
 8022b68:	461f      	mov	r7, r3
 8022b6a:	2209      	movs	r2, #9
 8022b6c:	3308      	adds	r3, #8
 8022b6e:	4606      	mov	r6, r0
 8022b70:	fb93 f3f2 	sdiv	r3, r3, r2
 8022b74:	2100      	movs	r1, #0
 8022b76:	2201      	movs	r2, #1
 8022b78:	429a      	cmp	r2, r3
 8022b7a:	db09      	blt.n	8022b90 <__s2b+0x30>
 8022b7c:	4630      	mov	r0, r6
 8022b7e:	f7ff ff47 	bl	8022a10 <_Balloc>
 8022b82:	b940      	cbnz	r0, 8022b96 <__s2b+0x36>
 8022b84:	4602      	mov	r2, r0
 8022b86:	4b19      	ldr	r3, [pc, #100]	@ (8022bec <__s2b+0x8c>)
 8022b88:	4819      	ldr	r0, [pc, #100]	@ (8022bf0 <__s2b+0x90>)
 8022b8a:	21d3      	movs	r1, #211	@ 0xd3
 8022b8c:	f001 f814 	bl	8023bb8 <__assert_func>
 8022b90:	0052      	lsls	r2, r2, #1
 8022b92:	3101      	adds	r1, #1
 8022b94:	e7f0      	b.n	8022b78 <__s2b+0x18>
 8022b96:	9b08      	ldr	r3, [sp, #32]
 8022b98:	6143      	str	r3, [r0, #20]
 8022b9a:	2d09      	cmp	r5, #9
 8022b9c:	f04f 0301 	mov.w	r3, #1
 8022ba0:	6103      	str	r3, [r0, #16]
 8022ba2:	dd16      	ble.n	8022bd2 <__s2b+0x72>
 8022ba4:	f104 0909 	add.w	r9, r4, #9
 8022ba8:	46c8      	mov	r8, r9
 8022baa:	442c      	add	r4, r5
 8022bac:	f818 3b01 	ldrb.w	r3, [r8], #1
 8022bb0:	4601      	mov	r1, r0
 8022bb2:	3b30      	subs	r3, #48	@ 0x30
 8022bb4:	220a      	movs	r2, #10
 8022bb6:	4630      	mov	r0, r6
 8022bb8:	f7ff ff8c 	bl	8022ad4 <__multadd>
 8022bbc:	45a0      	cmp	r8, r4
 8022bbe:	d1f5      	bne.n	8022bac <__s2b+0x4c>
 8022bc0:	f1a5 0408 	sub.w	r4, r5, #8
 8022bc4:	444c      	add	r4, r9
 8022bc6:	1b2d      	subs	r5, r5, r4
 8022bc8:	1963      	adds	r3, r4, r5
 8022bca:	42bb      	cmp	r3, r7
 8022bcc:	db04      	blt.n	8022bd8 <__s2b+0x78>
 8022bce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022bd2:	340a      	adds	r4, #10
 8022bd4:	2509      	movs	r5, #9
 8022bd6:	e7f6      	b.n	8022bc6 <__s2b+0x66>
 8022bd8:	f814 3b01 	ldrb.w	r3, [r4], #1
 8022bdc:	4601      	mov	r1, r0
 8022bde:	3b30      	subs	r3, #48	@ 0x30
 8022be0:	220a      	movs	r2, #10
 8022be2:	4630      	mov	r0, r6
 8022be4:	f7ff ff76 	bl	8022ad4 <__multadd>
 8022be8:	e7ee      	b.n	8022bc8 <__s2b+0x68>
 8022bea:	bf00      	nop
 8022bec:	08039401 	.word	0x08039401
 8022bf0:	08039489 	.word	0x08039489

08022bf4 <__hi0bits>:
 8022bf4:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
 8022bf8:	4603      	mov	r3, r0
 8022bfa:	bf36      	itet	cc
 8022bfc:	0403      	lslcc	r3, r0, #16
 8022bfe:	2000      	movcs	r0, #0
 8022c00:	2010      	movcc	r0, #16
 8022c02:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8022c06:	bf3c      	itt	cc
 8022c08:	021b      	lslcc	r3, r3, #8
 8022c0a:	3008      	addcc	r0, #8
 8022c0c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8022c10:	bf3c      	itt	cc
 8022c12:	011b      	lslcc	r3, r3, #4
 8022c14:	3004      	addcc	r0, #4
 8022c16:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8022c1a:	bf3c      	itt	cc
 8022c1c:	009b      	lslcc	r3, r3, #2
 8022c1e:	3002      	addcc	r0, #2
 8022c20:	2b00      	cmp	r3, #0
 8022c22:	db05      	blt.n	8022c30 <__hi0bits+0x3c>
 8022c24:	f013 4f80 	tst.w	r3, #1073741824	@ 0x40000000
 8022c28:	f100 0001 	add.w	r0, r0, #1
 8022c2c:	bf08      	it	eq
 8022c2e:	2020      	moveq	r0, #32
 8022c30:	4770      	bx	lr

08022c32 <__lo0bits>:
 8022c32:	6803      	ldr	r3, [r0, #0]
 8022c34:	4602      	mov	r2, r0
 8022c36:	f013 0007 	ands.w	r0, r3, #7
 8022c3a:	d00b      	beq.n	8022c54 <__lo0bits+0x22>
 8022c3c:	07d9      	lsls	r1, r3, #31
 8022c3e:	d421      	bmi.n	8022c84 <__lo0bits+0x52>
 8022c40:	0798      	lsls	r0, r3, #30
 8022c42:	bf49      	itett	mi
 8022c44:	085b      	lsrmi	r3, r3, #1
 8022c46:	089b      	lsrpl	r3, r3, #2
 8022c48:	2001      	movmi	r0, #1
 8022c4a:	6013      	strmi	r3, [r2, #0]
 8022c4c:	bf5c      	itt	pl
 8022c4e:	6013      	strpl	r3, [r2, #0]
 8022c50:	2002      	movpl	r0, #2
 8022c52:	4770      	bx	lr
 8022c54:	b299      	uxth	r1, r3
 8022c56:	b909      	cbnz	r1, 8022c5c <__lo0bits+0x2a>
 8022c58:	0c1b      	lsrs	r3, r3, #16
 8022c5a:	2010      	movs	r0, #16
 8022c5c:	b2d9      	uxtb	r1, r3
 8022c5e:	b909      	cbnz	r1, 8022c64 <__lo0bits+0x32>
 8022c60:	3008      	adds	r0, #8
 8022c62:	0a1b      	lsrs	r3, r3, #8
 8022c64:	0719      	lsls	r1, r3, #28
 8022c66:	bf04      	itt	eq
 8022c68:	091b      	lsreq	r3, r3, #4
 8022c6a:	3004      	addeq	r0, #4
 8022c6c:	0799      	lsls	r1, r3, #30
 8022c6e:	bf04      	itt	eq
 8022c70:	089b      	lsreq	r3, r3, #2
 8022c72:	3002      	addeq	r0, #2
 8022c74:	07d9      	lsls	r1, r3, #31
 8022c76:	d403      	bmi.n	8022c80 <__lo0bits+0x4e>
 8022c78:	085b      	lsrs	r3, r3, #1
 8022c7a:	f100 0001 	add.w	r0, r0, #1
 8022c7e:	d003      	beq.n	8022c88 <__lo0bits+0x56>
 8022c80:	6013      	str	r3, [r2, #0]
 8022c82:	4770      	bx	lr
 8022c84:	2000      	movs	r0, #0
 8022c86:	4770      	bx	lr
 8022c88:	2020      	movs	r0, #32
 8022c8a:	4770      	bx	lr

08022c8c <__i2b>:
 8022c8c:	b510      	push	{r4, lr}
 8022c8e:	460c      	mov	r4, r1
 8022c90:	2101      	movs	r1, #1
 8022c92:	f7ff febd 	bl	8022a10 <_Balloc>
 8022c96:	4602      	mov	r2, r0
 8022c98:	b928      	cbnz	r0, 8022ca6 <__i2b+0x1a>
 8022c9a:	4b05      	ldr	r3, [pc, #20]	@ (8022cb0 <__i2b+0x24>)
 8022c9c:	4805      	ldr	r0, [pc, #20]	@ (8022cb4 <__i2b+0x28>)
 8022c9e:	f240 1145 	movw	r1, #325	@ 0x145
 8022ca2:	f000 ff89 	bl	8023bb8 <__assert_func>
 8022ca6:	2301      	movs	r3, #1
 8022ca8:	6144      	str	r4, [r0, #20]
 8022caa:	6103      	str	r3, [r0, #16]
 8022cac:	bd10      	pop	{r4, pc}
 8022cae:	bf00      	nop
 8022cb0:	08039401 	.word	0x08039401
 8022cb4:	08039489 	.word	0x08039489

08022cb8 <__multiply>:
 8022cb8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022cbc:	4614      	mov	r4, r2
 8022cbe:	690a      	ldr	r2, [r1, #16]
 8022cc0:	6923      	ldr	r3, [r4, #16]
 8022cc2:	429a      	cmp	r2, r3
 8022cc4:	bfa8      	it	ge
 8022cc6:	4623      	movge	r3, r4
 8022cc8:	460f      	mov	r7, r1
 8022cca:	bfa4      	itt	ge
 8022ccc:	460c      	movge	r4, r1
 8022cce:	461f      	movge	r7, r3
 8022cd0:	f8d4 a010 	ldr.w	sl, [r4, #16]
 8022cd4:	f8d7 9010 	ldr.w	r9, [r7, #16]
 8022cd8:	68a3      	ldr	r3, [r4, #8]
 8022cda:	6861      	ldr	r1, [r4, #4]
 8022cdc:	eb0a 0609 	add.w	r6, sl, r9
 8022ce0:	42b3      	cmp	r3, r6
 8022ce2:	b085      	sub	sp, #20
 8022ce4:	bfb8      	it	lt
 8022ce6:	3101      	addlt	r1, #1
 8022ce8:	f7ff fe92 	bl	8022a10 <_Balloc>
 8022cec:	b930      	cbnz	r0, 8022cfc <__multiply+0x44>
 8022cee:	4602      	mov	r2, r0
 8022cf0:	4b44      	ldr	r3, [pc, #272]	@ (8022e04 <__multiply+0x14c>)
 8022cf2:	4845      	ldr	r0, [pc, #276]	@ (8022e08 <__multiply+0x150>)
 8022cf4:	f44f 71b1 	mov.w	r1, #354	@ 0x162
 8022cf8:	f000 ff5e 	bl	8023bb8 <__assert_func>
 8022cfc:	f100 0514 	add.w	r5, r0, #20
 8022d00:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 8022d04:	462b      	mov	r3, r5
 8022d06:	2200      	movs	r2, #0
 8022d08:	4543      	cmp	r3, r8
 8022d0a:	d321      	bcc.n	8022d50 <__multiply+0x98>
 8022d0c:	f107 0114 	add.w	r1, r7, #20
 8022d10:	f104 0214 	add.w	r2, r4, #20
 8022d14:	eb02 028a 	add.w	r2, r2, sl, lsl #2
 8022d18:	eb01 0389 	add.w	r3, r1, r9, lsl #2
 8022d1c:	9302      	str	r3, [sp, #8]
 8022d1e:	1b13      	subs	r3, r2, r4
 8022d20:	3b15      	subs	r3, #21
 8022d22:	f023 0303 	bic.w	r3, r3, #3
 8022d26:	3304      	adds	r3, #4
 8022d28:	f104 0715 	add.w	r7, r4, #21
 8022d2c:	42ba      	cmp	r2, r7
 8022d2e:	bf38      	it	cc
 8022d30:	2304      	movcc	r3, #4
 8022d32:	9301      	str	r3, [sp, #4]
 8022d34:	9b02      	ldr	r3, [sp, #8]
 8022d36:	9103      	str	r1, [sp, #12]
 8022d38:	428b      	cmp	r3, r1
 8022d3a:	d80c      	bhi.n	8022d56 <__multiply+0x9e>
 8022d3c:	2e00      	cmp	r6, #0
 8022d3e:	dd03      	ble.n	8022d48 <__multiply+0x90>
 8022d40:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 8022d44:	2b00      	cmp	r3, #0
 8022d46:	d05b      	beq.n	8022e00 <__multiply+0x148>
 8022d48:	6106      	str	r6, [r0, #16]
 8022d4a:	b005      	add	sp, #20
 8022d4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022d50:	f843 2b04 	str.w	r2, [r3], #4
 8022d54:	e7d8      	b.n	8022d08 <__multiply+0x50>
 8022d56:	f8b1 a000 	ldrh.w	sl, [r1]
 8022d5a:	f1ba 0f00 	cmp.w	sl, #0
 8022d5e:	d024      	beq.n	8022daa <__multiply+0xf2>
 8022d60:	f104 0e14 	add.w	lr, r4, #20
 8022d64:	46a9      	mov	r9, r5
 8022d66:	f04f 0c00 	mov.w	ip, #0
 8022d6a:	f85e 7b04 	ldr.w	r7, [lr], #4
 8022d6e:	f8d9 3000 	ldr.w	r3, [r9]
 8022d72:	fa1f fb87 	uxth.w	fp, r7
 8022d76:	b29b      	uxth	r3, r3
 8022d78:	fb0a 330b 	mla	r3, sl, fp, r3
 8022d7c:	ea4f 4b17 	mov.w	fp, r7, lsr #16
 8022d80:	f8d9 7000 	ldr.w	r7, [r9]
 8022d84:	4463      	add	r3, ip
 8022d86:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 8022d8a:	fb0a c70b 	mla	r7, sl, fp, ip
 8022d8e:	eb07 4713 	add.w	r7, r7, r3, lsr #16
 8022d92:	b29b      	uxth	r3, r3
 8022d94:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 8022d98:	4572      	cmp	r2, lr
 8022d9a:	f849 3b04 	str.w	r3, [r9], #4
 8022d9e:	ea4f 4c17 	mov.w	ip, r7, lsr #16
 8022da2:	d8e2      	bhi.n	8022d6a <__multiply+0xb2>
 8022da4:	9b01      	ldr	r3, [sp, #4]
 8022da6:	f845 c003 	str.w	ip, [r5, r3]
 8022daa:	9b03      	ldr	r3, [sp, #12]
 8022dac:	f8b3 9002 	ldrh.w	r9, [r3, #2]
 8022db0:	3104      	adds	r1, #4
 8022db2:	f1b9 0f00 	cmp.w	r9, #0
 8022db6:	d021      	beq.n	8022dfc <__multiply+0x144>
 8022db8:	682b      	ldr	r3, [r5, #0]
 8022dba:	f104 0c14 	add.w	ip, r4, #20
 8022dbe:	46ae      	mov	lr, r5
 8022dc0:	f04f 0a00 	mov.w	sl, #0
 8022dc4:	f8bc b000 	ldrh.w	fp, [ip]
 8022dc8:	f8be 7002 	ldrh.w	r7, [lr, #2]
 8022dcc:	fb09 770b 	mla	r7, r9, fp, r7
 8022dd0:	4457      	add	r7, sl
 8022dd2:	b29b      	uxth	r3, r3
 8022dd4:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 8022dd8:	f84e 3b04 	str.w	r3, [lr], #4
 8022ddc:	f85c 3b04 	ldr.w	r3, [ip], #4
 8022de0:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 8022de4:	f8be 3000 	ldrh.w	r3, [lr]
 8022de8:	fb09 330a 	mla	r3, r9, sl, r3
 8022dec:	eb03 4317 	add.w	r3, r3, r7, lsr #16
 8022df0:	4562      	cmp	r2, ip
 8022df2:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 8022df6:	d8e5      	bhi.n	8022dc4 <__multiply+0x10c>
 8022df8:	9f01      	ldr	r7, [sp, #4]
 8022dfa:	51eb      	str	r3, [r5, r7]
 8022dfc:	3504      	adds	r5, #4
 8022dfe:	e799      	b.n	8022d34 <__multiply+0x7c>
 8022e00:	3e01      	subs	r6, #1
 8022e02:	e79b      	b.n	8022d3c <__multiply+0x84>
 8022e04:	08039401 	.word	0x08039401
 8022e08:	08039489 	.word	0x08039489

08022e0c <__pow5mult>:
 8022e0c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8022e10:	4615      	mov	r5, r2
 8022e12:	f012 0203 	ands.w	r2, r2, #3
 8022e16:	4607      	mov	r7, r0
 8022e18:	460e      	mov	r6, r1
 8022e1a:	d007      	beq.n	8022e2c <__pow5mult+0x20>
 8022e1c:	4c25      	ldr	r4, [pc, #148]	@ (8022eb4 <__pow5mult+0xa8>)
 8022e1e:	3a01      	subs	r2, #1
 8022e20:	2300      	movs	r3, #0
 8022e22:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8022e26:	f7ff fe55 	bl	8022ad4 <__multadd>
 8022e2a:	4606      	mov	r6, r0
 8022e2c:	10ad      	asrs	r5, r5, #2
 8022e2e:	d03d      	beq.n	8022eac <__pow5mult+0xa0>
 8022e30:	69fc      	ldr	r4, [r7, #28]
 8022e32:	b97c      	cbnz	r4, 8022e54 <__pow5mult+0x48>
 8022e34:	2010      	movs	r0, #16
 8022e36:	f7fd ff7f 	bl	8020d38 <malloc>
 8022e3a:	4602      	mov	r2, r0
 8022e3c:	61f8      	str	r0, [r7, #28]
 8022e3e:	b928      	cbnz	r0, 8022e4c <__pow5mult+0x40>
 8022e40:	4b1d      	ldr	r3, [pc, #116]	@ (8022eb8 <__pow5mult+0xac>)
 8022e42:	481e      	ldr	r0, [pc, #120]	@ (8022ebc <__pow5mult+0xb0>)
 8022e44:	f240 11b3 	movw	r1, #435	@ 0x1b3
 8022e48:	f000 feb6 	bl	8023bb8 <__assert_func>
 8022e4c:	e9c0 4401 	strd	r4, r4, [r0, #4]
 8022e50:	6004      	str	r4, [r0, #0]
 8022e52:	60c4      	str	r4, [r0, #12]
 8022e54:	f8d7 801c 	ldr.w	r8, [r7, #28]
 8022e58:	f8d8 4008 	ldr.w	r4, [r8, #8]
 8022e5c:	b94c      	cbnz	r4, 8022e72 <__pow5mult+0x66>
 8022e5e:	f240 2171 	movw	r1, #625	@ 0x271
 8022e62:	4638      	mov	r0, r7
 8022e64:	f7ff ff12 	bl	8022c8c <__i2b>
 8022e68:	2300      	movs	r3, #0
 8022e6a:	f8c8 0008 	str.w	r0, [r8, #8]
 8022e6e:	4604      	mov	r4, r0
 8022e70:	6003      	str	r3, [r0, #0]
 8022e72:	f04f 0900 	mov.w	r9, #0
 8022e76:	07eb      	lsls	r3, r5, #31
 8022e78:	d50a      	bpl.n	8022e90 <__pow5mult+0x84>
 8022e7a:	4631      	mov	r1, r6
 8022e7c:	4622      	mov	r2, r4
 8022e7e:	4638      	mov	r0, r7
 8022e80:	f7ff ff1a 	bl	8022cb8 <__multiply>
 8022e84:	4631      	mov	r1, r6
 8022e86:	4680      	mov	r8, r0
 8022e88:	4638      	mov	r0, r7
 8022e8a:	f7ff fe01 	bl	8022a90 <_Bfree>
 8022e8e:	4646      	mov	r6, r8
 8022e90:	106d      	asrs	r5, r5, #1
 8022e92:	d00b      	beq.n	8022eac <__pow5mult+0xa0>
 8022e94:	6820      	ldr	r0, [r4, #0]
 8022e96:	b938      	cbnz	r0, 8022ea8 <__pow5mult+0x9c>
 8022e98:	4622      	mov	r2, r4
 8022e9a:	4621      	mov	r1, r4
 8022e9c:	4638      	mov	r0, r7
 8022e9e:	f7ff ff0b 	bl	8022cb8 <__multiply>
 8022ea2:	6020      	str	r0, [r4, #0]
 8022ea4:	f8c0 9000 	str.w	r9, [r0]
 8022ea8:	4604      	mov	r4, r0
 8022eaa:	e7e4      	b.n	8022e76 <__pow5mult+0x6a>
 8022eac:	4630      	mov	r0, r6
 8022eae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8022eb2:	bf00      	nop
 8022eb4:	080394e4 	.word	0x080394e4
 8022eb8:	08039472 	.word	0x08039472
 8022ebc:	08039489 	.word	0x08039489

08022ec0 <__lshift>:
 8022ec0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8022ec4:	460c      	mov	r4, r1
 8022ec6:	6849      	ldr	r1, [r1, #4]
 8022ec8:	6923      	ldr	r3, [r4, #16]
 8022eca:	eb03 1862 	add.w	r8, r3, r2, asr #5
 8022ece:	68a3      	ldr	r3, [r4, #8]
 8022ed0:	4607      	mov	r7, r0
 8022ed2:	4691      	mov	r9, r2
 8022ed4:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8022ed8:	f108 0601 	add.w	r6, r8, #1
 8022edc:	42b3      	cmp	r3, r6
 8022ede:	db0b      	blt.n	8022ef8 <__lshift+0x38>
 8022ee0:	4638      	mov	r0, r7
 8022ee2:	f7ff fd95 	bl	8022a10 <_Balloc>
 8022ee6:	4605      	mov	r5, r0
 8022ee8:	b948      	cbnz	r0, 8022efe <__lshift+0x3e>
 8022eea:	4602      	mov	r2, r0
 8022eec:	4b28      	ldr	r3, [pc, #160]	@ (8022f90 <__lshift+0xd0>)
 8022eee:	4829      	ldr	r0, [pc, #164]	@ (8022f94 <__lshift+0xd4>)
 8022ef0:	f44f 71ef 	mov.w	r1, #478	@ 0x1de
 8022ef4:	f000 fe60 	bl	8023bb8 <__assert_func>
 8022ef8:	3101      	adds	r1, #1
 8022efa:	005b      	lsls	r3, r3, #1
 8022efc:	e7ee      	b.n	8022edc <__lshift+0x1c>
 8022efe:	2300      	movs	r3, #0
 8022f00:	f100 0114 	add.w	r1, r0, #20
 8022f04:	f100 0210 	add.w	r2, r0, #16
 8022f08:	4618      	mov	r0, r3
 8022f0a:	4553      	cmp	r3, sl
 8022f0c:	db33      	blt.n	8022f76 <__lshift+0xb6>
 8022f0e:	6920      	ldr	r0, [r4, #16]
 8022f10:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8022f14:	f104 0314 	add.w	r3, r4, #20
 8022f18:	f019 091f 	ands.w	r9, r9, #31
 8022f1c:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8022f20:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 8022f24:	d02b      	beq.n	8022f7e <__lshift+0xbe>
 8022f26:	f1c9 0e20 	rsb	lr, r9, #32
 8022f2a:	468a      	mov	sl, r1
 8022f2c:	2200      	movs	r2, #0
 8022f2e:	6818      	ldr	r0, [r3, #0]
 8022f30:	fa00 f009 	lsl.w	r0, r0, r9
 8022f34:	4310      	orrs	r0, r2
 8022f36:	f84a 0b04 	str.w	r0, [sl], #4
 8022f3a:	f853 2b04 	ldr.w	r2, [r3], #4
 8022f3e:	459c      	cmp	ip, r3
 8022f40:	fa22 f20e 	lsr.w	r2, r2, lr
 8022f44:	d8f3      	bhi.n	8022f2e <__lshift+0x6e>
 8022f46:	ebac 0304 	sub.w	r3, ip, r4
 8022f4a:	3b15      	subs	r3, #21
 8022f4c:	f023 0303 	bic.w	r3, r3, #3
 8022f50:	3304      	adds	r3, #4
 8022f52:	f104 0015 	add.w	r0, r4, #21
 8022f56:	4584      	cmp	ip, r0
 8022f58:	bf38      	it	cc
 8022f5a:	2304      	movcc	r3, #4
 8022f5c:	50ca      	str	r2, [r1, r3]
 8022f5e:	b10a      	cbz	r2, 8022f64 <__lshift+0xa4>
 8022f60:	f108 0602 	add.w	r6, r8, #2
 8022f64:	3e01      	subs	r6, #1
 8022f66:	4638      	mov	r0, r7
 8022f68:	612e      	str	r6, [r5, #16]
 8022f6a:	4621      	mov	r1, r4
 8022f6c:	f7ff fd90 	bl	8022a90 <_Bfree>
 8022f70:	4628      	mov	r0, r5
 8022f72:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8022f76:	f842 0f04 	str.w	r0, [r2, #4]!
 8022f7a:	3301      	adds	r3, #1
 8022f7c:	e7c5      	b.n	8022f0a <__lshift+0x4a>
 8022f7e:	3904      	subs	r1, #4
 8022f80:	f853 2b04 	ldr.w	r2, [r3], #4
 8022f84:	f841 2f04 	str.w	r2, [r1, #4]!
 8022f88:	459c      	cmp	ip, r3
 8022f8a:	d8f9      	bhi.n	8022f80 <__lshift+0xc0>
 8022f8c:	e7ea      	b.n	8022f64 <__lshift+0xa4>
 8022f8e:	bf00      	nop
 8022f90:	08039401 	.word	0x08039401
 8022f94:	08039489 	.word	0x08039489

08022f98 <__mcmp>:
 8022f98:	690a      	ldr	r2, [r1, #16]
 8022f9a:	4603      	mov	r3, r0
 8022f9c:	6900      	ldr	r0, [r0, #16]
 8022f9e:	1a80      	subs	r0, r0, r2
 8022fa0:	b530      	push	{r4, r5, lr}
 8022fa2:	d10e      	bne.n	8022fc2 <__mcmp+0x2a>
 8022fa4:	3314      	adds	r3, #20
 8022fa6:	3114      	adds	r1, #20
 8022fa8:	eb03 0482 	add.w	r4, r3, r2, lsl #2
 8022fac:	eb01 0182 	add.w	r1, r1, r2, lsl #2
 8022fb0:	f854 5d04 	ldr.w	r5, [r4, #-4]!
 8022fb4:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8022fb8:	4295      	cmp	r5, r2
 8022fba:	d003      	beq.n	8022fc4 <__mcmp+0x2c>
 8022fbc:	d205      	bcs.n	8022fca <__mcmp+0x32>
 8022fbe:	f04f 30ff 	mov.w	r0, #4294967295
 8022fc2:	bd30      	pop	{r4, r5, pc}
 8022fc4:	42a3      	cmp	r3, r4
 8022fc6:	d3f3      	bcc.n	8022fb0 <__mcmp+0x18>
 8022fc8:	e7fb      	b.n	8022fc2 <__mcmp+0x2a>
 8022fca:	2001      	movs	r0, #1
 8022fcc:	e7f9      	b.n	8022fc2 <__mcmp+0x2a>
	...

08022fd0 <__mdiff>:
 8022fd0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022fd4:	4689      	mov	r9, r1
 8022fd6:	4606      	mov	r6, r0
 8022fd8:	4611      	mov	r1, r2
 8022fda:	4648      	mov	r0, r9
 8022fdc:	4614      	mov	r4, r2
 8022fde:	f7ff ffdb 	bl	8022f98 <__mcmp>
 8022fe2:	1e05      	subs	r5, r0, #0
 8022fe4:	d112      	bne.n	802300c <__mdiff+0x3c>
 8022fe6:	4629      	mov	r1, r5
 8022fe8:	4630      	mov	r0, r6
 8022fea:	f7ff fd11 	bl	8022a10 <_Balloc>
 8022fee:	4602      	mov	r2, r0
 8022ff0:	b928      	cbnz	r0, 8022ffe <__mdiff+0x2e>
 8022ff2:	4b3f      	ldr	r3, [pc, #252]	@ (80230f0 <__mdiff+0x120>)
 8022ff4:	f240 2137 	movw	r1, #567	@ 0x237
 8022ff8:	483e      	ldr	r0, [pc, #248]	@ (80230f4 <__mdiff+0x124>)
 8022ffa:	f000 fddd 	bl	8023bb8 <__assert_func>
 8022ffe:	2301      	movs	r3, #1
 8023000:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8023004:	4610      	mov	r0, r2
 8023006:	b003      	add	sp, #12
 8023008:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802300c:	bfbc      	itt	lt
 802300e:	464b      	movlt	r3, r9
 8023010:	46a1      	movlt	r9, r4
 8023012:	4630      	mov	r0, r6
 8023014:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8023018:	bfba      	itte	lt
 802301a:	461c      	movlt	r4, r3
 802301c:	2501      	movlt	r5, #1
 802301e:	2500      	movge	r5, #0
 8023020:	f7ff fcf6 	bl	8022a10 <_Balloc>
 8023024:	4602      	mov	r2, r0
 8023026:	b918      	cbnz	r0, 8023030 <__mdiff+0x60>
 8023028:	4b31      	ldr	r3, [pc, #196]	@ (80230f0 <__mdiff+0x120>)
 802302a:	f240 2145 	movw	r1, #581	@ 0x245
 802302e:	e7e3      	b.n	8022ff8 <__mdiff+0x28>
 8023030:	f8d9 7010 	ldr.w	r7, [r9, #16]
 8023034:	6926      	ldr	r6, [r4, #16]
 8023036:	60c5      	str	r5, [r0, #12]
 8023038:	f109 0310 	add.w	r3, r9, #16
 802303c:	f109 0514 	add.w	r5, r9, #20
 8023040:	f104 0e14 	add.w	lr, r4, #20
 8023044:	f100 0b14 	add.w	fp, r0, #20
 8023048:	eb05 0887 	add.w	r8, r5, r7, lsl #2
 802304c:	eb0e 0686 	add.w	r6, lr, r6, lsl #2
 8023050:	9301      	str	r3, [sp, #4]
 8023052:	46d9      	mov	r9, fp
 8023054:	f04f 0c00 	mov.w	ip, #0
 8023058:	9b01      	ldr	r3, [sp, #4]
 802305a:	f85e 0b04 	ldr.w	r0, [lr], #4
 802305e:	f853 af04 	ldr.w	sl, [r3, #4]!
 8023062:	9301      	str	r3, [sp, #4]
 8023064:	fa1f f38a 	uxth.w	r3, sl
 8023068:	4619      	mov	r1, r3
 802306a:	b283      	uxth	r3, r0
 802306c:	1acb      	subs	r3, r1, r3
 802306e:	0c00      	lsrs	r0, r0, #16
 8023070:	4463      	add	r3, ip
 8023072:	ebc0 401a 	rsb	r0, r0, sl, lsr #16
 8023076:	eb00 4023 	add.w	r0, r0, r3, asr #16
 802307a:	b29b      	uxth	r3, r3
 802307c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
 8023080:	4576      	cmp	r6, lr
 8023082:	f849 3b04 	str.w	r3, [r9], #4
 8023086:	ea4f 4c20 	mov.w	ip, r0, asr #16
 802308a:	d8e5      	bhi.n	8023058 <__mdiff+0x88>
 802308c:	1b33      	subs	r3, r6, r4
 802308e:	3b15      	subs	r3, #21
 8023090:	f023 0303 	bic.w	r3, r3, #3
 8023094:	3415      	adds	r4, #21
 8023096:	3304      	adds	r3, #4
 8023098:	42a6      	cmp	r6, r4
 802309a:	bf38      	it	cc
 802309c:	2304      	movcc	r3, #4
 802309e:	441d      	add	r5, r3
 80230a0:	445b      	add	r3, fp
 80230a2:	461e      	mov	r6, r3
 80230a4:	462c      	mov	r4, r5
 80230a6:	4544      	cmp	r4, r8
 80230a8:	d30e      	bcc.n	80230c8 <__mdiff+0xf8>
 80230aa:	f108 0103 	add.w	r1, r8, #3
 80230ae:	1b49      	subs	r1, r1, r5
 80230b0:	f021 0103 	bic.w	r1, r1, #3
 80230b4:	3d03      	subs	r5, #3
 80230b6:	45a8      	cmp	r8, r5
 80230b8:	bf38      	it	cc
 80230ba:	2100      	movcc	r1, #0
 80230bc:	440b      	add	r3, r1
 80230be:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 80230c2:	b191      	cbz	r1, 80230ea <__mdiff+0x11a>
 80230c4:	6117      	str	r7, [r2, #16]
 80230c6:	e79d      	b.n	8023004 <__mdiff+0x34>
 80230c8:	f854 1b04 	ldr.w	r1, [r4], #4
 80230cc:	46e6      	mov	lr, ip
 80230ce:	0c08      	lsrs	r0, r1, #16
 80230d0:	fa1c fc81 	uxtah	ip, ip, r1
 80230d4:	4471      	add	r1, lr
 80230d6:	eb00 402c 	add.w	r0, r0, ip, asr #16
 80230da:	b289      	uxth	r1, r1
 80230dc:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 80230e0:	f846 1b04 	str.w	r1, [r6], #4
 80230e4:	ea4f 4c20 	mov.w	ip, r0, asr #16
 80230e8:	e7dd      	b.n	80230a6 <__mdiff+0xd6>
 80230ea:	3f01      	subs	r7, #1
 80230ec:	e7e7      	b.n	80230be <__mdiff+0xee>
 80230ee:	bf00      	nop
 80230f0:	08039401 	.word	0x08039401
 80230f4:	08039489 	.word	0x08039489

080230f8 <__ulp>:
 80230f8:	b082      	sub	sp, #8
 80230fa:	ed8d 0b00 	vstr	d0, [sp]
 80230fe:	9a01      	ldr	r2, [sp, #4]
 8023100:	4b0f      	ldr	r3, [pc, #60]	@ (8023140 <__ulp+0x48>)
 8023102:	4013      	ands	r3, r2
 8023104:	f1a3 7350 	sub.w	r3, r3, #54525952	@ 0x3400000
 8023108:	2b00      	cmp	r3, #0
 802310a:	dc08      	bgt.n	802311e <__ulp+0x26>
 802310c:	425b      	negs	r3, r3
 802310e:	f1b3 7fa0 	cmp.w	r3, #20971520	@ 0x1400000
 8023112:	ea4f 5223 	mov.w	r2, r3, asr #20
 8023116:	da04      	bge.n	8023122 <__ulp+0x2a>
 8023118:	f44f 2300 	mov.w	r3, #524288	@ 0x80000
 802311c:	4113      	asrs	r3, r2
 802311e:	2200      	movs	r2, #0
 8023120:	e008      	b.n	8023134 <__ulp+0x3c>
 8023122:	f1a2 0314 	sub.w	r3, r2, #20
 8023126:	2b1e      	cmp	r3, #30
 8023128:	bfda      	itte	le
 802312a:	f04f 4200 	movle.w	r2, #2147483648	@ 0x80000000
 802312e:	40da      	lsrle	r2, r3
 8023130:	2201      	movgt	r2, #1
 8023132:	2300      	movs	r3, #0
 8023134:	4619      	mov	r1, r3
 8023136:	4610      	mov	r0, r2
 8023138:	ec41 0b10 	vmov	d0, r0, r1
 802313c:	b002      	add	sp, #8
 802313e:	4770      	bx	lr
 8023140:	7ff00000 	.word	0x7ff00000

08023144 <__b2d>:
 8023144:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023148:	6906      	ldr	r6, [r0, #16]
 802314a:	f100 0814 	add.w	r8, r0, #20
 802314e:	eb08 0686 	add.w	r6, r8, r6, lsl #2
 8023152:	1f37      	subs	r7, r6, #4
 8023154:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8023158:	4610      	mov	r0, r2
 802315a:	f7ff fd4b 	bl	8022bf4 <__hi0bits>
 802315e:	f1c0 0320 	rsb	r3, r0, #32
 8023162:	280a      	cmp	r0, #10
 8023164:	600b      	str	r3, [r1, #0]
 8023166:	491b      	ldr	r1, [pc, #108]	@ (80231d4 <__b2d+0x90>)
 8023168:	dc15      	bgt.n	8023196 <__b2d+0x52>
 802316a:	f1c0 0c0b 	rsb	ip, r0, #11
 802316e:	fa22 f30c 	lsr.w	r3, r2, ip
 8023172:	45b8      	cmp	r8, r7
 8023174:	ea43 0501 	orr.w	r5, r3, r1
 8023178:	bf34      	ite	cc
 802317a:	f856 3c08 	ldrcc.w	r3, [r6, #-8]
 802317e:	2300      	movcs	r3, #0
 8023180:	3015      	adds	r0, #21
 8023182:	fa02 f000 	lsl.w	r0, r2, r0
 8023186:	fa23 f30c 	lsr.w	r3, r3, ip
 802318a:	4303      	orrs	r3, r0
 802318c:	461c      	mov	r4, r3
 802318e:	ec45 4b10 	vmov	d0, r4, r5
 8023192:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023196:	45b8      	cmp	r8, r7
 8023198:	bf3a      	itte	cc
 802319a:	f856 3c08 	ldrcc.w	r3, [r6, #-8]
 802319e:	f1a6 0708 	subcc.w	r7, r6, #8
 80231a2:	2300      	movcs	r3, #0
 80231a4:	380b      	subs	r0, #11
 80231a6:	d012      	beq.n	80231ce <__b2d+0x8a>
 80231a8:	f1c0 0120 	rsb	r1, r0, #32
 80231ac:	fa23 f401 	lsr.w	r4, r3, r1
 80231b0:	4082      	lsls	r2, r0
 80231b2:	4322      	orrs	r2, r4
 80231b4:	4547      	cmp	r7, r8
 80231b6:	f042 557f 	orr.w	r5, r2, #1069547520	@ 0x3fc00000
 80231ba:	bf8c      	ite	hi
 80231bc:	f857 2c04 	ldrhi.w	r2, [r7, #-4]
 80231c0:	2200      	movls	r2, #0
 80231c2:	4083      	lsls	r3, r0
 80231c4:	40ca      	lsrs	r2, r1
 80231c6:	f445 1540 	orr.w	r5, r5, #3145728	@ 0x300000
 80231ca:	4313      	orrs	r3, r2
 80231cc:	e7de      	b.n	802318c <__b2d+0x48>
 80231ce:	ea42 0501 	orr.w	r5, r2, r1
 80231d2:	e7db      	b.n	802318c <__b2d+0x48>
 80231d4:	3ff00000 	.word	0x3ff00000

080231d8 <__d2b>:
 80231d8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80231dc:	460f      	mov	r7, r1
 80231de:	2101      	movs	r1, #1
 80231e0:	ec59 8b10 	vmov	r8, r9, d0
 80231e4:	4616      	mov	r6, r2
 80231e6:	f7ff fc13 	bl	8022a10 <_Balloc>
 80231ea:	4604      	mov	r4, r0
 80231ec:	b930      	cbnz	r0, 80231fc <__d2b+0x24>
 80231ee:	4602      	mov	r2, r0
 80231f0:	4b23      	ldr	r3, [pc, #140]	@ (8023280 <__d2b+0xa8>)
 80231f2:	4824      	ldr	r0, [pc, #144]	@ (8023284 <__d2b+0xac>)
 80231f4:	f240 310f 	movw	r1, #783	@ 0x30f
 80231f8:	f000 fcde 	bl	8023bb8 <__assert_func>
 80231fc:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8023200:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8023204:	b10d      	cbz	r5, 802320a <__d2b+0x32>
 8023206:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 802320a:	9301      	str	r3, [sp, #4]
 802320c:	f1b8 0300 	subs.w	r3, r8, #0
 8023210:	d023      	beq.n	802325a <__d2b+0x82>
 8023212:	4668      	mov	r0, sp
 8023214:	9300      	str	r3, [sp, #0]
 8023216:	f7ff fd0c 	bl	8022c32 <__lo0bits>
 802321a:	e9dd 1200 	ldrd	r1, r2, [sp]
 802321e:	b1d0      	cbz	r0, 8023256 <__d2b+0x7e>
 8023220:	f1c0 0320 	rsb	r3, r0, #32
 8023224:	fa02 f303 	lsl.w	r3, r2, r3
 8023228:	430b      	orrs	r3, r1
 802322a:	40c2      	lsrs	r2, r0
 802322c:	6163      	str	r3, [r4, #20]
 802322e:	9201      	str	r2, [sp, #4]
 8023230:	9b01      	ldr	r3, [sp, #4]
 8023232:	61a3      	str	r3, [r4, #24]
 8023234:	2b00      	cmp	r3, #0
 8023236:	bf0c      	ite	eq
 8023238:	2201      	moveq	r2, #1
 802323a:	2202      	movne	r2, #2
 802323c:	6122      	str	r2, [r4, #16]
 802323e:	b1a5      	cbz	r5, 802326a <__d2b+0x92>
 8023240:	f2a5 4533 	subw	r5, r5, #1075	@ 0x433
 8023244:	4405      	add	r5, r0
 8023246:	603d      	str	r5, [r7, #0]
 8023248:	f1c0 0035 	rsb	r0, r0, #53	@ 0x35
 802324c:	6030      	str	r0, [r6, #0]
 802324e:	4620      	mov	r0, r4
 8023250:	b003      	add	sp, #12
 8023252:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8023256:	6161      	str	r1, [r4, #20]
 8023258:	e7ea      	b.n	8023230 <__d2b+0x58>
 802325a:	a801      	add	r0, sp, #4
 802325c:	f7ff fce9 	bl	8022c32 <__lo0bits>
 8023260:	9b01      	ldr	r3, [sp, #4]
 8023262:	6163      	str	r3, [r4, #20]
 8023264:	3020      	adds	r0, #32
 8023266:	2201      	movs	r2, #1
 8023268:	e7e8      	b.n	802323c <__d2b+0x64>
 802326a:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 802326e:	f2a0 4032 	subw	r0, r0, #1074	@ 0x432
 8023272:	6038      	str	r0, [r7, #0]
 8023274:	6918      	ldr	r0, [r3, #16]
 8023276:	f7ff fcbd 	bl	8022bf4 <__hi0bits>
 802327a:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 802327e:	e7e5      	b.n	802324c <__d2b+0x74>
 8023280:	08039401 	.word	0x08039401
 8023284:	08039489 	.word	0x08039489

08023288 <__ratio>:
 8023288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802328c:	b085      	sub	sp, #20
 802328e:	e9cd 1000 	strd	r1, r0, [sp]
 8023292:	a902      	add	r1, sp, #8
 8023294:	f7ff ff56 	bl	8023144 <__b2d>
 8023298:	9800      	ldr	r0, [sp, #0]
 802329a:	a903      	add	r1, sp, #12
 802329c:	ec55 4b10 	vmov	r4, r5, d0
 80232a0:	f7ff ff50 	bl	8023144 <__b2d>
 80232a4:	9b01      	ldr	r3, [sp, #4]
 80232a6:	6919      	ldr	r1, [r3, #16]
 80232a8:	9b00      	ldr	r3, [sp, #0]
 80232aa:	691b      	ldr	r3, [r3, #16]
 80232ac:	1ac9      	subs	r1, r1, r3
 80232ae:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 80232b2:	1a9b      	subs	r3, r3, r2
 80232b4:	ec5b ab10 	vmov	sl, fp, d0
 80232b8:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 80232bc:	2b00      	cmp	r3, #0
 80232be:	bfce      	itee	gt
 80232c0:	462a      	movgt	r2, r5
 80232c2:	ebc3 3303 	rsble	r3, r3, r3, lsl #12
 80232c6:	465a      	movle	r2, fp
 80232c8:	462f      	mov	r7, r5
 80232ca:	46d9      	mov	r9, fp
 80232cc:	bfcc      	ite	gt
 80232ce:	eb02 5703 	addgt.w	r7, r2, r3, lsl #20
 80232d2:	eb02 5903 	addle.w	r9, r2, r3, lsl #20
 80232d6:	464b      	mov	r3, r9
 80232d8:	4652      	mov	r2, sl
 80232da:	4620      	mov	r0, r4
 80232dc:	4639      	mov	r1, r7
 80232de:	f7dd fb25 	bl	800092c <__aeabi_ddiv>
 80232e2:	ec41 0b10 	vmov	d0, r0, r1
 80232e6:	b005      	add	sp, #20
 80232e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080232ec <__copybits>:
 80232ec:	3901      	subs	r1, #1
 80232ee:	b570      	push	{r4, r5, r6, lr}
 80232f0:	1149      	asrs	r1, r1, #5
 80232f2:	6914      	ldr	r4, [r2, #16]
 80232f4:	3101      	adds	r1, #1
 80232f6:	f102 0314 	add.w	r3, r2, #20
 80232fa:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80232fe:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8023302:	1f05      	subs	r5, r0, #4
 8023304:	42a3      	cmp	r3, r4
 8023306:	d30c      	bcc.n	8023322 <__copybits+0x36>
 8023308:	1aa3      	subs	r3, r4, r2
 802330a:	3b11      	subs	r3, #17
 802330c:	f023 0303 	bic.w	r3, r3, #3
 8023310:	3211      	adds	r2, #17
 8023312:	42a2      	cmp	r2, r4
 8023314:	bf88      	it	hi
 8023316:	2300      	movhi	r3, #0
 8023318:	4418      	add	r0, r3
 802331a:	2300      	movs	r3, #0
 802331c:	4288      	cmp	r0, r1
 802331e:	d305      	bcc.n	802332c <__copybits+0x40>
 8023320:	bd70      	pop	{r4, r5, r6, pc}
 8023322:	f853 6b04 	ldr.w	r6, [r3], #4
 8023326:	f845 6f04 	str.w	r6, [r5, #4]!
 802332a:	e7eb      	b.n	8023304 <__copybits+0x18>
 802332c:	f840 3b04 	str.w	r3, [r0], #4
 8023330:	e7f4      	b.n	802331c <__copybits+0x30>

08023332 <__any_on>:
 8023332:	f100 0214 	add.w	r2, r0, #20
 8023336:	6900      	ldr	r0, [r0, #16]
 8023338:	114b      	asrs	r3, r1, #5
 802333a:	4298      	cmp	r0, r3
 802333c:	b510      	push	{r4, lr}
 802333e:	db11      	blt.n	8023364 <__any_on+0x32>
 8023340:	dd0a      	ble.n	8023358 <__any_on+0x26>
 8023342:	f011 011f 	ands.w	r1, r1, #31
 8023346:	d007      	beq.n	8023358 <__any_on+0x26>
 8023348:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
 802334c:	fa24 f001 	lsr.w	r0, r4, r1
 8023350:	fa00 f101 	lsl.w	r1, r0, r1
 8023354:	428c      	cmp	r4, r1
 8023356:	d10b      	bne.n	8023370 <__any_on+0x3e>
 8023358:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802335c:	4293      	cmp	r3, r2
 802335e:	d803      	bhi.n	8023368 <__any_on+0x36>
 8023360:	2000      	movs	r0, #0
 8023362:	bd10      	pop	{r4, pc}
 8023364:	4603      	mov	r3, r0
 8023366:	e7f7      	b.n	8023358 <__any_on+0x26>
 8023368:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 802336c:	2900      	cmp	r1, #0
 802336e:	d0f5      	beq.n	802335c <__any_on+0x2a>
 8023370:	2001      	movs	r0, #1
 8023372:	e7f6      	b.n	8023362 <__any_on+0x30>

08023374 <__ascii_wctomb>:
 8023374:	4603      	mov	r3, r0
 8023376:	4608      	mov	r0, r1
 8023378:	b141      	cbz	r1, 802338c <__ascii_wctomb+0x18>
 802337a:	2aff      	cmp	r2, #255	@ 0xff
 802337c:	d904      	bls.n	8023388 <__ascii_wctomb+0x14>
 802337e:	228a      	movs	r2, #138	@ 0x8a
 8023380:	601a      	str	r2, [r3, #0]
 8023382:	f04f 30ff 	mov.w	r0, #4294967295
 8023386:	4770      	bx	lr
 8023388:	700a      	strb	r2, [r1, #0]
 802338a:	2001      	movs	r0, #1
 802338c:	4770      	bx	lr

0802338e <__ssputs_r>:
 802338e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023392:	688e      	ldr	r6, [r1, #8]
 8023394:	461f      	mov	r7, r3
 8023396:	42be      	cmp	r6, r7
 8023398:	680b      	ldr	r3, [r1, #0]
 802339a:	4682      	mov	sl, r0
 802339c:	460c      	mov	r4, r1
 802339e:	4690      	mov	r8, r2
 80233a0:	d82d      	bhi.n	80233fe <__ssputs_r+0x70>
 80233a2:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 80233a6:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 80233aa:	d026      	beq.n	80233fa <__ssputs_r+0x6c>
 80233ac:	6965      	ldr	r5, [r4, #20]
 80233ae:	6909      	ldr	r1, [r1, #16]
 80233b0:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80233b4:	eba3 0901 	sub.w	r9, r3, r1
 80233b8:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 80233bc:	1c7b      	adds	r3, r7, #1
 80233be:	444b      	add	r3, r9
 80233c0:	106d      	asrs	r5, r5, #1
 80233c2:	429d      	cmp	r5, r3
 80233c4:	bf38      	it	cc
 80233c6:	461d      	movcc	r5, r3
 80233c8:	0553      	lsls	r3, r2, #21
 80233ca:	d527      	bpl.n	802341c <__ssputs_r+0x8e>
 80233cc:	4629      	mov	r1, r5
 80233ce:	f7fd fce5 	bl	8020d9c <_malloc_r>
 80233d2:	4606      	mov	r6, r0
 80233d4:	b360      	cbz	r0, 8023430 <__ssputs_r+0xa2>
 80233d6:	6921      	ldr	r1, [r4, #16]
 80233d8:	464a      	mov	r2, r9
 80233da:	f7fe ff64 	bl	80222a6 <memcpy>
 80233de:	89a3      	ldrh	r3, [r4, #12]
 80233e0:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 80233e4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 80233e8:	81a3      	strh	r3, [r4, #12]
 80233ea:	6126      	str	r6, [r4, #16]
 80233ec:	6165      	str	r5, [r4, #20]
 80233ee:	444e      	add	r6, r9
 80233f0:	eba5 0509 	sub.w	r5, r5, r9
 80233f4:	6026      	str	r6, [r4, #0]
 80233f6:	60a5      	str	r5, [r4, #8]
 80233f8:	463e      	mov	r6, r7
 80233fa:	42be      	cmp	r6, r7
 80233fc:	d900      	bls.n	8023400 <__ssputs_r+0x72>
 80233fe:	463e      	mov	r6, r7
 8023400:	6820      	ldr	r0, [r4, #0]
 8023402:	4632      	mov	r2, r6
 8023404:	4641      	mov	r1, r8
 8023406:	f7fe fe63 	bl	80220d0 <memmove>
 802340a:	68a3      	ldr	r3, [r4, #8]
 802340c:	1b9b      	subs	r3, r3, r6
 802340e:	60a3      	str	r3, [r4, #8]
 8023410:	6823      	ldr	r3, [r4, #0]
 8023412:	4433      	add	r3, r6
 8023414:	6023      	str	r3, [r4, #0]
 8023416:	2000      	movs	r0, #0
 8023418:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802341c:	462a      	mov	r2, r5
 802341e:	f000 fbfd 	bl	8023c1c <_realloc_r>
 8023422:	4606      	mov	r6, r0
 8023424:	2800      	cmp	r0, #0
 8023426:	d1e0      	bne.n	80233ea <__ssputs_r+0x5c>
 8023428:	6921      	ldr	r1, [r4, #16]
 802342a:	4650      	mov	r0, sl
 802342c:	f7fe ff5a 	bl	80222e4 <_free_r>
 8023430:	230c      	movs	r3, #12
 8023432:	f8ca 3000 	str.w	r3, [sl]
 8023436:	89a3      	ldrh	r3, [r4, #12]
 8023438:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 802343c:	81a3      	strh	r3, [r4, #12]
 802343e:	f04f 30ff 	mov.w	r0, #4294967295
 8023442:	e7e9      	b.n	8023418 <__ssputs_r+0x8a>

08023444 <_svfiprintf_r>:
 8023444:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023448:	4698      	mov	r8, r3
 802344a:	898b      	ldrh	r3, [r1, #12]
 802344c:	061b      	lsls	r3, r3, #24
 802344e:	b09d      	sub	sp, #116	@ 0x74
 8023450:	4607      	mov	r7, r0
 8023452:	460d      	mov	r5, r1
 8023454:	4614      	mov	r4, r2
 8023456:	d510      	bpl.n	802347a <_svfiprintf_r+0x36>
 8023458:	690b      	ldr	r3, [r1, #16]
 802345a:	b973      	cbnz	r3, 802347a <_svfiprintf_r+0x36>
 802345c:	2140      	movs	r1, #64	@ 0x40
 802345e:	f7fd fc9d 	bl	8020d9c <_malloc_r>
 8023462:	6028      	str	r0, [r5, #0]
 8023464:	6128      	str	r0, [r5, #16]
 8023466:	b930      	cbnz	r0, 8023476 <_svfiprintf_r+0x32>
 8023468:	230c      	movs	r3, #12
 802346a:	603b      	str	r3, [r7, #0]
 802346c:	f04f 30ff 	mov.w	r0, #4294967295
 8023470:	b01d      	add	sp, #116	@ 0x74
 8023472:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023476:	2340      	movs	r3, #64	@ 0x40
 8023478:	616b      	str	r3, [r5, #20]
 802347a:	2300      	movs	r3, #0
 802347c:	9309      	str	r3, [sp, #36]	@ 0x24
 802347e:	2320      	movs	r3, #32
 8023480:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8023484:	f8cd 800c 	str.w	r8, [sp, #12]
 8023488:	2330      	movs	r3, #48	@ 0x30
 802348a:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 8023628 <_svfiprintf_r+0x1e4>
 802348e:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8023492:	f04f 0901 	mov.w	r9, #1
 8023496:	4623      	mov	r3, r4
 8023498:	469a      	mov	sl, r3
 802349a:	f813 2b01 	ldrb.w	r2, [r3], #1
 802349e:	b10a      	cbz	r2, 80234a4 <_svfiprintf_r+0x60>
 80234a0:	2a25      	cmp	r2, #37	@ 0x25
 80234a2:	d1f9      	bne.n	8023498 <_svfiprintf_r+0x54>
 80234a4:	ebba 0b04 	subs.w	fp, sl, r4
 80234a8:	d00b      	beq.n	80234c2 <_svfiprintf_r+0x7e>
 80234aa:	465b      	mov	r3, fp
 80234ac:	4622      	mov	r2, r4
 80234ae:	4629      	mov	r1, r5
 80234b0:	4638      	mov	r0, r7
 80234b2:	f7ff ff6c 	bl	802338e <__ssputs_r>
 80234b6:	3001      	adds	r0, #1
 80234b8:	f000 80a7 	beq.w	802360a <_svfiprintf_r+0x1c6>
 80234bc:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80234be:	445a      	add	r2, fp
 80234c0:	9209      	str	r2, [sp, #36]	@ 0x24
 80234c2:	f89a 3000 	ldrb.w	r3, [sl]
 80234c6:	2b00      	cmp	r3, #0
 80234c8:	f000 809f 	beq.w	802360a <_svfiprintf_r+0x1c6>
 80234cc:	2300      	movs	r3, #0
 80234ce:	f04f 32ff 	mov.w	r2, #4294967295
 80234d2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80234d6:	f10a 0a01 	add.w	sl, sl, #1
 80234da:	9304      	str	r3, [sp, #16]
 80234dc:	9307      	str	r3, [sp, #28]
 80234de:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 80234e2:	931a      	str	r3, [sp, #104]	@ 0x68
 80234e4:	4654      	mov	r4, sl
 80234e6:	2205      	movs	r2, #5
 80234e8:	f814 1b01 	ldrb.w	r1, [r4], #1
 80234ec:	484e      	ldr	r0, [pc, #312]	@ (8023628 <_svfiprintf_r+0x1e4>)
 80234ee:	f7dc fee7 	bl	80002c0 <memchr>
 80234f2:	9a04      	ldr	r2, [sp, #16]
 80234f4:	b9d8      	cbnz	r0, 802352e <_svfiprintf_r+0xea>
 80234f6:	06d0      	lsls	r0, r2, #27
 80234f8:	bf44      	itt	mi
 80234fa:	2320      	movmi	r3, #32
 80234fc:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8023500:	0711      	lsls	r1, r2, #28
 8023502:	bf44      	itt	mi
 8023504:	232b      	movmi	r3, #43	@ 0x2b
 8023506:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 802350a:	f89a 3000 	ldrb.w	r3, [sl]
 802350e:	2b2a      	cmp	r3, #42	@ 0x2a
 8023510:	d015      	beq.n	802353e <_svfiprintf_r+0xfa>
 8023512:	9a07      	ldr	r2, [sp, #28]
 8023514:	4654      	mov	r4, sl
 8023516:	2000      	movs	r0, #0
 8023518:	f04f 0c0a 	mov.w	ip, #10
 802351c:	4621      	mov	r1, r4
 802351e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8023522:	3b30      	subs	r3, #48	@ 0x30
 8023524:	2b09      	cmp	r3, #9
 8023526:	d94b      	bls.n	80235c0 <_svfiprintf_r+0x17c>
 8023528:	b1b0      	cbz	r0, 8023558 <_svfiprintf_r+0x114>
 802352a:	9207      	str	r2, [sp, #28]
 802352c:	e014      	b.n	8023558 <_svfiprintf_r+0x114>
 802352e:	eba0 0308 	sub.w	r3, r0, r8
 8023532:	fa09 f303 	lsl.w	r3, r9, r3
 8023536:	4313      	orrs	r3, r2
 8023538:	9304      	str	r3, [sp, #16]
 802353a:	46a2      	mov	sl, r4
 802353c:	e7d2      	b.n	80234e4 <_svfiprintf_r+0xa0>
 802353e:	9b03      	ldr	r3, [sp, #12]
 8023540:	1d19      	adds	r1, r3, #4
 8023542:	681b      	ldr	r3, [r3, #0]
 8023544:	9103      	str	r1, [sp, #12]
 8023546:	2b00      	cmp	r3, #0
 8023548:	bfbb      	ittet	lt
 802354a:	425b      	neglt	r3, r3
 802354c:	f042 0202 	orrlt.w	r2, r2, #2
 8023550:	9307      	strge	r3, [sp, #28]
 8023552:	9307      	strlt	r3, [sp, #28]
 8023554:	bfb8      	it	lt
 8023556:	9204      	strlt	r2, [sp, #16]
 8023558:	7823      	ldrb	r3, [r4, #0]
 802355a:	2b2e      	cmp	r3, #46	@ 0x2e
 802355c:	d10a      	bne.n	8023574 <_svfiprintf_r+0x130>
 802355e:	7863      	ldrb	r3, [r4, #1]
 8023560:	2b2a      	cmp	r3, #42	@ 0x2a
 8023562:	d132      	bne.n	80235ca <_svfiprintf_r+0x186>
 8023564:	9b03      	ldr	r3, [sp, #12]
 8023566:	1d1a      	adds	r2, r3, #4
 8023568:	681b      	ldr	r3, [r3, #0]
 802356a:	9203      	str	r2, [sp, #12]
 802356c:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8023570:	3402      	adds	r4, #2
 8023572:	9305      	str	r3, [sp, #20]
 8023574:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 8023638 <_svfiprintf_r+0x1f4>
 8023578:	7821      	ldrb	r1, [r4, #0]
 802357a:	2203      	movs	r2, #3
 802357c:	4650      	mov	r0, sl
 802357e:	f7dc fe9f 	bl	80002c0 <memchr>
 8023582:	b138      	cbz	r0, 8023594 <_svfiprintf_r+0x150>
 8023584:	9b04      	ldr	r3, [sp, #16]
 8023586:	eba0 000a 	sub.w	r0, r0, sl
 802358a:	2240      	movs	r2, #64	@ 0x40
 802358c:	4082      	lsls	r2, r0
 802358e:	4313      	orrs	r3, r2
 8023590:	3401      	adds	r4, #1
 8023592:	9304      	str	r3, [sp, #16]
 8023594:	f814 1b01 	ldrb.w	r1, [r4], #1
 8023598:	4824      	ldr	r0, [pc, #144]	@ (802362c <_svfiprintf_r+0x1e8>)
 802359a:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 802359e:	2206      	movs	r2, #6
 80235a0:	f7dc fe8e 	bl	80002c0 <memchr>
 80235a4:	2800      	cmp	r0, #0
 80235a6:	d036      	beq.n	8023616 <_svfiprintf_r+0x1d2>
 80235a8:	4b21      	ldr	r3, [pc, #132]	@ (8023630 <_svfiprintf_r+0x1ec>)
 80235aa:	bb1b      	cbnz	r3, 80235f4 <_svfiprintf_r+0x1b0>
 80235ac:	9b03      	ldr	r3, [sp, #12]
 80235ae:	3307      	adds	r3, #7
 80235b0:	f023 0307 	bic.w	r3, r3, #7
 80235b4:	3308      	adds	r3, #8
 80235b6:	9303      	str	r3, [sp, #12]
 80235b8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80235ba:	4433      	add	r3, r6
 80235bc:	9309      	str	r3, [sp, #36]	@ 0x24
 80235be:	e76a      	b.n	8023496 <_svfiprintf_r+0x52>
 80235c0:	fb0c 3202 	mla	r2, ip, r2, r3
 80235c4:	460c      	mov	r4, r1
 80235c6:	2001      	movs	r0, #1
 80235c8:	e7a8      	b.n	802351c <_svfiprintf_r+0xd8>
 80235ca:	2300      	movs	r3, #0
 80235cc:	3401      	adds	r4, #1
 80235ce:	9305      	str	r3, [sp, #20]
 80235d0:	4619      	mov	r1, r3
 80235d2:	f04f 0c0a 	mov.w	ip, #10
 80235d6:	4620      	mov	r0, r4
 80235d8:	f810 2b01 	ldrb.w	r2, [r0], #1
 80235dc:	3a30      	subs	r2, #48	@ 0x30
 80235de:	2a09      	cmp	r2, #9
 80235e0:	d903      	bls.n	80235ea <_svfiprintf_r+0x1a6>
 80235e2:	2b00      	cmp	r3, #0
 80235e4:	d0c6      	beq.n	8023574 <_svfiprintf_r+0x130>
 80235e6:	9105      	str	r1, [sp, #20]
 80235e8:	e7c4      	b.n	8023574 <_svfiprintf_r+0x130>
 80235ea:	fb0c 2101 	mla	r1, ip, r1, r2
 80235ee:	4604      	mov	r4, r0
 80235f0:	2301      	movs	r3, #1
 80235f2:	e7f0      	b.n	80235d6 <_svfiprintf_r+0x192>
 80235f4:	ab03      	add	r3, sp, #12
 80235f6:	9300      	str	r3, [sp, #0]
 80235f8:	462a      	mov	r2, r5
 80235fa:	4b0e      	ldr	r3, [pc, #56]	@ (8023634 <_svfiprintf_r+0x1f0>)
 80235fc:	a904      	add	r1, sp, #16
 80235fe:	4638      	mov	r0, r7
 8023600:	f3af 8000 	nop.w
 8023604:	1c42      	adds	r2, r0, #1
 8023606:	4606      	mov	r6, r0
 8023608:	d1d6      	bne.n	80235b8 <_svfiprintf_r+0x174>
 802360a:	89ab      	ldrh	r3, [r5, #12]
 802360c:	065b      	lsls	r3, r3, #25
 802360e:	f53f af2d 	bmi.w	802346c <_svfiprintf_r+0x28>
 8023612:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8023614:	e72c      	b.n	8023470 <_svfiprintf_r+0x2c>
 8023616:	ab03      	add	r3, sp, #12
 8023618:	9300      	str	r3, [sp, #0]
 802361a:	462a      	mov	r2, r5
 802361c:	4b05      	ldr	r3, [pc, #20]	@ (8023634 <_svfiprintf_r+0x1f0>)
 802361e:	a904      	add	r1, sp, #16
 8023620:	4638      	mov	r0, r7
 8023622:	f000 f879 	bl	8023718 <_printf_i>
 8023626:	e7ed      	b.n	8023604 <_svfiprintf_r+0x1c0>
 8023628:	080395e0 	.word	0x080395e0
 802362c:	080395ea 	.word	0x080395ea
 8023630:	00000000 	.word	0x00000000
 8023634:	0802338f 	.word	0x0802338f
 8023638:	080395e6 	.word	0x080395e6

0802363c <_printf_common>:
 802363c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8023640:	4616      	mov	r6, r2
 8023642:	4698      	mov	r8, r3
 8023644:	688a      	ldr	r2, [r1, #8]
 8023646:	690b      	ldr	r3, [r1, #16]
 8023648:	f8dd 9020 	ldr.w	r9, [sp, #32]
 802364c:	4293      	cmp	r3, r2
 802364e:	bfb8      	it	lt
 8023650:	4613      	movlt	r3, r2
 8023652:	6033      	str	r3, [r6, #0]
 8023654:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8023658:	4607      	mov	r7, r0
 802365a:	460c      	mov	r4, r1
 802365c:	b10a      	cbz	r2, 8023662 <_printf_common+0x26>
 802365e:	3301      	adds	r3, #1
 8023660:	6033      	str	r3, [r6, #0]
 8023662:	6823      	ldr	r3, [r4, #0]
 8023664:	0699      	lsls	r1, r3, #26
 8023666:	bf42      	ittt	mi
 8023668:	6833      	ldrmi	r3, [r6, #0]
 802366a:	3302      	addmi	r3, #2
 802366c:	6033      	strmi	r3, [r6, #0]
 802366e:	6825      	ldr	r5, [r4, #0]
 8023670:	f015 0506 	ands.w	r5, r5, #6
 8023674:	d106      	bne.n	8023684 <_printf_common+0x48>
 8023676:	f104 0a19 	add.w	sl, r4, #25
 802367a:	68e3      	ldr	r3, [r4, #12]
 802367c:	6832      	ldr	r2, [r6, #0]
 802367e:	1a9b      	subs	r3, r3, r2
 8023680:	42ab      	cmp	r3, r5
 8023682:	dc26      	bgt.n	80236d2 <_printf_common+0x96>
 8023684:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 8023688:	6822      	ldr	r2, [r4, #0]
 802368a:	3b00      	subs	r3, #0
 802368c:	bf18      	it	ne
 802368e:	2301      	movne	r3, #1
 8023690:	0692      	lsls	r2, r2, #26
 8023692:	d42b      	bmi.n	80236ec <_printf_common+0xb0>
 8023694:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8023698:	4641      	mov	r1, r8
 802369a:	4638      	mov	r0, r7
 802369c:	47c8      	blx	r9
 802369e:	3001      	adds	r0, #1
 80236a0:	d01e      	beq.n	80236e0 <_printf_common+0xa4>
 80236a2:	6823      	ldr	r3, [r4, #0]
 80236a4:	6922      	ldr	r2, [r4, #16]
 80236a6:	f003 0306 	and.w	r3, r3, #6
 80236aa:	2b04      	cmp	r3, #4
 80236ac:	bf02      	ittt	eq
 80236ae:	68e5      	ldreq	r5, [r4, #12]
 80236b0:	6833      	ldreq	r3, [r6, #0]
 80236b2:	1aed      	subeq	r5, r5, r3
 80236b4:	68a3      	ldr	r3, [r4, #8]
 80236b6:	bf0c      	ite	eq
 80236b8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80236bc:	2500      	movne	r5, #0
 80236be:	4293      	cmp	r3, r2
 80236c0:	bfc4      	itt	gt
 80236c2:	1a9b      	subgt	r3, r3, r2
 80236c4:	18ed      	addgt	r5, r5, r3
 80236c6:	2600      	movs	r6, #0
 80236c8:	341a      	adds	r4, #26
 80236ca:	42b5      	cmp	r5, r6
 80236cc:	d11a      	bne.n	8023704 <_printf_common+0xc8>
 80236ce:	2000      	movs	r0, #0
 80236d0:	e008      	b.n	80236e4 <_printf_common+0xa8>
 80236d2:	2301      	movs	r3, #1
 80236d4:	4652      	mov	r2, sl
 80236d6:	4641      	mov	r1, r8
 80236d8:	4638      	mov	r0, r7
 80236da:	47c8      	blx	r9
 80236dc:	3001      	adds	r0, #1
 80236de:	d103      	bne.n	80236e8 <_printf_common+0xac>
 80236e0:	f04f 30ff 	mov.w	r0, #4294967295
 80236e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80236e8:	3501      	adds	r5, #1
 80236ea:	e7c6      	b.n	802367a <_printf_common+0x3e>
 80236ec:	18e1      	adds	r1, r4, r3
 80236ee:	1c5a      	adds	r2, r3, #1
 80236f0:	2030      	movs	r0, #48	@ 0x30
 80236f2:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 80236f6:	4422      	add	r2, r4
 80236f8:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 80236fc:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8023700:	3302      	adds	r3, #2
 8023702:	e7c7      	b.n	8023694 <_printf_common+0x58>
 8023704:	2301      	movs	r3, #1
 8023706:	4622      	mov	r2, r4
 8023708:	4641      	mov	r1, r8
 802370a:	4638      	mov	r0, r7
 802370c:	47c8      	blx	r9
 802370e:	3001      	adds	r0, #1
 8023710:	d0e6      	beq.n	80236e0 <_printf_common+0xa4>
 8023712:	3601      	adds	r6, #1
 8023714:	e7d9      	b.n	80236ca <_printf_common+0x8e>
	...

08023718 <_printf_i>:
 8023718:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 802371c:	7e0f      	ldrb	r7, [r1, #24]
 802371e:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8023720:	2f78      	cmp	r7, #120	@ 0x78
 8023722:	4691      	mov	r9, r2
 8023724:	4680      	mov	r8, r0
 8023726:	460c      	mov	r4, r1
 8023728:	469a      	mov	sl, r3
 802372a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 802372e:	d807      	bhi.n	8023740 <_printf_i+0x28>
 8023730:	2f62      	cmp	r7, #98	@ 0x62
 8023732:	d80a      	bhi.n	802374a <_printf_i+0x32>
 8023734:	2f00      	cmp	r7, #0
 8023736:	f000 80d2 	beq.w	80238de <_printf_i+0x1c6>
 802373a:	2f58      	cmp	r7, #88	@ 0x58
 802373c:	f000 80b9 	beq.w	80238b2 <_printf_i+0x19a>
 8023740:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8023744:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8023748:	e03a      	b.n	80237c0 <_printf_i+0xa8>
 802374a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 802374e:	2b15      	cmp	r3, #21
 8023750:	d8f6      	bhi.n	8023740 <_printf_i+0x28>
 8023752:	a101      	add	r1, pc, #4	@ (adr r1, 8023758 <_printf_i+0x40>)
 8023754:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8023758:	080237b1 	.word	0x080237b1
 802375c:	080237c5 	.word	0x080237c5
 8023760:	08023741 	.word	0x08023741
 8023764:	08023741 	.word	0x08023741
 8023768:	08023741 	.word	0x08023741
 802376c:	08023741 	.word	0x08023741
 8023770:	080237c5 	.word	0x080237c5
 8023774:	08023741 	.word	0x08023741
 8023778:	08023741 	.word	0x08023741
 802377c:	08023741 	.word	0x08023741
 8023780:	08023741 	.word	0x08023741
 8023784:	080238c5 	.word	0x080238c5
 8023788:	080237ef 	.word	0x080237ef
 802378c:	0802387f 	.word	0x0802387f
 8023790:	08023741 	.word	0x08023741
 8023794:	08023741 	.word	0x08023741
 8023798:	080238e7 	.word	0x080238e7
 802379c:	08023741 	.word	0x08023741
 80237a0:	080237ef 	.word	0x080237ef
 80237a4:	08023741 	.word	0x08023741
 80237a8:	08023741 	.word	0x08023741
 80237ac:	08023887 	.word	0x08023887
 80237b0:	6833      	ldr	r3, [r6, #0]
 80237b2:	1d1a      	adds	r2, r3, #4
 80237b4:	681b      	ldr	r3, [r3, #0]
 80237b6:	6032      	str	r2, [r6, #0]
 80237b8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 80237bc:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 80237c0:	2301      	movs	r3, #1
 80237c2:	e09d      	b.n	8023900 <_printf_i+0x1e8>
 80237c4:	6833      	ldr	r3, [r6, #0]
 80237c6:	6820      	ldr	r0, [r4, #0]
 80237c8:	1d19      	adds	r1, r3, #4
 80237ca:	6031      	str	r1, [r6, #0]
 80237cc:	0606      	lsls	r6, r0, #24
 80237ce:	d501      	bpl.n	80237d4 <_printf_i+0xbc>
 80237d0:	681d      	ldr	r5, [r3, #0]
 80237d2:	e003      	b.n	80237dc <_printf_i+0xc4>
 80237d4:	0645      	lsls	r5, r0, #25
 80237d6:	d5fb      	bpl.n	80237d0 <_printf_i+0xb8>
 80237d8:	f9b3 5000 	ldrsh.w	r5, [r3]
 80237dc:	2d00      	cmp	r5, #0
 80237de:	da03      	bge.n	80237e8 <_printf_i+0xd0>
 80237e0:	232d      	movs	r3, #45	@ 0x2d
 80237e2:	426d      	negs	r5, r5
 80237e4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 80237e8:	4859      	ldr	r0, [pc, #356]	@ (8023950 <_printf_i+0x238>)
 80237ea:	230a      	movs	r3, #10
 80237ec:	e011      	b.n	8023812 <_printf_i+0xfa>
 80237ee:	6821      	ldr	r1, [r4, #0]
 80237f0:	6833      	ldr	r3, [r6, #0]
 80237f2:	0608      	lsls	r0, r1, #24
 80237f4:	f853 5b04 	ldr.w	r5, [r3], #4
 80237f8:	d402      	bmi.n	8023800 <_printf_i+0xe8>
 80237fa:	0649      	lsls	r1, r1, #25
 80237fc:	bf48      	it	mi
 80237fe:	b2ad      	uxthmi	r5, r5
 8023800:	2f6f      	cmp	r7, #111	@ 0x6f
 8023802:	4853      	ldr	r0, [pc, #332]	@ (8023950 <_printf_i+0x238>)
 8023804:	6033      	str	r3, [r6, #0]
 8023806:	bf14      	ite	ne
 8023808:	230a      	movne	r3, #10
 802380a:	2308      	moveq	r3, #8
 802380c:	2100      	movs	r1, #0
 802380e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8023812:	6866      	ldr	r6, [r4, #4]
 8023814:	60a6      	str	r6, [r4, #8]
 8023816:	2e00      	cmp	r6, #0
 8023818:	bfa2      	ittt	ge
 802381a:	6821      	ldrge	r1, [r4, #0]
 802381c:	f021 0104 	bicge.w	r1, r1, #4
 8023820:	6021      	strge	r1, [r4, #0]
 8023822:	b90d      	cbnz	r5, 8023828 <_printf_i+0x110>
 8023824:	2e00      	cmp	r6, #0
 8023826:	d04b      	beq.n	80238c0 <_printf_i+0x1a8>
 8023828:	4616      	mov	r6, r2
 802382a:	fbb5 f1f3 	udiv	r1, r5, r3
 802382e:	fb03 5711 	mls	r7, r3, r1, r5
 8023832:	5dc7      	ldrb	r7, [r0, r7]
 8023834:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8023838:	462f      	mov	r7, r5
 802383a:	42bb      	cmp	r3, r7
 802383c:	460d      	mov	r5, r1
 802383e:	d9f4      	bls.n	802382a <_printf_i+0x112>
 8023840:	2b08      	cmp	r3, #8
 8023842:	d10b      	bne.n	802385c <_printf_i+0x144>
 8023844:	6823      	ldr	r3, [r4, #0]
 8023846:	07df      	lsls	r7, r3, #31
 8023848:	d508      	bpl.n	802385c <_printf_i+0x144>
 802384a:	6923      	ldr	r3, [r4, #16]
 802384c:	6861      	ldr	r1, [r4, #4]
 802384e:	4299      	cmp	r1, r3
 8023850:	bfde      	ittt	le
 8023852:	2330      	movle	r3, #48	@ 0x30
 8023854:	f806 3c01 	strble.w	r3, [r6, #-1]
 8023858:	f106 36ff 	addle.w	r6, r6, #4294967295
 802385c:	1b92      	subs	r2, r2, r6
 802385e:	6122      	str	r2, [r4, #16]
 8023860:	f8cd a000 	str.w	sl, [sp]
 8023864:	464b      	mov	r3, r9
 8023866:	aa03      	add	r2, sp, #12
 8023868:	4621      	mov	r1, r4
 802386a:	4640      	mov	r0, r8
 802386c:	f7ff fee6 	bl	802363c <_printf_common>
 8023870:	3001      	adds	r0, #1
 8023872:	d14a      	bne.n	802390a <_printf_i+0x1f2>
 8023874:	f04f 30ff 	mov.w	r0, #4294967295
 8023878:	b004      	add	sp, #16
 802387a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802387e:	6823      	ldr	r3, [r4, #0]
 8023880:	f043 0320 	orr.w	r3, r3, #32
 8023884:	6023      	str	r3, [r4, #0]
 8023886:	4833      	ldr	r0, [pc, #204]	@ (8023954 <_printf_i+0x23c>)
 8023888:	2778      	movs	r7, #120	@ 0x78
 802388a:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 802388e:	6823      	ldr	r3, [r4, #0]
 8023890:	6831      	ldr	r1, [r6, #0]
 8023892:	061f      	lsls	r7, r3, #24
 8023894:	f851 5b04 	ldr.w	r5, [r1], #4
 8023898:	d402      	bmi.n	80238a0 <_printf_i+0x188>
 802389a:	065f      	lsls	r7, r3, #25
 802389c:	bf48      	it	mi
 802389e:	b2ad      	uxthmi	r5, r5
 80238a0:	6031      	str	r1, [r6, #0]
 80238a2:	07d9      	lsls	r1, r3, #31
 80238a4:	bf44      	itt	mi
 80238a6:	f043 0320 	orrmi.w	r3, r3, #32
 80238aa:	6023      	strmi	r3, [r4, #0]
 80238ac:	b11d      	cbz	r5, 80238b6 <_printf_i+0x19e>
 80238ae:	2310      	movs	r3, #16
 80238b0:	e7ac      	b.n	802380c <_printf_i+0xf4>
 80238b2:	4827      	ldr	r0, [pc, #156]	@ (8023950 <_printf_i+0x238>)
 80238b4:	e7e9      	b.n	802388a <_printf_i+0x172>
 80238b6:	6823      	ldr	r3, [r4, #0]
 80238b8:	f023 0320 	bic.w	r3, r3, #32
 80238bc:	6023      	str	r3, [r4, #0]
 80238be:	e7f6      	b.n	80238ae <_printf_i+0x196>
 80238c0:	4616      	mov	r6, r2
 80238c2:	e7bd      	b.n	8023840 <_printf_i+0x128>
 80238c4:	6833      	ldr	r3, [r6, #0]
 80238c6:	6825      	ldr	r5, [r4, #0]
 80238c8:	6961      	ldr	r1, [r4, #20]
 80238ca:	1d18      	adds	r0, r3, #4
 80238cc:	6030      	str	r0, [r6, #0]
 80238ce:	062e      	lsls	r6, r5, #24
 80238d0:	681b      	ldr	r3, [r3, #0]
 80238d2:	d501      	bpl.n	80238d8 <_printf_i+0x1c0>
 80238d4:	6019      	str	r1, [r3, #0]
 80238d6:	e002      	b.n	80238de <_printf_i+0x1c6>
 80238d8:	0668      	lsls	r0, r5, #25
 80238da:	d5fb      	bpl.n	80238d4 <_printf_i+0x1bc>
 80238dc:	8019      	strh	r1, [r3, #0]
 80238de:	2300      	movs	r3, #0
 80238e0:	6123      	str	r3, [r4, #16]
 80238e2:	4616      	mov	r6, r2
 80238e4:	e7bc      	b.n	8023860 <_printf_i+0x148>
 80238e6:	6833      	ldr	r3, [r6, #0]
 80238e8:	1d1a      	adds	r2, r3, #4
 80238ea:	6032      	str	r2, [r6, #0]
 80238ec:	681e      	ldr	r6, [r3, #0]
 80238ee:	6862      	ldr	r2, [r4, #4]
 80238f0:	2100      	movs	r1, #0
 80238f2:	4630      	mov	r0, r6
 80238f4:	f7dc fce4 	bl	80002c0 <memchr>
 80238f8:	b108      	cbz	r0, 80238fe <_printf_i+0x1e6>
 80238fa:	1b80      	subs	r0, r0, r6
 80238fc:	6060      	str	r0, [r4, #4]
 80238fe:	6863      	ldr	r3, [r4, #4]
 8023900:	6123      	str	r3, [r4, #16]
 8023902:	2300      	movs	r3, #0
 8023904:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8023908:	e7aa      	b.n	8023860 <_printf_i+0x148>
 802390a:	6923      	ldr	r3, [r4, #16]
 802390c:	4632      	mov	r2, r6
 802390e:	4649      	mov	r1, r9
 8023910:	4640      	mov	r0, r8
 8023912:	47d0      	blx	sl
 8023914:	3001      	adds	r0, #1
 8023916:	d0ad      	beq.n	8023874 <_printf_i+0x15c>
 8023918:	6823      	ldr	r3, [r4, #0]
 802391a:	079b      	lsls	r3, r3, #30
 802391c:	d413      	bmi.n	8023946 <_printf_i+0x22e>
 802391e:	68e0      	ldr	r0, [r4, #12]
 8023920:	9b03      	ldr	r3, [sp, #12]
 8023922:	4298      	cmp	r0, r3
 8023924:	bfb8      	it	lt
 8023926:	4618      	movlt	r0, r3
 8023928:	e7a6      	b.n	8023878 <_printf_i+0x160>
 802392a:	2301      	movs	r3, #1
 802392c:	4632      	mov	r2, r6
 802392e:	4649      	mov	r1, r9
 8023930:	4640      	mov	r0, r8
 8023932:	47d0      	blx	sl
 8023934:	3001      	adds	r0, #1
 8023936:	d09d      	beq.n	8023874 <_printf_i+0x15c>
 8023938:	3501      	adds	r5, #1
 802393a:	68e3      	ldr	r3, [r4, #12]
 802393c:	9903      	ldr	r1, [sp, #12]
 802393e:	1a5b      	subs	r3, r3, r1
 8023940:	42ab      	cmp	r3, r5
 8023942:	dcf2      	bgt.n	802392a <_printf_i+0x212>
 8023944:	e7eb      	b.n	802391e <_printf_i+0x206>
 8023946:	2500      	movs	r5, #0
 8023948:	f104 0619 	add.w	r6, r4, #25
 802394c:	e7f5      	b.n	802393a <_printf_i+0x222>
 802394e:	bf00      	nop
 8023950:	080395f1 	.word	0x080395f1
 8023954:	08039602 	.word	0x08039602

08023958 <__sflush_r>:
 8023958:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 802395c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023960:	0716      	lsls	r6, r2, #28
 8023962:	4605      	mov	r5, r0
 8023964:	460c      	mov	r4, r1
 8023966:	d454      	bmi.n	8023a12 <__sflush_r+0xba>
 8023968:	684b      	ldr	r3, [r1, #4]
 802396a:	2b00      	cmp	r3, #0
 802396c:	dc02      	bgt.n	8023974 <__sflush_r+0x1c>
 802396e:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8023970:	2b00      	cmp	r3, #0
 8023972:	dd48      	ble.n	8023a06 <__sflush_r+0xae>
 8023974:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8023976:	2e00      	cmp	r6, #0
 8023978:	d045      	beq.n	8023a06 <__sflush_r+0xae>
 802397a:	2300      	movs	r3, #0
 802397c:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 8023980:	682f      	ldr	r7, [r5, #0]
 8023982:	6a21      	ldr	r1, [r4, #32]
 8023984:	602b      	str	r3, [r5, #0]
 8023986:	d030      	beq.n	80239ea <__sflush_r+0x92>
 8023988:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 802398a:	89a3      	ldrh	r3, [r4, #12]
 802398c:	0759      	lsls	r1, r3, #29
 802398e:	d505      	bpl.n	802399c <__sflush_r+0x44>
 8023990:	6863      	ldr	r3, [r4, #4]
 8023992:	1ad2      	subs	r2, r2, r3
 8023994:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8023996:	b10b      	cbz	r3, 802399c <__sflush_r+0x44>
 8023998:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 802399a:	1ad2      	subs	r2, r2, r3
 802399c:	2300      	movs	r3, #0
 802399e:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 80239a0:	6a21      	ldr	r1, [r4, #32]
 80239a2:	4628      	mov	r0, r5
 80239a4:	47b0      	blx	r6
 80239a6:	1c43      	adds	r3, r0, #1
 80239a8:	89a3      	ldrh	r3, [r4, #12]
 80239aa:	d106      	bne.n	80239ba <__sflush_r+0x62>
 80239ac:	6829      	ldr	r1, [r5, #0]
 80239ae:	291d      	cmp	r1, #29
 80239b0:	d82b      	bhi.n	8023a0a <__sflush_r+0xb2>
 80239b2:	4a2a      	ldr	r2, [pc, #168]	@ (8023a5c <__sflush_r+0x104>)
 80239b4:	410a      	asrs	r2, r1
 80239b6:	07d6      	lsls	r6, r2, #31
 80239b8:	d427      	bmi.n	8023a0a <__sflush_r+0xb2>
 80239ba:	2200      	movs	r2, #0
 80239bc:	6062      	str	r2, [r4, #4]
 80239be:	04d9      	lsls	r1, r3, #19
 80239c0:	6922      	ldr	r2, [r4, #16]
 80239c2:	6022      	str	r2, [r4, #0]
 80239c4:	d504      	bpl.n	80239d0 <__sflush_r+0x78>
 80239c6:	1c42      	adds	r2, r0, #1
 80239c8:	d101      	bne.n	80239ce <__sflush_r+0x76>
 80239ca:	682b      	ldr	r3, [r5, #0]
 80239cc:	b903      	cbnz	r3, 80239d0 <__sflush_r+0x78>
 80239ce:	6560      	str	r0, [r4, #84]	@ 0x54
 80239d0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 80239d2:	602f      	str	r7, [r5, #0]
 80239d4:	b1b9      	cbz	r1, 8023a06 <__sflush_r+0xae>
 80239d6:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 80239da:	4299      	cmp	r1, r3
 80239dc:	d002      	beq.n	80239e4 <__sflush_r+0x8c>
 80239de:	4628      	mov	r0, r5
 80239e0:	f7fe fc80 	bl	80222e4 <_free_r>
 80239e4:	2300      	movs	r3, #0
 80239e6:	6363      	str	r3, [r4, #52]	@ 0x34
 80239e8:	e00d      	b.n	8023a06 <__sflush_r+0xae>
 80239ea:	2301      	movs	r3, #1
 80239ec:	4628      	mov	r0, r5
 80239ee:	47b0      	blx	r6
 80239f0:	4602      	mov	r2, r0
 80239f2:	1c50      	adds	r0, r2, #1
 80239f4:	d1c9      	bne.n	802398a <__sflush_r+0x32>
 80239f6:	682b      	ldr	r3, [r5, #0]
 80239f8:	2b00      	cmp	r3, #0
 80239fa:	d0c6      	beq.n	802398a <__sflush_r+0x32>
 80239fc:	2b1d      	cmp	r3, #29
 80239fe:	d001      	beq.n	8023a04 <__sflush_r+0xac>
 8023a00:	2b16      	cmp	r3, #22
 8023a02:	d11e      	bne.n	8023a42 <__sflush_r+0xea>
 8023a04:	602f      	str	r7, [r5, #0]
 8023a06:	2000      	movs	r0, #0
 8023a08:	e022      	b.n	8023a50 <__sflush_r+0xf8>
 8023a0a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8023a0e:	b21b      	sxth	r3, r3
 8023a10:	e01b      	b.n	8023a4a <__sflush_r+0xf2>
 8023a12:	690f      	ldr	r7, [r1, #16]
 8023a14:	2f00      	cmp	r7, #0
 8023a16:	d0f6      	beq.n	8023a06 <__sflush_r+0xae>
 8023a18:	0793      	lsls	r3, r2, #30
 8023a1a:	680e      	ldr	r6, [r1, #0]
 8023a1c:	bf08      	it	eq
 8023a1e:	694b      	ldreq	r3, [r1, #20]
 8023a20:	600f      	str	r7, [r1, #0]
 8023a22:	bf18      	it	ne
 8023a24:	2300      	movne	r3, #0
 8023a26:	eba6 0807 	sub.w	r8, r6, r7
 8023a2a:	608b      	str	r3, [r1, #8]
 8023a2c:	f1b8 0f00 	cmp.w	r8, #0
 8023a30:	dde9      	ble.n	8023a06 <__sflush_r+0xae>
 8023a32:	6a21      	ldr	r1, [r4, #32]
 8023a34:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8023a36:	4643      	mov	r3, r8
 8023a38:	463a      	mov	r2, r7
 8023a3a:	4628      	mov	r0, r5
 8023a3c:	47b0      	blx	r6
 8023a3e:	2800      	cmp	r0, #0
 8023a40:	dc08      	bgt.n	8023a54 <__sflush_r+0xfc>
 8023a42:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023a46:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8023a4a:	81a3      	strh	r3, [r4, #12]
 8023a4c:	f04f 30ff 	mov.w	r0, #4294967295
 8023a50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023a54:	4407      	add	r7, r0
 8023a56:	eba8 0800 	sub.w	r8, r8, r0
 8023a5a:	e7e7      	b.n	8023a2c <__sflush_r+0xd4>
 8023a5c:	dfbffffe 	.word	0xdfbffffe

08023a60 <_fflush_r>:
 8023a60:	b538      	push	{r3, r4, r5, lr}
 8023a62:	690b      	ldr	r3, [r1, #16]
 8023a64:	4605      	mov	r5, r0
 8023a66:	460c      	mov	r4, r1
 8023a68:	b913      	cbnz	r3, 8023a70 <_fflush_r+0x10>
 8023a6a:	2500      	movs	r5, #0
 8023a6c:	4628      	mov	r0, r5
 8023a6e:	bd38      	pop	{r3, r4, r5, pc}
 8023a70:	b118      	cbz	r0, 8023a7a <_fflush_r+0x1a>
 8023a72:	6a03      	ldr	r3, [r0, #32]
 8023a74:	b90b      	cbnz	r3, 8023a7a <_fflush_r+0x1a>
 8023a76:	f7fe f987 	bl	8021d88 <__sinit>
 8023a7a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023a7e:	2b00      	cmp	r3, #0
 8023a80:	d0f3      	beq.n	8023a6a <_fflush_r+0xa>
 8023a82:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8023a84:	07d0      	lsls	r0, r2, #31
 8023a86:	d404      	bmi.n	8023a92 <_fflush_r+0x32>
 8023a88:	0599      	lsls	r1, r3, #22
 8023a8a:	d402      	bmi.n	8023a92 <_fflush_r+0x32>
 8023a8c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8023a8e:	f7fe fc00 	bl	8022292 <__retarget_lock_acquire_recursive>
 8023a92:	4628      	mov	r0, r5
 8023a94:	4621      	mov	r1, r4
 8023a96:	f7ff ff5f 	bl	8023958 <__sflush_r>
 8023a9a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8023a9c:	07da      	lsls	r2, r3, #31
 8023a9e:	4605      	mov	r5, r0
 8023aa0:	d4e4      	bmi.n	8023a6c <_fflush_r+0xc>
 8023aa2:	89a3      	ldrh	r3, [r4, #12]
 8023aa4:	059b      	lsls	r3, r3, #22
 8023aa6:	d4e1      	bmi.n	8023a6c <_fflush_r+0xc>
 8023aa8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8023aaa:	f7fe fbf3 	bl	8022294 <__retarget_lock_release_recursive>
 8023aae:	e7dd      	b.n	8023a6c <_fflush_r+0xc>

08023ab0 <__swhatbuf_r>:
 8023ab0:	b570      	push	{r4, r5, r6, lr}
 8023ab2:	460c      	mov	r4, r1
 8023ab4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8023ab8:	2900      	cmp	r1, #0
 8023aba:	b096      	sub	sp, #88	@ 0x58
 8023abc:	4615      	mov	r5, r2
 8023abe:	461e      	mov	r6, r3
 8023ac0:	da0d      	bge.n	8023ade <__swhatbuf_r+0x2e>
 8023ac2:	89a3      	ldrh	r3, [r4, #12]
 8023ac4:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8023ac8:	f04f 0100 	mov.w	r1, #0
 8023acc:	bf14      	ite	ne
 8023ace:	2340      	movne	r3, #64	@ 0x40
 8023ad0:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8023ad4:	2000      	movs	r0, #0
 8023ad6:	6031      	str	r1, [r6, #0]
 8023ad8:	602b      	str	r3, [r5, #0]
 8023ada:	b016      	add	sp, #88	@ 0x58
 8023adc:	bd70      	pop	{r4, r5, r6, pc}
 8023ade:	466a      	mov	r2, sp
 8023ae0:	f000 f848 	bl	8023b74 <_fstat_r>
 8023ae4:	2800      	cmp	r0, #0
 8023ae6:	dbec      	blt.n	8023ac2 <__swhatbuf_r+0x12>
 8023ae8:	9901      	ldr	r1, [sp, #4]
 8023aea:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 8023aee:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 8023af2:	4259      	negs	r1, r3
 8023af4:	4159      	adcs	r1, r3
 8023af6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8023afa:	e7eb      	b.n	8023ad4 <__swhatbuf_r+0x24>

08023afc <__smakebuf_r>:
 8023afc:	898b      	ldrh	r3, [r1, #12]
 8023afe:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8023b00:	079d      	lsls	r5, r3, #30
 8023b02:	4606      	mov	r6, r0
 8023b04:	460c      	mov	r4, r1
 8023b06:	d507      	bpl.n	8023b18 <__smakebuf_r+0x1c>
 8023b08:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 8023b0c:	6023      	str	r3, [r4, #0]
 8023b0e:	6123      	str	r3, [r4, #16]
 8023b10:	2301      	movs	r3, #1
 8023b12:	6163      	str	r3, [r4, #20]
 8023b14:	b003      	add	sp, #12
 8023b16:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8023b18:	ab01      	add	r3, sp, #4
 8023b1a:	466a      	mov	r2, sp
 8023b1c:	f7ff ffc8 	bl	8023ab0 <__swhatbuf_r>
 8023b20:	9f00      	ldr	r7, [sp, #0]
 8023b22:	4605      	mov	r5, r0
 8023b24:	4639      	mov	r1, r7
 8023b26:	4630      	mov	r0, r6
 8023b28:	f7fd f938 	bl	8020d9c <_malloc_r>
 8023b2c:	b948      	cbnz	r0, 8023b42 <__smakebuf_r+0x46>
 8023b2e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8023b32:	059a      	lsls	r2, r3, #22
 8023b34:	d4ee      	bmi.n	8023b14 <__smakebuf_r+0x18>
 8023b36:	f023 0303 	bic.w	r3, r3, #3
 8023b3a:	f043 0302 	orr.w	r3, r3, #2
 8023b3e:	81a3      	strh	r3, [r4, #12]
 8023b40:	e7e2      	b.n	8023b08 <__smakebuf_r+0xc>
 8023b42:	89a3      	ldrh	r3, [r4, #12]
 8023b44:	6020      	str	r0, [r4, #0]
 8023b46:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8023b4a:	81a3      	strh	r3, [r4, #12]
 8023b4c:	9b01      	ldr	r3, [sp, #4]
 8023b4e:	e9c4 0704 	strd	r0, r7, [r4, #16]
 8023b52:	b15b      	cbz	r3, 8023b6c <__smakebuf_r+0x70>
 8023b54:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8023b58:	4630      	mov	r0, r6
 8023b5a:	f000 f81d 	bl	8023b98 <_isatty_r>
 8023b5e:	b128      	cbz	r0, 8023b6c <__smakebuf_r+0x70>
 8023b60:	89a3      	ldrh	r3, [r4, #12]
 8023b62:	f023 0303 	bic.w	r3, r3, #3
 8023b66:	f043 0301 	orr.w	r3, r3, #1
 8023b6a:	81a3      	strh	r3, [r4, #12]
 8023b6c:	89a3      	ldrh	r3, [r4, #12]
 8023b6e:	431d      	orrs	r5, r3
 8023b70:	81a5      	strh	r5, [r4, #12]
 8023b72:	e7cf      	b.n	8023b14 <__smakebuf_r+0x18>

08023b74 <_fstat_r>:
 8023b74:	b538      	push	{r3, r4, r5, lr}
 8023b76:	4d07      	ldr	r5, [pc, #28]	@ (8023b94 <_fstat_r+0x20>)
 8023b78:	2300      	movs	r3, #0
 8023b7a:	4604      	mov	r4, r0
 8023b7c:	4608      	mov	r0, r1
 8023b7e:	4611      	mov	r1, r2
 8023b80:	602b      	str	r3, [r5, #0]
 8023b82:	f7dd fee1 	bl	8001948 <_fstat>
 8023b86:	1c43      	adds	r3, r0, #1
 8023b88:	d102      	bne.n	8023b90 <_fstat_r+0x1c>
 8023b8a:	682b      	ldr	r3, [r5, #0]
 8023b8c:	b103      	cbz	r3, 8023b90 <_fstat_r+0x1c>
 8023b8e:	6023      	str	r3, [r4, #0]
 8023b90:	bd38      	pop	{r3, r4, r5, pc}
 8023b92:	bf00      	nop
 8023b94:	20012304 	.word	0x20012304

08023b98 <_isatty_r>:
 8023b98:	b538      	push	{r3, r4, r5, lr}
 8023b9a:	4d06      	ldr	r5, [pc, #24]	@ (8023bb4 <_isatty_r+0x1c>)
 8023b9c:	2300      	movs	r3, #0
 8023b9e:	4604      	mov	r4, r0
 8023ba0:	4608      	mov	r0, r1
 8023ba2:	602b      	str	r3, [r5, #0]
 8023ba4:	f7dd fee0 	bl	8001968 <_isatty>
 8023ba8:	1c43      	adds	r3, r0, #1
 8023baa:	d102      	bne.n	8023bb2 <_isatty_r+0x1a>
 8023bac:	682b      	ldr	r3, [r5, #0]
 8023bae:	b103      	cbz	r3, 8023bb2 <_isatty_r+0x1a>
 8023bb0:	6023      	str	r3, [r4, #0]
 8023bb2:	bd38      	pop	{r3, r4, r5, pc}
 8023bb4:	20012304 	.word	0x20012304

08023bb8 <__assert_func>:
 8023bb8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8023bba:	4614      	mov	r4, r2
 8023bbc:	461a      	mov	r2, r3
 8023bbe:	4b09      	ldr	r3, [pc, #36]	@ (8023be4 <__assert_func+0x2c>)
 8023bc0:	681b      	ldr	r3, [r3, #0]
 8023bc2:	4605      	mov	r5, r0
 8023bc4:	68d8      	ldr	r0, [r3, #12]
 8023bc6:	b954      	cbnz	r4, 8023bde <__assert_func+0x26>
 8023bc8:	4b07      	ldr	r3, [pc, #28]	@ (8023be8 <__assert_func+0x30>)
 8023bca:	461c      	mov	r4, r3
 8023bcc:	e9cd 3401 	strd	r3, r4, [sp, #4]
 8023bd0:	9100      	str	r1, [sp, #0]
 8023bd2:	462b      	mov	r3, r5
 8023bd4:	4905      	ldr	r1, [pc, #20]	@ (8023bec <__assert_func+0x34>)
 8023bd6:	f000 f84f 	bl	8023c78 <fiprintf>
 8023bda:	f000 f85f 	bl	8023c9c <abort>
 8023bde:	4b04      	ldr	r3, [pc, #16]	@ (8023bf0 <__assert_func+0x38>)
 8023be0:	e7f4      	b.n	8023bcc <__assert_func+0x14>
 8023be2:	bf00      	nop
 8023be4:	2000031c 	.word	0x2000031c
 8023be8:	0803964e 	.word	0x0803964e
 8023bec:	08039620 	.word	0x08039620
 8023bf0:	08039613 	.word	0x08039613

08023bf4 <_calloc_r>:
 8023bf4:	b570      	push	{r4, r5, r6, lr}
 8023bf6:	fba1 5402 	umull	r5, r4, r1, r2
 8023bfa:	b93c      	cbnz	r4, 8023c0c <_calloc_r+0x18>
 8023bfc:	4629      	mov	r1, r5
 8023bfe:	f7fd f8cd 	bl	8020d9c <_malloc_r>
 8023c02:	4606      	mov	r6, r0
 8023c04:	b928      	cbnz	r0, 8023c12 <_calloc_r+0x1e>
 8023c06:	2600      	movs	r6, #0
 8023c08:	4630      	mov	r0, r6
 8023c0a:	bd70      	pop	{r4, r5, r6, pc}
 8023c0c:	220c      	movs	r2, #12
 8023c0e:	6002      	str	r2, [r0, #0]
 8023c10:	e7f9      	b.n	8023c06 <_calloc_r+0x12>
 8023c12:	462a      	mov	r2, r5
 8023c14:	4621      	mov	r1, r4
 8023c16:	f7fe fa75 	bl	8022104 <memset>
 8023c1a:	e7f5      	b.n	8023c08 <_calloc_r+0x14>

08023c1c <_realloc_r>:
 8023c1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8023c20:	4680      	mov	r8, r0
 8023c22:	4615      	mov	r5, r2
 8023c24:	460c      	mov	r4, r1
 8023c26:	b921      	cbnz	r1, 8023c32 <_realloc_r+0x16>
 8023c28:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8023c2c:	4611      	mov	r1, r2
 8023c2e:	f7fd b8b5 	b.w	8020d9c <_malloc_r>
 8023c32:	b92a      	cbnz	r2, 8023c40 <_realloc_r+0x24>
 8023c34:	f7fe fb56 	bl	80222e4 <_free_r>
 8023c38:	2400      	movs	r4, #0
 8023c3a:	4620      	mov	r0, r4
 8023c3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023c40:	f000 f833 	bl	8023caa <_malloc_usable_size_r>
 8023c44:	4285      	cmp	r5, r0
 8023c46:	4606      	mov	r6, r0
 8023c48:	d802      	bhi.n	8023c50 <_realloc_r+0x34>
 8023c4a:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
 8023c4e:	d8f4      	bhi.n	8023c3a <_realloc_r+0x1e>
 8023c50:	4629      	mov	r1, r5
 8023c52:	4640      	mov	r0, r8
 8023c54:	f7fd f8a2 	bl	8020d9c <_malloc_r>
 8023c58:	4607      	mov	r7, r0
 8023c5a:	2800      	cmp	r0, #0
 8023c5c:	d0ec      	beq.n	8023c38 <_realloc_r+0x1c>
 8023c5e:	42b5      	cmp	r5, r6
 8023c60:	462a      	mov	r2, r5
 8023c62:	4621      	mov	r1, r4
 8023c64:	bf28      	it	cs
 8023c66:	4632      	movcs	r2, r6
 8023c68:	f7fe fb1d 	bl	80222a6 <memcpy>
 8023c6c:	4621      	mov	r1, r4
 8023c6e:	4640      	mov	r0, r8
 8023c70:	f7fe fb38 	bl	80222e4 <_free_r>
 8023c74:	463c      	mov	r4, r7
 8023c76:	e7e0      	b.n	8023c3a <_realloc_r+0x1e>

08023c78 <fiprintf>:
 8023c78:	b40e      	push	{r1, r2, r3}
 8023c7a:	b503      	push	{r0, r1, lr}
 8023c7c:	4601      	mov	r1, r0
 8023c7e:	ab03      	add	r3, sp, #12
 8023c80:	4805      	ldr	r0, [pc, #20]	@ (8023c98 <fiprintf+0x20>)
 8023c82:	f853 2b04 	ldr.w	r2, [r3], #4
 8023c86:	6800      	ldr	r0, [r0, #0]
 8023c88:	9301      	str	r3, [sp, #4]
 8023c8a:	f000 f83f 	bl	8023d0c <_vfiprintf_r>
 8023c8e:	b002      	add	sp, #8
 8023c90:	f85d eb04 	ldr.w	lr, [sp], #4
 8023c94:	b003      	add	sp, #12
 8023c96:	4770      	bx	lr
 8023c98:	2000031c 	.word	0x2000031c

08023c9c <abort>:
 8023c9c:	b508      	push	{r3, lr}
 8023c9e:	2006      	movs	r0, #6
 8023ca0:	f000 f974 	bl	8023f8c <raise>
 8023ca4:	2001      	movs	r0, #1
 8023ca6:	f7dd fdff 	bl	80018a8 <_exit>

08023caa <_malloc_usable_size_r>:
 8023caa:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8023cae:	1f18      	subs	r0, r3, #4
 8023cb0:	2b00      	cmp	r3, #0
 8023cb2:	bfbc      	itt	lt
 8023cb4:	580b      	ldrlt	r3, [r1, r0]
 8023cb6:	18c0      	addlt	r0, r0, r3
 8023cb8:	4770      	bx	lr

08023cba <__sfputc_r>:
 8023cba:	6893      	ldr	r3, [r2, #8]
 8023cbc:	3b01      	subs	r3, #1
 8023cbe:	2b00      	cmp	r3, #0
 8023cc0:	b410      	push	{r4}
 8023cc2:	6093      	str	r3, [r2, #8]
 8023cc4:	da08      	bge.n	8023cd8 <__sfputc_r+0x1e>
 8023cc6:	6994      	ldr	r4, [r2, #24]
 8023cc8:	42a3      	cmp	r3, r4
 8023cca:	db01      	blt.n	8023cd0 <__sfputc_r+0x16>
 8023ccc:	290a      	cmp	r1, #10
 8023cce:	d103      	bne.n	8023cd8 <__sfputc_r+0x1e>
 8023cd0:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023cd4:	f7fe b968 	b.w	8021fa8 <__swbuf_r>
 8023cd8:	6813      	ldr	r3, [r2, #0]
 8023cda:	1c58      	adds	r0, r3, #1
 8023cdc:	6010      	str	r0, [r2, #0]
 8023cde:	7019      	strb	r1, [r3, #0]
 8023ce0:	4608      	mov	r0, r1
 8023ce2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8023ce6:	4770      	bx	lr

08023ce8 <__sfputs_r>:
 8023ce8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023cea:	4606      	mov	r6, r0
 8023cec:	460f      	mov	r7, r1
 8023cee:	4614      	mov	r4, r2
 8023cf0:	18d5      	adds	r5, r2, r3
 8023cf2:	42ac      	cmp	r4, r5
 8023cf4:	d101      	bne.n	8023cfa <__sfputs_r+0x12>
 8023cf6:	2000      	movs	r0, #0
 8023cf8:	e007      	b.n	8023d0a <__sfputs_r+0x22>
 8023cfa:	f814 1b01 	ldrb.w	r1, [r4], #1
 8023cfe:	463a      	mov	r2, r7
 8023d00:	4630      	mov	r0, r6
 8023d02:	f7ff ffda 	bl	8023cba <__sfputc_r>
 8023d06:	1c43      	adds	r3, r0, #1
 8023d08:	d1f3      	bne.n	8023cf2 <__sfputs_r+0xa>
 8023d0a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08023d0c <_vfiprintf_r>:
 8023d0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023d10:	460d      	mov	r5, r1
 8023d12:	b09d      	sub	sp, #116	@ 0x74
 8023d14:	4614      	mov	r4, r2
 8023d16:	4698      	mov	r8, r3
 8023d18:	4606      	mov	r6, r0
 8023d1a:	b118      	cbz	r0, 8023d24 <_vfiprintf_r+0x18>
 8023d1c:	6a03      	ldr	r3, [r0, #32]
 8023d1e:	b90b      	cbnz	r3, 8023d24 <_vfiprintf_r+0x18>
 8023d20:	f7fe f832 	bl	8021d88 <__sinit>
 8023d24:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8023d26:	07d9      	lsls	r1, r3, #31
 8023d28:	d405      	bmi.n	8023d36 <_vfiprintf_r+0x2a>
 8023d2a:	89ab      	ldrh	r3, [r5, #12]
 8023d2c:	059a      	lsls	r2, r3, #22
 8023d2e:	d402      	bmi.n	8023d36 <_vfiprintf_r+0x2a>
 8023d30:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8023d32:	f7fe faae 	bl	8022292 <__retarget_lock_acquire_recursive>
 8023d36:	89ab      	ldrh	r3, [r5, #12]
 8023d38:	071b      	lsls	r3, r3, #28
 8023d3a:	d501      	bpl.n	8023d40 <_vfiprintf_r+0x34>
 8023d3c:	692b      	ldr	r3, [r5, #16]
 8023d3e:	b99b      	cbnz	r3, 8023d68 <_vfiprintf_r+0x5c>
 8023d40:	4629      	mov	r1, r5
 8023d42:	4630      	mov	r0, r6
 8023d44:	f7fe f96e 	bl	8022024 <__swsetup_r>
 8023d48:	b170      	cbz	r0, 8023d68 <_vfiprintf_r+0x5c>
 8023d4a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8023d4c:	07dc      	lsls	r4, r3, #31
 8023d4e:	d504      	bpl.n	8023d5a <_vfiprintf_r+0x4e>
 8023d50:	f04f 30ff 	mov.w	r0, #4294967295
 8023d54:	b01d      	add	sp, #116	@ 0x74
 8023d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8023d5a:	89ab      	ldrh	r3, [r5, #12]
 8023d5c:	0598      	lsls	r0, r3, #22
 8023d5e:	d4f7      	bmi.n	8023d50 <_vfiprintf_r+0x44>
 8023d60:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8023d62:	f7fe fa97 	bl	8022294 <__retarget_lock_release_recursive>
 8023d66:	e7f3      	b.n	8023d50 <_vfiprintf_r+0x44>
 8023d68:	2300      	movs	r3, #0
 8023d6a:	9309      	str	r3, [sp, #36]	@ 0x24
 8023d6c:	2320      	movs	r3, #32
 8023d6e:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8023d72:	f8cd 800c 	str.w	r8, [sp, #12]
 8023d76:	2330      	movs	r3, #48	@ 0x30
 8023d78:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 8023f28 <_vfiprintf_r+0x21c>
 8023d7c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8023d80:	f04f 0901 	mov.w	r9, #1
 8023d84:	4623      	mov	r3, r4
 8023d86:	469a      	mov	sl, r3
 8023d88:	f813 2b01 	ldrb.w	r2, [r3], #1
 8023d8c:	b10a      	cbz	r2, 8023d92 <_vfiprintf_r+0x86>
 8023d8e:	2a25      	cmp	r2, #37	@ 0x25
 8023d90:	d1f9      	bne.n	8023d86 <_vfiprintf_r+0x7a>
 8023d92:	ebba 0b04 	subs.w	fp, sl, r4
 8023d96:	d00b      	beq.n	8023db0 <_vfiprintf_r+0xa4>
 8023d98:	465b      	mov	r3, fp
 8023d9a:	4622      	mov	r2, r4
 8023d9c:	4629      	mov	r1, r5
 8023d9e:	4630      	mov	r0, r6
 8023da0:	f7ff ffa2 	bl	8023ce8 <__sfputs_r>
 8023da4:	3001      	adds	r0, #1
 8023da6:	f000 80a7 	beq.w	8023ef8 <_vfiprintf_r+0x1ec>
 8023daa:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8023dac:	445a      	add	r2, fp
 8023dae:	9209      	str	r2, [sp, #36]	@ 0x24
 8023db0:	f89a 3000 	ldrb.w	r3, [sl]
 8023db4:	2b00      	cmp	r3, #0
 8023db6:	f000 809f 	beq.w	8023ef8 <_vfiprintf_r+0x1ec>
 8023dba:	2300      	movs	r3, #0
 8023dbc:	f04f 32ff 	mov.w	r2, #4294967295
 8023dc0:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8023dc4:	f10a 0a01 	add.w	sl, sl, #1
 8023dc8:	9304      	str	r3, [sp, #16]
 8023dca:	9307      	str	r3, [sp, #28]
 8023dcc:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8023dd0:	931a      	str	r3, [sp, #104]	@ 0x68
 8023dd2:	4654      	mov	r4, sl
 8023dd4:	2205      	movs	r2, #5
 8023dd6:	f814 1b01 	ldrb.w	r1, [r4], #1
 8023dda:	4853      	ldr	r0, [pc, #332]	@ (8023f28 <_vfiprintf_r+0x21c>)
 8023ddc:	f7dc fa70 	bl	80002c0 <memchr>
 8023de0:	9a04      	ldr	r2, [sp, #16]
 8023de2:	b9d8      	cbnz	r0, 8023e1c <_vfiprintf_r+0x110>
 8023de4:	06d1      	lsls	r1, r2, #27
 8023de6:	bf44      	itt	mi
 8023de8:	2320      	movmi	r3, #32
 8023dea:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8023dee:	0713      	lsls	r3, r2, #28
 8023df0:	bf44      	itt	mi
 8023df2:	232b      	movmi	r3, #43	@ 0x2b
 8023df4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8023df8:	f89a 3000 	ldrb.w	r3, [sl]
 8023dfc:	2b2a      	cmp	r3, #42	@ 0x2a
 8023dfe:	d015      	beq.n	8023e2c <_vfiprintf_r+0x120>
 8023e00:	9a07      	ldr	r2, [sp, #28]
 8023e02:	4654      	mov	r4, sl
 8023e04:	2000      	movs	r0, #0
 8023e06:	f04f 0c0a 	mov.w	ip, #10
 8023e0a:	4621      	mov	r1, r4
 8023e0c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8023e10:	3b30      	subs	r3, #48	@ 0x30
 8023e12:	2b09      	cmp	r3, #9
 8023e14:	d94b      	bls.n	8023eae <_vfiprintf_r+0x1a2>
 8023e16:	b1b0      	cbz	r0, 8023e46 <_vfiprintf_r+0x13a>
 8023e18:	9207      	str	r2, [sp, #28]
 8023e1a:	e014      	b.n	8023e46 <_vfiprintf_r+0x13a>
 8023e1c:	eba0 0308 	sub.w	r3, r0, r8
 8023e20:	fa09 f303 	lsl.w	r3, r9, r3
 8023e24:	4313      	orrs	r3, r2
 8023e26:	9304      	str	r3, [sp, #16]
 8023e28:	46a2      	mov	sl, r4
 8023e2a:	e7d2      	b.n	8023dd2 <_vfiprintf_r+0xc6>
 8023e2c:	9b03      	ldr	r3, [sp, #12]
 8023e2e:	1d19      	adds	r1, r3, #4
 8023e30:	681b      	ldr	r3, [r3, #0]
 8023e32:	9103      	str	r1, [sp, #12]
 8023e34:	2b00      	cmp	r3, #0
 8023e36:	bfbb      	ittet	lt
 8023e38:	425b      	neglt	r3, r3
 8023e3a:	f042 0202 	orrlt.w	r2, r2, #2
 8023e3e:	9307      	strge	r3, [sp, #28]
 8023e40:	9307      	strlt	r3, [sp, #28]
 8023e42:	bfb8      	it	lt
 8023e44:	9204      	strlt	r2, [sp, #16]
 8023e46:	7823      	ldrb	r3, [r4, #0]
 8023e48:	2b2e      	cmp	r3, #46	@ 0x2e
 8023e4a:	d10a      	bne.n	8023e62 <_vfiprintf_r+0x156>
 8023e4c:	7863      	ldrb	r3, [r4, #1]
 8023e4e:	2b2a      	cmp	r3, #42	@ 0x2a
 8023e50:	d132      	bne.n	8023eb8 <_vfiprintf_r+0x1ac>
 8023e52:	9b03      	ldr	r3, [sp, #12]
 8023e54:	1d1a      	adds	r2, r3, #4
 8023e56:	681b      	ldr	r3, [r3, #0]
 8023e58:	9203      	str	r2, [sp, #12]
 8023e5a:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8023e5e:	3402      	adds	r4, #2
 8023e60:	9305      	str	r3, [sp, #20]
 8023e62:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 8023f38 <_vfiprintf_r+0x22c>
 8023e66:	7821      	ldrb	r1, [r4, #0]
 8023e68:	2203      	movs	r2, #3
 8023e6a:	4650      	mov	r0, sl
 8023e6c:	f7dc fa28 	bl	80002c0 <memchr>
 8023e70:	b138      	cbz	r0, 8023e82 <_vfiprintf_r+0x176>
 8023e72:	9b04      	ldr	r3, [sp, #16]
 8023e74:	eba0 000a 	sub.w	r0, r0, sl
 8023e78:	2240      	movs	r2, #64	@ 0x40
 8023e7a:	4082      	lsls	r2, r0
 8023e7c:	4313      	orrs	r3, r2
 8023e7e:	3401      	adds	r4, #1
 8023e80:	9304      	str	r3, [sp, #16]
 8023e82:	f814 1b01 	ldrb.w	r1, [r4], #1
 8023e86:	4829      	ldr	r0, [pc, #164]	@ (8023f2c <_vfiprintf_r+0x220>)
 8023e88:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 8023e8c:	2206      	movs	r2, #6
 8023e8e:	f7dc fa17 	bl	80002c0 <memchr>
 8023e92:	2800      	cmp	r0, #0
 8023e94:	d03f      	beq.n	8023f16 <_vfiprintf_r+0x20a>
 8023e96:	4b26      	ldr	r3, [pc, #152]	@ (8023f30 <_vfiprintf_r+0x224>)
 8023e98:	bb1b      	cbnz	r3, 8023ee2 <_vfiprintf_r+0x1d6>
 8023e9a:	9b03      	ldr	r3, [sp, #12]
 8023e9c:	3307      	adds	r3, #7
 8023e9e:	f023 0307 	bic.w	r3, r3, #7
 8023ea2:	3308      	adds	r3, #8
 8023ea4:	9303      	str	r3, [sp, #12]
 8023ea6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8023ea8:	443b      	add	r3, r7
 8023eaa:	9309      	str	r3, [sp, #36]	@ 0x24
 8023eac:	e76a      	b.n	8023d84 <_vfiprintf_r+0x78>
 8023eae:	fb0c 3202 	mla	r2, ip, r2, r3
 8023eb2:	460c      	mov	r4, r1
 8023eb4:	2001      	movs	r0, #1
 8023eb6:	e7a8      	b.n	8023e0a <_vfiprintf_r+0xfe>
 8023eb8:	2300      	movs	r3, #0
 8023eba:	3401      	adds	r4, #1
 8023ebc:	9305      	str	r3, [sp, #20]
 8023ebe:	4619      	mov	r1, r3
 8023ec0:	f04f 0c0a 	mov.w	ip, #10
 8023ec4:	4620      	mov	r0, r4
 8023ec6:	f810 2b01 	ldrb.w	r2, [r0], #1
 8023eca:	3a30      	subs	r2, #48	@ 0x30
 8023ecc:	2a09      	cmp	r2, #9
 8023ece:	d903      	bls.n	8023ed8 <_vfiprintf_r+0x1cc>
 8023ed0:	2b00      	cmp	r3, #0
 8023ed2:	d0c6      	beq.n	8023e62 <_vfiprintf_r+0x156>
 8023ed4:	9105      	str	r1, [sp, #20]
 8023ed6:	e7c4      	b.n	8023e62 <_vfiprintf_r+0x156>
 8023ed8:	fb0c 2101 	mla	r1, ip, r1, r2
 8023edc:	4604      	mov	r4, r0
 8023ede:	2301      	movs	r3, #1
 8023ee0:	e7f0      	b.n	8023ec4 <_vfiprintf_r+0x1b8>
 8023ee2:	ab03      	add	r3, sp, #12
 8023ee4:	9300      	str	r3, [sp, #0]
 8023ee6:	462a      	mov	r2, r5
 8023ee8:	4b12      	ldr	r3, [pc, #72]	@ (8023f34 <_vfiprintf_r+0x228>)
 8023eea:	a904      	add	r1, sp, #16
 8023eec:	4630      	mov	r0, r6
 8023eee:	f3af 8000 	nop.w
 8023ef2:	4607      	mov	r7, r0
 8023ef4:	1c78      	adds	r0, r7, #1
 8023ef6:	d1d6      	bne.n	8023ea6 <_vfiprintf_r+0x19a>
 8023ef8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8023efa:	07d9      	lsls	r1, r3, #31
 8023efc:	d405      	bmi.n	8023f0a <_vfiprintf_r+0x1fe>
 8023efe:	89ab      	ldrh	r3, [r5, #12]
 8023f00:	059a      	lsls	r2, r3, #22
 8023f02:	d402      	bmi.n	8023f0a <_vfiprintf_r+0x1fe>
 8023f04:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8023f06:	f7fe f9c5 	bl	8022294 <__retarget_lock_release_recursive>
 8023f0a:	89ab      	ldrh	r3, [r5, #12]
 8023f0c:	065b      	lsls	r3, r3, #25
 8023f0e:	f53f af1f 	bmi.w	8023d50 <_vfiprintf_r+0x44>
 8023f12:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8023f14:	e71e      	b.n	8023d54 <_vfiprintf_r+0x48>
 8023f16:	ab03      	add	r3, sp, #12
 8023f18:	9300      	str	r3, [sp, #0]
 8023f1a:	462a      	mov	r2, r5
 8023f1c:	4b05      	ldr	r3, [pc, #20]	@ (8023f34 <_vfiprintf_r+0x228>)
 8023f1e:	a904      	add	r1, sp, #16
 8023f20:	4630      	mov	r0, r6
 8023f22:	f7ff fbf9 	bl	8023718 <_printf_i>
 8023f26:	e7e4      	b.n	8023ef2 <_vfiprintf_r+0x1e6>
 8023f28:	080395e0 	.word	0x080395e0
 8023f2c:	080395ea 	.word	0x080395ea
 8023f30:	00000000 	.word	0x00000000
 8023f34:	08023ce9 	.word	0x08023ce9
 8023f38:	080395e6 	.word	0x080395e6

08023f3c <_raise_r>:
 8023f3c:	291f      	cmp	r1, #31
 8023f3e:	b538      	push	{r3, r4, r5, lr}
 8023f40:	4605      	mov	r5, r0
 8023f42:	460c      	mov	r4, r1
 8023f44:	d904      	bls.n	8023f50 <_raise_r+0x14>
 8023f46:	2316      	movs	r3, #22
 8023f48:	6003      	str	r3, [r0, #0]
 8023f4a:	f04f 30ff 	mov.w	r0, #4294967295
 8023f4e:	bd38      	pop	{r3, r4, r5, pc}
 8023f50:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 8023f52:	b112      	cbz	r2, 8023f5a <_raise_r+0x1e>
 8023f54:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8023f58:	b94b      	cbnz	r3, 8023f6e <_raise_r+0x32>
 8023f5a:	4628      	mov	r0, r5
 8023f5c:	f000 f830 	bl	8023fc0 <_getpid_r>
 8023f60:	4622      	mov	r2, r4
 8023f62:	4601      	mov	r1, r0
 8023f64:	4628      	mov	r0, r5
 8023f66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8023f6a:	f000 b817 	b.w	8023f9c <_kill_r>
 8023f6e:	2b01      	cmp	r3, #1
 8023f70:	d00a      	beq.n	8023f88 <_raise_r+0x4c>
 8023f72:	1c59      	adds	r1, r3, #1
 8023f74:	d103      	bne.n	8023f7e <_raise_r+0x42>
 8023f76:	2316      	movs	r3, #22
 8023f78:	6003      	str	r3, [r0, #0]
 8023f7a:	2001      	movs	r0, #1
 8023f7c:	e7e7      	b.n	8023f4e <_raise_r+0x12>
 8023f7e:	2100      	movs	r1, #0
 8023f80:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 8023f84:	4620      	mov	r0, r4
 8023f86:	4798      	blx	r3
 8023f88:	2000      	movs	r0, #0
 8023f8a:	e7e0      	b.n	8023f4e <_raise_r+0x12>

08023f8c <raise>:
 8023f8c:	4b02      	ldr	r3, [pc, #8]	@ (8023f98 <raise+0xc>)
 8023f8e:	4601      	mov	r1, r0
 8023f90:	6818      	ldr	r0, [r3, #0]
 8023f92:	f7ff bfd3 	b.w	8023f3c <_raise_r>
 8023f96:	bf00      	nop
 8023f98:	2000031c 	.word	0x2000031c

08023f9c <_kill_r>:
 8023f9c:	b538      	push	{r3, r4, r5, lr}
 8023f9e:	4d07      	ldr	r5, [pc, #28]	@ (8023fbc <_kill_r+0x20>)
 8023fa0:	2300      	movs	r3, #0
 8023fa2:	4604      	mov	r4, r0
 8023fa4:	4608      	mov	r0, r1
 8023fa6:	4611      	mov	r1, r2
 8023fa8:	602b      	str	r3, [r5, #0]
 8023faa:	f7dd fc6d 	bl	8001888 <_kill>
 8023fae:	1c43      	adds	r3, r0, #1
 8023fb0:	d102      	bne.n	8023fb8 <_kill_r+0x1c>
 8023fb2:	682b      	ldr	r3, [r5, #0]
 8023fb4:	b103      	cbz	r3, 8023fb8 <_kill_r+0x1c>
 8023fb6:	6023      	str	r3, [r4, #0]
 8023fb8:	bd38      	pop	{r3, r4, r5, pc}
 8023fba:	bf00      	nop
 8023fbc:	20012304 	.word	0x20012304

08023fc0 <_getpid_r>:
 8023fc0:	f7dd bc5a 	b.w	8001878 <_getpid>

08023fc4 <_init>:
 8023fc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023fc6:	bf00      	nop
 8023fc8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8023fca:	bc08      	pop	{r3}
 8023fcc:	469e      	mov	lr, r3
 8023fce:	4770      	bx	lr

08023fd0 <_fini>:
 8023fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8023fd2:	bf00      	nop
 8023fd4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8023fd6:	bc08      	pop	{r3}
 8023fd8:	469e      	mov	lr, r3
 8023fda:	4770      	bx	lr
